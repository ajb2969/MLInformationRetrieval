<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="828">Normal operator</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Normal operator</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, especially <a href="functional_analysis" title="wikilink">functional analysis</a>, a <strong>normal operator</strong> on a complex <a href="Hilbert_space" title="wikilink">Hilbert space</a> <em>H</em> is a <a href="continuous_function_(topology)" title="wikilink">continuous</a> <a href="linear_operator" title="wikilink">linear operator</a> <em>N</em> : <em>H</em> → <em>H</em> that <a href="commutator" title="wikilink">commutes</a> with its <a href="hermitian_adjoint" title="wikilink">hermitian adjoint</a> <em>N*</em>, that is: <em>NN*</em> = <em>N*N</em>. <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Normal operators are important because the <a href="spectral_theorem" title="wikilink">spectral theorem</a> holds for them. The class of normal operators is well-understood. Examples of normal operators are</p>
<ul>
<li><a href="unitary_operator" title="wikilink">unitary operators</a>: <em>N*</em> = ''N<sup>−1</sup></li>
<li><a href="Hermitian_operator" title="wikilink">Hermitian operators</a> (i.e., self-adjoint operators): <em>N*</em> = <em>N</em></li>
<li><a class="uri" href="Skew-Hermitian" title="wikilink">Skew-Hermitian</a> operators: <em>N*</em> = −<em>N</em></li>
<li><a href="positive_operator" title="wikilink">positive operators</a>: <em>N</em> = <em>MM*</em> for some <em>M</em> (so <em>N</em> is self-adjoint).</li>
</ul>

<p>A <a href="normal_matrix" title="wikilink">normal matrix</a> is the matrix expression of a normal operator on the Hilbert space <strong>C</strong><sup><em>n</em></sup>.</p>
<h2 id="properties">Properties</h2>

<p>Normal operators are characterized by the <a href="spectral_theorem" title="wikilink">spectral theorem</a>. A <a href="Compact_operator_on_Hilbert_space" title="wikilink">compact normal operator</a> (in particular, a normal operator on a finite-dimensional linear space) is unitarily diagonalizable.</p>

<p>Let <em>T</em> be a bounded operator. The following are equivalent.</p>
<ul>
<li><em>T</em> is normal.</li>
<li><em>T*</em> is normal.</li>
<li>||<em>Tx</em>|| = ||<em>T*x</em>|| for all <em>x</em> (use 

<math display="inline" id="Normal_operator:0">
<semantics>
<mrow>
<msup>
<mrow>
<mo>∥</mo>
<mrow>
<mi>T</mi>
<mi>x</mi>
</mrow>
<mo>∥</mo>
</mrow>
<mn>2</mn>
</msup>
<mo>=</mo>
<mrow>
<mo stretchy="false">⟨</mo>
<mrow>
<msup>
<mi>T</mi>
<mo>*</mo>
</msup>
<mi>T</mi>
<mi>x</mi>
</mrow>
<mo>,</mo>
<mi>x</mi>
<mo stretchy="false">⟩</mo>
</mrow>
<mo>=</mo>
<mrow>
<mo stretchy="false">⟨</mo>
<mrow>
<mi>T</mi>
<msup>
<mi>T</mi>
<mo>*</mo>
</msup>
<mi>x</mi>
</mrow>
<mo>,</mo>
<mi>x</mi>
<mo stretchy="false">⟩</mo>
</mrow>
<mo>=</mo>
<msup>
<mrow>
<mo>∥</mo>
<mrow>
<msup>
<mi>T</mi>
<mo>*</mo>
</msup>
<mi>x</mi>
</mrow>
<mo>∥</mo>
</mrow>
<mn>2</mn>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="latexml">norm</csymbol>
<apply>
<times></times>
<ci>T</ci>
<ci>x</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
<list>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>T</ci>
<times></times>
</apply>
<ci>T</ci>
<ci>x</ci>
</apply>
<ci>x</ci>
</list>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<list>
<apply>
<times></times>
<ci>T</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>T</ci>
<times></times>
</apply>
<ci>x</ci>
</apply>
<ci>x</ci>
</list>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="latexml">norm</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>T</ci>
<times></times>
</apply>
<ci>x</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \|Tx\|^{2}=\langle T^{*}Tx,x\rangle=\langle TT^{*}x,x\rangle=\|T^{*}x\|^{2}
  </annotation>
</semantics>
</math>

).</li>
<li>The selfadjoint and anti-selfadjoint parts of <em>T</em> commute. That is, if we write 

<math display="inline" id="Normal_operator:1">
<semantics>
<mrow>
<mi>T</mi>
<mo>≡</mo>
<mrow>
<msub>
<mi>T</mi>
<mn>1</mn>
</msub>
<mo>+</mo>
<mrow>
<mi>i</mi>
<msub>
<mi>T</mi>
<mn>2</mn>
</msub>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<equivalent></equivalent>
<ci>T</ci>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>T</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<times></times>
<ci>i</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>T</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   T\equiv T_{1}+iT_{2}
  </annotation>
</semantics>
</math>

 with 

<math display="inline" id="Normal_operator:2">
<semantics>
<mrow>
<msub>
<mi>T</mi>
<mn>1</mn>
</msub>
<mo>:=</mo>
<mfrac>
<mrow>
<mi>T</mi>
<mo>+</mo>
<msup>
<mi>T</mi>
<mo>*</mo>
</msup>
</mrow>
<mn>2</mn>
</mfrac>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">assign</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>T</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<divide></divide>
<apply>
<plus></plus>
<ci>T</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>T</ci>
<times></times>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   T_{1}:=\frac{T+T^{*}}{2}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Normal_operator:3">
<semantics>
<mrow>
<mrow>
<mrow>
<mpadded width="+1.7pt">
<mi>i</mi>
</mpadded>
<msub>
<mi>T</mi>
<mn>2</mn>
</msub>
</mrow>
<mo>:=</mo>
<mfrac>
<mrow>
<mi>T</mi>
<mo>-</mo>
<msup>
<mi>T</mi>
<mo>*</mo>
</msup>
</mrow>
<mn>2</mn>
</mfrac>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">assign</csymbol>
<apply>
<times></times>
<ci>i</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>T</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<divide></divide>
<apply>
<minus></minus>
<ci>T</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>T</ci>
<times></times>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   i\,T_{2}:=\frac{T-T^{*}}{2},
  </annotation>
</semantics>
</math>

, then 

<math display="inline" id="Normal_operator:4">
<semantics>
<mrow>
<mrow>
<msub>
<mi>T</mi>
<mn>1</mn>
</msub>
<msub>
<mi>T</mi>
<mn>2</mn>
</msub>
</mrow>
<mo>=</mo>
<mrow>
<msub>
<mi>T</mi>
<mn>2</mn>
</msub>
<msub>
<mi>T</mi>
<mn>1</mn>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>T</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>T</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>T</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>T</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   T_{1}T_{2}=T_{2}T_{1}
  </annotation>
</semantics>
</math>

.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></li>
</ul>

<p>If <em>N</em> is a normal operator, then <em>N</em> and <em>N*</em> have the same kernel and range. Consequently, the range of <em>N</em> is dense if and only if <em>N</em> is injective. Put in another way, the kernel of a normal operator is the orthogonal complement of its range. It follows that the kernel of the operator <em>N<sup>k</sup></em> coincides with that of <em>N</em> for any <em>k</em>. Every generalized eigenvalue of a normal operator is thus genuine. λ is an eigenvalue of a normal operator <em>N</em> if and only if its complex conjugate 

<math display="inline" id="Normal_operator:5">
<semantics>
<mover accent="true">
<mi>λ</mi>
<mo>¯</mo>
</mover>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-¯</ci>
<ci>λ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \overline{\lambda}
  </annotation>
</semantics>
</math>

 is an eigenvalue of <em>N*</em>. Eigenvectors of a normal operator corresponding to different eigenvalues are orthogonal, and a normal operator stabilizes the orthogonal complement of each of its eigenspaces.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> This implies the usual spectral theorem: every normal operator on a finite-dimensional space is diagonalizable by a unitary operator. There is also an infinite-dimensional version of the spectral theorem expressed in terms of <a href="projection-valued_measure" title="wikilink">projection-valued measures</a>. The residual spectrum of a normal operator is empty.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>The product of normal operators that commute is again normal; this is nontrivial, but follows directly from <a href="Fuglede's_theorem" title="wikilink">Fuglede's theorem</a>, which states (in a form generalized by Putnam):</p>
<dl>
<dd>If 

<math display="inline" id="Normal_operator:6">
<semantics>
<msub>
<mi>N</mi>
<mn>1</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>N</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   N_{1}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Normal_operator:7">
<semantics>
<msub>
<mi>N</mi>
<mn>2</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>N</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   N_{2}
  </annotation>
</semantics>
</math>

 are normal operators and if <em>A</em> is a bounded linear operator such that 

<math display="inline" id="Normal_operator:8">
<semantics>
<mrow>
<mrow>
<msub>
<mi>N</mi>
<mn>1</mn>
</msub>
<mi>A</mi>
</mrow>
<mo>=</mo>
<mrow>
<mi>A</mi>
<msub>
<mi>N</mi>
<mn>2</mn>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>N</ci>
<cn type="integer">1</cn>
</apply>
<ci>A</ci>
</apply>
<apply>
<times></times>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>N</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   N_{1}A=AN_{2}
  </annotation>
</semantics>
</math>

, then 

<math display="inline" id="Normal_operator:9">
<semantics>
<mrow>
<mrow>
<msubsup>
<mi>N</mi>
<mn>1</mn>
<mo>*</mo>
</msubsup>
<mi>A</mi>
</mrow>
<mo>=</mo>
<mrow>
<mi>A</mi>
<msubsup>
<mi>N</mi>
<mn>2</mn>
<mo>*</mo>
</msubsup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>N</ci>
<cn type="integer">1</cn>
</apply>
<times></times>
</apply>
<ci>A</ci>
</apply>
<apply>
<times></times>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>N</ci>
<cn type="integer">2</cn>
</apply>
<times></times>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   N_{1}^{*}A=AN_{2}^{*}
  </annotation>
</semantics>
</math>

.
</dd>
</dl>

<p>The operator norm of a normal operator equals its <a href="numerical_radius" title="wikilink">numerical radius</a> and <a href="spectral_radius" title="wikilink">spectral radius</a>.</p>

<p>A normal operator coincides with its <a href="Aluthge_transform" title="wikilink">Aluthge transform</a>.</p>
<h2 id="properties-in-finite-dimensional-case">Properties in finite-dimensional case</h2>

<p>If a normal operator <em>T</em> on a <em>finite-dimensional</em> real or complex Hilbert space (inner product space) <em>H</em> stabilizes a subspace <em>V</em>, then it also stabilizes its orthogonal complement <em>V</em><sup>⊥</sup>. (This statement is trivial in the case where <em>T</em> is self-adjoint.)</p>

<p><em>Proof.</em> Let <em>P<sub>V</sub></em> be the orthogonal projection onto <em>V</em>. Then the orthogonal projection onto <em>V</em><sup>⊥</sup> is <strong>1</strong><sub><em>H</em></sub>−<em>P<sub>V</sub></em>. The fact that <em>T</em> stabilizes <em>V</em> can be expressed as (<strong>1</strong><sub><em>H</em></sub>−<em>P<sub>V</sub></em>)<em>TP<sub>V</sub></em> = 0, or <em>TP<sub>V</sub></em> = <em>P<sub>V</sub>TP<sub>V</sub></em>. The goal is to show that <em>X</em> := <em>P<sub>V</sub>T</em>(<strong>1</strong><sub><em>H</em></sub>−<em>P<sub>V</sub></em>) = 0. Since (<em>A</em>, <em>B</em>) ↦ tr(<em>AB*</em>) is an <a href="inner_product" title="wikilink">inner product</a> on the space of endomorphisms of <em>H</em>, it is enough to show that tr(<em>XX*</em>) = 0. But first we express <em>XX*</em> in terms of orthogonal projections:</p>

<p>
<math display="block" id="Normal_operator:10">
<semantics>
<mrow>
<mrow>
<mi>X</mi>
<msup>
<mi>X</mi>
<mo>*</mo>
</msup>
</mrow>
<mo>=</mo>
<mrow>
<msub>
<mi>P</mi>
<mi>V</mi>
</msub>
<mi>T</mi>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mn>𝟏</mn>
<mi>H</mi>
</msub>
<mo>-</mo>
<msub>
<mi>P</mi>
<mi>V</mi>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</msup>
<msup>
<mi>T</mi>
<mo>*</mo>
</msup>
<msub>
<mi>P</mi>
<mi>V</mi>
</msub>
</mrow>
<mo>=</mo>
<mrow>
<msub>
<mi>P</mi>
<mi>V</mi>
</msub>
<mi>T</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mn>𝟏</mn>
<mi>H</mi>
</msub>
<mo>-</mo>
<msub>
<mi>P</mi>
<mi>V</mi>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<msup>
<mi>T</mi>
<mo>*</mo>
</msup>
<msub>
<mi>P</mi>
<mi>V</mi>
</msub>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<msub>
<mi>P</mi>
<mi>V</mi>
</msub>
<mi>T</mi>
<msup>
<mi>T</mi>
<mo>*</mo>
</msup>
<msub>
<mi>P</mi>
<mi>V</mi>
</msub>
</mrow>
<mo>-</mo>
<mrow>
<msub>
<mi>P</mi>
<mi>V</mi>
</msub>
<mi>T</mi>
<msub>
<mi>P</mi>
<mi>V</mi>
</msub>
<msup>
<mi>T</mi>
<mo>*</mo>
</msup>
<msub>
<mi>P</mi>
<mi>V</mi>
</msub>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<ci>X</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>X</ci>
<times></times>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<ci>V</ci>
</apply>
<ci>T</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<cn type="integer">1</cn>
<ci>H</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<ci>V</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>T</ci>
<times></times>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<ci>V</ci>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<ci>V</ci>
</apply>
<ci>T</ci>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<cn type="integer">1</cn>
<ci>H</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<ci>V</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>T</ci>
<times></times>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<ci>V</ci>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<ci>V</ci>
</apply>
<ci>T</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>T</ci>
<times></times>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<ci>V</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<ci>V</ci>
</apply>
<ci>T</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<ci>V</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>T</ci>
<times></times>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<ci>V</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   XX^{*}=P_{V}T(\boldsymbol{1}_{H}-P_{V})^{2}T^{*}P_{V}=P_{V}T(\boldsymbol{1}_{H%
}-P_{V})T^{*}P_{V}=P_{V}TT^{*}P_{V}-P_{V}TP_{V}T^{*}P_{V}
  </annotation>
</semantics>
</math>

,</p>

<p>Now using properties of the <a href="Trace_(linear_algebra)" title="wikilink">trace</a> and of orthogonal projections we have:</p>

<p>
<math display="inline" id="Normal_operator:11">
<semantics>
<mrow>
<mo>tr</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>X</mi>
<msup>
<mi>X</mi>
<mo>*</mo>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>tr</ci>
<apply>
<times></times>
<ci>X</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>X</ci>
<times></times>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \displaystyle\operatorname{tr}(XX^{*})
  </annotation>
</semantics>
</math>
</p>

<p>The same argument goes through for compact normal operators in infinite dimensional Hilbert spaces, where one make use of the <a class="uri" href="Hilbert-Schmidt" title="wikilink">Hilbert-Schmidt</a> inner product, defined by tr(<em>AB*</em>) suitably interpreted.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> However, for bounded normal operators orthogonal complement to a stable subspace may not be stable.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> It follows that the Hilbert space cannot be spanned by eigenvectors of such an operator. Consider, for example, the <a href="bilateral_shift" title="wikilink">bilateral shift</a> (or two-sided shift) acting on 

<math display="inline" id="Normal_operator:12">
<semantics>
<msup>
<mi mathvariant="normal">ℓ</mi>
<mn>2</mn>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>normal-ℓ</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ell^{2}
  </annotation>
</semantics>
</math>

, which is normal, but has no eigenvalues.</p>

<p>The invariant subspaces of a shift acting on Hardy space are characterized by <a href="Beurling's_theorem" title="wikilink">Beurling's theorem</a>.</p>
<h2 id="normal-elements-of-algebras">Normal elements of algebras</h2>

<p>The notion of normal operators generalizes to an involutive algebra:</p>

<p>An element <em>x</em> of an involutive algebra is said to be normal if <em>xx*</em> = <em>x*x</em>.</p>

<p>Selfadjoint and unitary elements are normal.</p>

<p>The most important case is when such an algebra is a <a class="uri" href="C*-algebra" title="wikilink">C*-algebra</a>.</p>
<h2 id="unbounded-normal-operators">Unbounded normal operators</h2>

<p>The definition of normal operators naturally generalizes to some class of unbounded operators. Explicitly, a closed operator <em>N</em> is said to be normal if we can write</p>

<p>
<math display="block" id="Normal_operator:13">
<semantics>
<mrow>
<mrow>
<mrow>
<msup>
<mi>N</mi>
<mo>*</mo>
</msup>
<mi>N</mi>
</mrow>
<mo>=</mo>
<mrow>
<mi>N</mi>
<msup>
<mi>N</mi>
<mo>*</mo>
</msup>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>N</ci>
<times></times>
</apply>
<ci>N</ci>
</apply>
<apply>
<times></times>
<ci>N</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>N</ci>
<times></times>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   N^{*}N=NN^{*}.
  </annotation>
</semantics>
</math>

 Here, the existence of the adjoint <em>N*</em> requires that the domain of <em>N</em> be dense, and the equality includes the assertion that the domain of <em>N*N</em> equals that of <em>NN*</em>, which is not necessarily the case in general.</p>

<p>Equivalently normal operators are precisely those for which<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>
<math display="block" id="Normal_operator:14">
<semantics>
<mrow>
<mrow>
<mrow>
<mo>∥</mo>
<mrow>
<mi>N</mi>
<mi>x</mi>
</mrow>
<mo>∥</mo>
</mrow>
<mo>=</mo>
<mrow>
<mo>∥</mo>
<mrow>
<msup>
<mi>N</mi>
<mo>*</mo>
</msup>
<mi>x</mi>
</mrow>
<mo>∥</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="latexml">norm</csymbol>
<apply>
<times></times>
<ci>N</ci>
<ci>x</ci>
</apply>
</apply>
<apply>
<csymbol cd="latexml">norm</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>N</ci>
<times></times>
</apply>
<ci>x</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \|Nx\|=\|N^{*}x\|\qquad
  </annotation>
</semantics>
</math>

 with</p>

<p>
<math display="block" id="Normal_operator:15">
<semantics>
<mrow>
<mrow>
<mrow>
<mpadded lspace="20pt" width="+20pt">
<mi class="ltx_font_mathcaligraphic">𝒟</mi>
</mpadded>
<mrow>
<mo stretchy="false">(</mo>
<mi>N</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi class="ltx_font_mathcaligraphic">𝒟</mi>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>N</mi>
<mo>*</mo>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>𝒟</ci>
<ci>N</ci>
</apply>
<apply>
<times></times>
<ci>𝒟</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>N</ci>
<times></times>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \qquad\mathcal{D}(N)=\mathcal{D}(N^{*}).
  </annotation>
</semantics>
</math>

 The spectral theorem still holds for unbounded (normal) operators. The proofs work by reduction to bounded (normal) operators.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="generalization">Generalization</h2>

<p>The success of the theory of normal operators led to several attempts for generalization by weakening the commutativity requirement. Classes of operators that include normal operators are (in order of inclusion)</p>
<ul>
<li><a href="Quasinormal_operator" title="wikilink">Quasinormal operators</a></li>
<li><a href="Subnormal_operator" title="wikilink">Subnormal operators</a></li>
<li><a href="Hyponormal_operator" title="wikilink">Hyponormal operators</a></li>
<li><a href="Paranormal_operator" title="wikilink">Paranormal operators</a></li>
<li><a href="Normaloid" title="wikilink">Normaloids</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Operator_theory" title="wikilink">Category:Operator theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">In contrast, for the important class of <a href="Creation_and_annihilation_operators" title="wikilink">Creation and annihilation operators</a> of, e.g., <a href="quantum_field_theory" title="wikilink">quantum field theory</a>, they don't commute<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7">Weidmann, Lineare Operatoren in Hilberträumen, Chapter 4, Section 3<a href="#fnref7">↩</a></li>
<li id="fn8">Alexander Frei, Spectral Measures, Mathematics Stackexchange, <a href="http://math.stackexchange.com/q/1332154/79762">Existence</a>,<a href="http://math.stackexchange.com/q/1112508/79762">Uniqueness</a><a href="#fnref8">↩</a></li>
<li id="fn9">John B. Conway, A Course in Functional Analysis, Second Edition, Chapter X, Section §4<a href="#fnref9">↩</a></li>
</ol>
</section>
</body>
</html>
