<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1845">Compressed sensing in speech signals</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Compressed sensing in speech signals</h1>
<hr/>

<p><a href="Compressed_Sensing" title="wikilink">Compressed Sensing</a> (CS) can be used to reconstruct sparse vector from less number of measurements, provided the signal can be represented in sparse domain. Sparse domain is a domain in which only a few measurements have non-zero values. Suppose a signal 

<math display="inline" id="Compressed_sensing_in_speech_signals:0">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <mi>R</mi>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x\in R^{N}}
  </annotation>
 </semantics>
</math>

 can be represented in a domain where only 

<math display="inline" id="Compressed_sensing_in_speech_signals:1">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\it M}
  </annotation>
 </semantics>
</math>

 coefficients out of 

<math display="inline" id="Compressed_sensing_in_speech_signals:2">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\it N}
  </annotation>
 </semantics>
</math>

 (where 

<math display="inline" id="Compressed_sensing_in_speech_signals:3">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>≪</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">much-less-than</csymbol>
    <ci>M</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {M\ll N}
  </annotation>
 </semantics>
</math>

) are non zero, then the signal is said to be sparse in that domain. This reconstructed sparse vector can be used to construct back the original signal if the sparse domain of signal is known. CS can be applied to speech signal only if sparse domain of speech signal is known.</p>

<p>Consider a speech signal 

<math display="inline" id="Compressed_sensing_in_speech_signals:4">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x}
  </annotation>
 </semantics>
</math>

, which can be represented in a domain 

<math display="inline" id="Compressed_sensing_in_speech_signals:5">
 <semantics>
  <mi mathvariant="normal">Ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\Psi}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Compressed_sensing_in_speech_signals:6">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Ψ</mi>
    <mi>𝜶</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <times></times>
     <ci>normal-Ψ</ci>
     <ci>𝜶</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x}={\Psi\boldsymbol{\alpha}}
  </annotation>
 </semantics>
</math>

, where speech signal 

<math display="inline" id="Compressed_sensing_in_speech_signals:7">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <mi>R</mi>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x\in R^{\it N}}
  </annotation>
 </semantics>
</math>

, dictionary matrix 

<math display="inline" id="Compressed_sensing_in_speech_signals:8">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ψ</mi>
   <mo>∈</mo>
   <msup>
    <mi>R</mi>
    <mrow>
     <mi>N</mi>
     <mo>×</mo>
     <mi>N</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>normal-Ψ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <apply>
      <times></times>
      <ci>N</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\Psi\in R^{\it{N\times N}}}
  </annotation>
 </semantics>
</math>

 and the sparse coefficient vector 

<math display="inline" id="Compressed_sensing_in_speech_signals:9">
 <semantics>
  <mrow>
   <mi>𝜶</mi>
   <mo>∈</mo>
   <msup>
    <mi>R</mi>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>𝜶</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\boldsymbol{\alpha}\in R^{\it N}}
  </annotation>
 </semantics>
</math>

. This speech signal is said to be sparse in domain 

<math display="inline" id="Compressed_sensing_in_speech_signals:10">
 <semantics>
  <mi mathvariant="normal">Ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\Psi}
  </annotation>
 </semantics>
</math>

, if number of significant (non zero) coefficients in sparse vector 

<math display="inline" id="Compressed_sensing_in_speech_signals:11">
 <semantics>
  <mi>𝜶</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝜶</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\boldsymbol{\alpha}}
  </annotation>
 </semantics>
</math>

 are 

<math display="inline" id="Compressed_sensing_in_speech_signals:12">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\it{K}}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Compressed_sensing_in_speech_signals:13">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>≪</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">much-less-than</csymbol>
    <ci>K</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\it{K\ll N}}
  </annotation>
 </semantics>
</math>

.</p>

<p>The observed signal 

<math display="inline" id="Compressed_sensing_in_speech_signals:14">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x}
  </annotation>
 </semantics>
</math>

 is of dimension 

<math display="inline" id="Compressed_sensing_in_speech_signals:15">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>×</mo>
   <mn mathvariant="italic">1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\it{N\times 1}}
  </annotation>
 </semantics>
</math>

. To reduce the complexity for solving 

<math display="inline" id="Compressed_sensing_in_speech_signals:16">
 <semantics>
  <mi>𝜶</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝜶</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\boldsymbol{\alpha}}
  </annotation>
 </semantics>
</math>

 using CS speech signal is observed using a measurement matrix 

<math display="inline" id="Compressed_sensing_in_speech_signals:17">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\Phi}
  </annotation>
 </semantics>
</math>

 such that</p>

<p>where 

<math display="inline" id="Compressed_sensing_in_speech_signals:18">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>∈</mo>
   <msup>
    <mi>R</mi>
    <mi>M</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {y\in R^{\it M}}
  </annotation>
 </semantics>
</math>

, and measurement matrix 

<math display="inline" id="Compressed_sensing_in_speech_signals:19">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mo>∈</mo>
   <msup>
    <mi>R</mi>
    <mrow>
     <mi>M</mi>
     <mo>×</mo>
     <mi>N</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>normal-Φ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\Phi\in R^{\it M\times N}}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Compressed_sensing_in_speech_signals:20">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>≪</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">much-less-than</csymbol>
    <ci>M</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\it{M\ll N}}
  </annotation>
 </semantics>
</math>

.</p>

<p>Sparse decomposition problem for eq. 1 can be solved as standard 

<math display="inline" id="Compressed_sensing_in_speech_signals:21">
 <semantics>
  <msub>
   <mi>l</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>l</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {l_{1}}
  </annotation>
 </semantics>
</math>

 minimization<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> as</p>

<p>}=\mbox{minimize}\;\Vert \mathbf{\boldsymbol\alpha} \Vert_1 \;\;\;\;\mbox{s.t.}\;\;\;\; \mathbf{y}=\mathbf{\Phi x}=\mathbf{\Phi \Psi} \mathbf{\boldsymbol\alpha} = \mathbf{A \boldsymbol\alpha}, \;\mbox{where} \;\;\mathbf{A}=\mathbf{\Phi \Psi}}|<mtpl><eqref>2<eqref></eqref></eqref></mtpl>}}</p>

<p>If measurement matrix 

<math display="inline" id="Compressed_sensing_in_speech_signals:22">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\Phi}
  </annotation>
 </semantics>
</math>

 satisfies the restricted isometric property (RIP) and is incoherent with dictionary matrix 

<math display="inline" id="Compressed_sensing_in_speech_signals:23">
 <semantics>
  <mi mathvariant="normal">Ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\Psi}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> then the reconstructed signal is much closer to the original speech signal.</p>

<p>Different types of measurement matrices like random matrices can be used for speech signals.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Estimating the sparsity of speech signal is a problem since speech signal highly varies over time and thus sparsity of speech signal also varies highly over time. If sparsity of speech signal can be calculated over time without much complexity that will be best. If this is not possible then worst-case scenario for sparsity can be considered for a given speech signal.</p>

<p>Sparse vector (

<math display="inline" id="Compressed_sensing_in_speech_signals:24">
 <semantics>
  <mover accent="true">
   <mi>𝜶</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>𝜶</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\hat{\boldsymbol{\alpha}}}
  </annotation>
 </semantics>
</math>

) for a given speech signals is reconstructed from less number of measurements (

<math display="inline" id="Compressed_sensing_in_speech_signals:25">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {y}
  </annotation>
 </semantics>
</math>

) using 

<math display="inline" id="Compressed_sensing_in_speech_signals:26">
 <semantics>
  <msub>
   <mi>l</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>l</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {l_{1}}
  </annotation>
 </semantics>
</math>

 minimization.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Then original speech signal is reconstructed form the calculated sparse vector 

<math display="inline" id="Compressed_sensing_in_speech_signals:27">
 <semantics>
  <mover accent="true">
   <mi>𝜶</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>𝜶</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\hat{\boldsymbol{\alpha}}}
  </annotation>
 </semantics>
</math>

 using the fixed dictionary matrix as 

<math display="inline" id="Compressed_sensing_in_speech_signals:28">
 <semantics>
  <mi mathvariant="normal">Ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\Psi}
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Compressed_sensing_in_speech_signals:29">
 <semantics>
  <mover accent="true">
   <mi>x</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\hat{x}}
  </annotation>
 </semantics>
</math>

 = 

<math display="inline" id="Compressed_sensing_in_speech_signals:30">
 <semantics>
  <mi mathvariant="normal">Ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\Psi}
  </annotation>
 </semantics>
</math>



<math display="inline" id="Compressed_sensing_in_speech_signals:31">
 <semantics>
  <mover accent="true">
   <mi>𝜶</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>𝜶</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\hat{\boldsymbol{\alpha}}}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Estimation of both the dictionary matrix and sparse vector from just random measurements only has been done iteratively in.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> The speech signal reconstructed from estimated sparse vector and dictionary matrix is much closer to the original signal. Some more iterative approaches to calculate both dictionary matrix and speech signal from just random measurements of speech signal are shown in.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Th application of structured sparsity for joint speech localization-separation in reverberant acoustics has been investigated for multiparty speech recognition.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Further applications of the concept of sparsity are yet to be studied in the field of speech processing. The idea behind CS for speech signals is that can we come up with some algorithms or methods where we only use those random measurements (

<math display="inline" id="Compressed_sensing_in_speech_signals:32">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {y})
  </annotation>
 </semantics>
</math>

) to do some application-based processing like speaker recognition, speech enhancement,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> etc.</p>
<h2 id="references">References</h2>

<p>'</p>

<p><a href="Category:Speech_processing" title="wikilink">Category:Speech processing</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
</ol>
</section>
</body>
</html>
