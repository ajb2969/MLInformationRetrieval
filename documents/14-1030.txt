   Expander code      Expander code   In coding theory , expander codes form a class of error-correcting codes that are constructed from bipartite  expander graphs . Along with Justesen codes , expander codes are of particular interest since they have a constant positive rate , a constant positive relative distance , and a constant alphabet size . In fact, the alphabet contains only two elements, so expander codes belong to the class of binary codes . Furthermore, expander codes can be both encoded and decoded in time proportional to the block length of the code. Expander codes are the only known asymptotically good codes which can be both encoded and decoded from a constant fraction of errors in polynomial time.  Expander codes  In coding theory , an expander code is a      [  n  ,   n  -  m   ]   2      subscript   n    n  m    2    [n,n-m]_{2}\,    linear block code whose parity check matrix is the adjacency matrix of a bipartite expander graph . These codes have good relative distance     2   (   1  -  ε   )    γ       2    1  ε   γ    2(1-\varepsilon)\gamma\,   , where    ε    ε   \varepsilon\,   and    γ    γ   \gamma\,   are properties of the expander graph as defined later), rate     (   1  -   m  n    )      1    m  n     \left(1-\tfrac{m}{n}\right)\,   , and decodability (algorithms of running time    O   (  n  )       O  n    O(n)\,   exist).  Definition  Consider a bipartite graph     G   (  L  ,  R  ,  E  )       G   L  R  E     G(L,R,E)\,   , where    L    L   L\,   and    R    R   R\,   are the vertex sets and    E    E   E\,   is the set of edges connecting vertices in    L    L   L\,   to vertices of    R    R   R\,   . Suppose every vertex in    L    L   L\,   has degree     d    d   d\,   (the graph is    d    d   d\,   - regular ),     |  L  |   =   n         L   n    |L|=n\,   , and     |  R  |   =   m         R   m    |R|=m\,   ,    m  <   n       m  n    m   . Then    G    G   G\,   is a    (  N  ,  M  ,  d  ,  γ  ,  α  )     N  M  d  γ  α    (N,M,d,\gamma,\alpha)\,   expander graph if every small enough subset    S  ⊂   L       S  L    S\subset L\,   ,     |  S  |   ≤   γ   n          S     γ  n     |S|\leq\gamma n\,   has the property that    S    S   S\,   has at least    d  α   |  S  |       d  α    S     d\alpha|S|\,   distinct neighbors in    R    R   R\,   . Note that this holds trivially for    γ  ≤    1  n        γ    1  n     \gamma\leq\tfrac{1}{n}\,   . When     1  n   <  γ  ≤   1           1  n   γ       1     \tfrac{1}{n}<\gamma\leq 1\,   and    α  =   1  -   ε        α    1  ε     \alpha=1-\varepsilon\,   for a constant    ε    ε   \varepsilon\,   , we say that    G    G   G\,   is a lossless expander.  Since    G    G   G\,   is a bipartite graph, we may consider its    n  ×   m       n  m    n\times m\,   adjacency matrix. Then the linear code    C    C   C\,   generated by viewing the transpose of this matrix as a parity check matrix is an expander code.  It has been shown that nontrivial lossless expander graphs exist. Moreover, we can explicitly construct them. 1  Rate  The rate of    C    C   C\,   is its dimension divided by its block length. In this case, the parity check matrix has size    m  ×   n       m  n    m\times n\,   , and hence    C    C   C\,   has dimension at least      (   n  -  m   )   /  n   =   1  -    m  n             n  m   n     1    m  n      (n-m)/n=1-\tfrac{m}{n}\,   .  Distance  Suppose    ε  <    1  2        ε    1  2     \varepsilon<\tfrac{1}{2}\,   . Then the distance of a    (  n  ,  m  ,  d  ,  γ  ,   1  -  ε   )     n  m  d  γ    1  ε     (n,m,d,\gamma,1-\varepsilon)\,   expander code    C    C   C\,   is at least    2   (   1  -  ε   )   γ   n       2    1  ε   γ  n    2(1-\varepsilon)\gamma n\,   .  Proof  Note that we can consider every codeword    c    c   c\,   in    C    C   C\,   as a subset of vertices    S  ⊂   L       S  L    S\subset L\,   , by saying that vertex     v  i   ∈   S        subscript  v  i   S    v_{i}\in S\,   if and only if the    i    i   i\,   th index of the codeword is a 1. Then    c    c   c\,   is a codeword iff every vertex    v  ∈   R       v  R    v\in R\,   is adjacent to an even number of vertices in    S    S   S\,   . (In order to be a codeword,     c  P   =   0         c  P   0    cP=0\,   , where    P    P   P\,   is the parity check matrix. Then, each vertex in    R    R   R\,   corresponds to each column of    P    P   P\,   . Matrix multiplication over     GF   (  2  )    =   {  0  ,  1  }         GF  2    0  1     \text{GF}(2)=\{0,1\}\,   then gives the desired result.) So, if a vertex    v  ∈   R       v  R    v\in R\,   is adjacent to a single vertex in    S    S   S\,   , we know immediately that    c    c   c\,   is not a codeword. Let    N   (  S  )       N  S    N(S)\,   denote the neighbors in    R    R   R\,   of    S    S   S\,   , and    U   (  S  )       U  S    U(S)\,   denote those neighbors of    S    S   S\,   which are unique, i.e., adjacent to a single vertex of    S    S   S\,   .  Lemma 1  For every    S  ⊂   L       S  L    S\subset L\,   of size     |  S  |   ≤   γ   n          S     γ  n     |S|\leq\gamma n\,   ,     d   |  S  |    ≥   |   N   (  S  )    |   ≥   |   U   (  S  )    |   ≥   d   (   1  -   2  ε    )    |  S  |            d    S        N  S             U  S           d    1    2  ε      S       d|S|\geq|N(S)|\geq|U(S)|\geq d(1-2\varepsilon)|S|\,   .  Proof  Trivially,     |   N   (  S  )    |   ≥   |   U   (  S  )    |           N  S        U  S      |N(S)|\geq|U(S)|\,   , since    v  ∈   U   (  S  )        v    U  S     v\in U(S)\,   implies    v  ∈   N   (  S  )        v    N  S     v\in N(S)\,   .     |   N   (  S  )    |   ≤   d   |  S  |            N  S      d    S      |N(S)|\leq d|S|\,   follows since the degree of every vertex in    S    S   S\,   is    d    d   d\,   . By the expansion property of the graph, there must be a set of    d   (   1  -  ε   )    |  S  |       d    1  ε     S     d(1-\varepsilon)|S|\,   edges which go to distinct vertices. The remaining    d  ε   |  S  |       d  ε    S     d\varepsilon|S|\,   edges make at most    d  ε   |  S  |       d  ε    S     d\varepsilon|S|\,   neighbors not unique, so     U   (  S  )    ≥    d   (   1  -  ε   )    |  S  |    -   d  ε   |  S  |     =   d   (   1  -   2  ε    )    |  S  |            U  S       d    1  ε     S      d  ε    S            d    1    2  ε      S       U(S)\geq d(1-\varepsilon)|S|-d\varepsilon|S|=d(1-2\varepsilon)|S|\,   .  Corollary  Every sufficiently small    S    S   S\,   has a unique neighbor. This follows since    ε  <    1  2        ε    1  2     \varepsilon<\tfrac{1}{2}\,   .  Lemma 2  Every subset    T  ⊂   L       T  L    T\subset L\,   with     |  T  |   <   2   (   1  -  ε   )   γ   n          T     2    1  ε   γ  n     |T|<2(1-\varepsilon)\gamma n\,   has a unique neighbor.  Proof  Lemma 1 proves the case     |  T  |   ≤   γ   n          T     γ  n     |T|\leq\gamma n\,   , so suppose     2   (   1  -  ε   )   γ  n   >   |  T  |   >   γ   n            2    1  ε   γ  n     T          γ  n      2(1-\varepsilon)\gamma n>|T|>\gamma n\,   . Let    S  ⊂   T       S  T    S\subset T\,   such that     |  S  |   =   γ   n          S     γ  n     |S|=\gamma n\,   . By Lemma 1, we know that     |   U   (  S  )    |   ≥   d   (   1  -   2  ε    )    |  S  |            U  S      d    1    2  ε      S      |U(S)|\geq d(1-2\varepsilon)|S|\,   . Then a vertex    v  ∈   U   (  S  )        v    U  S     v\in U(S)\,   is in    U   (  T  )       U  T    U(T)\,   iff    v  ∉   N   (   T  ∖  S   )        v    N    T  S      v\notin N(T\setminus S)\,   , and we know that     |   T  ∖  S   |   ≤    2   (   1  -  ε   )   γ  n   -   γ  n    =    (   1  -   2  ε    )   γ   n              T  S        2    1  ε   γ  n     γ  n             1    2  ε    γ  n      |T\setminus S|\leq 2(1-\varepsilon)\gamma n-\gamma n=(1-2\varepsilon)\gamma n\,   , so by the first part of Lemma 1, we know     |   N   (   T  ∖  S   )    |   ≤   d   (   1  -   2  ε    )   γ   n            N    T  S       d    1    2  ε    γ  n     |N(T\setminus S)|\leq d(1-2\varepsilon)\gamma n\,   . Since    ε  <    1  2        ε    1  2     \varepsilon<\tfrac{1}{2}\,   ,     |   U   (  T  )    |   ≥   |    U   (  S  )    ∖   N   (   T  ∖  S   )     |   ≥    |   U   (  S  )    |   -   |   N   (   T  ∖  S   )    |    >   0             U  T          U  S     N    T  S                 U  S        N    T  S           0     |U(T)|\geq|U(S)\setminus N(T\setminus S)|\geq|U(S)|-|N(T\setminus S)|>0\,   , and hence    U   (  T  )       U  T    U(T)\,   is not empty.  Corollary  Note that if a    T  ⊂   L       T  L    T\subset L\,   has at least 1 unique neighbor, i.e.     |   U   (  T  )    |   >   0           U  T    0    |U(T)|>0\,   , then the corresponding word    c    c   c\,   corresponding to    T    T   T\,   cannot be a codeword, as it will not multiply to the all zeros vector by the parity check matrix. By the previous argument,    c  ∈  C  ⟹   w  t   (  c  )    ≥   2   (   1  -  ε   )   γ   n          c  C         w  t  c          2    1  ε   γ  n      c\in C\implies wt(c)\geq 2(1-\varepsilon)\gamma n\,   . Since    C    C   C\,   is linear, we conclude that    C    C   C\,   has distance at least    2   (   1  -  ε   )   γ   n       2    1  ε   γ  n    2(1-\varepsilon)\gamma n\,   .  Encoding  The encoding time for an expander code is upper bounded by that of a general linear code -    O   (   n  2   )       O   superscript  n  2     O(n^{2})\,   by matrix multiplication. A result due to Spielman shows that encoding is possible in    O   (  n  )       O  n    O(n)\,   time. 2  Decoding  Decoding of expander codes is possible in    O   (  n  )       O  n    O(n)\,   time when    ε  <    1  4        ε    1  4     \varepsilon<\tfrac{1}{4}\,   using the following algorithm.  Let     v  i      subscript  v  i    v_{i}\,   be the vertex of    L    L   L\,   that corresponds to the    i    i   i\,   th index in the codewords of    C    C   C\,   . Let    y  ∈     {  0  ,  1  }   n        y   superscript   0  1   n     y\in\{0,1\}^{n}\,   be a received word, and     V   (  y  )    =   {   v  i   |   the   i  th   position of  y  is a  1   }         V  y    conditional-set   subscript  v  i     the   superscript  i  th   position of  y  is a  1      V(y)=\{v_{i}|\text{ the }i^{\text{th}}\text{ position of }y\text{ is a }1\}\,   . Let    e   (  i  )       e  i    e(i)\,   be    |   {  v  ∈  R  |  N   (  v  )   ∩  V   (  y  )       fragments  normal-|   fragments  normal-{  v   R  normal-|  N   fragments  normal-(  v  normal-)    V   fragments  normal-(  y  normal-)      |\{v\in R|N(v)\cap V(y)\,   is even    }  |     fragments  normal-}  normal-|    \}|\,   , and    o   (  i  )       o  i    o(i)\,   be    |   {  v  ∈  R  |  N   (  v  )   ∩  V   (  y  )       fragments  normal-|   fragments  normal-{  v   R  normal-|  N   fragments  normal-(  v  normal-)    V   fragments  normal-(  y  normal-)      |\{v\in R|N(v)\cap V(y)\,   is odd    }  |     fragments  normal-}  normal-|    \}|\,   . Then consider the greedy algorithm:   Input: received codeword    y    y   y\,   . initialize y' to y
  while there is a v in R adjacent to an odd number of vertices in V(y')
      if there is an i such that o(i) > e(i)
          flip entry i in y'
      else
          fail  Output: fail, or modified codeword     y  ′      superscript  y  normal-′    y^{\prime}\,   .   Proof  We show first the correctness of the algorithm, and then examine its running time.  Correctness  We must show that the algorithm terminates with the correct codeword when the received codeword is within half the code's distance of the original codeword. Let the set of corrupt variables be    S    S   S\,   ,    s  =   |  S  |       s    S     s=|S|\,   , and the set of unsatisfied (adjacent to an odd number of vertices) vertices in    R    R   R\,   be    c    c   c\,   . The following lemma will prove useful.  Lemma 3  If    0  <  s  <   γ   n          0  s         γ  n      0   , then there is a     v  i      subscript  v  i    v_{i}\,   with     o   (  i  )    >   e   (  i  )          o  i     e  i     o(i)>e(i)\,   .  Proof  By Lemma 1, we know that     U   (  S  )    ≥   d   (   1  -   2  ε    )    s          U  S     d    1    2  ε    s     U(S)\geq d(1-2\varepsilon)s\,   . So an average vertex has at least     d   (   1  -   2  ε    )    >   d  /   2          d    1    2  ε       d  2     d(1-2\varepsilon)>d/2\,   unique neighbors (recall unique neighbors are unsatisfied and hence contribute to    o   (  i  )       o  i    o(i)\,   ), since    ε  <    1  4        ε    1  4     \varepsilon<\tfrac{1}{4}\,   , and thus there is a vertex     v  i      subscript  v  i    v_{i}\,   with     o   (  i  )    >   e   (  i  )          o  i     e  i     o(i)>e(i)\,   .  So, if we have not yet reached a codeword, then there will always be some vertex to flip. Next, we show that the number of errors can never increase beyond    γ   n       γ  n    \gamma n\,   .  Lemma 4  If we start with    s  <   γ   (   1  -   2  ε    )    n        s    γ    1    2  ε    n     s<\gamma(1-2\varepsilon)n\,   , then we never reach    s  =   γ   n        s    γ  n     s=\gamma n\,   at any point in the algorithm.  Proof  When we flip a vertex     v  i      subscript  v  i    v_{i}\,   ,    o   (  i  )       o  i    o(i)\,   and    e   (  i  )       e  i    e(i)\,   are interchanged, and since we had     o   (  i  )    >   e   (  i  )          o  i     e  i     o(i)>e(i)\,   , this means the number of unsatisfied vertices on the right decreases by at least one after each flip. Since    s  <   γ   (   1  -   2  ε    )    n        s    γ    1    2  ε    n     s<\gamma(1-2\varepsilon)n\,   , the initial number of unsatisfied vertices is at most    d  γ   (   1  -   2  ε    )    n       d  γ    1    2  ε    n    d\gamma(1-2\varepsilon)n\,   , by the graph's    d    d   d\,   -regularity. If we reached a string with    γ   n       γ  n    \gamma n\,   errors, then by Lemma 1, there would be at least    d  γ   (   1  -   2  ε    )    n       d  γ    1    2  ε    n    d\gamma(1-2\varepsilon)n\,   unique neighbors, which means there would be at least    d  γ   (   1  -   2  ε    )    n       d  γ    1    2  ε    n    d\gamma(1-2\varepsilon)n\,   unsatisfied vertices, a contradiction.  Lemmas 3 and 4 show us that if we start with    s  <   γ   (   1  -   2  ε    )    n        s    γ    1    2  ε    n     s<\gamma(1-2\varepsilon)n\,   (half the distance of    C    C   C\,   ), then we will always find a vertex     v  i      subscript  v  i    v_{i}\,   to flip. Each flip reduces the number of unsatisfied vertices in    R    R   R\,   by at least 1, and hence the algorithm terminates in at most    m    m   m\,   steps, and it terminates at some codeword, by Lemma 3. (Were it not at a codeword, there would be some vertex to flip). Lemma 4 shows us that we can never be farther than    γ   n       γ  n    \gamma n\,   away from the correct codeword. Since the code has distance     2   (   1  -  ε   )   γ  n   >   γ   n          2    1  ε   γ  n     γ  n     2(1-\varepsilon)\gamma n>\gamma n\,   (since    ε  <    1  2        ε    1  2     \varepsilon<\tfrac{1}{2}\,   ), the codeword it terminates on must be the correct codeword, since the number of bit flips is less than half the distance (so we couldn't have traveled far enough to reach any other codeword).  Complexity  We now show that the algorithm can achieve linear time decoding. Let     n  m       n  m    \tfrac{n}{m}\,   be constant, and    r    r   r\,   be the maximum degree of any vertex in    R    R   R\,   . Note that    r    r   r\,   is also constant for known constructions.   Pre-processing: It takes    O   (   m  r   )       O    m  r     O(mr)\,   time to compute whether each vertex in    R    R   R\,   has an odd or even number of neighbors.  Pre-processing 2: We take     O   (   d  n   )    =   O   (   d  m  r   )          O    d  n      O    d  m  r      O(dn)=O(dmr)\,   time to compute a list of vertices     v  i      subscript  v  i    v_{i}\,   in    L    L   L\,   which have     o   (  i  )    >   e   (  i  )          o  i     e  i     o(i)>e(i)\,   .  Each Iteration: We simply remove the first list element. To update the list of odd / even vertices in    R    R   R\,   , we need only update    O   (  d  )       O  d    O(d)\,   entries, inserting / removing as necessary. We then update    O   (   d  r   )       O    d  r     O(dr)\,   entries in the list of vertices in    L    L   L\,   with more odd than even neighbors, inserting / removing as necessary. Thus each iteration takes    O   (   d  r   )       O    d  r     O(dr)\,   time.  As argued above, the total number of iterations is at most    m    m   m\,   .   This gives a total runtime of     O   (   m  d  r   )    =   O   (  n  )          O    m  d  r      O  n     O(mdr)=O(n)\,   time, where    d    d   d\,   and    r    r   r\,   are constants.  See also   Expander graph  Low-density parity-check code  Linear time encoding and decoding of error-correcting codes  ABNNR and AEL codes   Notes  This article is based on Dr. Venkatesan Guruswami's course notes. 3  References    "  Category:Error detection and correction  Category:Coding theory  Category:Capacity-approaching codes     ↩  ↩    ↩     