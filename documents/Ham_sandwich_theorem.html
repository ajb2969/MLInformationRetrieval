<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="386">Ham sandwich theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Ham sandwich theorem</h1>
<hr/>

<p>In <a href="mathematics" title="wikilink">mathematical</a> <a href="measure_theory" title="wikilink">measure theory</a>, the <strong>sandwich theorem</strong> states that given 

<math display="inline" id="Ham_sandwich_theorem:0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 <a class="uri" href="measurable" title="wikilink">measurable</a> "objects" in 

<math display="inline" id="Ham_sandwich_theorem:1">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-<a href="dimension" title="wikilink">dimensional</a> space, it is possible to divide all of them in half (with respect to their <a href="Measure_(mathematics)" title="wikilink">measure</a>, i.e. volume) with a single 

<math display="inline" id="Ham_sandwich_theorem:2">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>n</mi>
    <mi mathvariant="normal">−</mi>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n−1)
  </annotation>
 </semantics>
</math>

-dimensional <a class="uri" href="hyperplane" title="wikilink">hyperplane</a>.</p>

<p>It was proposed by <a href="Hugo_Steinhaus" title="wikilink">Hugo Steinhaus</a> and proved by <a href="Stefan_Banach" title="wikilink">Stefan Banach</a> (explicitly in dimension 3, without bothering to automatically state the theorem in the n-dimensional case), and also years later called the <strong>Stone–Tukey theorem</strong> after <a href="Arthur_Harold_Stone" title="wikilink">Arthur H. Stone</a> and <a href="John_Tukey" title="wikilink">John Tukey</a>,</p>
<h2 id="naming">Naming</h2>
<figure><b>(Figure)</b>
<figcaption>A ham sandwich</figcaption>
</figure>

<p>The ham sandwich theorem takes its name from the case when 

<math display="inline" id="Ham_sandwich_theorem:3">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=3
  </annotation>
 </semantics>
</math>

 and the three objects of any shape are a chunk of <a href="ham_(meat)" title="wikilink">ham</a> and two chunks of <a class="uri" href="bread" title="wikilink">bread</a> — notionally, a <a class="uri" href="sandwich" title="wikilink">sandwich</a> — which can then all be simultaneously bisected with a single cut (i.e., a <a href="plane_(mathematics)" title="wikilink">plane</a>). In two dimensions, the theorem is known as the <strong>pancake theorem</strong> of having to cut two infinitesimally thin <a href="pancake" title="wikilink">pancakes</a> on a plate each in half with a single cut (i.e., a straight <a href="line_(mathematics)" title="wikilink">line</a>).</p>
<h2 id="history">History</h2>

<p>According to , the earliest known paper about the ham sandwich theorem, specifically the 

<math display="inline" id="Ham_sandwich_theorem:4">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=3
  </annotation>
 </semantics>
</math>

 case of bisecting three solids with a plane, is by . Beyer and Zardecki's paper includes a translation of the 1938 paper. It attributes the posing of the problem to <a href="Hugo_Steinhaus" title="wikilink">Hugo Steinhaus</a>, and credits <a href="Stefan_Banach" title="wikilink">Stefan Banach</a> as the first to solve the problem, by a reduction to the <a href="Borsuk–Ulam_theorem" title="wikilink">Borsuk–Ulam theorem</a>. The paper poses the problem in two ways: first, formally, as "Is it always possible to bisect three solids, arbitrarily located, with the aid of an appropriate plane?" and second, informally, as "Can we place a piece of ham under a meat cutter so that meat, bone, and fat are cut in halves?" Later, the paper offers a proof of the theorem.</p>

<p>A more modern reference is , which is the basis of the name "Stone–Tukey theorem". This paper proves the 

<math display="inline" id="Ham_sandwich_theorem:5">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-dimensional version of the theorem in a more general setting involving measures. The paper attributes the 

<math display="inline" id="Ham_sandwich_theorem:6">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=3
  </annotation>
 </semantics>
</math>

 case to <a href="Stanislaw_Ulam" title="wikilink">Stanislaw Ulam</a>, based on information from a referee; but  claim that this is incorrect, given Steinhaus's paper, although "Ulam did make a fundamental contribution in proposing" the <a href="Borsuk–Ulam_theorem" title="wikilink">Borsuk–Ulam theorem</a>.</p>
<h2 id="reduction-to-the-borsukulam-theorem">Reduction to the Borsuk–Ulam theorem</h2>

<p>The ham sandwich theorem can be proved as follows using the <a href="Borsuk–Ulam_theorem" title="wikilink">Borsuk–Ulam theorem</a>. This proof follows the one described by Steinhaus and others (1938), attributed there to <a href="Stefan_Banach" title="wikilink">Stefan Banach</a>, for the 

<math display="inline" id="Ham_sandwich_theorem:7">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=3
  </annotation>
 </semantics>
</math>

 case.</p>

<p>Let <mtpl></mtpl> denote the 

<math display="inline" id="Ham_sandwich_theorem:8">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 objects that we wish to simultaneously bisect. Let 

<math display="inline" id="Ham_sandwich_theorem:9">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 be the <a href="unit_sphere" title="wikilink">unit</a> <a href="n-sphere" title="wikilink">

<math display="inline" id="Ham_sandwich_theorem:10">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>n</mi>
    <mi mathvariant="normal">−</mi>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n−1)
  </annotation>
 </semantics>
</math>

-sphere</a> embedded in 

<math display="inline" id="Ham_sandwich_theorem:11">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-dimensional <a href="Euclidean_space" title="wikilink">Euclidean space</a> 

<math display="inline" id="Ham_sandwich_theorem:12">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

, centered at the <a href="Origin_(mathematics)" title="wikilink">origin</a>. For each point 

<math display="inline" id="Ham_sandwich_theorem:13">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 on the surface of the sphere 

<math display="inline" id="Ham_sandwich_theorem:14">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, we can define a <a href="Linear_continuum" title="wikilink">continuum</a> of oriented affine <a href="hyperplane" title="wikilink">hyperplanes</a> (not necessarily centred at 0) perpendicular to the (<a href="Surface_normal" title="wikilink">normal</a>) <a href="vector_(geometric)" title="wikilink">vector</a> from the origin to 

<math display="inline" id="Ham_sandwich_theorem:15">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, with the "positive side" of each hyperplane defined as the side pointed to by that vector. By the <a href="intermediate_value_theorem" title="wikilink">intermediate value theorem</a>, every family of such hyperplanes contains at least one hyperplane that bisects the bounded object <mtpl></mtpl>: at one extreme translation, no volume of <mtpl></mtpl> is on the positive side, and at the other extreme translation, all of <mtpl></mtpl>'s volume is on the positive side, so in between there must be a translation that has half of <mtpl></mtpl>'s volume on the positive side. If there is more than one such hyperplane in the family, we can pick one canonically by choosing the midpoint of the interval of translations for which <mtpl></mtpl> is bisected. Thus we obtain, for each point 

<math display="inline" id="Ham_sandwich_theorem:16">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 on the sphere 

<math display="inline" id="Ham_sandwich_theorem:17">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, a hyperplane 

<math display="inline" id="Ham_sandwich_theorem:18">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   π(p)
  </annotation>
 </semantics>
</math>

 that is perpendicular to the vector from the origin to 

<math display="inline" id="Ham_sandwich_theorem:19">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and that bisects <mtpl></mtpl>.</p>

<p>Now we define a function 

<math display="inline" id="Ham_sandwich_theorem:20">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 from the 

<math display="inline" id="Ham_sandwich_theorem:21">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>n</mi>
    <mi mathvariant="normal">−</mi>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n−1)
  </annotation>
 </semantics>
</math>

-sphere 

<math display="inline" id="Ham_sandwich_theorem:22">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Ham_sandwich_theorem:23">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>n</mi>
    <mi mathvariant="normal">−</mi>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n−1)
  </annotation>
 </semantics>
</math>

-dimensional Euclidean space 

<math display="inline" id="Ham_sandwich_theorem:24">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{n-1}
  </annotation>
 </semantics>
</math>

 as follows:</p>
<dl>
<dd>

<math display="inline" id="Ham_sandwich_theorem:25">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo stretchy="false">(</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <ci>normal-(</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(p)=(
  </annotation>
 </semantics>
</math>

vol of <mtpl></mtpl> on the positive side of 

<math display="inline" id="Ham_sandwich_theorem:26">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   π(p)
  </annotation>
 </semantics>
</math>

, vol of <mtpl></mtpl> on the positive side of 

<math display="inline" id="Ham_sandwich_theorem:27">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   π(p)
  </annotation>
 </semantics>
</math>

, ..., vol of <mtpl></mtpl> on the positive side of 

<math display="inline" id="Ham_sandwich_theorem:28">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">π</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   π(p))
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>

<p>This function 

<math display="inline" id="Ham_sandwich_theorem:29">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is <a href="continuous_function" title="wikilink">continuous</a>. By the <a href="Borsuk–Ulam_theorem" title="wikilink">Borsuk–Ulam theorem</a>, there are <a href="antipodal_points" title="wikilink">antipodal points</a> 

<math display="inline" id="Ham_sandwich_theorem:30">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ham_sandwich_theorem:31">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 on the sphere 

<math display="inline" id="Ham_sandwich_theorem:32">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Ham_sandwich_theorem:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(p)=f(q)
  </annotation>
 </semantics>
</math>

. Antipodal points 

<math display="inline" id="Ham_sandwich_theorem:34">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ham_sandwich_theorem:35">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 correspond to hyperplanes 

<math display="inline" id="Ham_sandwich_theorem:36">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   π(p)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ham_sandwich_theorem:37">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   π(q)
  </annotation>
 </semantics>
</math>

 that are equal except that they have opposite positive sides. Thus, 

<math display="inline" id="Ham_sandwich_theorem:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(p)=f(q)
  </annotation>
 </semantics>
</math>

 means that the volume of <mtpl></mtpl> is the same on the positive and negative side of 

<math display="inline" id="Ham_sandwich_theorem:39">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   π(p)
  </annotation>
 </semantics>
</math>

 (or 

<math display="inline" id="Ham_sandwich_theorem:40">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   π(q)
  </annotation>
 </semantics>
</math>

), for 

<math display="inline" id="Ham_sandwich_theorem:41">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>n</mi>
     <mi mathvariant="normal">−</mi>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>normal-−</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,2,...,n−1
  </annotation>
 </semantics>
</math>

. Thus, 

<math display="inline" id="Ham_sandwich_theorem:42">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   π(p)
  </annotation>
 </semantics>
</math>

 (or 

<math display="inline" id="Ham_sandwich_theorem:43">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   π(q)
  </annotation>
 </semantics>
</math>

) is the desired ham sandwich cut that simultaneously bisects the volumes of <mtpl></mtpl>.</p>
<h2 id="measure-theoretic-versions">Measure theoretic versions</h2>

<p>In <a href="measure_theory" title="wikilink">measure theory</a>,  proved two more general forms of the ham sandwich theorem. Both versions concern the bisection of 

<math display="inline" id="Ham_sandwich_theorem:44">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 <a href="subset" title="wikilink">subsets</a> <mtpl></mtpl> of a common set 

<math display="inline" id="Ham_sandwich_theorem:45">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Ham_sandwich_theorem:46">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 has a <a class="uri" href="Carathéodory" title="wikilink">Carathéodory</a> <a href="outer_measure" title="wikilink">outer measure</a> and each <mtpl></mtpl> has finite outer measure.</p>

<p>Their first general formulation is as follows: for any suitably restricted real <a href="function_(mathematics)" title="wikilink">function</a> 

<math display="inline" id="Ham_sandwich_theorem:47">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>S</mi>
      <mi>n</mi>
     </msup>
     <mo>×</mo>
     <mi>X</mi>
    </mrow>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <ci>n</ci>
      </apply>
      <ci>X</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\colon S^{n}\times X\to\mathbb{R}
  </annotation>
 </semantics>
</math>

, there is a point 

<math display="inline" id="Ham_sandwich_theorem:48">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 of the 

<math display="inline" id="Ham_sandwich_theorem:49">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-<a class="uri" href="sphere" title="wikilink">sphere</a> <mtpl></mtpl> such that the surface 

<math display="inline" id="Ham_sandwich_theorem:50">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo>,</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>s</ci>
      <ci>x</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(s,x)=0
  </annotation>
 </semantics>
</math>

, dividing 

<math display="inline" id="Ham_sandwich_theorem:51">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 into 

<math display="inline" id="Ham_sandwich_theorem:52">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo>,</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>s</ci>
      <ci>x</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(s,x)>0
  </annotation>
 </semantics>
</math>

</p>

<p>Their second formulation is as follows: for any 

<math display="inline" id="Ham_sandwich_theorem:54">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 measurable functions <mtpl></mtpl> over 

<math display="inline" id="Ham_sandwich_theorem:55">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 that are <a href="linearly_independent" title="wikilink">linearly independent</a> over any subset of 

<math display="inline" id="Ham_sandwich_theorem:56">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=0
  </annotation>
 </semantics>
</math>

 of positive measure, there is a <a href="linear_combination" title="wikilink">linear combination</a> <mtpl></mtpl> such that the surface 

<math display="inline" id="Ham_sandwich_theorem:57">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

, dividing 

<math display="inline" id="Ham_sandwich_theorem:58">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)>0
  </annotation>
 </semantics>
</math>

 into 

<math display="inline" id="Ham_sandwich_theorem:59">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>i</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i>0
  </annotation>
 </semantics>
</math>

</p>
<h2 id="discrete-and-computational-geometry-versions">Discrete and computational geometry versions</h2>
<figure><b>(Figure)</b>
<figcaption>A ham-sandwich cut of eight red points and seven blue points in the plane.</figcaption>
</figure>

<p>In <a href="discrete_geometry" title="wikilink">discrete geometry</a> and <a href="computational_geometry" title="wikilink">computational geometry</a>, the ham sandwich theorem usually refers to the special case in which each of the sets being divided is a <a href="finite_set" title="wikilink">finite set</a> of <a href="point_(geometry)" title="wikilink">points</a>. Here the relevant measure is the <a href="counting_measure" title="wikilink">counting measure</a>, which simply counts the number of points on either side of the hyperplane. In two dimensions, the theorem can be stated as follows:</p>
<dl>
<dd>For a finite set of points in the plane, each colored "red" or "blue", there is a <a href="line_(mathematics)" title="wikilink">line</a> that simultaneously bisects the red points and bisects the blue points, that is, the number of red points on either side of the line is equal and the number of blue points on either side of the line is equal.
</dd>
</dl>

<p>There is an exceptional case when points lie on the line. In this situation, we count each of these points as either being on one side, on the other, or on neither side of the line (possibly depending on the point), i.e. "bisecting" in fact means that each side contains less than half of the total number of points. This exceptional case is actually required for the theorem to hold, of course when the number of red points or the number of blue is odd, but also in specific configurations with even numbers of points, for instance when all the points lie on the same line and the two colors are separated from each other (i.e. colors don't alternate along the line). A situation where the numbers of points on each side cannot match each other is provided by adding an extra point out of the line in the previous configuration.</p>

<p>In computational geometry, this ham sandwich theorem leads to a computational problem, the <strong>ham sandwich problem</strong>. In two dimensions, the problem is this: given a finite set of 

<math display="inline" id="Ham_sandwich_theorem:64">
 <semantics>
  <mi>O</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>O</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O
  </annotation>
 </semantics>
</math>

 points in the plane, each colored "red" or "blue", find a ham sandwich cut for them. First,  described an algorithm for the special, separated case. Here all red points are on one side of some line and all blue points are on the other side, a situation where there is a unique ham sandwich cut, which Megiddo could find in linear time. Later,  gave an algorithm for the general two-dimensional case; the running time of their algorithm is 

<math display="inline" id="Ham_sandwich_theorem:65">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

, where the symbol 

<math display="inline" id="Ham_sandwich_theorem:66">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 indicates the use of <a href="Big_O_notation" title="wikilink">Big O notation</a>. Finally,  found an optimal 

<math display="inline" id="Ham_sandwich_theorem:67">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

-time <a class="uri" href="algorithm" title="wikilink">algorithm</a>. This algorithm was extended to higher dimensions by . Given 

<math display="inline" id="Ham_sandwich_theorem:68">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>d</mi>
    <mi mathvariant="normal">−</mi>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (d−1)
  </annotation>
 </semantics>
</math>

 sets of points in general position in 

<math display="inline" id="Ham_sandwich_theorem:69">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mstyle scriptlevel="+1">
     <mtable columnspacing="0.4em" rowspacing="0.2ex">
      <mtr>
       <mtd>
        <mrow>
         <mi>k</mi>
         <mo>+</mo>
         <mi>n</mi>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mi>n</mi>
       </mtd>
      </mtr>
     </mtable>
    </mstyle>
    <mo>)</mo>
   </mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="latexml">binomial</csymbol>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <ci>n</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\left({{k+n}\atop{n}}\right)}-1
  </annotation>
 </semantics>
</math>

-dimensional space, the algorithm computes a 

<math display="inline" id="Ham_sandwich_theorem:70">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mstyle scriptlevel="+1">
     <mtable columnspacing="0.4em" rowspacing="0.2ex">
      <mtr>
       <mtd>
        <mrow>
         <mi>k</mi>
         <mo>+</mo>
         <mi>n</mi>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mi>n</mi>
       </mtd>
      </mtr>
     </mtable>
    </mstyle>
    <mo>)</mo>
   </mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="latexml">binomial</csymbol>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <ci>n</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\left({{k+n}\atop{n}}\right)}-1
  </annotation>
 </semantics>
</math>

-dimensional hyperplane that has equal numbers of points of each of the sets in each of its half-spaces, i.e., a ham-sandwich cut for the given points.</p>
<h2 id="generalizations">Generalizations</h2>

<p>The original theorem works for at most n collections, where n is the number of dimensions. If we want to bisect a larger number of collections, we can use, instead of a hyperplane, an algebraic surface of degree k, i.e., an n-1 dimensional surface defined by a polynomial function of degree k:</p>

<p>Given 

<math display="inline" id="Ham_sandwich_theorem:71">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>,</mo>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>y</mi>
     <mn>2</mn>
    </msup>
    <mo>,</mo>
    <mrow>
     <mi>x</mi>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
    <vector>
     <ci>x</ci>
     <ci>y</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)\to(x,y,x^{2},y^{2},xy)
  </annotation>
 </semantics>
</math>

 measures in an n-dimensional space, there exists an algebraic surface of degree k which bisects them all. ().</p>

<p>This generalization is proved by mapping the n-dimensional plane into a <span class="LaTeX">$\binom{k+n}{n}-1$</span> dimensional plane, and then applying the original theorem. For example, for n=2 and k=2, the 2-dimensional plane is mapped to a 5-dimensional plane via:</p>

<p><span class="LaTeX">$(x,y) \to (x,y,x^2,y^2,xy)$</span>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Exact_division" title="wikilink">Exact division</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://jeff560.tripod.com/h.html">ham sandwich theorem</a> on the <a href="http://jeff560.tripod.com/mathword.html">Earliest known uses of some of the words of mathematics</a></li>
<li><a href="http://cgm.cs.mcgill.ca/~athens/cs507/Projects/2002/DanielleMacNevin/index.htm">Ham Sandwich Cuts</a> by Danielle MacNevin</li>
<li><a href="http://gfredericks.com/sandbox/ham_sandwich">An interactive 2D demonstration</a></li>
</ul>

<p>"</p>

<p><a href="Category:Theorems_in_measure_theory" title="wikilink">Category:Theorems in measure theory</a> <a href="Category:Articles_containing_proofs" title="wikilink">Category:Articles containing proofs</a> <a href="Category:Theorems_in_topology" title="wikilink">Category:Theorems in topology</a></p>
</body>
</html>
