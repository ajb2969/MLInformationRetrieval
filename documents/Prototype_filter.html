<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="621">Prototype filter</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Prototype filter</h1>
<hr/>

<p><strong>Prototype filters</strong> are <a href="electronic_filter" title="wikilink">electronic filter</a> designs that are used as a template to produce a modified filter design for a particular application. They are an example of a <a href="nondimensionalization" title="wikilink">nondimensionalised</a> design from which the desired filter can be <a href="Scale_factor" title="wikilink">scaled</a> or <a href="Transform_(mathematics)" title="wikilink">transformed</a>. They are most often seen in regard to <a href="electronic_filter" title="wikilink">electronic filters</a> and especially <a href="Linear_filter" title="wikilink">linear analogue passive filters</a>. However, in principle, the method can be applied to any kind of linear filter or <a href="signal_processing" title="wikilink">signal processing</a>, including mechanical, acoustic and optical filters.</p>

<p>Filters are required to operate at many different <a href="Frequency" title="wikilink">frequencies</a>, <a href="Electrical_impedance" title="wikilink">impedances</a> and <a href="Bandwidth_(signal_processing)" title="wikilink">bandwidths</a>. The utility of a prototype filter comes from the property that all these other filters can be derived from it by applying a scaling factor to the components of the prototype. The filter design need thus only be carried out once in full, with other filters being obtained by simply applying a scaling factor.</p>

<p>Especially useful is the ability to transform from one bandform to another. In this case, the transform is more than a simple scale factor. Bandform here is meant to indicate the category of <a class="uri" href="passband" title="wikilink">passband</a> that the filter possesses. The usual bandforms are <a class="uri" href="lowpass" title="wikilink">lowpass</a>, <a class="uri" href="highpass" title="wikilink">highpass</a>, <a class="uri" href="bandpass" title="wikilink">bandpass</a> and <a class="uri" href="bandstop" title="wikilink">bandstop</a>, but others are possible. In particular, it is possible for a filter to have multiple passbands. In fact, in some treatments, the <a class="uri" href="bandstop" title="wikilink">bandstop</a> filter is considered to be a type of multiple passband filter having two passbands. Most commonly, the prototype filter is expressed as a lowpass filter, but other techniques are possible.</p>

<p> __TOC__ </p>
<h2 id="low-pass-prototype">Low-pass prototype</h2>

<p>The prototype is most often a low-pass filter with a 3 dB <a href="corner_frequency" title="wikilink">corner frequency</a> of angular frequency <em>ω<sub>c</sub>'</em> = 1 <a href="Angular_frequency" title="wikilink">rad/s</a>. Occasionally, frequency <em>f</em>' ' = 1 <a href="Hertz" title="wikilink">Hz</a> is used instead of <em>ω<sub>c</sub>'</em> = 1. Likewise, the nominal or characteristic impedance of the filter is set to <em>R</em> ' = 1 Ω.</p>

<p>In principle, any non-zero frequency point on the filter response could be used as a reference for the prototype design. For example, for filters with ripple in the passband, the corner frequency is usually defined as the highest frequency at maximum <a href="Ripple_(electrical)#Frequency-domain_ripple" title="wikilink">ripple</a> rather than 3 dB. Another case is in <a href="Composite_image_filter" title="wikilink">image parameter filters</a> (an older design method than the more modern <a href="network_synthesis_filters" title="wikilink">network synthesis filters</a>) which use the <a href="cut-off_frequency" title="wikilink">cut-off frequency</a> rather than the 3 dB point since cut-off is a well-defined point in this type of filter.</p>

<p>The prototype filter can only be used to produce other filters of the same class<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and order.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> For instance, a fifth-order <a href="Bessel_filter" title="wikilink">Bessel filter</a> prototype can be converted into any other fifth-order Bessel filter, but it cannot be transformed into a third-order Bessel filter or a fifth-order <a href="Tchebyscheff_filter" title="wikilink">Tchebyscheff filter</a>.</p>
<h2 id="frequency-scaling">Frequency scaling</h2>

<p>The prototype filter is scaled to the frequency required with the following transformation:</p>

<p>

<math display="inline" id="Prototype_filter:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>i</mi>
    <mi>ω</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <msubsup>
       <mi>ω</mi>
       <mi>c</mi>
       <mo>′</mo>
      </msubsup>
      <msub>
       <mi>ω</mi>
       <mi>c</mi>
      </msub>
     </mfrac>
     <mo>)</mo>
    </mrow>
    <mi>i</mi>
    <mi>ω</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>ω</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>c</ci>
       </apply>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <ci>c</ci>
      </apply>
     </apply>
     <ci>i</ci>
     <ci>ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\omega\to\left(\frac{\omega_{c}^{\prime}}{\omega_{c}}\right)i\omega
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>ω<sub>c</sub>'</em> is the value of the frequency parameter (e.g. cut-off frequency) for the prototype and <em>ω<sub>c</sub></em> is the desired value. So if <em>ω<sub>c</sub>'</em> = 1 then the transfer function of the filter is transformed as:</p>

<p>

<math display="inline" id="Prototype_filter:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>i</mi>
      <mi>ω</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>i</mi>
      <mfrac>
       <mi>ω</mi>
       <msub>
        <mi>ω</mi>
        <mi>c</mi>
       </msub>
      </mfrac>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>ω</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <apply>
       <divide></divide>
       <ci>ω</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>c</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(i\omega)\to A\left(i\frac{\omega}{\omega_{c}}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>It can readily be seen that to achieve this, the non-resistive components of the filter must be transformed by:</p>

<p>

<math display="inline" id="Prototype_filter:2">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>→</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mfrac>
      <msubsup>
       <mi>ω</mi>
       <mi>c</mi>
       <mo>′</mo>
      </msubsup>
      <msub>
       <mi>ω</mi>
       <mi>c</mi>
      </msub>
     </mfrac>
    </mpadded>
    <mi>L</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>L</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>c</ci>
       </apply>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <ci>c</ci>
      </apply>
     </apply>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\to\frac{\omega_{c}^{\prime}}{\omega_{c}}\,L
  </annotation>
 </semantics>
</math>

  and,   

<math display="inline" id="Prototype_filter:3">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>→</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mfrac>
      <msubsup>
       <mi>ω</mi>
       <mi>c</mi>
       <mo>′</mo>
      </msubsup>
      <msub>
       <mi>ω</mi>
       <mi>c</mi>
      </msub>
     </mfrac>
    </mpadded>
    <mi>C</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>C</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>c</ci>
       </apply>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <ci>c</ci>
      </apply>
     </apply>
     <ci>C</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\to\frac{\omega_{c}^{\prime}}{\omega_{c}}\,C
  </annotation>
 </semantics>
</math>


</p>
<h2 id="impedance-scaling">Impedance scaling</h2>

<p>Impedance scaling is invariably a scaling to a fixed resistance. This is because the terminations of the filter, at least nominally, are taken to be a fixed resistance. To carry out this scaling to a nominal impedance <em>R</em>, each impedance element of the filter is transformed by:</p>

<p>

<math display="inline" id="Prototype_filter:4">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>→</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mfrac>
      <mi>R</mi>
      <msup>
       <mi>R</mi>
       <mo>′</mo>
      </msup>
     </mfrac>
    </mpadded>
    <mi>Z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>Z</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>R</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>R</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z\to\frac{R}{R^{\prime}}\,Z
  </annotation>
 </semantics>
</math>

</p>

<p>It may be more convenient on some elements to scale the admittance instead:</p>

<p>

<math display="inline" id="Prototype_filter:5">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>→</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mfrac>
      <msup>
       <mi>R</mi>
       <mo>′</mo>
      </msup>
      <mi>R</mi>
     </mfrac>
    </mpadded>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>Y</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>R</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>R</ci>
     </apply>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y\to\frac{R^{\prime}}{R}\,Y
  </annotation>
 </semantics>
</math>

</p>

<p> It can readily be seen that to achieve this, the non-resistive components of the filter must be scaled as:</p>

<p>

<math display="inline" id="Prototype_filter:6">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>→</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mfrac>
      <mi>R</mi>
      <msup>
       <mi>R</mi>
       <mo>′</mo>
      </msup>
     </mfrac>
    </mpadded>
    <mi>L</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>L</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>R</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>R</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\to\frac{R}{R^{\prime}}\,L
  </annotation>
 </semantics>
</math>

    and,    

<math display="inline" id="Prototype_filter:7">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>→</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mfrac>
      <msup>
       <mi>R</mi>
       <mo>′</mo>
      </msup>
      <mi>R</mi>
     </mfrac>
    </mpadded>
    <mi>C</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>C</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>R</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>R</ci>
     </apply>
     <ci>C</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\to\frac{R^{\prime}}{R}\,C
  </annotation>
 </semantics>
</math>

</p>

<p>Impedance scaling by itself has no effect on the transfer function of the filter (providing that the terminating impedances have the same scaling applied to them). However, it is usual to combine the frequency and impedance scaling into a single step:<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> 

<math display="inline" id="Prototype_filter:8">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo rspace="4.2pt">→</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mfrac>
      <msubsup>
       <mi>ω</mi>
       <mi>c</mi>
       <mo>′</mo>
      </msubsup>
      <msub>
       <mi>ω</mi>
       <mi>c</mi>
      </msub>
     </mfrac>
    </mpadded>
    <mpadded width="+1.7pt">
     <mfrac>
      <mi>R</mi>
      <msup>
       <mi>R</mi>
       <mo>′</mo>
      </msup>
     </mfrac>
    </mpadded>
    <mi>L</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>L</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>c</ci>
       </apply>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <ci>c</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <ci>R</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>R</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\to\,\frac{\omega_{c}^{\prime}}{\omega_{c}}\,\frac{R}{R^{\prime}}\,L
  </annotation>
 </semantics>
</math>


  and,   

<math display="inline" id="Prototype_filter:9">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo rspace="4.2pt">→</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mfrac>
      <msubsup>
       <mi>ω</mi>
       <mi>c</mi>
       <mo>′</mo>
      </msubsup>
      <msub>
       <mi>ω</mi>
       <mi>c</mi>
      </msub>
     </mfrac>
    </mpadded>
    <mpadded width="+1.7pt">
     <mfrac>
      <msup>
       <mi>R</mi>
       <mo>′</mo>
      </msup>
      <mi>R</mi>
     </mfrac>
    </mpadded>
    <mi>C</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>C</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>c</ci>
       </apply>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <ci>c</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>R</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>R</ci>
     </apply>
     <ci>C</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\to\,\frac{\omega_{c}^{\prime}}{\omega_{c}}\,\frac{R^{\prime}}{R}\,C
  </annotation>
 </semantics>
</math>

</p>
<h2 id="bandform-transformation">Bandform transformation</h2>

<p>In general, the bandform of a filter is transformed by replacing <em>iω</em> where it occurs in the transfer function with a function of <em>iω</em>. This in turn leads to the transformation of the impedance components of the filter into some other component(s). The frequency scaling above is a trivial case of bandform transformation corresponding to a lowpass to lowpass transformation.</p>
<h3 id="lowpass-to-highpass">Lowpass to highpass</h3>

<p>The frequency transformation required in this case is:<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> 

<math display="inline" id="Prototype_filter:10">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>i</mi>
     <mi>ω</mi>
    </mrow>
    <msubsup>
     <mi>ω</mi>
     <mi>c</mi>
     <mo>′</mo>
    </msubsup>
   </mfrac>
   <mo>→</mo>
   <mfrac>
    <msub>
     <mi>ω</mi>
     <mi>c</mi>
    </msub>
    <mrow>
     <mi>i</mi>
     <mi>ω</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>ω</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <ci>c</ci>
      </apply>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>ω</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{i\omega}{\omega_{c}^{\prime}}\to\frac{\omega_{c}}{i\omega}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>ω<sub>c</sub></em> is the point on the highpass filter corresponding to <em>ω<sub>c</sub>'</em> on the prototype. The transfer function then transforms as:</p>

<p>

<math display="inline" id="Prototype_filter:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>i</mi>
      <mi>ω</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mrow>
       <mpadded width="+1.7pt">
        <msub>
         <mi>ω</mi>
         <mi>c</mi>
        </msub>
       </mpadded>
       <msubsup>
        <mi>ω</mi>
        <mi>c</mi>
        <mo>′</mo>
       </msubsup>
      </mrow>
      <mrow>
       <mi>i</mi>
       <mi>ω</mi>
      </mrow>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>ω</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>c</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <ci>c</ci>
        </apply>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>ω</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(i\omega)\to A\left(\frac{\omega_{c}\,\omega_{c}^{\prime}}{i\omega}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>Inductors are transformed into capacitors according to,</p>

<p>

<math display="inline" id="Prototype_filter:12">
 <semantics>
  <mrow>
   <msup>
    <mi>L</mi>
    <mo>′</mo>
   </msup>
   <mo>→</mo>
   <mi>C</mi>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mpadded width="+1.7pt">
      <msub>
       <mi>ω</mi>
       <mi>c</mi>
      </msub>
     </mpadded>
     <mpadded width="+1.7pt">
      <msubsup>
       <mi>ω</mi>
       <mi>c</mi>
       <mo>′</mo>
      </msubsup>
     </mpadded>
     <msup>
      <mi>L</mi>
      <mo>′</mo>
     </msup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>C</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>c</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <ci>c</ci>
        </apply>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>L</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{\prime}\to C=\frac{1}{\omega_{c}\,\omega_{c}^{\prime}\,L^{\prime}}
  </annotation>
 </semantics>
</math>

</p>

<p>and capacitors are transformed into inductors,</p>

<p>

<math display="inline" id="Prototype_filter:13">
 <semantics>
  <mrow>
   <msup>
    <mi>C</mi>
    <mo>′</mo>
   </msup>
   <mo>→</mo>
   <mi>L</mi>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mpadded width="+1.7pt">
      <msub>
       <mi>ω</mi>
       <mi>c</mi>
      </msub>
     </mpadded>
     <mpadded width="+1.7pt">
      <msubsup>
       <mi>ω</mi>
       <mi>c</mi>
       <mo>′</mo>
      </msubsup>
     </mpadded>
     <msup>
      <mi>C</mi>
      <mo>′</mo>
     </msup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>C</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>L</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>c</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <ci>c</ci>
        </apply>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>C</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{\prime}\to L=\frac{1}{\omega_{c}\,\omega_{c}^{\prime}\,C^{\prime}}
  </annotation>
 </semantics>
</math>


</p>

<p>the primed quantities being the component value in the prototype.</p>
<h3 id="lowpass-to-bandpass">Lowpass to bandpass</h3>

<p>In this case, the required frequency transformation is:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> 

<math display="inline" id="Prototype_filter:14">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>i</mi>
     <mi>ω</mi>
    </mrow>
    <msubsup>
     <mi>ω</mi>
     <mi>c</mi>
     <mo>′</mo>
    </msubsup>
   </mfrac>
   <mo>→</mo>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mfrac>
       <mrow>
        <mi>i</mi>
        <mi>ω</mi>
       </mrow>
       <msub>
        <mi>ω</mi>
        <mn>0</mn>
       </msub>
      </mfrac>
      <mo>+</mo>
      <mfrac>
       <msub>
        <mi>ω</mi>
        <mn>0</mn>
       </msub>
       <mrow>
        <mi>i</mi>
        <mi>ω</mi>
       </mrow>
      </mfrac>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>ω</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <ci>c</ci>
      </apply>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <plus></plus>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>ω</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>ω</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{i\omega}{\omega_{c}^{\prime}}\to Q\left(\frac{i\omega}{\omega_{0}}+\frac%
{\omega_{0}}{i\omega}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>Q</em> is the Q-factor and is equal to the inverse of the fractional bandwidth:<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> 

<math display="inline" id="Prototype_filter:15">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>=</mo>
   <mfrac>
    <msub>
     <mi>ω</mi>
     <mn>0</mn>
    </msub>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>ω</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Q</ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>ω</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=\frac{\omega_{0}}{\Delta\omega}
  </annotation>
 </semantics>
</math>

</p>

<p>If <em>ω<sub>1</sub></em> and <em>ω<sub>2</sub></em> are the lower and upper frequency points (respectively) of the bandpass response corresponding to <em>ω<sub>c</sub>'</em> of the prototype, then,</p>

<p>

<math display="inline" id="Prototype_filter:16">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>ω</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>ω</mi>
     <mn>2</mn>
    </msub>
    <mo>-</mo>
    <mpadded width="+1.7pt">
     <msub>
      <mi>ω</mi>
      <mn>1</mn>
     </msub>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>ω</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta\omega=\omega_{2}-\omega_{1}\,
  </annotation>
 </semantics>
</math>

   and    

<math display="inline" id="Prototype_filter:17">
 <semantics>
  <mrow>
   <msub>
    <mi>ω</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <msqrt>
    <mrow>
     <msub>
      <mi>ω</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>ω</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <root></root>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{0}=\sqrt{\omega_{1}\omega_{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>Δ<em>ω</em> is the absolute bandwidth, and <em>ω<sub>0</sub></em> is the resonant frequency of the resonators in the filter. Note that frequency scaling the prototype prior to lowpass to bandpass transformation does not affect the resonant frequency, but instead affects the final bandwidth of the filter.</p>

<p>The transfer function of the filter is transformed according to:</p>

<p>

<math display="inline" id="Prototype_filter:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>i</mi>
      <mi>ω</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msubsup>
       <mi>ω</mi>
       <mi>c</mi>
       <mo>′</mo>
      </msubsup>
      <mi>Q</mi>
      <mrow>
       <mo>[</mo>
       <mrow>
        <mfrac>
         <mrow>
          <mi>i</mi>
          <mi>ω</mi>
         </mrow>
         <msub>
          <mi>ω</mi>
          <mn>0</mn>
         </msub>
        </mfrac>
        <mo>+</mo>
        <mfrac>
         <msub>
          <mi>ω</mi>
          <mn>0</mn>
         </msub>
         <mrow>
          <mi>i</mi>
          <mi>ω</mi>
         </mrow>
        </mfrac>
       </mrow>
       <mo>]</mo>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>ω</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>c</ci>
       </apply>
       <ci>normal-′</ci>
      </apply>
      <ci>Q</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>ω</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ω</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ω</ci>
          <cn type="integer">0</cn>
         </apply>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>ω</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(i\omega)\to A\left(\omega_{c}^{\prime}Q\left[\frac{i\omega}{\omega_{0}}+%
\frac{\omega_{0}}{i\omega}\right]\right)
  </annotation>
 </semantics>
</math>


</p>

<p> Inductors are transformed into series <a href="resonator" title="wikilink">resonators</a>,</p>

<p>

<math display="inline" id="Prototype_filter:19">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>L</mi>
     <mo>′</mo>
    </msup>
    <mo>→</mo>
    <mi>L</mi>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mrow>
       <msubsup>
        <mi>ω</mi>
        <mi>c</mi>
        <mo>′</mo>
       </msubsup>
       <mi>Q</mi>
      </mrow>
      <msub>
       <mi>ω</mi>
       <mn>0</mn>
      </msub>
     </mfrac>
     <mpadded width="+1.7pt">
      <msup>
       <mi>L</mi>
       <mo>′</mo>
      </msup>
     </mpadded>
    </mrow>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mrow>
    <mi>C</mi>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <msub>
        <mi>ω</mi>
        <mn>0</mn>
       </msub>
       <msubsup>
        <mi>ω</mi>
        <mi>c</mi>
        <mo>′</mo>
       </msubsup>
       <mi>Q</mi>
      </mrow>
     </mfrac>
     <mfrac>
      <mn>1</mn>
      <msup>
       <mi>L</mi>
       <mo>′</mo>
      </msup>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>L</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>L</ci>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ω</ci>
           <ci>c</ci>
          </apply>
          <ci>normal-′</ci>
         </apply>
         <ci>Q</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>L</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>C</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ω</ci>
          <ci>c</ci>
         </apply>
         <ci>normal-′</ci>
        </apply>
        <ci>Q</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>L</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{\prime}\to L=\frac{\omega_{c}^{\prime}Q}{\omega_{0}}L^{\prime}\,,\,C=\frac{%
1}{\omega_{0}\omega_{c}^{\prime}Q}\frac{1}{L^{\prime}}
  </annotation>
 </semantics>
</math>

</p>

<p>and capacitors are transformed into parallel resonators,</p>

<p>

<math display="inline" id="Prototype_filter:20">
 <semantics>
  <mrow>
   <msup>
    <mi>C</mi>
    <mo>′</mo>
   </msup>
   <mo>→</mo>
   <mi>C</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msubsup>
      <mi>ω</mi>
      <mi>c</mi>
      <mo>′</mo>
     </msubsup>
     <mi>Q</mi>
    </mrow>
    <msub>
     <mi>ω</mi>
     <mn>0</mn>
    </msub>
   </mfrac>
   <mpadded width="+1.7pt">
    <msup>
     <mi>C</mi>
     <mo>′</mo>
    </msup>
   </mpadded>
   <mrow>
    <mo fence="true" rspace="4.2pt">∥</mo>
    <mi>L</mi>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <msub>
       <mi>ω</mi>
       <mn>0</mn>
      </msub>
      <msubsup>
       <mi>ω</mi>
       <mi>c</mi>
       <mo>′</mo>
      </msubsup>
      <mi>Q</mi>
     </mrow>
    </mfrac>
    <mfrac>
     <mn>1</mn>
     <msup>
      <mi>C</mi>
      <mo>′</mo>
     </msup>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>C</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>normal-→</ci>
    <csymbol cd="unknown">C</csymbol>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>c</ci>
       </apply>
       <ci>normal-′</ci>
      </apply>
      <ci>Q</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>C</ci>
     <ci>normal-′</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-∥</ci>
     <csymbol cd="unknown">L</csymbol>
     <eq></eq>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <ci>c</ci>
        </apply>
        <ci>normal-′</ci>
       </apply>
       <ci>Q</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>C</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{\prime}\to C=\frac{\omega_{c}^{\prime}Q}{\omega_{0}}C^{\prime}\,\lVert\,L=%
\frac{1}{\omega_{0}\omega_{c}^{\prime}Q}\frac{1}{C^{\prime}}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="lowpass-to-bandstop">Lowpass to bandstop</h3>

<p>The required frequency transformation for lowpass to bandstop is:<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> 

<math display="inline" id="Prototype_filter:21">
 <semantics>
  <mrow>
   <mfrac>
    <msubsup>
     <mi>ω</mi>
     <mi>c</mi>
     <mo>′</mo>
    </msubsup>
    <mrow>
     <mi>i</mi>
     <mi>ω</mi>
    </mrow>
   </mfrac>
   <mo>→</mo>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mfrac>
       <mrow>
        <mi>i</mi>
        <mi>ω</mi>
       </mrow>
       <msub>
        <mi>ω</mi>
        <mn>0</mn>
       </msub>
      </mfrac>
      <mo>+</mo>
      <mstyle displaystyle="true">
       <mfrac>
        <msub>
         <mi>ω</mi>
         <mn>0</mn>
        </msub>
        <mrow>
         <mi>i</mi>
         <mi>ω</mi>
        </mrow>
       </mfrac>
      </mstyle>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <ci>c</ci>
      </apply>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>ω</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <plus></plus>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>ω</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>ω</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\omega_{c}^{\prime}}{i\omega}\to Q\left(\frac{i\omega}{\omega_{0}}+%
\dfrac{\omega_{0}}{i\omega}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>Inductors are transformed into parallel resonators,</p>

<p>

<math display="inline" id="Prototype_filter:22">
 <semantics>
  <mrow>
   <msup>
    <mi>L</mi>
    <mo>′</mo>
   </msup>
   <mo>→</mo>
   <mi>L</mi>
   <mo>=</mo>
   <mfrac>
    <msubsup>
     <mi>ω</mi>
     <mi>c</mi>
     <mo>′</mo>
    </msubsup>
    <mrow>
     <msub>
      <mi>ω</mi>
      <mn>0</mn>
     </msub>
     <mi>Q</mi>
    </mrow>
   </mfrac>
   <mpadded width="+1.7pt">
    <msup>
     <mi>L</mi>
     <mo>′</mo>
    </msup>
   </mpadded>
   <mrow>
    <mo fence="true" rspace="4.2pt">∥</mo>
    <mi>C</mi>
    <mo>=</mo>
    <mfrac>
     <mi>Q</mi>
     <mrow>
      <msub>
       <mi>ω</mi>
       <mn>0</mn>
      </msub>
      <msubsup>
       <mi>ω</mi>
       <mi>c</mi>
       <mo>′</mo>
      </msubsup>
     </mrow>
    </mfrac>
    <mfrac>
     <mn>1</mn>
     <msup>
      <mi>L</mi>
      <mo>′</mo>
     </msup>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>L</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>normal-→</ci>
    <csymbol cd="unknown">L</csymbol>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <ci>c</ci>
      </apply>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>Q</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>L</ci>
     <ci>normal-′</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-∥</ci>
     <csymbol cd="unknown">C</csymbol>
     <eq></eq>
     <apply>
      <divide></divide>
      <ci>Q</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <ci>c</ci>
        </apply>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>L</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{\prime}\to L=\frac{\omega_{c}^{\prime}}{\omega_{0}Q}L^{\prime}\,\lVert\,C=%
\frac{Q}{\omega_{0}\omega_{c}^{\prime}}\frac{1}{L^{\prime}}
  </annotation>
 </semantics>
</math>

</p>

<p>and capacitors are transformed into series resonators,</p>

<p>

<math display="inline" id="Prototype_filter:23">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>C</mi>
     <mo>′</mo>
    </msup>
    <mo>→</mo>
    <mi>C</mi>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <msubsup>
       <mi>ω</mi>
       <mi>c</mi>
       <mo>′</mo>
      </msubsup>
      <mrow>
       <msub>
        <mi>ω</mi>
        <mn>0</mn>
       </msub>
       <mi>Q</mi>
      </mrow>
     </mfrac>
     <mpadded width="+1.7pt">
      <msup>
       <mi>C</mi>
       <mo>′</mo>
      </msup>
     </mpadded>
    </mrow>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mrow>
    <mi>L</mi>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mi>Q</mi>
      <mrow>
       <msub>
        <mi>ω</mi>
        <mn>0</mn>
       </msub>
       <msubsup>
        <mi>ω</mi>
        <mi>c</mi>
        <mo>′</mo>
       </msubsup>
      </mrow>
     </mfrac>
     <mfrac>
      <mn>1</mn>
      <msup>
       <mi>C</mi>
       <mo>′</mo>
      </msup>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>C</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>C</ci>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ω</ci>
          <ci>c</ci>
         </apply>
         <ci>normal-′</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ω</ci>
          <cn type="integer">0</cn>
         </apply>
         <ci>Q</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>C</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>L</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>Q</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ω</ci>
          <ci>c</ci>
         </apply>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>C</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{\prime}\to C=\frac{\omega_{c}^{\prime}}{\omega_{0}Q}C^{\prime}\,,\,L=\frac{%
Q}{\omega_{0}\omega_{c}^{\prime}}\frac{1}{C^{\prime}}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="lowpass-to-multi-band">Lowpass to multi-band</h3>

<p>Filters with multiple passbands may be obtained by applying the general transformation:</p>

<p>

<math display="inline" id="Prototype_filter:24">
 <semantics>
  <mrow>
   <mfrac>
    <msubsup>
     <mi>ω</mi>
     <mi>c</mi>
     <mo>′</mo>
    </msubsup>
    <mrow>
     <mi>i</mi>
     <mi>ω</mi>
    </mrow>
   </mfrac>
   <mo>→</mo>
   <mrow>
    <mstyle displaystyle="true">
     <mfrac>
      <mn>1</mn>
      <mrow>
       <msub>
        <mi>Q</mi>
        <mn>1</mn>
       </msub>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mstyle displaystyle="true">
          <mfrac>
           <mrow>
            <mi>i</mi>
            <mi>ω</mi>
           </mrow>
           <msub>
            <mi>ω</mi>
            <mn>01</mn>
           </msub>
          </mfrac>
         </mstyle>
         <mo>+</mo>
         <mstyle displaystyle="true">
          <mfrac>
           <msub>
            <mi>ω</mi>
            <mn>01</mn>
           </msub>
           <mrow>
            <mi>i</mi>
            <mi>ω</mi>
           </mrow>
          </mfrac>
         </mstyle>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mstyle>
    <mo>+</mo>
    <mstyle displaystyle="true">
     <mfrac>
      <mn>1</mn>
      <mrow>
       <msub>
        <mi>Q</mi>
        <mn>2</mn>
       </msub>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mstyle displaystyle="true">
          <mfrac>
           <mrow>
            <mi>i</mi>
            <mi>ω</mi>
           </mrow>
           <msub>
            <mi>ω</mi>
            <mn>02</mn>
           </msub>
          </mfrac>
         </mstyle>
         <mo>+</mo>
         <mstyle displaystyle="true">
          <mfrac>
           <msub>
            <mi>ω</mi>
            <mn>02</mn>
           </msub>
           <mrow>
            <mi>i</mi>
            <mi>ω</mi>
           </mrow>
          </mfrac>
         </mstyle>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mstyle>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <ci>c</ci>
      </apply>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>ω</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>ω</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ω</ci>
          <cn type="integer">01</cn>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ω</ci>
          <cn type="integer">01</cn>
         </apply>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>ω</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>ω</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ω</ci>
          <cn type="integer">02</cn>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ω</ci>
          <cn type="integer">02</cn>
         </apply>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>ω</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\omega_{c}^{\prime}}{i\omega}\to\dfrac{1}{Q_{1}\left(\dfrac{i\omega}{%
\omega_{01}}+\dfrac{\omega_{01}}{i\omega}\right)}+\dfrac{1}{Q_{2}\left(\dfrac{%
i\omega}{\omega_{02}}+\dfrac{\omega_{02}}{i\omega}\right)}+\cdots
  </annotation>
 </semantics>
</math>

</p>

<p>The number of resonators in the expression corresponds to the number of passbands required. Lowpass and highpass filters can be viewed as special cases of the resonator expression with one or the other of the terms becoming zero as appropriate. Bandstop filters can be regarded as a combination of a lowpass and a highpass filter. Multiple bandstop filters can always be expressed in terms of a multiple bandpass filter. In this way it, can be seen that this transformation represents the general case for any bandform, and all the other transformations are to be viewed as special cases of it.</p>

<p>The same response can equivalently be obtained, sometimes with a more convenient component topology, by transforming to multiple stopbands instead of multiple passbands. The required transformation in those cases is:</p>

<p>

<math display="inline" id="Prototype_filter:25">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>i</mi>
     <mi>ω</mi>
    </mrow>
    <msubsup>
     <mi>ω</mi>
     <mi>c</mi>
     <mo>′</mo>
    </msubsup>
   </mfrac>
   <mo>→</mo>
   <mrow>
    <mstyle displaystyle="true">
     <mfrac>
      <mn>1</mn>
      <mrow>
       <msub>
        <mi>Q</mi>
        <mn>1</mn>
       </msub>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mstyle displaystyle="true">
          <mfrac>
           <mrow>
            <mi>i</mi>
            <mi>ω</mi>
           </mrow>
           <msub>
            <mi>ω</mi>
            <mn>01</mn>
           </msub>
          </mfrac>
         </mstyle>
         <mo>+</mo>
         <mstyle displaystyle="true">
          <mfrac>
           <msub>
            <mi>ω</mi>
            <mn>01</mn>
           </msub>
           <mrow>
            <mi>i</mi>
            <mi>ω</mi>
           </mrow>
          </mfrac>
         </mstyle>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mstyle>
    <mo>+</mo>
    <mstyle displaystyle="true">
     <mfrac>
      <mn>1</mn>
      <mrow>
       <msub>
        <mi>Q</mi>
        <mn>2</mn>
       </msub>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mstyle displaystyle="true">
          <mfrac>
           <mrow>
            <mi>i</mi>
            <mi>ω</mi>
           </mrow>
           <msub>
            <mi>ω</mi>
            <mn>02</mn>
           </msub>
          </mfrac>
         </mstyle>
         <mo>+</mo>
         <mstyle displaystyle="true">
          <mfrac>
           <msub>
            <mi>ω</mi>
            <mn>02</mn>
           </msub>
           <mrow>
            <mi>i</mi>
            <mi>ω</mi>
           </mrow>
          </mfrac>
         </mstyle>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mstyle>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>ω</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <ci>c</ci>
      </apply>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>ω</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ω</ci>
          <cn type="integer">01</cn>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ω</ci>
          <cn type="integer">01</cn>
         </apply>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>ω</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>ω</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ω</ci>
          <cn type="integer">02</cn>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ω</ci>
          <cn type="integer">02</cn>
         </apply>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>ω</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{i\omega}{\omega_{c}^{\prime}}\to\dfrac{1}{Q_{1}\left(\dfrac{i\omega}{%
\omega_{01}}+\dfrac{\omega_{01}}{i\omega}\right)}+\dfrac{1}{Q_{2}\left(\dfrac{%
i\omega}{\omega_{02}}+\dfrac{\omega_{02}}{i\omega}\right)}+\cdots
  </annotation>
 </semantics>
</math>

</p>
<h2 id="alternative-prototype">Alternative prototype</h2>

<p>In his treatment of <a href="Composite_image_filter" title="wikilink">image filters</a>, <a href="Otto_Zobel" title="wikilink">Zobel</a> provided an alternative basis for constructing a prototype which is not based in the <a href="frequency_domain" title="wikilink">frequency domain</a>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> The Zobel prototypes do not, therefore, correspond to any particular bandform, but they can be transformed into any of them. Not giving special significance to any one bandform makes the method more mathematically pleasing; however, it is not in common use.</p>

<p>The Zobel prototype considers filter sections, rather than components. That is, the transformation is carried out on a <a href="two-port_network" title="wikilink">two-port network</a> rather than a two-terminal inductor or capacitor. The transfer function is expressed in terms of the product of the series <a href="Electrical_impedance" title="wikilink">impedance</a>, Z, and the shunt <a class="uri" href="admittance" title="wikilink">admittance</a> Y of a filter half-section. See the article <a href="Image_impedance" title="wikilink">Image impedance</a> for a description of half-sections. This quantity is <a href="Nondimensionalization" title="wikilink">nondimensional</a>, adding to the prototype's generality. Generally, ZY is a complex quantity,</p>

<p>

<math display="inline" id="Prototype_filter:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>Z</mi>
    <mi>Y</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>U</mi>
    <mo>+</mo>
    <mrow>
     <mi>i</mi>
     <mi>V</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Z</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>U</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ZY=U+iV\,\!
  </annotation>
 </semantics>
</math>

 and as <em>U</em> and <em>V</em> are both, in general, functions of <em>ω</em> we should properly write,</p>

<p>

<math display="inline" id="Prototype_filter:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>Z</mi>
    <mi>Y</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>U</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>i</mi>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Z</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>U</ci>
      <ci>ω</ci>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>V</ci>
      <ci>ω</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ZY=U(\omega)+iV(\omega)\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>With image filters, it is possible to obtain filters of different classes from the <a href="constant_k_filter" title="wikilink">constant k filter</a> prototype by means of a different kind of transformation (see <a href="composite_image_filter" title="wikilink">composite image filter</a>), constant k being those filters for which Z/Y is a constant. For this reason, filters of all classes are given in terms of <em>U(ω)</em> for a constant k, which is notated as,</p>

<p>

<math display="inline" id="Prototype_filter:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>Z</mi>
    <mi>Y</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>U</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>i</mi>
     <msub>
      <mi>V</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Z</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <ci>k</ci>
      </apply>
      <ci>ω</ci>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>k</ci>
      </apply>
      <ci>ω</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ZY=U_{k}(\omega)+iV_{k}(\omega)\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>In the case of dissipationless networks, i.e. no resistors, the quantity <em>V(ω)</em> is zero and only <em>U(ω)</em> need be considered. <em>U<sub>k</sub>(ω)</em> ranges from 0 at the centre of the <a class="uri" href="passband" title="wikilink">passband</a> to -1 at the <a href="cut-off_frequency" title="wikilink">cut-off frequency</a> and then continues to increase negatively into the <a class="uri" href="stopband" title="wikilink">stopband</a> regardless of the bandform of the filter being designed. To obtain the required bandform, the following transforms are used:</p>

<p>For a lowpass constant k prototype that is scaled:</p>

<p>

<math display="inline" id="Prototype_filter:29">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>R</mi>
     <mn>0</mn>
    </msub>
    <mo>=</mo>
    <mpadded width="+1.7pt">
     <mn>1</mn>
    </mpadded>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mrow>
    <msub>
     <mi>ω</mi>
     <mi>c</mi>
    </msub>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>c</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{0}=1\,,\,\omega_{c}=1
  </annotation>
 </semantics>
</math>

</p>

<p>the independent variable of the response plot is,</p>

<p>

<math display="inline" id="Prototype_filter:30">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>U</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <msup>
     <mi>ω</mi>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>k</ci>
     </apply>
     <ci>ω</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ω</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{k}(\omega)=-\omega^{2}\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>The bandform transformations from this prototype are,</p>

<p>for lowpass, 

<math display="inline" id="Prototype_filter:31">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>U</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <msup>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mrow>
       <mi>i</mi>
       <mi>ω</mi>
      </mrow>
      <msub>
       <mi>ω</mi>
       <mi>c</mi>
      </msub>
     </mfrac>
     <mo>)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>k</ci>
     </apply>
     <ci>ω</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>ω</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <ci>c</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{k}(\omega)\to\left(\frac{i\omega}{\omega_{c}}\right)^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>for highpass, 

<math display="inline" id="Prototype_filter:32">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>U</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <msup>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <msub>
       <mi>ω</mi>
       <mi>c</mi>
      </msub>
      <mrow>
       <mi>i</mi>
       <mi>ω</mi>
      </mrow>
     </mfrac>
     <mo>)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>k</ci>
     </apply>
     <ci>ω</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <ci>c</ci>
      </apply>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>ω</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{k}(\omega)\to\left(\frac{\omega_{c}}{i\omega}\right)^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>and for bandpass, 

<math display="inline" id="Prototype_filter:33">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>U</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>Q</mi>
     <mn>2</mn>
    </msup>
    <msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mfrac>
        <mrow>
         <mi>i</mi>
         <mi>ω</mi>
        </mrow>
        <msub>
         <mi>ω</mi>
         <mn>0</mn>
        </msub>
       </mfrac>
       <mo>+</mo>
       <mfrac>
        <msub>
         <mi>ω</mi>
         <mn>0</mn>
        </msub>
        <mrow>
         <mi>i</mi>
         <mi>ω</mi>
        </mrow>
       </mfrac>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>k</ci>
     </apply>
     <ci>ω</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Q</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>ω</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>ω</ci>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{k}(\omega)\to Q^{2}\left(\frac{i\omega}{\omega_{0}}+\frac{\omega_{0}}{i%
\omega}\right)^{2}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Electronic_filter_topology" title="wikilink">Electronic filter topology</a></li>
<li><a href="Electronic_filter" title="wikilink">Electronic filter</a></li>
<li><a href="Linear_filter" title="wikilink">Linear filter</a></li>
<li><a href="Composite_image_filter" title="wikilink">Composite image filter</a></li>
</ul>

<p> </p>
<h2 id="footnotes">Footnotes</h2>
<h2 id="references">References</h2>
<h2 id="bibliography">Bibliography</h2>
<ul>
<li>Zobel, O J, "Theory and Design of Uniform and Composite Electric Wave Filters", <em>Bell Systems Technical Journal</em>, <strong>vol.2</strong> (1923), pp. 1–46.</li>
<li>Zobel, O J, "Electrical wave filters", US patent 1 850 146, filed 25 Nov 1930, issued 22 Mar 1932. Gives many useful formulae and a non-frequency domain basis for defining prototypes.</li>
<li>Matthaei, Young, Jones <em>Microwave Filters, Impedance-Matching Networks, and Coupling Structures</em> McGraw-Hill 1964.</li>
<li>Farago, P S, <em>An Introduction to Linear Network Analysis</em>, English Universities Press, 1961.</li>
</ul>

<p>"</p>

<p><a href="Category:Linear_filters" title="wikilink">Category:Linear filters</a> <a href="Category:Image_impedance_filters" title="wikilink">Category:Image impedance filters</a> <a href="Category:Filter_theory" title="wikilink">Category:Filter theory</a> <a href="Category:Analog_circuits" title="wikilink">Category:Analog circuits</a> <a href="Category:Electronic_design" title="wikilink">Category:Electronic design</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">The class of a filter is the mathematical class of the polynomials in the <a href="rational_function" title="wikilink">rational function</a> that describe its <a href="transfer_function" title="wikilink">transfer function</a>. Image parameter filters are not rational and hence do not have a polynomial class. Such filters are classified by type (<a href="k-type_filter" title="wikilink">k-type</a>, <a href="m-type_filter" title="wikilink">m-type</a> etc). <em>Type</em> serves as the class name for image filters and is based on the filter circuit topology.<a href="#fnref1">↩</a></li>
<li id="fn2">The order of a filter is the <a href="degree_of_a_polynomial" title="wikilink">order</a> of the filter's rational function. A rational function is a ratio of two <a href="polynomial" title="wikilink">polynomials</a> and the order of the function is the order of the highest order polynomial. Any filter constructed from a finite number of discrete elements will be described by a rational function and in general, the order will be equal to the number of <a href="electrical_reactance" title="wikilink">reactive</a> elements that are used.<a href="#fnref2">↩</a></li>
<li id="fn3">Matthaei <em>et al.</em>, pp.96-97.<a href="#fnref3">↩</a></li>
<li id="fn4">Matthaei <em>et al.</em>, pp.412-413.<a href="#fnref4">↩</a></li>
<li id="fn5">Matthaei <em>et al.</em>, pp.438-440.<a href="#fnref5">↩</a></li>
<li id="fn6">Farago, p.69.<a href="#fnref6">↩</a></li>
<li id="fn7">Matthaei <em>et al.</em>, pp.727-729.<a href="#fnref7">↩</a></li>
<li id="fn8">Zobel, 1930, p. 3.<a href="#fnref8">↩</a></li>
</ol>
</section>
</body>
</html>
