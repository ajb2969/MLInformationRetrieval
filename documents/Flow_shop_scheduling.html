<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="40">Flow shop scheduling</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Flow shop scheduling</h1>
<hr/>

<p><strong>Flow shop scheduling</strong> problems, are a class of <a href="Scheduling_(production_processes)" title="wikilink">scheduling</a> problems with a <a class="uri" href="workshop" title="wikilink">workshop</a> or <a href="group_shop" title="wikilink">group shop</a> in which the flow control shall enable an appropriate sequencing for each job and for processing on a set of <a href="machine" title="wikilink">machines</a> or with other <a href="resource" title="wikilink">resources</a> <em>1,2,...,m</em> in compliance with given processing orders. Especially the maintaining of a continuous flow of processing tasks is desired with a minimum of <em>idle time</em> and a minimum of <em>waiting time</em>. Flow shop scheduling is a special case of <a href="job_shop_scheduling" title="wikilink">job shop scheduling</a> where there is strict order of all operations to be performed on all jobs. Flow shop scheduling may apply as well to <a href="Manufacturing" title="wikilink">production</a> facilities as to <a class="uri" href="computing" title="wikilink">computing</a> designs.</p>

<p>A special type of flow shop scheduling problem is the permutation flow shop scheduling problem in which the <a href="Process_(engineering)" title="wikilink">processing</a> order of the jobs on the resources is the same for each subsequent step of processing.</p>
<h2 id="sequencing-performance-measurements-γ">Sequencing Performance Measurements (γ)</h2>

<p>The sequencing problem can be stated as determining a sequence S such that one or several sequencing objectives are optimized.</p>
<ol>
<li>(Average)Flow time, 

<math display="inline" id="Flow_shop_scheduling:0">
 <semantics>
  <mrow>
   <mo largeop="true" symmetric="true">∑</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>w</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>F</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <sum></sum>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum(w_{i})F_{i}
  </annotation>
 </semantics>
</math>

</li>
<li>Makespan,C<sub>max</sub></li>
<li>(Average) Tardiness, 

<math display="inline" id="Flow_shop_scheduling:1">
 <semantics>
  <mrow>
   <mo largeop="true" symmetric="true">∑</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>w</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>T</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <sum></sum>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum(w_{i})T_{i}
  </annotation>
 </semantics>
</math>

</li>
<li>....</li>
</ol>

<p>detailed discussion of performance measurement can be found in Malakooti (2013).</p>
<h2 id="complexity-of-flow-shop-scheduling">Complexity of flow shop scheduling</h2>

<p>As presented by Garey et al. (1976), most of extensions of the flow shop scheduling problems are Np-Hard and few of them can be solved optimally in O(nlogn), for example F2|prmu|C<sub>max</sub> can be solved optimally by using <a href="Johnson's_Rule" title="wikilink">Johnson's Rule</a>.</p>
<h2 id="solution-methods">Solution Methods</h2>

<p>The proposed methods to solve flow shop scheduling problems can be classified to <a href="exact_methods" title="wikilink">exact methods</a> such as <a href="Branch_and_Bound" title="wikilink">Branch and Bound</a> and <a href="dynamic_programming" title="wikilink">dynamic programming</a>, <a href="Heuristic_algorithms" title="wikilink">Heuristic algorithms</a> and <a class="uri" href="metaheuristics" title="wikilink">metaheuristics</a>.</p>
<h3 id="minimizing-makespancmax">Minimizing makespan,C<sub>max</sub></h3>

<p>F2|prmu|C<sub>max</sub> and F3|prmu|C<sub>max</sub> can be solved optimally by using Johnson's Rule (1954) but for general case there is no algorithm that grantee the optimality of the solution.<br/>
Here is minimization using Johnson's Rule<br/>
The flow shop contains n jobs simultaneously available at time zero and to be processed by two machines arranged in series with unlimited storage in between them. The processing time of all jobs are known with certainty. It is required to schedule n jobs on machines so as to minimize makespan. The Johnson's rule for scheduling jobs in two machine flow shop is given below: In an optimal schedule, job i precedes job j if <em>min{p<sub>i1</sub>,p<sub>j2</sub>} j1,p<sub>i2</sub>}</em>. Where as, p<sub>i1</sub> is the processing time of job i on machine 1 and p<sub>i2</sub> is the processing time of job i on machine 2. Similarly, p<sub>j1</sub> and p<sub>j2</sub> are processing times of job j on machine 1 and machine 2 respectively.<br/>
The steps are summarized below for Johnson's algorithms:<br/>
let, p<sub>1j</sub>=processing time of job j on machine 1<br/>
p<sub>2j</sub>=processing time of job j on machine 2<br/>
Johnson's Algorithm<br/>
Step 1:Form set1 containing all the jobs with p<sub>1j</sub> 2j<br/>
Step 2:Form set2 containing all the jobs with p<sub>1j</sub> &gt; p<sub>2j</sub>,the jobs with p<sub>1j</sub>=p<sub>2j</sub> may be put in either set.<br/>
Step 3: Form the sequence as follows:<br/>
i) The job in set1 go first in the sequence and they go in increasing order of p<sub>1j</sub>(SPT)<br/>
ii) The jobs in set2 follow in decreasing order of p<sub>2j</sub> (LPT). Ties are broken arbitrarily.<br/>
This type schedule is referred as SPT(1)-LPT(2) schedule.</p>
<h3 id="other-objectives">Other objectives</h3>

<p>So far, there is no algorithm which can guarantee optimal solution.</p>

<p>The detailed discussion of the available solution methods are provided by Malakooti (2013).</p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>Malakooti, B (2013). Operations and Production Systems with Multiple Objectives. John Wiley &amp; Sons. ISBN 978-1-118-58537-5.</li>
<li>Garey, M. R., Johnson, D. S., &amp; Sethi, R. (1976). The complexity of flowshop and jobshop scheduling. Mathematics of operations research, 1(2), 117-129.</li>
<li>Johnson, S. M. (1954). Optimal two‐and three‐stage production schedules with setup times included. Naval research logistics quarterly, 1(1), 61-68.</li>
<li><a class="uri" href="http://faculty.ksu.edu.sa/ialharkan/IE428/Chapter_4.pdf">http://faculty.ksu.edu.sa/ialharkan/IE428/Chapter_4.pdf</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://posh-wolf.herokuapp.com/">Posh Wolf</a> - online flow shop solver with real-time visualization</li>
</ul>

<p>"</p>

<p><a href="Category:Operations_research" title="wikilink">Category:Operations research</a> <a href="Category:Scheduling_(computing)" title="wikilink">Category:Scheduling (computing)</a> <a href="Category:Workflow_technology" title="wikilink">Category:Workflow technology</a> <a href="Category:NP-hard_problems" title="wikilink">Category:NP-hard problems</a></p>
</body>
</html>
