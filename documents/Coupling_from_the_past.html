<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="490">Coupling from the past</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Coupling from the past</h1>
<hr/>

<p>Among <a href="Markov_chain_Monte_Carlo" title="wikilink">Markov chain Monte Carlo</a> (MCMC) <a class="uri" href="algorithms" title="wikilink">algorithms</a>, <strong>coupling from the past</strong> is a method for <a href="sampling_(statistics)" title="wikilink">sampling</a> from the stationary distribution of a <a href="Markov_chain" title="wikilink">Markov chain</a>. Contrary to many MCMC algorithms, coupling from the past gives in principle a perfect sample from the <a href="stationary_distribution" title="wikilink">stationary distribution</a> . It was invented by <a href="James_Propp" title="wikilink">James Propp</a> and <a href="David_Bruce_Wilson" title="wikilink">David Wilson</a> in 1996.</p>
<h2 id="the-basic-idea">The basic idea</h2>

<p>Consider a finite state <a href="Markov_chain" title="wikilink">irreducible</a> <a href="Markov_chain" title="wikilink">aperiodic</a> Markov chain 

<math display="inline" id="Coupling_from_the_past:0">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 with state space 

<math display="inline" id="Coupling_from_the_past:1">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 and (unique) stationary distribution 

<math display="inline" id="Coupling_from_the_past:2">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 (

<math display="inline" id="Coupling_from_the_past:3">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 is a probability vector). Suppose that we come up with a probability distribution 

<math display="inline" id="Coupling_from_the_past:4">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 on the set of maps 

<math display="inline" id="Coupling_from_the_past:5">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>S</mi>
    <mo>→</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>S</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:S\to S
  </annotation>
 </semantics>
</math>

 with the property that for every fixed 

<math display="inline" id="Coupling_from_the_past:6">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in S
  </annotation>
 </semantics>
</math>

, its image 

<math display="inline" id="Coupling_from_the_past:7">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(s)
  </annotation>
 </semantics>
</math>

 is distributed according to the transition probability of 

<math display="inline" id="Coupling_from_the_past:8">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 from state 

<math display="inline" id="Coupling_from_the_past:9">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

. An example of such a probability distribution is the one where 

<math display="inline" id="Coupling_from_the_past:10">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(s)
  </annotation>
 </semantics>
</math>

 is <a href="independent_(probability)" title="wikilink">independent</a> from 

<math display="inline" id="Coupling_from_the_past:11">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(s^{\prime})
  </annotation>
 </semantics>
</math>

 whenever 

<math display="inline" id="Coupling_from_the_past:12">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>≠</mo>
   <msup>
    <mi>s</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>s</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\neq s^{\prime}
  </annotation>
 </semantics>
</math>

, but it is often worthwhile to consider other distributions. Now let 

<math display="inline" id="Coupling_from_the_past:13">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{j}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Coupling_from_the_past:14">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>∈</mo>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>j</ci>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j\in\mathbb{Z}
  </annotation>
 </semantics>
</math>

 be independent samples from 

<math display="inline" id="Coupling_from_the_past:15">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

.</p>

<p>Suppose that 

<math display="inline" id="Coupling_from_the_past:16">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is chosen randomly according to 

<math display="inline" id="Coupling_from_the_past:17">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 and is independent from the sequence 

<math display="inline" id="Coupling_from_the_past:18">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{j}
  </annotation>
 </semantics>
</math>

. (We do not worry for now where this 

<math display="inline" id="Coupling_from_the_past:19">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is coming from.) Then 

<math display="inline" id="Coupling_from_the_past:20">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{-1}(x)
  </annotation>
 </semantics>
</math>

 is also distributed according to 

<math display="inline" id="Coupling_from_the_past:21">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

, because 

<math display="inline" id="Coupling_from_the_past:22">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Coupling_from_the_past:23">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

-stationary and our assumption on the law of 

<math display="inline" id="Coupling_from_the_past:24">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

. Define</p>

<p>

<math display="block" id="Coupling_from_the_past:25">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>F</mi>
     <mi>j</mi>
    </msub>
    <mo>:=</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>∘</mo>
     <msub>
      <mi>f</mi>
      <mrow>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
     </msub>
     <mo>∘</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>∘</mo>
     <msub>
      <mi>f</mi>
      <mrow>
       <mo>-</mo>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{j}:=f_{-1}\circ f_{-2}\circ\cdots\circ f_{-j}.
  </annotation>
 </semantics>
</math>

 Then it follows by induction that 

<math display="inline" id="Coupling_from_the_past:26">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mi>j</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>j</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{j}(x)
  </annotation>
 </semantics>
</math>

 is also distributed according to 

<math display="inline" id="Coupling_from_the_past:27">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 for every 

<math display="inline" id="Coupling_from_the_past:28">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>∈</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>j</ci>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j\in\mathbb{N}
  </annotation>
 </semantics>
</math>

. Now here is the main point. It may happen that for some 

<math display="inline" id="Coupling_from_the_past:29">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>∈</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>n</ci>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\in\mathbb{N}
  </annotation>
 </semantics>
</math>

 the image of the map 

<math display="inline" id="Coupling_from_the_past:30">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{n}
  </annotation>
 </semantics>
</math>

 is a single element of 

<math display="inline" id="Coupling_from_the_past:31">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

. In other words, 

<math display="inline" id="Coupling_from_the_past:32">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>F</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>F</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{n}(x)=F_{n}(y)
  </annotation>
 </semantics>
</math>

 for each 

<math display="inline" id="Coupling_from_the_past:33">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in S
  </annotation>
 </semantics>
</math>

. Therefore, we do not need to have access to 

<math display="inline" id="Coupling_from_the_past:34">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 in order to compute 

<math display="inline" id="Coupling_from_the_past:35">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>n</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{n}(x)
  </annotation>
 </semantics>
</math>

. The algorithm then involves finding some 

<math display="inline" id="Coupling_from_the_past:36">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>∈</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>n</ci>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\in\mathbb{N}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Coupling_from_the_past:37">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>n</ci>
    </apply>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{n}(S)
  </annotation>
 </semantics>
</math>

 is a <a href="singleton_(mathematics)" title="wikilink">singleton</a>, and outputing the element of that singleton. The design of a good distribution 

<math display="inline" id="Coupling_from_the_past:38">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 for which the task of finding such an 

<math display="inline" id="Coupling_from_the_past:39">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 and computing 

<math display="inline" id="Coupling_from_the_past:40">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{n}
  </annotation>
 </semantics>
</math>

 is not too costly is not always obvious, but has been accomplished successfully in several important instances.</p>
<h2 id="the-monotone-case">The monotone case</h2>

<p>There is a special class of Markov chains in which there are particularly good choices for 

<math display="inline" id="Coupling_from_the_past:41">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 and a tool for determining if 

<math display="inline" id="Coupling_from_the_past:42">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>F</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>n</ci>
      </apply>
      <ci>S</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |F_{n}(S)|=1
  </annotation>
 </semantics>
</math>

. (Here 

<math display="inline" id="Coupling_from_the_past:43">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mo>⋅</mo>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <ci>normal-⋅</ci>
    <ci>normal-|</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\cdot|
  </annotation>
 </semantics>
</math>

 denotes <a href="cardinal_number" title="wikilink">cardinality</a>.) Suppose that 

<math display="inline" id="Coupling_from_the_past:44">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is a <a href="partially_ordered_set" title="wikilink">partially ordered set</a> with order 

<math display="inline" id="Coupling_from_the_past:45">
 <semantics>
  <mo>≤</mo>
  <annotation-xml encoding="MathML-Content">
   <leq></leq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq
  </annotation>
 </semantics>
</math>

, which has a unique minimal element 

<math display="inline" id="Coupling_from_the_past:46">
 <semantics>
  <msub>
   <mi>s</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{0}
  </annotation>
 </semantics>
</math>

 and a unique maximal element 

<math display="inline" id="Coupling_from_the_past:47">
 <semantics>
  <msub>
   <mi>s</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{1}
  </annotation>
 </semantics>
</math>

; that is, every 

<math display="inline" id="Coupling_from_the_past:48">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in S
  </annotation>
 </semantics>
</math>

 satisfies 

<math display="inline" id="Coupling_from_the_past:49">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mn>0</mn>
   </msub>
   <mo>≤</mo>
   <mi>s</mi>
   <mo>≤</mo>
   <msub>
    <mi>s</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>s</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{0}\leq s\leq s_{1}
  </annotation>
 </semantics>
</math>

. Also, suppose that 

<math display="inline" id="Coupling_from_the_past:50">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 may be chosen to be supported on the set of <a href="monotone_function" title="wikilink">monotone</a> maps 

<math display="inline" id="Coupling_from_the_past:51">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>S</mi>
    <mo>→</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>S</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:S\to S
  </annotation>
 </semantics>
</math>

. Then it is easy to see that 

<math display="inline" id="Coupling_from_the_past:52">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>F</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>n</ci>
      </apply>
      <ci>S</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |F_{n}(S)|=1
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Coupling_from_the_past:53">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>F</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>s</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>F</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>s</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{n}(s_{0})=F_{n}(s_{1})
  </annotation>
 </semantics>
</math>

, since 

<math display="inline" id="Coupling_from_the_past:54">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{n}
  </annotation>
 </semantics>
</math>

 is monotone. Thus, checking this becomes rather easy. The algorithm can proceed by choosing 

<math display="inline" id="Coupling_from_the_past:55">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>:=</mo>
   <msub>
    <mi>n</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>n</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n:=n_{0}
  </annotation>
 </semantics>
</math>

 for some constant 

<math display="inline" id="Coupling_from_the_past:56">
 <semantics>
  <msub>
   <mi>n</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{0}
  </annotation>
 </semantics>
</math>

, sampling the maps 

<math display="inline" id="Coupling_from_the_past:57">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>f</mi>
    <mrow>
     <mo>-</mo>
     <mi>n</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{-1},\dots,f_{-n}
  </annotation>
 </semantics>
</math>

, and outputing 

<math display="inline" id="Coupling_from_the_past:58">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>s</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{n}(s_{0})
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Coupling_from_the_past:59">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>F</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>s</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>F</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>s</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{n}(s_{0})=F_{n}(s_{1})
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Coupling_from_the_past:60">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>F</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>s</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mrow>
    <msub>
     <mi>F</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>s</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{n}(s_{0})\neq F_{n}(s_{1})
  </annotation>
 </semantics>
</math>

 the algorithm proceeds by doubling 

<math display="inline" id="Coupling_from_the_past:61">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 and repeating as necessary until an output is obtained. (But the algorithm does not resample the maps 

<math display="inline" id="Coupling_from_the_past:62">
 <semantics>
  <msub>
   <mi>f</mi>
   <mrow>
    <mo>-</mo>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <apply>
     <minus></minus>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{-j}
  </annotation>
 </semantics>
</math>

 which were already sampled; it uses the previously sampled maps when needed.)</p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Monte_Carlo_methods" title="wikilink">Category:Monte Carlo methods</a> <a href="Category:Markov_chain_Monte_Carlo" title="wikilink">Category:Markov chain Monte Carlo</a></p>
</body>
</html>
