<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1483">Inverse transform sampling</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Inverse transform sampling</h1>
<hr/>

<p><strong>Inverse transform sampling</strong> (also known as <strong>inversion sampling</strong>, the <strong>inverse probability integral transform</strong>, the <strong>inverse transformation method</strong>, <strong><a href="Nikolai_Smirnov_(mathematician)" title="wikilink">Smirnov</a> transform</strong>, <strong>golden rule</strong>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>) is a basic method for <a href="pseudo-random_number_sampling" title="wikilink">pseudo-random number sampling</a>, i.e. for generating sample numbers at <a class="uri" href="random" title="wikilink">random</a> from any <a href="probability_distribution" title="wikilink">probability distribution</a> given its <a href="cumulative_distribution_function" title="wikilink">cumulative distribution function</a> (cdf).</p>

<p>The basic idea is to <a href="Continuous_uniform_distribution" title="wikilink">uniformly sample</a> a number 

<math display="inline" id="Inverse_transform_sampling:0">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 between 0 and 1, interpreted as a probability, and then return the largest number 

<math display="inline" id="Inverse_transform_sampling:1">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 from the domain of the distribution 

<math display="inline" id="Inverse_transform_sampling:2">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(X)
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Inverse_transform_sampling:3">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>-</mo>
    <mi mathvariant="normal">∞</mi>
    <mo><</mo>
    <mi>X</mi>
    <mo><</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≤</mo>
   <mi>u</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <minus></minus>
     <infinity></infinity>
     <lt></lt>
     <csymbol cd="unknown">X</csymbol>
     <lt></lt>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <leq></leq>
    <csymbol cd="unknown">u</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(-\infty<X<x)\leq u
  </annotation>
 </semantics>
</math>

. For example, imagine that 

<math display="inline" id="Inverse_transform_sampling:4">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(X)
  </annotation>
 </semantics>
</math>

 is the standard <a href="normal_distribution" title="wikilink">normal distribution</a> (i.e. with <a class="uri" href="mean" title="wikilink">mean</a> 0, <a href="standard_deviation" title="wikilink">standard deviation</a> 1). Then if we choose 

<math display="inline" id="Inverse_transform_sampling:5">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>=</mo>
   <mn>0.5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>u</ci>
    <cn type="float">0.5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u=0.5
  </annotation>
 </semantics>
</math>

, we would return 0, because 50% of the probability of a normal distribution occurs in the region where 

<math display="inline" id="Inverse_transform_sampling:6">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>≤</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>X</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\leq 0
  </annotation>
 </semantics>
</math>

. Similarly, if we choose 

<math display="inline" id="Inverse_transform_sampling:7">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>=</mo>
   <mn>0.975</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>u</ci>
    <cn type="float">0.975</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u=0.975
  </annotation>
 </semantics>
</math>

, we would return 1.95996...; if we choose 

<math display="inline" id="Inverse_transform_sampling:8">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>=</mo>
   <mn>0.995</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>u</ci>
    <cn type="float">0.995</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u=0.995
  </annotation>
 </semantics>
</math>

, we would return 2.5758...; if we choose 

<math display="inline" id="Inverse_transform_sampling:9">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>=</mo>
   <mn>0.999999</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>u</ci>
    <cn type="float">0.999999</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u=0.999999
  </annotation>
 </semantics>
</math>

, we would return 4.7534243...; if we choose 

<math display="inline" id="Inverse_transform_sampling:10">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>=</mo>
   <mn>0.9999995</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>u</ci>
    <cn type="float">0.9999995</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u=0.9999995
  </annotation>
 </semantics>
</math>

, we would return 4.891638...; if we choose 

<math display="inline" id="Inverse_transform_sampling:11">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>=</mo>
   <mn>0.9999999999999997779553951</mn>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mn>52</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>u</ci>
     <cn type="float">0.9999999999999997779553951</cn>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <cn type="integer">52</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u=0.9999999999999997779553951=1-2^{-52}
  </annotation>
 </semantics>
</math>

, we would return 8.1258906647...; if we choose 

<math display="inline" id="Inverse_transform_sampling:12">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>=</mo>
   <mn>0.9999999999999998889776975</mn>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mn>53</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>u</ci>
     <cn type="float">0.9999999999999998889776975</cn>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <cn type="integer">53</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u=0.9999999999999998889776975=1-2^{-53}
  </annotation>
 </semantics>
</math>

, we would return 8.2095361516... etc. Essentially, we are randomly choosing a proportion of the area under the curve and returning the number in the domain such that exactly this proportion of the area occurs to the left of that number. Intuitively, we are unlikely to choose a number in the tails because there is very little area in them: We'd have to pick a number very close to 0 or 1.</p>

<p>Computationally, this method involves computing the <a href="quantile_function" title="wikilink">quantile function</a> of the distribution — in other words, computing the <a href="cumulative_distribution_function" title="wikilink">cumulative distribution function</a> (CDF) of the distribution (which maps a number in the domain to a probability between 0 and 1) and then inverting that function. This is the source of the term "inverse" or "inversion" in most of the names for this method. Note that for a <a href="discrete_distribution" title="wikilink">discrete distribution</a>, computing the CDF is not in general too difficult: We simply add up the individual probabilities for the various points of the distribution. For a <a href="continuous_distribution" title="wikilink">continuous distribution</a>, however, we need to integrate the <a href="probability_density_function" title="wikilink">probability density function</a> (PDF) of the distribution, which is impossible to do analytically for most distributions (including the <a href="normal_distribution" title="wikilink">normal distribution</a>). As a result, this method may be computationally inefficient for many distributions and other methods are preferred; however, it is a useful method for building more generally applicable samplers such as those based on <a href="rejection_sampling" title="wikilink">rejection sampling</a>.</p>

<p>For the <a href="normal_distribution" title="wikilink">normal distribution</a>, the lack of an analytical expression for the corresponding quantile function means that other methods (e.g. the <a href="Box–Muller_transform" title="wikilink">Box–Muller transform</a>) may be preferred computationally. It is often the case that, even for simple distributions, the inverse transform sampling method can be improved on:<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> see, for example, the <a href="ziggurat_algorithm" title="wikilink">ziggurat algorithm</a> and <a href="rejection_sampling" title="wikilink">rejection sampling</a>. On the other hand, it is possible to approximate the quantile function of the normal distribution extremely accurately using moderate-degree polynomials, and in fact the method of doing this is fast enough that inversion sampling is now the default method for sampling from a normal distribution in the statistical package <a href="R_(programming_language)" title="wikilink">R</a>.</p>
<h2 id="definition">Definition</h2>

<p>The <a href="probability_integral_transform" title="wikilink">probability integral transform</a> states that if 

<math display="inline" id="Inverse_transform_sampling:13">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is a <a href="continuous_random_variable" title="wikilink">continuous random variable</a> with <a href="cumulative_distribution_function" title="wikilink">cumulative distribution function</a> 

<math display="inline" id="Inverse_transform_sampling:14">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>X</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{X}
  </annotation>
 </semantics>
</math>

, then the random variable 

<math display="inline" id="Inverse_transform_sampling:15">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>F</mi>
     <mi>X</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Y</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>X</ci>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y=F_{X}(X)
  </annotation>
 </semantics>
</math>

 has a <a href="uniform_distribution_(continuous)" title="wikilink">uniform distribution</a> on [0, 1]. The inverse probability integral transform is just the inverse of this: specifically, if 

<math display="inline" id="Inverse_transform_sampling:16">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 has a uniform distribution on [0, 1] and if 

<math display="inline" id="Inverse_transform_sampling:17">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 has a cumulative distribution 

<math display="inline" id="Inverse_transform_sampling:18">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>X</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{X}
  </annotation>
 </semantics>
</math>

, then the cumulative distribution function of the random variable 

<math display="inline" id="Inverse_transform_sampling:19">
 <semantics>
  <mrow>
   <msubsup>
    <mi>F</mi>
    <mi>X</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{X}^{-1}(Y)
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Inverse_transform_sampling:20">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 .</p>
<h2 id="the-method">The method</h2>

<p>The problem that the inverse transform sampling method solves is as follows:</p>
<ul>
<li>Let <em>X</em> be a <a href="random_variable" title="wikilink">random variable</a> whose distribution can be described by the <a href="cumulative_distribution_function" title="wikilink">cumulative distribution function</a> <em>F</em>.</li>
<li>We want to generate values of <em>X</em> which are distributed according to this distribution.</li>
</ul>

<p>The inverse transform sampling method works as follows:</p>
<ol>
<li><a href="pseudorandom_number_generator" title="wikilink">Generate a random number</a> <em>u</em> from the standard uniform distribution in the interval [0,1].</li>
<li>Compute the value <em>x</em> such that <em>F</em>(<em>x</em>) = <em>u</em>.</li>
<li>Take <em>x</em> to be the random number drawn from the distribution described by <em>F</em>.</li>
</ol>

<p>Expressed differently, given a continuous uniform variable <em>U</em> in [0, 1] and an <a href="Inverse_function" title="wikilink">invertible</a> cumulative distribution function <em>F</em>, the random variable <em>X</em> = <em>F</em><sup> −1</sup>(<em>U</em>) has distribution <em>F</em> (or, <em>X</em> is distributed <em>F</em>).</p>

<p>A treatment of such inverse functions as objects satisfying differential equations can be given.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Some such differential equations admit explicit power series solutions, despite their non-linearity.</p>
<h2 id="proof-of-correctness">Proof of correctness</h2>

<p>Let <em>F</em> be a continuous <a href="cumulative_distribution_function" title="wikilink">cumulative distribution function</a>, and let <em>F</em><sup>−1</sup> be its inverse function (using the <a class="uri" href="infimum" title="wikilink">infimum</a> because CDFs are weakly monotonic and <a href="Càdlàg" title="wikilink">right-continuous</a>):<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>

<math display="inline" id="Inverse_transform_sampling:21">
 <semantics>
  <mrow>
   <mi>Pr</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>F</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>U</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>≤</mo>
     <mi>x</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>Pr</ci>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>F</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>U</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\Pr(F^{-1}(U)\leq x)
  </annotation>
 </semantics>
</math>


 follows the distribution <em>F</em>.</p>

<p><em>Proof:</em></p>

<p>

<math display="inline" id="Inverse_transform_sampling:22">
 <semantics>
  <mrow>
   <msubsup>
    <mi>F</mi>
    <mi>X</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>X</ci>
    </apply>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{-1}_{X}(u)
  </annotation>
 </semantics>
</math>

</p>
<h2 id="reduction-of-the-number-of-inversions">Reduction of the number of inversions</h2>

<p>In order to obtain a large number (lets say M) of samples one needs to perform the same number of inversions 

<math display="inline" id="Inverse_transform_sampling:23">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>X</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{X}
  </annotation>
 </semantics>
</math>

 of the distribtion <span class="LaTeX">$F_X$</span>. One possible way to reduce the number of inversions to only a few while obtaining a large number of samples is the application of the so-called the Stochastic Collocation Monte Carlo sampler (SCMC sampler), within a polynomial chaos expansion framework, allows us the generation of any number of Monte Carlo samples based on only a few inversions of the original distribution and independent samples from a variable for which the inversions are analytically available, like for example the standard normal variable. <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Probability_integral_transform" title="wikilink">Probability integral transform</a></li>
<li><a href="Copula_(statistics)" title="wikilink">Copula</a>, defined by means of probability integral transform.</li>
<li><a href="Quantile_function" title="wikilink">Quantile function</a>, for the explicit construction of inverse CDFs.</li>
<li><a href="Cumulative_distribution_function#Inverse" title="wikilink">Inverse distribution function</a> for a precise mathematical definition for distributions with discrete components.</li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Monte_Carlo_methods" title="wikilink">Category:Monte Carlo methods</a> <a href="Category:Non-uniform_random_numbers" title="wikilink">Category:Non-uniform random numbers</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Aalto University, N. Hyvönen, Computational methods in inverse problems. Twelfth lecture <a class="uri" href="https://noppa.tkk.fi/noppa/kurssi/mat-1.3626/luennot/Mat-1_3626_lecture12.pdf">https://noppa.tkk.fi/noppa/kurssi/mat-1.3626/luennot/Mat-1_3626_lecture12.pdf</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">Steinbrecher, G., Shaw, W.T. (2008). Quantile mechanics. <em>European Journal of Applied Mathematics</em> 19 (2): 87–112.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">L.A. Grzelak, J.A.S. Witteveen, M. Suarez, and C.W. Oosterlee. The stochastic collocation Monte Carlo sampler: Highly efficient sampling from “expensive” distributions. <a class="uri" href="http://papers.ssrn.com/sol3/papers.cfm?abstract_id=2529691">http://papers.ssrn.com/sol3/papers.cfm?abstract_id=2529691</a><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
