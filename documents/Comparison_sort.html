<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1996">Comparison sort</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Comparison sort</h1>
<hr/>

<p> A <strong>comparison sort</strong> is a type of <a href="sorting_algorithm" title="wikilink">sorting algorithm</a> that only reads the list elements through a single abstract comparison operation (often a "less than or equal to" operator or a <a href="three-way_comparison" title="wikilink">three-way comparison</a>) that determines which of two elements should occur first in the final sorted list. The only requirement is that the operator obey two of the properties of a <a href="total_order" title="wikilink">total order</a>:</p>
<ol>
<li>if <em>a</em> ≤ <em>b</em> and <em>b</em> ≤ <em>c</em> then <em>a</em> ≤ <em>c</em> (transitivity)</li>
<li>for all <em>a</em> and <em>b</em>, either <em>a</em> ≤ <em>b</em> or <em>b</em> ≤ <em>a</em> (totalness or <a href="trichotomy_(mathematics)" title="wikilink">trichotomy</a>).</li>
</ol>

<p>It is possible that both <em>a</em> ≤ <em>b</em> and <em>b</em> ≤ <em>a</em>; in this case either may come first in the sorted list. In a <a href="Sorting_algorithm#Stability" title="wikilink">stable sort</a>, the input order determines the sorted order in this case.</p>

<p>A metaphor for thinking about comparison sorts is that someone has a set of unlabelled weights and a <a href="balance_scale" title="wikilink">balance scale</a>. Their goal is to line up the weights in order by their weight without any information except that obtained by placing two weights on the scale and seeing which one is heavier (or if they weigh the same).</p>
<h2 id="examples">Examples</h2>

<p> Some of the most well-known comparison sorts include:</p>
<ul>
<li><a href="Quick_sort" title="wikilink">Quick sort</a></li>
<li><a href="Heap_sort" title="wikilink">Heap sort</a></li>
<li><a href="Merge_sort" title="wikilink">Merge sort</a></li>
<li><a href="Intro_sort" title="wikilink">Intro sort</a></li>
<li><a href="Insertion_sort" title="wikilink">Insertion sort</a></li>
<li><a href="Selection_sort" title="wikilink">Selection sort</a></li>
<li><a href="Bubble_sort" title="wikilink">Bubble sort</a></li>
<li><a href="Odd-even_sort" title="wikilink">Odd-even sort</a></li>
<li><a href="Cocktail_sort" title="wikilink">Cocktail sort</a></li>
<li><a href="Cycle_sort" title="wikilink">Cycle sort</a></li>
<li><a href="Merge_insertion_(Ford-Johnson)_sort" title="wikilink">Merge insertion (Ford-Johnson) sort</a></li>
<li><a class="uri" href="Smoothsort" title="wikilink">Smoothsort</a></li>
<li><a class="uri" href="Timsort" title="wikilink">Timsort</a></li>
</ul>
<h2 id="performance-limits-and-advantages-of-different-sorting-techniques">Performance limits and advantages of different sorting techniques</h2>

<p>There are fundamental limits on the performance of comparison sorts. A comparison sort must have an average-case lower bound of <a href="big-O_notation" title="wikilink">Ω</a>(<em>n</em> log <em>n</em>) comparison operations,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> which is known as <a class="uri" href="linearithmic" title="wikilink">linearithmic</a> time. This is a consequence of the limited information available through comparisons alone — or, to put it differently, of the vague algebraic structure of totally ordered sets. In this sense, mergesort, heapsort, and introsort are <a href="asymptotically_optimal" title="wikilink">asymptotically optimal</a> in terms of the number of comparisons they must perform, although this metric neglects other operations. Non-comparison sorts (such as the examples discussed below) can achieve <a href="big-O_notation" title="wikilink">O</a>(<em>n</em>) performance by using operations other than comparisons, allowing them to sidestep this lower bound (assuming elements are constant-sized).</p>

<p>Note that comparison sorts may run faster on some lists; many <a href="adaptive_sort" title="wikilink">adaptive sorts</a> such as <a href="insertion_sort" title="wikilink">insertion sort</a> run in O(<em>n</em>) time on an already-sorted or nearly-sorted list. The <a href="big-O_notation" title="wikilink">Ω</a>(<em>n</em> log <em>n</em>) lower bound applies only to the case in which the input list can be in any possible order.</p>

<p>Also note that real-world measures of sorting speed may need to take into account the ability of some algorithms to optimally use relatively fast cached <a href="Random_Access_Memory" title="wikilink">computer memory</a>, or the application may benefit from sorting methods where sorted data begins to appear to the user quickly (and then user's speed of reading will be the limiting factor) as opposed to sorting methods where no output is available for display until the whole list is sorted.</p>

<p>Despite these limitations, comparison sorts offer the notable practical advantage that control over the comparison function allows sorting of many different datatypes and fine control over how the list is sorted. For example, reversing the result of the comparison function allows the list to be sorted in reverse; and one can sort a list of <a href="tuple" title="wikilink">tuples</a> in <a href="lexicographic_order" title="wikilink">lexicographic order</a> by just creating a comparison function that compares each part in sequence:</p>

<p><strong><code>function</code></strong><code> tupleCompare((lefta, leftb, leftc), (righta, rightb, rightc))</code><br/>
<code>    </code><strong><code>if</code></strong><code> lefta ≠ righta</code><br/>
<code>        </code><strong><code>return</code></strong><code> compare(lefta, righta)</code><br/>
<code>    </code><strong><code>else</code> <code>if</code></strong><code> leftb ≠ rightb</code><br/>
<code>        </code><strong><code>return</code></strong><code> compare(leftb, rightb)</code><br/>
<code>    </code><strong><code>else</code></strong><br/>
<code>        </code><strong><code>return</code></strong><code> compare(leftc, rightc)</code></p>

<p><a href="Balanced_ternary" title="wikilink">Balanced ternary</a> notation allows comparisons to be made in one step, whose result will be one of "less than", "greater than" or "equal to".</p>

<p>Comparison sorts generally adapt more easily to complex orders such as the order of <a href="floating-point_number" title="wikilink">floating-point numbers</a>. Additionally, once a comparison function is written, any comparison sort can be used without modification; non-comparison sorts typically require specialized versions for each datatype.</p>

<p>This flexibility, together with the efficiency of the above comparison sorting algorithms on modern computers, has led to widespread preference for comparison sorts in most practical work.</p>
<h2 id="alternatives">Alternatives</h2>

<p>Some sorting problems admit a strictly faster solution than the 

<math display="inline" id="Comparison_sort:0">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ω(nlogn)
  </annotation>
 </semantics>
</math>

 bound for comparison sorting; an example is <a href="integer_sorting" title="wikilink">integer sorting</a>, where all keys are integral. When the keys form a small (compared to 

<math display="inline" id="Comparison_sort:1">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

) range, <a href="counting_sort" title="wikilink">counting sort</a> is an example algorithm that runs in linear time. Other integer sorting algorithms, such as <a href="radix_sort" title="wikilink">radix sort</a>, are not asymptotically faster than comparison sorting, but can be faster in practice.</p>

<p>The problem of <a href="X_+_Y_sorting" title="wikilink">sorting pairs of numbers by their sum</a> is not subject to the 

<math display="inline" id="Comparison_sort:2">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi mathvariant="normal">²</mi>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>normal-²</ci>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ω(n²logn)
  </annotation>
 </semantics>
</math>

 bound either (the square resulting from the pairing up); the best known algorithm still takes 

<math display="inline" id="Comparison_sort:3">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi mathvariant="normal">²</mi>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>normal-²</ci>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n²logn)
  </annotation>
 </semantics>
</math>

 time, but only 

<math display="inline" id="Comparison_sort:4">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi mathvariant="normal">²</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>normal-²</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n²)
  </annotation>
 </semantics>
</math>

 comparisons.</p>
<h2 id="number-of-comparisons-required-to-sort-a-list">Number of comparisons required to sort a list</h2>
<div class="thumb tright">
<div class="thumbinner" style="width:270px;">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p><em>n</em></p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Comparison_sort:5">
 <semantics>
  <mrow>
   <mo stretchy="false">⌈</mo>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">⌉</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ceiling></ceiling>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <factorial></factorial>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lceil\log_{2}(n!)\rceil
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>Minimum</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>3</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>5</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>7</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>10</p></td>
<td style="text-align: left;">
<p>10</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>13</p></td>
<td style="text-align: left;">
<p>13</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;">
<p>16</p></td>
<td style="text-align: left;">
<p>16</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>9</p></td>
<td style="text-align: left;">
<p>19</p></td>
<td style="text-align: left;">
<p>19</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>10</p></td>
<td style="text-align: left;">
<p>22</p></td>
<td style="text-align: left;">
<p>22</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>11</p></td>
<td style="text-align: left;">
<p>26</p></td>
<td style="text-align: left;">
<p>26</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>12</p></td>
<td style="text-align: left;">
<p>29</p></td>
<td style="text-align: left;">
<p>30<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>13</p></td>
<td style="text-align: left;">
<p>33</p></td>
<td style="text-align: left;">
<p>34<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>14</p></td>
<td style="text-align: left;">
<p>37</p></td>
<td style="text-align: left;">
<p>38<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>15</p></td>
<td style="text-align: left;">
<p>41</p></td>
<td style="text-align: left;">
<p>42<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>16</p></td>
<td style="text-align: left;">
<p>45</p></td>
<td style="text-align: left;">
<p>45 or 46<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>19</p></td>
<td style="text-align: left;">
<p>57</p></td>
<td style="text-align: left;">
<p>58<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>22</p></td>
<td style="text-align: left;">
<p>70</p></td>
<td style="text-align: left;">
<p>71<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>n</em></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Comparison_sort:6">
 <semantics>
  <mrow>
   <mo stretchy="false">⌈</mo>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">⌉</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ceiling></ceiling>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <factorial></factorial>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lceil\log_{2}(n!)\rceil
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Comparison_sort:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>2</mn>
     </msub>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mfrac>
    <mi>n</mi>
    <mrow>
     <mi>ln</mi>
     <mn>2</mn>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <cn type="integer">2</cn>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <apply>
      <ln></ln>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\log_{2}n-\frac{n}{\ln 2}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>10</p></td>
<td style="text-align: left;">
<p>22</p></td>
<td style="text-align: left;">
<p>19</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>100</p></td>
<td style="text-align: left;">
<p>525</p></td>
<td style="text-align: left;">
<p>521</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1 000</p></td>
<td style="text-align: left;">
<p>8 530</p></td>
<td style="text-align: left;">
<p>8 524</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>10 000</p></td>
<td style="text-align: left;">
<p>118 459</p></td>
<td style="text-align: left;">
<p>118 451</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>100 000</p></td>
<td style="text-align: left;">
<p>1 516 705</p></td>
<td style="text-align: left;">
<p>1 516 695</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>18 488 885</p></td>
<td style="text-align: left;">
<p>18 488 874</p></td>
</tr>
</tbody>
</table>
<div class="thumbcaption">

<p>Above: A comparison of the lower bound 

<math display="inline" id="Comparison_sort:8">
 <semantics>
  <mrow>
   <mo stretchy="false">⌈</mo>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">⌉</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ceiling></ceiling>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <factorial></factorial>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lceil\log_{2}(n!)\rceil
  </annotation>
 </semantics>
</math>

 to the actual minimum number of comparisons (from ) required to sort a list of <em>n</em> items. Below: Using <a href="Stirling's_approximation" title="wikilink">Stirling's approximation</a>, this lower bound is well-approximated by 

<math display="inline" id="Comparison_sort:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>2</mn>
     </msub>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mfrac>
    <mi>n</mi>
    <mrow>
     <mi>ln</mi>
     <mn>2</mn>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <cn type="integer">2</cn>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <apply>
      <ln></ln>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\log_{2}n-\frac{n}{\ln 2}
  </annotation>
 </semantics>
</math>

.</p>
</div>
</div>
</div>

<p>The number of comparisons that a comparison sort algorithm requires increases at least in proportion to 

<math display="inline" id="Comparison_sort:10">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mrow>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\log(n)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Comparison_sort:11">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is the number of elements to sort. This bound is <a href="asymptotic_complexity" title="wikilink">asymptotically tight</a>.</p>

<p>Given a list of distinct numbers (we can assume this because this is a worst-case analysis), there are <em>n</em> <a class="uri" href="factorial" title="wikilink">factorial</a> permutations exactly one of which is the list in sorted order. The sort algorithm must gain enough information from the comparisons to identify the correct permutation. If the algorithm always completes after at most <em>f</em>(<em>n</em>) steps, it cannot distinguish more than 2<sup><em>f</em>(<em>n</em>)</sup> cases because the keys are distinct and each comparison has only two possible outcomes. Therefore,</p>

<p>

<math display="block" id="Comparison_sort:12">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mo>≥</mo>
   <mrow>
    <mi>n</mi>
    <mo lspace="0pt" rspace="3.5pt">!</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <factorial></factorial>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{f(n)}\geq n!
  </annotation>
 </semantics>
</math>

, or equivalently 

<math display="inline" id="Comparison_sort:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <factorial></factorial>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)\geq\log_{2}(n!).
  </annotation>
 </semantics>
</math>

 From <a href="Stirling's_approximation" title="wikilink">Stirling's approximation</a> we know that 

<math display="inline" id="Comparison_sort:14">
 <semantics>
  <mrow>
   <msub>
    <mi>log</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <log></log>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <factorial></factorial>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log_{2}(n!)
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Comparison_sort:15">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <msub>
       <mi>log</mi>
       <mn>2</mn>
      </msub>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <cn type="integer">2</cn>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(n\log_{2}n)
  </annotation>
 </semantics>
</math>

. This provides the lower-bound part of the claim.</p>

<p>An identical upper bound follows from the existence of the algorithms that attain this bound in the worst case.</p>

<p>The above argument provides an <em>absolute</em>, rather than only asymptotic lower bound on the number of comparisons, namely 

<math display="inline" id="Comparison_sort:16">
 <semantics>
  <mrow>
   <mo stretchy="false">⌈</mo>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">⌉</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ceiling></ceiling>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <factorial></factorial>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lceil\log_{2}(n!)\rceil
  </annotation>
 </semantics>
</math>

 comparisons. This lower bound is fairly good (it can be approached within a linear tolerance by a simple merge sort), but it is known to be inexact. For example, 

<math display="inline" id="Comparison_sort:17">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⌈</mo>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>13</mn>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">⌉</mo>
   </mrow>
   <mo>=</mo>
   <mn>33</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ceiling></ceiling>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <factorial></factorial>
       <cn type="integer">13</cn>
      </apply>
     </apply>
    </apply>
    <cn type="integer">33</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lceil\log_{2}(13!)\rceil=33
  </annotation>
 </semantics>
</math>

, but the minimal number of comparisons to sort 13 elements has been proved to be 34 .<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>Determining the <em>exact</em> number of comparisons needed to sort a given number of entries is a computationally hard problem even for small <em>n</em>, and no simple formula for the solution is known. For some of the few concrete values that have been computed, see .</p>
<h3 id="lower-bound-for-the-average-number-of-comparisons">Lower bound for the average number of comparisons</h3>

<p>A similar bound applies to the average number of comparisons. Assuming that</p>
<ul>
<li>all keys are distinct, i.e. every comparison will give either <em>a&gt;b</em> or <em>a<b< em="">, ''log<sub="" <em="">n</sub=""></b<></em>="" *="" a="" all="" and="" chosen="" determine="" elements,="" fewer="" from="" impossible="" in="" input="" is="" it="" of="" order="" permutation,="" permutations="" possible="" random="" set="" than="" the="" to="" uniformly="" which="" with=""&gt;2


<p>(n!)'' comparisons on average.</p></li>
</ul>

<p>This can be most easily seen using concepts from <a href="information_theory" title="wikilink">information theory</a>. The <a href="Shannon_entropy" title="wikilink">Shannon entropy</a> of such a random permutation is <em>log<sub>2</sub>(n!)</em> bits. Since a comparison can give only two results, the maximum amount of information it provides is 1 bit. Therefore after <em>k</em> comparisons the remaining entropy of the permutation, given the results of those comparisons, is at least <em>log<sub>2</sub>(n!) - k</em> bits on average. To perform the sort, complete information is needed, so the remaining entropy must be 0. It follows that <em>k</em> must be at least <em>log<sub>2</sub>(n!)</em>.</p>

<p>Note that this differs from the worst case argument given above, in that it does not allow rounding up to the nearest integer. For example, for <em>n = 3</em>, the lower bound for the worst case is 3, the lower bound for the average case as shown above is approximately 2.58, while the highest lower bound for the average case is 8/3, approximately 2.67.</p>

<p>In the case that multiple items may have the same key, there is no obvious statistical interpretation for the term "average case", so an argument like the above cannot be applied without making specific assumptions about the distribution of keys.</p>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li><a href="Donald_Knuth" title="wikilink">Donald Knuth</a>. <em>The Art of Computer Programming</em>, Volume 3: <em>Sorting and Searching</em>, Second Edition. Addison-Wesley, 1997. ISBN 0-201-89685-0. Section 5.3.1: Minimum-Comparison Sorting, pp. 180–197.</li>
</ul>

<p>"</p>

<p><a href="Category:Sorting_algorithms" title="wikilink">Category:Sorting algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">M. Wells, Elements of Combinatorial Computing, Pergamon Press, Oxford, 1971.<a href="#fnref2">↩</a></li>
<li id="fn3">Marcin Peczarski, New Results in Minimum-Comparison Sorting. Algorithmica 40(2):133-145, 2004.<a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5">Cheng Weiyi, Liu Xiaoguang, Wang Gang et al. The results of S(15) and S(19) to minimum-comparison sorting problem. Journal of Frontiers of Computer Science and Technology, 2007, 1(3): 305-313.<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9">Marcin Peczarski: The Ford-Johnson algorithm is still unbeaten for less than 47 elements. Inf. Process. Lett. 101(3): 126-128 (2007) <a href="#fnref9">↩</a></li>
</ol>
</section>
</body>
</html>
