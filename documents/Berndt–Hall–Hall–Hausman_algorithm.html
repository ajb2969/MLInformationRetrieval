<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1218">Berndt–Hall–Hall–Hausman algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Berndt–Hall–Hall–Hausman algorithm</h1>
<hr/>

<p>The <strong>Berndt–Hall–Hall–Hausman</strong> (<strong>BHHH</strong>) <strong>algorithm</strong> is a <a href="numerical_optimization" title="wikilink">numerical optimization</a> <a class="uri" href="algorithm" title="wikilink">algorithm</a> similar to the <a href="Gauss–Newton_algorithm" title="wikilink">Gauss–Newton algorithm</a>. It is named after the four originators: <a href="Ernst_R._Berndt" title="wikilink">Ernst R. Berndt</a>, B. Hall, <a href="Robert_Hall_(economist)" title="wikilink">Robert Hall</a>, and <a href="Jerry_Hausman" title="wikilink">Jerry Hausman</a>.</p>
<h2 id="usage">Usage</h2>

<p>If a <a class="uri" href="nonlinear" title="wikilink">nonlinear</a> model is fitted to the <a class="uri" href="data" title="wikilink">data</a> one often needs to estimate <a href="coefficient" title="wikilink">coefficients</a> through <a href="Optimization_(mathematics)" title="wikilink">optimization</a>. A number of optimisation algorithms have the following general structure. Suppose that the function to be optimized is <em>Q</em>(<em>β</em>). Then the algorithms are iterative, defining a sequence of approximations, <em>β<sub>k</sub></em> given by</p>

<p>

<math display="block" id="Berndt–Hall–Hall–Hausman_algorithm:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>β</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>β</mi>
      <mi>k</mi>
     </msub>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>λ</mi>
       <mi>k</mi>
      </msub>
      <msub>
       <mi>A</mi>
       <mi>k</mi>
      </msub>
      <mfrac>
       <mrow>
        <mo>∂</mo>
        <mi>Q</mi>
       </mrow>
       <mrow>
        <mo>∂</mo>
        <mi>β</mi>
       </mrow>
      </mfrac>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>β</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>Q</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>β</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{k+1}=\beta_{k}-\lambda_{k}A_{k}\frac{\partial Q}{\partial\beta}(\beta_{%
k}),
  </annotation>
 </semantics>
</math>

,</p>

<p>where 

<math display="inline" id="Berndt–Hall–Hall–Hausman_algorithm:1">
 <semantics>
  <msub>
   <mi>β</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{k}
  </annotation>
 </semantics>
</math>

 is the parameter estimate at step k, and 

<math display="inline" id="Berndt–Hall–Hall–Hausman_algorithm:2">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{k}
  </annotation>
 </semantics>
</math>

 is a parameter (called step size) which partly determines the particular algorithm. For the BHHH algorithm <em>λ<sub>k</sub></em> is determined by calculations within a given iterative step, involving a line-search until a point ''β<sub>k''+1</sub> is found satisfying certain criteria. In addition, for the BHHH algorithm, <em>Q</em> has the form</p>

<p>

<math display="block" id="Berndt–Hall–Hall–Hausman_algorithm:3">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </munderover>
    <msub>
     <mi>Q</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Q</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=\sum_{i=1}^{N}Q_{i}
  </annotation>
 </semantics>
</math>

 and <em>A</em> is calculated using</p>

<p>

<math display="block" id="Berndt–Hall–Hall–Hausman_algorithm:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>A</mi>
     <mi>k</mi>
    </msub>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo>[</mo>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>N</mi>
       </munderover>
       <mrow>
        <mfrac>
         <mrow>
          <mrow>
           <mo>∂</mo>
           <mi>ln</mi>
          </mrow>
          <msub>
           <mi>Q</mi>
           <mi>i</mi>
          </msub>
         </mrow>
         <mrow>
          <mo>∂</mo>
          <mi>β</mi>
         </mrow>
        </mfrac>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>β</mi>
          <mi>k</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
        <mfrac>
         <mrow>
          <mrow>
           <mo>∂</mo>
           <mi>ln</mi>
          </mrow>
          <msub>
           <mi>Q</mi>
           <mi>i</mi>
          </msub>
         </mrow>
         <mrow>
          <mo>∂</mo>
          <mi>β</mi>
         </mrow>
        </mfrac>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>β</mi>
           <mi>k</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>′</mo>
        </msup>
       </mrow>
      </mrow>
      <mo>]</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>N</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <apply>
           <partialdiff></partialdiff>
           <ln></ln>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>Q</ci>
           <ci>i</ci>
          </apply>
         </apply>
         <apply>
          <partialdiff></partialdiff>
          <ci>β</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>β</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <apply>
           <partialdiff></partialdiff>
           <ln></ln>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>Q</ci>
           <ci>i</ci>
          </apply>
         </apply>
         <apply>
          <partialdiff></partialdiff>
          <ci>β</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>β</ci>
          <ci>k</ci>
         </apply>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{k}=\left[\sum_{i=1}^{N}\frac{\partial\ln Q_{i}}{\partial\beta}(\beta_{k})%
\frac{\partial\ln Q_{i}}{\partial\beta}(\beta_{k})^{\prime}\right]^{-1}.
  </annotation>
 </semantics>
</math>

 In other cases, e.g. <a class="uri" href="Newton–Raphson" title="wikilink">Newton–Raphson</a>, 

<math display="inline" id="Berndt–Hall–Hall–Hausman_algorithm:5">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{k}
  </annotation>
 </semantics>
</math>

 can have other forms. The BHHH algorithm has the advantage that, if certain conditions apply, convergence of the iterative procedure is guaranteed.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Davidon–Fletcher–Powell_algorithm" title="wikilink">Davidon–Fletcher–Powell (DFP) algorithm</a></li>
<li><a href="Broyden–Fletcher–Goldfarb–Shanno_algorithm" title="wikilink">Broyden–Fletcher–Goldfarb–Shanno (BFGS) algorithm</a></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Econometrics" title="wikilink">Category:Econometrics</a> <a href="Category:Optimization_algorithms_and_methods" title="wikilink">Category:Optimization algorithms and methods</a></p>
</body>
</html>
