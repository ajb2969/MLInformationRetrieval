<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1125">Generic-case complexity</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Generic-case complexity</h1>
<hr/>

<p><strong>Generic-case complexity</strong> is a subfield of <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a> that studies the complexity of computational problems on "most inputs".</p>

<p>Generic-case complexity is a way of measuring the complexity of a <a href="computational_problem" title="wikilink">computational problem</a> by neglecting a small set of unrepresentative inputs and considering <a href="worst-case_complexity" title="wikilink">worst-case complexity</a> on the rest. Small is defined in terms of asymptotic density. The apparent efficacy of generic case complexity is because for a wide variety of concrete computational problems, the most difficult instances seem to be rare. Typical instances are relatively easy.</p>

<p>This approach to complexity originated in <a href="combinatorial_group_theory" title="wikilink">combinatorial group theory</a>, which has a computational tradition going back to the beginning of the last century. The notion of generic complexity was introduced in <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> where authors showed that for a large class of <a href="finitely_generated_group" title="wikilink">finitely generated groups</a> the generic time complexity of some classical <a href="decision_problems" title="wikilink">decision problems</a> from combinatorial group theory, namely the <a href="word_problem_for_groups" title="wikilink">word problem</a>, <a href="conjugacy_problem" title="wikilink">conjugacy problem</a> and <a href="membership_problem" title="wikilink">membership problem</a>, are linear.</p>

<p>A detailed introduction of generic case complexity can be found in the surveys ,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> <ref></ref></p>

<p><code>R. Gilman, A. G. Miasnikov, A. D. Myasnikov, and A. Ushakov, </code><em><a href="http://www.stevens.edu/algebraic/Files/GC/gc_survey.pdf"><code>Report</code> <code>on</code> <code>generic</code> <code>case</code> <code>complexity</code></a></em><code>, Herald of Omsk University, Special Issue, 2007, 103–110.</code></p>

<p></p>
<h2 id="basic-definitions">Basic definitions</h2>
<h3 id="asymptotic-density">Asymptotic density</h3>

<p>Let <em>I</em> be an <a href="infinite_set" title="wikilink">infinite set</a> of inputs for a computational problem.</p>

<p><strong>Definition 1.</strong> A size function on <em>I</em> is a map 

<math display="inline" id="Generic-case_complexity:0">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>:</mo>
   <mrow>
    <mi>I</mi>
    <mo>→</mo>
    <mi>ℕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>σ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>I</ci>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma:I\to\mathbb{N}
  </annotation>
 </semantics>
</math>

 with infinite range. The ball of radius <em>n</em> is 

<math display="inline" id="Generic-case_complexity:1">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mi>I</mi>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <mrow>
      <mi>σ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>≤</mo>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>x</ci>
      <ci>I</ci>
     </apply>
     <apply>
      <leq></leq>
      <apply>
       <times></times>
       <ci>σ</ci>
       <ci>x</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{n}=\{x\in I\mid\sigma(x)\leq n\}
  </annotation>
 </semantics>
</math>

.</p>

<p>If the inputs are coded as strings over a finite alphabet, size might be the string length.</p>

<p>Let 

<math display="inline" id="Generic-case_complexity:2">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>μ</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\mu_{n}\}
  </annotation>
 </semantics>
</math>

 be an ensemble of <a href="probability_distributions" title="wikilink">probability distributions</a> where 

<math display="inline" id="Generic-case_complexity:3">
 <semantics>
  <msub>
   <mi>μ</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>μ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{n}
  </annotation>
 </semantics>
</math>

 is a <a href="probability_distribution" title="wikilink">probability distribution</a> on 

<math display="inline" id="Generic-case_complexity:4">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{n}
  </annotation>
 </semantics>
</math>

. If the balls 

<math display="inline" id="Generic-case_complexity:5">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{n}
  </annotation>
 </semantics>
</math>

 are finite, then each 

<math display="inline" id="Generic-case_complexity:6">
 <semantics>
  <msub>
   <mi>μ</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>μ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{n}
  </annotation>
 </semantics>
</math>

 can be taken to be the equiprobable distribution which is the most common case. Notice that only finitely many 

<math display="inline" id="Generic-case_complexity:7">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{n}
  </annotation>
 </semantics>
</math>

's can be empty or have 

<math display="inline" id="Generic-case_complexity:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>μ</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>B</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{n}(B_{n})=0
  </annotation>
 </semantics>
</math>

; we ignore them.</p>

<p><strong>Definition 2.</strong> The asymptotic density of a subset 

<math display="inline" id="Generic-case_complexity:9">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>⊂</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>X</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\subset I
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Generic-case_complexity:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>ρ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>lim</mo>
     <mrow>
      <mi>n</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
    <mrow>
     <msub>
      <mi>μ</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>X</mi>
       <mo>∩</mo>
       <msub>
        <mi>B</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ρ</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>n</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <intersect></intersect>
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(X)=\lim_{n\to\infty}\mu_{n}(X\cap B_{n})
  </annotation>
 </semantics>
</math>

 when this limit exists.</p>

<p>When the balls 

<math display="inline" id="Generic-case_complexity:11">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{n}
  </annotation>
 </semantics>
</math>

 are finite and 

<math display="inline" id="Generic-case_complexity:12">
 <semantics>
  <msub>
   <mi>μ</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>μ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{n}
  </annotation>
 </semantics>
</math>

 is the equiprobable measure,</p>

<p>

<math display="block" id="Generic-case_complexity:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ρ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo movablelimits="false">lim</mo>
     <mfrac>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mi>X</mi>
        <mo>∩</mo>
        <msub>
         <mi>B</mi>
         <mi>n</mi>
        </msub>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>B</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">|</mo>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ρ</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <limit></limit>
     <apply>
      <divide></divide>
      <apply>
       <abs></abs>
       <apply>
        <intersect></intersect>
        <ci>X</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>B</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(X)=\lim\frac{|X\cap B_{n}|}{|B_{n}|}.
  </annotation>
 </semantics>
</math>

</p>

<p>In this case it is often convenient to use spheres 

<math display="inline" id="Generic-case_complexity:14">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mi>I</mi>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <mrow>
      <mi>σ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>x</ci>
      <ci>I</ci>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>σ</ci>
       <ci>x</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{n}=\{x\in I\mid\sigma(x)=n\}
  </annotation>
 </semantics>
</math>

 instead of balls and define 

<math display="inline" id="Generic-case_complexity:15">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>ρ</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>lim</mo>
    <mfrac>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>X</mi>
       <mo>∩</mo>
       <msub>
        <mi>I</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <msub>
       <mi>I</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">|</mo>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ρ</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <limit></limit>
     <apply>
      <divide></divide>
      <apply>
       <abs></abs>
       <apply>
        <intersect></intersect>
        <ci>X</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>I</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>I</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho^{\prime}(X)=\lim\frac{|X\cap I_{n}|}{|I_{n}|}
  </annotation>
 </semantics>
</math>

. An argument using <a href="Stolz_theorem" title="wikilink">Stolz theorem</a> shows that 

<math display="inline" id="Generic-case_complexity:16">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ρ</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(X)
  </annotation>
 </semantics>
</math>

 exists if 

<math display="inline" id="Generic-case_complexity:17">
 <semantics>
  <mrow>
   <msup>
    <mi>ρ</mi>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ρ</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho^{\prime}(X)
  </annotation>
 </semantics>
</math>

 does, and in that case they are equal.</p>

<p><strong>Definition 3</strong> 

<math display="inline" id="Generic-case_complexity:18">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>⊆</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>X</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\subseteq I
  </annotation>
 </semantics>
</math>

 is generic if 

<math display="inline" id="Generic-case_complexity:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>ρ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ρ</ci>
     <ci>X</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(X)=1
  </annotation>
 </semantics>
</math>

 and negligible if 

<math display="inline" id="Generic-case_complexity:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>ρ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ρ</ci>
     <ci>X</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(X)=0
  </annotation>
 </semantics>
</math>

. <em>X</em> is exponentially (superpolynomially) generic if the convergence to the limit in Definition 2 is exponentially (superpolynomially) fast, etc.</p>

<p>A generic subset <em>X</em> is asymptotically large. Whether <em>X</em> appears large in practice depends on how fast 

<math display="inline" id="Generic-case_complexity:21">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>X</mi>
     <mo>∩</mo>
     <msub>
      <mi>B</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <intersect></intersect>
     <ci>X</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{n}(X\cap B_{n})
  </annotation>
 </semantics>
</math>

 converges to 1. Superpolynomial convergence seems to be fast enough.</p>
<h3 id="generic-complexity-classes">Generic complexity classes</h3>

<p><strong>Definition 4</strong> An <a class="uri" href="algorithm" title="wikilink">algorithm</a> is in <em>GenP</em> (generically polynomial time) if it never gives incorrect answers and if it gives correct answers in <a href="polynomial_time" title="wikilink">polynomial time</a> on a generic set of inputs. A problem is in <em>GenP</em> if it admits an algorithm in <em>GenP</em>. Likewise for <em>GenL</em> (generically <a href="linear_time" title="wikilink">linear time</a>), <em>GenE</em> (generically <a href="exponential_time" title="wikilink">exponential time</a> with a linear exponent) <em>GenExp</em> (generically exponential time), etc. <em>ExpGenP</em> is the subclass of <em>GenP</em> for which the relevant generic set is exponentially generic.</p>

<p>More generally for any 

<math display="inline" id="Generic-case_complexity:22">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>ℕ</mi>
    <mo>→</mo>
    <mi>ℕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>ℕ</ci>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\mathbb{N}\to\mathbb{N}
  </annotation>
 </semantics>
</math>

 we can define the class <em>Gen(f)</em> corresponding to <a href="time_complexity" title="wikilink">time complexity</a> <em>O</em>(<em>f</em>) on a generic set of input.</p>

<p><strong>Definition 5.</strong> An algorithm solves a problem generically if it never gives incorrect answers and if it gives correct answers on a generic set of inputs. A problem is generically solvable if it is solved generically by some algorithm.</p>
<h2 id="theory-and-applications">Theory and applications</h2>
<h3 id="combinatorial-group-theory-problems">Combinatorial group theory problems</h3>
<ul>
<li>The famous <a href="undecidable_problem" title="wikilink">undecidable problems</a>: the word, conjugacy and membership decision problems are in generically polynomial.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
</ul>
<ul>
<li>The word and conjugacy <a href="search_problem" title="wikilink">search problems</a> are in <em>GenP</em> for all fixed finitely presented groups.<ref></ref></li>
</ul>

<p>A. Ushakov, <em>Dissertation</em>, City University of New York, 2005.</p>
<ul>
<li>The well known <a href="coset_enumeration" title="wikilink">coset enumeration</a> procedure admits a computable upper bound on a generic set of inputs.<ref></ref></li>
</ul>

<p>R. Gilman, <em>Hard problems in group theory</em>, talk given at the International Conference on Geometric and Combinatorial Methods in Group Theory and Semigroup Theory, May 18, 2009.</p>
<ul>
<li>The Whitehead algorithm for testing whether or not one element of a free group is mapped to another by an automorphism has an exponential worst case upper bound but runs well in practice. The algorithm is shown to be in <em>GenL</em>.<ref></ref></li>
</ul>

<p>I. Kapovich, P. Schupp, V. Shpilrain, <em><a href="http://arxiv.org/abs/math.GR/0303386">Generic properties of Whiteheads algorithm and isomorphism rigidity of random one-relator groups</a></em>, Pacific J. Math. 223 (2006) </p>
<ul>
<li>The conjugacy problem in <a href="HNN_extension" title="wikilink">HNN extensions</a> can be unsolvable even for <a href="free_group" title="wikilink">free groups</a>. However, it is generically cubic time<ref></ref></li>
</ul>

<p>A.V. Borovik, A.G. Myasnikov, V.N. Remeslennikov, <em><a href="http://arxiv.org/abs/0903.3754">Generic complexity of the conjugacy problem in HNN-extensions and algorithmic stratification of Miller's groups</a></em>, Internat. J. Algebra Comput. 17 (2007), 963–997. </p>
<h3 id="the-halting-problem-and-the-post-correspondence-problem">The halting problem and the Post correspondence problem</h3>
<ul>
<li>The <a href="halting_problem" title="wikilink">halting problem</a> for <a href="Turing_machine" title="wikilink">Turing machine</a> with one-sided tape is easily decidable most of the time; it is in <em>GenP</em><ref></ref></li>
</ul>

<p><a href="Joel_David_Hamkins" title="wikilink">J. D. Hamkins</a> and A. Miasnikov, <em><a href="http://arxiv.org/abs/math/0504351">The halting problem is decidable on a set of asymptotic probability one</a></em>, Notre Dame J. Formal Logic 47 (2006), 515–524. </p>

<p>The situation for two-sided tape is unknown. However, there is a kind of lower bound for machines of both types. The halting problem is not in <em>ExpGenP</em> for any model of Turing machine,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<ul>
<li>The <a href="Post_correspondence_problem" title="wikilink">Post correspondence problem</a> is in <em>ExpGenP</em>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></li>
</ul>
<h3 id="presburger-arithmetic">Presburger arithmetic</h3>

<p>The <a href="decision_problem" title="wikilink">decision problem</a> for <a href="Presburger_arithmetic" title="wikilink">Presburger arithmetic</a> admits a double exponential worst case lower bound <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> and a triple exponential worst case upper bound. The generic complexity is not known, but it is known that the problem is not in <em>ExpGenP</em>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h3 id="np-complete-problems">NP complete problems</h3>

<p>As it is well known that <a href="NP-complete_problems" title="wikilink">NP-complete problems</a> can be easy on average, it is not a surprise that several of them are generically easy too.</p>
<ul>
<li>The three <a href="satisfiability_problem" title="wikilink">satisfiability problem</a> is in <em>ExpGenP</em> <ref></ref></li>
</ul>

<p>R. Gilman, A. G. Miasnikov, A. D. Myasnikov, and A. Ushakov, Report on generic case complexity, Herald of Omsk University, Special Issue, 2007, 103–110. </p>
<ul>
<li>The <a href="subset_sum_problem" title="wikilink">subset sum problem</a> is in <em>GenP</em>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></li>
</ul>
<h3 id="one-way-functions">One way functions</h3>

<p>There is a generic complexity version of a <a href="one-way_function" title="wikilink">one-way function</a> <a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> which yields the same class of functions but allows one to consider different security assumptions than usual.</p>
<h3 id="public-key-cryptography">Public-key cryptography</h3>

<p>A series of articles,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> is devoted to cryptanalysis of the <a href="Anshel–Anshel–Goldfeld_key_exchange" title="wikilink">Anshel–Anshel–Goldfeld key exchange</a> protocol, whose security is based on assumptions about the <a href="braid_group" title="wikilink">braid group</a>. This series culminates in <a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> which applies techniques from generic case complexity to obtain a complete analysis of the <a href="length_based_attack" title="wikilink">length based attack</a> and the conditions under which it works. The generic point of view also suggests a kind of new attack called the quotient attack, and a more secure version of the Anshel–Anshel–Goldfeld protocol.</p>
<h3 id="list-of-general-theoretical-results">List of general theoretical results</h3>
<ul>
<li>A famous <a href="Rice's_theorem" title="wikilink">Rice's theorem</a> states that if <em>F</em> is a subset of the set of partial computable functions from 

<math display="inline" id="Generic-case_complexity:23">
 <semantics>
  <mi>ℕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{N}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Generic-case_complexity:24">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{0,1\}
  </annotation>
 </semantics>
</math>

, then unless <em>F</em> or its complement is empty, the problem of deciding whether or not a particular <a href="Turing_machine" title="wikilink">Turing machine</a> computes a function in <em>F</em> is undecidable. The following theorem gives a generic version.</li>
</ul>

<p><strong>Theorem 1</strong> <a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> Let <em>I</em> be the set of all Turing machines. If <em>F</em> is a subset of the set of all partial computable function from 

<math display="inline" id="Generic-case_complexity:25">
 <semantics>
  <mi>ℕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{N}
  </annotation>
 </semantics>
</math>

 to itself such that <em>F</em> and its complement are both non-empty, then the problem of deciding whether or not a given Turing machine computes a function from <em>F</em> is not decidable on any exponentially generic subset of <em>I</em>.</p>
<ul>
<li>The following theorems are from.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></li>
</ul>

<p><strong>Theorem 2</strong> The set of <a href="formal_languages" title="wikilink">formal languages</a> which are generically computable has measure zero.</p>

<p><strong>Theorem 3</strong> There is an infinite hierarchy of generic complexity classes. More precisely for a proper complexity function <em>f</em>, 

<math display="inline" id="Generic-case_complexity:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mi>e</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⊊</mo>
   <mrow>
    <mi>G</mi>
    <mi>e</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>f</mi>
      <mn>3</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <prsubset></prsubset>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>e</ci>
     <ci>n</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>e</ci>
     <ci>n</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Gen(f)\subsetneq Gen(f^{3})
  </annotation>
 </semantics>
</math>

.</p>
<ul>
<li>The next theorem shows that just as there are <a href="average_case_complete_problems" title="wikilink">average case complete problems</a> within distributional NP problems,</li>
</ul>

<p>there are also generic case complete problems. The arguments in the generic case are similar to those in the average case, and the generic case complete problem is also average case complete. It is the distributional <a href="bounded_halting_problem" title="wikilink">bounded halting problem</a>.</p>

<p><strong>Theorem 4</strong> <a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> There is a notion of generic-polynomial-time reduction with respect to which the distributional bounded halting problem is complete within class of distributional NP problems.</p>
<h2 id="comparisons-with-previous-work">Comparisons with previous work</h2>
<h3 id="almost-polynomial-time">Almost polynomial time</h3>

<p>Meyer and Paterson <a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> define an algorithm to be almost polynomial time, or APT, if it halts within <em>p(n)</em> steps on all but <em>p(n)</em> inputs of size <em>n</em>. Clearly APT algorithms are included in our class <em>GenP</em>. We have seen several <a href="NP_complete" title="wikilink">NP complete</a> problems in <em>GenP</em>, but Meyer and Paterson show that this is not the case for APT. They prove that an NP complete problem is reducible to a problem in APT if and only if <a href="P_=_NP" title="wikilink">P = NP</a>. Thus APT seems much more restrictive than <em>GenP</em>.</p>
<h3 id="average-case-complexity">Average-case complexity</h3>

<p>Generic case complexity is similar to <a href="average-case_complexity" title="wikilink">average-case complexity</a>. However there are some significant differences. Generic case complexity is a direct measure of the performance of an algorithm on most inputs while average case complexity gives a measure of the balance between easy and difficult instances. In addition Generic-case complexity naturally applies to <a href="undecidable_problem" title="wikilink">undecidable problems</a>.</p>

<p>Suppose 

<math display="inline" id="Generic-case_complexity:27">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 is an algorithm whose <a href="time_complexity" title="wikilink">time complexity</a>, 

<math display="inline" id="Generic-case_complexity:28">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>:</mo>
   <mrow>
    <mi>I</mi>
    <mo>→</mo>
    <mi>ℕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>T</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>I</ci>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T:I\to\mathbb{N}
  </annotation>
 </semantics>
</math>

 is polynomial on 

<math display="inline" id="Generic-case_complexity:29">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 average. What can we infer about the behavior of 

<math display="inline" id="Generic-case_complexity:30">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 on typical inputs?</p>

<p><strong>Example 1</strong> Let <em>I</em> be the set of all words over 

<math display="inline" id="Generic-case_complexity:31">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{0,1\}
  </annotation>
 </semantics>
</math>

 and define the size 

<math display="inline" id="Generic-case_complexity:32">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>σ</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(w)
  </annotation>
 </semantics>
</math>

 to be word length, 

<math display="inline" id="Generic-case_complexity:33">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>w</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |w|
  </annotation>
 </semantics>
</math>

. Define 

<math display="inline" id="Generic-case_complexity:34">
 <semantics>
  <msub>
   <mi>I</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{n}
  </annotation>
 </semantics>
</math>

 to be the set of words of length <em>n</em>, and assume that each 

<math display="inline" id="Generic-case_complexity:35">
 <semantics>
  <msub>
   <mi>μ</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>μ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{n}
  </annotation>
 </semantics>
</math>

 is the equiprobable measure. Suppose that <em>T(w)=n</em> for all but one word in each 

<math display="inline" id="Generic-case_complexity:36">
 <semantics>
  <msub>
   <mi>I</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{n}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Generic-case_complexity:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <msup>
     <mn>2</mn>
     <mi>n</mi>
    </msup>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>w</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(w)=2^{2^{n}}
  </annotation>
 </semantics>
</math>

 on the exceptional words.</p>

<p>In this example <em>T</em> is certainly polynomial on typical inputs, but <em>T</em> is not polynomial on average. <em>T</em> is in <em>GenP</em>.</p>

<p><strong>Example 2</strong> Keep <em>I</em> and 

<math display="inline" id="Generic-case_complexity:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>w</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>w</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(w)=|w|
  </annotation>
 </semantics>
</math>

 as before, but define 

<math display="inline" id="Generic-case_complexity:39">
 <semantics>
  <mrow>
   <mrow>
    <mi>μ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>w</mi>
        <mo stretchy="false">|</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>μ</ci>
     <ci>w</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <abs></abs>
         <ci>w</ci>
        </apply>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu(w)=2^{-2|w|-1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Generic-case_complexity:40">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>w</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>w</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <abs></abs>
      <ci>w</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(w)=2^{|w|}
  </annotation>
 </semantics>
</math>

. <em>T</em> is polynomial on average even though it is exponential on typical inputs. <em>T</em> is not in <em>GenP</em>.</p>

<p>In these two examples the generic complexity is more closely related to behavior on typical inputs than average case complexity. Average case complexity measures something else: the balance between the frequency of difficult instances and the degree of difficulty,.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> Roughly speaking an algorithm which is polynomial time on average can have only a subpolynomial fraction of inputs that require superpolynomial time to compute.</p>

<p>Nevertheless in some cases generic and average case complexity are quite close to each other. A function 

<math display="inline" id="Generic-case_complexity:41">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>I</mi>
    <mo>→</mo>
    <msup>
     <mi>ℝ</mi>
     <mo>+</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>I</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <plus></plus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:I\rightarrow\mathbb{R}^{+}
  </annotation>
 </semantics>
</math>

 is polynomial on 

<math display="inline" id="Generic-case_complexity:42">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

-average on spheres if there exists 

<math display="inline" id="Generic-case_complexity:43">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>≥</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>k</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\geq 1
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Generic-case_complexity:44">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>w</mi>
      <mo>∈</mo>
      <msub>
       <mi>I</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </msub>
    <mrow>
     <msup>
      <mi>f</mi>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mi>k</mi>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>w</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>μ</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>w</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>w</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>I</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>k</ci>
       </apply>
      </apply>
      <ci>w</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <ci>n</ci>
      </apply>
      <ci>w</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{w\in I_{n}}f^{1/k}(w)\mu_{n}(w)=O(n)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Generic-case_complexity:45">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>μ</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\mu_{n}\}
  </annotation>
 </semantics>
</math>

 is the ensemble induced by 

<math display="inline" id="Generic-case_complexity:46">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

. If <em>f</em> is polynomial on 

<math display="inline" id="Generic-case_complexity:47">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

-average on spheres, the <em>f</em> is polynomial on 

<math display="inline" id="Generic-case_complexity:48">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

-average, and for many distributions the converse holds <a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>

<p><strong>Theorem</strong> 5 <a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> If a function 

<math display="inline" id="Generic-case_complexity:49">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>I</mi>
    <mo>→</mo>
    <msup>
     <mi>ℝ</mi>
     <mo>+</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>I</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <plus></plus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:I\rightarrow\mathbb{R}^{+}
  </annotation>
 </semantics>
</math>

 is polynomial on 

<math display="inline" id="Generic-case_complexity:50">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

-average on spheres then <em>f</em> is generically polynomial relative to the spherical asymptotic density 

<math display="inline" id="Generic-case_complexity:51">
 <semantics>
  <msup>
   <mi>ρ</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ρ</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho^{\prime}
  </annotation>
 </semantics>
</math>

.</p>

<p><strong>Theorem</strong> 6 <a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> Suppose a complete algorithm 

<math display="inline" id="Generic-case_complexity:52">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 has subexponential time bound <em>T</em> and a partial algorithm 

<math display="inline" id="Generic-case_complexity:53">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>

 for the same problem is in <em>ExpGenP</em> with respect to the ensemble 

<math display="inline" id="Generic-case_complexity:54">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>μ</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\mu_{n}\}
  </annotation>
 </semantics>
</math>

 corresponding to a probability measure 

<math display="inline" id="Generic-case_complexity:55">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 on the inputs <em>I</em> for 

<math display="inline" id="Generic-case_complexity:56">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

. Then there is a complete algorithm which is 

<math display="inline" id="Generic-case_complexity:57">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

-average time complexity.</p>
<h3 id="errorless-heuristic-algorithms">Errorless heuristic algorithms</h3>

<p>In a 2006 paper, Bogdanov and Trevisan came close to defining generic case complexity.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> Instead of partial algorithms, they consider so-called errorless heuristic algorithms. These are complete algorithms which may fail by halting with output "?". The class <em>AvgnegP</em> is defined to consist of all errorless heuristic algorithms <em>A</em> which run in polynomial time and for which the probability of failure on 

<math display="inline" id="Generic-case_complexity:58">
 <semantics>
  <msub>
   <mi>I</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{n}
  </annotation>
 </semantics>
</math>

 is negligible, i.e., converges superpolynomially fast to 0. <em>AvgnegP</em> is a subset of <em>GenP</em>. Errorless heuristic algorithms are essentially the same as the algorithms with benign faults defined by Impagliazzo where polynomial time on average algorithms are characterized in terms of so-called benign algorithm schemes.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Computational_complexity_theory" title="wikilink">Category:Computational complexity theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">I. Kapovich, A. Myasnikov, P. Schupp and V. Shpilrain, <em><a href="http://arxiv.org/abs/math/0203239">Generic case complexity, decision problems in group theory and random walks</a></em>, J. Algebra, vol 264 (2003), 665–694.<a href="#fnref1">↩</a></li>
<li id="fn2">R. Gilman, A. G. Miasnikov, A. D. Myasnikov, and A. Ushakov, <em>Generic Case Complexity</em>, unpublished first draft of a book, 143 pages.<a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4">A. Miasnikov and A. Rybalov, <em>[<a class="uri" href="http://projecteuclid.org/DPubS?service=UI&amp;version">http://projecteuclid.org/DPubS?service=UI&amp;version;</a>;=1.0&amp;verb;=Display&amp;handle;=euclid.jsl/1208359065 Generic complexity of undecidable problems]</em>, J. Symbolic Logic 73 (2008), 656–673.<a href="#fnref4">↩</a></li>
<li id="fn5">A. Rybalov, <em>[<a class="uri" href="http://www.sciencedirect.com/science?_ob=ArticleURL&amp;_udi=B6V1G-4N2TS51-3&amp;_user=605441&amp;_rdoc=1&amp;_fmt">http://www.sciencedirect.com/science?_ob=ArticleURL&amp;_udi=B6V1G-4N2TS51-3&amp;_user=605441&amp;_rdoc=1&amp;_fmt</a>=&amp;_orig=search&amp;_sort=d&amp;_docanchor=&amp;view;=c&amp;_searchStrId=1052347431&amp;_rerunOrigin=google&amp;_acct=C000029138&amp;_version=1&amp;_urlVersion=0&amp;_userid=605441&amp;md5;=8bee4d70a78ff9d14450f6bc7a993984 On the strongly generic undecidability of the halting problem]</em>, Theoret. Comput. Sci. 377 (2007), 268–270.<a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7">M. J. Fischer and M. O. Rabin, <em>Super-Exponential Complexity of Presburger Arithmetic</em>, Proceedings of the SIAM-AMS Symposium in Applied Mathematics 7 (1974) 2741.<a href="#fnref7">↩</a></li>
<li id="fn8">A. Rybalov, <em>Generic complexity of Presburger arithmetic</em>, 356–361 in Second International Symposium on Computer Science in Russia, CSR 2007, Lecture Notes in Computer Science 4649, Springer 2007.<a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10">A. D. Myasnikov, <em><a href="http://arxiv.org/abs/0802.3734">Generic Complexity and One-Way Functions</a></em>, Groups, Complexity and Cryptography, 1, (2009), 13–31.<a href="#fnref10">↩</a></li>
<li id="fn11">R. Gilman, A. G. Miasnikov, A. D. Myasnikov, and A. Ushakov, <em>New developments in commutator key exchange</em>, Proc. First Int. Conf. on Symbolic Computation and Cryptography (SCC-2008), Beijing, 2008.<a href="#fnref11">↩</a></li>
<li id="fn12">A. G. Myasnikov, V. Shpilrain, A. Ushakov, <em>A practical attack on a braid group based cryptographic protocol</em>, in Lecture Notes in Computer Science, 3621, Springer Verlag, 2005, 86–96.<a href="#fnref12">↩</a></li>
<li id="fn13">A. D. Myasnikov, and A. Ushakov, <em>Length based attack and braid groups: cryptanalysis of Anshel–Anshel–Goldfeld key exchange protocol</em>, in Public Key Cryptography PKC 2007, 76–88, Lecture Notes in Comput. Sci., 4450, Springer, Berlin, 2007.<a href="#fnref13">↩</a></li>
<li id="fn14">A. G. Miasnikov and A. Ushakov, <em>Random subgroups and analysis of the length-based and quotient attacks</em>, Journal of Mathematical Cryptology, 2 (2008), 29–61.<a href="#fnref14">↩</a></li>
<li id="fn15">A. Miasnikov and A. Rybalov, <em>Generic complexity of undecidable problems</em>, J. Symbolic Logic 73 (2008), 656–673.<a href="#fnref15">↩</a></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18">A. R. Meyer and M. S. Paterson, <em>With what frequency are apparently intractable problems difficult?</em>, M.I.T. Technical Report, MIT/LCS/TM-126, February, 1979.<a href="#fnref18">↩</a></li>
<li id="fn19">Y. Gurevich, <em>The challenger-solver game: variations on the theme of P =?NP</em>, Logic in Computer Science Column, The Bulletin of the EATCS, October 1989, p.112-121.<a href="#fnref19">↩</a></li>
<li id="fn20">R. Impagliazzo, <em>A personal view of average-case complexity</em>, in Proceedings of the 10th Annual Structure in Complexity Theory Conference - SCT 1995, IEEE Computer Society, 1995, page 134.<a href="#fnref20">↩</a></li>
<li id="fn21">Y. Gurevich, <em>Average case completeness</em>, J. of Computer and System Science, 42 (1991), 346–398.<a href="#fnref21">↩</a></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24">A. Bogdanov, L. Trevisan, <em>Average-case Complexity</em>, Found. Trends Theor. Comput. Sci. <strong>2</strong>, No. 1, 111 p. (2006)..<a href="#fnref24">↩</a></li>
</ol>
</section>
</body>
</html>
