<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="669">Analog signal processing</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Analog signal processing</h1>
<hr/>

<p><strong>Analog signal processing</strong> is any type of <a href="signal_processing" title="wikilink">signal processing</a> conducted on continuous <a href="analog_signal" title="wikilink">analog signals</a> by some analog means (as opposed to the discrete <a href="Digital_Signal_Processing" title="wikilink">Digital Signal Processing</a> where the <a href="signal_processing" title="wikilink">signal processing</a> is carried out by a digital process). "Analog" indicates something that is mathematically represented as a set of continuous values. This differs from "digital" which uses a series of discrete quantities to represent signal. Analog values are typically represented as a <a class="uri" href="voltage" title="wikilink">voltage</a>, <a href="electric_current" title="wikilink">electric current</a>, or <a href="electric_charge" title="wikilink">electric charge</a> around components in the electronic devices. An error or noise affecting such physical quantities will result in a corresponding error in the signals represented by such physical quantities.</p>

<p>Examples of <em>analog signal processing</em> include crossover filters in loudspeakers, "bass", "treble" and "volume" controls on stereos, and "tint" controls on TVs. Common analog processing elements include capacitors, resistors, inductors and transistors.</p>
<h2 id="tools-used-in-analog-signal-processing">Tools used in analog signal processing</h2>

<p>A system's behavior can be mathematically modeled and is represented in the time domain as h(t) and in the <a href="frequency_domain" title="wikilink">frequency domain</a> as H(s), where s is a <a href="complex_number" title="wikilink">complex number</a> in the form of s=a+ib, or s=a+jb in electrical engineering terms (electrical engineers use j because current is represented by the variable i). Input signals are usually called x(t) or X(s) and output signals are usually called y(t) or Y(s).</p>
<h3 id="convolution">Convolution</h3>

<p><a class="uri" href="Convolution" title="wikilink">Convolution</a> is the basic concept in signal processing that states an input signal can be combined with the system's function to find the output signal. It is the integral of the product of two waveforms after one has reversed and shifted; the symbol for convolution is *.</p>

<p>

<math display="block" id="Analog_signal_processing:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>*</mo>
      <mi>h</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi>a</mi>
     <mi>b</mi>
    </msubsup>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>τ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mi>τ</mi>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>τ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>h</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <ci>a</ci>
       </apply>
       <ci>b</ci>
      </apply>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>τ</ci>
       <ci>h</ci>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <ci>τ</ci>
       </apply>
       <ci>d</ci>
       <ci>τ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(t)=(x*h)(t)=\int_{a}^{b}x(\tau)h(t-\tau)\,d\tau
  </annotation>
 </semantics>
</math>

 That is the convolution integral and is used to find the convolution of a signal and a system; typically a = -∞ and b = +∞.</p>

<p>Consider two waveforms f and g. By calculating the convolution, we determine how much a reversed function g must be shifted along the x-axis to become identical to function f. The convolution function essentially reverses and slides function g along the axis, and calculates the integral of their (f and the reversed and shifted g) product for each possible amount of sliding. When the functions match, the value of (f*g) is maximized. This occurs because when positive areas (peaks) or negative areas (troughs) are multiplied, they contribute to the integral.</p>
<h3 id="fourier-transform">Fourier transform</h3>

<p>The <a href="Fourier_transform" title="wikilink">Fourier transform</a> is a function that transforms a signal or system in the time domain into the frequency domain, but it only works for certain functions. The constraint on which systems or signals can be transformed by the Fourier Transform is that:</p>

<p>

<math display="block" id="Analog_signal_processing:1">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mo>-</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">|</mo>
     </mrow>
     <mi>d</mi>
     <mi>t</mi>
    </mrow>
   </mrow>
   <mo><</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <int></int>
       <infinity></infinity>
      </apply>
      <apply>
       <minus></minus>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int^{\infty}_{-\infty}|x(t)|\,dt<\infty
  </annotation>
 </semantics>
</math>

 This is the Fourier transform integral:</p>

<p>

<math display="block" id="Analog_signal_processing:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>j</mi>
      <mi>ω</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mo>-</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mpadded width="+1.7pt">
      <msup>
       <mi>e</mi>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>j</mi>
         <mi>ω</mi>
         <mi>t</mi>
        </mrow>
       </mrow>
      </msup>
     </mpadded>
     <mi>d</mi>
     <mi>t</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>X</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>ω</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <int></int>
       <infinity></infinity>
      </apply>
      <apply>
       <minus></minus>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>j</ci>
         <ci>ω</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(j\omega)=\int^{\infty}_{-\infty}x(t)e^{-j\omega t}\,dt
  </annotation>
 </semantics>
</math>

 Usually the Fourier transform integral isn't used to determine the transform; instead, a table of transform pairs is used to find the Fourier transform of a signal or system. The inverse Fourier transform is used to go from frequency domain to time domain:</p>

<p>

<math display="block" id="Analog_signal_processing:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
     </mrow>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>j</mi>
        <mi>ω</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mpadded width="+1.7pt">
       <msup>
        <mi>e</mi>
        <mrow>
         <mi>j</mi>
         <mi>ω</mi>
         <mi>t</mi>
        </mrow>
       </msup>
      </mpadded>
      <mi>d</mi>
      <mi>ω</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <int></int>
        <infinity></infinity>
       </apply>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>X</ci>
       <apply>
        <times></times>
        <ci>j</ci>
        <ci>ω</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <times></times>
         <ci>j</ci>
         <ci>ω</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <ci>d</ci>
       <ci>ω</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(t)=\frac{1}{2\pi}\int^{\infty}_{-\infty}X(j\omega)e^{j\omega t}\,d\omega
  </annotation>
 </semantics>
</math>

 Each signal or system that can be transformed has a unique Fourier transform. There is only one time signal for any frequency signal, and vice versa.</p>
<h3 id="laplace-transform">Laplace transform</h3>

<p>The <a href="Laplace_transform" title="wikilink">Laplace transform</a> is a generalized <a href="Fourier_transform" title="wikilink">Fourier transform</a>. It allows a transform of any system or signal because it is a transform into the complex plane instead of just the jω line like the Fourier transform. The major difference is that the Laplace transform has a region of convergence for which the transform is valid. This implies that a signal in frequency may have more than one signal in time; the correct time signal for the transform is determined by the <a href="region_of_convergence" title="wikilink">region of convergence</a>. If the region of convergence includes the jω axis, jω can be substituted into the Laplace transform for s and it's the same as the Fourier transform. The Laplace transform is:</p>

<p>

<math display="block" id="Analog_signal_processing:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <msup>
      <mn>0</mn>
      <mo>-</mo>
     </msup>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mpadded width="+1.7pt">
      <msup>
       <mi>e</mi>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>s</mi>
         <mi>t</mi>
        </mrow>
       </mrow>
      </msup>
     </mpadded>
     <mi>d</mi>
     <mi>t</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <int></int>
       <infinity></infinity>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">0</cn>
       <minus></minus>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>s</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(s)=\int^{\infty}_{0^{-}}x(t)e^{-st}\,dt
  </annotation>
 </semantics>
</math>

 and the inverse Laplace transform, if all the singularities of X(s) are in the left half of the complex plane, is:</p>

<p>

<math display="block" id="Analog_signal_processing:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
     </mrow>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mpadded width="+1.7pt">
       <msup>
        <mi>e</mi>
        <mrow>
         <mi>s</mi>
         <mi>t</mi>
        </mrow>
       </msup>
      </mpadded>
      <mi>d</mi>
      <mi>s</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <int></int>
        <infinity></infinity>
       </apply>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>s</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <times></times>
         <ci>s</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <ci>d</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(t)=\frac{1}{2\pi}\int^{\infty}_{-\infty}X(s)e^{st}\,ds
  </annotation>
 </semantics>
</math>

</p>
<h3 id="bode-plots">Bode plots</h3>

<p><a href="Bode_plot" title="wikilink">Bode plots</a> are plots of magnitude vs. frequency and phase vs. frequency for a system. The magnitude axis is in <a class="uri" href="Decibel" title="wikilink">Decibel</a> (dB). The phase axis is in either degrees or radians. The frequency axes are in a <a href="logarithmic_scale" title="wikilink">logarithmic scale</a>. These are useful because for sinusoidal inputs, the output is the input multiplied by the value of the magnitude plot at the frequency and shifted by the value of the phase plot at the frequency.</p>
<h2 id="domains">Domains</h2>
<h3 id="time-domain">Time domain</h3>

<p>This is the domain that most people are familiar with. A plot in the time domain shows the amplitude of the signal with respect to time.</p>
<h3 id="frequency-domain">Frequency domain</h3>

<p>A plot in the <a href="frequency_domain" title="wikilink">frequency domain</a> shows either the phase shift or magnitude of a signal at each frequency that it exists at. These can be found by taking the Fourier transform of a time signal and are plotted similarly to a bode plot.</p>
<h2 id="signals">Signals</h2>

<p>While any signal can be used in analog signal processing, there are many types of signals that are used very frequently.</p>
<h3 id="sinusoids">Sinusoids</h3>

<p><a href="Sine_wave" title="wikilink">Sinusoids</a> are the building block of analog signal processing. All real world signals can be represented as an infinite sum of sinusoidal functions via a <a href="Fourier_series" title="wikilink">Fourier series</a>. A sinusoidal function can be represented in terms of an exponential by the application of <a href="Euler's_Formula" title="wikilink">Euler's Formula</a>.</p>
<h3 id="impulse">Impulse</h3>

<p>An impulse (<a href="Dirac_delta_function" title="wikilink">Dirac delta function</a>) is defined as a signal that has an infinite magnitude and an infinitesimally narrow width with an area under it of one, centered at zero. An impulse can be represented as an infinite sum of sinusoids that includes all possible frequencies. It is not, in reality, possible to generate such a signal, but it can be sufficiently approximated with a large amplitude, narrow pulse, to produce the theoretical impulse response in a network to a high degree of accuracy. The symbol for an impulse is δ(t). If an impulse is used as an input to a system, the output is known as the impulse response. The impulse response defines the system because all possible frequencies are represented in the input</p>
<h3 id="step">Step</h3>

<p>A unit step function, also called the <a href="Heaviside_step_function" title="wikilink">Heaviside step function</a>, is a signal that has a magnitude of zero before zero and a magnitude of one after zero. The symbol for a unit step is u(t). If a step is used as the input to a system, the output is called the step response. The step response shows how a system responds to a sudden input, similar to turning on a switch. The period before the output stabilizes is called the transient part of a signal. The step response can be multiplied with other signals to show how the system responds when an input is suddenly turned on.</p>

<p>The unit step function is related to the Dirac delta function by;</p>

<p>

<math display="block" id="Analog_signal_processing:6">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mo>-</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
     <mi>t</mi>
    </msubsup>
    <mrow>
     <mi>δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>s</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-u</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>δ</ci>
      <ci>s</ci>
      <ci>d</ci>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{u}(t)=\int_{-\infty}^{t}\delta(s)ds
  </annotation>
 </semantics>
</math>

</p>
<h2 id="systems">Systems</h2>
<h3 id="linear-time-invariant-lti">Linear time-invariant (LTI)</h3>

<p>Linearity means that if you have two inputs and two corresponding outputs, if you take a linear combination of those two inputs you will get a linear combination of the outputs. An example of a linear system is a first order low-pass or high-pass filter. Linear systems are made out of analog devices that demonstrate linear properties. These devices don't have to be entirely linear, but must have a region of operation that is linear. An operational amplifier is a non-linear device, but has a region of operation that is linear, so it can be modeled as linear within that region of operation. Time-invariance means it doesn't matter when you start a system, the same output will result. For example, if you have a system and put an input into it today, you would get the same output if you started the system tomorrow instead. There aren't any real systems that are LTI, but many systems can be modeled as LTI for simplicity in determining what their output will be. All systems have some dependence on things like temperature, signal level or other factors that cause them to be non-linear or non-time-invariant, but most are stable enough to model as LTI. Linearity and time-invariance are important because they are the only types of systems that can be easily solved using conventional analog signal processing methods. Once a system becomes non-linear or non-time-invariant, it becomes a non-linear differential equations problem, and there are very few of those that can actually be solved. (Haykin &amp; Van Veen 2003)</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Signal_processing" title="wikilink">Signal processing</a></li>
<li><a href="Digital_signal_processing" title="wikilink">Digital signal processing</a></li>
<li><a href="Signal_(electrical_engineering)" title="wikilink">Signal (electrical engineering)</a></li>
<li><a href="Analogue_electronics" title="wikilink">Analogue electronics</a></li>
<li><a href="Analog_recording_vs._digital_recording" title="wikilink">Analog recording vs. digital recording</a></li>
<li><a class="uri" href="Electronics" title="wikilink">Electronics</a></li>
<li><a href="Electrical_engineering" title="wikilink">Electrical engineering</a></li>
<li><a class="uri" href="Capacitor" title="wikilink">Capacitor</a></li>
<li><a class="uri" href="Inductor" title="wikilink">Inductor</a></li>
<li><a class="uri" href="Resistor" title="wikilink">Resistor</a></li>
<li><a class="uri" href="Transistor" title="wikilink">Transistor</a></li>
</ul>
<h3 id="circuits">circuits</h3>
<ul>
<li><a href="RC_circuit" title="wikilink">RC circuit</a></li>
<li><a href="LC_circuit" title="wikilink">LC circuit</a></li>
<li><a href="RLC_circuit" title="wikilink">RLC circuit</a></li>
<li><a href="Series_and_parallel_circuits" title="wikilink">Series and parallel circuits</a></li>
</ul>
<h3 id="filters">filters</h3>
<ul>
<li><a href="Band-pass_filter" title="wikilink">Band-pass filter</a></li>
<li><a href="Band-stop_filter" title="wikilink">Band-stop filter</a></li>
<li><a href="High-pass_filter" title="wikilink">High-pass filter</a></li>
<li><a href="Low-pass_filter" title="wikilink">Low-pass filter</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Haykin, Simon, and Barry Van Veen. Signals and Systems. 2nd ed. Hoboken, NJ: John Wiley and Sons, Inc., 2003.</li>
<li>McClellan, James H., Ronald W. Schafer, and Mark A. Yoder. Signal Processing First. Upper Saddle River, NJ: Pearson Education, Inc., 2003.</li>
</ul>

<p>"</p>

<p><a href="Category:Signal_processing" title="wikilink">Category:Signal processing</a></p>
</body>
</html>
