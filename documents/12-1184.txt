   Amplitude amplification      Amplitude amplification   Amplitude amplification is a technique in quantum computing which generalizes the idea behind the Grover's search algorithm , and gives rise to a family of quantum algorithms . It was discovered by Gilles Brassard and Peter Høyer in 1997, 1 and independently rediscovered by Lov Grover in 1998. 2  In a quantum computer, amplitude amplification can be used to obtain a quadratic speedup over several classical algorithms.  Algorithm  The derivation presented here roughly follows the one given in . 3 Assume we have an N-dimensional Hilbert space    ℋ   ℋ   \mathcal{H}   representing the state space of our quantum system, spanned by the orthonormal computational basis states    B  :=    {   |  k  ⟩   }    k  =  0    N  -  1       assign  B   superscript   subscript    ket  k      k  0      N  1      B:=\{|k\rangle\}_{k=0}^{N-1}   . Furthermore assume we have a Hermitian  projection operator     P  :   ℋ  →  ℋ      normal-:  P   normal-→  ℋ  ℋ     P:\mathcal{H}\to\mathcal{H}   . Alternatively,   P   P   P   may be given in terms of a Boolean oracle function    χ  :   ℤ  →   {  0  ,  1  }       normal-:  χ   normal-→  ℤ   0  1      \chi:\mathbb{Z}\to\{0,1\}   and an orthonormal operational basis     B  op   :=    {   |   ω  k   ⟩   }    k  =  0    N  -  1       assign   subscript  B  op    superscript   subscript    ket   subscript  ω  k       k  0      N  1      B_{\text{op}}:=\{|\omega_{k}\rangle\}_{k=0}^{N-1}   , in which case      P  :=    ∑    χ   (  k  )    =  1      |   ω  k   ⟩    ⟨   ω  k   |        assign  P    subscript       χ  k   1       ket   subscript  ω  k     bra   subscript  ω  k        P:=\sum_{\chi(k)=1}|\omega_{k}\rangle\langle\omega_{k}|   .   P   P   P   can be used to partition   ℋ   ℋ   \mathcal{H}   into a direct sum of two mutually orthogonal subspaces, the good subspace    ℋ  1     subscript  ℋ  1    \mathcal{H}_{1}   and the bad subspace    ℋ  0     subscript  ℋ  0    \mathcal{H}_{0}   :      ℋ  1     subscript  ℋ  1    \displaystyle\mathcal{H}_{1}     Given a normalized state vector     |  ψ  ⟩   ∈  ℋ       ket  ψ   ℋ    |\psi\rangle\in\mathcal{H}   which has nonzero overlap with both subspaces, we can uniquely decompose it as       |  ψ  ⟩   =     sin   (  θ  )     |   ψ  1   ⟩    +    cos   (  θ  )     |   ψ  0   ⟩          ket  ψ         θ    ket   subscript  ψ  1         θ    ket   subscript  ψ  0        |\psi\rangle=\sin(\theta)|\psi_{1}\rangle+\cos(\theta)|\psi_{0}\rangle   , where    θ  =   arcsin   (   |   P   |  ψ  ⟩    |   )    ∈   [  0  ,   π  /  2   ]         θ        P   ket  ψ            0    π  2       \theta=\arcsin\left(\left|P|\psi\rangle\right|\right)\in[0,\pi/2]   , and    |   ψ  1   ⟩     ket   subscript  ψ  1     |\psi_{1}\rangle   and    |   ψ  0   ⟩     ket   subscript  ψ  0     |\psi_{0}\rangle   are the normalized projections of    |  ψ  ⟩     ket  ψ    |\psi\rangle   into the subspaces    ℋ  1     subscript  ℋ  1    \mathcal{H}_{1}   and    ℋ  0     subscript  ℋ  0    \mathcal{H}_{0}   , respectively. This decomposition defines a two-dimensional subspace    ℋ  ψ     subscript  ℋ  ψ    \mathcal{H}_{\psi}   , spanned by the vectors    |   ψ  0   ⟩     ket   subscript  ψ  0     |\psi_{0}\rangle   and    |   ψ  1   ⟩     ket   subscript  ψ  1     |\psi_{1}\rangle   .  The probability of finding the system in a good state when measured is     sin  2    (  θ  )       superscript   2   θ    \sin^{2}(\theta)   .  Define a unitary operator     Q   (  ψ  ,  P  )    :=   -    S  ψ    S  P        assign    Q   ψ  P         subscript  S  ψ    subscript  S  P       Q(\psi,P):=-S_{\psi}S_{P}\,\!   , where      S  ψ     subscript  S  ψ    \displaystyle S_{\psi}       S  P     subscript  S  P    S_{P}   flips the phase of the states in the good subspace, whereas    S  ψ     subscript  S  ψ    S_{\psi}   flips the phase of the initial state    |  ψ  ⟩     ket  ψ    |\psi\rangle   .  The action of this operator on    ℋ  ψ     subscript  ℋ  ψ    \mathcal{H}_{\psi}   is given by       Q   |   ψ  0   ⟩    =   -    S  ψ    |   ψ  0   ⟩     =     (    2    cos  2    (  θ  )     -  1   )    |   ψ  0   ⟩    +   2   sin   (  θ  )     cos   (  θ  )     |   ψ  1   ⟩             Q   ket   subscript  ψ  0          subscript  S  ψ    ket   subscript  ψ  0                   2    superscript   2   θ    1    ket   subscript  ψ  0       2    θ     θ    ket   subscript  ψ  1         Q|\psi_{0}\rangle=-S_{\psi}|\psi_{0}\rangle=(2\cos^{2}(\theta)-1)|\psi_{0}%
 \rangle+2\sin(\theta)\cos(\theta)|\psi_{1}\rangle   and       Q   |   ψ  1   ⟩    =    S  ψ    |   ψ  1   ⟩    =    -   2   sin   (  θ  )     cos   (  θ  )     |   ψ  0   ⟩     +    (   1  -   2    sin  2    (  θ  )      )    |   ψ  1   ⟩             Q   ket   subscript  ψ  1        subscript  S  ψ    ket   subscript  ψ  1                2    θ     θ    ket   subscript  ψ  0          1    2    superscript   2   θ      ket   subscript  ψ  1         Q|\psi_{1}\rangle=S_{\psi}|\psi_{1}\rangle=-2\sin(\theta)\cos(\theta)|\psi_{0}%
 \rangle+(1-2\sin^{2}(\theta))|\psi_{1}\rangle   . Thus in the    ℋ  ψ     subscript  ℋ  ψ    \mathcal{H}_{\psi}   subspace   Q   Q   Q   corresponds to a rotation by the angle    2  θ      2  θ    2\theta\,\!   :      Q  =   (      cos   (   2  θ   )       sin   (   2  θ   )         -   sin   (   2  θ   )        cos   (   2  θ   )       )       Q        2  θ        2  θ            2  θ         2  θ        Q=\begin{pmatrix}\cos(2\theta)&\sin(2\theta)\\
 -\sin(2\theta)&\cos(2\theta)\end{pmatrix}   .  Applying   Q   Q   Q      n   n   n   times on the state    |  ψ  ⟩     ket  ψ    |\psi\rangle   gives        Q  n    |  ψ  ⟩    =     cos   (    (    2  n   +  1   )   θ   )     |   ψ  0   ⟩    +    sin   (    (    2  n   +  1   )   θ   )     |   ψ  1   ⟩            superscript  Q  n    ket  ψ                2  n   1   θ     ket   subscript  ψ  0               2  n   1   θ     ket   subscript  ψ  1        Q^{n}|\psi\rangle=\cos((2n+1)\theta)|\psi_{0}\rangle+\sin((2n+1)\theta)|\psi_{%
 1}\rangle   , rotating the state between the good and bad subspaces. After   n   n   n   iterations the probability of finding the system in a good state is     sin  2    (    (    2  n   +  1   )   θ   )       superscript   2         2  n   1   θ     \sin^{2}((2n+1)\theta)\,\!   . The probability is maximized if we choose      n  =   ⌊   π   4  θ    ⌋       n      π    4  θ       n=\left\lfloor\frac{\pi}{4\theta}\right\rfloor   . Up until this point each iteration increases the amplitude of the good states, hence the name of the technique.  Applications  Assume we have an unsorted database with N elements, and an oracle function   χ   χ   \chi   which can recognize the good entries we are searching for, and     B  op   =  B       subscript  B  op   B    B_{\text{op}}=B   for simplicity.  If there are G such entries in the database in total, then we can find them by initializing the quantum computer into a uniform superposition       |  ψ  ⟩   =    1   N      ∑   k  =  0    N  -  1     |  k  ⟩          ket  ψ       1    N      superscript   subscript     k  0      N  1     ket  k       |\psi\rangle=\frac{1}{\sqrt{N}}\sum_{k=0}^{N-1}|k\rangle   of all the database elements, and running the above algorithm. In this case the overlap of the initial state with the good subspace is equal to the square root of the frequency of the good entries in the database,     sin   (  θ  )    =   |   P   |  ψ  ⟩    |   =    G  /  N            θ       P   ket  ψ              G  N       \sin(\theta)=|P|\psi\rangle|=\sqrt{G/N}   . If     sin   (  θ  )    ≪  1     much-less-than    θ   1    \sin(\theta)\ll 1   , we can approximate the number of required iterations as       n  =   ⌊   π   4  θ    ⌋   ≈   ⌊   π   4   sin   (  θ  )      ⌋   =   ⌊    π  4     N  G     ⌋   =   O   (   N   )     .        n      π    4  θ              π    4    θ                 π  4       N  G             O    N       n=\left\lfloor\frac{\pi}{4\theta}\right\rfloor\approx\left\lfloor\frac{\pi}{4%
 \sin(\theta)}\right\rfloor=\left\lfloor\frac{\pi}{4}\sqrt{\frac{N}{G}}\right%
 \rfloor=O(\sqrt{N}).   Measuring the state will now give one of the good entries with a high probability. Since each application of    S  P     subscript  S  P    S_{P}   requires a single oracle query (assuming that the oracle is implemented as a quantum gate), we can find a good entry with just    O   (   N   )       O    N     O(\sqrt{N})   oracle queries, thus obtaining a quadratic speedup over the best possible classical algorithm.  If we set G to one, the above scenario essentially reduces to the original Grover search.  References  "  Category:Quantum algorithms  Category:Search algorithms     ↩  ↩  ↩     