<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="278">Suffix array</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Suffix array</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>{| class="infobox" style="width: 22em" ! Suffix array |- ! <a href="List_of_data_structures" title="wikilink">Type</a> | <a href="Array_data_structure" title="wikilink">Array</a> |- ! Invented by 

<math display="inline" id="Suffix_array:0">
 <semantics>
  <mo stretchy="false">|</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-|</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |
  </annotation>
 </semantics>
</math>

 Manber|Myers|1990}}</p>

<p>|- ! <a href="Time_complexity" title="wikilink">Time complexity</a><br/>
in <a href="big_O_notation" title="wikilink">big O notation</a> |- | | Average | Worst case |- ! Space | 

<math display="inline" id="Suffix_array:1">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(n)
  </annotation>
 </semantics>
</math>

 | 

<math display="inline" id="Suffix_array:2">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(n)
  </annotation>
 </semantics>
</math>

 |- ! Construction | 

<math display="inline" id="Suffix_array:3">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(n)
  </annotation>
 </semantics>
</math>

 | 

<math display="inline" id="Suffix_array:4">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(n)
  </annotation>
 </semantics>
</math>

 |}</p>

<p>In <a href="computer_science" title="wikilink">computer science</a>, a <strong>suffix array</strong> is a sorted <a href="Array_data_structure" title="wikilink">array</a> of all <a href="Suffix_(computer_science)" title="wikilink">suffixes</a> of a <a href="String_(computer_science)" title="wikilink">string</a>. It is a data structure used, among others, in full text indices, data compression algorithms and within the field of <a class="uri" href="bioinformatics" title="wikilink">bioinformatics</a>.</p>

<p>Suffix arrays were introduced by  as a simple, space efficient alternative to <a href="suffix_tree" title="wikilink">suffix trees</a>. They have independently been discovered by  under the name <em>PAT array</em>.</p>
<h2 id="definition">Definition</h2>

<p>Let 

<math display="inline" id="Suffix_array:5">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>1</mn>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>2</mn>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi mathvariant="normal">…</mi>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <cn type="integer">1</cn>
     </apply>
     <ci>S</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <ci>S</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=S[1]S[2]...S[n]
  </annotation>
 </semantics>
</math>

 be a string and let 

<math display="inline" id="Suffix_array:6">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <interval closure="closed">
     <ci>i</ci>
     <ci>j</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S[i,j]
  </annotation>
 </semantics>
</math>

 denote the substring of 

<math display="inline" id="Suffix_array:7">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 ranging from 

<math display="inline" id="Suffix_array:8">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Suffix_array:9">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

.</p>

<p>The suffix array 

<math display="inline" id="Suffix_array:10">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Suffix_array:11">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is now defined to be an array of integers providing the starting positions of <a href="Suffix_(computer_science)" title="wikilink">suffixes</a> of 

<math display="inline" id="Suffix_array:12">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 in <a href="lexicographical_order" title="wikilink">lexicographical order</a>. This means, an entry 

<math display="inline" id="Suffix_array:13">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>i</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A[i]
  </annotation>
 </semantics>
</math>

 contains the starting position of the 

<math display="inline" id="Suffix_array:14">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th smallest suffix in 

<math display="inline" id="Suffix_array:15">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 and thus for all 

<math display="inline" id="Suffix_array:16">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo><</mo>
   <mi>i</mi>
   <mo>≤</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1<i\leq n
  </annotation>
 </semantics>
</math>



<math display="block" id="Suffix_array:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>A</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>i</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>A</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>i</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>S</ci>
     <interval closure="closed">
      <apply>
       <times></times>
       <ci>A</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <minus></minus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <ci>n</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>S</ci>
     <interval closure="closed">
      <apply>
       <times></times>
       <ci>A</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>i</ci>
       </apply>
      </apply>
      <ci>n</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S[A[i-1],n]<S[A[i],n]
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="example">Example</h2>

<p>Consider the text 

<math display="inline" id="Suffix_array:18">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

=<code>banana$</code> to be indexed:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">

<p>| i</p></th>
<th style="text-align: left;">
<p>1</p></th>
<th style="text-align: left;">
<p>2</p></th>
<th style="text-align: left;">
<p>3</p></th>
<th style="text-align: left;">
<p>4</p></th>
<th style="text-align: left;">
<p>5</p></th>
<th style="text-align: left;">
<p>6</p></th>
<th style="text-align: left;">
<p>7</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>| 

<math display="inline" id="Suffix_array:19">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>i</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S[i]
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>b</p></td>
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;">
<p>n</p></td>
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;">
<p>n</p></td>
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;">
<p>$</p></td>
</tr>
</tbody>
</table>

<p>The text ends with the special sentinel letter <code>$</code> that is unique and lexicographically smaller than any other character. The text has the following suffixes:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Suffix</p></th>
<th style="text-align: left;">
<p>i</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>banana$</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>anana$</p></td>
<td style="text-align: left;">
<p>2</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>nana$</p></td>
<td style="text-align: left;">
<p>3</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>ana$</p></td>
<td style="text-align: left;">
<p>4</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>na$</p></td>
<td style="text-align: left;">
<p>5</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>a$</p></td>
<td style="text-align: left;">
<p>6</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>$</p></td>
<td style="text-align: left;">
<p>7</p></td>
</tr>
</tbody>
</table>

<p>These suffixes can be sorted in ascending order:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Suffix</p></th>
<th style="text-align: left;">
<p>i</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>$</p></td>
<td style="text-align: left;">
<p>7</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>a$</p></td>
<td style="text-align: left;">
<p>6</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>ana$</p></td>
<td style="text-align: left;">
<p>4</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>anana$</p></td>
<td style="text-align: left;">
<p>2</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>banana$</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>na$</p></td>
<td style="text-align: left;">
<p>5</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>nana$</p></td>
<td style="text-align: left;">
<p>3</p></td>
</tr>
</tbody>
</table>

<p>The suffix array 

<math display="inline" id="Suffix_array:20">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 contains the starting positions of these sorted suffixes:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">

<p>| i</p></th>
<th style="text-align: left;">
<p>1</p></th>
<th style="text-align: left;">
<p>2</p></th>
<th style="text-align: left;">
<p>3</p></th>
<th style="text-align: left;">
<p>4</p></th>
<th style="text-align: left;">
<p>5</p></th>
<th style="text-align: left;">
<p>6</p></th>
<th style="text-align: left;">
<p>7</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>| 

<math display="inline" id="Suffix_array:21">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>i</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A[i]
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>3</p></td>
</tr>
</tbody>
</table>

<p>The suffix array with the suffixes written out vertically underneath for clarity:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">

<p>| i</p></th>
<th style="text-align: left;">
<p>1</p></th>
<th style="text-align: left;">
<p>2</p></th>
<th style="text-align: left;">
<p>3</p></th>
<th style="text-align: left;">
<p>4</p></th>
<th style="text-align: left;">
<p>5</p></th>
<th style="text-align: left;">
<p>6</p></th>
<th style="text-align: left;">
<p>7</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>| 

<math display="inline" id="Suffix_array:22">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>i</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A[i]
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>3</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>| 1</p></td>
<td style="text-align: left;">
<p>$</p></td>
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;">
<p>b</p></td>
<td style="text-align: left;">
<p>n</p></td>
<td style="text-align: left;">
<p>n</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>| 2</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>$</p></td>
<td style="text-align: left;">
<p>n</p></td>
<td style="text-align: left;">
<p>n</p></td>
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;">
<p>a</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>| 3</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;">
<p>n</p></td>
<td style="text-align: left;">
<p>$</p></td>
<td style="text-align: left;">
<p>n</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>| 4</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>$</p></td>
<td style="text-align: left;">
<p>n</p></td>
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>a</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>| 5</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;">
<p>n</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>$</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>| 6</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>$</p></td>
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>| 7</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>$</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>

<p>So for example, 

<math display="inline" id="Suffix_array:23">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>3</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A[3]
  </annotation>
 </semantics>
</math>

 contains the value 4, and therefore refers to the suffix starting at position 4 within 

<math display="inline" id="Suffix_array:24">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, which is the suffix <code>ana$</code>.</p>
<h2 id="correspondence-to-suffix-trees">Correspondence to suffix trees</h2>

<p>Suffix arrays are closely related to <a href="suffix_tree" title="wikilink">suffix trees</a>:</p>
<ul>
<li>Suffix arrays can be constructed by performing a <a href="depth-first_traversal" title="wikilink">depth-first traversal</a> of a suffix tree. The suffix array corresponds to the leaf-labels given in the order in which these are visited during the traversal, if edges are visited in the lexicographical order of their first character.</li>
<li>A suffix tree can be constructed in linear time by using a combination of suffix and <a href="LCP_array" title="wikilink">LCP array</a>. For a description of the algorithm, see the <a href="LCP_array#Suffix_tree_construction" title="wikilink">corresponding section</a> in the <a href="LCP_array" title="wikilink">LCP array</a> article.</li>
</ul>

<p>It has been shown that every suffix tree algorithm can be systematically replaced with an algorithm that uses a suffix array enhanced with additional information (such as the <a href="LCP_array" title="wikilink">LCP array</a>) and solves the same problem in the same time complexity. Advantages of suffix arrays over suffix trees include improved space requirements, simpler linear time construction algorithms (e.g., compared to <a href="Ukkonen's_algorithm" title="wikilink">Ukkonen's algorithm</a>) and improved cache locality.</p>
<h2 id="space-efficiency">Space Efficiency</h2>

<p>Suffix arrays were introduced by  in order to improve over the space requirements of <a href="suffix_tree" title="wikilink">suffix trees</a>: Suffix arrays store 

<math display="inline" id="Suffix_array:25">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 integers. Assuming an integer requires 

<math display="inline" id="Suffix_array:26">
 <semantics>
  <mn>4</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">4</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4
  </annotation>
 </semantics>
</math>

 bytes, a suffix array requires 

<math display="inline" id="Suffix_array:27">
 <semantics>
  <mrow>
   <mn>4</mn>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">4</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4n
  </annotation>
 </semantics>
</math>

 bytes in total. This is significantly less than the 

<math display="inline" id="Suffix_array:28">
 <semantics>
  <mrow>
   <mn>20</mn>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">20</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   20n
  </annotation>
 </semantics>
</math>

 bytes which are required by a careful suffix tree implementation.</p>

<p>However, in certain applications, the space requirements of suffix arrays may still be prohibitive. Analyzed in bits, a suffix array requires 

<math display="inline" id="Suffix_array:29">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(n\log n)
  </annotation>
 </semantics>
</math>

 space, whereas the original text over an alphabet of size 

<math display="inline" id="Suffix_array:30">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 only requires 

<math display="inline" id="Suffix_array:31">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mi>log</mi>
      <mi>σ</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <log></log>
      <ci>σ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(n\log\sigma)
  </annotation>
 </semantics>
</math>

 bits. For a human genome with 

<math display="inline" id="Suffix_array:32">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>σ</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma=4
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Suffix_array:33">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mn>3.4</mn>
    <mo>×</mo>
    <msup>
     <mn>10</mn>
     <mn>9</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <times></times>
     <cn type="float">3.4</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">10</cn>
      <cn type="integer">9</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=3.4\times 10^{9}
  </annotation>
 </semantics>
</math>

 the suffix array would therefore occupy about 16 times more memory than the genome itself.</p>

<p>Such discrepancies motivated a trend towards <a href="compressed_suffix_array" title="wikilink">compressed suffix arrays</a> and <a class="uri" href="BWT" title="wikilink">BWT</a>-based compressed full-text indices such as the <a class="uri" href="FM-index" title="wikilink">FM-index</a>. These data structures require only space within the size of the text or even less.</p>
<h2 id="construction-algorithms">Construction Algorithms</h2>

<p>A suffix tree can be built in 

<math display="inline" id="Suffix_array:34">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(n)
  </annotation>
 </semantics>
</math>

 and can be converted into a suffix array by traversing the tree depth-first also in 

<math display="inline" id="Suffix_array:35">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(n)
  </annotation>
 </semantics>
</math>

, so there exist algorithms that can build a suffix array in 

<math display="inline" id="Suffix_array:36">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(n)
  </annotation>
 </semantics>
</math>

.</p>

<p>A naive approach to construct a suffix array is to use a <a href="Comparison_sort" title="wikilink">comparison-based sorting algorithm</a>. These algorithms require 

<math display="inline" id="Suffix_array:37">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(n\log n)
  </annotation>
 </semantics>
</math>

 suffix comparisons, but a suffix comparison runs in 

<math display="inline" id="Suffix_array:38">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(n)
  </annotation>
 </semantics>
</math>

 time, so the overall runtime of this approach is 

<math display="inline" id="Suffix_array:39">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>n</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(n^{2}\log n)
  </annotation>
 </semantics>
</math>

.</p>

<p>More advanced algorithms take advantage of the fact that the suffixes to be sorted are not arbitrary strings but related to each other. These algorithms strive to achieve the following goals:</p>
<ul>
<li>minimal asymptotic complexity 

<math display="inline" id="Suffix_array:40">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(n)
  </annotation>
 </semantics>
</math>

</li>
<li>lightweight in space, meaning little or no working memory beside the text and the suffix array itself is needed</li>
<li>fast in practice</li>
</ul>

<p>One of the first algorithms to achieve all goals is the SA-IS algorithm of . The algorithm is also rather simple (n and <em>general alphabets</em> where only character comparisons are allowed.</p>

<p>Most suffix array construction algorithms are based on one of the following approaches:</p>
<ul>
<li><em>Prefix doubling</em> algorithms are based on a strategy of . The idea is to find prefixes that honor the lexicographic ordering of suffixes. The assessed prefix length doubles in each iteration of the algorithm until a prefix is unique and provides the rank of the associated suffix.</li>
<li><em>Recursive</em> algorithms follow the approach of the suffix tree construction algorithm by  to recursively sort a subset of suffixes. This subset is then used to infer a suffix array of the remaining suffixes. Both of these suffix arrays are then merged to compute the final suffix array.</li>
<li><em>Induced copying</em> algorithms are similar to recursive algorithms in the sense that they use an already sorted subset to induce a fast sort of the remaining suffixes. The difference is that these algorithms favor iteration over recursion to sort the selected suffix subset. A survey of this diverse group of algorithms has been put together by .</li>
</ul>

<p>A well-known recursive algorithm for integer alphabets is the <em>DC3 / skew</em> algorithm of . It runs in linear time and has successfully been used as the basis for parallel and <a href="External_memory_algorithm" title="wikilink">external memory</a> suffix array construction algorithms.</p>

<p>Recent work by  proposes an algorithm for updating the suffix array of a text that has been edited instead of rebuilding a new suffix array from scratch. Even if the theoretical worst-case time complexity is 

<math display="inline" id="Suffix_array:41">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(n\log n)
  </annotation>
 </semantics>
</math>

, it appears to perform well in practice: experimental results from the authors showed that their implementation of dynamic suffix arrays is generally more efficient than rebuilding when considering the insertion of a reasonable number of letters in the original text.</p>
<h2 id="applications">Applications</h2>

<p>The suffix array of a string can be used as an <a href="Index_(search_engine)" title="wikilink">index</a> to quickly locate every occurrence of a substring pattern 

<math display="inline" id="Suffix_array:42">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 within the string 

<math display="inline" id="Suffix_array:43">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

. Finding every occurrence of the pattern is equivalent to finding every suffix that begins with the substring. Thanks to the lexicographical ordering, these suffixes will be grouped together in the suffix array and can be found efficiently with two <a href="binary_search" title="wikilink">binary searches</a>. The first search locates the starting position of the interval, and the second one determines the end position:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> search(P):
        l <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> r <span class="op">=</span> n
        <span class="cf">while</span> l <span class="op">&lt;</span> r:
            mid <span class="op">=</span> (l<span class="op">+</span>r) <span class="op">/</span> <span class="dv">2</span>
            <span class="cf">if</span> P <span class="op">&gt;</span> suffixAt(A[mid]):
                l <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span>
            <span class="cf">else</span>:
                r <span class="op">=</span> mid
        s <span class="op">=</span> l<span class="op">;</span> r <span class="op">=</span> n
        <span class="cf">while</span> l <span class="op">&lt;</span> r:
            mid <span class="op">=</span> (l<span class="op">+</span>r) <span class="op">/</span> <span class="dv">2</span>
            <span class="cf">if</span> P <span class="op">&lt;</span> suffixAt(A[mid]):
                r <span class="op">=</span> mid
            <span class="cf">else</span>:
                l <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span>
        <span class="cf">return</span> (s, r)</code></pre></div>

<p>Finding the substring pattern 

<math display="inline" id="Suffix_array:44">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 of length 

<math display="inline" id="Suffix_array:45">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 in the string 

<math display="inline" id="Suffix_array:46">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 of length 

<math display="inline" id="Suffix_array:47">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 takes 

<math display="inline" id="Suffix_array:48">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>m</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(m\log n)
  </annotation>
 </semantics>
</math>

 time, given that a single suffix comparison needs to compare 

<math display="inline" id="Suffix_array:49">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 characters.  describe how this bound can be improved to 

<math display="inline" id="Suffix_array:50">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>m</mi>
     <mo>+</mo>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <apply>
     <plus></plus>
     <ci>m</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(m+\log n)
  </annotation>
 </semantics>
</math>

 time using <a href="LCP_array" title="wikilink">LCP</a> information. The idea is that a pattern comparison does not need to re-compare certain characters, when it is already known that these are part of the longest common prefix of the pattern and the current search interval.  improve the bound even further and achieve a search time of 

<math display="inline" id="Suffix_array:51">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(m)
  </annotation>
 </semantics>
</math>

 as known from <a href="suffix_tree" title="wikilink">suffix trees</a>.</p>

<p>Suffix sorting algorithms can be used to compute the <a href="Burrows–Wheeler_transform" title="wikilink">Burrows–Wheeler transform (BWT)</a>. The <a href="Burrows–Wheeler_transform" title="wikilink">BWT</a> requires sorting of all cyclic permutations of a string. If this string ends in a special end-of-string character that is lexicographically smaller than all other character (i.e., $), then the order of the sorted rotated <a href="Burrows–Wheeler_transform" title="wikilink">BWT</a> matrix corresponds to the order of suffixes in a suffix array. The <a href="Burrows–Wheeler_transform" title="wikilink">BWT</a> can therefore be computed in linear time by first constructing a suffix array of the text and then deducing the <a href="Burrows–Wheeler_transform" title="wikilink">BWT</a> string

<math display="block" id="Suffix_array:52">
 <semantics>
  <mrow>
   <mrow>
    <mi>B</mi>
    <mi>W</mi>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>i</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <mi>A</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>i</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>B</ci>
     <ci>W</ci>
     <ci>T</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>A</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>i</ci>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   BWT[i]=S[A[i]-1]
  </annotation>
 </semantics>
</math>

.</p>

<p>Suffix arrays can also be used to look up substrings in <a href="Example-Based_Machine_Translation" title="wikilink">Example-Based Machine Translation</a>, demanding much less storage than a full <a href="phrase_table" title="wikilink">phrase table</a> as used in <a href="Statistical_machine_translation" title="wikilink">Statistical machine translation</a>.</p>

<p>Many additional applications of the suffix array require the <a href="LCP_array" title="wikilink">LCP array</a>. Some of these are detailed in the <a href="LCP_array#Applications" title="wikilink">application section</a> of the latter.</p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://algs4.cs.princeton.edu/63suffix/SuffixArray.java.html">Suffix Array in Java</a></li>
<li><a href="http://code.google.com/p/compression-code/downloads/list">Suffix sorting module for BWT in C code</a></li>
<li><a href="http://www.codeodor.com/index.cfm/2007/12/24/The-Suffix-Array/1845">Suffix Array Implementation in Ruby</a></li>
<li><a href="http://sary.sourceforge.net/index.html.en">Suffix array library and tools</a></li>
<li><a href="http://pizzachili.dcc.uchile.cl/">Project containing various Suffix Array c/c++ Implementations with a unified interface</a></li>
<li><a href="http://code.google.com/p/libdivsufsort/">A fast, lightweight, and robust C API library to construct the suffix array</a></li>
<li><a href="http://code.google.com/p/pysuffix/">Suffix Array implementation in Python</a></li>
<li><a href="http://www.geeksforgeeks.org/suffix-tree-application-4-build-linear-time-suffix-array/">Linear Time Suffix Array implementation in C using suffix tree</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Arrays" title="wikilink">Category:Arrays</a> <a href="Category:Substring_indices" title="wikilink">Category:Substring indices</a> <a href="Category:String_data_structures" title="wikilink">Category:String data structures</a></p>
</body>

