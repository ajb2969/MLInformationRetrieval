<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1480">Syntactic predicate</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Syntactic predicate</h1>
<hr/>

<p>A <strong>syntactic predicate</strong> specifies the syntactic validity of applying a <a href="Formal_grammar#The_syntax_of_grammars" title="wikilink">production</a> in a <a href="formal_grammar" title="wikilink">formal grammar</a> and is analogous to a <a class="uri" href="semantic" title="wikilink">semantic</a> <a href="Predicate_(grammar)" title="wikilink">predicate</a> that specifies the semantic validity of applying a production. It is a simple and effective means of dramatically improving the recognition strength of an <a href="LL_parser" title="wikilink">LL parser</a> by providing arbitrary lookahead. In their original implementation, syntactic predicates had the form “( α )?” and could only appear on the left edge of a production. The required syntactic condition α could be any valid context-free grammar fragment.</p>

<p>More formally, a <strong>syntactic predicate</strong> is a form of production <a href="intersection_(set_theory)" title="wikilink">intersection</a>, used in <a href="parsing" title="wikilink">parser</a> specifications or in <a href="formal_grammar" title="wikilink">formal grammars</a>. In this sense, the term <em>predicate</em> has the meaning of a mathematical <a href="indicator_function" title="wikilink">indicator function</a>. If <em>p<sub>1</sub></em> and <em>p<sub>2,</sub></em> are production rules, the <a href="Formal_language" title="wikilink">language</a> generated by <em>both</em> <em>p<sub>1</sub></em> <strong>and</strong> <em>p<sub>2</sub></em> is their set intersection.</p>

<p>As typically defined or implemented, syntactic predicates implicitly order the productions so that predicated productions specified earlier have higher precedence than predicated productions specified later within the same decision. This conveys an ability to disambiguate ambiguous productions because the programmer can simply specify which production should match.</p>

<p><a href="Parsing_expression_grammar" title="wikilink">Parsing expression grammars</a> (PEGs), invented by Bryan Ford, extend these simple predicates by allowing "not predicates" and permitting a predicate to appear anywhere within a production. Morever, Ford invented <a href="packrat_parsing" title="wikilink">packrat parsing</a> to handle these grammars in linear time by employing <a class="uri" href="memoization" title="wikilink">memoization</a>, at the cost of heap space.</p>

<p>It is possible to support linear-time parsing of predicates as general as those allowed by PEGs, but reduce the memory cost associated with memoization by avoiding backtracking where some more efficient implementation of lookahead suffices. This approach is implemented by <a class="uri" href="ANTLR" title="wikilink">ANTLR</a> version 3, which uses <a href="Deterministic_finite_automata" title="wikilink">Deterministic finite automata</a> for lookahead; this may require testing a predicate in order to choose between transitions of the DFA (called "pred-LL(*)" parsing).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="overview">Overview</h2>
<h3 id="terminology">Terminology</h3>

<p>The term <em>syntactic predicate</em> was coined by Parr &amp; Quong and differentiates this form of predicate from <a href="semantic_predicate" title="wikilink">semantic predicates</a> (also discussed).<ref name="Parr&amp;Quong1993"></ref></p>

<p>Syntactic predicates have been called <em>multi-step matching</em>, <em>parse constraints</em>, and simply <em>predicates</em> in various literature. (See References section below.) This article uses the term <em>syntactic predicate</em> throughout for consistency and to distinguish them from <a href="semantic_predicate" title="wikilink">semantic predicates</a>.</p>
<h3 id="formal-closure-properties">Formal closure properties</h3>

<p><a href="Yehoshua_Bar-Hillel" title="wikilink">Bar-Hillel</a> <em>et al.</em><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> show that the intersection of two <a href="regular_language" title="wikilink">regular languages</a> is also a regular language, which is to say that the regular languages are <a href="Closure_(mathematics)" title="wikilink">closed</a> under <a href="Intersection_(set_theory)" title="wikilink">intersection</a>.</p>

<p>The intersection of a <a href="regular_language" title="wikilink">regular language</a> and a <a class="uri" href="context-free" title="wikilink">context-free</a> language is also closed, and it has been known at least since Hartmanis<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> that the intersection of two <a class="uri" href="context-free" title="wikilink">context-free</a> languages is not necessarily a context-free language (and is thus not closed). This can be demonstrated easily using the canonical <a href="Chomsky_hierarchy" title="wikilink">Type 1</a> language, 

<math display="inline" id="Syntactic_predicate:0">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <msup>
      <mi>a</mi>
      <mi>n</mi>
     </msup>
     <msup>
      <mi>b</mi>
      <mi>n</mi>
     </msup>
     <msup>
      <mi>c</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mi>n</mi>
     <mo>≥</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>c</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <geq></geq>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=\{a^{n}b^{n}c^{n}:n\geq 1\}
  </annotation>
 </semantics>
</math>

:</p>

<p><code>Let </code>

<math display="inline" id="Syntactic_predicate:1">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <msup>
      <mi>a</mi>
      <mi>m</mi>
     </msup>
     <msup>
      <mi>b</mi>
      <mi>n</mi>
     </msup>
     <msup>
      <mi>c</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mi>m</mi>
      <mo>,</mo>
      <mi>n</mi>
     </mrow>
     <mo>≥</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>c</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <geq></geq>
      <list>
       <ci>m</ci>
       <ci>n</ci>
      </list>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{1}=\{a^{m}b^{n}c^{n}:m,n\geq 1\}
  </annotation>
 </semantics>
</math>

<code> (Type 2)</code><br/>
<code>Let </code>

<math display="inline" id="Syntactic_predicate:2">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <msup>
      <mi>a</mi>
      <mi>n</mi>
     </msup>
     <msup>
      <mi>b</mi>
      <mi>n</mi>
     </msup>
     <msup>
      <mi>c</mi>
      <mi>m</mi>
     </msup>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mi>m</mi>
      <mo>,</mo>
      <mi>n</mi>
     </mrow>
     <mo>≥</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>c</ci>
       <ci>m</ci>
      </apply>
     </apply>
     <apply>
      <geq></geq>
      <list>
       <ci>m</ci>
       <ci>n</ci>
      </list>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{2}=\{a^{n}b^{n}c^{m}:m,n\geq 1\}
  </annotation>
 </semantics>
</math>

<code> (Type 2)</code><br/>
<code>Let </code>

<math display="inline" id="Syntactic_predicate:3">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mn>3</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>L</mi>
     <mn>1</mn>
    </msub>
    <mo>∩</mo>
    <msub>
     <mi>L</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <intersect></intersect>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{3}=L_{1}\cap L_{2}
  </annotation>
 </semantics>
</math>

</p>

<p>Given the <a href="String_(computer_science)" title="wikilink">strings</a> <em>abcc</em>, <em>aabbc</em>, and <em>aaabbbccc</em>, it is clear that the only string that belongs to both L<sub>1</sub> <strong>and</strong> L<sub>2</sub> (that is, the only one that produces a <a href="empty_string" title="wikilink">non-empty</a> intersection) is <em>aaabbbccc</em>.</p>
<h3 id="other-considerations">Other considerations</h3>

<p>In most formalisms that use syntactic predicates, the syntax of the predicate is <a href="Commutative" title="wikilink">noncommutative</a>, which is to say that the operation of predication is ordered. For instance, using the above example, consider the following pseudo-grammar, where <em>X ::= Y PRED Z</em> is understood to mean: "<em>Y</em> produces <em>X</em> <a href="if_and_only_if" title="wikilink">if and only if</a> <em>Y</em> also satisfies predicate <em>Z</em>":</p>

<p><code>S    ::= a X</code><br/>
<code>X    ::= Y PRED Z</code><br/>
<code>Y    ::= a+ BNCN</code><br/>
<code>Z    ::= ANBN c+</code><br/>
<code>BNCN ::= b [BNCN] c</code><br/>
<code>ANBN ::= a [ANBN] b</code></p>

<p>Given the string <em>aaaabbbccc</em>, in the case where <em>Y</em> must be satisfied <em>first</em> (and assuming a greedy implementation), S will generate <em>aX</em> and <em>X</em> in turn will generate <em>aaabbbccc</em>, thereby generating <em>aaaabbbccc</em>. In the case where <em>Z</em> must be satisfied first, ANBN will fail to generate <em>aaaabbb</em>, and thus <em>aaaabbbccc</em> is not generated by the grammar. Moreover, if either <em>Y</em> or <em>Z</em> (or both) specify any action to be taken upon reduction (as would be the case in many parsers), the order that these productions match determines the order in which those side-effects occur. Formalisms that vary over time (such as <a href="adaptive_grammar" title="wikilink">adaptive grammars</a>) may rely on these <a href="side_effect_(computer_science)" title="wikilink">side effects</a>.</p>
<h3 id="examples-of-use">Examples of use</h3>
<dl>
<dt>ANTLR</dt>
</dl>

<p>Parr &amp; Quong<ref name="Parr&amp;Quong1995"> give this example of a syntactic predicate:</ref></p>

<p><code>stat: (declaration)? declaration</code><br/>
<code>    | expression</code><br/>
<code>    ;</code></p>

<p>which is intended to satisfy the following informally stated<ref name="Stroustrup&amp;Ellis1990"> constraints of <a class="uri" href="C++" title="wikilink">C++</a>:</ref></p>
<ol>
<li>If it looks like a declaration, it is; otherwise</li>
<li>if it looks like an expression, it is; otherwise</li>
<li>it is a syntax error.</li>
</ol>

<p>In the first production of rule stat, the syntactic predicate <strong>(declaration)?</strong> indicates that declaration is the syntactic context that must be present for the rest of that production to succeed. We can interpret the use of (declaration)? as "I am not sure if declaration will match; let me try it out and, if it does not match, I shall try the next alternative." Thus, when encountering a valid declaration, the rule declaration will be recognized twice—once as syntactic predicate and once during the actual parse to execute semantic actions.</p>

<p>Of note in the above example is the fact that any code triggered by the acceptance of the <em>declaration</em> production will only occur if the predicate is satisfied.</p>
<h4 id="canonical-examples">Canonical examples</h4>

<p>The language 

<math display="inline" id="Syntactic_predicate:4">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <msup>
      <mi>a</mi>
      <mi>n</mi>
     </msup>
     <msup>
      <mi>b</mi>
      <mi>n</mi>
     </msup>
     <msup>
      <mi>c</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>n</mi>
     <mo>≥</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>c</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <geq></geq>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=\{a^{n}b^{n}c^{n}|n\geq 1\}
  </annotation>
 </semantics>
</math>

 can be represented in various grammars and formalisms as follows:</p>
<dl>
<dt>Parsing Expression Grammars</dt>
</dl>

<p><code>S ← &amp;(A !b) a+ B !c</code><br/>
<code>A ← a A? b</code><br/>
<code>B ← b B? c</code></p>
<dl>
<dt>§-Calculus</dt>
</dl>

<p>Using a <em>bound</em> predicate:</p>

<p><code>S → {A}</code><sup><code>B</code></sup></p>

<p><code>A → X 'c+'</code><br/>
<code>X → 'a' [X] 'b'</code><br/>
<code>B → 'a+' Y</code><br/>
<code>Y → 'b' [Y] 'c'</code></p>

<p>Using two <em>free</em> predicates:</p>

<p><code>A → </code><sub><em><code>a</code></em></sub><code> </code><sub><em><code>b</code></em></sub><code> Ψ(</code><em><code>a</code></em><code> </code><em><code>b</code></em><code>)</code><sup><code>X</code></sup><code> </code><sub><em><code>c</code></em></sub><code> Ψ(</code><em><code>b</code></em><code> </code><em><code>c</code></em><code>)</code><sup><code>Y</code></sup></p>

<p><code>X → 'a' [X] 'b'</code><br/>
<code>Y → 'b' [Y] 'c'</code></p>
<dl>
<dt>Conjunctive Grammars</dt>
</dl>

<p>(Note: the following example actually generates 

<math display="inline" id="Syntactic_predicate:5">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <msup>
      <mi>a</mi>
      <mi>n</mi>
     </msup>
     <msup>
      <mi>b</mi>
      <mi>n</mi>
     </msup>
     <msup>
      <mi>c</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>n</mi>
     <mo>≥</mo>
     <mn>0</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>c</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <geq></geq>
      <ci>n</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=\{a^{n}b^{n}c^{n}|n\geq 0\}
  </annotation>
 </semantics>
</math>

, but is included here because it is the example given by the inventor of conjunctive grammars.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a>):</p>

<p><code>S → AB&amp;DC;</code><br/>
<code>A → aA | ε</code><br/>
<code>B → bBc | ε</code><br/>
<code>C → cC | ε</code><br/>
<code>D → aDb | ε</code></p>
<dl>
<dt>Perl 6 rules</dt>
</dl>

<p><code>rule S { <before < code=""><a><code> &gt; a+ </code><b><code>  }</code><br/>
<code>rule A { a </code><a><code>? b }</code><br/>
<code>rule B { b </code><b><code>? c }</code></b></a></b></a></before <></code></p>
<h2 id="parsersformalisms-using-some-form-of-syntactic-predicate">Parsers/formalisms using some form of syntactic predicate</h2>

<p>Although by no means an exhaustive list, the following <a href="parsing" title="wikilink">parsers</a> and <a href="formal_grammar" title="wikilink">grammar</a> <a href="Formal_system" title="wikilink">formalisms</a> employ syntactic predicates:</p>
<dl>
<dt><a class="uri" href="ANTLR" title="wikilink">ANTLR</a> (Parr &amp; Quong)</dt>
<dd>As originally implemented,<ref name="Parr&amp;Quong1993"> syntactic predicates sit on the leftmost edge of a production such that the <a href="Formal_grammar" title="wikilink">production</a> to the right of the predicate is attempted if and only if the syntactic predicate first accepts the next portion of the input stream. Although ordered, the predicates are checked first, with parsing of a clause continuing if and only if the predicate is satisfied, and semantic actions only occurring in non-predicates.<ref name="Parr&amp;Quong1995">
</ref></ref></dd>
<dt>Augmented Pattern Matcher (Balmas)</dt>
<dd>Balmas refers to syntactic predicates as "multi-step matching" in her paper on APM.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> As an APM parser parses, it can bind substrings to a variable, and later check this variable against other rules, continuing to parse if and only if that substring is acceptable to further rules.
</dd>
<dt><a href="Parsing_expression_grammar" title="wikilink">Parsing expression grammars</a> (Ford)</dt>
<dd>Ford's PEGs have syntactic predicates expressed as the <em>and-predicate</em> and the <em>not-predicate</em>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a>
</dd>
<dt>§-Calculus (Jackson)</dt>
<dd>In the §-Calculus, syntactic predicates are originally called simply <em>predicates</em>, but are later divided into <em>bound</em> and <em>free</em> forms, each with different input properties.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a>
</dd>
<dt><a href="Perl_6_rules" title="wikilink">Perl 6 rules</a></dt>
<dd><a href="Perl_6" title="wikilink">Perl 6</a> introduces a generalized tool for describing a grammar called <em>rules</em>, which are an extension of <a class="uri" href="Perl" title="wikilink">Perl</a> 5's regular expression syntax.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Predicates are introduced via a lookahead mechanism called <em>before</em>, either with "<code><nowiki><before ...=""></before></nowiki></code>" or "<code><nowiki></nowiki></code>" (that is: "<em>not</em> before"). Perl 5 also has such lookahead, but it can only encapsulate Perl 5's more limited regexp features.
</dd>
<dt>ProGrammar (NorKen Technologies)</dt>
<dd>ProGrammar's GDL (Grammar Definition Language) makes use of syntactic predicates in a form called <em>parse constraints</em>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a>
</dd>
<dt><a href="Conjunctive_grammars" title="wikilink">Conjunctive</a> and <a href="Boolean_grammar" title="wikilink">Boolean</a> Grammars (Okhotin)</dt>
<dd>Conjunctive grammars, first introduced by Okhotin,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> introduce the explicit notion of <a href="logical_conjunction" title="wikilink">conjunction</a>-as-predication. Later treatment of conjunctive and boolean grammars<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> is the most thorough treatment of this formalism to date.
</dd>
</dl>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://users.utu.fi/aleokh/conjunctive/">Alexander Okhotin's Conjunctive Grammars Page</a></li>
<li><a href="http://users.utu.fi/aleokh/boolean/">Alexander Okhotin's Boolean Grammars Page</a></li>
<li><a href="http://pdos.csail.mit.edu/~baford/packrat/">The Packrat Parsing and Parsing Expression Grammars Page</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Parsing" title="wikilink">Category:Parsing</a> <a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
</ol>
</section>
</body>
</html>
