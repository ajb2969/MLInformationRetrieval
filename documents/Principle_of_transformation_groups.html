<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="807">Principle of transformation groups</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Principle of transformation groups</h1>
<hr/>

<p>The <strong>principle of transformation groups</strong> is a rule for assigning <em>epistemic</em> probabilities in a statistical inference problem. It was first suggested by Edwin T Jaynes <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and can be seen as a generalisation of the <a href="principle_of_indifference" title="wikilink">principle of indifference</a>.</p>

<p>This can be seen as a method to create <em>objective ignorance probabilities</em> in the sense that two people who apply the principle and are confronted with the same information will assign the same probabilities.</p>
<h2 id="motivation-and-description-of-the-method">Motivation and description of the method</h2>

<p>The method is motivated by the following normative principle, or desideratum:</p>

<p><em>In two problems where we have the same prior information we should assign the same prior probabilities</em></p>

<p>The method then comes about from "transforming" a given problem into an equivalent one. This method has close connections with <a href="group_theory" title="wikilink">group theory</a>, and to a large extent is about finding symmetry in a given problem, and then exploiting this symmetry to assign prior probabilities.</p>

<p>In problems with discrete variables (e.g. dice, cards, categorical data) the principle reduces to the <a href="principle_of_indifference" title="wikilink">principle of indifference</a>, as the "symmetry" in the discrete case is a permutation of the labels, that is the <a href="permutation_group" title="wikilink">permutation group</a> is the relevant transformation group for this problem.</p>

<p>In problems with continuous variables, this method generally reduces to solving a <a href="differential_equation" title="wikilink">differential equation</a>. Given that differential equations do not always lead to unique solutions, this method cannot be guaranteed to produce a unique solution. However, in a large class of the most common types of parameters it does lead to unique solutions (see the examples below)</p>
<h2 id="examples">Examples</h2>
<h3 id="discrete-case---coin-flipping">Discrete Case - coin flipping</h3>

<p>Consider a problem where all you are told is that there is a coin, and it has a head (H) and a tail (T). Denote this information by <em>I</em>. You are then asked "what is the probability of Heads?". Call this <em>problem 1</em> and denote the probability <em>P(H|I)</em>. Consider another question "what is the probability of Tails?". Call this <em>problem 2</em> and denote this probability by <em>P(T|I)</em>.</p>

<p>Now from the information which was actually in the question, there is no distinction between heads and tails. The whole paragraph above could be re-written with "Heads" and "Tails" interchanged, and "H" and "T" interchanged, and the problem statement would not be any different. Using the desideratum then demands that</p>

<p>

<math display="inline" id="Principle_of_transformation_groups:0">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo stretchy="false">|</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo stretchy="false">|</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">H</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(H|I)=P(T|I)
  </annotation>
 </semantics>
</math>

</p>

<p>The probabilities must add to 1, this means that</p>

<p>

<math display="inline" id="Principle_of_transformation_groups:1">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo stretchy="false">|</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo stretchy="false">|</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
   <mo>→</mo>
   <mn>2</mn>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo stretchy="false">|</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
   <mo>→</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo stretchy="false">|</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>0.5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">H</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">1</cn>
    <ci>normal-→</ci>
    <cn type="integer">2</cn>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">H</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">1</cn>
    <ci>normal-→</ci>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">H</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="float">0.5</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(H|I)+P(T|I)=1\rightarrow 2P(H|I)=1\rightarrow P(H|I)=0.5
  </annotation>
 </semantics>
</math>

.</p>

<p>Thus we have a unique solution. This argument easily extents to <em>N</em> categories, to give the "flat" prior probability <em>1/N</em>. This provides a <em>consistency</em> based argument to the principle of indifference which goes as follows: <em>if someone is truly ignorant about a discrete/countable set of outcomes apart from their potential existence, but does not assign them equal prior probabilities, then they are assigning different probabilities when given the same information</em>.</p>

<p>This can be alternatively phrased as: <em>a person who does not use the principle of indifference to assign prior probabilities to discrete variables, is either not ignorant about them, or reasoning inconsistently</em>.</p>
<h3 id="continuous-case---location-parameter">Continuous Case - location parameter</h3>

<p>This is the easiest example for continuous variables. It is given by stating one is "ignorant" of the location parameter in a given problem. The statement that a parameter is a "location parameter" is that the sampling distribution, or likelihood of an observation <em>X</em> depends on a parameter 

<math display="inline" id="Principle_of_transformation_groups:2">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 only through the difference</p>

<p>

<math display="inline" id="Principle_of_transformation_groups:3">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">|</mo>
    <mi>μ</mi>
    <mo>,</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>-</mo>
    <mi>μ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">μ</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <minus></minus>
     <csymbol cd="unknown">μ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(X|\mu,I)=f(X-\mu)
  </annotation>
 </semantics>
</math>

</p>

<p>for some normalised, but otherwise arbitrary distribution <em>f(.)</em>. Examples of location parameters include mean parameter of <a href="normal_distribution" title="wikilink">normal distribution</a> with known variance and median parameter of <a href="Cauchy_distribution" title="wikilink">Cauchy distribution</a> with known inter-quartile range. The two "equivalent problems" in this case, given ones knowledge of the sampling distribution 

<math display="inline" id="Principle_of_transformation_groups:4">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">|</mo>
    <mi>μ</mi>
    <mo>,</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>-</mo>
    <mi>μ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">μ</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <minus></minus>
     <csymbol cd="unknown">μ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(X|\mu,I)=f(X-\mu)
  </annotation>
 </semantics>
</math>

, but no other knowledge about 

<math display="inline" id="Principle_of_transformation_groups:5">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

, is simply given by a "shift" of equal magnitude in <em>X</em> and 

<math display="inline" id="Principle_of_transformation_groups:6">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

. This is because of the relation:</p>

<p>

<math display="inline" id="Principle_of_transformation_groups:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>X</mi>
      <mo>-</mo>
      <mi>μ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>X</mi>
        <mo>+</mo>
        <mi>b</mi>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>μ</mi>
        <mo>+</mo>
        <mi>b</mi>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>X</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
      <mo>-</mo>
      <msup>
       <mi>μ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <ci>X</ci>
       <ci>μ</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <plus></plus>
         <ci>X</ci>
         <ci>b</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <plus></plus>
         <ci>μ</ci>
         <ci>b</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>X</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>μ</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(X-\mu)=f([X+b]-[\mu+b])=f(X^{(1)}-\mu^{(1)})
  </annotation>
 </semantics>
</math>

</p>

<p>So simply "shifting" all quantities up by some number <em>b</em> and solving in the "shifted space" and then "shifting" back to the original one should give exactly the same answer as if we just worked on the original space. Making the transformation from 

<math display="inline" id="Principle_of_transformation_groups:8">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Principle_of_transformation_groups:9">
 <semantics>
  <msup>
   <mi>μ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>μ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu^{(1)}
  </annotation>
 </semantics>
</math>

 has a <a href="Jacobian_matrix_and_determinant" title="wikilink">jacobian</a> of simply 1, and so the prior probability must satisfy the functional equation:</p>

<p>

<math display="inline" id="Principle_of_transformation_groups:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>μ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <msup>
        <mi>μ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msup>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <mi>μ</mi>
      </mrow>
     </mfrac>
     <mo stretchy="false">|</mo>
    </mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>μ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>μ</mi>
      <mo>+</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>μ</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <abs></abs>
       <apply>
        <divide></divide>
        <apply>
         <partialdiff></partialdiff>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>μ</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <partialdiff></partialdiff>
         <ci>μ</ci>
        </apply>
       </apply>
      </apply>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>μ</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <plus></plus>
       <ci>μ</ci>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\mu)=|{\partial\mu^{(1)}\over\partial\mu}|f(\mu^{(1)})=f(\mu+b)
  </annotation>
 </semantics>
</math>

</p>

<p>And the only function which satisfies this equation is the "constant prior":</p>

<p>

<math display="inline" id="Principle_of_transformation_groups:11">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>μ</mi>
    <mo stretchy="false">|</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∝</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">μ</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proportional-to</csymbol>
    <cn type="integer">1</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\mu|I)\propto 1
  </annotation>
 </semantics>
</math>

</p>

<p>Thus the uniform prior is justified for expressing complete ignorance of a location parameter.</p>
<h3 id="continuous-case---scale-parameter">Continuous case - scale parameter</h3>

<p>As in the above argument, a statement that 

<math display="inline" id="Principle_of_transformation_groups:12">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 is a scale parameter means that the sampling distribution has the functional form:</p>

<p>

<math display="inline" id="Principle_of_transformation_groups:13">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">|</mo>
    <mi>σ</mi>
    <mo>,</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mi>σ</mi>
   </mfrac>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mfrac>
     <mi>X</mi>
     <mi>σ</mi>
    </mfrac>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">σ</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>σ</ci>
    </apply>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <divide></divide>
      <ci>X</ci>
      <ci>σ</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(X|\sigma,I)={1\over\sigma}f({X\over\sigma})
  </annotation>
 </semantics>
</math>

</p>

<p>Where, as before <em>f(.)</em> is a normalised probability density function. the requirement that probabilities be finite and positive forces the condition 

<math display="inline" id="Principle_of_transformation_groups:14">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>σ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma>0
  </annotation>
 </semantics>
</math>

. Examples include the standard deviation of a normal distribution with known mean, the <a href="gamma_distribution" title="wikilink">gamma distribution</a>. The "symmetry" in this problem is found by noting that</p>

<p>

<math display="inline" id="Principle_of_transformation_groups:15">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mi>X</mi>
     <mi>σ</mi>
    </mfrac>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mi>X</mi>
      <mi>a</mi>
     </mrow>
     <mrow>
      <mi>σ</mi>
      <mi>a</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>;</mo>
   <mrow>
    <mi>a</mi>
    <mo>></mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <ci>X</ci>
      <ci>σ</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <ci>σ</ci>
       <ci>a</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <ci>a</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {X\over\sigma}={Xa\over\sigma a};a>0
  </annotation>
 </semantics>
</math>

</p>

<p>But, unlike in the location parameter case, the jacobian of this transformation in the sample space and the parameter space is <em>a</em>, not 1. so the sampling probability changes to:</p>

<p>

<math display="inline" id="Principle_of_transformation_groups:16">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>X</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo stretchy="false">|</mo>
    <mi>σ</mi>
    <mo>,</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mi>a</mi>
   </mfrac>
   <mfrac>
    <mn>1</mn>
    <mi>σ</mi>
   </mfrac>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mfrac>
     <mrow>
      <mi>X</mi>
      <mi>a</mi>
     </mrow>
     <mrow>
      <mi>σ</mi>
      <mi>a</mi>
     </mrow>
    </mfrac>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <msup>
     <mi>σ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
   </mfrac>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mfrac>
     <msup>
      <mi>X</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <msup>
      <mi>σ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
    </mfrac>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">σ</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>a</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>σ</ci>
    </apply>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <ci>σ</ci>
       <ci>a</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>σ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>X</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>σ</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(X^{(1)}|\sigma,I)={1\over a}{1\over\sigma}f({Xa\over\sigma a})={1\over\sigma%
^{(1)}}f({X^{(1)}\over\sigma^{(1)}})
  </annotation>
 </semantics>
</math>

</p>

<p>Which is invariant (i.e. has the same form before and after the transformation), and the prior probability changes to:</p>

<p>

<math display="inline" id="Principle_of_transformation_groups:17">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>σ</mi>
    <mo stretchy="false">|</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mi>a</mi>
   </mfrac>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>σ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mi>a</mi>
   </mfrac>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mfrac>
     <mi>σ</mi>
     <mi>a</mi>
    </mfrac>
    <mo stretchy="false">|</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">σ</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>a</ci>
    </apply>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>σ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>a</ci>
    </apply>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <divide></divide>
      <ci>σ</ci>
      <ci>a</ci>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\sigma|I)={1\over a}p(\sigma^{(1)})={1\over a}p({\sigma\over a}|I)
  </annotation>
 </semantics>
</math>

</p>

<p>Which has the unique solution (up to a proportionality constant):</p>

<p>

<math display="inline" id="Principle_of_transformation_groups:18">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>σ</mi>
    <mo stretchy="false">|</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∝</mo>
   <mfrac>
    <mn>1</mn>
    <mi>σ</mi>
   </mfrac>
   <mo>→</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>l</mi>
    <mi>o</mi>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>σ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∝</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">σ</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proportional-to</csymbol>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>σ</ci>
    </apply>
    <ci>normal-→</ci>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">l</csymbol>
     <csymbol cd="unknown">o</csymbol>
     <csymbol cd="unknown">g</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">σ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-|</ci>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proportional-to</csymbol>
    <cn type="integer">1</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\sigma|I)\propto{1\over\sigma}\rightarrow p(log(\sigma)|I)\propto 1
  </annotation>
 </semantics>
</math>

</p>

<p>Which is the well-known <a href="Jeffreys_prior" title="wikilink">Jeffreys prior</a> for scale parameters, which is "flat" on the log scale, although it should be noted that it is derived using a different argument to that here, based on the <a href="Fisher_information" title="wikilink">Fisher information</a> function. The fact that these two methods give the same results in this case does not imply it in general.</p>
<h3 id="continuous-case---bertrands-paradox">Continuous case - Bertrand's paradox</h3>

<p>Edwin Jaynes used this principle to provide a resolution to <a href="Bertrand_paradox_(probability)" title="wikilink">Bertrand's Paradox</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> by stating his ignorance about the exact position of the circle. The details are available in the reference or in the link.</p>
<h2 id="discussion">Discussion</h2>

<p>This argument depends crucially on <em>I</em>; changing the information may result in a different probability assignment. It is just as crucial as changing <a class="uri" href="axioms" title="wikilink">axioms</a> in <a href="deductive_logic" title="wikilink">deductive logic</a> - small changes in the information can lead to large changes in the probability assignments allowed by "consistent reasoning".</p>

<p>To illustrate suppose that the coin flipping example also states as part of the information that the coin has a side (S) (i.e. it is a <em>real coin</em>). Denote this new information by <em>N</em>. The same argument using "complete ignorance", or more precisely, the information actually described, gives:</p>

<p>

<math display="inline" id="Principle_of_transformation_groups:19">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo stretchy="false">|</mo>
    <mi>I</mi>
    <mo>,</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo stretchy="false">|</mo>
    <mi>I</mi>
    <mo>,</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">|</mo>
    <mi>I</mi>
    <mo>,</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
   <mo>/</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">H</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">1</cn>
    <divide></divide>
    <cn type="integer">3</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(H|I,N)=P(T|I,N)=P(S|I,N)=1/3
  </annotation>
 </semantics>
</math>

</p>

<p>But this seems absurd to most people - intuition tells us that we should have P(S) very close to zero. This is because most people's intuition do not see "symmetry" between a coin landing on its side compared to landing on heads. Our intuition says that the particular "labels" actually carry some information about the problem. A simple argument could be used to make this more formal mathematically (e.g. the physics of the problem make it difficult for a flipped coin to land on its side) - perhaps the symmetry would then lie in comparing a "big" coin with a "small" coin. It could reasonably be assumed that:</p>

<p>

<math display="inline" id="Principle_of_transformation_groups:20">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">|</mo>
    <mtext>smaller coin</mtext>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">|</mo>
    <mtext>slightly bigger coin</mtext>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-|</ci>
     <mtext>smaller coin</mtext>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-|</ci>
     <mtext>slightly bigger coin</mtext>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(S|\text{smaller coin})=P(S|\text{slightly bigger coin})
  </annotation>
 </semantics>
</math>

</p>

<p>Note that this new information probably wouldn't break the symmetry between "heads" and "tails", so <em>that</em> permutation would still apply in describing "equivalent problems", and we would require:</p>

<p>

<math display="inline" id="Principle_of_transformation_groups:21">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo stretchy="false">|</mo>
    <mtext>smaller coin</mtext>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo stretchy="false">|</mo>
    <mtext>slightly bigger coin</mtext>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo stretchy="false">|</mo>
    <mtext>smaller coin</mtext>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo stretchy="false">|</mo>
    <mtext>slightly bigger coin</mtext>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">H</csymbol>
     <ci>normal-|</ci>
     <mtext>smaller coin</mtext>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">H</csymbol>
     <ci>normal-|</ci>
     <mtext>slightly bigger coin</mtext>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-|</ci>
     <mtext>smaller coin</mtext>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-|</ci>
     <mtext>slightly bigger coin</mtext>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(H|\text{smaller coin})=P(H|\text{slightly bigger coin})=P(T|\text{smaller %
coin})=P(T|\text{slightly bigger coin})
  </annotation>
 </semantics>
</math>

</p>

<p>This is a good example of how the principle of transformation groups can be used to "flesh out" personal opinions. All of the information used in the derivation is explicitly stated. If a prior probability assignment doesn't "seem right" according to what your intuition tells you, then there must be some "background information" which has not be put into the problem.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> It is then the task to try and work out what that information is. In some sense, by combining the method of transformation groups with one's intuition can be used to "weed out" the actual assumptions one has. This makes it a very powerful tool for prior elicitation.</p>

<p>Introducing the size of the coin is permissible because the it was not specified in the problem, so this is still only using information in the question. Introducing a "nuisance parameter" and then making the answer invariant to this parameter is a very useful technique for solving supposedly "ill-posed" problems like Bertrand's Paradox. This has been called "the well-posing strategy" by some.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>The real power of this principle lies in its application to continuous parameters, where the notion of "complete ignorance" is not so well defined as in the discrete case. However, if applied with infinite limits, it often gives <a href="improper_prior" title="wikilink">improper prior</a> distributions. Note that the discrete case for a countably infinite set, such as (0,1,2,...) also produces an improper discrete prior. For most cases where the likelihood is sufficiently "steep" this does not present a problem. However, in order to be absolutely sure to avoid incoherent results and paradoxes, the prior distribution should be approached via a well defined and well behaved limiting process. One such process is the use of a sequence of priors with increasing range, such as 

<math display="inline" id="Principle_of_transformation_groups:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>I</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo>∈</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mo>-</mo>
       <mi>b</mi>
       <mo>,</mo>
       <mi>b</mi>
       <mo stretchy="false">]</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mn>2</mn>
     <mi>b</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">I</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">M</csymbol>
       <in></in>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-[</ci>
        <minus></minus>
        <csymbol cd="unknown">b</csymbol>
        <ci>normal-,</ci>
        <csymbol cd="unknown">b</csymbol>
        <ci>normal-]</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(M)={I(M\in[-b,b])\over 2b}
  </annotation>
 </semantics>
</math>

 where the limit 

<math display="inline" id="Principle_of_transformation_groups:23">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>b</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\rightarrow\infty
  </annotation>
 </semantics>
</math>

 is to be taken <em>at the end of the calculation</em> i.e. after the normalisation of the posterior distribution. What this effectively is doing, is ensuring that one is taking the limit of the ratio, and not the ratio of two limits. See <a href="Limit_of_a_function#Properties" title="wikilink">Limit of a function#Properties</a> for details on limits and why this order of operations is important.</p>

<p>If the limit of the ratio does not exist or diverges, then this gives an improper posterior (i.e. a posterior which does not integrate to one). This indicates that the data are so uninformative about the parameters that the prior probability of arbitrarily large values still matters in the final answer. In some sense, an improper posterior means that the information contained in the data has not "ruled out" arbitrarily large values. Looking at the improper priors this way, it seems to make some sense that "complete ignorance" priors should be improper, because the information used to derive them is so meager that it cannot rule out absurd values on its own. From a state of complete ignorance, only the data or some other form of additional information can rule out such absurdities.</p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>Edwin Thompson Jaynes. <em>Probability Theory: The Logic of Science</em>. Cambridge University Press, 2003. ISBN 0-521-59271-2.</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Principles" title="wikilink">Category:Principles</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a class="uri" href="http://bayes.wustl.edu/etj/articles/prior.pdf">http://bayes.wustl.edu/etj/articles/prior.pdf</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a class="uri" href="http://bayes.wustl.edu/etj/articles/well.pdf">http://bayes.wustl.edu/etj/articles/well.pdf</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a class="uri" href="http://bayes.wustl.edu/etj/articles/cmonkeys.pdf">http://bayes.wustl.edu/etj/articles/cmonkeys.pdf</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
