<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1367">Delta-sigma modulation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Delta-sigma modulation</h1>
<hr/>

<p><strong>Delta-sigma</strong> (<strong>ΔΣ</strong>; or <strong>sigma-delta</strong>, <strong>ΣΔ</strong>) modulation is a <a href="digital_signal_processing" title="wikilink">digital signal processing</a>, or DSP method for encoding <a href="analog_signal" title="wikilink">analog signals</a> into <a href="digital_signal" title="wikilink">digital signals</a> as found in an <a href="analog_to_digital_converter" title="wikilink">ADC</a>. It is also used to transfer higher-resolution digital signals into lower-resolution digital signals as part of the process to convert digital signals into analog.</p>

<p>In a conventional ADC, an analog signal is integrated, or sampled, with a sampling frequency and subsequently quantized in a multi-level quantizer into a digital signal. This process introduces quantization error noise. The first step in a delta-sigma modulation is delta modulation. In <a href="delta_modulation" title="wikilink">delta modulation</a> the change in the signal (its delta) is encoded, rather than the absolute value. The result is a stream of pulses, as opposed to a stream of numbers as is the case with <a href="pulse_code_modulation" title="wikilink">PCM</a>. In delta-sigma modulation, the accuracy of the modulation is improved by passing the digital output through a 1-bit <a href="digital_to_analog_converter" title="wikilink">DAC</a> and adding (sigma) the resulting analog signal to the input signal, thereby reducing the error introduced by the delta-modulation.</p>

<p>This technique has found increasing use in modern electronic components such as <a href="Analog-to-digital_converter" title="wikilink">converters</a>, <a href="frequency_synthesizer" title="wikilink">frequency synthesizers</a>, <a href="Switched-mode_power_supply" title="wikilink">switched-mode power supplies</a> and <a href="motor_controller" title="wikilink">motor controllers</a>, primarily because of its cost efficiency and reduced circuit complexity.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Both <a href="analog-to-digital_converter" title="wikilink">analog-to-digital converters</a> (ADCs) and <a href="digital-to-analog_converter" title="wikilink">digital-to-analog converters</a> (DACs) can employ delta-sigma modulation. A delta-sigma ADC first encodes an analog signal using high-frequency delta-sigma modulation, and then applies a digital filter to form a higher-resolution but lower sample-frequency digital output. On the other hand, a delta-sigma DAC encodes a high-resolution digital input signal into a lower-resolution but higher sample-frequency signal that is mapped to <a href="voltage" title="wikilink">voltages</a>, and then smoothed with an analog filter. In both cases, the temporary use of a lower-resolution signal simplifies circuit design and improves efficiency.</p>

<p>The coarsely-quantized output of a delta-sigma modulator is occasionally used directly in signal processing or as a representation for signal storage. For example, the <a href="Super_Audio_CD" title="wikilink">Super Audio CD</a> (SACD) stores the output of a delta-sigma modulator directly on a disk.</p>
<h2 id="motivation">Motivation</h2>
<h3 id="why-convert-an-analog-signal-into-a-stream-of-pulses">Why convert an analog signal into a stream of pulses?</h3>

<p>In brief, because it is very easy to regenerate pulses at the receiver into the ideal form transmitted. The only part of the transmitted waveform required at the receiver is the time at which the pulse occurred. Given the timing information the transmitted waveform can be reconstructed electronically with great precision. In contrast, without conversion to a pulse stream but simply transmitting the analog signal directly, all <a href="Noise_(electronics)" title="wikilink">noise</a> in the system is added to the analog signal, reducing its quality.</p>

<p>Each pulse is made up of a step up followed after a short interval by a step down. It is possible, even in the presence of electronic noise, to recover the timing of these steps and from that regenerate the transmitted pulse stream almost noiselessly. Then the accuracy of the transmission process reduces to the accuracy with which the transmitted pulse stream represents the input waveform.</p>
<h3 id="why-delta-sigma-modulation">Why delta-sigma modulation?</h3>

<p>Delta-sigma modulation converts the analog voltage into a pulse frequency and is alternatively known as <a href="Pulse-density_modulation" title="wikilink">Pulse Density modulation</a> or <a href="Pulse-frequency_modulation" title="wikilink">Pulse Frequency modulation</a>. In general, frequency may vary smoothly in infinitesimal steps, as may voltage, and both may serve as an analog of an infinitesimally varying physical variable such as acoustic pressure, light intensity, etc. The substitution of frequency for voltage is thus entirely natural and carries in its train the transmission advantages of a pulse stream. The different names for the modulation method are the result of pulse frequency modulation by different electronic implementations, which all produce similar transmitted waveforms.</p>
<h3 id="why-the-delta-sigma-analog-to-digital-conversion">Why the delta-sigma analog to digital conversion?</h3>

<p>The ADC converts the mean of an analog voltage into the mean of an analog pulse frequency and counts the pulses in a known interval so that the pulse count divided by the interval gives an accurate digital representation of the mean analog voltage during the interval. This interval can be chosen to give any desired resolution or accuracy. The method is cheaply produced by modern methods; and it is widely used.</p>
<h2 id="analog-to-digital-conversion">Analog to digital conversion</h2>
<h3 id="description">Description</h3>

<p>The ADC generates a pulse stream in which the frequency, 

<math display="inline" id="Delta-sigma_modulation:0">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

, of pulses in the stream is proportional to the analog voltage input, 

<math display="inline" id="Delta-sigma_modulation:1">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

, so that 

<math display="inline" id="Delta-sigma_modulation:2">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mo>⋅</mo>
    <mi>v</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>f</ci>
    <apply>
     <ci>normal-⋅</ci>
     <ci>k</ci>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=k\cdot v
  </annotation>
 </semantics>
</math>

, where k is a constant for the particular implementation.</p>

<p>A counter sums the number of pulses that occur in a predetermined period, 

<math display="inline" id="Delta-sigma_modulation:3">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 so that the sum, 

<math display="inline" id="Delta-sigma_modulation:4">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

, is 

<math display="inline" id="Delta-sigma_modulation:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mo>⋅</mo>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mo>⋅</mo>
    <mi>P</mi>
    <mo>⋅</mo>
    <mi>v</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <ci>P</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>k</ci>
     <ci>P</ci>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\cdot f=k\cdot P\cdot v
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="inline" id="Delta-sigma_modulation:6">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>⋅</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>k</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\cdot P
  </annotation>
 </semantics>
</math>

 is chosen so that a digital display of the count, 

<math display="inline" id="Delta-sigma_modulation:7">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

, is a display of 

<math display="inline" id="Delta-sigma_modulation:8">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 with a predetermined scaling factor. Because 

<math display="inline" id="Delta-sigma_modulation:9">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 may take any designed value it may be made large enough to give any desired resolution or accuracy.</p>

<p>Each pulse of the pulse stream has a known, constant <a class="uri" href="amplitude" title="wikilink">amplitude</a> 

<math display="inline" id="Delta-sigma_modulation:10">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 and duration 

<math display="inline" id="Delta-sigma_modulation:11">
 <semantics>
  <mrow>
   <mo>d</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-d</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{d}t
  </annotation>
 </semantics>
</math>

, and thus has a known <a class="uri" href="integral" title="wikilink">integral</a> 

<math display="inline" id="Delta-sigma_modulation:12">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo>d</mo>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <apply>
     <ci>normal-d</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\operatorname{d}t
  </annotation>
 </semantics>
</math>

 but variable separating interval.</p>

<p>In a formal analysis an impulse such as integral 

<math display="inline" id="Delta-sigma_modulation:13">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo>d</mo>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <apply>
     <ci>normal-d</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\operatorname{d}t
  </annotation>
 </semantics>
</math>

 is treated as the <a href="Dirac_delta_function" title="wikilink">Dirac δ (delta) function</a> and is specified by the step produced on integration. Here we indicate that step as 

<math display="inline" id="Delta-sigma_modulation:14">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo>d</mo>
      <mi>t</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Δ</ci>
    <apply>
     <int></int>
     <apply>
      <times></times>
      <ci>V</ci>
      <apply>
       <ci>normal-d</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta=\int V\operatorname{d}t
  </annotation>
 </semantics>
</math>

.</p>

<p>The interval between pulses, <em>p</em>, is determined by a feedback loop arranged so that 

<math display="inline" id="Delta-sigma_modulation:15">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mi>f</mi>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>k</mi>
     <mo>⋅</mo>
     <mi>v</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>p</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <ci>normal-⋅</ci>
       <ci>k</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p=\frac{1}{f}=\frac{1}{k\cdot v}
  </annotation>
 </semantics>
</math>

.</p>

<p>The action of the feedback loop is to monitor the integral of v and when that integral has incremented by 

<math display="inline" id="Delta-sigma_modulation:16">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

, which is indicated by the integral waveform crossing a threshold, then subtracting 

<math display="inline" id="Delta-sigma_modulation:17">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

 from the integral of v so that the combined waveform sawtooths between the threshold and ( threshold - 

<math display="inline" id="Delta-sigma_modulation:18">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

 ). At each step a pulse is added to the pulse stream.</p>

<p>Between impulses, the slope of the integral is proportional to 

<math display="inline" id="Delta-sigma_modulation:19">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

, that is, for some 

<math display="inline" id="Delta-sigma_modulation:20">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 it equals 

<math display="inline" id="Delta-sigma_modulation:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>⋅</mo>
    <mi>v</mi>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mi mathvariant="normal">Δ</mi>
    <mi>p</mi>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mo>⋅</mo>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mo>⋅</mo>
    <mi>k</mi>
    <mo>⋅</mo>
    <mi>v</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-⋅</ci>
      <ci>A</ci>
      <ci>v</ci>
     </apply>
     <apply>
      <divide></divide>
      <ci>normal-Δ</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-⋅</ci>
      <ci>normal-Δ</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-⋅</ci>
      <ci>normal-Δ</ci>
      <ci>k</ci>
      <ci>v</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\cdot v=\frac{\Delta}{p}=\Delta\cdot f=\Delta\cdot k\cdot v
  </annotation>
 </semantics>
</math>

. Whence 

<math display="inline" id="Delta-sigma_modulation:22">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mo>⋅</mo>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <ci>normal-⋅</ci>
     <ci>normal-Δ</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\Delta\cdot k
  </annotation>
 </semantics>
</math>

.</p>

<p>It is the pulse stream which is transmitted for delta-sigma modulation but the pulses are counted to form sigma in the case of analogue to digital conversion.</p>
<h3 id="analysis">Analysis</h3>

<p>  Shown below the block diagram illustrated in Fig. 1 are waveforms at points designated by numbers 1 to 5 for an input of 0.2 volts on the left and 0.4 volts on the right.</p>

<p>In most practical applications the summing interval is large compared with the impulse duration and for signals which are a significant fraction of full scale the variable separating interval is also small compared with the summing interval. The <a href="Nyquist–Shannon_sampling_theorem" title="wikilink">Nyquist–Shannon sampling theorem</a> requires two samples to render a varying input signal. The samples appropriate to this criterion are two successive Σ counts taken in two successive summing intervals. The summing interval, which must accommodate a large count in order to achieve adequate precision, is inevitably long so that the converter can only render relatively low frequencies. Hence it is convenient and fair to represent the input voltage (1) as constant over a few impulses.</p>

<p>Consider first the waveforms on the left.</p>

<p>1 is the input and for this short interval is constant at 0.2 V. The stream of delta impulses is shown at 2 and the difference between 1 and 2 is shown at 3. This difference is integrated to produce the waveform 4. The threshold detector generates a pulse 5 which starts as the waveform 4 crosses the threshold and is sustained until the waveform 4 falls below the threshold. Within the loop 5 triggers the impulse generator and external to the loop increments the counter. The summing interval is a prefixed time and at its expiry the count is strobed into the buffer and the counter reset.</p>

<p>It is necessary that the ratio between the impulse interval and the summing interval is equal to the maximum (full scale) count. It is then possible for the impulse duration and the summing interval to be defined by the same clock with a suitable arrangement of logic and counters. This has the advantage that neither interval has to be defined with absolute precision as only the ratio is important. Then to achieve overall accuracy it is only necessary that the amplitude of the impulse be accurately defined.</p>

<p>On the right the input is now 0.4 V and the sum during the impulse is −0.6 V as opposed to −0.8 V on the left. Thus the negative slope during the impulse is lower on the right than on the left.</p>

<p>Also the sum is 0.4 V on the right during the interval as opposed to 0.2 V on the left. Thus the positive slope outside the impulse is higher on the right than on the left.</p>

<p>The resultant effect is that the integral (4) crosses the threshold more quickly on the right than on the left. A full analysis would show that in fact the interval between threshold crossings on the right is half that on the left. Thus the frequency of impulses is doubled. Hence the count increments at twice the speed on the right to that on the left which is consistent with the input voltage being doubled.</p>

<p>Construction of the waveforms illustrated at (4) is aided by concepts associated with the Dirac delta function in that all impulses of the same strength produce the same step when integrated, by definition. Then (4) is constructed using an intermediate step (6) in which each integrated impulse is represented by a step of the assigned strength which decays to zero at the rate determined by the input voltage. The effect of the finite duration of the impulse is constructed in (4) by drawing a line from the base of the impulse step at zero volts to intersect the decay line from (6) at the full duration of the impulse.</p>

<p>As stated, Fig. 1 is a simplified block diagram of the delta-sigma ADC in which the various functional elements have been separated out for individual treatment and which tries to be independent of any particular implementation. Many particular implementations seek to define the impulse duration and the summing interval from the same clock as discussed above but in such a way that the start of the impulse is delayed until the next occurrence of the appropriate clock pulse boundary. The effect of this delay is illustrated in Fig. 1a for a sequence of impulses which occur at a nominal 2.5 clock intervals, firstly for impulses generated immediately the threshold is crossed as previously discussed and secondly for impulses delayed by the clock. The effect of the delay is firstly that the ramp continues until the onset of the impulse, secondly that the impulse produces a fixed amplitude step so that the integral retains the excess it acquired during the impulse delay and so the ramp restarts from a higher point and is now on the same locus as the unclocked integral. The effect is that, for this example, the undelayed impulses will occur at clock points 0, 2.5, 5, 7.5, 10, etc. and the clocked impulses will occur at 0, 3, 5, 8, 10, etc. The maximum error that can occur due to clocking is marginally less than one count. Although the Sigma-Delta converter is generally implemented using a common clock to define the impulse duration and the summing interval it is not absolutely necessary and an implementation in which the durations are independently defined avoids one source of noise, the noise generated by waiting for the next common clock boundary. Where noise is a primary consideration that overrides the need for absolute amplitude accuracy; e.g., in bandwidth limited signal transmission, separately defined intervals may be implemented.</p>
<h3 id="practical-implementation">Practical Implementation</h3>

<p>  A circuit diagram for a practical implementation is illustrated, Fig 1b and the associated waveforms Fig. 1c. This circuit diagram is mainly for illustration purposes, details of particular manufacturers implementations will usually be available from the particular manufacturer. A scrap view of an alternative front end is shown in Fig. 1b which has the advantage that the voltage at the switch terminals are relatively constant and close to 0.0 V. Also the current generated through R by −V<sub>ref</sub> is constant at −V<sub>ref</sub>/R so that much less noise is radiated to adjacent parts of the circuit. Then this would be the preferred front end in practice but, in order to show the impulse as a voltage pulse so as to be consistent with previous discussion, the front end given here, which is an electrical equivalent, is used.</p>

<p>From the top of Fig 1c the waveforms, labelled as they are on the circuit diagram, are:-</p>

<p>The clock.</p>

<p>(a) V<sub>in</sub>. This is shown as varying from 0.4 V initially to 1.0 V and then to zero volts to show the effect on the feedback loop.</p>

<p>(b) The impulse waveform. It will be discovered how this acquires its form as we traverse the feedback loop.</p>

<p>(c) The current into the capacitor, I<sub>c</sub>, is the linear sum of the impulse voltage upon R and V<sub>in</sub> upon R. To show this sum as a voltage the product R × I<sub>c</sub> is plotted. The input impedance of the amplifier is regarded as so high that the current drawn by the input is neglected.</p>

<p>(d) The negated integral of I<sub>c</sub>. This negation is standard for the op. amp. implementation of an integrator and comes about because the current into the capacitor at the amplifier input is the current out of the capacitor at the amplifier output and the voltage is the integral of the current divided by the capacitance of C.</p>

<p>(e) The comparator output. The comparator is a very high gain amplifier with its plus input terminal connected for reference to 0.0 V. Whenever the negative input terminal is taken negative with respect the positive terminal of the amplifier the output saturates positive and conversely negative saturation for positive input. Thus the output saturates positive whenever the integral (d) goes below the 0 V reference level and remains there until (d) goes positive with respect to the reference level.</p>

<p>(f) The impulse timer is a D type positive edge triggered flip flop. Input information applied at D is transferred to Q on the occurrence of the positive edge of the clock pulse. thus when the comparator output (e) is positive Q goes positive or remains positive at the next positive clock edge. Similarly, when (e) is negative Q goes negative at the next positive clock edge. Q controls the electronic switch to generate the current impulse into the integrator. Examination of the waveform (e) during the initial period illustrated, when V<sub>in</sub> is 0.4 V, shows (e) crossing the threshold well before the trigger edge (positive edge of the clock pulse) so that there is an appreciable delay before the impulse starts. After the start of the impulse there is further delay while (e) climbs back past the threshold. During this time the comparator output remains high but goes low before the next trigger edge. At that next trigger edge the impulse timer goes low to follow the comparator. Thus the clock determines the duration of the impulse. For the next impulse the threshold is crossed immediately before the trigger edge and so the comparator is only briefly positive. V<sub>in</sub> (a) goes to full scale, +V<sub>ref</sub>, shortly before the end of the next impulse. For the remainder of that impulse the capacitor current (c) goes to zero and hence the integrator slope briefly goes to zero. Following this impulse the full scale positive current is flowing (c) and the integrator sinks at its maximum rate and so crosses the threshold well before the next trigger edge. At that edge the impulse starts and the Vin current is now matched by the reference current so that the net capacitor current (c) is zero. Then the integration now has zero slope and remains at the negative value it had at the start of the impulse. This has the effect that the impulse current remains switched on because Q is stuck positive because the comparator is stuck positive at every trigger edge. This is consistent with contiguous, butting impulses which is required at full scale input.</p>

<p>Eventually Vin (a) goes to zero which means that the current sum (c) goes fully negative and the integral ramps up. It shortly thereafter crosses the threshold and this in turn is followed by Q, thus switching the impulse current off. The capacitor current (c) is now zero and so the integral slope is zero, remaining constant at the value it had acquired at the end of the impulse.</p>

<p>(g) The countstream is generated by gating the negated clock with Q to produce this waveform. Thereafter the summing interval, sigma count and buffered count are produced using appropriate counters and registers. The V<sub>in</sub> waveform is approximated by passing the countstream (g) into a low pass filter, however it suffers from the defect discussed in the context of Fig. 1a. One possibility for reducing this error is to halve the feedback pulse length to half a clock period and double its amplitude by halving the impulse defining resistor thus producing an impulse of the same strength but one which never butts onto its adjacent impulses. Then there will be a threshold crossing for every impulse. In this arrangement a monostable flip flop triggered by the comparator at the threshold crossing will closely follow the threshold crossings and thus eliminate one source of error, both in the ADC and the sigma delta modulator.</p>
<h3 id="remarks">Remarks</h3>

<p>In this section we have mainly dealt with the analogue to digital converter as a stand alone function which achieves astonishing accuracy with what is now a very simple and cheap architecture. Initially the Delta-Sigma configuration was devised by INOSE et al. to solve problems in the accurate transmission of analog signals. In that application it was the pulse stream that was transmitted and the original analog signal recovered with a low pass filter after the received pulses had been reformed. This low pass filter performed the summation function associated with Σ. The highly mathematical treatment of transmission errors was introduced by them and is appropriate when applied to the pulse stream but these errors are lost in the accumulation process associated with Σ to be replaced with the errors associated with the mean of means when discussing the ADC. For those uncomfortable with this assertion consider this.</p>

<p>It is well known that by Fourier analysis techniques the incoming waveform can be represented over the summing interval by the sum of a constant plus a fundamental and harmonics each of which has an exact integer number of cycles over the sampling period. It is also well known that the integral of a sine wave or cosine wave over one or more full cycles is zero. Then the integral of the incoming waveform over the summing interval reduces to the integral of the constant and when that integral is divided by the summing interval it becomes the mean over that interval. The interval between pulses is proportional to the inverse of the mean of the input voltage during that interval and thus over that interval, ts, is a sample of the mean of the input voltage proportional to V/ts. Thus the average of the input voltage over the summing period is VΣ/N and is the mean of means and so subject to little variance.</p>

<p>Unfortunately the analysis for the transmitted pulse stream has, in many cases, been carried over, uncritically, to the ADC.</p>

<p>It was indicated in section 2.2 Analysis that the effect of constraining a pulse to only occur on clock boundaries is to introduce noise, that generated by waiting for the next clock boundary. This will have its most deleterious effect on the high frequency components of a complex signal. Whilst the case has been made for clocking in the ADC environment, where it removes one source of error, namely the ratio between the impulse duration and the summing interval, it is deeply unclear what useful purpose clocking serves in a single channel transmission environment since it is a source of both noise and complexity but it is conceivable that it would be useful in a TDM (<a href="time_division_multiplex" title="wikilink">time division multiplex</a>) environment.</p>

<p>A very accurate transmission system with constant sampling rate may be formed using the full arrangement shown here by transmitting the samples from the buffer protected with redundancy error correction. In this case there will be a trade off between bandwidth and N, the size of the buffer. The signal recovery system will require redundancy error checking, digital to analog conversion, and sample and hold circuitry. A possible further enhancement is to include some form of slope regeneration. This amounts to PCM (pulse code modulation) with digitization performed by a sigma-delta ADC.</p>

<p>The above description shows why the impulse is called delta. The integral of an impulse is a step. A one bit DAC may be expected to produce a step and so must be a conflation of an impulse and an integration. The analysis which treats the impulse as the output of a 1-bit DAC hides the structure behind the name (sigma delta) and cause confusion and difficulty interpreting the name as an indication of function. This analysis is very widespread but is deprecated.</p>

<p>A modern alternative method for generating voltage to frequency conversion is discussed in synchronous voltage to frequency converter (SVFC) which may be followed by a counter to produce a digital representation in a similar manner to that described above.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="digital-to-analog-conversion">Digital to analog conversion</h2>
<h3 id="discussion">Discussion</h3>

<p>Delta-sigma modulators are often used in <a href="digital_to_analog_converter" title="wikilink">digital to analog converters</a> (DACs). In general, a DAC converts a digital number representing some analog value into that analog value. For example, the analog voltage level into a speaker may be represented as a 20 bit digital number, and the DAC converts that number into the desired voltage. To actually drive a load (like a speaker) a DAC is usually connected to or integrated with an <a href="electronic_amplifier" title="wikilink">electronic amplifier</a>.</p>

<p>This can be done using a delta-sigma modulator in a <a href="Class_D_Amplifier" title="wikilink">Class D Amplifier</a>. In this case, a multi-bit digital number is input to the delta-sigma modulator, which converts it into a faster sequence of 0s and 1s. These 0s and 1s are then converted into analog voltages. The conversion, usually with MOSFET drivers, is very efficient in terms of power because the drivers are usually either fully on or fully off, and in these states have low power loss.</p>

<p>The resulting two-level signal is now like the desired signal, but with higher frequency components to change the signal so that it only has two levels. These added frequency components arise from the <a href="quantization_error" title="wikilink">quantization error</a> of the delta-sigma modulator, but can be filtered away by a simple <a href="low-pass_filter" title="wikilink">low-pass filter</a>. The result is a reproduction of the original, desired analog signal from the digital values.</p>

<p>The circuit itself is relatively inexpensive. The digital circuit is small, and the MOSFETs used for the power amplification are simple. This is in contrast to a multi-bit DAC which can have very stringent design conditions to precisely represent digital values with a large number of bits.</p>

<p>The use of a delta-sigma modulator in the digital to analog conversion has enabled a cost-effective, low power, and high performance solution.</p>
<h2 id="relationship-to-δ-modulation">Relationship to Δ-modulation</h2>

<p> ΔΣ modulation (SDM) is inspired by <a href="delta_modulation" title="wikilink">Δ modulation</a> (DM), as shown in Fig. 2. If <a href="Quantization_(signal_processing)" title="wikilink">quantization</a> were <a href="Homogeneous_function" title="wikilink">homogeneous</a> (e.g., if it were <a class="uri" href="linear" title="wikilink">linear</a>), the following would be a sufficient derivation of the equivalence of DM and SDM:</p>
<ol>
<li>Start with a block diagram of a Δ-modulator/demodulator.</li>
<li>The linearity property of integration (

<math display="inline" id="Delta-sigma_modulation:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo largeop="true" symmetric="true">∫</mo>
     <mpadded width="+1.7pt">
      <mi>a</mi>
     </mpadded>
    </mrow>
    <mo rspace="4.2pt">+</mo>
    <mrow>
     <mo largeop="true" symmetric="true">∫</mo>
     <mpadded width="+1.7pt">
      <mi>b</mi>
     </mpadded>
    </mrow>
   </mrow>
   <mo rspace="4.2pt">=</mo>
   <mrow>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>a</mi>
      </mpadded>
      <mo rspace="4.2pt">+</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <int></int>
      <ci>a</ci>
     </apply>
     <apply>
      <int></int>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <int></int>
     <apply>
      <plus></plus>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\int a\,+\,\int b\,=\,\int(a\,+\,b)
  </annotation>
 </semantics>
</math>

) makes it possible to move the integrator, which reconstructs the analog signal in the demodulator section, in front of the Δ-modulator.</li>
<li>Again, the linearity property of the integration allows the two integrators to be combined and a ΔΣ-modulator/demodulator block diagram is obtained.</li>
</ol>

<p>However, the quantizer is <strong>not</strong> homogeneous, and so this explanation is flawed. It's true that ΔΣ is <em>inspired</em> by Δ-modulation, but the two are distinct in operation. From the first block diagram in Fig. 2, the integrator in the feedback path can be removed if the feedback is taken directly from the input of the low-pass filter. Hence, for delta modulation of input signal 

<math display="inline" id="Delta-sigma_modulation:24">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle u
  </annotation>
 </semantics>
</math>

, the low-pass filter sees the signal</p>

<p>

<math display="block" id="Delta-sigma_modulation:25">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mtext>DM</mtext>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mo>Quantize</mo>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mi>u</mi>
        <mo>-</mo>
        <msub>
         <mi>y</mi>
         <mtext>DM</mtext>
        </msub>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <mtext>DM</mtext>
    </apply>
    <apply>
     <int></int>
     <apply>
      <ci>Quantize</ci>
      <apply>
       <minus></minus>
       <ci>u</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <mtext>DM</mtext>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{\text{DM}}=\int\operatorname{Quantize}\left(u-y_{\text{DM}}\right).\,
  </annotation>
 </semantics>
</math>

 However, sigma-delta modulation of the same input signal places at the low-pass filter</p>

<p>

<math display="block" id="Delta-sigma_modulation:26">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mtext>SDM</mtext>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>Quantize</mo>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mo largeop="true" symmetric="true">∫</mo>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mi>u</mi>
         <mo>-</mo>
         <msub>
          <mi>y</mi>
          <mtext>SDM</mtext>
         </msub>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <mtext>SDM</mtext>
    </apply>
    <apply>
     <ci>Quantize</ci>
     <apply>
      <int></int>
      <apply>
       <minus></minus>
       <ci>u</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <mtext>SDM</mtext>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{\text{SDM}}=\operatorname{Quantize}\left(\int\left(u-y_{\text{SDM}}\right)%
\right).\,
  </annotation>
 </semantics>
</math>

 In other words, SDM and DM swap the position of the integrator and quantizer. The net effect is a simpler implementation that has the added benefit of <a href="noise_shaping" title="wikilink">shaping</a> the quantization noise away from signals of interest (i.e., signals of interest are low-pass filtered while quantization noise is high-pass filtered). This effect becomes more dramatic with increased <a class="uri" href="oversampling" title="wikilink">oversampling</a>, which allows for quantization noise to be somewhat programmable. On the other hand, Δ-modulation shapes both noise and signal equally.</p>

<p>Additionally, the quantizer (e.g., <a class="uri" href="comparator" title="wikilink">comparator</a>) used in DM has a small output representing a small step up and down the quantized approximation of the input while the quantizer used in SDM must take values <em>outside</em> of the range of the input signal, as shown in Fig. 3. </p>

<p>In general, ΔΣ has some advantages versus Δ modulation:</p>
<ul>
<li>The whole structure is simpler:
<ul>
<li>Only one integrator is needed</li>
<li>The demodulator can be a simple linear filter (e.g., RC or LC filter) to reconstruct the signal</li>
<li>The quantizer (e.g., comparator) can have full-scale outputs</li>
</ul></li>
<li>The quantized value is the integral of the difference signal, which makes it less sensitive to the rate of change of the signal.</li>
</ul>
<h2 id="principle">Principle</h2>

<p>The principle of the ΔΣ architecture is explained at length in section 2. Initially, when a sequence starts, the circuit will have an arbitrary state which is dependent on the integral of all previous history. In mathematical terms this corresponds to the arbitrary integration constant of the indefinite integral. This follows from the fact that at the heart of the method there is an integrator which can have any arbitrary state dependent on previous input, see Fig. 1c (d). From the occurrence of the first pulse onward the frequency of the pulse stream is proportional to the input voltage to be transformed. A demonstration applet is available online to simulate the whole architecture.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="variations">Variations</h2>

<p>There are many kinds of ADC that use this delta-sigma structure. The above analysis focuses on the simplest 1st-order, 2-level, uniform-decimation sigma-delta ADC. Many ADCs use a second-order 5-level sinc3 sigma-delta structure.</p>
<h3 id="nd-order-and-higher-order-modulator">2nd order and higher order modulator</h3>

<p> The number of integrators, and consequently, the numbers of feedback loops, indicates the <em>order</em> of a ΔΣ-modulator; a 2nd order ΔΣ modulator is shown in Fig. 4. First order modulators are unconditionally stable, but stability analysis must be performed for higher order modulators.</p>
<h3 id="level-and-higher-quantizer">3-level and higher quantizer</h3>

<p>The modulator can also be classified by the number of bits it has in output, which strictly depends on the output of the quantizer. The quantizer can be realized with a <em>N-level</em> comparator, thus the modulator has <em>log<sub>2</sub>N</em>-bit output. A simple comparator has 2 levels and so is 1 bit quantizer; a 3-level quantizer is called a "1.5" bit quantizer; a 4-level quantizer is a 2 bit quantizer; a 5-level quantizer is called a "2.5 bit" quantizer.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h3 id="decimation-structures">Decimation structures</h3>

<p>The conceptually simplest decimation structure is a counter that is reset to zero at the beginning of each integration period, then read out at the end of the integration period.</p>

<p>The multi-stage noise shaping (MASH) structure has a noise shaping property, and is commonly used in digital audio and fractional-N frequency synthesizers. It comprises two or more cascaded overflowing accumulators, each of which is equivalent to a first-order sigma delta modulator. The carry outputs are combined through summations and delays to produce a binary output, the width of which depends on the number of stages (order) of the MASH. Besides its noise shaping function, it has two more attractive properties:</p>
<ul>
<li>simple to implement in hardware; only common digital blocks such as <a href="Accumulator_(computing)" title="wikilink">accumulators</a>, <a href="Adder_(electronics)" title="wikilink">adders</a>, and <a href="D_flip-flop" title="wikilink">D flip-flops</a> are required</li>
<li>unconditionally stable (there are no feedback loops outside the accumulators)</li>
</ul>

<p>A very popular decimation structure is the <em>sinc</em> filter. For 2nd order modulators, the <em>sinc3</em> filter is close to optimum.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="quantization-theory-formulas">Quantization theory formulas</h2>

<p>When a signal is quantized, the resulting signal approximately has the second-order statistics of a signal with independent additive white noise. Assuming that the signal value is in the range of one step of the quantized value with an equal distribution, the root mean square value of this quantization noise is</p>

<p>

<math display="block" id="Delta-sigma_modulation:27">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <msub>
     <mi>e</mi>
     <mi>rms</mi>
    </msub>
   </mpadded>
   <mo>=</mo>
   <msqrt>
    <mrow>
     <mpadded lspace="1.7pt" width="+1.7pt">
      <mfrac>
       <mn>1</mn>
       <mi mathvariant="normal">Δ</mi>
      </mfrac>
     </mpadded>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi mathvariant="normal">Δ</mi>
         <mo>/</mo>
         <mn>2</mn>
        </mrow>
       </mrow>
       <mrow>
        <mo>+</mo>
        <mrow>
         <mi mathvariant="normal">Δ</mi>
         <mo>/</mo>
         <mn>2</mn>
        </mrow>
       </mrow>
      </msubsup>
      <mrow>
       <mpadded width="+1.7pt">
        <msup>
         <mi>e</mi>
         <mn>2</mn>
        </msup>
       </mpadded>
       <mi>d</mi>
       <mpadded width="+1.7pt">
        <mi>e</mi>
       </mpadded>
      </mrow>
     </mrow>
    </mrow>
   </msqrt>
   <mo rspace="4.2pt">=</mo>
   <mfrac>
    <mi mathvariant="normal">Δ</mi>
    <mrow>
     <mn>2</mn>
     <msqrt>
      <mn>3</mn>
     </msqrt>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>rms</ci>
     </apply>
     <apply>
      <root></root>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>normal-Δ</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <int></int>
          <apply>
           <minus></minus>
           <apply>
            <divide></divide>
            <ci>normal-Δ</ci>
            <cn type="integer">2</cn>
           </apply>
          </apply>
         </apply>
         <apply>
          <plus></plus>
          <apply>
           <divide></divide>
           <ci>normal-Δ</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>e</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>d</ci>
         <ci>e</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <ci>normal-Δ</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <root></root>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{\mathrm{rms}}\,=\sqrt{\,\frac{1}{\Delta}\int_{-\Delta/2}^{+\Delta/2}e^{2}\,%
de\,}=\,\frac{\Delta}{2\sqrt{3}}
  </annotation>
 </semantics>
</math>

</p>

<p>In reality, the quantization noise is of course not independent of the signal; this dependence is the source of idle tones and pattern noise in Sigma-Delta converters.</p>

<p>The over-sampling ratio (OSR), where 

<math display="inline" id="Delta-sigma_modulation:28">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi mathvariant="normal">s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>normal-s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{\mathrm{s}}
  </annotation>
 </semantics>
</math>

 is the sampling frequency and 

<math display="inline" id="Delta-sigma_modulation:29">
 <semantics>
  <mrow>
   <mn>2</mn>
   <msub>
    <mi>f</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2f_{0}
  </annotation>
 </semantics>
</math>

 is <a href="Nyquist_rate" title="wikilink">Nyquist rate</a>, is defined by</p>

<p>

<math display="block" id="Delta-sigma_modulation:30">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <mi>OSR</mi>
   </mpadded>
   <mo rspace="4.2pt">=</mo>
   <mpadded width="+1.7pt">
    <mfrac>
     <msub>
      <mi>f</mi>
      <mi>s</mi>
     </msub>
     <mrow>
      <mn>2</mn>
      <msub>
       <mi>f</mi>
       <mn>0</mn>
      </msub>
     </mrow>
    </mfrac>
   </mpadded>
   <mo rspace="4.2pt">=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mn>2</mn>
     <msub>
      <mi>f</mi>
      <mn>0</mn>
     </msub>
     <mi>τ</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>OSR</ci>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>s</ci>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>τ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{OSR}\,=\,\frac{f_{s}}{2f_{0}}\,=\,\frac{1}{2f_{0}\tau}
  </annotation>
 </semantics>
</math>

</p>

<p>The <a href="Root_mean_square" title="wikilink">RMS</a> noise voltage within the band of interest can be expressed in terms of OSR</p>

<p>

<math display="block" id="Delta-sigma_modulation:31">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <msub>
     <mi mathvariant="normal">n</mi>
     <mn>0</mn>
    </msub>
   </mpadded>
   <mo rspace="4.2pt">=</mo>
   <mfrac>
    <msub>
     <mi>e</mi>
     <mrow>
      <mi>r</mi>
      <mi>m</mi>
      <mi>s</mi>
     </mrow>
    </msub>
    <msqrt>
     <mrow>
      <mi>O</mi>
      <mi>S</mi>
      <mi>R</mi>
     </mrow>
    </msqrt>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-n</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <ci>r</ci>
       <ci>m</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <root></root>
      <apply>
       <times></times>
       <ci>O</ci>
       <ci>S</ci>
       <ci>R</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{n_{0}}\,=\,\frac{e_{rms}}{\sqrt{OSR}}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="oversampling">Oversampling</h2>

<p>  Let's consider a signal at frequency 

<math display="inline" id="Delta-sigma_modulation:32">
 <semantics>
  <msub>
   <mi>f</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle f_{0}
  </annotation>
 </semantics>
</math>

 and a sampling frequency of 

<math display="inline" id="Delta-sigma_modulation:33">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi mathvariant="normal">s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>normal-s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle f_{\mathrm{s}}
  </annotation>
 </semantics>
</math>

 much higher than Nyquist rate (see fig. 5). ΔΣ modulation is based on the technique of oversampling to reduce the noise in the band of interest (green), which also avoids the use of high-precision analog circuits for the <em><a href="anti-aliasing_filter" title="wikilink">anti-aliasing filter</a></em>. The quantization noise is the same both in a Nyquist converter (in yellow) and in an oversampling converter (in blue), but it is distributed over a larger spectrum. In ΔΣ-converters, noise is further reduced at low frequencies, which is the band where the signal of interest is, and it is increased at the higher frequencies, where it can be filtered. This technique is known as noise shaping.</p>

<p>For a first order delta sigma modulator, the noise is shaped by a filter with transfer function 

<math display="inline" id="Delta-sigma_modulation:34">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="4.2pt">=</mo>
   <mrow>
    <mo>[</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <msup>
      <mi>z</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>n</ci>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle H_{n}(z)\,=\,\left[1-z^{-1}\right]
  </annotation>
 </semantics>
</math>

. Assuming that the sampling frequency 

<math display="inline" id="Delta-sigma_modulation:35">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <msub>
     <mi>f</mi>
     <mi>s</mi>
    </msub>
   </mpadded>
   <mo rspace="4.2pt">≫</mo>
   <msub>
    <mi>f</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">much-greater-than</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle f_{s}\,\gg\,f_{0}
  </annotation>
 </semantics>
</math>

, the quantization noise in the desired signal bandwidth can be approximated as:</p>

<p>

<math display="inline" id="Delta-sigma_modulation:36">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <msub>
     <mi mathvariant="normal">n</mi>
     <mn>0</mn>
    </msub>
   </mpadded>
   <mo rspace="4.2pt">=</mo>
   <mrow>
    <msub>
     <mi>e</mi>
     <mrow>
      <mi>r</mi>
      <mi>m</mi>
      <mi>s</mi>
     </mrow>
    </msub>
    <mpadded width="+1.7pt">
     <mfrac>
      <mi>π</mi>
      <msqrt>
       <mn>3</mn>
      </msqrt>
     </mfrac>
    </mpadded>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <msub>
        <mi>f</mi>
        <mn>0</mn>
       </msub>
       <mi>τ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mfrac>
      <mn>3</mn>
      <mn>2</mn>
     </mfrac>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-n</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <ci>r</ci>
       <ci>m</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <ci>π</ci>
      <apply>
       <root></root>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>τ</ci>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">3</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{n_{0}}\,=\,e_{rms}\frac{\pi}{\sqrt{3}}\,(2f_{0}\tau)^{\frac{3}{2}}
  </annotation>
 </semantics>
</math>

.</p>

<p>Similarly for a second order delta sigma modulator, the noise is shaped by a filter with transfer function 

<math display="inline" id="Delta-sigma_modulation:37">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="4.2pt">=</mo>
   <msup>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <msup>
       <mi>z</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <mo>]</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>n</ci>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle H_{n}(z)\,=\,\left[1-z^{-1}\right]^{2}
  </annotation>
 </semantics>
</math>

. The in-band quantization noise can be approximated as:</p>

<p>

<math display="inline" id="Delta-sigma_modulation:38">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <msub>
     <mi mathvariant="normal">n</mi>
     <mn>0</mn>
    </msub>
   </mpadded>
   <mo rspace="4.2pt">=</mo>
   <mrow>
    <msub>
     <mi>e</mi>
     <mrow>
      <mi>r</mi>
      <mi>m</mi>
      <mi>s</mi>
     </mrow>
    </msub>
    <mpadded width="+1.7pt">
     <mfrac>
      <msup>
       <mi>π</mi>
       <mn>2</mn>
      </msup>
      <msqrt>
       <mn>5</mn>
      </msqrt>
     </mfrac>
    </mpadded>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <msub>
        <mi>f</mi>
        <mn>0</mn>
       </msub>
       <mi>τ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mfrac>
      <mn>5</mn>
      <mn>2</mn>
     </mfrac>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-n</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <ci>r</ci>
       <ci>m</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>π</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <root></root>
       <cn type="integer">5</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>τ</ci>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">5</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{n_{0}}\,=\,e_{rms}\frac{\pi^{2}}{\sqrt{5}}\,(2f_{0}\tau)^{\frac{5}{2}}
  </annotation>
 </semantics>
</math>

.</p>

<p>In general, for a 

<math display="inline" id="Delta-sigma_modulation:39">
 <semantics>
  <mi mathvariant="normal">N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathrm{N}
  </annotation>
 </semantics>
</math>

-order ΔΣ-modulator, the variance of the in-band quantization noise:</p>

<p>

<math display="inline" id="Delta-sigma_modulation:40">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <msub>
     <mi mathvariant="normal">n</mi>
     <mn>0</mn>
    </msub>
   </mpadded>
   <mo rspace="4.2pt">=</mo>
   <mrow>
    <msub>
     <mi>e</mi>
     <mrow>
      <mi>r</mi>
      <mi>m</mi>
      <mi>s</mi>
     </mrow>
    </msub>
    <mpadded width="+1.7pt">
     <mfrac>
      <msup>
       <mi>π</mi>
       <mi>n</mi>
      </msup>
      <msqrt>
       <mrow>
        <mrow>
         <mn>2</mn>
         <mi>n</mi>
        </mrow>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msqrt>
     </mfrac>
    </mpadded>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <msub>
        <mi>f</mi>
        <mn>0</mn>
       </msub>
       <mi>τ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mfrac>
      <mrow>
       <mrow>
        <mn>2</mn>
        <mi>n</mi>
       </mrow>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mn>2</mn>
     </mfrac>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-n</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <ci>r</ci>
       <ci>m</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>π</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <root></root>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>n</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>τ</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>n</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{n_{0}}\,=\,e_{rms}\frac{\pi^{n}}{\sqrt{2n+1}}\,(2f_{0}\tau)^{\frac{2n+%
1}{2}}
  </annotation>
 </semantics>
</math>

.</p>

<p>When the sampling frequency is doubled, the signal to quantization noise is improved by 

<math display="inline" id="Delta-sigma_modulation:41">
 <semantics>
  <mrow>
   <mn>10</mn>
   <mrow>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mn>2</mn>
      <mrow>
       <mrow>
        <mn>2</mn>
        <mi>N</mi>
       </mrow>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mi>d</mi>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">10</cn>
    <apply>
     <log></log>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>N</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <ci>d</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle 10\log(2^{2N+1})\,dB
  </annotation>
 </semantics>
</math>

 for a 

<math display="inline" id="Delta-sigma_modulation:42">
 <semantics>
  <mi mathvariant="normal">N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathrm{N}
  </annotation>
 </semantics>
</math>

-order ΔΣ-modulator. The higher the oversampling ratio, the higher the <a href="signal-to-noise_ratio" title="wikilink">signal-to-noise ratio</a> and the higher the resolution in bits.</p>

<p>Another key aspect given by oversampling is the speed/resolution tradeoff. In fact, the decimation filter put after the modulator not only filters the whole sampled signal in the band of interest (cutting the noise at higher frequencies), but also reduces the frequency of the signal increasing its resolution. This is obtained by a sort of <em>averaging</em> of the higher data rate bitstream.</p>
<h3 id="example-of-decimation">Example of decimation</h3>

<p>Let's have, for instance, an 8:1 decimation filter and a 1-bit bitstream; if we have an input stream like 10010110, counting the number of ones, we get 4. Then the decimation result is 4/8 = 0.5. We can then represent it with a 3-bits number 100 (binary), which means half of the largest possible number. In other words,</p>
<ul>
<li>the sample frequency is reduced by a factor of eight</li>
<li>the serial (1-bit) input bus becomes a parallel (3-bits) output bus.</li>
</ul>
<h2 id="naming">Naming</h2>

<p>The technique was first presented in the early 1960s by professor Haruhiko Yasuda while he was a student at Waseda University, Tokyo, Japan. The name <em>Delta-Sigma</em> comes directly from the presence of a Delta modulator and an integrator, as firstly introduced by Inose et al. in their patent application.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> That is, the name comes from integrating or "<em>summing</em>" <strong>differences</strong>, which are operations usually associated with Greek letters <a class="uri" href="Sigma" title="wikilink">Sigma</a> and <a href="Delta_(letter)" title="wikilink">Delta</a> respectively. Both names <em>Sigma-Delta</em> and <em>Delta-Sigma</em> are frequently used.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Pulse-density_modulation" title="wikilink">Pulse-density modulation</a></li>
<li><a href="Pulse-width_modulation" title="wikilink">Pulse-width modulation</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cs.tut.fi/sgn/arg/rosti/1-bit/">1-bit A/D and D/A Converters</a></li>
<li><a href="http://www.embedded.com/design/configurable-systems/4006431/Sigma-delta-techniques-extend-DAC-resolution">Sigma-delta techniques extend DAC resolution</a> article by Tim Wescott 2004-06-23</li>
<li><a href="http://www.commsdesign.com/design_corner/showArticle.jhtml?articleID=18402743">Tutorial on Designing Delta-Sigma Modulators: Part I</a> and <a href="http://www.commsdesign.com/design_corner/showArticle.jhtml?articleID=18402763">Part II</a> by Mingliang (Michael) Liu</li>
<li><a href="http://eecs.oregonstate.edu/research/members/temes/pubs.html">Gabor Temes' Publications</a></li>
<li><a href="http://electronjunkie.wordpress.com/tag/sigma-delta-modulation/">Simple Sigma Delta Modulator example</a> Contains Block-diagrams, code, and simple explanations</li>
<li><a href="http://www.circuitdesign.info/blog/2008/09/example-simulink-model-scripts/">Example Simulink model &amp; scripts for continuous-time sigma-delta ADC</a> Contains example matlab code and Simulink model</li>
<li><a href="http://www-cis.stanford.edu/icl/wooley-grp/projects.html">Bruce Wooley's Delta-Sigma Converter Projects</a></li>
<li><a href="http://www.beis.de/Elektronik/DeltaSigma/DeltaSigma.html">An Introduction to Delta Sigma Converters</a> (which covers both ADCs and DACs sigma-delta)</li>
<li><a href="http://www.maxim-ic.com/appnotes.cfm/an_pk/1870/CMP/WP-10">Demystifying Sigma-Delta ADCs</a>. This in-depth article covers the theory behind a Delta-Sigma analog-to-digital converter.</li>
<li><a href="http://digitalsignallabs.com/SigmaDelta.pdf">Motorola digital signal processors: Principles of sigma-delta modulation for analog-to-digital converters</a></li>
<li><a href="http://www.digitalsignallabs.com/presentation.pdf">One-Bit Delta Sigma D/A Conversion Part I: Theory</a> article by Randy Yates presented at the 2004 comp.dsp conference</li>
<li><a href="http://www.aholme.co.uk/Frac2/Mash.htm">MASH (Multi-stAge noise SHaping) structure</a> with both theory and a block-level implementation of a MASH</li>
<li><a href="http://www.circuitdesign.info/blog/2008/11/continuous-time-sigma-delta-adc-noise-shaping-filter-circuit-architectures-2/">Continuous time sigma-delta ADC noise shaping filter circuit architectures</a> discusses architectural trade-offs for continuous-time sigma-delta noise-shaping filters</li>
<li><a href="http://www.cardinalpeak.com/blog/?p=392/">Some intuitive motivation for why a Delta Sigma modulator works</a></li>
</ul>

<p><a href="fr:Convertisseur_analogique-numérique#Convertisseur_Sigma_Delta" title="wikilink">fr:Convertisseur analogique-numérique#Convertisseur Sigma Delta</a>"</p>

<p><a href="Category:Digital_signal_processing" title="wikilink">Category:Digital signal processing</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a class="uri" href="http://www.numerix-dsp.com/appsnotes/APR8-sigma-delta.pdf">http://www.numerix-dsp.com/appsnotes/APR8-sigma-delta.pdf</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://www.analog.com/static/imported-files/tutorials/MT-028.pdf">Voltage-to-Frequency Converters</a> by Walt Kester and James Bryant 2009. Analog Devices.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://designtools.analog.com/dt/sdtutorial/sdtutorial.html">Analog Devices : Virtual Design Center : Interactive Design Tools : Sigma-Delta ADC Tutorial</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="http://www.faqs.org/patents/app/20090072897">Sigma-delta class-D amplifier and control method for a sigma-delta class-D amplifier</a> by Jwin-Yen Guo and Teng-Hung Chang<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="http://www.slac.stanford.edu/econf/C0604032/papers/0232.PDF">A Novel Architecture for DAQ in Multi-channel, Large Volume, Long Drift Liquid Argon TPC</a> by S. Centro, G. Meng, F. Pietropaola, S. Ventura 2006<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=4253561">A Low Power Sinc3 Filter for ΣΔ Modulators</a> by A. Lombardi, E. Bonizzoni, P. Malcovati, F. Maloberti 2007<a href="#fnref6">↩</a></li>
<li id="fn7">H. Inose, Y. Yasuda, J. Murakami, "A Telemetering System by Code Manipulation -- ΔΣ Modulation", IRE Trans on Space Electronics and Telemetry, Sep. 1962, pp. 204-209.<a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
