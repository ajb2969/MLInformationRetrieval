   Kernel Fisher discriminant analysis      Kernel Fisher discriminant analysis  In [[statistics]], '''kernel Fisher discriminant analysis (KFD)''', {{cite journal|last=Mika|first=S |author2=RÃ¤tsch, G. |author3=Weston, J. |author4=SchÃ¶lkopf, B. |author5=MÃ¼ller, KR|title=F isher discriminant analysis with kernels|journal=Neural Networks for Signal Processing|year=1999|volume=IX|pages=41-48|doi=10.1109/NNSP.1999.788121}} also known as generalized discriminant analysis 1 and kernel discriminant analysis , 2 is a kernelized version of linear discriminant analysis . It is named after Ronald Fisher . Using the kernel trick , LDA is implicitly performed in a new feature space, which allows non-linear mappings to be learned.  Linear discriminant analysis  Intuitively, the idea of LDA is to find a projection where class separation is maximized. Given two sets of labeled data,    ğ‚  1     subscript  ğ‚  1    \mathbf{C}_{1}   and    ğ‚  2     subscript  ğ‚  2    \mathbf{C}_{2}   , define the class means    ğ¦  1     subscript  ğ¦  1    \mathbf{m}_{1}   and    ğ¦  2     subscript  ğ¦  2    \mathbf{m}_{2}   to be        ğ¦  i   =    1   l  i      âˆ‘   n  =  1    l  i     ğ±  n  i      ,       subscript  ğ¦  i       1   subscript  l  i      superscript   subscript     n  1     subscript  l  i     superscript   subscript  ğ±  n   i       \mathbf{m}_{i}=\frac{1}{l_{i}}\sum_{n=1}^{l_{i}}\mathbf{x}_{n}^{i},     where    l  i     subscript  l  i    l_{i}   is the number of examples of class    ğ‚  i     subscript  ğ‚  i    \mathbf{C}_{i}   . The goal of linear discriminant analysis is to give a large separation of the class means while also keeping the in-class variance small. 3 This is formulated as maximizing        J   (  ğ°  )    =     ğ°  T    ğ’  B   ğ°     ğ°  T    ğ’  W   ğ°     ,        J  ğ°        superscript  ğ°  T    subscript  ğ’  B   ğ°      superscript  ğ°  T    subscript  ğ’  W   ğ°      J(\mathbf{w})=\frac{\mathbf{w}^{\text{T}}\mathbf{S}_{B}\mathbf{w}}{\mathbf{w}^%
 {\text{T}}\mathbf{S}_{W}\mathbf{w}},     where    ğ’  B     subscript  ğ’  B    \mathbf{S}_{B}   is the between-class covariance matrix and    ğ’  W     subscript  ğ’  W    \mathbf{S}_{W}   is the total within-class covariance matrix:      ğ’  B     subscript  ğ’  B    \displaystyle\mathbf{S}_{B}     Differentiating    J   (  ğ°  )       J  ğ°    J(\mathbf{w})   with respect to   ğ°   ğ°   \mathbf{w}   , setting equal to zero, and rearranging gives         (    ğ°  T    ğ’  B   ğ°   )    ğ’  W   ğ°   =    (    ğ°  T    ğ’  W   ğ°   )    ğ’  B   ğ°    .           superscript  ğ°  T    subscript  ğ’  B   ğ°    subscript  ğ’  W   ğ°        superscript  ğ°  T    subscript  ğ’  W   ğ°    subscript  ğ’  B   ğ°     (\mathbf{w}^{\text{T}}\mathbf{S}_{B}\mathbf{w})\mathbf{S}_{W}\mathbf{w}=(%
 \mathbf{w}^{\text{T}}\mathbf{S}_{W}\mathbf{w})\mathbf{S}_{B}\mathbf{w}.     Since we only care about the direction of   ğ°   ğ°   \mathbf{w}   and     ğ’  B   ğ°       subscript  ğ’  B   ğ°    \mathbf{S}_{B}\mathbf{w}   has the same direction as    (    ğ¦  2   -   ğ¦  1    )       subscript  ğ¦  2    subscript  ğ¦  1     (\mathbf{m}_{2}-\mathbf{m}_{1})   ,     ğ’  B   ğ°       subscript  ğ’  B   ğ°    \mathbf{S}_{B}\mathbf{w}   can be replaced by    (    ğ¦  2   -   ğ¦  1    )       subscript  ğ¦  2    subscript  ğ¦  1     (\mathbf{m}_{2}-\mathbf{m}_{1})   and we can drop the scalars    (    ğ°  T    ğ’  B   ğ°   )       superscript  ğ°  T    subscript  ğ’  B   ğ°    (\mathbf{w}^{\text{T}}\mathbf{S}_{B}\mathbf{w})   and    (    ğ°  T    ğ’  W   ğ°   )       superscript  ğ°  T    subscript  ğ’  W   ğ°    (\mathbf{w}^{\text{T}}\mathbf{S}_{W}\mathbf{w})   to give       ğ°  âˆ    ğ’  W   -  1     (    ğ¦  2   -   ğ¦  1    )     .     proportional-to  ğ°     subscript   superscript  ğ’    1    W      subscript  ğ¦  2    subscript  ğ¦  1       \mathbf{w}\propto\mathbf{S}^{-1}_{W}(\mathbf{m}_{2}-\mathbf{m}_{1}).     Kernel trick with LDA  To extend LDA to non-linear mappings, the data can be mapped to a new feature space,   F   F   F   , via some function   Ï•   Ï•   \phi   . In this new feature space, the function that needs to be maximized is 4        J   (  ğ°  )    =     ğ°  T    ğ’  B  Ï•   ğ°     ğ°  T    ğ’  W  Ï•   ğ°     ,        J  ğ°        superscript  ğ°  T    superscript   subscript  ğ’  B   Ï•   ğ°      superscript  ğ°  T    superscript   subscript  ğ’  W   Ï•   ğ°      J(\mathbf{w})=\frac{\mathbf{w}^{\text{T}}\mathbf{S}_{B}^{\phi}\mathbf{w}}{%
 \mathbf{w}^{\text{T}}\mathbf{S}_{W}^{\phi}\mathbf{w}},     where      ğ’  B  Ï•     superscript   subscript  ğ’  B   Ï•    \displaystyle\mathbf{S}_{B}^{\phi}     and        ğ¦  i  Ï•   =    1   l  i      âˆ‘   j  =  1    l  i     Ï•   (   ğ±  j  i   )       .       superscript   subscript  ğ¦  i   Ï•       1   subscript  l  i      superscript   subscript     j  1     subscript  l  i      Ï•   superscript   subscript  ğ±  j   i        \mathbf{m}_{i}^{\phi}=\frac{1}{l_{i}}\sum_{j=1}^{l_{i}}\phi(\mathbf{x}_{j}^{i}).     Further, note that    ğ°  âˆˆ  F      ğ°  F    \mathbf{w}\in F   . Explicitly computing the mappings    Ï•   (   ğ±  i   )       Ï•   subscript  ğ±  i     \phi(\mathbf{x}_{i})   and then performing LDA can be computationally expensive, and in many cases intractable. For example,   F   F   F   may be infinitely dimensional. Thus, rather than explicitly mapping the data to   F   F   F   , the data can be implicitly embedded by rewriting the algorithm in terms of dot products and using the kernel trick in which the dot product in the new feature space is replaced by a kernel function,     k   (  ğ±  ,  ğ²  )    =     Ï•   (  ğ±  )    â‹…  Ï•    (  ğ²  )          k   ğ±  ğ²       normal-â‹…    Ï•  ğ±   Ï•   ğ²     k(\mathbf{x},\mathbf{y})=\phi(\mathbf{x})\cdot\phi(\mathbf{y})   .  LDA can be reformulated in terms of dot products by first noting that   ğ°   ğ°   \mathbf{w}   will have an expansion of the form 5       ğ°  =    âˆ‘   i  =  1   l     Î±  i   Ï•   (   ğ±  i   )      .      ğ°    superscript   subscript     i  1    l      subscript  Î±  i   Ï•   subscript  ğ±  i       \mathbf{w}=\sum_{i=1}^{l}\alpha_{i}\phi(\mathbf{x}_{i}).   Then note that         ğ°  T    ğ¦  i  Ï•    =    1   l  i      âˆ‘   j  =  1   l     âˆ‘   k  =  1    l  i      Î±  j   k   (   ğ±  j   ,   ğ±  k  i   )       =    Î±  T    ğŒ  i     ,           superscript  ğ°  T    superscript   subscript  ğ¦  i   Ï•        1   subscript  l  i      superscript   subscript     j  1    l     superscript   subscript     k  1     subscript  l  i       subscript  Î±  j   k    subscript  ğ±  j    superscript   subscript  ğ±  k   i                superscript  Î±  T    subscript  ğŒ  i       \mathbf{w}^{\text{T}}\mathbf{m}_{i}^{\phi}=\frac{1}{l_{i}}\sum_{j=1}^{l}\sum_{%
 k=1}^{l_{i}}\alpha_{j}k(\mathbf{x}_{j},\mathbf{x}_{k}^{i})=\mathbf{\alpha}^{%
 \text{T}}\mathbf{M}_{i},     where         (   ğŒ  i   )   j   =    1   l  i      âˆ‘   k  =  1    l  i     k   (   ğ±  j   ,   ğ±  k  i   )       .       subscript   subscript  ğŒ  i   j       1   subscript  l  i      superscript   subscript     k  1     subscript  l  i      k    subscript  ğ±  j    superscript   subscript  ğ±  k   i         (\mathbf{M}_{i})_{j}=\frac{1}{l_{i}}\sum_{k=1}^{l_{i}}k(\mathbf{x}_{j},\mathbf%
 {x}_{k}^{i}).     The numerator of    J   (  ğ°  )       J  ğ°    J(\mathbf{w})   can then be written as:       ğ°  T    ğ’  B  Ï•   ğ°       superscript  ğ°  T    superscript   subscript  ğ’  B   Ï•   ğ°    \displaystyle\mathbf{w}^{\text{T}}\mathbf{S}_{B}^{\phi}\mathbf{w}   where    ğŒ  =    (    ğŒ  2   -   ğŒ  1    )     (    ğŒ  2   -   ğŒ  1    )   T        ğŒ       subscript  ğŒ  2    subscript  ğŒ  1     superscript     subscript  ğŒ  2    subscript  ğŒ  1    T      \mathbf{M}=(\mathbf{M}_{2}-\mathbf{M}_{1})(\mathbf{M}_{2}-\mathbf{M}_{1})^{%
 \text{T}}   . Similarly, the denominator can be written as         ğ°  T    ğ’  W  Ï•   ğ°   =    Î±  T   ğ  Î±    ,         superscript  ğ°  T    superscript   subscript  ğ’  W   Ï•   ğ°      superscript  Î±  T   ğ  Î±     \mathbf{w}^{\text{T}}\mathbf{S}_{W}^{\phi}\mathbf{w}=\mathbf{\alpha}^{\text{T}%
 }\mathbf{N}\mathbf{\alpha},     where       ğ  =    âˆ‘   j  =   1  ,  2       ğŠ  j    (   ğˆ  -   ğŸ   l  j     )    ğŠ  j  T      ,      ğ    subscript     j   1  2        subscript  ğŠ  j     ğˆ   subscript  1   subscript  l  j      superscript   subscript  ğŠ  j   T       \mathbf{N}=\sum_{j=1,2}\mathbf{K}_{j}(\mathbf{I}-\mathbf{1}_{l_{j}})\mathbf{K}%
 _{j}^{\text{T}},     with the     n  th   ,   m  th       superscript  n  th    superscript  m  th     n^{\text{th}},m^{\text{th}}   component of    ğŠ  j     subscript  ğŠ  j    \mathbf{K}_{j}   defined as    k   (   ğ±  n   ,   ğ±  m  j   )       k    subscript  ğ±  n    superscript   subscript  ğ±  m   j      k(\mathbf{x}_{n},\mathbf{x}_{m}^{j})   ,   ğˆ   ğˆ   \mathbf{I}   is the identity matrix, and    ğŸ   l  j      subscript  1   subscript  l  j     \mathbf{1}_{l_{j}}   the matrix with all entries equal to    1  /   l  j       1   subscript  l  j     1/l_{j}   . This identity can be derived by starting out with the expression for     ğ°  T    ğ’  W  Ï•   ğ°       superscript  ğ°  T    superscript   subscript  ğ’  W   Ï•   ğ°    \mathbf{w}^{\text{T}}\mathbf{S}_{W}^{\phi}\mathbf{w}   and using the expansion of   ğ°   ğ°   \mathbf{w}   and the definitions of    ğ’  W  Ï•     superscript   subscript  ğ’  W   Ï•    \mathbf{S}_{W}^{\phi}   and    ğ¦  i  Ï•     superscript   subscript  ğ¦  i   Ï•    \mathbf{m}_{i}^{\phi}          ğ°  T    ğ’  W  Ï•   ğ°       superscript  ğ°  T    superscript   subscript  ğ’  W   Ï•   ğ°    \displaystyle\mathbf{w}^{\text{T}}\mathbf{S}_{W}^{\phi}\mathbf{w}     With these equations for the numerator and denominator of    J   (  ğ°  )       J  ğ°    J(\mathbf{w})   , the equation for   J   J   J   can be rewritten as        J   (  Î±  )    =     Î±  T   ğŒ  Î±     Î±  T   ğ  Î±     .        J  Î±        superscript  Î±  T   ğŒ  Î±      superscript  Î±  T   ğ  Î±      J(\mathbf{\alpha})=\frac{\mathbf{\alpha}^{\text{T}}\mathbf{M}\mathbf{\alpha}}{%
 \mathbf{\alpha}^{\text{T}}\mathbf{N}\mathbf{\alpha}}.     Then, differentiating and setting equal to zero gives         (    Î±  T   ğŒ  Î±   )   ğ  Î±   =    (    Î±  T   ğ  Î±   )   ğŒ  Î±    .           superscript  Î±  T   ğŒ  Î±   ğ  Î±        superscript  Î±  T   ğ  Î±   ğŒ  Î±     (\mathbf{\alpha}^{\text{T}}\mathbf{M}\mathbf{\alpha})\mathbf{N}\mathbf{\alpha}%
 =(\mathbf{\alpha}^{\text{T}}\mathbf{N}\mathbf{\alpha})\mathbf{M}\mathbf{\alpha}.     Since only the direction of   ğ°   ğ°   \mathbf{w}   , and hence the direction of   Î±   Î±   \mathbf{\alpha}   , matters, the above can be solved for   Î±   Î±   \mathbf{\alpha}   as       Î±  =    ğ   -  1     (    ğŒ  2   -   ğŒ  1    )     .      Î±     superscript  ğ    1       subscript  ğŒ  2    subscript  ğŒ  1       \mathbf{\alpha}=\mathbf{N}^{-1}(\mathbf{M}_{2}-\mathbf{M}_{1}).     Note that in practice,   ğ   ğ   \mathbf{N}   is usually singular and so a multiple of the identity is added to it 6        ğ  Ïµ   =   ğ  +   Ïµ  ğˆ     .       subscript  ğ  Ïµ     ğ    Ïµ  ğˆ      \mathbf{N}_{\epsilon}=\mathbf{N}+\epsilon\mathbf{I}.     Given the solution for   Î±   Î±   \mathbf{\alpha}   , the projection of a new data point is given by 7        y   (  ğ±  )    =   (    ğ°  â‹…  Ï•    (  ğ±  )    )   =    âˆ‘   i  =  1   l     Î±  i   k   (   ğ±  i   ,  ğ±  )      .          y  ğ±      normal-â‹…  ğ°  Ï•   ğ±          superscript   subscript     i  1    l      subscript  Î±  i   k    subscript  ğ±  i   ğ±        y(\mathbf{x})=(\mathbf{w}\cdot\phi(\mathbf{x}))=\sum_{i=1}^{l}\alpha_{i}k(%
 \mathbf{x}_{i},\mathbf{x}).     Multi-class KFD  The extension to cases where there are more than two classes is relatively straightforward. 8 9 10 Let   c   c   c   be the number of classes. Then multi-class KFD involves projecting the data into a    (   c  -  1   )      c  1    (c-1)   -dimensional space using    (   c  -  1   )      c  1    (c-1)   discriminant functions        y  i   =    ğ°  i  T   Ï•   (  ğ±  )      i  =   1  ,  â€¦  ,   c  -  1.        formulae-sequence     subscript  y  i      superscript   subscript  ğ°  i   T   Ï•  ğ±      i   1  normal-â€¦    c  1.       y_{i}=\mathbf{w}_{i}^{\text{T}}\phi(\mathbf{x})\qquad i=1,\ldots,c-1.     This can be written in matrix notation       ğ²  =    ğ–  T   Ï•   (  ğ±  )     ,      ğ²     superscript  ğ–  T   Ï•  ğ±     \mathbf{y}=\mathbf{W}^{\text{T}}\phi(\mathbf{x}),     where the    ğ°  i     subscript  ğ°  i    \mathbf{w}_{i}   are the columns of   ğ–   ğ–   \mathbf{W}   . 11 Further, the between-class covariance matrix is now        ğ’  B  Ï•   =    âˆ‘   i  =  1   c     l  i    (    ğ¦  i  Ï•   -   ğ¦  Ï•    )     (    ğ¦  i  Ï•   -   ğ¦  Ï•    )   T      ,       superscript   subscript  ğ’  B   Ï•     superscript   subscript     i  1    c      subscript  l  i      superscript   subscript  ğ¦  i   Ï•    superscript  ğ¦  Ï•     superscript     superscript   subscript  ğ¦  i   Ï•    superscript  ğ¦  Ï•    T       \mathbf{S}_{B}^{\phi}=\sum_{i=1}^{c}l_{i}(\mathbf{m}_{i}^{\phi}-\mathbf{m}^{%
 \phi})(\mathbf{m}_{i}^{\phi}-\mathbf{m}^{\phi})^{\text{T}},     where    ğ¦  Ï•     superscript  ğ¦  Ï•    \mathbf{m}^{\phi}   is the mean of all the data in the new feature space. The within-class covariance matrix is        ğ’  W  Ï•   =    âˆ‘   i  =  1   c     âˆ‘   n  =  1    l  i      (    Ï•   (   ğ±  n  i   )    -   ğ¦  i  Ï•    )     (    Ï•   (   ğ±  n  i   )    -   ğ¦  i  Ï•    )   T       ,       superscript   subscript  ğ’  W   Ï•     superscript   subscript     i  1    c     superscript   subscript     n  1     subscript  l  i          Ï•   superscript   subscript  ğ±  n   i     superscript   subscript  ğ¦  i   Ï•     superscript      Ï•   superscript   subscript  ğ±  n   i     superscript   subscript  ğ¦  i   Ï•    T        \mathbf{S}_{W}^{\phi}=\sum_{i=1}^{c}\sum_{n=1}^{l_{i}}(\phi(\mathbf{x}_{n}^{i}%
 )-\mathbf{m}_{i}^{\phi})(\phi(\mathbf{x}_{n}^{i})-\mathbf{m}_{i}^{\phi})^{%
 \text{T}},     The solution is now obtained by maximizing        J   (  ğ–  )    =    |    ğ–  T    ğ’  B  Ï•   ğ–   |    |    ğ–  T    ğ’  W  Ï•   ğ–   |     .        J  ğ–          superscript  ğ–  T    superscript   subscript  ğ’  B   Ï•   ğ–         superscript  ğ–  T    superscript   subscript  ğ’  W   Ï•   ğ–       J(\mathbf{W})=\frac{\left|\mathbf{W}^{\text{T}}\mathbf{S}_{B}^{\phi}\mathbf{W}%
 \right|}{\left|\mathbf{W}^{\text{T}}\mathbf{S}_{W}^{\phi}\mathbf{W}\right|}.     The kernel trick can again be used and the goal of multi-class KFD becomes 12        ğ€  *   =   argmax  ğ€   =    |    ğ€  T   ğŒğ€   |    |    ğ€  T   ğğ€   |     ,         superscript  ğ€     ğ€  argmax               superscript  ğ€  T   ğŒğ€         superscript  ğ€  T   ğğ€        \mathbf{A}^{*}=\underset{\mathbf{A}}{\operatorname{argmax}}=\frac{\left|%
 \mathbf{A}^{\text{T}}\mathbf{M}\mathbf{A}\right|}{\left|\mathbf{A}^{\text{T}}%
 \mathbf{N}\mathbf{A}\right|},     where    A  =   [   Î±  1   ,  â€¦  ,   Î±   c  -  1    ]       A    subscript  Î±  1   normal-â€¦   subscript  Î±    c  1       A=[\mathbf{\alpha}_{1},\ldots,\mathbf{\alpha}_{c-1}]   and     M   M   \displaystyle M     The    ğŒ  i     subscript  ğŒ  i    \mathbf{M}_{i}   are defined as in the above section and    ğŒ  *     subscript  ğŒ     \mathbf{M}_{*}   is defined as         (   ğŒ  *   )   j   =    1  l     âˆ‘   k  =  1   l    k   (   ğ±  j   ,   ğ±  k   )       .       subscript   subscript  ğŒ    j       1  l     superscript   subscript     k  1    l     k    subscript  ğ±  j    subscript  ğ±  k         (\mathbf{M}_{*})_{j}=\frac{1}{l}\sum_{k=1}^{l}k(\mathbf{x}_{j},\mathbf{x}_{k}).       ğ€  *     superscript  ğ€     \mathbf{A}^{*}   can then be computed by finding the    (   c  -  1   )      c  1    (c-1)   leading eigenvectors of     ğ   -  1    ğŒ       superscript  ğ    1    ğŒ    \mathbf{N}^{-1}\mathbf{M}   . 13 Furthermore, the projection of a new input,    ğ±  t     subscript  ğ±  t    \mathbf{x}_{t}   , is given by 14        ğ²   (   ğ±  t   )    =     (   ğ€  *   )   T    ğŠ  t     ,        ğ²   subscript  ğ±  t       superscript   superscript  ğ€    T    subscript  ğŠ  t      \mathbf{y}(\mathbf{x}_{t})=\left(\mathbf{A}^{*}\right)^{\text{T}}\mathbf{K}_{t},     where the    i   t  h      superscript  i    t  h     i^{th}   component of    ğŠ  t     subscript  ğŠ  t    \mathbf{K}_{t}   is given by    k   (   ğ±  i   ,   ğ±  t   )       k    subscript  ğ±  i    subscript  ğ±  t      k(\mathbf{x}_{i},\mathbf{x}_{t})   .  Classification using KFD  In both two-class and multi-class KFD, the class label of a new input can be assigned as 15        f   (  ğ±  )    =   a  r  g    min  j   D    (   ğ²   (  ğ±  )    ,    ğ²  Â¯   j   )     ,        f  ğ±     a  r  g    subscript   j   D      ğ²  ğ±    subscript   normal-Â¯  ğ²   j       f(\mathbf{x})=arg\min_{j}D(\mathbf{y}(\mathbf{x}),\bar{\mathbf{y}}_{j}),     where     ğ²  Â¯   j     subscript   normal-Â¯  ğ²   j    \bar{\mathbf{y}}_{j}   is the projected mean for class   j   j   j   and    D   (  â‹…  ,  â‹…  )       D   normal-â‹…  normal-â‹…     D(\cdot,\cdot)   is a distance function.  Applications  Kernel discriminant analysis has been used in a variety of applications. These include:   Face recognition 16 17 18 and detection 19 20  Hand-written digit recognition 21 22  Palmprint recognition 23  Classification of malignant and benign cluster microcalcifications 24  Seed classification 25   See also   Factor analysis  Kernel principal component analysis  Kernel trick  Linear discriminant analysis   References  External links   Kernel Discriminant Analysis - This site gives a high level explanation of KFD.  Kernel Discriminant Analysis in C# - C# code to perform KFD.  Matlab Toolbox for Dimensionality Reduction - Includes a method for performing KFD.  Handwriting Recognition using Kernel Discriminant Analysis - C# code that demonstrates handwritten digit recognition using KFD.   "  Category:Multivariate statistics     â†©  â†©  â†©   â†©     â†©  â†©        â†©  â†©  â†©  â†©   â†©  â†©  â†©      