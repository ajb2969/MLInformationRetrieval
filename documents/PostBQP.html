<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1772">PostBQP</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>PostBQP</h1>
<hr/>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, <strong>PostBQP</strong> is a <a href="complexity_class" title="wikilink">complexity class</a> consisting of all of the <a href="computational_problem" title="wikilink">computational problems</a> solvable in <a href="polynomial_time" title="wikilink">polynomial time</a> on a <a href="quantum_Turing_machine" title="wikilink">quantum Turing machine</a> with <a class="uri" href="postselection" title="wikilink">postselection</a> and bounded error (in the sense that the algorithm is correct at least 2/3 of the time on all inputs).</p>

<p>Postselection is not considered to be a feature that a realistic computer (even a quantum one) would possess, but nevertheless postselecting machines are interesting from a theoretical perspective.</p>

<p>Removing either one of the two main features (quantumness, postselection) from <strong>PostBQP</strong> gives the following two complexity classes, both of which are subsets of <strong>PostBQP</strong>:</p>
<ul>
<li><strong><a class="uri" href="BQP" title="wikilink">BQP</a></strong> is the same as <strong>PostBQP</strong> except without postselection</li>
<li><strong>BPP<sub>path</sub></strong> is the same as <strong>PostBPP</strong> except that instead of quantum, the algorithm is a classical randomized algorithm (with postselection)<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></li>
</ul>

<p>The addition of <a class="uri" href="postselection" title="wikilink">postselection</a> seems to make quantum Turing machines much more powerful: <a href="Scott_Aaronson" title="wikilink">Scott Aaronson</a> proved<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <strong>PostBQP</strong> is equal to <strong>PP</strong>, a class which is believed to be relatively powerful, whereas <strong><a class="uri" href="BQP" title="wikilink">BQP</a></strong> is not known even to contain the seemingly smaller class <strong><a href="NP_(complexity_class)" title="wikilink">NP</a></strong>. Using similar techniques, Aaronson also proved that small changes to the laws of quantum computing would have significant effects. As specific examples, under either of the two following changes, the "new" version of <strong>BQP</strong> would equal <strong><a href="PP_(complexity)" title="wikilink">PP</a></strong>:</p>
<ul>
<li>if we broadened the definition of 'quantum gate' to include not just unitary operations but linear operations, or</li>
<li>if the probability of measuring a basis state 

<math display="inline" id="PostBQP:0">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>x</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |x\rangle
  </annotation>
 </semantics>
</math>

 was proportional to 

<math display="inline" id="PostBQP:1">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>α</mi>
     <mi>x</mi>
    </msub>
    <mo stretchy="false">|</mo>
   </mrow>
   <mi>p</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\alpha_{x}|^{p}
  </annotation>
 </semantics>
</math>

 instead of 

<math display="inline" id="PostBQP:2">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>α</mi>
     <mi>x</mi>
    </msub>
    <mo stretchy="false">|</mo>
   </mrow>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\alpha_{x}|^{2}
  </annotation>
 </semantics>
</math>

 for any even integer <em>p &gt; 2</em>.</li>
</ul>
<h2 id="basic-properties">Basic properties</h2>

<p>In order to describe some of the properties of <strong>PostBQP</strong> we fix a formal way of describing quantum postselection. Define a quantum algorithm to be a family of <a href="quantum_circuit" title="wikilink">quantum circuits</a> (specifically, a <a href="uniform_circuit_family" title="wikilink">uniform circuit family</a>). We designate one qubit as the <em>postselection qubit P</em> and another as the <em>output qubit Q</em>. Then <strong>PostBQP</strong> is defined by postselecting upon the event that the postselection qubit is |1&gt;. Explicitly, a language <em>L</em> is in PostBQP if there is a quantum algorithm <em>A</em> so that after running <em>A</em> on input <em>x</em> and measuring the two qubits <em>P</em> and <em>Q</em>,</p>
<ul>
<li><em>P</em> = 1 with nonzero probability</li>
<li>if the input <em>x</em> is in <em>L</em> then Pr[<em>Q</em> = 1|<em>P</em> = 1] ≥ 2/3</li>
<li>if the input <em>x</em> is not in <em>L</em> then Pr[<em>Q</em> = 0|<em>P</em> = 1] ≥ 2/3.</li>
</ul>

<p>One can show that allowing a single postselection step at the end of the algorithm (as described above) or allowing intermediate postselection steps during the algorithm are equivalent.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>Here are three basic properties of <strong>PostBQP</strong> (which also hold for <strong>BQP</strong> via similar proofs):</p>

<p>1. <strong>PostBQP</strong> is <em>closed under complement</em>. Given a language <em>L</em> in <strong>PostBQP</strong> and a corresponding deciding circuit family, create a new circuit family by flipping the output qubit after measurement, then the new circuit family proves the complement of <em>L</em> is in <strong>PostBQP</strong>.</p>

<p>2. You can do <em>probability amplification</em> in <strong>PostBQP</strong>. The definition of <strong>PostBQP</strong> is not changed if we replace the 2/3 value in its definition by any other constant strictly between 1/2 and 1. As an example, given a <strong>PostBQP</strong> algorithm <em>A</em> with success probability 2/3, we can construct another algorithm which runs three independent copies of <em>A</em>, outputs a postselection bit equal to the <a href="logical_conjunction" title="wikilink">conjunction</a> of the three "inner" ones, and outputs an output bit equal to the <a class="uri" href="majority" title="wikilink">majority</a> of the three "inner" ones; the new algorithm will be correct with conditional probability 

<math display="inline" id="PostBQP:3">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <mo>/</mo>
       <mn>3</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>3</mn>
    </msup>
    <mo>+</mo>
    <mrow>
     <mn>3</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>3</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>2</mn>
        <mo>/</mo>
        <mn>3</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>20</mn>
    <mo>/</mo>
    <mn>27</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <divide></divide>
       <cn type="integer">2</cn>
       <cn type="integer">3</cn>
      </apply>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <divide></divide>
        <cn type="integer">2</cn>
        <cn type="integer">3</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">20</cn>
     <cn type="integer">27</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (2/3)^{3}+3(1/3)(2/3)^{2}=20/27
  </annotation>
 </semantics>
</math>

, greater than the original 2/3.</p>

<p>3. <strong>PostBQP</strong> is <em>closed under <a href="intersection_(set_theory)" title="wikilink">intersection</a></em>. Suppose we have <strong>PostBQP</strong> circuit families for two languages <em>L1</em> and <em>L2</em>, with respective postselection qubits and output qubits <em>P1, P2, Q1, Q2</em>. We may assume by probability amplification that both circuit families have success probability at least 5/6. Then we create a composite algorithm where the circuits for <em>L1</em> and <em>L2</em> are run independently, and we set <em>P</em> to the conjunction of <em>P1</em> and <em>P2</em>, and <em>Q</em> to the conjunction of <em>Q1</em> and <em>Q2</em>. It is not hard to see by a <a href="union_bound" title="wikilink">union bound</a> that this composite algorithm correctly decides membership in 

<math display="inline" id="PostBQP:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mn>1</mn>
   </mrow>
   <mo>∩</mo>
   <mrow>
    <mi>L</mi>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <intersect></intersect>
    <apply>
     <times></times>
     <ci>L</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>L</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L1\cap L2
  </annotation>
 </semantics>
</math>

 with (conditional) probability at least 2/3.</p>

<p>More generally, combinations of these ideas show that <strong>PostBQP</strong> is closed under union and BQP truth-table reductions.</p>

<p>==PostBQP = PP==</p>

<p><a href="Scott_Aaronson" title="wikilink">Scott Aaronson</a> showed<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> that the complexity classes <strong>PostBQP</strong> (postselected bounded error quantum polynomial time) and <strong><a href="PP_(complexity)" title="wikilink">PP</a></strong> (probabilistic polynomial time) are equal. The result was significant because this <a href="PP_(complexity)#Quantum_computation_reformulation" title="wikilink">quantum computation reformulation of <strong>PP</strong></a> gave new insight and simpler proofs of properties of <strong>PP</strong>.</p>

<p>The usual definition of a <strong>PostBQP</strong> circuit family is one with two outbit qubits <em>P</em> (postselection) and <em>Q</em> (output) with a single measurement of <em>P</em> and <em>Q</em> at the end such that the probability of measuring <em>P</em> = 1 has nonzero probability, the conditional probability Pr[<em>Q</em> = 1|<em>P</em> = 1] ≥ 2/3 if the input <em>x</em> is in the language, and Pr[<em>Q</em> = 0|<em>P</em> = 1] ≥ 2/3 if the input <em>x</em> is not in the language. For technical reasons we tweak the definition of <strong>PostBQP</strong> as follows: we require that Pr[<em>P</em> = 1] ≥ 2<sup>−<em>n</em><sup><em>c</em></sup></sup> for some constant <em>c</em> depending on the circuit family. Note this choice does not affect the <a href="PostBQP#Basic_properties" title="wikilink">basic properties of <strong>PostBQP</strong></a>, and also it can be shown that any computation consisting of typical gates (e.g. Hadamard, Toffoli) has this property whenever Pr[<em>P</em> = 1] &gt; 0.</p>
<h2 id="proving-postbqp-pp">Proving PostBQP ⊆ PP</h2>

<p>Suppose we are given a <strong>PostBQP</strong> family of circuits to decide a language <em>L</em>. We assume without loss of generality (e.g. see the <a href="Quantum_computer#EssentialProperties" title="wikilink">inessential properties of quantum computers</a>) that all gates have transition matrices that are represented with real numbers, at the expense of adding one more qubit.</p>

<p>Let 

<math display="inline" id="PostBQP:5">
 <semantics>
  <mi mathvariant="normal">Ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi
  </annotation>
 </semantics>
</math>

 denote the final quantum state of the circuit before the postselecting measurement is made. The overall goal of the proof is to construct a <strong>PP</strong> algorithm to decide <em>L</em>. More specifically it suffices to have <em>L</em> correctly compare the squared amplitude of 

<math display="inline" id="PostBQP:6">
 <semantics>
  <mi mathvariant="normal">Ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi
  </annotation>
 </semantics>
</math>

 in the states with <em>Q</em> = 1, <em>P</em> = 1 to the squared amplitude of 

<math display="inline" id="PostBQP:7">
 <semantics>
  <mi mathvariant="normal">Ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi
  </annotation>
 </semantics>
</math>

 in the states with <em>Q</em> = 0, <em>P</em> = 1 to determine which is bigger. The key insight is that the comparison of these amplitudes can be transformed into comparing the acceptance probability of a <strong>PP</strong> machine with 1/2.</p>
<h3 id="matrix-view-of-postbqp-algorithms">Matrix view of PostBQP algorithms</h3>

<p>Let <em>n</em> denote the input size, <em>B</em> = <em>B</em>(<em>n</em>) denote the total number of qubits in the circuit (inputs, ancillary, output and postselection qubits), and <em>G</em> = <em>G</em>(<em>n</em>) denote the total number of gates. Represent the <em>i</em>th gate by its transition matrix <em>A</em><sup><em>i</em></sup> (a real unitary 

<math display="inline" id="PostBQP:8">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>B</mi>
   </msup>
   <mo>×</mo>
   <msup>
    <mn>2</mn>
    <mi>B</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>B</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{B}\times 2^{B}
  </annotation>
 </semantics>
</math>

 matrix) and let the initial state be |<em>x</em>&gt; (padded with zeroes). Then 

<math display="inline" id="PostBQP:9">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ψ</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mi>G</mi>
    </msup>
    <msup>
     <mi>A</mi>
     <mrow>
      <mi>G</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi mathvariant="normal">⋯</mi>
    <msup>
     <mi>A</mi>
     <mn>2</mn>
    </msup>
    <msup>
     <mi>A</mi>
     <mn>1</mn>
    </msup>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mi>x</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Ψ</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>G</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <apply>
       <minus></minus>
       <ci>G</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi=A^{G}A^{G-1}\cdots A^{2}A^{1}|x\rangle
  </annotation>
 </semantics>
</math>

. Define <em>S<sub>1</sub></em> (resp. <em>S</em><sub>0</sub>) to be the set of basis states corresponding to <em>P</em> = 1, <em>Q</em> = 1 (resp. <em>P</em> = 1, <em>Q</em> = 0) and define the probabilities</p>

<p>

<math display="block" id="PostBQP:10">
 <semantics>
  <mrow>
   <msub>
    <mi>π</mi>
    <mn>1</mn>
   </msub>
   <mo>:=</mo>
   <mtext>Pr</mtext>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>P</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi>Q</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>ω</mi>
     <mo>∈</mo>
     <msub>
      <mi>S</mi>
      <mn>1</mn>
     </msub>
    </mrow>
   </munder>
   <msubsup>
    <mi mathvariant="normal">Ψ</mi>
    <mi>ω</mi>
    <mn>2</mn>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <cn type="integer">1</cn>
    </apply>
    <csymbol cd="latexml">assign</csymbol>
    <mtext>Pr</mtext>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">P</csymbol>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <csymbol cd="unknown">Q</csymbol>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Ψ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>ω</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{1}:=\text{Pr}[P=1,Q=1]=\sum_{\omega\in S_{1}}\Psi^{2}_{\omega}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="PostBQP:11">
 <semantics>
  <mrow>
   <msub>
    <mi>π</mi>
    <mn>0</mn>
   </msub>
   <mo>:=</mo>
   <mtext>Pr</mtext>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>P</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi>Q</mi>
    <mo>=</mo>
    <mn>0</mn>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>ω</mi>
     <mo>∈</mo>
     <msub>
      <mi>S</mi>
      <mn>0</mn>
     </msub>
    </mrow>
   </munder>
   <msubsup>
    <mi mathvariant="normal">Ψ</mi>
    <mi>ω</mi>
    <mn>2</mn>
   </msubsup>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <cn type="integer">0</cn>
    </apply>
    <csymbol cd="latexml">assign</csymbol>
    <mtext>Pr</mtext>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">P</csymbol>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <csymbol cd="unknown">Q</csymbol>
     <eq></eq>
     <cn type="integer">0</cn>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Ψ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>ω</ci>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{0}:=\text{Pr}[P=1,Q=0]=\sum_{\omega\in S_{0}}\Psi^{2}_{\omega}.
  </annotation>
 </semantics>
</math>

</p>

<p>The definition of <strong>PostBQP</strong> ensures that either 

<math display="inline" id="PostBQP:12">
 <semantics>
  <mrow>
   <msub>
    <mi>π</mi>
    <mn>1</mn>
   </msub>
   <mo>≥</mo>
   <mrow>
    <mn>2</mn>
    <msub>
     <mi>π</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{1}\geq 2\pi_{0}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="PostBQP:13">
 <semantics>
  <mrow>
   <msub>
    <mi>π</mi>
    <mn>0</mn>
   </msub>
   <mo>≥</mo>
   <mrow>
    <mn>2</mn>
    <msub>
     <mi>π</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{0}\geq 2\pi_{1}
  </annotation>
 </semantics>
</math>

 according to whether <em>x</em> is in <em>L</em> or not.</p>

<p>Our <strong>PP</strong> machine will compare 

<math display="inline" id="PostBQP:14">
 <semantics>
  <msub>
   <mi>π</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>π</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="PostBQP:15">
 <semantics>
  <msub>
   <mi>π</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>π</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{0}
  </annotation>
 </semantics>
</math>

. In order to do this, we expand the definition of matrix multiplication:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="PostBQP:16">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Ψ</mi>
    <mi>ω</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <msub>
       <mi>α</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>α</mi>
       <mi>G</mi>
      </msub>
     </mrow>
    </msub>
    <mrow>
     <msubsup>
      <mi>A</mi>
      <mrow>
       <mi>ω</mi>
       <mo>,</mo>
       <msub>
        <mi>α</mi>
        <mi>G</mi>
       </msub>
      </mrow>
      <mi>G</mi>
     </msubsup>
     <msubsup>
      <mi>A</mi>
      <mrow>
       <msub>
        <mi>α</mi>
        <mi>G</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>α</mi>
        <mrow>
         <mi>G</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mrow>
      <mrow>
       <mi>G</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mi mathvariant="normal">⋯</mi>
     <msubsup>
      <mi>A</mi>
      <mrow>
       <msub>
        <mi>α</mi>
        <mn>3</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>α</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mn>2</mn>
     </msubsup>
     <msubsup>
      <mi>A</mi>
      <mrow>
       <msub>
        <mi>α</mi>
        <mn>2</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>α</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mn>1</mn>
     </msubsup>
     <msub>
      <mi>x</mi>
      <msub>
       <mi>α</mi>
       <mn>1</mn>
      </msub>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Ψ</ci>
     <ci>ω</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>G</ci>
       </apply>
      </list>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <ci>G</ci>
       </apply>
       <list>
        <ci>ω</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <ci>G</ci>
        </apply>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <apply>
         <minus></minus>
         <ci>G</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <ci>G</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <apply>
          <minus></minus>
          <ci>G</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </list>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <cn type="integer">2</cn>
       </apply>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <cn type="integer">3</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <cn type="integer">2</cn>
        </apply>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <cn type="integer">1</cn>
       </apply>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <cn type="integer">1</cn>
        </apply>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi_{\omega}=\sum_{\alpha_{1},\ldots,\alpha_{G}}A^{G}_{\omega,\alpha_{G}}A^{G%
-1}_{\alpha_{G},\alpha_{G-1}}\cdots A^{2}_{\alpha_{3},\alpha_{2}}A^{1}_{\alpha%
_{2},\alpha_{1}}x_{\alpha_{1}}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where the sum is taken over all lists of <em>G</em> basis vectors 

<math display="inline" id="PostBQP:17">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}
  </annotation>
 </semantics>
</math>

. Now 

<math display="inline" id="PostBQP:18">
 <semantics>
  <msub>
   <mi>π</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>π</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="PostBQP:19">
 <semantics>
  <msub>
   <mi>π</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>π</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{0}
  </annotation>
 </semantics>
</math>

 can be expressed as a sum of pairwise products of these terms. Intuitively, we want to design a machine whose acceptance probability is something like 

<math display="inline" id="PostBQP:20">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <msub>
       <mi>π</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>-</mo>
     <msub>
      <mi>π</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2}(1+\pi_{1}-\pi_{0})
  </annotation>
 </semantics>
</math>

, since then 

<math display="inline" id="PostBQP:21">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in L
  </annotation>
 </semantics>
</math>

 would imply that the acceptance probability is 

<math display="inline" id="PostBQP:22">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <msub>
        <mi>π</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo>-</mo>
      <msub>
       <mi>π</mi>
       <mn>0</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>π</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2}(1+\pi_{1}-\pi_{0})>1/2
  </annotation>
 </semantics>
</math>

, while 

<math display="inline" id="PostBQP:23">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∉</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>x</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\not\in L
  </annotation>
 </semantics>
</math>

 would imply that the acceptance probability is 

<math display="inline" id="PostBQP:24">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <msub>
        <mi>π</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo>-</mo>
      <msub>
       <mi>π</mi>
       <mn>0</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>π</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2}(1+\pi_{1}-\pi_{0})<1/2
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="technicality-we-may-assume-entries-of-the-transition-matrices-ai-are-rationals-with-denominator-2fn-for-some-polynomial-fn.">Technicality: we may assume entries of the transition matrices <em>A<sup>i</sup></em> are rationals with denominator 

<math display="inline" id="PostBQP:25">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{f(n)}
  </annotation>
 </semantics>
</math>

 for some polynomial <em>f(n)</em>.</h4>

<p>The definition of <strong>PostBQP</strong> tells us that 

<math display="inline" id="PostBQP:26">
 <semantics>
  <mrow>
   <msub>
    <mi>π</mi>
    <mn>1</mn>
   </msub>
   <mo>≥</mo>
   <mrow>
    <mfrac>
     <mn>2</mn>
     <mn>3</mn>
    </mfrac>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>π</mi>
       <mn>0</mn>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>π</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{1}\geq\frac{2}{3}(\pi_{0}+\pi_{1})
  </annotation>
 </semantics>
</math>

 if <em>x</em> is in <em>L</em>, and that otherwise 

<math display="inline" id="PostBQP:27">
 <semantics>
  <mrow>
   <msub>
    <mi>π</mi>
    <mn>0</mn>
   </msub>
   <mo>≥</mo>
   <mrow>
    <mfrac>
     <mn>2</mn>
     <mn>3</mn>
    </mfrac>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>π</mi>
       <mn>0</mn>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>π</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{0}\geq\frac{2}{3}(\pi_{0}+\pi_{1})
  </annotation>
 </semantics>
</math>

. Let us replace all entries of <em>A</em> by the nearest fraction with denominator 

<math display="inline" id="PostBQP:28">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{f(n)}
  </annotation>
 </semantics>
</math>

 for a large polynomial <em>f(n)</em> that we presently describe. What will be used later is that the <em>new</em> 

<math display="inline" id="PostBQP:29">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 values satisfy 

<math display="inline" id="PostBQP:30">
 <semantics>
  <mrow>
   <msub>
    <mi>π</mi>
    <mn>1</mn>
   </msub>
   <mo>></mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>π</mi>
       <mn>0</mn>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>π</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{1}>\frac{1}{2}(\pi_{0}+\pi_{1})
  </annotation>
 </semantics>
</math>

 if <em>x</em> is in <em>L</em>, and 

<math display="inline" id="PostBQP:31">
 <semantics>
  <mrow>
   <msub>
    <mi>π</mi>
    <mn>0</mn>
   </msub>
   <mo>></mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>π</mi>
       <mn>0</mn>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>π</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{0}>\frac{1}{2}(\pi_{0}+\pi_{1})
  </annotation>
 </semantics>
</math>

 if <em>x</em> is not in <em>L</em>. Using the earlier technical assumption and by analyzing how the 1-norm of the computational state changes, this is seen to be satisfied if 

<math display="inline" id="PostBQP:32">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <mrow>
         <msup>
          <mn>2</mn>
          <mrow>
           <mo>-</mo>
           <mrow>
            <mi>f</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>n</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mrow>
         </msup>
         <msup>
          <mn>2</mn>
          <mi>B</mi>
         </msup>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>G</mi>
     </msup>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo><</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>6</mn>
     </mfrac>
     <msup>
      <mn>2</mn>
      <mrow>
       <mo>-</mo>
       <msup>
        <mi>n</mi>
        <mi>c</mi>
       </msup>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">2</cn>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <ci>f</ci>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">2</cn>
         <ci>B</ci>
        </apply>
       </apply>
      </apply>
      <ci>G</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">6</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <ci>c</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1+2^{-f(n)}2^{B})^{G}-1<\frac{1}{6}2^{-n^{c}},
  </annotation>
 </semantics>
</math>

 thus clearly there is a large enough <em>f</em> that is polynomial in <em>n</em>.</p>
<h3 id="constructing-the-pp-machine">Constructing the PP machine</h3>

<p>Now we provide the detailed implementation of our <strong>PP</strong> machine. Let 

<math display="inline" id="PostBQP:33">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 denote the sequence 

<math display="inline" id="PostBQP:34">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>α</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>G</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\alpha_{i}\}_{i=1}^{G}
  </annotation>
 </semantics>
</math>

 and define the shorthand notation</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="PostBQP:35">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mi>ω</mi>
     <mo>,</mo>
     <mi>α</mi>
     <mo>,</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <msubsup>
     <mi>A</mi>
     <mrow>
      <mi>ω</mi>
      <mo>,</mo>
      <msub>
       <mi>α</mi>
       <mi>G</mi>
      </msub>
     </mrow>
     <mi>G</mi>
    </msubsup>
    <msubsup>
     <mi>A</mi>
     <mrow>
      <msub>
       <mi>α</mi>
       <mi>G</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>α</mi>
       <mrow>
        <mi>G</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
     <mrow>
      <mi>G</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
    <mi mathvariant="normal">⋯</mi>
    <msubsup>
     <mi>A</mi>
     <mrow>
      <msub>
       <mi>α</mi>
       <mn>3</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>α</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mn>2</mn>
    </msubsup>
    <msubsup>
     <mi>A</mi>
     <mrow>
      <msub>
       <mi>α</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>α</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mn>1</mn>
    </msubsup>
    <msub>
     <mi>x</mi>
     <msub>
      <mi>α</mi>
      <mn>1</mn>
     </msub>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>normal-Π</ci>
     <vector>
      <ci>A</ci>
      <ci>ω</ci>
      <ci>α</ci>
      <ci>x</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <ci>G</ci>
      </apply>
      <list>
       <ci>ω</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>G</ci>
       </apply>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <apply>
        <minus></minus>
        <ci>G</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>G</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <apply>
         <minus></minus>
         <ci>G</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </list>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <cn type="integer">2</cn>
      </apply>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <cn type="integer">2</cn>
       </apply>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <cn type="integer">1</cn>
      </apply>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <cn type="integer">1</cn>
       </apply>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi(A,\omega,\alpha,x):=A^{G}_{\omega,\alpha_{G}}A^{G-1}_{\alpha_{G},\alpha_{G%
-1}}\cdots A^{2}_{\alpha_{3},\alpha_{2}}A^{1}_{\alpha_{2},\alpha_{1}}x_{\alpha%
_{1}}
  </annotation>
 </semantics>
</math>

,
</dd>
</dl>
</dd>
</dl>

<p>then</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="PostBQP:36">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>π</mi>
      <mn>1</mn>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>π</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>ω</mi>
        <mo>∈</mo>
        <msub>
         <mi>S</mi>
         <mn>1</mn>
        </msub>
       </mrow>
      </msub>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>α</mi>
         <mo>,</mo>
         <msup>
          <mi>α</mi>
          <mo>′</mo>
         </msup>
        </mrow>
       </msub>
       <mrow>
        <mi mathvariant="normal">Π</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>A</mi>
         <mo>,</mo>
         <mi>ω</mi>
         <mo>,</mo>
         <mi>α</mi>
         <mo>,</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi mathvariant="normal">Π</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>A</mi>
         <mo>,</mo>
         <mi>ω</mi>
         <mo>,</mo>
         <msup>
          <mi>α</mi>
          <mo>′</mo>
         </msup>
         <mo>,</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>ω</mi>
        <mo>∈</mo>
        <msub>
         <mi>S</mi>
         <mn>0</mn>
        </msub>
       </mrow>
      </msub>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>α</mi>
         <mo>,</mo>
         <msup>
          <mi>α</mi>
          <mo>′</mo>
         </msup>
        </mrow>
       </msub>
       <mrow>
        <mi mathvariant="normal">Π</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>A</mi>
         <mo>,</mo>
         <mi>ω</mi>
         <mo>,</mo>
         <mi>α</mi>
         <mo>,</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi mathvariant="normal">Π</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>A</mi>
         <mo>,</mo>
         <mi>ω</mi>
         <mo>,</mo>
         <msup>
          <mi>α</mi>
          <mo>′</mo>
         </msup>
         <mo>,</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>ω</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>S</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <list>
         <ci>α</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>α</ci>
          <ci>normal-′</ci>
         </apply>
        </list>
       </apply>
       <apply>
        <times></times>
        <ci>normal-Π</ci>
        <vector>
         <ci>A</ci>
         <ci>ω</ci>
         <ci>α</ci>
         <ci>x</ci>
        </vector>
        <ci>normal-Π</ci>
        <vector>
         <ci>A</ci>
         <ci>ω</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>α</ci>
          <ci>normal-′</ci>
         </apply>
         <ci>x</ci>
        </vector>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>ω</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>S</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <list>
         <ci>α</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>α</ci>
          <ci>normal-′</ci>
         </apply>
        </list>
       </apply>
       <apply>
        <times></times>
        <ci>normal-Π</ci>
        <vector>
         <ci>A</ci>
         <ci>ω</ci>
         <ci>α</ci>
         <ci>x</ci>
        </vector>
        <ci>normal-Π</ci>
        <vector>
         <ci>A</ci>
         <ci>ω</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>α</ci>
          <ci>normal-′</ci>
         </apply>
         <ci>x</ci>
        </vector>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{1}-\pi_{0}=\sum_{\omega\in S_{1}}\sum_{\alpha,\alpha^{\prime}}\Pi(A,%
\omega,\alpha,x)\Pi(A,\omega,\alpha^{\prime},x)-\sum_{\omega\in S_{0}}\sum_{%
\alpha,\alpha^{\prime}}\Pi(A,\omega,\alpha,x)\Pi(A,\omega,\alpha^{\prime},x).
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>We define our <strong>PP</strong> machine to</p>
<ul>
<li>pick a basis state 

<math display="inline" id="PostBQP:37">
 <semantics>
  <mi>ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega
  </annotation>
 </semantics>
</math>

 uniformly at random</li>
<li>if 

<math display="inline" id="PostBQP:38">
 <semantics>
  <mrow>
   <mi>ω</mi>
   <mo>∉</mo>
   <mrow>
    <msub>
     <mi>S</mi>
     <mn>0</mn>
    </msub>
    <mo>∪</mo>
    <msub>
     <mi>S</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>ω</ci>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega\not\in S_{0}\cup S_{1}
  </annotation>
 </semantics>
</math>

 then STOP and accept with probability 1/2, reject with probability 1/2</li>
<li>pick two sequences 

<math display="inline" id="PostBQP:39">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>,</mo>
   <msup>
    <mi>α</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>α</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>α</ci>
     <ci>normal-′</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha,\alpha^{\prime}
  </annotation>
 </semantics>
</math>

 of <em>G</em> basis states uniformly at random</li>
<li>compute 

<math display="inline" id="PostBQP:40">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mi>ω</mi>
     <mo>,</mo>
     <mi>α</mi>
     <mo>,</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">Π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mi>ω</mi>
     <mo>,</mo>
     <msup>
      <mi>α</mi>
      <mo>′</mo>
     </msup>
     <mo>,</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <apply>
     <times></times>
     <ci>normal-Π</ci>
     <vector>
      <ci>A</ci>
      <ci>ω</ci>
      <ci>α</ci>
      <ci>x</ci>
     </vector>
     <ci>normal-Π</ci>
     <vector>
      <ci>A</ci>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>α</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>x</ci>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=\Pi(A,\omega,\alpha,x)\Pi(A,\omega,\alpha^{\prime},x)
  </annotation>
 </semantics>
</math>

 (which is a fraction with denominator 

<math display="inline" id="PostBQP:41">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mn>2</mn>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>f</ci>
     <ci>n</ci>
     <ci>G</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{2f(n)G(n)}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="PostBQP:42">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>≤</mo>
   <mi>X</mi>
   <mo>≤</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -1\leq X\leq 1
  </annotation>
 </semantics>
</math>

)</li>
<li>if 

<math display="inline" id="PostBQP:43">
 <semantics>
  <mrow>
   <mi>ω</mi>
   <mo>∈</mo>
   <msub>
    <mi>S</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ω</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega\in S_{1}
  </annotation>
 </semantics>
</math>

 then accept with probability 

<math display="inline" id="PostBQP:44">
 <semantics>
  <mfrac>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mi>X</mi>
   </mrow>
   <mn>2</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>X</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1+X}{2}
  </annotation>
 </semantics>
</math>

 and reject with probability 

<math display="inline" id="PostBQP:45">
 <semantics>
  <mfrac>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mi>X</mi>
   </mrow>
   <mn>2</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>X</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1-X}{2}
  </annotation>
 </semantics>
</math>

 (which takes at most <em>2f(n)G(n)+1</em> coin flips)</li>
<li>otherwise (then 

<math display="inline" id="PostBQP:46">
 <semantics>
  <mrow>
   <mi>ω</mi>
   <mo>∈</mo>
   <msub>
    <mi>S</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ω</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega\in S_{0}
  </annotation>
 </semantics>
</math>

) accept with probability 

<math display="inline" id="PostBQP:47">
 <semantics>
  <mfrac>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mi>X</mi>
   </mrow>
   <mn>2</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>X</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1-X}{2}
  </annotation>
 </semantics>
</math>

 and reject with probability 

<math display="inline" id="PostBQP:48">
 <semantics>
  <mfrac>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mi>X</mi>
   </mrow>
   <mn>2</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>X</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1+X}{2}
  </annotation>
 </semantics>
</math>

 (which again takes at most <em>2f(n)G(n)+1</em> coin flips)</li>
</ul>

<p>Then it is straightforward to compute that this machine accepts with probability 

<math display="inline" id="PostBQP:49">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>π</mi>
        <mn>1</mn>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>π</mi>
        <mn>0</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>/</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mn>2</mn>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <mrow>
         <mi>B</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mn>2</mn>
         <mi>B</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>G</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>B</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>B</ci>
        <ci>n</ci>
        <ci>G</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2}+(\pi_{1}-\pi_{0})/(2^{1+B(n)+2B(n)G(n)}),
  </annotation>
 </semantics>
</math>

 so this is a <strong>PP</strong> machine for the language <em>L</em>, as needed.</p>
<h2 id="proving-pp-postbqp">Proving PP ⊆ PostBQP</h2>

<p>Suppose we have a <strong>PP</strong> machine with time complexity <em>T:=T(n)</em> on input <em>x</em> of length <em>n := |x|</em>. Thus the machine flips a coin at most <em>T</em> times during the computation. We can thus view the machine as a deterministic function <em>f</em> (implemented, e.g. by a classical circuit) which takes two inputs (<em>x, r</em>) where <em>r</em>, a binary string of length <em>T</em>, represents the results of the random coin flips that are performed by the computation, and the output of <em>f</em> is 1 (accept) or 0 (reject). The definition of <strong>PP</strong> tells us that</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="PostBQP:50">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>L</mi>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">#</mi>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mi>r</mi>
       <mo>∈</mo>
       <msup>
        <mrow>
         <mo stretchy="false">{</mo>
         <mn>0</mn>
         <mo>,</mo>
         <mn>1</mn>
         <mo stretchy="false">}</mo>
        </mrow>
        <mi>T</mi>
       </msup>
      </mrow>
      <mo>∣</mo>
      <mrow>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>r</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>T</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <in></in>
     <ci>x</ci>
     <ci>L</ci>
    </apply>
    <apply>
     <geq></geq>
     <apply>
      <times></times>
      <ci>normal-#</ci>
      <apply>
       <csymbol cd="latexml">conditional-set</csymbol>
       <apply>
        <in></in>
        <ci>r</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <set>
          <cn type="integer">0</cn>
          <cn type="integer">1</cn>
         </set>
         <ci>T</ci>
        </apply>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <ci>f</ci>
         <interval closure="open">
          <ci>x</ci>
          <ci>r</ci>
         </interval>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in L\Leftrightarrow\#\{r\in\{0,1\}^{T}\mid f(x,r)=1\}\geq 2^{T-1}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Thus, we want a <strong>PostBQP</strong> algorithm that can determine whether the above statement is true.</p>

<p>Define <em>s</em> to be the number of random strings which lead to acceptance,</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="PostBQP:51">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>:=</mo>
   <mrow>
    <mi mathvariant="normal">#</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>r</mi>
      <mo>∈</mo>
      <msup>
       <mrow>
        <mo stretchy="false">{</mo>
        <mn>0</mn>
        <mo>,</mo>
        <mn>1</mn>
        <mo stretchy="false">}</mo>
       </mrow>
       <mi>T</mi>
      </msup>
     </mrow>
     <mo>∣</mo>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>r</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>s</ci>
    <apply>
     <times></times>
     <ci>normal-#</ci>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <in></in>
       <ci>r</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <set>
         <cn type="integer">0</cn>
         <cn type="integer">1</cn>
        </set>
        <ci>T</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <ci>f</ci>
        <interval closure="open">
         <ci>x</ci>
         <ci>r</ci>
        </interval>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s:=\#\{r\in\{0,1\}^{T}\mid f(x,r)=1\}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>and so 

<math display="inline" id="PostBQP:52">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>T</mi>
   </msup>
   <mo>-</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>T</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{T}-s
  </annotation>
 </semantics>
</math>

 is the number of rejected strings. It is straightforward to argue that without loss of generality, 

<math display="inline" id="PostBQP:53">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∉</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>T</mi>
     </msup>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
    <mo>,</mo>
    <msup>
     <mn>2</mn>
     <mi>T</mi>
    </msup>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>s</ci>
    <set>
     <cn type="integer">0</cn>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>T</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>T</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\not\in\{0,2^{T}/2,2^{T}\}
  </annotation>
 </semantics>
</math>

; for details, see a similar <a href="without_loss_of_generality" title="wikilink">without loss of generality</a> assumption in the <a href="PP_(complexity)#complement" title="wikilink">proof that <strong>PP</strong> is closed under complementation</a>.</p>
<h3 id="aaronsons-algorithm">Aaronson's algorithm</h3>

<p>Aaronson's algorithm for solving this problem is as follows. For simplicity, we will write all quantum states as unnormalized. First, we prepare the state 

<math display="inline" id="PostBQP:54">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <msup>
      <mrow>
       <mo stretchy="false">{</mo>
       <mn>0</mn>
       <mo>,</mo>
       <mn>1</mn>
       <mo stretchy="false">}</mo>
      </mrow>
      <mi>T</mi>
     </msup>
    </mrow>
   </msub>
   <mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mi>x</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <set>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </set>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{x\in\{0,1\}^{T}}|x\rangle|f(x)\rangle
  </annotation>
 </semantics>
</math>

. Second, we apply <a href="Hadamard_gate" title="wikilink">Hadamard gates</a> to the first register (each of the first <em>T</em> qubits), measure the first register and postselect on it being the all-zero string. It is easy to verify that this leaves the last register (the last qubit) in the residual state</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="PostBQP:55">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mi>ψ</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>:=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mn>2</mn>
         <mi>T</mi>
        </msup>
        <mo>-</mo>
        <mi>s</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>0</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>s</mi>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>1</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>ψ</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>T</ci>
       </apply>
       <ci>s</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle:=(2^{T}-s)|0\rangle+s|1\rangle.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Where <em>H</em> denotes the Hadamard gate, we compute the state</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="PostBQP:56">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mi>ψ</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msup>
        <mn>2</mn>
        <mi>T</mi>
       </msup>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>0</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msup>
          <mn>2</mn>
          <mi>T</mi>
         </msup>
         <mo>-</mo>
         <mrow>
          <mn>2</mn>
          <mi>s</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>1</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <msqrt>
     <mn>2</mn>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>ψ</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>T</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">2</cn>
         <ci>T</ci>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>s</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <root></root>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H|\psi\rangle=(2^{T}|0\rangle+(2^{T}-2s)|1\rangle)/\sqrt{2}
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
</dd>
</dl>

<p>Where 

<math display="inline" id="PostBQP:57">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>,</mo>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>α</ci>
    <ci>β</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha,\beta
  </annotation>
 </semantics>
</math>

 are positive real numbers to be chosen later with 

<math display="inline" id="PostBQP:58">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>α</mi>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mi>β</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>α</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>β</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha^{2}+\beta^{2}=1
  </annotation>
 </semantics>
</math>

, we compute the state 

<math display="inline" id="PostBQP:59">
 <semantics>
  <mrow>
   <mrow>
    <mi>α</mi>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mn>0</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mi>ψ</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>β</mi>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mn>1</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mrow>
      <mi>H</mi>
      <mi>ψ</mi>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>α</ci>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>ψ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>β</ci>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <apply>
       <times></times>
       <ci>H</ci>
       <ci>ψ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha|0\rangle|\psi\rangle+\beta|1\rangle|H\psi\rangle
  </annotation>
 </semantics>
</math>

 and measure the second qubit, postselecting on its value being equal to 1, which leaves the first qubit in a residual state depending on 

<math display="inline" id="PostBQP:60">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>/</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>β</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta/\alpha
  </annotation>
 </semantics>
</math>

 which we denote</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="PostBQP:61">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>ϕ</mi>
     <mrow>
      <mi>β</mi>
      <mo>/</mo>
      <mi>α</mi>
     </mrow>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mrow>
     <mi>α</mi>
     <mi>s</mi>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mn>0</mn>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mi>β</mi>
      <msqrt>
       <mn>2</mn>
      </msqrt>
     </mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mn>2</mn>
        <mi>T</mi>
       </msup>
       <mo>-</mo>
       <mrow>
        <mn>2</mn>
        <mi>s</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mn>1</mn>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <apply>
       <divide></divide>
       <ci>β</ci>
       <ci>α</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>α</ci>
      <ci>s</ci>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>β</ci>
       <apply>
        <root></root>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>T</ci>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>s</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi_{\beta/\alpha}\rangle:=\alpha s|0\rangle+\frac{\beta}{\sqrt{2}}(2^{T}-2s%
)|1\rangle
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
</dd>
</dl>

<p>Visualizing the possible states of a qubit as a circle, we see that if 

<math display="inline" id="PostBQP:62">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>></mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>T</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>s</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <ci>T</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s>2^{T-1}
  </annotation>
 </semantics>
</math>

, (i.e. if 

<math display="inline" id="PostBQP:63">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in L
  </annotation>
 </semantics>
</math>

) then 

<math display="inline" id="PostBQP:64">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mrow>
    <mi>β</mi>
    <mo>/</mo>
    <mi>α</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <apply>
     <divide></divide>
     <ci>β</ci>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{\beta/\alpha}
  </annotation>
 </semantics>
</math>

 lies in the open quadrant 

<math display="inline" id="PostBQP:65">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mrow>
     <mi>a</mi>
     <mi>c</mi>
     <mi>c</mi>
    </mrow>
   </msub>
   <mo>:=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mn>1</mn>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mn>0</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>c</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <interval closure="open">
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">0</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{acc}:=(-|1\rangle,|0\rangle)
  </annotation>
 </semantics>
</math>

 while if 

<math display="inline" id="PostBQP:66">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo><</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>T</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>s</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <ci>T</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s<2^{T-1}
  </annotation>
 </semantics>
</math>

, (i.e. if 

<math display="inline" id="PostBQP:67">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∉</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>x</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\not\in L
  </annotation>
 </semantics>
</math>

) then 

<math display="inline" id="PostBQP:68">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mrow>
    <mi>β</mi>
    <mo>/</mo>
    <mi>α</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <apply>
     <divide></divide>
     <ci>β</ci>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{\beta/\alpha}
  </annotation>
 </semantics>
</math>

 lies in the open quadrant 

<math display="inline" id="PostBQP:69">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mrow>
     <mi>r</mi>
     <mi>e</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>:=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mn>0</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mn>1</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>e</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">1</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{rej}:=(|0\rangle,|1\rangle)
  </annotation>
 </semantics>
</math>

. In fact for any fixed <em>x</em> (and its corresponding <em>s</em>), as we vary the ratio 

<math display="inline" id="PostBQP:70">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>/</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>β</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta/\alpha
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="PostBQP:71">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mi mathvariant="normal">∞</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">0</cn>
    <infinity></infinity>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (0,\infty)
  </annotation>
 </semantics>
</math>

, note that the image of 

<math display="inline" id="PostBQP:72">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msub>
    <mi>ϕ</mi>
    <mrow>
     <mi>β</mi>
     <mo>/</mo>
     <mi>α</mi>
    </mrow>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <apply>
      <divide></divide>
      <ci>β</ci>
      <ci>α</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi_{\beta/\alpha}\rangle
  </annotation>
 </semantics>
</math>

 is precisely the corresponding open quadrant. In the rest of the proof, we make precise the idea that we can distinguish between these two quadrants.</p>
<h3 id="analysis">Analysis</h3>

<p>Let 

<math display="inline" id="PostBQP:73">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mo>+</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>1</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>0</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <msqrt>
     <mn>2</mn>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <plus></plus>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <root></root>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |+\rangle=(|1\rangle+|0\rangle)/\sqrt{2}
  </annotation>
 </semantics>
</math>

, which is the center of 

<math display="inline" id="PostBQP:74">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mrow>
    <mi>r</mi>
    <mi>e</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>e</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{rej}
  </annotation>
 </semantics>
</math>

, and let 

<math display="inline" id="PostBQP:75">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mo>-</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <minus></minus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |-\rangle
  </annotation>
 </semantics>
</math>

 be orthogonal to 

<math display="inline" id="PostBQP:76">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mo>+</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |+\rangle
  </annotation>
 </semantics>
</math>

. Any qubit in 

<math display="inline" id="PostBQP:77">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mrow>
    <mi>a</mi>
    <mi>c</mi>
    <mi>c</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>c</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{acc}
  </annotation>
 </semantics>
</math>

, when measured in the basis 

<math display="inline" id="PostBQP:78">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mo>+</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mo>-</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <plus></plus>
    </apply>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <minus></minus>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{|+\rangle,|-\rangle\}
  </annotation>
 </semantics>
</math>

, gives the value 

<math display="inline" id="PostBQP:79">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mo>+</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |+\rangle
  </annotation>
 </semantics>
</math>

 less than 1/2 of the time. On the other hand, if 

<math display="inline" id="PostBQP:80">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∉</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>x</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\not\in L
  </annotation>
 </semantics>
</math>

 and we had picked 

<math display="inline" id="PostBQP:81">
 <semantics>
  <mrow>
   <mrow>
    <mi>β</mi>
    <mo>/</mo>
    <mi>α</mi>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>r</mi>
    <mo>*</mo>
   </msup>
   <mo>:=</mo>
   <mrow>
    <mrow>
     <msqrt>
      <mn>2</mn>
     </msqrt>
     <mi>s</mi>
    </mrow>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mn>2</mn>
       <mi>T</mi>
      </msup>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <mi>s</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <ci>β</ci>
      <ci>α</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>r</ci>
      <times></times>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <root></root>
        <cn type="integer">2</cn>
       </apply>
       <ci>s</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>T</ci>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>s</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta/\alpha=r^{*}:=\sqrt{2}s/(2^{T}-2s)
  </annotation>
 </semantics>
</math>

 then measuring 

<math display="inline" id="PostBQP:82">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msub>
    <mi>ϕ</mi>
    <mrow>
     <mi>β</mi>
     <mo>/</mo>
     <mi>α</mi>
    </mrow>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <apply>
      <divide></divide>
      <ci>β</ci>
      <ci>α</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi_{\beta/\alpha}\rangle
  </annotation>
 </semantics>
</math>

 in the basis 

<math display="inline" id="PostBQP:83">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mo>+</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mo>-</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <plus></plus>
    </apply>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <minus></minus>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{|+\rangle,|-\rangle\}
  </annotation>
 </semantics>
</math>

 would give the value 

<math display="inline" id="PostBQP:84">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mo>+</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |+\rangle
  </annotation>
 </semantics>
</math>

 all of the time. Since we don't know <em>s</em> we also don't know the precise value of <em>r*</em>, but we can try several (polynomially many) different values for 

<math display="inline" id="PostBQP:85">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>/</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>β</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta/\alpha
  </annotation>
 </semantics>
</math>

 in hopes of getting one that is "near" <em>r*</em>.</p>

<p>Specifically, note 

<math display="inline" id="PostBQP:86">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mi>T</mi>
    </mrow>
   </msup>
   <mo><</mo>
   <mi>r</mi>
   <mo>*</mo>
   <mo><</mo>
   <msup>
    <mn>2</mn>
    <mi>T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <ci>T</ci>
     </apply>
    </apply>
    <lt></lt>
    <csymbol cd="unknown">r</csymbol>
    <times></times>
    <lt></lt>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>T</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{-T}<r*<2^{T}
  </annotation>
 </semantics>
</math>

 and let us successively set 

<math display="inline" id="PostBQP:87">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>/</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>β</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta/\alpha
  </annotation>
 </semantics>
</math>

 to every value of the form 

<math display="inline" id="PostBQP:88">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>i</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{i}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="PostBQP:89">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mi>T</mi>
   </mrow>
   <mo>≤</mo>
   <mi>i</mi>
   <mo>≤</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <minus></minus>
      <ci>T</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -T\leq i\leq T
  </annotation>
 </semantics>
</math>

. Then elementary calculations show that for one of these values of <em>i</em>, the probability that the measurement of 

<math display="inline" id="PostBQP:90">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msub>
    <mi>ϕ</mi>
    <msup>
     <mn>2</mn>
     <mi>i</mi>
    </msup>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi_{2^{i}}\rangle
  </annotation>
 </semantics>
</math>

 in the basis 

<math display="inline" id="PostBQP:91">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mo>+</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mo>-</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <plus></plus>
    </apply>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <minus></minus>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{|+\rangle,|-\rangle\}
  </annotation>
 </semantics>
</math>

 yields 

<math display="inline" id="PostBQP:92">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mo>+</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |+\rangle
  </annotation>
 </semantics>
</math>

 is at least 

<math display="inline" id="PostBQP:93">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>3</mn>
      <mo>+</mo>
      <mrow>
       <mn>2</mn>
       <msqrt>
        <mn>2</mn>
       </msqrt>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mn>6</mn>
   </mrow>
   <mo>≈</mo>
   <mn>0.971.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <cn type="integer">3</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <root></root>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <cn type="integer">6</cn>
    </apply>
    <cn type="float">0.971.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (3+2\sqrt{2})/6\approx 0.971.
  </annotation>
 </semantics>
</math>

</p>

<p>Overall, the <strong>PostBQP</strong> algorithm is as follows. Let <em>k</em> be any constant strictly between 1/2 and 

<math display="inline" id="PostBQP:94">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>3</mn>
     <mo>+</mo>
     <mrow>
      <mn>2</mn>
      <msqrt>
       <mn>2</mn>
      </msqrt>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <mn>6</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <plus></plus>
     <cn type="integer">3</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <cn type="integer">6</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (3+2\sqrt{2})/6
  </annotation>
 </semantics>
</math>

. We do the following experiment for each 

<math display="inline" id="PostBQP:95">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mi>T</mi>
   </mrow>
   <mo>≤</mo>
   <mi>i</mi>
   <mo>≤</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <minus></minus>
      <ci>T</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -T\leq i\leq T
  </annotation>
 </semantics>
</math>

: construct and measure 

<math display="inline" id="PostBQP:96">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msub>
    <mi>ϕ</mi>
    <msup>
     <mn>2</mn>
     <mi>i</mi>
    </msup>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi_{2^{i}}\rangle
  </annotation>
 </semantics>
</math>

 in the basis 

<math display="inline" id="PostBQP:97">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mo>+</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mo>-</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <plus></plus>
    </apply>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <minus></minus>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{|+\rangle,|-\rangle\}
  </annotation>
 </semantics>
</math>

 a total of 

<math display="inline" id="PostBQP:98">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mi>log</mi>
    <mi>T</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <apply>
     <log></log>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\log T
  </annotation>
 </semantics>
</math>

 times where <em>C</em> is a constant. If the proportion of 

<math display="inline" id="PostBQP:99">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mo>+</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |+\rangle
  </annotation>
 </semantics>
</math>

 measurements is greater than <em>k</em>, then reject. If we don't reject for any <em>i</em>, accept. <a href="Chernoff_bound" title="wikilink">Chernoff bounds</a> then show that for a sufficiently large universal constant <em>C</em>, we correctly classify <em>x</em> with probability at least 2/3.</p>

<p>Note that this algorithm satisfies the technical assumption that the overall postselection probability is not too small: each individual measurement of 

<math display="inline" id="PostBQP:100">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msub>
    <mi>ϕ</mi>
    <msup>
     <mn>2</mn>
     <mi>i</mi>
    </msup>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi_{2^{i}}\rangle
  </annotation>
 </semantics>
</math>

 has postselection probability 

<math display="inline" id="PostBQP:101">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/2^{O(T)}
  </annotation>
 </semantics>
</math>

 and so the overall probability is 

<math display="inline" id="PostBQP:102">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>T</mi>
        <mn>2</mn>
       </msup>
       <mrow>
        <mi>log</mi>
        <mi>T</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>T</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <log></log>
        <ci>T</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/2^{O(T^{2}\log T)}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="implications">Implications</h2>
<ul>
<li>See <a href="PP_%28complexity%29#Quantum_computation_reformulation" title="wikilink">Quantum computation reformulation of <strong>PP</strong></a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Articles_containing_proofs" title="wikilink">Category:Articles containing proofs</a> <a href="Category:Quantum_complexity_theory" title="wikilink">Category:Quantum complexity theory</a> <a href="Category:Probabilistic_complexity_classes" title="wikilink">Category:Probabilistic complexity classes</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">. Preprint available at <a href="http://arxiv.org/abs/quant-ph/0412187">1</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
