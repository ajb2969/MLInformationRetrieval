<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1819">Nested sampling algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Nested sampling algorithm</h1>
<hr/>

<p>The <strong>nested sampling algorithm</strong> is a <a href="computation" title="wikilink">computational</a> approach to the problem of comparing models in <a href="Bayesian_statistics" title="wikilink">Bayesian statistics</a>, developed in 2004 by <a class="uri" href="physicist" title="wikilink">physicist</a> John Skilling.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="background">Background</h2>

<p><a href="Bayes'_theorem" title="wikilink">Bayes' theorem</a> can be applied to a pair of competing models 

<math display="inline" id="Nested_sampling_algorithm:0">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Nested_sampling_algorithm:1">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M2
  </annotation>
 </semantics>
</math>

 for data 

<math display="inline" id="Nested_sampling_algorithm:2">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

, one of which may be true (though which one is not known) but which both cannot simultaneously be true. The posterior probability for 

<math display="inline" id="Nested_sampling_algorithm:3">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M1
  </annotation>
 </semantics>
</math>

 may be calculated as follows:</p>

<p>

<math display="inline" id="Nested_sampling_algorithm:4">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mn>1</mn>
    <mo stretchy="false">|</mo>
    <mi>D</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <cn type="integer">1</cn>
     <ci>normal-|</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(M1|D)
  </annotation>
 </semantics>
</math>


</p>

<p>Given no a priori information in favor of 

<math display="inline" id="Nested_sampling_algorithm:5">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M1
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Nested_sampling_algorithm:6">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M2
  </annotation>
 </semantics>
</math>

, it is reasonable to assign prior probabilities 

<math display="inline" id="Nested_sampling_algorithm:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>M</mi>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>M</mi>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>M</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>M</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(M1)=P(M2)=1/2
  </annotation>
 </semantics>
</math>

, so that 

<math display="inline" id="Nested_sampling_algorithm:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>M</mi>
        <mn>2</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>/</mo>
     <mi>P</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>M</mi>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <times></times>
        <ci>M</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>P</ci>
     </apply>
     <apply>
      <times></times>
      <ci>M</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(M2)/P(M1)=1
  </annotation>
 </semantics>
</math>

. The remaining <a href="Bayes_factor" title="wikilink">Bayes factor</a>

<math display="inline" id="Nested_sampling_algorithm:9">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>D</mi>
    <mo stretchy="false">|</mo>
    <mi>M</mi>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>D</mi>
    <mo stretchy="false">|</mo>
    <mi>M</mi>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">M</csymbol>
     <cn type="integer">2</cn>
     <ci>normal-)</ci>
    </cerror>
    <divide></divide>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">M</csymbol>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(D|M2)/P(D|M1)
  </annotation>
 </semantics>
</math>

 is not so easy to evaluate since in general it requires marginalization of nuisance parameters. Generally, 

<math display="inline" id="Nested_sampling_algorithm:10">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M1
  </annotation>
 </semantics>
</math>

 has a collection of parameters that can be lumped together and called 

<math display="inline" id="Nested_sampling_algorithm:11">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Nested_sampling_algorithm:12">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M2
  </annotation>
 </semantics>
</math>

 has its own vector of parameters that may be of different dimensionality but is still referred to as 

<math display="inline" id="Nested_sampling_algorithm:13">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

. The marginalization for 

<math display="inline" id="Nested_sampling_algorithm:14">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M1
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="block" id="Nested_sampling_algorithm:15">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>D</mi>
    <mo stretchy="false">|</mo>
    <mi>M</mi>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo largeop="true" symmetric="true">∫</mo>
   <mi>d</mi>
   <mi>θ</mi>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>D</mi>
    <mo stretchy="false">|</mo>
    <mi>θ</mi>
    <mo>,</mo>
    <mi>M</mi>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">|</mo>
    <mi>M</mi>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">M</csymbol>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <int></int>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">θ</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">M</csymbol>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">M</csymbol>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(D|M1)=\int d\theta P(D|\theta,M1)P(\theta|M1)
  </annotation>
 </semantics>
</math>

</p>

<p>and likewise for 

<math display="inline" id="Nested_sampling_algorithm:16">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M2
  </annotation>
 </semantics>
</math>

. This integral is often analytically intractable, and in these cases it is necessary to employ a numerical algorithm to find an approximation. The nested sampling algorithm was developed by John Skilling specifically to approximate these marginalization integrals, and it has the added benefit of generating samples from the posterior distribution 

<math display="inline" id="Nested_sampling_algorithm:17">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">|</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>M</mi>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">M</csymbol>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\theta|D,M1)
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> It is an alternative to methods from the Bayesian literature<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> such as bridge sampling and defensive importance sampling.</p>

<p>Here is a simple version of the nested sampling algorithm, followed by a description of how it computes the marginal probability density 

<math display="inline" id="Nested_sampling_algorithm:18">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>D</mi>
    <mo stretchy="false">|</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Z</csymbol>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z=P(D|M)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Nested_sampling_algorithm:19">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Nested_sampling_algorithm:20">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M1
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Nested_sampling_algorithm:21">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M2
  </annotation>
 </semantics>
</math>

:</p>

<p><code>  Start with </code>

<math display="inline" id="Nested_sampling_algorithm:22">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

<code> points </code>

<math display="inline" id="Nested_sampling_algorithm:23">
 <semantics>
  <mrow>
   <msub>
    <mi>θ</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>θ</mi>
    <mi>N</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <ci>N</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{1},...,\theta_{N}
  </annotation>
 </semantics>
</math>

<code> sampled from prior.</code><br/>
<code>  for </code>

<math display="inline" id="Nested_sampling_algorithm:24">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1
  </annotation>
 </semantics>
</math>

<code> to </code>

<math display="inline" id="Nested_sampling_algorithm:25">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

<code> do        % The number of iterations j is chosen by guesswork.</code><br/>
<code>      </code>

<math display="inline" id="Nested_sampling_algorithm:26">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mi>i</mi>
   </msub>
   <mo>:=</mo>
   <mi>min</mi>
   <mo stretchy="false">(</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>i</ci>
    </apply>
    <csymbol cd="latexml">assign</csymbol>
    <min></min>
    <ci>normal-(</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{i}:=\min(
  </annotation>
 </semantics>
</math>

<code>current likelihood values of the points</code>

<math display="inline" id="Nested_sampling_algorithm:27">
 <semantics>
  <mo stretchy="false">)</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-)</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   )
  </annotation>
 </semantics>
</math>

<code>;</code><br/>
<code>      </code>

<math display="inline" id="Nested_sampling_algorithm:28">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mi>i</mi>
    </msub>
    <mo>:=</mo>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>i</mi>
        <mo>/</mo>
        <mi>N</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <exp></exp>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <ci>i</ci>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}:=\exp(-i/N);
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Nested_sampling_algorithm:29">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>i</mi>
   </msub>
   <mo>:=</mo>
   <mrow>
    <msub>
     <mi>X</mi>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>X</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}:=X_{i-1}-X_{i}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Nested_sampling_algorithm:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>Z</mi>
    <mo>:=</mo>
    <mrow>
     <mi>Z</mi>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>L</mi>
       <mi>i</mi>
      </msub>
      <mo>*</mo>
      <msub>
       <mi>w</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>Z</ci>
    <apply>
     <plus></plus>
     <ci>Z</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z:=Z+L_{i}*w_{i};
  </annotation>
 </semantics>
</math>

</p>

<p><code>      Save the point with least likelihood as a sample point with weight </code>

<math display="inline" id="Nested_sampling_algorithm:31">
 <semantics>
  <msub>
   <mi>w</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}
  </annotation>
 </semantics>
</math>

<code>.</code><br/>
<code>      Update the point with least likelihood with some Markov Chain</code><br/>
<code>      Monte Carlo steps according to the prior, accepting only steps that</code><br/>
<code>      keep the likelihood above </code>

<math display="inline" id="Nested_sampling_algorithm:32">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{i}
  </annotation>
 </semantics>
</math>

<code>.</code><br/>
<code>  end</code><br/>
<code>  return </code>

<math display="inline" id="Nested_sampling_algorithm:33">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

<code>;</code></p>

<p>At each iteration, 

<math display="inline" id="Nested_sampling_algorithm:34">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}
  </annotation>
 </semantics>
</math>

 is an estimate of the amount of prior mass covered by the hypervolume in parameter space of all points with likelihood greater than 

<math display="inline" id="Nested_sampling_algorithm:35">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}
  </annotation>
 </semantics>
</math>

. The weight factor 

<math display="inline" id="Nested_sampling_algorithm:36">
 <semantics>
  <msub>
   <mi>w</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}
  </annotation>
 </semantics>
</math>

 is an estimate of the amount of prior mass that lies between two nested hypersurfaces 

<math display="inline" id="Nested_sampling_algorithm:37">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>θ</mi>
   <mo stretchy="false">|</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>D</mi>
    <mo stretchy="false">|</mo>
    <mi>θ</mi>
    <mo>,</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>D</mi>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>θ</mi>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>,</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-{</ci>
    <csymbol cd="unknown">θ</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-}</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\theta|P(D|\theta,M)=P(D|\theta_{i-1},M)\}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Nested_sampling_algorithm:38">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>θ</mi>
   <mo stretchy="false">|</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>D</mi>
    <mo stretchy="false">|</mo>
    <mi>θ</mi>
    <mo>,</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>D</mi>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>θ</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-{</ci>
    <csymbol cd="unknown">θ</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-}</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\theta|P(D|\theta,M)=P(D|\theta_{i},M)\}
  </annotation>
 </semantics>
</math>

. The update step 

<math display="inline" id="Nested_sampling_algorithm:39">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>:=</mo>
   <mrow>
    <mi>Z</mi>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>L</mi>
      <mi>i</mi>
     </msub>
     <mo>*</mo>
     <msub>
      <mi>w</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>Z</ci>
    <apply>
     <plus></plus>
     <ci>Z</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z:=Z+L_{i}*w_{i}
  </annotation>
 </semantics>
</math>

 computes the sum over 

<math display="inline" id="Nested_sampling_algorithm:40">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Nested_sampling_algorithm:41">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mi>i</mi>
   </msub>
   <mo>*</mo>
   <msub>
    <mi>w</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{i}*w_{i}
  </annotation>
 </semantics>
</math>

 to numerically approximate the integral</p>

<p>

<math display="block" id="Nested_sampling_algorithm:42">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>D</mi>
       <mo stretchy="false">|</mo>
       <mi>M</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>D</mi>
       <mo stretchy="false">|</mo>
       <mi>θ</mi>
       <mo>,</mo>
       <mi>M</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>θ</mi>
       <mo stretchy="false">|</mo>
       <mi>M</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>θ</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>D</mi>
       <mo stretchy="false">|</mo>
       <mi>θ</mi>
       <mo>,</mo>
       <mi>M</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>θ</mi>
       <mo stretchy="false">|</mo>
       <mi>M</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">D</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">M</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <int></int>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">D</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">θ</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">M</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">θ</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">M</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">d</csymbol>
      <csymbol cd="unknown">θ</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <int></int>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">D</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">θ</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">M</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">d</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">θ</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">M</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{lcl}P(D|M)&=&\int P(D|\theta,M)P(\theta|M)d\theta\\
&=&\int P(D|\theta,M)dP(\theta|M)\\
\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>The idea is to chop up the range of 

<math display="inline" id="Nested_sampling_algorithm:43">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>D</mi>
    <mo stretchy="false">|</mo>
    <mi>θ</mi>
    <mo>,</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\theta)=P(D|\theta,M)
  </annotation>
 </semantics>
</math>

 and estimate, for each interval 

<math display="inline" id="Nested_sampling_algorithm:44">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>θ</mi>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>θ</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [f(\theta_{i-1}),f(\theta_{i})]
  </annotation>
 </semantics>
</math>

, how likely it is a priori that a randomly chosen 

<math display="inline" id="Nested_sampling_algorithm:45">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 would map to this interval. This can be thought of as a Bayesian's way to numerically implement <a href="Lebesgue_integration" title="wikilink">Lebesgue integration</a>.</p>
<h2 id="implementations">Implementations</h2>
<ul>
<li>Simple example code written in <a href="C_(programming_language)" title="wikilink">C</a>, <a href="R_(programming_language)" title="wikilink">R</a>, or <a href="Python_(programming_language)" title="wikilink">Python</a> demonstrating this algorithm can be downloaded from <a href="http://www.inference.phy.cam.ac.uk/bayesys/">John Skilling's website</a></li>
<li>There is also a Haskell port of the above simple codes on <a href="http://hackage.haskell.org/package/NestedSampling">Hackage</a></li>
<li>An implementation in <a href="R_(programming_language)" title="wikilink">R</a> originally designed for fitting of spectra is described at <a href="http://www.mrao.cam.ac.uk/~bn204/galevol/speca/rnested.html">1</a> and can be obtained on GitHub at <a href="https://github.com/bnikolic/RNested">2</a></li>
<li>A highly modular <a href="Python_(programming_language)" title="wikilink">Python</a> parallel implementation of Nested Sampling for <a href="statistical_physics" title="wikilink">statistical physics</a> and <a href="condensed_matter_physics" title="wikilink">condensed matter physics</a> applications is publicly available from GitHub <a href="https://github.com/js850/nested_sampling">3</a>.</li>
</ul>
<h2 id="applications">Applications</h2>

<p>Since nested sampling was proposed in 2004, it has been used in multiple settings within the field of <a class="uri" href="astronomy" title="wikilink">astronomy</a>. One paper suggested using nested sampling for <a href="cosmology" title="wikilink">cosmological</a> <a href="model_selection" title="wikilink">model selection</a> and object detection, as it "uniquely combines accuracy, general applicability and computational feasibility."<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> A refinement of the nested sampling algorithm to handle multimodal posteriors has also been suggested as a means of detecting astronomical objects in existing datasets.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Other applications of nested sampling is in the field of <a href="finite_element_updating" title="wikilink">finite element updating</a> where nested sampling is used to choose an optimal <a href="finite_element" title="wikilink">finite element</a> model and this was applied to <a href="structural_dynamics" title="wikilink">structural dynamics</a>. <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Bayesian_model_comparison" title="wikilink">Bayesian model comparison</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Bayesian_statistics" title="wikilink">Category:Bayesian statistics</a> <a href="Category:Model_selection" title="wikilink">Category:Model selection</a> <a href="Category:Statistical_algorithms" title="wikilink">Category:Statistical algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6">Mthembu, L., Marwala, T., Friswell, M.I. and Adhikari, S. 2011. Model selection in finite element model updating using the Bayesian evidence statistic.Mechanical Systems and Signal Processing, 25(7), 2399– 2412.<a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
