<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="197">Cluster analysis</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Cluster analysis</h1>
<hr/>

<p> <strong>Cluster analysis</strong> or <strong>clustering</strong> is the task of grouping a set of objects in such a way that objects in the same group (called a <strong>cluster</strong>) are more similar (in some sense or another) to each other than to those in other groups (clusters). It is a main task of exploratory <a href="data_mining" title="wikilink">data mining</a>, and a common technique for <a href="statistics" title="wikilink">statistical</a> <a href="data_analysis" title="wikilink">data analysis</a>, used in many fields, including <a href="machine_learning" title="wikilink">machine learning</a>, <a href="pattern_recognition" title="wikilink">pattern recognition</a>, <a href="image_analysis" title="wikilink">image analysis</a>, <a href="information_retrieval" title="wikilink">information retrieval</a>, and <a class="uri" href="bioinformatics" title="wikilink">bioinformatics</a>.</p>

<p>Cluster analysis itself is not one specific <a class="uri" href="algorithm" title="wikilink">algorithm</a>, but the general task to be solved. It can be achieved by various algorithms that differ significantly in their notion of what constitutes a cluster and how to efficiently find them. Popular notions of clusters include groups with small <a href="Distance_function" title="wikilink">distances</a> among the cluster members, dense areas of the data space, intervals or particular <a href="statistical_distribution" title="wikilink">statistical distributions</a>. Clustering can therefore be formulated as a <a href="multi-objective_optimization" title="wikilink">multi-objective optimization</a> problem. The appropriate clustering algorithm and parameter settings (including values such as the <a href="Metric_(mathematics)" title="wikilink">distance function</a> to use, a density threshold or the number of expected clusters) depend on the individual data set and intended use of the results. Cluster analysis as such is not an automatic task, but an iterative process of <a href="knowledge_discovery" title="wikilink">knowledge discovery</a> or interactive multi-objective optimization that involves trial and failure. It will often be necessary to modify data preprocessing and model parameters until the result achieves the desired properties.</p>

<p>Besides the term <em>clustering</em>, there are a number of terms with similar meanings, including <em>automatic <a href="Statistical_classification" title="wikilink">classification</a></em>, <em><a href="numerical_taxonomy" title="wikilink">numerical taxonomy</a></em>, <em>botryology</em> (from Greek Œ≤œåœÑœÅœÖœÇ "grape") and <em>typological analysis</em>. The subtle differences are often in the usage of the results: while in data mining, the resulting groups are the matter of interest, in automatic classification the resulting discriminative power is of interest. This often leads to misunderstandings between researchers coming from the fields of data mining and machine learning, since they use the same terms and often the same algorithms, but have different goals.</p>

<p>Cluster analysis was originated in anthropology by Driver and Kroeber in 1932 and introduced to psychology by Zubin in 1938 and <a href="Robert_Tryon" title="wikilink">Robert Tryon</a> in 1939<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and famously used by Cattell beginning in 1943<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> for trait theory classification in personality psychology.</p>
<h2 id="definition">Definition</h2>

<p>According to Vladimir Estivill-Castro, the notion of a "cluster" cannot be precisely defined, which is one of the reasons why there are so many clustering algorithms.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> There is a common denominator: a group of data objects. However, different researchers employ different cluster models, and for each of these cluster models again different algorithms can be given. The notion of a cluster, as found by different algorithms, varies significantly in its properties. Understanding these "cluster models" is key to understanding the differences between the various algorithms. Typical cluster models include:</p>
<ul>
<li>Connectivity models: for example <a href="hierarchical_clustering" title="wikilink">hierarchical clustering</a> builds models based on distance connectivity.</li>
<li>Centroid models: for example the <a href="k-means_algorithm" title="wikilink">k-means algorithm</a> represents each cluster by a single mean vector.</li>
<li>Distribution models: clusters are modeled using statistical distributions, such as <a href="multivariate_normal_distribution" title="wikilink">multivariate normal distributions</a> used by the <a href="Expectation-maximization_algorithm" title="wikilink">Expectation-maximization algorithm</a>.</li>
<li>Density models: for example <a class="uri" href="DBSCAN" title="wikilink">DBSCAN</a> and <a class="uri" href="OPTICS" title="wikilink">OPTICS</a> defines clusters as connected dense regions in the data space.</li>
<li>Subspace models: in <a class="uri" href="Biclustering" title="wikilink">Biclustering</a> (also known as Co-clustering or two-mode-clustering), clusters are modeled with both cluster members and relevant attributes.</li>
<li>Group models: some algorithms do not provide a refined model for their results and just provide the grouping information.</li>
<li>Graph-based models: a <a href="Clique_(graph_theory)" title="wikilink">clique</a>, i.e., a subset of nodes in a <a href="Graph_(mathematics)" title="wikilink">graph</a> such that every two nodes in the subset are connected by an edge can be considered as a prototypical form of cluster. Relaxations of the complete connectivity requirement (a fraction of the edges can be missing) are known as quasi-cliques, as in <a href="HCS_clustering_algorithm" title="wikilink">HCS clustering algorithm</a> .</li>
</ul>

<p>A "clustering" is essentially a set of such clusters, usually containing all objects in the data set. Additionally, it may specify the relationship of the clusters to each other, for example a hierarchy of clusters embedded in each other. Clusterings can be roughly distinguished as:</p>
<ul>
<li>hard clustering: each object belongs to a cluster or not</li>
<li>soft clustering (also: <a href="fuzzy_clustering" title="wikilink">fuzzy clustering</a>): each object belongs to each cluster to a certain degree (e.g.¬†a likelihood of belonging to the cluster)</li>
</ul>

<p>There are also finer distinctions possible, for example:</p>
<ul>
<li>strict partitioning clustering: here each object belongs to exactly one cluster</li>
<li>strict partitioning clustering with outliers: objects can also belong to no cluster, and are considered <a href="Anomaly_detection" title="wikilink">outliers</a>.</li>
<li>overlapping clustering (also: alternative clustering, multi-view clustering): while usually a hard clustering, objects may belong to more than one cluster.</li>
<li>hierarchical clustering: objects that belong to a child cluster also belong to the parent cluster</li>
<li><a href="subspace_clustering" title="wikilink">subspace clustering</a>: while an overlapping clustering, within a uniquely defined subspace, clusters are not expected to overlap.</li>
</ul>
<h2 id="algorithms">Algorithms</h2>

<p>Clustering algorithms can be categorized based on their cluster model, as listed above. The following overview will only list the most prominent examples of clustering algorithms, as there are possibly over 100 published clustering algorithms. Not all provide models for their clusters and can thus not easily be categorized. An overview of algorithms explained in Wikipedia can be found in the <a href="List_of_algorithms#Statistics" title="wikilink">list of statistics algorithms</a>.</p>

<p>There is no objectively "correct" clustering algorithm, but as it was noted, "clustering is in the eye of the beholder."<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The most appropriate clustering algorithm for a particular problem often needs to be chosen experimentally, unless there is a mathematical reason to prefer one cluster model over another. It should be noted that an algorithm that is designed for one kind of model has no chance on a data set that contains a radically different kind of model.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> For example, k-means cannot find non-convex clusters.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="connectivity-based-clustering-hierarchical-clustering">Connectivity based clustering (hierarchical clustering)</h3>

<p>Connectivity based clustering, also known as <em><a href="hierarchical_clustering" title="wikilink">hierarchical clustering</a></em>, is based on the core idea of objects being more related to nearby objects than to objects farther away. These algorithms connect "objects" to form "clusters" based on their distance. A cluster can be described largely by the maximum distance needed to connect parts of the cluster. At different distances, different clusters will form, which can be represented using a <a class="uri" href="dendrogram" title="wikilink">dendrogram</a>, which explains where the common name "hierarchical clustering" comes from: these algorithms do not provide a single partitioning of the data set, but instead provide an extensive hierarchy of clusters that merge with each other at certain distances. In a dendrogram, the y-axis marks the distance at which the clusters merge, while the objects are placed along the x-axis such that the clusters don't mix.</p>

<p>Connectivity based clustering is a whole family of methods that differ by the way distances are computed. Apart from the usual choice of <a href="distance_function" title="wikilink">distance functions</a>, the user also needs to decide on the linkage criterion (since a cluster consists of multiple objects, there are multiple candidates to compute the distance to) to use. Popular choices are known as <a href="single-linkage_clustering" title="wikilink">single-linkage clustering</a> (the minimum of object distances), <a href="complete_linkage_clustering" title="wikilink">complete linkage clustering</a> (the maximum of object distances) or <a class="uri" href="UPGMA" title="wikilink">UPGMA</a> ("Unweighted Pair Group Method with Arithmetic Mean", also known as average linkage clustering). Furthermore, hierarchical clustering can be agglomerative (starting with single elements and aggregating them into clusters) or divisive (starting with the complete data set and dividing it into partitions).</p>

<p>These methods will not produce a unique partitioning of the data set, but a hierarchy from which the user still needs to choose appropriate clusters. They are not very robust towards outliers, which will either show up as additional clusters or even cause other clusters to merge (known as "chaining phenomenon", in particular with <a href="single-linkage_clustering" title="wikilink">single-linkage clustering</a>). In the general case, the complexity is 

<math display="inline" id="Cluster_analysis:0">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ùí™</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ùí™</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(n^{3})
  </annotation>
 </semantics>
</math>

 for agglomerative clustering and 

<math display="inline" id="Cluster_analysis:1">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ùí™</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ùí™</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(2^{n-1})
  </annotation>
 </semantics>
</math>

 for divisive clustering,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> which makes them too slow for large data sets. For some special cases, optimal efficient methods (of complexity 

<math display="inline" id="Cluster_analysis:2">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ùí™</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ùí™</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(n^{2})
  </annotation>
 </semantics>
</math>

) are known: SLINK<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> for single-linkage and CLINK<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> for complete-linkage clustering. In the <a href="data_mining" title="wikilink">data mining</a> community these methods are recognized as a theoretical foundation of cluster analysis, but often considered obsolete. They did however provide inspiration for many later methods such as density based clustering.</p>

<p><a class="uri" href="File:SLINK-Gaussian-data.svg|Single-linkage">File:SLINK-Gaussian-data.svg|Single-linkage</a> on Gaussian data. At 35 clusters, the biggest cluster starts fragmenting into smaller parts, while before it was still connected to the second largest due to the single-link effect. <a class="uri" href="File:SLINK-density-data.svg|Single-linkage">File:SLINK-density-data.svg|Single-linkage</a> on density-based clusters. 20 clusters extracted, most of which contain single elements, since linkage clustering does not have a notion of "noise".</p>
<h3 id="centroid-based-clustering">Centroid-based clustering</h3>

<p>In centroid-based clustering, clusters are represented by a central vector, which may not necessarily be a member of the data set. When the number of clusters is fixed to k, <a href="k-means_clustering" title="wikilink"><em>k</em>-means clustering</a> gives a formal definition as an optimization problem: find the 

<math display="inline" id="Cluster_analysis:3">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 cluster centers and assign the objects to the nearest cluster center, such that the squared distances from the cluster are minimized.</p>

<p>The optimization problem itself is known to be <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>, and thus the common approach is to search only for approximate solutions. A particularly well known approximative method is <a href="Lloyd's_algorithm" title="wikilink">Lloyd's algorithm</a>,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> often actually referred to as "<em>k-means algorithm</em>". It does however only find a <a href="local_optimum" title="wikilink">local optimum</a>, and is commonly run multiple times with different random initializations. Variations of k-means often include such optimizations as choosing the best of multiple runs, but also restricting the centroids to members of the data set (<a class="uri" href="k-medoids" title="wikilink">k-medoids</a>), choosing <a href="median" title="wikilink">medians</a> (<a href="k-medians_clustering" title="wikilink">k-medians clustering</a>), choosing the initial centers less randomly (<a class="uri" href="K-means++" title="wikilink">K-means++</a>) or allowing a fuzzy cluster assignment (<a href="Fuzzy_clustering" title="wikilink">Fuzzy c-means</a>).</p>

<p>Most k-means-type algorithms require the <a href="Determining_the_number_of_clusters_in_a_data_set" title="wikilink">number of clusters</a> - 

<math display="inline" id="Cluster_analysis:4">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 - to be specified in advance, which is considered to be one of the biggest drawbacks of these algorithms. Furthermore, the algorithms prefer clusters of approximately similar size, as they will always assign an object to the nearest centroid. This often leads to incorrectly cut borders in between of clusters (which is not surprising, as the algorithm optimized cluster centers, not cluster borders).</p>

<p>K-means has a number of interesting theoretical properties. On the one hand, it partitions the data space into a structure known as a <a href="Voronoi_diagram" title="wikilink">Voronoi diagram</a>. On the other hand, it is conceptually close to nearest neighbor <a href="statistical_classification" title="wikilink">classification</a>, and as such is popular in <a href="machine_learning" title="wikilink">machine learning</a>. Third, it can be seen as a variation of model based classification, and Lloyd's algorithm as a variation of the <a href="Expectation-maximization_algorithm" title="wikilink">Expectation-maximization algorithm</a> for this model discussed below.</p>

<p><a class="uri" href="File:KMeans-Gaussian-data.svg|K-means">File:KMeans-Gaussian-data.svg|K-means</a> separates data into Voronoi-cells, which assumes equal-sized clusters (not adequate here) <a class="uri" href="File:KMeans-density-data.svg|K-means">File:KMeans-density-data.svg|K-means</a> cannot represent density-based clusters</p>
<h3 id="distribution-based-clustering">Distribution-based clustering</h3>

<p>The clustering model most closely related to statistics is based on <a href="Probability_distribution" title="wikilink">distribution models</a>. Clusters can then easily be defined as objects belonging most likely to the same distribution. A convenient property of this approach is that this closely resembles the way artificial data sets are generated: by sampling random objects from a distribution.</p>

<p>While the theoretical foundation of these methods is excellent, they suffer from one key problem known as <a class="uri" href="overfitting" title="wikilink">overfitting</a>, unless constraints are put on the model complexity. A more complex model will usually be able to explain the data better, which makes choosing the appropriate model complexity inherently difficult.</p>

<p>One prominent method is known as Gaussian mixture models (using the <a href="expectation-maximization_algorithm" title="wikilink">expectation-maximization algorithm</a>). Here, the data set is usually modelled with a fixed (to avoid overfitting) number of <a href="Gaussian_distribution" title="wikilink">Gaussian distributions</a> that are initialized randomly and whose parameters are iteratively optimized to fit better to the data set. This will converge to a <a href="local_optimum" title="wikilink">local optimum</a>, so multiple runs may produce different results. In order to obtain a hard clustering, objects are often then assigned to the Gaussian distribution they most likely belong to; for soft clusterings, this is not necessary.</p>

<p>Distribution-based clustering produces complex models for clusters that can capture <a href="correlation_and_dependence" title="wikilink">correlation and dependence</a> between attributes. However, these algorithms put an extra burden on the user: for many real data sets, there may be no concisely defined mathematical model (e.g. assuming Gaussian distributions is a rather strong assumption on the data).</p>

<p><a class="uri" href="File:EM-Gaussian-data.svg|On">File:EM-Gaussian-data.svg|On</a> Gaussian-distributed data, EM works well, since it uses Gaussians for modelling clusters <a class="uri" href="File:EM-density-data.svg|Density-based">File:EM-density-data.svg|Density-based</a> clusters cannot be modeled using Gaussian distributions</p>
<h3 id="density-based-clustering">Density-based clustering</h3>

<p>In density-based clustering,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> clusters are defined as areas of higher density than the remainder of the data set. Objects in these sparse areas - that are required to separate clusters - are usually considered to be noise and border points.</p>

<p>The most popular<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> density based clustering method is <a class="uri" href="DBSCAN" title="wikilink">DBSCAN</a>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> In contrast to many newer methods, it features a well-defined cluster model called "density-reachability". Similar to linkage based clustering, it is based on connecting points within certain distance thresholds. However, it only connects points that satisfy a density criterion, in the original variant defined as a minimum number of other objects within this radius. A cluster consists of all density-connected objects (which can form a cluster of an arbitrary shape, in contrast to many other methods) plus all objects that are within these objects' range. Another interesting property of DBSCAN is that its complexity is fairly low - it requires a linear number of range queries on the database - and that it will discover essentially the same results (it is <a href="deterministic_algorithm" title="wikilink">deterministic</a> for core and noise points, but not for border points) in each run, therefore there is no need to run it multiple times. <a href="OPTICS_algorithm" title="wikilink">OPTICS</a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> is a generalization of DBSCAN that removes the need to choose an appropriate value for the range parameter 

<math display="inline" id="Cluster_analysis:5">
 <semantics>
  <mi>Œµ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œµ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

, and produces a hierarchical result related to that of <a href="hierarchical_clustering" title="wikilink">linkage clustering</a>. DeLi-Clu,<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> Density-Link-Clustering combines ideas from <a href="single-linkage_clustering" title="wikilink">single-linkage clustering</a> and OPTICS, eliminating the 

<math display="inline" id="Cluster_analysis:6">
 <semantics>
  <mi>Œµ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œµ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

 parameter entirely and offering performance improvements over OPTICS by using an <a class="uri" href="R-tree" title="wikilink">R-tree</a> index.</p>

<p>The key drawback of <a class="uri" href="DBSCAN" title="wikilink">DBSCAN</a> and <a class="uri" href="OPTICS" title="wikilink">OPTICS</a> is that they expect some kind of density drop to detect cluster borders. Moreover, they cannot detect intrinsic cluster structures which are prevalent in the majority of real life data. A variation of DBSCAN, <a href="EnDBSCAN_algorithm" title="wikilink">EnDBSCAN</a>,<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> efficiently detects such kinds of structures. On data sets with, for example, overlapping Gaussian distributions - a common use case in artificial data - the cluster borders produced by these algorithms will often look arbitrary, because the cluster density decreases continuously. On a data set consisting of mixtures of Gaussians, these algorithms are nearly always outperformed by methods such as <a href="Expectation‚Äìmaximization_algorithm" title="wikilink">EM clustering</a> that are able to precisely model this kind of data.</p>

<p><a class="uri" href="Mean-shift" title="wikilink">Mean-shift</a> is a clustering approach where each object is moved to the densest area in its vicinity, based on <a href="kernel_density_estimation" title="wikilink">kernel density estimation</a>. Eventually, objects converge to local maxima of density. Similar to k-means clustering, these "density attractors" can serve as representatives for the data set, but mean-shift can detect arbitrary-shaped clusters similar to DBSCAN. Due to the expensive iterative procedure and density estimation, mean-shift is usually slower than DBSCAN or k-Means.</p>

<p><a class="uri" href="File:DBSCAN-density-data.svg|Density-based">File:DBSCAN-density-data.svg|Density-based</a> clustering with <a class="uri" href="DBSCAN" title="wikilink">DBSCAN</a>. <a class="uri" href="File:DBSCAN-Gaussian-data.svg">File:DBSCAN-Gaussian-data.svg</a>|<a class="uri" href="DBSCAN" title="wikilink">DBSCAN</a> assumes clusters of similar density, and may have problems separating nearby clusters <a class="uri" href="File:OPTICS-Gaussian-data.svg">File:OPTICS-Gaussian-data.svg</a>|<a href="OPTICS_algorithm" title="wikilink">OPTICS</a> is a DBSCAN variant that handles different densities much better</p>
<h3 id="recent-developments">Recent developments</h3>

<p>In recent years considerable effort has been put into improving the performance of existing algorithms.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> Among them are <em><a class="uri" href="CLARANS" title="wikilink">CLARANS</a></em> (Ng and Han, 1994),<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> and <em><a href="Birch_(data_clustering)" title="wikilink">BIRCH</a></em> (Zhang et al., 1996).<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> With the recent need to process larger and larger data sets (also known as <a href="big_data" title="wikilink">big data</a>), the willingness to trade semantic meaning of the generated clusters for performance has been increasing. This led to the development of pre-clustering methods such as <a href="canopy_clustering_algorithm" title="wikilink">canopy clustering</a>, which can process huge data sets efficiently, but the resulting "clusters" are merely a rough pre-partitioning of the data set to then analyze the partitions with existing slower methods such as <a href="k-means_clustering" title="wikilink">k-means clustering</a>. Various other approaches to clustering have been tried such as seed based clustering.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>

<p>For <a href="high-dimensional_space" title="wikilink">high-dimensional data</a>, many of the existing methods fail due to the <a href="curse_of_dimensionality" title="wikilink">curse of dimensionality</a>, which renders particular distance functions problematic in high-dimensional spaces. This led to new <a href="clustering_high-dimensional_data" title="wikilink">clustering algorithms for high-dimensional data</a> that focus on <a href="subspace_clustering" title="wikilink">subspace clustering</a> (where only some attributes are used, and cluster models include the relevant attributes for the cluster) and <a href="correlation_clustering" title="wikilink">correlation clustering</a> that also looks for arbitrary rotated ("correlated") subspace clusters that can be modeled by giving a <a class="uri" href="correlation" title="wikilink">correlation</a> of their attributes. Examples for such clustering algorithms are CLIQUE<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> and <a class="uri" href="SUBCLU" title="wikilink">SUBCLU</a>.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>

<p>Ideas from density-based clustering methods (in particular the <a class="uri" href="DBSCAN" title="wikilink">DBSCAN</a>/<a class="uri" href="OPTICS" title="wikilink">OPTICS</a> family of algorithms) have been adopted to subspace clustering (HiSC,<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> hierarchical subspace clustering and DiSH<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a>) and correlation clustering (HiCO,<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> hierarchical correlation clustering, 4C<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> using "correlation connectivity" and ERiC<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> exploring hierarchical density-based correlation clusters).</p>

<p>Several different clustering systems based on <a href="mutual_information" title="wikilink">mutual information</a> have been proposed. One is Marina MeilƒÉ's <em><a href="variation_of_information" title="wikilink">variation of information</a></em> metric;<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> another provides hierarchical clustering.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> Using genetic algorithms, a wide range of different fit-functions can be optimized, including mutual information.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> Also <a href="message_passing" title="wikilink">message passing</a> algorithms, a recent development in <a href="Computer_Science" title="wikilink">Computer Science</a> and <a href="Statistical_Physics" title="wikilink">Statistical Physics</a>, has led to the creation of new types of clustering algorithms.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p>
<h3 id="other-methods">Other methods</h3>
<ul>
<li><a href="Basic_sequential_algorithmic_scheme" title="wikilink">Basic sequential algorithmic scheme</a> (BSAS)</li>
</ul>
<h2 id="evaluation-and-assessment">Evaluation and assessment</h2>

<p>Evaluation of clustering results sometimes is referred to as cluster validation.</p>

<p>There have been several suggestions for a measure of similarity between two clusterings. Such a measure can be used to compare how well different data clustering algorithms perform on a set of data. These measures are usually tied to the type of criterion being considered in assessing the quality of a clustering method.</p>
<h3 id="internal-evaluation">Internal evaluation</h3>

<p>When a clustering result is evaluated based on the data that was clustered itself, this is called internal evaluation. These methods usually assign the best score to the algorithm that produces clusters with high similarity within a cluster and low similarity between clusters. One drawback of using internal criteria in cluster evaluation is that high scores on an internal measure do not necessarily result in effective information retrieval applications.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> Additionally, this evaluation is biased towards algorithms that use the same cluster model. For example, k-Means clustering naturally optimizes object distances, and a distance-based internal criterion will likely overrate the resulting clustering.</p>

<p>Therefore, the internal evaluation measures are best suited to get some insight into situations where one algorithm performs better than another, but this shall not imply that one algorithm produces more valid results than another.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> Validity as measured by such an index depends on the claim that this kind of structure exists in the data set. An algorithm designed for some kind of models has no chance if the data set contains a radically different set of models, or if the evaluation measures a radically different criterion.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> For example, k-means clustering can only find convex clusters, and many evaluation indexes assume convex clusters. On a data set with non-convex clusters neither the use of k-means, nor of an evaluation criterion that assumes convexity, is sound.</p>

<p>The following methods can be used to assess the quality of clustering algorithms based on internal criterion:</p>
<ul>
<li><strong><a href="Davies‚ÄìBouldin_index" title="wikilink">Davies‚ÄìBouldin index</a></strong></li>
</ul>
<dl>
<dd>The <a href="Davies‚ÄìBouldin_index" title="wikilink">Davies‚ÄìBouldin index</a> can be calculated by the following formula:
</dd>
<dd><math>
</math></dd>
</dl>

<p>DB = \frac {1} {n} \sum_{i=1}^{n} \max_{j\neq i}\left(\frac{\sigma_i + \sigma_j} {d(c_i,c_j)}\right) </p>
<dl>
<dd>where n is the number of clusters, 

<math display="inline" id="Cluster_analysis:7">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{x}
  </annotation>
 </semantics>
</math>

 is the <a class="uri" href="centroid" title="wikilink">centroid</a> of cluster 

<math display="inline" id="Cluster_analysis:8">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Cluster_analysis:9">
 <semantics>
  <msub>
   <mi>œÉ</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>œÉ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{x}
  </annotation>
 </semantics>
</math>

 is the average distance of all elements in cluster 

<math display="inline" id="Cluster_analysis:10">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 to centroid 

<math display="inline" id="Cluster_analysis:11">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{x}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Cluster_analysis:12">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>c</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>c</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>j</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(c_{i},c_{j})
  </annotation>
 </semantics>
</math>

 is the distance between centroids 

<math display="inline" id="Cluster_analysis:13">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Cluster_analysis:14">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{j}
  </annotation>
 </semantics>
</math>

. Since algorithms that produce clusters with low intra-cluster distances (high intra-cluster similarity) and high inter-cluster distances (low inter-cluster similarity) will have a low Davies‚ÄìBouldin index, the clustering algorithm that produces a collection of clusters with the smallest <a href="Davies‚ÄìBouldin_index" title="wikilink">Davies‚ÄìBouldin index</a> is considered the best algorithm based on this criterion.
</dd>
</dl>
<ul>
<li><strong><a href="Dunn_index" title="wikilink">Dunn index</a></strong></li>
</ul>
<dl>
<dd>The Dunn index aims to identify dense and well-separated clusters. It is defined as the ratio between the minimal inter-cluster distance to maximal intra-cluster distance. For each cluster partition, the Dunn index can be calculated by the following formula:<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a>
</dd>
<dd><math>
</math></dd>
</dl>

<p>D = \frac{\min_{1 \leq i </p>
<dl>
<dd>where <em>d</em>(<em>i</em>,<em>j</em>) represents the distance between clusters <em>i</em> and <em>j</em>, and <em>d</em> '(<em>k</em>) measures the intra-cluster distance of cluster <em>k</em>. The inter-cluster distance <em>d</em>(<em>i</em>,<em>j</em>) between two clusters may be any number of distance measures, such as the distance between the <a class="uri" href="centroids" title="wikilink">centroids</a> of the clusters. Similarly, the intra-cluster distance <em>d</em> '(<em>k</em>) may be measured in a variety ways, such as the maximal distance between any pair of elements in cluster <em>k</em>. Since internal criterion seek clusters with high intra-cluster similarity and low inter-cluster similarity, algorithms that produce clusters with high Dunn index are more desirable.
</dd>
</dl>
<ul>
<li><a href="Silhouette_(clustering)" title="wikilink">Silhouette coefficient</a></li>
</ul>
<dl>
<dd>The silhouette coefficient contrasts the average distance to elements in the same cluster with the average distance to elements in other clusters. Objects with a high silhouette value are considered well clustered, objects with a low value may be outliers. This index works well with k-means clustering, and is also used to determine the optimal number of clusters.
</dd>
</dl>
<h3 id="external-evaluation">External evaluation</h3>

<p>In external evaluation, clustering results are evaluated based on data that was not used for clustering, such as known class labels and external benchmarks. Such benchmarks consist of a set of pre-classified items, and these sets are often created by human (experts). Thus, the benchmark sets can be thought of as a <a href="gold_standard_(test)" title="wikilink">gold standard</a> for evaluation. These types of evaluation methods measure how close the clustering is to the predetermined benchmark classes. However, it has recently been discussed whether this is adequate for real data, or only on synthetic data sets with a factual ground truth, since classes can contain internal structure, the attributes present may not allow separation of clusters or the classes may contain <a href="Anomaly_detection" title="wikilink">anomalies</a>.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> Additionally, from a <a href="knowledge_discovery" title="wikilink">knowledge discovery</a> point of view, the reproduction of known knowledge may not necessarily be the intended result.<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a></p>

<p>A number of measures are adapted from variants used to evaluate classification tasks. In place of counting the number of times a class was correctly assigned to a single data point (known as <a href="true_positive" title="wikilink">true positives</a>), such <em>pair counting</em> metrics assess whether each pair of data points that is truly in the same cluster is predicted to be in the same cluster.</p>

<p>Some of the measures of quality of a cluster algorithm using external criterion include:</p>
<ul>
<li><strong><a href="Rand_measure" title="wikilink">Rand measure</a></strong> (William M. Rand 1971)<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a></li>
</ul>
<dl>
<dd>The Rand index computes how similar the clusters (returned by the clustering algorithm) are to the benchmark classifications. One can also view the Rand index as a measure of the percentage of correct decisions made by the algorithm. It can be computed using the following formula:
</dd>
<dd><math>
</math></dd>
</dl>

<p>RI = \frac {TP + TN} {TP + FP + FN + TN} </p>
<dl>
<dd>where 

<math display="inline" id="Cluster_analysis:15">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   TP
  </annotation>
 </semantics>
</math>

 is the number of true positives, 

<math display="inline" id="Cluster_analysis:16">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   TN
  </annotation>
 </semantics>
</math>

 is the number of <a href="true_negative" title="wikilink">true negatives</a>, 

<math display="inline" id="Cluster_analysis:17">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   FP
  </annotation>
 </semantics>
</math>

 is the number of <a href="false_positives" title="wikilink">false positives</a>, and 

<math display="inline" id="Cluster_analysis:18">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   FN
  </annotation>
 </semantics>
</math>

 is the number of <a href="false_negatives" title="wikilink">false negatives</a>. One issue with the <a href="Rand_index" title="wikilink">Rand index</a> is that <a href="false_positive" title="wikilink">false positives</a> and <a href="false_negative" title="wikilink">false negatives</a> are equally weighted. This may be an undesirable characteristic for some clustering applications. The F-measure addresses this concern, as does the chance-corrected <a href="adjusted_Rand_index" title="wikilink">adjusted Rand index</a>.
</dd>
</dl>
<ul>
<li><strong><a class="uri" href="F-measure" title="wikilink">F-measure</a></strong></li>
</ul>
<dl>
<dd>The F-measure can be used to balance the contribution of <a href="false_negative" title="wikilink">false negatives</a> by weighting <a href="recall_(information_retrieval)" title="wikilink">recall</a> through a parameter 

<math display="inline" id="Cluster_analysis:19">
 <semantics>
  <mrow>
   <mi>Œ≤</mi>
   <mo>‚â•</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>Œ≤</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\geq 0
  </annotation>
 </semantics>
</math>

. Let <a href="precision_(information_retrieval)" title="wikilink">precision</a> and <a href="recall_(information_retrieval)" title="wikilink">recall</a> be defined as follows:
</dd>
<dd><math>
</math></dd>
</dl>

<p>P = \frac {TP } {TP + FP } </p>

<p>

<math display="block" id="Cluster_analysis:20">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>T</mi>
     <mi>P</mi>
    </mrow>
    <mrow>
     <mrow>
      <mi>T</mi>
      <mi>P</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>F</mi>
      <mi>N</mi>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>P</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>P</ci>
      </apply>
      <apply>
       <times></times>
       <ci>F</ci>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=\frac{TP}{TP+FN}
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd>where 

<math display="inline" id="Cluster_analysis:21">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is the <a href="precision_(information_retrieval)" title="wikilink">precision</a> rate and 

<math display="inline" id="Cluster_analysis:22">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is the <a href="recall_(information_retrieval)" title="wikilink">recall</a> rate. We can calculate the F-measure by using the following formula:<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a>
</dd>
<dd><math>
</math></dd>
</dl>

<p>F_{\beta} = \frac {(\beta^2 + 1)\cdot P \cdot R } {\beta^2 \cdot P + R} </p>
<dl>
<dd>Notice that when 

<math display="inline" id="Cluster_analysis:23">
 <semantics>
  <mrow>
   <mi>Œ≤</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Œ≤</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta=0
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Cluster_analysis:24">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{0}=P
  </annotation>
 </semantics>
</math>

. In other words, <a href="recall_(information_retrieval)" title="wikilink">recall</a> has no impact on the F-measure when 

<math display="inline" id="Cluster_analysis:25">
 <semantics>
  <mrow>
   <mi>Œ≤</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Œ≤</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta=0
  </annotation>
 </semantics>
</math>

, and increasing 

<math display="inline" id="Cluster_analysis:26">
 <semantics>
  <mi>Œ≤</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ≤</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 allocates an increasing amount of weight to recall in the final F-measure.
</dd>
</dl>
<ul>
<li><strong><a href="Jaccard_coefficient" title="wikilink">Jaccard index</a></strong></li>
</ul>
<dl>
<dd>The Jaccard index is used to quantify the similarity between two datasets. The <a href="Jaccard_coefficient" title="wikilink">Jaccard index</a> takes on a value between 0 and 1. An index of 1 means that the two dataset are identical, and an index of 0 indicates that the datasets have no common elements. The Jaccard index is defined by the following formula:
</dd>
<dd><math>
</math></dd>
</dl>

<p>J(A,B) = \frac {|A \cap B| } {|A \cup B|} = \frac{TP}{TP + FP + FN} </p>
<dl>
<dd>This is simply the number of unique elements common to both sets divided by the total number of unique elements in both sets.
</dd>
</dl>
<ul>
<li><strong><a href="Fowlkes‚ÄìMallows_Index" title="wikilink">Fowlkes‚ÄìMallows index</a></strong> (E. B. Fowlkes &amp; C. L. Mallows 1983)<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a></li>
</ul>
<dl>
<dd>The Fowlkes-Mallows index computes the similarity between the clusters returned by the clustering algorithm and the benchmark classifications. The higher the value of the Fowlkes-Mallows index the more similar the clusters and the benchmark classifications are. It can be computed using the following formula:
</dd>
<dd><math>
</math></dd>
</dl>

<p>FM = \sqrt{ \frac {TP}{TP+FP} \cdot \frac{TP}{TP+FN} } </p>
<dl>
<dd>where 

<math display="inline" id="Cluster_analysis:27">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   TP
  </annotation>
 </semantics>
</math>

 is the number of <a href="true_positive" title="wikilink">true positives</a>, 

<math display="inline" id="Cluster_analysis:28">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   FP
  </annotation>
 </semantics>
</math>

 is the number of <a href="false_positives" title="wikilink">false positives</a>, and 

<math display="inline" id="Cluster_analysis:29">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   FN
  </annotation>
 </semantics>
</math>

 is the number of <a href="false_negatives" title="wikilink">false negatives</a>. The 

<math display="inline" id="Cluster_analysis:30">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   FM
  </annotation>
 </semantics>
</math>

 index is the geometric mean of the <a href="precision_(information_retrieval)" title="wikilink">precision</a> and <a href="recall_(information_retrieval)" title="wikilink">recall</a> 

<math display="inline" id="Cluster_analysis:31">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Cluster_analysis:32">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

, while the F-measure is their harmonic mean.<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> Moreover, <a href="precision_(information_retrieval)" title="wikilink">precision</a> and <a href="recall_(information_retrieval)" title="wikilink">recall</a> are also known as Wallace's indices 

<math display="inline" id="Cluster_analysis:33">
 <semantics>
  <msup>
   <mi>B</mi>
   <mi>I</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>B</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{I}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Cluster_analysis:34">
 <semantics>
  <msup>
   <mi>B</mi>
   <mrow>
    <mi>I</mi>
    <mi>I</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>B</ci>
    <apply>
     <times></times>
     <ci>I</ci>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{II}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a>
</dd>
</dl>
<ul>
<li>The <strong><a href="Mutual_Information" title="wikilink">Mutual Information</a></strong> is an <a href="information_theory" title="wikilink">information theoretic</a> measure of how much information is shared between a clustering and a ground-truth classification that can detect a non-linear similarity between two clusterings. <a href="Adjusted_mutual_information" title="wikilink">Adjusted mutual information</a> is the corrected-for-chance variant of this that has a reduced bias for varying cluster numbers.</li>
</ul>
<ul>
<li><strong><a href="Confusion_matrix" title="wikilink">Confusion matrix</a></strong></li>
</ul>
<dl>
<dd>A confusion matrix can be used to quickly visualize the results of a classification (or clustering) algorithm. It shows how different a cluster is from the gold standard cluster.
</dd>
</dl>
<h2 id="applications">Applications</h2>
<dl>
<dt><a class="uri" href="Biology" title="wikilink">Biology</a>, computational biology and <a class="uri" href="bioinformatics" title="wikilink">bioinformatics</a><br/>
;<a class="uri" href="Plant" title="wikilink">Plant</a> and <a class="uri" href="animal" title="wikilink">animal</a> <a class="uri" href="ecology" title="wikilink">ecology</a><br/>
: cluster analysis is used to describe and to make spatial and temporal comparisons of communities (assemblages) of organisms in heterogeneous environments; it is also used in <a href="Systematics" title="wikilink">plant systematics</a> to generate artificial <a href="Phylogeny" title="wikilink">phylogenies</a> or clusters of organisms (individuals) at the species, genus or higher level that share a number of attributes<br/>
;<a href="transcriptome" title="wikilink">Transcriptomics</a><br/>
: clustering is used to build groups of <a class="uri" href="genes" title="wikilink">genes</a> with related expression patterns (also known as coexpressed genes) as in <a href="HCS_clustering_algorithm" title="wikilink">HCS clustering algorithm</a> . Often such groups contain functionally related proteins, such as <a href="enzyme" title="wikilink">enzymes</a> for a specific <a href="metabolic_pathway" title="wikilink">pathway</a>, or genes that are co-regulated. High throughput experiments using <a href="expressed_sequence_tag" title="wikilink">expressed sequence tags</a> (ESTs) or <a href="DNA_microarray" title="wikilink">DNA microarrays</a> can be a powerful tool for <a href="genome_annotation" title="wikilink">genome annotation</a>, a general aspect of <a class="uri" href="genomics" title="wikilink">genomics</a>.<br/>
;<a href="Sequence_analysis" title="wikilink">Sequence analysis</a><br/>
: clustering is used to group homologous sequences into <a href="list_of_gene_families" title="wikilink">gene families</a>. This is a very important concept in bioinformatics, and <a href="evolutionary_biology" title="wikilink">evolutionary biology</a> in general. See evolution by <a href="gene_duplication" title="wikilink">gene duplication</a>.<br/>
;High-throughput <a href="genotype" title="wikilink">genotyping</a> platforms<br/>
: clustering algorithms are used to automatically assign genotypes.<br/>
;<a href="Human_genetic_clustering" title="wikilink">Human genetic clustering</a><br/>
:The similarity of genetic data is used in clustering to infer population structures.<br/>
<a class="uri" href="Medicine" title="wikilink">Medicine</a><br/>
;<a href="Medical_imaging" title="wikilink">Medical imaging</a><br/>
: On <a href="PET_scan" title="wikilink">PET scans</a>, cluster analysis can be used to differentiate between different types of <a href="tissue_(biology)" title="wikilink">tissue</a> and <a class="uri" href="blood" title="wikilink">blood</a> in a three-dimensional image. In this application, actual position does not matter, but the <a class="uri" href="voxel" title="wikilink">voxel</a> intensity is considered as a <a href="coordinate_vector" title="wikilink">vector</a>, with a dimension for each image that was taken over time. This technique allows, for example, accurate measurement of the rate a radioactive tracer is delivered to the area of interest, without a separate sampling of <a class="uri" href="arterial" title="wikilink">arterial</a> blood, an intrusive technique that is most common today.<br/>
;Analysis of antimicrobial activity<br/>
:Cluster analysis can be used to analyse patterns of antibiotic resistance, to classify antimicrobial compounds according to their mechanism of action, to classify antibiotics according to their antibacterial activity.<br/>
;IMRT segmentation<br/>
: Clustering can be used to divide a fluence map into distinct regions for conversion into deliverable fields in MLC-based Radiation Therapy.<br/>
Business and <a class="uri" href="marketing" title="wikilink">marketing</a><br/>
;<a href="Market_research" title="wikilink">Market research</a><br/>
: Cluster analysis is widely used in market research when working with multivariate data from <a href="Statistical_survey" title="wikilink">surveys</a> and test panels. Market researchers use cluster analysis to partition the general <a class="uri" href="population" title="wikilink">population</a> of <a href="consumer" title="wikilink">consumers</a> into market segments and to better understand the relationships between different groups of consumers/potential <a class="uri" href="customers" title="wikilink">customers</a>, and for use in <a href="market_segmentation" title="wikilink">market segmentation</a>, <a href="positioning_(marketing)" title="wikilink">Product positioning</a>, <a href="New_product_development" title="wikilink">New product development</a> and Selecting test markets.<br/>
;Grouping of shopping items<br/>
: Clustering can be used to group all the shopping items available on the web into a set of unique products. For example, all the items on eBay can be grouped into unique products. (eBay doesn't have the concept of a <a href="Stock-keeping_unit" title="wikilink">SKU</a>)<br/>
<a href="World_wide_web" title="wikilink">World wide web</a><br/>
;Social network analysis<br/>
: In the study of <a href="social_network" title="wikilink">social networks</a>, clustering may be used to recognize <a class="uri" href="communities" title="wikilink">communities</a> within large groups of people.<br/>
;Search result grouping<br/>
: In the process of intelligent grouping of the files and websites, clustering may be used to create a more relevant set of search results compared to normal search engines like <a class="uri" href="Google" title="wikilink">Google</a>. There are currently a number of web based clustering tools such as <a class="uri" href="Clusty" title="wikilink">Clusty</a>.<br/>
;Slippy map optimization<br/>
: <a class="uri" href="Flickr" title="wikilink">Flickr</a>'s map of photos and other map sites use clustering to reduce the number of markers on a map. This makes it both faster and reduces the amount of visual clutter.<br/>
<a href="Computer_science" title="wikilink">Computer science</a><br/>
;<a href="Software_evolution" title="wikilink">Software evolution</a><br/>
: Clustering is useful in software evolution as it helps to reduce legacy properties in code by reforming functionality that has become dispersed. It is a form of restructuring and hence is a way of direct preventative maintenance.<br/>
;<a href="Image_segmentation" title="wikilink">Image segmentation</a><br/>
: Clustering can be used to divide a <a href="Digital_data" title="wikilink">digital</a> <a class="uri" href="image" title="wikilink">image</a> into distinct regions for <a href="border_detection" title="wikilink">border detection</a> or <a href="object_recognition" title="wikilink">object recognition</a>.<br/>
;<a href="Evolutionary_algorithms" title="wikilink">Evolutionary algorithms</a><br/>
: Clustering may be used to identify different niches within the population of an evolutionary algorithm so that reproductive opportunity can be distributed more evenly amongst the evolving species or subspecies.<br/>
;<a href="Recommender_systems" title="wikilink">Recommender systems</a><br/>
: Recommender systems are designed to recommend new items based on a user's tastes. They sometimes use clustering algorithms to predict a user's preferences based on the preferences of other users in the user's cluster.<br/>
;<a href="Markov_chain_Monte_Carlo" title="wikilink">Markov chain Monte Carlo methods</a><br/>
: Clustering is often utilized to locate and characterize extrema in the target distribution.<br/>
Social science<br/>
;Crime analysis<br/>
: Cluster analysis can be used to identify areas where there are greater incidences of particular types of crime. By identifying these distinct areas or "hot spots" where a similar crime has happened over a period of time, it is possible to manage law enforcement resources more effectively.<br/>
;<a href="Educational_data_mining" title="wikilink">Educational data mining</a><br/>
:Cluster analysis is for example used to identify groups of schools or students with similar properties.<br/>
; Typologies<br/>
: From poll data, projects such as those undertaken by the Pew Research Center use cluster analysis to discern typologies of opinions, habits, and demographics that may be useful in politics and marketing.<br/>
Others<br/>
;Field robotics<br/>
: Clustering algorithms are used for robotic situational awareness to track objects and detect outliers in sensor data.<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a><br/>
;<a href="Mathematical_chemistry" title="wikilink">Mathematical chemistry</a><br/>
: To find structural similarity, etc., for example, 3000 chemical compounds were clustered in the space of 90 <a href="topological_index" title="wikilink">topological indices</a>.<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a><br/>
;<a class="uri" href="Climatology" title="wikilink">Climatology</a><br/>
: To find weather regimes or preferred sea level pressure atmospheric patterns.<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a><br/>
;Petroleum geology<br/>
: Cluster analysis is used to reconstruct missing bottom hole core data or missing log curves in order to evaluate reservoir properties.<br/>
;Physical geography<br/>
: The clustering of chemical properties in different sample locations.</dt>
</dl>
<h2 id="see-also">See also</h2>
<h3 id="specialized-types-of-cluster-analysis">Specialized types of cluster analysis</h3>
<ul>
<li><a href="Clustering_high-dimensional_data" title="wikilink">Clustering high-dimensional data</a></li>
<li><a href="Conceptual_clustering" title="wikilink">Conceptual clustering</a></li>
<li><a href="Consensus_clustering" title="wikilink">Consensus clustering</a></li>
<li><a href="Constrained_clustering" title="wikilink">Constrained clustering</a></li>
<li><a href="Data_stream_clustering" title="wikilink">Data stream clustering</a></li>
<li><a href="Sequence_clustering" title="wikilink">Sequence clustering</a></li>
<li><a href="Spectral_clustering" title="wikilink">Spectral clustering</a></li>
<li><a href="HCS_clustering_algorithm" title="wikilink">HCS clustering</a></li>
</ul>
<h3 id="techniques-used-in-cluster-analysis">Techniques used in cluster analysis</h3>
<ul>
<li><a href="Artificial_neural_network" title="wikilink">Artificial neural network</a> (ANN)</li>
<li><a href="Nearest_neighbor_search" title="wikilink">Nearest neighbor search</a></li>
<li><a href="Neighbourhood_components_analysis" title="wikilink">Neighbourhood components analysis</a></li>
<li><a href="Latent_class_model" title="wikilink">Latent class analysis</a></li>
</ul>
<h3 id="data-projection-and-preprocessing">Data projection and preprocessing</h3>
<ul>
<li><a href="Dimension_reduction" title="wikilink">Dimension reduction</a></li>
<li><a href="Principal_component_analysis" title="wikilink">Principal component analysis</a></li>
<li><a href="Multidimensional_scaling" title="wikilink">Multidimensional scaling</a></li>
</ul>
<h3 id="other">Other</h3>
<ul>
<li><a href="Cluster-weighted_modeling" title="wikilink">Cluster-weighted modeling</a></li>
<li><a href="Curse_of_dimensionality" title="wikilink">Curse of dimensionality</a></li>
<li><a href="Determining_the_number_of_clusters_in_a_data_set" title="wikilink">Determining the number of clusters in a data set</a></li>
<li><a href="Parallel_coordinates" title="wikilink">Parallel coordinates</a></li>
<li><a href="Structured_data_analysis_(statistics)" title="wikilink">Structured data analysis</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Data_mining" title="wikilink">Category:Data mining</a> <a href="Category:Cluster_analysis" title="wikilink"> </a> <a class="uri" href="Category:Geostatistics" title="wikilink">Category:Geostatistics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">‚Ü©</a></li>
<li id="fn2"><a href="#fnref2">‚Ü©</a></li>
<li id="fn3"><a href="#fnref3">‚Ü©</a></li>
<li id="fn4"><a href="#fnref4">‚Ü©</a></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">‚Ü©</a></li>
<li id="fn9"><a href="#fnref9">‚Ü©</a></li>
<li id="fn10"><a href="#fnref10">‚Ü©</a></li>
<li id="fn11"><a href="#fnref11">‚Ü©</a></li>
<li id="fn12"><a href="#fnref12">‚Ü©</a></li>
<li id="fn13"><a href="http://academic.research.microsoft.com/CSDirectory/paper_category_7.htm">Microsoft academic search: most cited data mining articles</a>: DBSCAN is on rank 24, when accessed on: 4/18/2010<a href="#fnref13">‚Ü©</a></li>
<li id="fn14"><a href="#fnref14">‚Ü©</a></li>
<li id="fn15"><a href="#fnref15">‚Ü©</a></li>
<li id="fn16"><a href="#fnref16">‚Ü©</a></li>
<li id="fn17"><a href="#fnref17">‚Ü©</a></li>
<li id="fn18"><a href="#fnref18">‚Ü©</a></li>
<li id="fn19"><a href="#fnref19">‚Ü©</a></li>
<li id="fn20">R. Ng and J. Han. "Efficient and effective clustering method for spatial data mining". In: Proceedings of the 20th VLDB Conference, pages 144-155, Santiago, Chile, 1994.<a href="#fnref20">‚Ü©</a></li>
<li id="fn21">Tian Zhang, Raghu Ramakrishnan, Miron Livny. "An Efficient Data Clustering Method for Very Large Databases." In: Proc. Int'l Conf. on Management of Data, ACM SIGMOD, pp. 103‚Äì114.<a href="#fnref21">‚Ü©</a></li>
<li id="fn22"><a href="#fnref22">‚Ü©</a></li>
<li id="fn23"><a href="#fnref23">‚Ü©</a></li>
<li id="fn24">Karin Kailing, <a href="Hans-Peter_Kriegel" title="wikilink">Hans-Peter Kriegel</a> and Peer Kr√∂ger. <em>Density-Connected Subspace Clustering for High-Dimensional Data</em>. In: <em>Proc. SIAM Int. Conf. on Data Mining (SDM'04)</em>, pp. 246-257, 2004.<a href="#fnref24">‚Ü©</a></li>
<li id="fn25"><a href="#fnref25">‚Ü©</a></li>
<li id="fn26"><a href="#fnref26">‚Ü©</a></li>
<li id="fn27"><a href="#fnref27">‚Ü©</a></li>
<li id="fn28"><a href="#fnref28">‚Ü©</a></li>
<li id="fn29"><a href="#fnref29">‚Ü©</a></li>
<li id="fn30"><a href="#fnref30">‚Ü©</a></li>
<li id="fn31"><a href="#fnref31">‚Ü©</a></li>
<li id="fn32"><a href="#fnref32">‚Ü©</a></li>
<li id="fn33"><a href="#fnref33">‚Ü©</a></li>
<li id="fn34"><a href="#fnref34">‚Ü©</a></li>
<li id="fn35"></li>
<li id="fn36"></li>
<li id="fn37"><a href="#fnref37">‚Ü©</a></li>
<li id="fn38"><a href="#fnref38">‚Ü©</a></li>
<li id="fn39"></li>
<li id="fn40"><a href="#fnref40">‚Ü©</a></li>
<li id="fn41"></li>
<li id="fn42">E. B. Fowlkes &amp; C. L. Mallows (1983), "A Method for Comparing Two Hierarchical Clusterings", Journal of the American Statistical Association 78, 553‚Äì569.<a href="#fnref42">‚Ü©</a></li>
<li id="fn43">L. Hubert et P. Arabie. Comparing partitions. J. of Classification, 2(1), 1985.<a href="#fnref43">‚Ü©</a></li>
<li id="fn44">D. L. Wallace. Comment. Journal of the American Statistical Association, 78 :569‚Äì 579, 1983.<a href="#fnref44">‚Ü©</a></li>
<li id="fn45"><a href="#fnref45">‚Ü©</a></li>
<li id="fn46"><a href="#fnref46">‚Ü©</a></li>
<li id="fn47"><a href="#fnref47">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
