   Monotone cubic interpolation      Monotone cubic interpolation  table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */     In the mathematical subfield of numerical analysis , monotone cubic interpolation is a variant of cubic interpolation that preserves monotonicity of the data set being interpolated.  Monotonicity is preserved by linear interpolation but not guaranteed by cubic interpolation .  Monotone cubic Hermite interpolation  Monotone interpolation can be accomplished using cubic Hermite spline with the tangents    m  i     subscript  m  i    m_{i}   modified to ensure the monotonicity of the resulting Hermite spline.  An algorithm is also available for monotone quintic Hermite interpolation.  Interpolant selection  There are several ways of selecting interpolating tangents for each data point. This section will outline the use of the Fritsch–Carlson method.  Let the data points be    (   x  k   ,   y  k   )      subscript  x  k    subscript  y  k     (x_{k},y_{k})   for    k  =   1  ,  …  ,  n       k   1  normal-…  n     k=1,...,n      Compute the slopes of the secant lines between successive points:       Δ  k   =     y   k  +  1    -   y  k      x   k  +  1    -   x  k          subscript  normal-Δ  k        subscript  y    k  1     subscript  y  k       subscript  x    k  1     subscript  x  k       \Delta_{k}=\frac{y_{k+1}-y_{k}}{x_{k+1}-x_{k}}      for    k  =   1  ,  …  ,   n  -  1        k   1  normal-…    n  1      k=1,\dots,n-1   .  Initialize the tangents at every data point as the average of the secants,       m  k   =     Δ   k  -  1    +   Δ  k    2        subscript  m  k        subscript  normal-Δ    k  1     subscript  normal-Δ  k    2     m_{k}=\frac{\Delta_{k-1}+\Delta_{k}}{2}      for    k  =   2  ,  …  ,   n  -  1        k   2  normal-…    n  1      k=2,\dots,n-1   ; if    Δ   k  -  1      subscript  normal-Δ    k  1     \Delta_{k-1}   and    Δ  k     subscript  normal-Δ  k    \Delta_{k}   have different sign, set     m  k   =  0       subscript  m  k   0    m_{k}=0   . These may be updated in further steps. For the endpoints, use one-sided differences:         m  1   =    Δ  1   and      m  n   =   Δ   n  -  1        formulae-sequence     subscript  m  1     subscript  normal-Δ  1   and       subscript  m  n    subscript  normal-Δ    n  1       m_{1}=\Delta_{1}\quad\text{and}\quad m_{n}=\Delta_{n-1}      For    k  =   1  ,  …  ,   n  -  1        k   1  normal-…    n  1      k=1,\dots,n-1   , if     Δ  k   =  0       subscript  normal-Δ  k   0    \Delta_{k}=0   (if two successive     y  k   =   y   k  +  1         subscript  y  k    subscript  y    k  1      y_{k}=y_{k+1}   are equal), then set      m  k   =   m   k  +  1    =  0   ,         subscript  m  k    subscript  m    k  1         0     m_{k}=m_{k+1}=0,   as the spline connecting these points must be flat to preserve monotonicity. Ignore step 4 and 5 for those   k   k   k   .  Let     α  k   =    m  k   /   Δ  k         subscript  α  k      subscript  m  k    subscript  normal-Δ  k      \alpha_{k}=m_{k}/\Delta_{k}   and     β  k   =    m   k  +  1    /   Δ  k         subscript  β  k      subscript  m    k  1     subscript  normal-Δ  k      \beta_{k}=m_{k+1}/\Delta_{k}   . If    α  k     subscript  α  k    \alpha_{k}   or    β   k  -  1      subscript  β    k  1     \beta_{k-1}   are computed to be less than zero, then the input data points are not strictly monotone, and    (   x  k   ,   y  k   )      subscript  x  k    subscript  y  k     (x_{k},y_{k})   is a local extremum. In such cases, piecewise monotone curves can still be generated by choosing     m  k   =  0       subscript  m  k   0    m_{k}=0   , although global strict monotonicity is not possible.  To prevent overshoot and ensure monotonicity, at least one of the following conditions must be met:  the function       ϕ   (  α  ,  β  )    =   α  -     (     2  α   +  β   -  3   )   2    3   (    α  +  β   -  2   )            ϕ   α  β      α     superscript        2  α   β   3   2     3      α  β   2        \phi(\alpha,\beta)=\alpha-\frac{(2\alpha+\beta-3)^{2}}{3(\alpha+\beta-2)}      must have a value greater than or equal to zero;        α  +   2  β    -  3   ≤  0          α    2  β    3   0    \alpha+2\beta-3\leq 0   ; or         2  α   +  β   -  3   ≤  0            2  α   β   3   0    2\alpha+\beta-3\leq 0   .    If monotonicity must be strict then    ϕ   (  α  ,  β  )       ϕ   α  β     \phi(\alpha,\beta)   must have a value strictly greater than zero.  One simple way to satisfy this constraint is to restrict the magnitude of vector    (   α  k   ,   β  k   )      subscript  α  k    subscript  β  k     (\alpha_{k},\beta_{k})   to a circle of radius 3. That is, if      α  k  2   +   β  k  2    >  9         superscript   subscript  α  k   2    superscript   subscript  β  k   2    9    \alpha_{k}^{2}+\beta_{k}^{2}>9   , then set     m  k   =    τ  k    α  k    Δ  k         subscript  m  k      subscript  τ  k    subscript  α  k    subscript  normal-Δ  k      m_{k}=\tau_{k}\alpha_{k}\Delta_{k}   and     m   k  +  1    =    τ  k    β  k    Δ  k         subscript  m    k  1       subscript  τ  k    subscript  β  k    subscript  normal-Δ  k      m_{k+1}=\tau_{k}\beta_{k}\Delta_{k}   where     τ  k   =   3     α  k  2   +   β  k  2           subscript  τ  k     3       superscript   subscript  α  k   2    superscript   subscript  β  k   2        \tau_{k}=\frac{3}{\sqrt{\alpha_{k}^{2}+\beta_{k}^{2}}}   .  Alternatively it is sufficient to restrict     α  k   ≤  3       subscript  α  k   3    \alpha_{k}\leq 3   and     β  k   ≤  3       subscript  β  k   3    \beta_{k}\leq 3   . To accomplish this if     α  k   >  3       subscript  α  k   3    \alpha_{k}>3   , then set     m  k   =   3  ×   Δ  k         subscript  m  k     3   subscript  normal-Δ  k      m_{k}=3\times\Delta_{k}   . Similarly for   β   β   \beta   .  Note that only one pass of the algorithm is required.  Cubic interpolation  After the preprocessing, evaluation of the interpolated spline is equivalent to cubic Hermite spline , using the data    x  k     subscript  x  k    x_{k}   ,    y  k     subscript  y  k    y_{k}   , and    m  k     subscript  m  k    m_{k}   for    k  =   1  ,  …  ,  n       k   1  normal-…  n     k=1,...,n   .  To evaluate at   x   x   x   , find the smallest value larger than   x   x   x   ,    x  upper     subscript  x  upper    x_{\text{upper}}   , and the largest value smaller than   x   x   x   ,    x  lower     subscript  x  lower    x_{\text{lower}}   , among    x  k     subscript  x  k    x_{k}   such that     x  lower   ≤  x  ≤   x  upper          subscript  x  lower   x        subscript  x  upper      x_{\text{lower}}\leq x\leq x_{\text{upper}}   . Calculate      h  =    x  upper   -   x  lower        h     subscript  x  upper    subscript  x  lower      h=x_{\text{upper}}-x_{\text{lower}}   and    t  =    x  -   x  lower    h       t      x   subscript  x  lower    h     t=\frac{x-x_{\text{lower}}}{h}   then the interpolant is        f  interpolated    (  x  )    =     y  lower    h  00    (  t  )    +   h   m  lower    h  10    (  t  )    +    y  upper    h  01    (  t  )    +   h   m  upper    h  11    (  t  )            subscript  f  interpolated   x        subscript  y  lower    subscript  h  00   t     h   subscript  m  lower    subscript  h  10   t      subscript  y  upper    subscript  h  01   t     h   subscript  m  upper    subscript  h  11   t      f_{\text{interpolated}}(x)=y_{\text{lower}}h_{00}(t)+hm_{\text{lower}}h_{10}(t%
 )+y_{\text{upper}}h_{01}(t)+hm_{\text{upper}}h_{11}(t)   where    h   i  i      subscript  h    i  i     h_{ii}   are the basis functions for the cubic Hermite spline .  Example implementation  The following JavaScript implementation takes a data set and produces a monotone cubic spline interpolant function:  /* Monotone cubic spline interpolation  Usage example:  var f = createInterpolant([0, 1, 2, 3, 4], [0, 1, 4, 9, 16]);  var message = '';  for (var x = 0; x <= 4; x += 0.5) {  var xSquared = f(x);  message += x + ' squared is about ' + xSquared + '\n';  }  alert(message);  */  var createInterpolant =  function (xs , ys) {  var i , length =  xs . length ;  // Deal with length issues  if (length !=  ys . length ) {  throw  'Need an equal count of xs and ys.' ;  }  if (length ===  0 ) {  return  function (x) {  return  0 ;  };  }  if (length ===  1 ) {  // Impl: Precomputing the result prevents problems if ys is mutated later and allows garbage collection of ys  // Impl: Unary plus properly converts values to numbers  var result =  + ys[ 0 ] ;  return  function (x) {  return result ;  };  }  // Rearrange xs and ys so that xs is sorted  var indexes = [] ;  for (i =  0 ; i < length ; i ++ ) {  indexes . push (i) ;  }  indexes . sort ( function (a , b) {  return xs[a] < xs[b] ?  - 1 : 1 ;  } ) ;  var oldXs = xs , oldYs = ys ;  // Impl: Creating new arrays also prevents problems if the input arrays are mutated later xs = [] ; ys = [] ;  // Impl: Unary plus properly converts values to numbers  for (i =  0 ; i < length ; i ++ ) {  xs . push ( + oldXs[indexes[i]]) ;  ys . push ( + oldYs[indexes[i]]) ;  }  // Get consecutive differences and slopes  var dys = [] , dxs = [] , ms = [] ;  for (i =  0 ; i < length -  1 ; i ++ ) {  var dx = xs[i +  1 ] - xs[i] , dy = ys[i +  1 ] - ys[i] ;  dxs . push (dx) ;  dys . push (dy) ;  ms . push (dy/dx) ;  }  // Get degree-1 coefficients  var c1s = [ms[ 0 ]] ;  for (i =  0 ; i <  dxs . length  -  1 ; i ++ ) {  var m = ms[i] , mNext = ms[i +  1 ] ;  if (m * mNext <=  0 ) {  c1s . push ( 0 ) ;  }  else  {  var dx = dxs[i] , dxNext = dxs[i +  1 ] , common = dx + dxNext ;  c1s . push ( 3 * common/((common + dxNext)/m + (common + dx)/mNext)) ;  }  }  c1s . push (ms[ ms . length  -  1 ]) ;  // Get degree-2 and degree-3 coefficients  var c2s = [] , c3s = [] ;  for (i =  0 ; i <  c1s . length  -  1 ; i ++ ) {  var c1 = c1s[i] , m = ms[i] , invDx =  1 /dxs[i] , common = c1 + c1s[i +  1 ] - m - m ;  c2s . push ((m - c1 - common) * invDx) ;  c3s . push (common * invDx * invDx) ;  }  // Return interpolant function  return  function (x) {  // The rightmost point in the dataset should give an exact result  var i =  xs . length  -  1 ;  if (x == xs[i]) {  return ys[i] ;  }  // Search for the interval x is in, returning the corresponding y if x is one of the original xs  var low =  0 , mid , high =  c3s . length  -  1 ;  while (low <= high) { mid =  Math . floor ( 0.5 * (low + high)) ;  var xHere = xs[mid] ;  if (xHere < x) { low = mid +  1 ;  }  else  if (xHere > x) { high = mid -  1 ;  }  else  {  return ys[mid] ;  }  } i =  Math . max ( 0 , high) ;  // Interpolate  var diff = x - xs[i] , diffSq = diff * diff ;  return ys[i] + c1s[i] * diff + c2s[i] * diffSq + c3s[i] * diff * diffSq ;  };  };  References      External links   GPLv 3 licensed C++ implementation: MonotCubicInterpolator.cpp  MonotCubicInterpolator.hpp   "  Category:Interpolation  Category:Splines  