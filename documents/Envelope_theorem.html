<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="277">Envelope theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Envelope theorem</h1>
<hr/>

<p>The Envelope Theorem is a result about the differentiability properties of the objective function of a parameterized optimization problem. As we change parameters of the objective, the Envelope Theorem shows that, in a certain sense, changes in the optimizer of the objective do not contribute to the change in the objective function.</p>
<h2 id="statement">Statement</h2>
<h2 id="envelope-theorems-for-arbitrary-choice-sets">Envelope theorems for arbitrary choice sets</h2>

<p>Let 

<math display="inline" id="Envelope_theorem:0">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 denote the choice set and let the relevant parameter be 

<math display="inline" id="Envelope_theorem:1">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>t</ci>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\in[0,1]
  </annotation>
 </semantics>
</math>


. Letting 

<math display="inline" id="Envelope_theorem:2">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>X</mi>
     <mo>×</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>X</ci>
      <interval closure="closed">
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </interval>
     </apply>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:X\times[0,1]\rightarrow R
  </annotation>
 </semantics>
</math>

 denote the parameterized objective function, the value function 

<math display="inline" id="Envelope_theorem:3">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 and the optimal choice correspondence (set-valued function) 

<math display="inline" id="Envelope_theorem:4">
 <semantics>
  <msup>
   <mi>X</mi>
   <mo>∗</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>X</ci>
    <ci>normal-∗</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{\ast}
  </annotation>
 </semantics>
</math>

 are given by:</p>

<p>

<math display="block" id="Envelope_theorem:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo movablelimits="false">sup</mo>
     <mrow>
      <mi>x</mi>
      <mo>∈</mo>
      <mi>X</mi>
     </mrow>
    </munder>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">supremum</csymbol>
      <apply>
       <in></in>
       <ci>x</ci>
       <ci>X</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>t</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(t)=\sup_{x\in X}f(x,t)
  </annotation>
 </semantics>
</math>

 (1)</p>

<p>

<math display="block" id="Envelope_theorem:6">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>X</mi>
     <mo>∗</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mi>X</mi>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>V</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <ci>normal-∗</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>x</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>t</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>V</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{\ast}(t)=\{x\in X:f(x,t)=V(t)\}
  </annotation>
 </semantics>
</math>

 (2)</p>

<p>"Envelope theorems" describe sufficient conditions for the value function 

<math display="inline" id="Envelope_theorem:7">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 to be differentiable in the parameter 

<math display="inline" id="Envelope_theorem:8">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 and describe its derivative as</p>

<p>

<math display="block" id="Envelope_theorem:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>V</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo>(</mo>
      <mi>t</mi>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>t</mi>
     </msub>
     <mrow>
      <mo>(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo>)</mo>
     </mrow>
     <mtext>for each</mtext>
     <mi>x</mi>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <msup>
      <mi>X</mi>
      <mo>∗</mo>
     </msup>
     <mrow>
      <mo>(</mo>
      <mi>t</mi>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>t</mi>
     </msub>
     <mtext>denotes partial derivative of</mtext>
     <mi>f</mi>
     <mtext>w.r.t to</mtext>
     <mi>t</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>V</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>t</ci>
       </apply>
       <interval closure="open">
        <ci>x</ci>
        <ci>t</ci>
       </interval>
       <mtext>for each</mtext>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>X</ci>
        <ci>normal-∗</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>t</ci>
     </apply>
     <mtext>denotes partial derivative of</mtext>
     <ci>f</ci>
     <mtext>w.r.t to</mtext>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{\prime}\left(t\right)=f_{t}\left(x,t\right)\text{ for each }x\in X^{\ast}%
\left(t\right).(f_{t}\text{ denotes partial derivative of }f\text{ w.r.t to }t)
  </annotation>
 </semantics>
</math>

 (3)</p>

<p>Namely, the derivative of the value function with respect to the parameter equals the partial derivative of the objective function with respect to 

<math display="inline" id="Envelope_theorem:10">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 holding the maximizer fixed at its optimal level. (The term derives from describing the graph of 

<math display="inline" id="Envelope_theorem:11">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 as the "upper envelope" of the graphs of the parameterized family of functions 

<math display="inline" id="Envelope_theorem:12">
 <semantics>
  <msub>
   <mrow>
    <mo>{</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo>(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mo>⋅</mo>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>}</mo>
   </mrow>
   <mrow>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>X</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <set>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>normal-⋅</ci>
      </interval>
     </apply>
    </set>
    <apply>
     <in></in>
     <ci>x</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{f\left(x,\cdot\right)\right\}_{x\in X}
  </annotation>
 </semantics>
</math>

.)</p>

<p>Traditional envelope theorem derivations use the first-order condition for (1), which requires that the choice set 

<math display="inline" id="Envelope_theorem:13">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 have the convex and topological structure, and the objective function 

<math display="inline" id="Envelope_theorem:14">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 be differentiable in the variable 

<math display="inline" id="Envelope_theorem:15">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. (The argument is that changes in the maximizer have only a "second-order effect" at the optimum and so can be ignored.) However, in many applications such as the analysis of incentive constraints in contract theory and game theory, nonconvex production problems, and "monotone" or "robust" comparative statics, the choice sets and objective functions generally lack the topological and convexity properties required by the traditional envelope theorems.</p>

<p><a href="Paul_Milgrom" title="wikilink">Paul Milgrom</a> and Segal (2002) observe that the traditional envelope formula holds for optimization problems with arbitrary choice sets at any differentiability point of the value function, provided that the objective function is differentiable in the parameter:</p>

<p><strong>Theorem 1:</strong> Let 

<math display="inline" id="Envelope_theorem:16">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>∈</mo>
   <mrow>
    <mo>(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>t</ci>
    <interval closure="open">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\in\left(0,1\right)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Envelope_theorem:17">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mrow>
    <msup>
     <mi>X</mi>
     <mo>∗</mo>
    </msup>
    <mrow>
     <mo>(</mo>
     <mi>t</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <ci>normal-∗</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in X^{\ast}\left(t\right)
  </annotation>
 </semantics>
</math>

. If both 

<math display="inline" id="Envelope_theorem:18">
 <semantics>
  <mrow>
   <msup>
    <mi>V</mi>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo>(</mo>
    <mi>t</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{\prime}\left(t\right)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Envelope_theorem:19">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>t</mi>
   </msub>
   <mrow>
    <mo>(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>t</ci>
    </apply>
    <interval closure="open">
     <ci>x</ci>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{t}\left(x,t\right)
  </annotation>
 </semantics>
</math>

 exist, the envelope formula (3) holds.</p>

<p><strong>Proof:</strong> (1) implies that for 

<math display="inline" id="Envelope_theorem:20">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mrow>
    <msup>
     <mi>X</mi>
     <mo>∗</mo>
    </msup>
    <mrow>
     <mo>(</mo>
     <mi>t</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <ci>normal-∗</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in X^{\ast}\left(t\right)
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Envelope_theorem:21">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mi>max</mi>
     <mrow>
      <mi>s</mi>
      <mo>∈</mo>
      <mrow>
       <mo>[</mo>
       <mn>0</mn>
       <mo>,</mo>
       <mn>1</mn>
       <mo>]</mo>
      </mrow>
     </mrow>
    </munder>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo>(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>s</mi>
        <mo>)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>V</mi>
       <mrow>
        <mo>(</mo>
        <mi>s</mi>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo>(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo>(</mo>
      <mi>t</mi>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <max></max>
       <apply>
        <in></in>
        <ci>s</ci>
        <interval closure="closed">
         <cn type="integer">0</cn>
         <cn type="integer">1</cn>
        </interval>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>f</ci>
        <interval closure="open">
         <ci>x</ci>
         <ci>s</ci>
        </interval>
       </apply>
       <apply>
        <times></times>
        <ci>V</ci>
        <ci>s</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>t</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>V</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max_{s\in\left[0,1\right]}\left[f\left(x,s\right)-V\left(s\right)\right]=f%
\left(x,t\right)-V\left(t\right)=0.
  </annotation>
 </semantics>
</math>

</p>

<p>Under the assumptions, the objective function of the displayed maximization problem is differentiable at 

<math display="inline" id="Envelope_theorem:22">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=t
  </annotation>
 </semantics>
</math>

, and the first-order condition for this maximization is exactly (3). Q.E.D.</p>

<p>While differentiability of the value function in general requires strong assumptions, in many applications weaker conditions such as absolute continuity, differentiability almost everywhere, or left- and right- differentiability, suffice. In particular, Milgrom and Segal 's (2002) Theorem 2 offers a sufficient condition for 

<math display="inline" id="Envelope_theorem:23">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 to be absolutely continuous, which means that it is differentiable almost everywhere and can be represented as an integral of its derivative:</p>

<p><strong>Theorem 2:</strong> Suppose that 

<math display="inline" id="Envelope_theorem:24">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mo>⋅</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>normal-⋅</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,\cdot)
  </annotation>
 </semantics>
</math>

 is absolutely continuous for all 

<math display="inline" id="Envelope_theorem:25">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in X
  </annotation>
 </semantics>
</math>

. Suppose also that there exists an integrable function 

<math display="inline" id="Envelope_theorem:26">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>b</ci>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b:[0,1]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Envelope_theorem:27">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Envelope_theorem:28">
 <semantics>
  <msub>
   <mi>ℝ</mi>
   <mo>+</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ℝ</ci>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}_{+}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Envelope_theorem:29">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>t</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>b</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>t</ci>
      </apply>
      <interval closure="open">
       <ci>x</ci>
       <ci>t</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>b</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |f_{t}(x,t)|\leq b(t)
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Envelope_theorem:30">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in X
  </annotation>
 </semantics>
</math>

 and almost all 

<math display="inline" id="Envelope_theorem:31">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>t</ci>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\in[0,1]
  </annotation>
 </semantics>
</math>

. Then 

<math display="inline" id="Envelope_theorem:32">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 is absolutely continuous. Suppose, in addition, that 

<math display="inline" id="Envelope_theorem:33">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mo>⋅</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>normal-⋅</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,\cdot)
  </annotation>
 </semantics>
</math>

 is differentiable for all 

<math display="inline" id="Envelope_theorem:34">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in X
  </annotation>
 </semantics>
</math>

, and that 

<math display="inline" id="Envelope_theorem:35">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>X</mi>
     <mo>∗</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mi mathvariant="normal">∅</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <ci>normal-∗</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <emptyset></emptyset>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{\ast}(t)\neq\varnothing
  </annotation>
 </semantics>
</math>

 almost everywhere on 

<math display="inline" id="Envelope_theorem:36">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0,1]
  </annotation>
 </semantics>
</math>

. Then for any selection 

<math display="inline" id="Envelope_theorem:37">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mo>∗</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <msup>
     <mi>X</mi>
     <mo>∗</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-∗</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <ci>normal-∗</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\ast}(t)\in X^{\ast}(t)
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Envelope_theorem:38">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>V</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mn>0</mn>
       <mi>t</mi>
      </msubsup>
      <mrow>
       <msub>
        <mi>f</mi>
        <mi>t</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msup>
          <mi>x</mi>
          <mo>∗</mo>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>s</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>,</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>d</mi>
       <mi>s</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>V</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <cn type="integer">0</cn>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>t</ci>
       </apply>
       <interval closure="open">
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <ci>normal-∗</ci>
         </apply>
         <ci>s</ci>
        </apply>
        <ci>s</ci>
       </interval>
       <ci>d</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(t)=V(0)+\int_{0}^{t}f_{t}(x^{\ast}(s),s)ds.
  </annotation>
 </semantics>
</math>

 (4)</p>

<p><strong>Proof:</strong> Using (1), observe that for any 

<math display="inline" id="Envelope_theorem:39">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>t</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>t</mi>
     <mi>′′</mi>
    </msup>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <ci>′′</ci>
     </apply>
    </list>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{\prime},t^{\prime\prime}\in[0,1]
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Envelope_theorem:40">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

</p>

<p>This implies that 

<math display="inline" id="Envelope_theorem:41">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 is absolutely continuous. Therefore, 

<math display="inline" id="Envelope_theorem:42">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <msub>
    <mi>t</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=t_{0}
  </annotation>
 </semantics>
</math>

 is differentiable almost everywhere, and using (3) yields (4). Q.E.D.</p>

<p>This result dispels the common misconception that nice behavior of the value function requires correspondingly nice behavior of the maximizer. Theorem 2 ensures the <a href="absolute_continuity" title="wikilink">absolute continuity</a> of the value function even though the maximizer may be discontinuous. In a similar vein, Milgrom and Segal's (2002) Theorem 3 implies that the value function must be differentiable at 

<math display="inline" id="Envelope_theorem:43">
 <semantics>
  <msub>
   <mrow>
    <mo>{</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo>(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mo>⋅</mo>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>}</mo>
   </mrow>
   <mrow>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>X</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <set>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>normal-⋅</ci>
      </interval>
     </apply>
    </set>
    <apply>
     <in></in>
     <ci>x</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{f\left(x,\cdot\right)\right\}_{x\in X}
  </annotation>
 </semantics>
</math>

 and hence satisfy the envelope formula (3) when the family 

<math display="inline" id="Envelope_theorem:44">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mn>0</mn>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mo>(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">0</cn>
    </apply>
    <interval closure="open">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{0}\in\left(0,1\right)
  </annotation>
 </semantics>
</math>

 is equi-differentiable at 

<math display="inline" id="Envelope_theorem:45">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>t</mi>
   </msub>
   <mrow>
    <mo>(</mo>
    <mrow>
     <msup>
      <mi>X</mi>
      <mo>∗</mo>
     </msup>
     <mrow>
      <mo>(</mo>
      <mi>t</mi>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <msub>
     <mi>t</mi>
     <mn>0</mn>
    </msub>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>t</ci>
    </apply>
    <interval closure="open">
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>X</ci>
       <ci>normal-∗</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{t}\left(X^{\ast}\left(t\right),t_{0}\right)
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Envelope_theorem:46">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <msub>
    <mi>t</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=t_{0}
  </annotation>
 </semantics>
</math>

 is single-valued and continuous at 

<math display="inline" id="Envelope_theorem:47">
 <semantics>
  <msub>
   <mi>t</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{0}
  </annotation>
 </semantics>
</math>

, even if the maximizer is not differentiable at 

<math display="inline" id="Envelope_theorem:48">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 (e.g., if 

<math display="inline" id="Envelope_theorem:49">
 <semantics>
  <msub>
   <mi>t</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{0}
  </annotation>
 </semantics>
</math>

 is described by a set of inequality constraints and the set of binding constraints changes at 

<math display="inline" id="Envelope_theorem:50">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo>(</mo>
    <mi>p</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi\left(p\right)
  </annotation>
 </semantics>
</math>


).</p>
<h2 id="applications-of-envelope-theorems">Applications of Envelope Theorems</h2>
<h3 id="applications-to-producer-theory">Applications to Producer Theory</h3>

<p>Theorem 1 implies <a href="Hotelling's_lemma" title="wikilink">Hotelling's lemma</a> at any differentiability point of the profit function, and Theorem 2 implies the <a href="producer_surplus" title="wikilink">producer surplus</a> formula. Formally, let 

<math display="inline" id="Envelope_theorem:51">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>⊆</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>L</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>X</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\subseteq\mathbb{R}^{L}
  </annotation>
 </semantics>
</math>

 denote the profit function of a price-taking firm with production set 

<math display="inline" id="Envelope_theorem:52">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>L</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>p</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\in\mathbb{R}^{L}
  </annotation>
 </semantics>
</math>

 facing prices 

<math display="inline" id="Envelope_theorem:53">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mo>∗</mo>
   </msup>
   <mrow>
    <mo>(</mo>
    <mi>p</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-∗</ci>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\ast}\left(p\right)
  </annotation>
 </semantics>
</math>

, and let 

<math display="block" id="Envelope_theorem:54">
 <semantics>
  <mrow>
   <mrow>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mi>max</mi>
     <mrow>
      <mi>x</mi>
      <mo>∈</mo>
      <mi>X</mi>
     </mrow>
    </munder>
    <mrow>
     <mi>p</mi>
     <mo>⋅</mo>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mo>⋅</mo>
     <msup>
      <mi>x</mi>
      <mo>∗</mo>
     </msup>
    </mrow>
    <mrow>
     <mo>(</mo>
     <mi>p</mi>
     <mo>)</mo>
    </mrow>
    <mtext>.</mtext>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>π</ci>
      <ci>p</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <max></max>
       <apply>
        <in></in>
        <ci>x</ci>
        <ci>X</ci>
       </apply>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <ci>p</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <ci>p</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>normal-∗</ci>
       </apply>
      </apply>
      <ci>p</ci>
      <mtext>.</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(p)=\max_{x\in X}p\cdot x=p\cdot x^{\ast}\left(p\right)\text{.}
  </annotation>
 </semantics>
</math>

 denote the firm's supply function, i.e.,</p>

<p>

<math display="inline" id="Envelope_theorem:55">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <msub>
    <mi>p</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=p_{i}
  </annotation>
 </semantics>
</math>


</p>

<p>Let 

<math display="inline" id="Envelope_theorem:56">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 (the price of good 

<math display="inline" id="Envelope_theorem:57">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mrow>
     <mo>-</mo>
     <mi>i</mi>
    </mrow>
   </msub>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mrow>
     <mi>L</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <apply>
      <minus></minus>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <apply>
      <minus></minus>
      <ci>L</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{-i}\in\mathbb{R}^{L-1}
  </annotation>
 </semantics>
</math>

) and fix the other goods' prices at 

<math display="inline" id="Envelope_theorem:58">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>t</mi>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>p</mi>
      <mrow>
       <mo>-</mo>
       <mi>i</mi>
      </mrow>
     </msub>
     <mo>⋅</mo>
     <msub>
      <mi>x</mi>
      <mrow>
       <mo>-</mo>
       <mi>i</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>t</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,t)=tx_{i}+p_{-i}\cdot x_{-i}
  </annotation>
 </semantics>
</math>

. Applying Theorem 1 to 

<math display="inline" id="Envelope_theorem:59">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mo>∂</mo>
      <mi>π</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>p</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>p</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>x</mi>
     <mi>i</mi>
     <mo>∗</mo>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <partialdiff></partialdiff>
       <ci>π</ci>
      </apply>
      <ci>p</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-∗</ci>
     </apply>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial\pi(p)}{\partial p_{i}}=x_{i}^{\ast}(p)
  </annotation>
 </semantics>
</math>

 yields 

<math display="inline" id="Envelope_theorem:60">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>


 (the firm's optimal supply of good 

<math display="inline" id="Envelope_theorem:61">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}
  </annotation>
 </semantics>
</math>

). Applying Theorem 2 (whose assumptions are verified when 

<math display="block" id="Envelope_theorem:62">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>π</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <msub>
        <mi>p</mi>
        <mrow>
         <mo>-</mo>
         <mi>i</mi>
        </mrow>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>π</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo>,</mo>
       <msub>
        <mi>p</mi>
        <mrow>
         <mo>-</mo>
         <mi>i</mi>
        </mrow>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mn>0</mn>
      <msub>
       <mi>p</mi>
       <mi>i</mi>
      </msub>
     </msubsup>
     <mrow>
      <msubsup>
       <mi>x</mi>
       <mi>i</mi>
       <mo>∗</mo>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo>,</mo>
       <msub>
        <mi>p</mi>
        <mrow>
         <mo>-</mo>
         <mi>i</mi>
        </mrow>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>s</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>π</ci>
      <interval closure="open">
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <apply>
         <minus></minus>
         <ci>i</ci>
        </apply>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>π</ci>
      <interval closure="open">
       <cn type="integer">0</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <apply>
         <minus></minus>
         <ci>i</ci>
        </apply>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-∗</ci>
      </apply>
      <interval closure="open">
       <ci>s</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <apply>
         <minus></minus>
         <ci>i</ci>
        </apply>
       </apply>
      </interval>
      <ci>d</ci>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(t,p_{-i})-\pi(0,p_{-i})=\int_{0}^{p_{i}}x_{i}^{\ast}(s,p_{-i})ds,
  </annotation>
 </semantics>
</math>

 is restricted to a bounded interval) yields</p>

<p>

<math display="inline" id="Envelope_theorem:63">
 <semantics>
  <mrow>
   <mrow>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo>,</mo>
     <msub>
      <mi>p</mi>
      <mrow>
       <mo>-</mo>
       <mi>i</mi>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mrow>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo>,</mo>
     <msub>
      <mi>p</mi>
      <mrow>
       <mo>-</mo>
       <mi>i</mi>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>π</ci>
     <interval closure="open">
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
       </apply>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>π</ci>
     <interval closure="open">
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(t,p_{-i})-\pi(0,p_{-i})
  </annotation>
 </semantics>
</math>

 i.e. the producer surplus 

<math display="inline" id="Envelope_theorem:64">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 can be obtained by integrating under the firm's supply curve for good 

<math display="inline" id="Envelope_theorem:65">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,t)
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="applications-to-mechanism-design-and-auction-theory">Applications to Mechanism design and Auction Theory</h3>

<p>Consider an agent whose utility function 

<math display="inline" id="Envelope_theorem:66">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mover accent="true">
    <mi>X</mi>
    <mo stretchy="false">¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\bar{X}
  </annotation>
 </semantics>
</math>

 over outcomes 

<math display="inline" id="Envelope_theorem:67">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>t</ci>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\in[0,1]
  </annotation>
 </semantics>
</math>

 depends on his type 

<math display="inline" id="Envelope_theorem:68">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>⊆</mo>
   <mover accent="true">
    <mi>X</mi>
    <mo stretchy="false">¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>X</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\subseteq\bar{X}
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Envelope_theorem:69">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(t)
  </annotation>
 </semantics>
</math>

 represent the "menu" of possible outcomes the agent could obtain in the mechanism by sending different messages. The agent's equilibrium utility 

<math display="inline" id="Envelope_theorem:70">
 <semantics>
  <mrow>
   <msup>
    <mi>X</mi>
    <mo>∗</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <ci>normal-∗</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{\ast}(t)
  </annotation>
 </semantics>
</math>

 in the mechanism is then given by (1), and the set 

<math display="inline" id="Envelope_theorem:71">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mo>∗</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <msup>
     <mi>X</mi>
     <mo>∗</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-∗</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <ci>normal-∗</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\ast}(t)\in X^{\ast}(t)
  </annotation>
 </semantics>
</math>

 of the mechanism's equilibrium outcomes is given by (2). Any selection 

<math display="inline" id="Envelope_theorem:72">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,t)
  </annotation>
 </semantics>
</math>

 is a choice rule implemented by the mechanism. Suppose that the agent's utility function 

<math display="inline" id="Envelope_theorem:73">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 is differentiable and absolutely continuous in 

<math display="inline" id="Envelope_theorem:74">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in Y
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Envelope_theorem:75">
 <semantics>
  <mrow>
   <msub>
    <mo>sup</mo>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mover accent="true">
      <mi>X</mi>
      <mo stretchy="false">¯</mo>
     </mover>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>t</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">supremum</csymbol>
     <apply>
      <in></in>
      <ci>x</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>X</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>t</ci>
      </apply>
      <interval closure="open">
       <ci>x</ci>
       <ci>t</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sup_{x\in\bar{X}}|f_{t}(x,t)|
  </annotation>
 </semantics>
</math>

, and that 

<math display="inline" id="Envelope_theorem:76">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0,1]
  </annotation>
 </semantics>
</math>

 is integrable on 

<math display="inline" id="Envelope_theorem:77">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

. Then Theorem 2 implies that the agent's equilibrium utility 

<math display="inline" id="Envelope_theorem:78">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>∗</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-∗</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\ast}
  </annotation>
 </semantics>
</math>

 in any mechanism implementing a given choice rule 

<math display="inline" id="Envelope_theorem:79">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>z</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <interval closure="open">
     <ci>y</ci>
     <ci>z</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=\left(y,z\right)
  </annotation>
 </semantics>
</math>

 must satisfy the integral condition (4).</p>

<p>The integral condition (4) is a key step in the analysis of mechanism design problems with continuous type spaces. In particular, in Myerson's (1981) analysis of single-item auctions, the outcome from the viewpoint of one bidder can be described as 

<math display="inline" id="Envelope_theorem:80">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Envelope_theorem:81">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 is the bidder's probability of receiving the object and 

<math display="inline" id="Envelope_theorem:82">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo>(</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>z</mi>
      <mo>)</mo>
     </mrow>
     <mo>,</mo>
     <mi>t</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>t</mi>
     <mi>y</mi>
    </mrow>
    <mo>-</mo>
    <mi>z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <interval closure="open">
       <ci>y</ci>
       <ci>z</ci>
      </interval>
      <ci>t</ci>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>t</ci>
      <ci>y</ci>
     </apply>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\left(\left(y,z\right),t\right)=ty-z
  </annotation>
 </semantics>
</math>

 is his expected payment, and the bidder's expected utility takes the form 

<math display="inline" id="Envelope_theorem:83">
 <semantics>
  <munder accentunder="true">
   <mi>t</mi>
   <mo>¯</mo>
  </munder>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underline{t}
  </annotation>
 </semantics>
</math>

. In this case, letting 

<math display="inline" id="Envelope_theorem:84">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 denote the bidder's lowest possible type, the integral condition (4) for the bidder's equilibrium expected utility 

<math display="block" id="Envelope_theorem:85">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>V</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>V</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <munder accentunder="true">
        <mi>t</mi>
        <mo>¯</mo>
       </munder>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mn>0</mn>
      <mi>t</mi>
     </msubsup>
     <mrow>
      <msup>
       <mi>y</mi>
       <mo>∗</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>s</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>V</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>normal-∗</ci>
      </apply>
      <ci>s</ci>
      <ci>d</ci>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(t)-V(\underline{t})=\int_{0}^{t}y^{\ast}(s)ds.
  </annotation>
 </semantics>
</math>

 takes the form</p>

<p>

<math display="inline" id="Envelope_theorem:86">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

</p>

<p>(This equation can be interpreted as the producer surplus formula for the firm whose production technology for converting numeraire 

<math display="inline" id="Envelope_theorem:87">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 into probability 

<math display="inline" id="Envelope_theorem:88">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 of winning the object is defined by the auction and which resells the object at a fixed price 

<math display="inline" id="Envelope_theorem:89">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mo>∗</mo>
   </msup>
   <mrow>
    <mo>(</mo>
    <mi>t</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <ci>normal-∗</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\ast}\left(t\right)
  </annotation>
 </semantics>
</math>

). This condition in turn yields Myerson's (1981) celebrated <a href="revenue_equivalence" title="wikilink">Revenue Equivalence Theorem</a>: the expected revenue generated in an auction in which bidders have independent private values is fully determined by the bidders' probabilities 

<math display="inline" id="Envelope_theorem:90">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 of getting the object for all types 

<math display="inline" id="Envelope_theorem:91">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <munder accentunder="true">
     <mi>t</mi>
     <mo>¯</mo>
    </munder>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(\underline{t})
  </annotation>
 </semantics>
</math>

 as well as by the expected payoffs 

<math display="inline" id="Envelope_theorem:92">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>⊆</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>K</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\subseteq\mathbb{R}^{K}
  </annotation>
 </semantics>
</math>

 of the bidders' lowest types. Finally, this condition is a key step in Myerson's (1981) of optimal auctions.</p>

<p>For other applications of the envelope theorem to mechanism design see Mirrlees (1971), Holmstrom (1979), Laffont and Maskin (1980), Riley and Samuelson (1981), Fudenberg and Tirole (1991), and Williams (1999). While these authors derived and exploited the envelope theorem by restricting attention to (piecewise) continuously differentiable choice rules or even narrower classes, it may sometimes be optimal to implement a choice rule that is not piecewise continuously differentiable. (One example is the class of trading problems with linear utility described in chapter 6.5 of Myerson (1991).) Note that the integral condition (3) still holds in this setting and implies such important results as Holmstrom's lemma (Holmstrom, 1979), Myerson's lemma (Myerson, 1981), the revenue equivalence theorem (for auctions), the Green-Laffont-Holmstrom theorem (Green and Laffont, 1979; Holmstrom, 1979), the Myerson-Satterthwaite inefficiency theorem (Myerson and Satterthwaite,1983), the Jehiel-Moldovanu impossibility theorems (Jehiel and Moldovanu, 2001), the McAfee-McMillan weak-cartels theorem (McAfee and McMillan, 1992), and Weber's martingale theorem (Weber, 1983), etc. The details of these applications are provided in Chapter 3 of Milgrom (2004), who offers an elegant and unifying framework in auction and mechanism design analysis mainly based on the envelope theorem and other familiar techniques and concepts in demand theory.</p>
<h3 id="applications-to-multidimensional-parameter-spaces">Applications to Multidimensional Parameter Spaces</h3>

<p>For a multidimensional parameter space 

<math display="inline" id="Envelope_theorem:93">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

, Theorem 1 can be applied to partial and directional derivatives of the value function. If both the objective function 

<math display="inline" id="Envelope_theorem:94">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 and the value function 

<math display="inline" id="Envelope_theorem:95">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 are (totally) differentiable in 

<math display="block" id="Envelope_theorem:96">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∇</mo>
     <mi>V</mi>
    </mrow>
    <mrow>
     <mo>(</mo>
     <mi>t</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mo>∇</mo>
      <mi>t</mi>
     </msub>
     <mi>f</mi>
    </mrow>
    <mrow>
     <mo>(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-∇</ci>
      <ci>V</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-∇</ci>
       <ci>t</ci>
      </apply>
      <ci>f</ci>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>t</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla V\left(t\right)=\nabla_{t}f\left(x,t\right)
  </annotation>
 </semantics>
</math>

, Theorem 1 implies the envelope formula for their gradients

<math display="inline" id="Envelope_theorem:97">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mrow>
    <msup>
     <mi>X</mi>
     <mo>∗</mo>
    </msup>
    <mrow>
     <mo>(</mo>
     <mi>t</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <ci>normal-∗</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in X^{\ast}\left(t\right)
  </annotation>
 </semantics>
</math>

 for each 

<math display="inline" id="Envelope_theorem:98">
 <semantics>
  <msub>
   <mi>t</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{0}
  </annotation>
 </semantics>
</math>

. While total differentiability of the value function may not be easy to ensure, Theorem 2 can be still applied along any smooth path connecting two parameter values 

<math display="inline" id="Envelope_theorem:99">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Envelope_theorem:100">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mo>⋅</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>normal-⋅</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,\cdot)
  </annotation>
 </semantics>
</math>

. Namely, suppose that functions 

<math display="inline" id="Envelope_theorem:101">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in X
  </annotation>
 </semantics>
</math>

 are differentiable for all 

<math display="inline" id="Envelope_theorem:102">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <msub>
       <mo>∇</mo>
       <mi>t</mi>
      </msub>
      <mi>f</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-∇</ci>
        <ci>t</ci>
       </apply>
       <ci>f</ci>
      </apply>
      <interval closure="open">
       <ci>x</ci>
       <ci>t</ci>
      </interval>
     </apply>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\nabla_{t}f(x,t)|\leq B
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Envelope_theorem:103">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>X</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in X,
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Envelope_theorem:104">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>∈</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>t</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\in T
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Envelope_theorem:105">
 <semantics>
  <msub>
   <mi>t</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{0}
  </annotation>
 </semantics>
</math>

. A smooth path from 

<math display="inline" id="Envelope_theorem:106">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Envelope_theorem:107">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo>[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo>]</mo>
    </mrow>
    <mo>→</mo>
    <mi>T</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>γ</ci>
    <apply>
     <ci>normal-→</ci>
     <interval closure="closed">
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </interval>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma:\left[0,1\right]\rightarrow T
  </annotation>
 </semantics>
</math>

 is described by a differentiable mapping 

<math display="inline" id="Envelope_theorem:108">
 <semantics>
  <mrow>
   <mrow>
    <mi>γ</mi>
    <mrow>
     <mo>(</mo>
     <mn>0</mn>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>t</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>γ</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma\left(0\right)=t_{0}
  </annotation>
 </semantics>
</math>

 with a bounded derivative, such that 

<math display="inline" id="Envelope_theorem:109">
 <semantics>
  <mrow>
   <mrow>
    <mi>γ</mi>
    <mrow>
     <mo>(</mo>
     <mn>1</mn>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>γ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma\left(1\right)=t
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Envelope_theorem:110">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>∇</mo>
     <mi>t</mi>
    </msub>
    <mi>f</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>x</mi>
      <mo>∗</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-∇</ci>
      <ci>t</ci>
     </apply>
     <ci>f</ci>
    </apply>
    <interval closure="open">
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>normal-∗</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla_{t}f(x^{\ast}(t),t)
  </annotation>
 </semantics>
</math>

. Theorem 2 implies that for any such smooth path, the change of the value function can be expressed as the <a href="line_integral" title="wikilink">path integral</a> of the partial gradient 

<math display="block" id="Envelope_theorem:111">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>V</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>V</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi>γ</mi>
     </msub>
     <mrow>
      <mrow>
       <mrow>
        <mrow>
         <msub>
          <mo>∇</mo>
          <mi>t</mi>
         </msub>
         <mi>f</mi>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msup>
           <mi>x</mi>
           <mo>∗</mo>
          </msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>s</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>,</mo>
         <mi>s</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>⋅</mo>
       <mi>d</mi>
      </mrow>
      <mi>s</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>V</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>γ</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>normal-∇</ci>
          <ci>t</ci>
         </apply>
         <ci>f</ci>
        </apply>
        <interval closure="open">
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>x</ci>
           <ci>normal-∗</ci>
          </apply>
          <ci>s</ci>
         </apply>
         <ci>s</ci>
        </interval>
       </apply>
       <ci>d</ci>
      </apply>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(t)-V(t_{0})=\int_{\gamma}\nabla_{t}f(x^{\ast}(s),s)\cdot ds.
  </annotation>
 </semantics>
</math>

 of the objective function along the path:</p>

<p>

<math display="inline" id="Envelope_theorem:112">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <msub>
    <mi>t</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=t_{0}
  </annotation>
 </semantics>
</math>

</p>

<p>In particular, for 

<math display="inline" id="Envelope_theorem:113">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

, this establishes that cyclic path integrals along any smooth path 

<math display="block" id="Envelope_theorem:114">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mrow>
      <mrow>
       <mrow>
        <msub>
         <mo>∇</mo>
         <mi>t</mi>
        </msub>
        <mi>f</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msup>
          <mi>x</mi>
          <mo>∗</mo>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>s</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>,</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⋅</mo>
      <mi>d</mi>
     </mrow>
     <mi>s</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <int></int>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>normal-∇</ci>
          <ci>t</ci>
         </apply>
         <ci>f</ci>
        </apply>
        <interval closure="open">
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>x</ci>
           <ci>normal-∗</ci>
          </apply>
          <ci>s</ci>
         </apply>
         <ci>s</ci>
        </interval>
       </apply>
       <ci>d</ci>
      </apply>
      <ci>s</ci>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int\nabla_{t}f(x^{\ast}(s),s)\cdot ds=0.
  </annotation>
 </semantics>
</math>

 must be zero:</p>

<p>

<math display="inline" id="Envelope_theorem:115">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>∗</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-∗</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\ast}
  </annotation>
 </semantics>
</math>

</p>

<p>This "integrability condition" plays an important role in mechanism design with multidimensional types, constraining what kind of choice rules 

<math display="inline" id="Envelope_theorem:116">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>⊆</mo>
   <mover accent="true">
    <mi>X</mi>
    <mo stretchy="false">¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>X</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\subseteq\bar{X}
  </annotation>
 </semantics>
</math>

 can be sustained by mechanism-induced menus 

<math display="inline" id="Envelope_theorem:117">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>X</mi>
   <mo>⊆</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>L</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <ci>x</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>L</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in X\subseteq\mathbb{R}^{L}
  </annotation>
 </semantics>
</math>

. In application to producer theory, with 

<math display="inline" id="Envelope_theorem:118">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>L</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>t</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\in\mathbb{R}^{L}
  </annotation>
 </semantics>
</math>

 being the firm's production vector and 

<math display="inline" id="Envelope_theorem:119">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo>(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>t</mi>
    <mo>⋅</mo>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>t</ci>
     </interval>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>t</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\left(x,t\right)=t\cdot x
  </annotation>
 </semantics>
</math>

 being the price vector, 

<math display="inline" id="Envelope_theorem:120">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>∗</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-∗</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\ast}
  </annotation>
 </semantics>
</math>

, and the integrability condition says that any rationalizable supply function 

<math display="block" id="Envelope_theorem:121">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mrow>
      <mrow>
       <msup>
        <mi>x</mi>
        <mo>∗</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⋅</mo>
      <mi>d</mi>
     </mrow>
     <mi>s</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <int></int>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <ci>normal-∗</ci>
        </apply>
        <ci>s</ci>
       </apply>
       <ci>d</ci>
      </apply>
      <ci>s</ci>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int x^{\ast}(s)\cdot ds=0.
  </annotation>
 </semantics>
</math>

 must satisfy</p>

<p>

<math display="inline" id="Envelope_theorem:122">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>∗</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-∗</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\ast}
  </annotation>
 </semantics>
</math>

</p>

<p>When 

<math display="inline" id="Envelope_theorem:123">
 <semantics>
  <msubsup>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo>∂</mo>
       <msubsup>
        <mi>x</mi>
        <mi>i</mi>
        <mo>∗</mo>
       </msubsup>
      </mrow>
      <mrow>
       <mo>(</mo>
       <mi>t</mi>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>/</mo>
     <mrow>
      <mo>∂</mo>
      <msub>
       <mi>t</mi>
       <mi>j</mi>
      </msub>
     </mrow>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mrow>
    <mrow>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>L</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
         <ci>normal-∗</ci>
        </apply>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <list>
       <ci>i</ci>
       <ci>j</ci>
      </list>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\partial x_{i}^{\ast}\left(t\right)/\partial t_{j}\right)_{i,j=1}^{L}
  </annotation>
 </semantics>
</math>

 is continuously differentiable, this integrability condition is equivalent to the symmetry of the <a href="substitution_matrix" title="wikilink">substitution matrix</a> 

<math display="inline" id="Envelope_theorem:124">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mrow>
    <mo>(</mo>
    <mi>t</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\left(t\right)
  </annotation>
 </semantics>
</math>


. (In <a href="consumer_theory" title="wikilink">consumer theory</a>, the same argument applied to the expenditure minimization problem yields symmetry of the <a href="Slutsky_matrix" title="wikilink">Slutsky matrix</a>.)</p>
<h3 id="applications-to-parameterized-constraints">Applications to Parameterized Constraints</h3>

<p>Suppose now that the feasible set 

<math display="block" id="Envelope_theorem:125">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo movablelimits="false">sup</mo>
     <mrow>
      <mi>x</mi>
      <mo>∈</mo>
      <mrow>
       <mi>X</mi>
       <mrow>
        <mo>(</mo>
        <mi>t</mi>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
    </munder>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">supremum</csymbol>
      <apply>
       <in></in>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>X</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>t</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(t)=\sup_{x\in X\left(t\right)}f(x,t)
  </annotation>
 </semantics>
</math>

 depends on the parameter, i.e.,</p>

<p>

<math display="block" id="Envelope_theorem:126">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>X</mi>
     <mo>∗</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>x</mi>
      <mo>∈</mo>
      <mrow>
       <mi>X</mi>
       <mrow>
        <mo>(</mo>
        <mi>t</mi>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>:</mo>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mrow>
       <mi>V</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mtext>,</mtext>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <ci>normal-∗</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <in></in>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>X</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <ci>f</ci>
        <interval closure="open">
         <ci>x</ci>
         <ci>t</ci>
        </interval>
       </apply>
       <apply>
        <times></times>
        <ci>V</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <mtext>,</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{\ast}(t)=\{x\in X\left(t\right):f(x,t)=V(t)\}\text{, }
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Envelope_theorem:127">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mrow>
     <mo>(</mo>
     <mi>t</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mi>X</mi>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo>(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>t</mi>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>≥</mo>
     <mn>0</mn>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>x</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <geq></geq>
      <apply>
       <times></times>
       <ci>g</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>t</ci>
       </interval>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\left(t\right)=\left\{x\in X:g\left(x,t\right)\geq 0\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Envelope_theorem:128">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mi>X</mi>
      <mo>×</mo>
      <mrow>
       <mo>[</mo>
       <mn>0</mn>
       <mo>,</mo>
       <mn>1</mn>
       <mo>]</mo>
      </mrow>
     </mrow>
     <mo>→</mo>
     <msup>
      <mi>ℝ</mi>
      <mi>K</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>g</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>X</ci>
      <interval closure="closed">
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </interval>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>K</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g:X\times\left[0,1\right]\rightarrow\mathbb{R}^{K}.
  </annotation>
 </semantics>
</math>

 for some 

<math display="inline" id="Envelope_theorem:129">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

</p>

<p>Suppose that 

<math display="inline" id="Envelope_theorem:130">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is a convex set, 

<math display="inline" id="Envelope_theorem:131">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Envelope_theorem:132">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 are concave in 

<math display="inline" id="Envelope_theorem:133">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <ci>normal-^</ci>
     <ci>x</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{x}\in X
  </annotation>
 </semantics>
</math>

, and there exists 

<math display="inline" id="Envelope_theorem:134">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo>(</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mo>,</mo>
     <mi>t</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>g</ci>
     <interval closure="open">
      <apply>
       <ci>normal-^</ci>
       <ci>x</ci>
      </apply>
      <ci>t</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\left(\hat{x},t\right)>0
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Envelope_theorem:135">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>∈</mo>
   <mrow>
    <mo>[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>t</ci>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\in\left[0,1\right]
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Envelope_theorem:136">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo>(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mi>y</mi>
      <mo>⋅</mo>
      <mi>g</mi>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>t</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <ci>y</ci>
       <ci>g</ci>
      </apply>
      <interval closure="open">
       <ci>x</ci>
       <ci>t</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\left(x,y,t\right)=f(x,t)+y\cdot g\left(x,t\right)
  </annotation>
 </semantics>
</math>

. Under these assumptions, it is well known (see, e.g., Luenberger (1969) and Rockafellar(1970)) that the above constrained optimization program can be represented as a saddle-point problem for the Lagrangian 

<math display="inline" id="Envelope_theorem:137">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>∈</mo>
   <msubsup>
    <mi>ℝ</mi>
    <mo>+</mo>
    <mi>K</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℝ</ci>
      <plus></plus>
     </apply>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in\mathbb{R}_{+}^{K}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Envelope_theorem:138">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is the vector of <a href="Lagrange_multipliers" title="wikilink">Lagrange multipliers</a> chosen by the adversary to minimize the Lagrangian. This allows the application of Milgrom and Segal's (2002, Theorem 4) envelope theorem for saddle-point problems, under the additional assumptions that 

<math display="inline" id="Envelope_theorem:139">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is a compact set in a normed linear space, 

<math display="inline" id="Envelope_theorem:140">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Envelope_theorem:141">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 are continuous in 

<math display="inline" id="Envelope_theorem:142">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{t}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Envelope_theorem:143">
 <semantics>
  <msub>
   <mi>g</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{t}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Envelope_theorem:144">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>t</mi>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>t</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(x,t\right)
  </annotation>
 </semantics>
</math>

 are continuous in 

<math display="inline" id="Envelope_theorem:145">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mo>∗</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msup>
     <mi>y</mi>
     <mo>∗</mo>
    </msup>
    <mrow>
     <mo>(</mo>
     <mi>t</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-∗</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>normal-∗</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(x^{\ast}(t),y^{\ast}\left(t\right)\right)
  </annotation>
 </semantics>
</math>

. In particular, letting 

<math display="inline" id="Envelope_theorem:146">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 denote the Lagrangian's saddle point for parameter value 

<math display="inline" id="Envelope_theorem:147">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

, the theorem implies that 

<math display="block" id="Envelope_theorem:148">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>V</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mn>0</mn>
       <mi>t</mi>
      </msubsup>
      <mrow>
       <msub>
        <mi>L</mi>
        <mi>t</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msup>
          <mi>x</mi>
          <mo>∗</mo>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>s</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>,</mo>
        <mrow>
         <msup>
          <mi>y</mi>
          <mo>∗</mo>
         </msup>
         <mrow>
          <mo>(</mo>
          <mi>s</mi>
          <mo>)</mo>
         </mrow>
        </mrow>
        <mo>,</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>d</mi>
       <mi>s</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>V</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <cn type="integer">0</cn>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>t</ci>
       </apply>
       <vector>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <ci>normal-∗</ci>
         </apply>
         <ci>s</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>y</ci>
          <ci>normal-∗</ci>
         </apply>
         <ci>s</ci>
        </apply>
        <ci>s</ci>
       </vector>
       <ci>d</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(t)=V(0)+\int_{0}^{t}L_{t}(x^{\ast}(s),y^{\ast}\left(s\right),s)ds.
  </annotation>
 </semantics>
</math>

 is absolutely continuous and satisfies</p>

<p>

<math display="inline" id="Envelope_theorem:149">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo>(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\left(x,t\right)
  </annotation>
 </semantics>
</math>

</p>

<p>For the special case in which 

<math display="inline" id="Envelope_theorem:150">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 is independent of 

<math display="inline" id="Envelope_theorem:151">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>K</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K=1
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Envelope_theorem:152">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo>(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo>(</mo>
      <mi>x</mi>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>t</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>x</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\left(x,t\right)=h\left(x\right)+t
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Envelope_theorem:153">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>V</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>L</mi>
     <mi>t</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>x</mi>
       <mo>∗</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msup>
       <mi>y</mi>
       <mo>∗</mo>
      </msup>
      <mrow>
       <mo>(</mo>
       <mi>t</mi>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>y</mi>
     <mo>∗</mo>
    </msup>
    <mrow>
     <mo>(</mo>
     <mi>t</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>V</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <ci>t</ci>
      </apply>
      <vector>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <ci>normal-∗</ci>
        </apply>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>y</ci>
         <ci>normal-∗</ci>
        </apply>
        <ci>t</ci>
       </apply>
       <ci>t</ci>
      </vector>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>normal-∗</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{\prime}(t)=L_{t}(x^{\ast}(t),y^{\ast}\left(t\right),t)=y^{\ast}\left(t\right)
  </annotation>
 </semantics>
</math>

, the formula implies that 

<math display="inline" id="Envelope_theorem:154">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 for a.e. 

<math display="inline" id="Envelope_theorem:155">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mo>∗</mo>
   </msup>
   <mrow>
    <mo>(</mo>
    <mi>t</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <ci>normal-∗</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\ast}\left(t\right)
  </annotation>
 </semantics>
</math>

. That is, the Lagrange multiplier <span class="LaTeX">$y^{\ast
}\left( t\right)$</span> on the constraint is its "<a href="shadow_price" title="wikilink">shadow price</a>" in the optimization program (see Rockafellar, 1970).</p>
<h3 id="other-applications">Other Applications</h3>

<p>Milgrom and Segal (2002) demonstrate that the generalized version of the envelope theorems can also be applied to convex programming, continuous optimization problems, saddle-point problems, and optimal stopping problems.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Maximum_theorem" title="wikilink">Maximum theorem</a></li>
<li><a href="Danskin's_theorem" title="wikilink">Danskin's theorem</a></li>
<li><a href="Hotelling's_lemma" title="wikilink">Hotelling's lemma</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Underlying_principles_of_microeconomic_behavior" title="wikilink">Category:Underlying principles of microeconomic behavior</a> <a href="Category:Calculus_of_variations" title="wikilink">Category:Calculus of variations</a> <a href="Category:Economics_theorems" title="wikilink">Category:Economics theorems</a> <a href="Category:Theorems_in_analysis" title="wikilink">Category:Theorems in analysis</a></p>
</body>
</html>
