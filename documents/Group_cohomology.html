<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1439">Group cohomology</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Group cohomology</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <strong>group cohomology</strong> is a set of mathematical tools used to study <a href="group_(mathematics)" title="wikilink">groups</a> using <a href="cohomology_theory" title="wikilink">cohomology theory</a>, a technique from <a href="algebraic_topology" title="wikilink">algebraic topology</a>. Analogous to <a href="group_representation" title="wikilink">group representations</a>, group cohomology looks at the <a href="group_action" title="wikilink">group actions</a> of a group <em>G</em> in an associated <a href="G-module" title="wikilink"><em>G</em>-module</a> <em>M</em> to elucidate the properties of the group. By treating the <em>G</em>-module as a kind of topological space with elements of 

<math display="inline" id="Group_cohomology:0">
 <semantics>
  <msup>
   <mi>G</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>G</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{n}
  </annotation>
 </semantics>
</math>

 representing <em>n</em>-<a href="Simplex" title="wikilink">simplices</a>, topological properties of the space may be computed, such as the set of cohomology groups 

<math display="inline" id="Group_cohomology:1">
 <semantics>
  <mrow>
   <msup>
    <mi>H</mi>
    <mi>n</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo>,</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>H</ci>
     <ci>n</ci>
    </apply>
    <interval closure="open">
     <ci>G</ci>
     <ci>M</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{n}(G,M)
  </annotation>
 </semantics>
</math>

. The cohomology groups in turn provide insight into the structure of the group <em>G</em> and <em>G</em>-module <em>M</em> themselves. Group cohomology plays a role in the investigation of fixed points of a group action in a module or space and the <a href="quotient_module" title="wikilink">quotient module</a> or space with respect to a group action. Group cohomology is used in the fields of <a href="abstract_algebra" title="wikilink">abstract algebra</a>, <a href="homological_algebra" title="wikilink">homological algebra</a>, <a href="algebraic_topology" title="wikilink">algebraic topology</a> and <a href="algebraic_number_theory" title="wikilink">algebraic number theory</a>, as well as in applications to <a href="group_theory" title="wikilink">group theory</a> proper. As in algebraic topology, there is a dual theory called <a href="Group_cohomology#Group_homology" title="wikilink"><em>group homology</em></a>. The techniques of group cohomology can also be extended to the case that instead of a <em>G</em>-module, <em>G</em> acts on a nonabelian <em>G</em>-group; in effect, a generalization of a module to <a href="Non-Abelian_group" title="wikilink">non-Abelian</a> coefficients.</p>

<p>These algebraic ideas are closely related to topological ideas. The group cohomology of a group <em>G</em> can be thought of as, and is motivated by, the <a href="singular_cohomology" title="wikilink">singular cohomology</a> of a suitable space having <em>G</em> as its <a href="fundamental_group" title="wikilink">fundamental group</a>, namely the corresponding <a href="Eilenberg–MacLane_space" title="wikilink">Eilenberg–MacLane space</a>. Thus, the group cohomology of <strong>Z</strong> can be thought of as the singular cohomology of the circle <strong>S</strong><sup>1</sup>, and similarly for <strong>Z</strong>/2<strong>Z</strong> and <strong>P</strong><sup>∞</sup>(<strong>R</strong>).</p>

<p>A great deal is known about the cohomology of groups, including interpretations of low-dimensional cohomology, functoriality, and how to change groups. The subject of group cohomology began in the 1920s, matured in the late 1940s, and continues as an area of active research today.</p>
<h2 id="motivation">Motivation</h2>

<p>A general paradigm in <a href="group_theory" title="wikilink">group theory</a> is that a <a href="group_(mathematics)" title="wikilink">group</a> <em>G</em> should be studied via its <a href="group_representation" title="wikilink">group representations</a>. A slight generalization of those representations are the <a href="G-module" title="wikilink"><em>G</em>-modules</a>: a <em>G</em>-module is an <a href="abelian_group" title="wikilink">abelian group</a> <em>M</em> together with a <a href="group_action" title="wikilink">group action</a> of <em>G</em> on <em>M</em>, with every element of <em>G</em> acting as an <a class="uri" href="automorphism" title="wikilink">automorphism</a> of <em>M</em>. We will write <em>G</em> multiplicatively and <em>M</em> additively.</p>

<p>Given such a <em>G</em>-module <em>M</em>, it is natural to consider the submodule of <a href="G-invariant" title="wikilink"><em>G</em>-invariant</a> elements:</p>

<p>

<math display="block" id="Group_cohomology:2">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>M</mi>
     <mi>G</mi>
    </msup>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>x</mi>
      <mo>∈</mo>
      <mpadded width="+5pt">
       <mi>M</mi>
      </mpadded>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">|</mo>
     <mrow>
      <mrow>
       <mrow>
        <mo>∀</mo>
        <mi>g</mi>
       </mrow>
       <mo>∈</mo>
       <mi>G</mi>
      </mrow>
      <mo rspace="7.5pt">:</mo>
      <mrow>
       <mrow>
        <mi>g</mi>
        <mi>x</mi>
       </mrow>
       <mo>=</mo>
       <mi>x</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>M</ci>
     <ci>G</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>x</ci>
      <ci>M</ci>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <in></in>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <ci>g</ci>
       </apply>
       <ci>G</ci>
      </apply>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <ci>g</ci>
        <ci>x</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M^{G}=\{x\in M\ |\ \forall g\in G:\ gx=x\}.
  </annotation>
 </semantics>
</math>

</p>

<p>Now, if <em>N</em> is a submodule of <em>M</em> (i.e. a subgroup of <em>M</em> mapped to itself by the action of <em>G</em>), it isn't in general true that the invariants in <em>M/N</em> are found as the quotient of the invariants in <em>M</em> by those in <em>N</em>: being invariant 'modulo <em>N</em> ' is broader. The first group cohomology <em>H</em><sup>1</sup>(<em>G</em>,<em>N</em>) precisely measures the difference. The group cohomology functors <em>H*</em> in general measure the extent to which taking invariants doesn't respect <a href="exact_sequence" title="wikilink">exact sequences</a>. This is expressed by a <a href="long_exact_sequence" title="wikilink">long exact sequence</a>.</p>
<h2 id="formal-constructions">Formal constructions</h2>

<p>In this article, <em>G</em> is a finite group. The collection of all <em>G</em>-modules is a <a href="category_theory" title="wikilink">category</a> (the morphisms are group homomorphisms <em>f</em> with the property <em>f</em>(<em>gx</em>) = <em>g</em>(<em>f</em>(<em>x</em>)) for all <em>g</em> in <em>G</em> and <em>x</em> in <em>M</em>). This category of <em>G</em>-modules is an abelian category with enough injectives (since it is isomorphic to the category of all <a href="module_(mathematics)" title="wikilink">modules</a> over the <a href="group_ring" title="wikilink">group ring</a> <strong>Z</strong>[<em>G</em>]).</p>

<p>Sending each module <em>M</em> to the group of invariants <em>M<sup>G</sup></em> yields a <a class="uri" href="functor" title="wikilink">functor</a> from this category to the category <strong>Ab</strong> of abelian groups. This functor is <a href="left_exact_functor" title="wikilink">left exact</a> but not necessarily right exact. We may therefore form its right <a href="derived_functor" title="wikilink">derived functors</a>; their values are abelian groups and they are denoted by <em>H<sup>n</sup></em>(<em>G</em>, <em>M</em>), "the <em>n</em>-th cohomology group of <em>G</em> with coefficients in <em>M</em>". <em>H</em><sup>0</sup>(<em>G</em>, <em>M</em>) is identified with <em>M<sup>G</sup></em>.</p>
<h3 id="long-exact-sequence-of-cohomology">Long exact sequence of cohomology</h3>

<p>In practice, one often computes the cohomology groups using the following fact: if</p>

<p>

<math display="block" id="Group_cohomology:3">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mi>L</mi>
   <mo>→</mo>
   <mi>M</mi>
   <mo>→</mo>
   <mi>N</mi>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <ci>L</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>M</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>N</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\to L\to M\to N\to 0
  </annotation>
 </semantics>
</math>

</p>

<p>is a <a href="short_exact_sequence" title="wikilink">short exact sequence</a> of <em>G</em>-modules, then a long exact sequence</p>

<p>

<math display="block" id="Group_cohomology:4">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <msup>
    <mi>L</mi>
    <mi>G</mi>
   </msup>
   <mo>→</mo>
   <msup>
    <mi>M</mi>
    <mi>G</mi>
   </msup>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>N</mi>
     <mi>G</mi>
    </msup>
    <mover accent="true">
     <mo>→</mo>
     <msup>
      <mi>δ</mi>
      <mn>0</mn>
     </msup>
    </mover>
    <msup>
     <mi>H</mi>
     <mn>1</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo>,</mo>
     <mi>L</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>H</mi>
     <mn>1</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo>,</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>H</mi>
     <mn>1</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo>,</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mover accent="true">
     <mo>→</mo>
     <msup>
      <mi>δ</mi>
      <mn>1</mn>
     </msup>
    </mover>
    <msup>
     <mi>H</mi>
     <mn>2</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo>,</mo>
     <mi>L</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mi mathvariant="normal">⋯</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <ci>G</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>M</ci>
      <ci>G</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>N</ci>
       <ci>G</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>δ</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>normal-→</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <cn type="integer">1</cn>
      </apply>
      <interval closure="open">
       <ci>G</ci>
       <ci>L</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <cn type="integer">1</cn>
      </apply>
      <interval closure="open">
       <ci>G</ci>
       <ci>M</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <cn type="integer">1</cn>
      </apply>
      <interval closure="open">
       <ci>G</ci>
       <ci>N</ci>
      </interval>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>δ</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-→</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <cn type="integer">2</cn>
      </apply>
      <interval closure="open">
       <ci>G</ci>
       <ci>L</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\to L^{G}\to M^{G}\to N^{G}\overset{\delta^{0}}{\to}H^{1}(G,L)\to H^{1}(G,M)%
\to H^{1}(G,N)\overset{\delta^{1}}{\to}H^{2}(G,L)\to\cdots
  </annotation>
 </semantics>
</math>

</p>

<p>is induced. The maps δ<sup><em>n</em></sup> are called the "<a href="connecting_homomorphism" title="wikilink">connecting homomorphisms</a>" and can be obtained from the <a href="snake_lemma" title="wikilink">snake lemma</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h3 id="cochain-complexes">Cochain complexes</h3>

<p>Rather than using the machinery of derived functors, the cohomology groups can also be defined more concretely, as follows.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> For <em>n</em> ≥ 0, let <em>C<sup>n</sup></em>(<em>G</em>, <em>M</em>) be the group of all <a href="function_(mathematics)" title="wikilink">functions</a> from <em>G<sup>n</sup></em> to <em>M</em>. This is an abelian group; its elements are called the (inhomogeneous) ''' <em>n</em>-cochains'''. The <strong>coboundary homomorphisms</strong></p>

<p>

<math display="block" id="Group_cohomology:5">
 <semantics>
  <mrow>
   <msup>
    <mi>d</mi>
    <mi>n</mi>
   </msup>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>C</mi>
      <mi>n</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>G</mi>
      <mo>,</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <msup>
      <mi>C</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>G</mi>
      <mo>,</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>d</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>C</ci>
       <ci>n</ci>
      </apply>
      <interval closure="open">
       <ci>G</ci>
       <ci>M</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>C</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <interval closure="open">
       <ci>G</ci>
       <ci>M</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d^{n}:C^{n}(G,M)\rightarrow C^{n+1}(G,M)
  </annotation>
 </semantics>
</math>

</p>

<p>are defined as</p>

<p>

<math display="block" id="Group_cohomology:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msup>
       <mi>d</mi>
       <mi>n</mi>
      </msup>
      <mi>φ</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>g</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>g</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>g</mi>
      <mn>1</mn>
     </msub>
     <mo>⋅</mo>
     <mi>φ</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>g</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>g</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>d</ci>
       <ci>n</ci>
      </apply>
      <ci>φ</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>φ</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(d^{n}\varphi\right)(g_{1},\dots,g_{n+1})=g_{1}\cdot\varphi(g_{2},\dots,g%
_{n+1})
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Group_cohomology:7">
 <semantics>
  <mrow>
   <mo>+</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>i</mi>
     </msup>
     <mi>φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>g</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>g</mi>
       <mrow>
        <mi>i</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>,</mo>
      <mrow>
       <msub>
        <mi>g</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>g</mi>
        <mrow>
         <mi>i</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mrow>
      <mo>,</mo>
      <msub>
       <mi>g</mi>
       <mrow>
        <mi>i</mi>
        <mo>+</mo>
        <mn>2</mn>
       </mrow>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>g</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <ci>i</ci>
      </apply>
      <ci>φ</ci>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <apply>
         <minus></minus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <apply>
          <plus></plus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}+\sum_{i=1}^{n}(-1)^{i}\varphi(g_{1},\dots,g_{i-1},g_{i}g_{i+1},g_{i+2},%
\dots,g_{n+1})
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Group_cohomology:8">
 <semantics>
  <mrow>
   <mo>+</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>g</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>g</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>φ</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}+(-1)^{n+1}\varphi(g_{1},\dots,g_{n})
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>The crucial thing to check here is</p>

<p>

<math display="block" id="Group_cohomology:9">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>d</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>∘</mo>
    <msup>
     <mi>d</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>d</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>d</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d^{n+1}\circ d^{n}=0
  </annotation>
 </semantics>
</math>

</p>

<p>thus we have a <a href="cochain_complex" title="wikilink">cochain complex</a> and we can compute cohomology. For <em>n</em> ≥ 0, define the group of ''' <em>n</em>-cocycles''' as:</p>

<p>

<math display="block" id="Group_cohomology:10">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>Z</mi>
     <mi>n</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo>,</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>ker</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>d</mi>
      <mi>n</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Z</ci>
      <ci>n</ci>
     </apply>
     <interval closure="open">
      <ci>G</ci>
      <ci>M</ci>
     </interval>
    </apply>
    <apply>
     <ci>ker</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>d</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z^{n}(G,M)=\operatorname{ker}(d^{n})
  </annotation>
 </semantics>
</math>

</p>

<p>and the group of <strong><em>n</em>-coboundaries</strong> as</p>

<p>

<math display="block" id="Group_cohomology:11">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <msup>
         <mi>B</mi>
         <mn>0</mn>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>G</mi>
         <mo>,</mo>
         <mi>M</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mrow>
         <msup>
          <mi>B</mi>
          <mi>n</mi>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>G</mi>
          <mo>,</mo>
          <mi>M</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>=</mo>
        <mrow>
         <mo>im</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <msup>
           <mi>d</mi>
           <mrow>
            <mi>n</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msup>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo rspace="7.5pt">,</mo>
       <mrow>
        <mi>n</mi>
        <mo>≥</mo>
        <mn>1</mn>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
   </mtable>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">cases</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <cn type="integer">0</cn>
      </apply>
      <interval closure="open">
       <ci>G</ci>
       <ci>M</ci>
      </interval>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <mtext>otherwise</mtext>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>B</ci>
        <ci>n</ci>
       </apply>
       <interval closure="open">
        <ci>G</ci>
        <ci>M</ci>
       </interval>
      </apply>
      <apply>
       <ci>im</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>d</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <geq></geq>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <mtext>otherwise</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{cases}B^{0}(G,M)={0}\\
B^{n}(G,M)=\operatorname{im}(d^{n-1}),\ n\geq 1\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Group_cohomology:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>H</mi>
      <mi>n</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>G</mi>
      <mo>,</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <msup>
        <mi>Z</mi>
        <mi>n</mi>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>G</mi>
        <mo>,</mo>
        <mi>M</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>/</mo>
      <msup>
       <mi>B</mi>
       <mi>n</mi>
      </msup>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>G</mi>
      <mo>,</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <ci>n</ci>
     </apply>
     <interval closure="open">
      <ci>G</ci>
      <ci>M</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Z</ci>
        <ci>n</ci>
       </apply>
       <interval closure="open">
        <ci>G</ci>
        <ci>M</ci>
       </interval>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <interval closure="open">
      <ci>G</ci>
      <ci>M</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{n}(G,M)=Z^{n}(G,M)/B^{n}(G,M).
  </annotation>
 </semantics>
</math>

</p>
<h3 id="the-functors-extn-and-formal-definition-of-group-cohomology">The functors Ext<sup><em>n</em></sup> and formal definition of group cohomology</h3>

<p>Yet another approach is to treat <em>G</em>-modules as modules over the <a href="group_ring" title="wikilink">group ring</a> <strong>Z</strong>[<em>G</em>], which allows one to define group cohomology via <a href="Ext_functor" title="wikilink">Ext functors</a>:</p>

<p>

<math display="block" id="Group_cohomology:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>H</mi>
      <mi>n</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>G</mi>
      <mo>,</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo>Ext</mo>
      <mrow>
       <mi>𝐙</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>G</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝐙</mi>
      <mo>,</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <ci>n</ci>
     </apply>
     <interval closure="open">
      <ci>G</ci>
      <ci>M</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Ext</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>𝐙</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>G</ci>
       </apply>
      </apply>
     </apply>
     <ci>𝐙</ci>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{n}(G,M)=\operatorname{Ext}^{n}_{\mathbf{Z}[G]}(\mathbf{Z},M),
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>M</em> is a <strong>Z</strong>[<em>G</em>]-module.</p>

<p>Here <strong>Z</strong> is treated as the trivial <em>G</em>-module: every element of <em>G</em> acts as the identity. These Ext groups can also be computed via a projective resolution of <strong>Z</strong>, the advantage being that such a resolution only depends on <em>G</em> and not on <em>M</em>. We recall the definition of Ext more explicitly for this context. Let <em>F</em> be a [[projective resolution|projective <strong>Z</strong>[<em>G</em>]-resolution]] (e.g. a [[free resolution| free <strong>Z</strong>[<em>G</em>]-resolution]]) of the trivial <strong>Z</strong>[<em>G</em>]-module <strong>Z</strong>:</p>

<p>

<math display="block" id="Group_cohomology:14">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">…</mi>
    <mo>→</mo>
    <msub>
     <mi>F</mi>
     <mi>n</mi>
    </msub>
    <mo>→</mo>
    <msub>
     <mi>F</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>→</mo>
    <mi mathvariant="normal">…</mi>
    <mo>→</mo>
    <msub>
     <mi>F</mi>
     <mn>0</mn>
    </msub>
    <mo>→</mo>
    <mi>𝐙</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-…</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>𝐙</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dots\to F_{n}\to F_{n-1}\to\dots\to F_{0}\to\mathbf{Z}.
  </annotation>
 </semantics>
</math>

</p>

<p>e.g., one may always take the resolution of group rings, <em>F<sub>n</sub></em> = <strong>Z</strong>[<em>G</em><sup><em>n</em>+1</sup>], with morphisms</p>

<p>

<math display="block" id="Group_cohomology:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mi>n</mi>
    </msub>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>𝐙</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <msup>
         <mi>G</mi>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msup>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo>→</mo>
      <mrow>
       <mi>𝐙</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <msup>
         <mi>G</mi>
         <mi>n</mi>
        </msup>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo rspace="12.5pt">,</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>g</mi>
        <mn>0</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>g</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>g</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>↦</mo>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mi>n</mi>
       </munderover>
       <mrow>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>i</mi>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>g</mi>
          <mn>0</mn>
         </msub>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo>,</mo>
         <mover accent="true">
          <msub>
           <mi>g</mi>
           <mi>i</mi>
          </msub>
          <mo>^</mo>
         </mover>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo>,</mo>
         <msub>
          <mi>g</mi>
          <mi>n</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <times></times>
       <ci>𝐙</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>G</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>𝐙</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>G</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>n</ci>
       </apply>
      </vector>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
         <ci>i</ci>
        </apply>
        <vector>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>g</ci>
          <cn type="integer">0</cn>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <ci>normal-^</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>g</ci>
           <ci>i</ci>
          </apply>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>g</ci>
          <ci>n</ci>
         </apply>
        </vector>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{n}:\mathbf{Z}[G^{n+1}]\to\mathbf{Z}[G^{n}],\quad(g_{0},g_{1},\dots,g_{n})%
\mapsto\sum_{i=0}^{n}(-1)^{i}(g_{0},\dots,\widehat{g_{i}},\dots,g_{n}).
  </annotation>
 </semantics>
</math>

</p>

<p>Recall that for <strong>Z</strong>[<em>G</em>]-modules <em>N</em> and <em>M</em>, Hom<sub><em>G</em></sub>(<em>N</em>, <em>M</em>) is an <a href="abelian_group" title="wikilink">abelian group</a> consisting of <strong>Z</strong>[<em>G</em>]-homomorphisms from <em>N</em> to <em>M</em>. Since Hom<sub><em>G</em></sub>(–, <em>M</em>) is a <a href="contravariant_functor" title="wikilink">contravariant functor</a> and reverses the arrows, applying Hom<sub><em>G</em></sub>(–, <em>M</em>) to <em>F</em> termwise produces a <a href="cochain_complex" title="wikilink">cochain complex</a> Hom<sub><em>G</em></sub>(<em>F</em>, <em>M</em>):</p>

<p>

<math display="block" id="Group_cohomology:16">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">⋯</mi>
    <mo>←</mo>
    <mrow>
     <msub>
      <mo>Hom</mo>
      <mi>G</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>F</mi>
       <mi>n</mi>
      </msub>
      <mo>,</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>←</mo>
    <mrow>
     <msub>
      <mo>Hom</mo>
      <mi>G</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>F</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>,</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>←</mo>
    <mi mathvariant="normal">…</mi>
    <mo>←</mo>
    <mrow>
     <msub>
      <mo>Hom</mo>
      <mi>G</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>F</mi>
       <mn>0</mn>
      </msub>
      <mo>,</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>←</mo>
    <mrow>
     <msub>
      <mo>Hom</mo>
      <mi>G</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝐙</mi>
      <mo>,</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-←</ci>
     <ci>normal-⋯</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Hom</ci>
       <ci>G</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>n</ci>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-←</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Hom</ci>
       <ci>G</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-←</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-…</ci>
    </apply>
    <apply>
     <ci>normal-←</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Hom</ci>
       <ci>G</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-←</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Hom</ci>
       <ci>G</ci>
      </apply>
      <ci>𝐙</ci>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cdots\leftarrow\operatorname{Hom}_{G}(F_{n},M)\leftarrow\operatorname{Hom}_{G%
}(F_{n-1},M)\leftarrow\dots\leftarrow\operatorname{Hom}_{G}(F_{0},M)\leftarrow%
\operatorname{Hom}_{G}(\mathbf{Z},M).
  </annotation>
 </semantics>
</math>

</p>

<p>The cohomology groups <em>H*</em>(<em>G</em>, <em>M</em>) of <em>G</em> with coefficients in the module <em>M</em> are defined as the cohomology of the above cochain complex:</p>

<p>

<math display="block" id="Group_cohomology:17">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>H</mi>
     <mi>n</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo>,</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>H</mi>
     <mi>n</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>Hom</mi>
       <mi>G</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>F</mi>
       <mo>,</mo>
       <mi>M</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <ci>n</ci>
     </apply>
     <interval closure="open">
      <ci>G</ci>
      <ci>M</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Hom</ci>
       <ci>G</ci>
      </apply>
      <interval closure="open">
       <ci>F</ci>
       <ci>M</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{n}(G,M)=H^{n}({\rm Hom}_{G}(F,M))
  </annotation>
 </semantics>
</math>

</p>

<p>for <em>n</em> ≥ 0.</p>

<p>This construction initially leads to a coboundary operator that acts on the "homogeneous" cochains. These are the elements of Hom<sub><em>G</em></sub>(<em>F</em>, <em>M</em>) i.e. functions φ<sub><em>n</em></sub>: <em>G<sup>n</sup></em> → <em>M</em> that obey</p>

<p>

<math display="block" id="Group_cohomology:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>g</mi>
     <msub>
      <mi>ϕ</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>g</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>g</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>g</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>ϕ</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>g</mi>
       <msub>
        <mi>g</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>g</mi>
       <msub>
        <mi>g</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mrow>
       <mi>g</mi>
       <msub>
        <mi>g</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>n</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>n</ci>
     </apply>
     <vector>
      <apply>
       <times></times>
       <ci>g</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>g</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <ci>g</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\phi_{n}(g_{1},g_{2},\ldots,g_{n})=\phi_{n}(gg_{1},gg_{2},\ldots,gg_{n}).
  </annotation>
 </semantics>
</math>

</p>

<p>The coboundary operator δ: <em>C<sup>n</sup></em> → <em>C</em><sup><em>n</em>+1</sup> is now naturally defined by, for example,</p>

<p>

<math display="block" id="Group_cohomology:19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>δ</mi>
     <msub>
      <mi>ϕ</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>g</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>g</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>g</mi>
       <mn>3</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <msub>
        <mi>ϕ</mi>
        <mn>2</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>g</mi>
         <mn>2</mn>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>g</mi>
         <mn>3</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>ϕ</mi>
        <mn>2</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>g</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>g</mi>
         <mn>3</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>ϕ</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>g</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>g</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>δ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <cn type="integer">2</cn>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <cn type="integer">3</cn>
      </apply>
     </vector>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϕ</ci>
        <cn type="integer">2</cn>
       </apply>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <cn type="integer">3</cn>
        </apply>
       </interval>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϕ</ci>
        <cn type="integer">2</cn>
       </apply>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <cn type="integer">3</cn>
        </apply>
       </interval>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <cn type="integer">2</cn>
      </apply>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta\phi_{2}(g_{1},g_{2},g_{3})=\phi_{2}(g_{2},g_{3})-\phi_{2}(g_{1},g_{3})+%
\phi_{2}(g_{1},g_{2}).
  </annotation>
 </semantics>
</math>

</p>

<p>The relation to the coboundary operator <em>d</em> that was defined in the previous section, and which acts on the "inhomogeneous" cochains 

<math display="inline" id="Group_cohomology:20">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

, is given by reparameterizing so that</p>

<p>

<math display="inline" id="Group_cohomology:21">
 <semantics>
  <mrow>
   <msub>
    <mi>φ</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>g</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>g</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>φ</ci>
     <cn type="integer">2</cn>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\varphi_{2}(g_{1},g_{2})
  </annotation>
 </semantics>
</math>


</p>

<p>and so on. Thus</p>

<p>

<math display="inline" id="Group_cohomology:22">
 <semantics>
  <mrow>
   <mi>d</mi>
   <msub>
    <mi>φ</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>g</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>g</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>g</mi>
     <mn>3</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>φ</ci>
     <cn type="integer">2</cn>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">3</cn>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle d\varphi_{2}(g_{1},g_{2},g_{3})
  </annotation>
 </semantics>
</math>


</p>

<p>as in the preceding section.</p>
<h3 id="group-homology">Group homology</h3>

<p>Dually to the construction of group cohomology there is the following definition of <strong>group homology</strong>: given a <a href="G-module" title="wikilink"><em>G</em>-module</a> <em>M</em>, set <em>DM</em> to be the <a class="uri" href="submodule" title="wikilink">submodule</a> <a href="generating_set_of_a_group" title="wikilink">generated</a> by elements of the form <em>g</em>·<em>m</em> − <em>m</em>, <em>g</em> ∈ <em>G</em>, <em>m</em> ∈ <em>M</em>. Assigning to <em>M</em> its so-called <em><a href="coinvariant" title="wikilink">coinvariants</a></em>, the <a href="quotient_group" title="wikilink">quotient</a></p>

<p>

<math display="block" id="Group_cohomology:23">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>M</mi>
     <mi>G</mi>
    </msub>
    <mo>:=</mo>
    <mrow>
     <mrow>
      <mi>M</mi>
      <mo>/</mo>
      <mi>D</mi>
     </mrow>
     <mi>M</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <ci>G</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>M</ci>
      <ci>D</ci>
     </apply>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{G}:=M/DM,\,
  </annotation>
 </semantics>
</math>

</p>

<p>is a <a href="right_exact_functor" title="wikilink">right exact functor</a>. Its <a href="left_derived_functor" title="wikilink">left derived functors</a> are by definition the group homology</p>

<p>

<math display="block" id="Group_cohomology:24">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo>(</mo>
    <mi>G</mi>
    <mo>,</mo>
    <mi>M</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>n</ci>
    </apply>
    <interval closure="open">
     <ci>G</ci>
     <ci>M</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{n}\left(G,M\right)
  </annotation>
 </semantics>
</math>

.</p>

<p>Note that the superscript/subscript convention for cohomology/homology agrees with the convention for group invariants/coinvariants, while which is denoted "co-" switches:</p>
<ul>
<li>superscripts correspond to cohomology <em>H*</em> and invariants <em>X<sup>G</sup></em> while</li>
<li>subscripts correspond to homology <em>H</em><sub>∗</sub> and coinvariants <em>X<sub>G</sub></em> := <em>X</em>/<em>G</em>.</li>
</ul>

<p>The <a href="covariant_functor" title="wikilink">covariant functor</a> which assigns <em>M<sub>G</sub></em> to <em>M</em> is isomorphic to the functor which sends <em>M</em> to <strong>Z</strong> ⊗<sub><strong>Z</strong>[<em>G</em>]</sub> <em>M</em>, where <strong>Z</strong> is endowed with the trivial <em>G</em>-action. Hence one also gets an expression for group homology in terms of the <a href="Tor_functor" title="wikilink">Tor functors</a>,</p>

<p>

<math display="block" id="Group_cohomology:25">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo>,</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo>Tor</mo>
     <mi>n</mi>
     <mrow>
      <mi>𝐙</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>G</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐙</mi>
     <mo>,</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>n</ci>
     </apply>
     <interval closure="open">
      <ci>G</ci>
      <ci>M</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Tor</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>𝐙</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>G</ci>
       </apply>
      </apply>
     </apply>
     <ci>𝐙</ci>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{n}(G,M)=\operatorname{Tor}_{n}^{\mathbf{Z}[G]}(\mathbf{Z},M)
  </annotation>
 </semantics>
</math>

</p>

<p>Recall that the tensor product <em>N</em> ⊗<sub><strong>Z</strong>[<em>G</em>]</sub> <em>M</em> is defined whenever <em>N</em> is a right <strong>Z</strong>[<em>G</em>]-module and <em>M</em> is a left <strong>Z</strong>[<em>G</em>]-module. If <em>N</em> is a left <strong>Z</strong>[<em>G</em>]-module, we turn it into a right <strong>Z</strong>[<em>G</em>]-module by setting <em>a</em> <em>g</em> = <em>g</em><sup>−1</sup> <em>a</em> for every <em>g</em> ∈ <em>G</em> and every <em>a</em> ∈ <em>N</em>. This convention allows to define the tensor product <em>N</em> ⊗<sub><strong>Z</strong>[<em>G</em>]</sub> <em>M</em> in the case where both <em>M</em> and <em>N</em> are left <strong>Z</strong>[<em>G</em>]-modules.</p>

<p>Specifically, the homology groups <em>H</em><sub><em>n</em></sub>(<em>G</em>, <em>M</em>) can be computed as follows. Start with a <a href="projective_resolution" title="wikilink">projective resolution</a> <em>F</em> of the trivial <strong>Z</strong>[<em>G</em>]-module <strong>Z</strong>, as in the previous section. Apply the covariant functor ⋅ ⊗<sub><strong>Z</strong>[<em>G</em>]</sub> <em>M</em> to <em>F</em> termwise to get a <a href="chain_complex" title="wikilink">chain complex</a> <em>F</em> ⊗<sub><strong>Z</strong>[<em>G</em>]</sub> <em>M</em>:</p>

<p>

<math display="block" id="Group_cohomology:26">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">…</mi>
    <mo>→</mo>
    <mrow>
     <msub>
      <mi>F</mi>
      <mi>n</mi>
     </msub>
     <msub>
      <mo>⊗</mo>
      <mrow>
       <mi>𝐙</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>G</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </msub>
     <mi>M</mi>
    </mrow>
    <mo>→</mo>
    <mrow>
     <msub>
      <mi>F</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msub>
      <mo>⊗</mo>
      <mrow>
       <mi>𝐙</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>G</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </msub>
     <mi>M</mi>
    </mrow>
    <mo>→</mo>
    <mi mathvariant="normal">…</mi>
    <mo>→</mo>
    <mrow>
     <msub>
      <mi>F</mi>
      <mn>0</mn>
     </msub>
     <msub>
      <mo>⊗</mo>
      <mrow>
       <mi>𝐙</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>G</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </msub>
     <mi>M</mi>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>𝐙</mi>
     <msub>
      <mo>⊗</mo>
      <mrow>
       <mi>𝐙</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>G</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </msub>
     <mi>M</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <ci>normal-…</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <ci>𝐙</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>G</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>n</ci>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <ci>𝐙</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>G</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-…</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <ci>𝐙</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>G</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <ci>𝐙</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>G</ci>
        </apply>
       </apply>
      </apply>
      <ci>𝐙</ci>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dots\to F_{n}\otimes_{\mathbf{Z}[G]}M\to F_{n-1}\otimes_{\mathbf{Z}[G]}M\to%
\dots\to F_{0}\otimes_{\mathbf{Z}[G]}M\to\mathbf{Z}\otimes_{\mathbf{Z}[G]}M.
  </annotation>
 </semantics>
</math>

</p>

<p>Then <em>H</em><sub><em>n</em></sub>(<em>G</em>, <em>M</em>) are the homology groups of this chain complex, 

<math display="inline" id="Group_cohomology:27">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo>,</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>F</mi>
      <msub>
       <mo>⊗</mo>
       <mrow>
        <mi>𝐙</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mi>G</mi>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
      </msub>
      <mi>M</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>n</ci>
     </apply>
     <interval closure="open">
      <ci>G</ci>
      <ci>M</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <ci>𝐙</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>G</ci>
        </apply>
       </apply>
      </apply>
      <ci>F</ci>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{n}(G,M)=H_{n}(F\otimes_{\mathbf{Z}[G]}M)
  </annotation>
 </semantics>
</math>

 for <em>n</em> ≥ 0.</p>

<p>Group homology and cohomology can be treated uniformly for some groups, especially <a href="finite_group" title="wikilink">finite groups</a>, in terms of complete resolutions and the <a href="Tate_cohomology_group" title="wikilink">Tate cohomology groups</a>.</p>
<h2 id="functorial-maps-in-terms-of-cochains">Functorial maps in terms of cochains</h2>
<h3 id="connecting-homomorphisms">Connecting homomorphisms</h3>

<p>For a short exact sequence 0 → <em>L</em> → <em>M</em> → <em>N</em> → 0, the connecting homomorphisms δ<sup>n</sup> : <em>H</em><sup>n</sup>(<em>G</em>, <em>N</em>) → <em>H</em><sup>n+1</sup>(<em>G</em>, <em>L</em>) can be described in terms of inhomogeneous cochains as follows.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> If <em>c</em> is an element of <em>H</em><sup>n</sup>(<em>G</em>, <em>N</em>) represented by an <em>n</em>-cocycle φ : <em>G</em><sup>n</sup> → N, then δ<sup>n</sup>(<em>c</em>) is represented by <em>d</em><sup>n</sup>(ψ), where ψ is an <em>n</em>-cochain <em>G</em><sup>n</sup> → M "lifting" φ (i.e. such that φ is the composition of ψ with the surjective map <em>M</em> → <em>N</em>).</p>
<h2 id="non-abelian-group-cohomology">Non-abelian group cohomology</h2>

<p>Using the <em>G</em>-invariants and the 1-cochains, one can construct the zeroth and first group cohomology for a group <em>G</em> with coefficients in a non-abelian group. Specifically, a <em>G</em>-group is a (not necessarily abelian) group <em>A</em> together with an action by <em>G</em>.</p>

<p>The <em>zeroth cohomology of G with coefficients in A</em> is defined to be the subgroup</p>

<p>

<math display="block" id="Group_cohomology:28">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>H</mi>
      <mn>0</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>G</mi>
      <mo>,</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mi>A</mi>
     <mi>G</mi>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <cn type="integer">0</cn>
     </apply>
     <interval closure="open">
      <ci>G</ci>
      <ci>A</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{0}(G,A)=A^{G},\,
  </annotation>
 </semantics>
</math>

</p>

<p>of elements of <em>A</em> fixed by <em>G</em>.</p>

<p>The <em>first cohomology of G with coefficients in A</em> is defined as 1-cocycles modulo an equivalence relation instead of by 1-coboundaries. The condition for a map φ to be a 1-cocycle is that φ(<em>gh</em>) = φ(<em>g</em>)[<em>g</em>φ(<em>h</em>)] and 

<math display="inline" id="Group_cohomology:29">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>φ</mi>
   </mpadded>
   <mo>∼</mo>
   <msup>
    <mi>φ</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <ci>φ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>φ</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \varphi\sim\varphi^{\prime}
  </annotation>
 </semantics>
</math>

 if there is an <em>a</em> in <em>A</em> such that 

<math display="inline" id="Group_cohomology:30">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="5pt" width="+5pt">
     <mi>a</mi>
    </mpadded>
    <msup>
     <mi>φ</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>g</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>g</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>g</mi>
      <mi>a</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>a</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>φ</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>g</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <times></times>
      <ci>φ</ci>
      <ci>g</ci>
     </apply>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ a\varphi^{\prime}(g)=\varphi(g)\cdot(ga)
  </annotation>
 </semantics>
</math>

. In general, <em>H</em><sup>1</sup>(<em>G</em>, <em>A</em>) is not a group when <em>A</em> is non-abelian. It instead has the structure of a <a href="pointed_set" title="wikilink">pointed set</a> – exactly the same situation arises in the 0th <a href="homotopy_group" title="wikilink">homotopy group</a>, 

<math display="inline" id="Group_cohomology:31">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="5pt" width="+5pt">
     <mi>π</mi>
    </mpadded>
    <mn>0</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>;</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <cn type="integer">0</cn>
    </apply>
    <list>
     <ci>X</ci>
     <ci>x</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \pi_{0}(X;x)
  </annotation>
 </semantics>
</math>

 which for a general topological space is not a group but a pointed set. Note that a group is in particular a pointed set, with the identity element as distinguished point.</p>

<p>Using explicit calculations, one still obtains a <em>truncated</em> long exact sequence in cohomology. Specifically, let</p>

<p>

<math display="block" id="Group_cohomology:32">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>→</mo>
   <mi>A</mi>
   <mo>→</mo>
   <mi>B</mi>
   <mo>→</mo>
   <mi>C</mi>
   <mo>→</mo>
   <mpadded width="+1.7pt">
    <mn>1</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">1</cn>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>B</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>C</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\to A\to B\to C\to 1\,
  </annotation>
 </semantics>
</math>

</p>

<p>be a short exact sequence of <em>G</em>-groups, then there is an exact sequence of pointed sets</p>

<p>

<math display="block" id="Group_cohomology:33">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>→</mo>
    <msup>
     <mi>A</mi>
     <mi>G</mi>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>B</mi>
     <mi>G</mi>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>C</mi>
     <mi>G</mi>
    </msup>
    <mo>→</mo>
    <mrow>
     <msup>
      <mi>H</mi>
      <mn>1</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>G</mi>
      <mo>,</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <msup>
      <mi>H</mi>
      <mn>1</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>G</mi>
      <mo>,</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <msup>
      <mi>H</mi>
      <mn>1</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>G</mi>
      <mo>,</mo>
      <mi>C</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>G</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>G</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>C</ci>
      <ci>G</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <cn type="integer">1</cn>
      </apply>
      <interval closure="open">
       <ci>G</ci>
       <ci>A</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <cn type="integer">1</cn>
      </apply>
      <interval closure="open">
       <ci>G</ci>
       <ci>B</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <cn type="integer">1</cn>
      </apply>
      <interval closure="open">
       <ci>G</ci>
       <ci>C</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\to A^{G}\to B^{G}\to C^{G}\to H^{1}(G,A)\to H^{1}(G,B)\to H^{1}(G,C).\,
  </annotation>
 </semantics>
</math>

</p>
<h2 id="connections-with-topological-cohomology-theories">Connections with topological cohomology theories</h2>

<p>Group cohomology can be related to topological cohomology theories: to the topological group <em>G</em> there is an associated <a href="classifying_space" title="wikilink">classifying space</a> <em>BG</em>. (If <em>G</em> has no topology about which we care, then we assign the <a href="discrete_topology" title="wikilink">discrete topology</a> to <em>G</em>. In this case, <em>BG</em> is an <a href="Eilenberg-MacLane_space" title="wikilink">Eilenberg-MacLane space</a> K(<em>G</em>,1), whose <a href="fundamental_group" title="wikilink">fundamental group</a> is <em>G</em> and whose higher <a href="homotopy_group" title="wikilink">homotopy groups</a> vanish). The <em>n</em>-th cohomology of <em>BG</em>, with coefficients in <em>M</em> (in the topological sense), is the same as the group cohomology of <em>G</em> with coefficients in <em>M</em>. This will involve a <a href="local_system" title="wikilink">local coefficient system</a> unless <em>M</em> is a trivial <em>G</em>-module. The connection holds because the total space <em>EG</em> is contractible, so its chain complex forms a projective resolution of <em>M</em>. These connections are explained in , Chapter II.</p>

<p>When <em>M</em> is a ring with trivial <em>G</em>-action, we inherit good properties which are familiar from the topological context: in particular, there is a <a href="cup_product" title="wikilink">cup product</a> under which</p>

<p>

<math display="block" id="Group_cohomology:34">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>H</mi>
     <mo>*</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo>;</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
     <mi>n</mi>
    </munder>
    <mrow>
     <msup>
      <mi>H</mi>
      <mi>n</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>G</mi>
      <mo>;</mo>
      <mi>M</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <times></times>
     </apply>
     <list>
      <ci>G</ci>
      <ci>M</ci>
     </list>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <ci>n</ci>
      </apply>
      <list>
       <ci>G</ci>
       <ci>M</ci>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{*}(G;M)=\bigoplus_{n}H^{n}(G;M)\,
  </annotation>
 </semantics>
</math>

</p>

<p>is a <a href="graded_module" title="wikilink">graded module</a>, and a <a href="Künneth_formula" title="wikilink">Künneth formula</a> applies.</p>

<p>If, furthermore, <em>M</em> = <em>k</em> is a field, then <em>H*</em>(<em>G</em>; <em>k</em>) is a graded <em>k</em>-algebra. In this case, the Künneth formula yields</p>

<p>

<math display="block" id="Group_cohomology:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>H</mi>
      <mo>*</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>G</mi>
        <mn>1</mn>
       </msub>
       <mo>×</mo>
       <msub>
        <mi>G</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo>;</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≅</mo>
    <mrow>
     <mrow>
      <mrow>
       <msup>
        <mi>H</mi>
        <mo>*</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>G</mi>
         <mn>1</mn>
        </msub>
        <mo>;</mo>
        <mi>k</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⊗</mo>
      <msup>
       <mi>H</mi>
       <mo>*</mo>
      </msup>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>G</mi>
       <mn>2</mn>
      </msub>
      <mo>;</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <times></times>
     </apply>
     <list>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>G</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>G</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </list>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>H</ci>
        <times></times>
       </apply>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>G</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>k</ci>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <times></times>
      </apply>
     </apply>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>G</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>k</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{*}(G_{1}\times G_{2};k)\cong H^{*}(G_{1};k)\otimes H^{*}(G_{2};k).\,
  </annotation>
 </semantics>
</math>

</p>

<p>For example, let <em>G</em> be the group with two elements, under the discrete topology. The real <a href="projective_space" title="wikilink">projective space</a> <strong>P</strong><sup>∞</sup>(<strong>R</strong>) is a classifying space for <em>G</em>. Let <em>k</em> = <strong>F</strong><sub>2</sub>, the <a href="field_(mathematics)" title="wikilink">field</a> of two elements. Then</p>

<p>

<math display="block" id="Group_cohomology:36">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>H</mi>
      <mo>*</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>G</mi>
      <mo>;</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≅</mo>
    <mrow>
     <mi>k</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <times></times>
     </apply>
     <list>
      <ci>G</ci>
      <ci>k</ci>
     </list>
    </apply>
    <apply>
     <times></times>
     <ci>k</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{*}(G;k)\cong k[x],\,
  </annotation>
 </semantics>
</math>

</p>

<p>a polynomial <em>k</em>-algebra on a single generator, since this is the <a href="singular_cohomology" title="wikilink">cellular cohomology</a> ring of <strong>P</strong><sup>∞</sup>(<strong>R</strong>).</p>

<p>Hence, as a second example, if <em>G</em> is an <a href="elementary_abelian_group" title="wikilink">elementary abelian 2-group</a> of rank <em>r</em>, and <em>k</em> = <strong>F</strong><sub>2</sub>, then the Künneth formula gives</p>

<p>

<math display="block" id="Group_cohomology:37">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>H</mi>
     <mo>*</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo>;</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≅</mo>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>r</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <times></times>
     </apply>
     <list>
      <ci>G</ci>
      <ci>k</ci>
     </list>
    </apply>
    <apply>
     <times></times>
     <ci>k</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>r</ci>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{*}(G;k)\cong k[x_{1},\ldots,x_{r}]
  </annotation>
 </semantics>
</math>

, a polynomial <em>k</em>-algebra generated by <em>r</em> classes in <em>H</em><sup>1</sup>(<em>G</em>; <em>k</em>).</p>
<h2 id="properties">Properties</h2>

<p>In the following, let <em>M</em> be a <em>G</em>-module.</p>
<h3 id="functoriality">Functoriality</h3>

<p>Group cohomology depends contravariantly on the group <em>G</em>, in the following sense: if <em>f</em> : <em>H</em> → <em>G</em> is a <a href="group_homomorphism" title="wikilink">group homomorphism</a>, then we have a naturally induced morphism <em>H<sup>n</sup></em>(<em>G</em>,<em>M</em>) → <em>H<sup>n</sup></em>(<em>H</em>,<em>M</em>) (where in the latter, <em>M</em> is treated as an <em>H</em>-module via <em>f</em>).</p>

<p>Given a morphism of <em>G</em>-modules <em>M</em>→<em>N</em>, one gets a morphism of cohomology groups in the <em>H<sup>n</sup></em>(<em>G</em>,<em>M</em>) → <em>H<sup>n</sup></em>(<em>G</em>,<em>N</em>).</p>
<h3 id="h1"><em>H</em><sup>1</sup></h3>

<p>The first cohomology group is the quotient of the so-called <em>crossed homomorphisms</em>, i.e. maps (of sets) <em>f</em> : <em>G</em> → <em>M</em> satisfying <em>f</em>(<em>ab</em>) = <em>f</em>(<em>a</em>) + <em>af</em>(<em>b</em>) for all <em>a</em>, <em>b</em> in <em>G</em>, modulo the so-called <em>principal crossed homomorphisms</em>, i.e. maps <em>f</em> : <em>G</em> → <em>M</em> given by <em>f</em>(<em>a</em>) = <em>am</em>−<em>m</em> for some fixed <em>m</em> ∈ <em>M</em>. This follows from the definition of cochains above.</p>

<p>If the action of <em>G</em> on <em>M</em> is trivial, then the above boils down to <em>H</em><sup>1</sup>(<em>G</em>,<em>M</em>) = Hom(<em>G</em>, <em>M</em>), the group of <a href="group_homomorphism" title="wikilink">group homomorphisms</a> <em>G</em> → <em>M</em>.</p>
<h3 id="h2"><em>H</em><sup>2</sup></h3>

<p>If <em>M</em> is a trivial <em>G</em>-module (i.e. the action of <em>G</em> on <em>M</em> is trivial), the second cohomology group <em>H</em><sup>2</sup>(<em>G</em>,<em>M</em>) is in one-to-one correspondence with the set of <a href="Group_extension#Central_extension" title="wikilink">central extensions</a> of <em>G</em> by <em>M</em> (up to a natural equivalence relation). More generally, if the action of <em>G</em> on <em>M</em> is nontrivial, <em>H</em><sup>2</sup>(<em>G</em>,<em>M</em>) classifies the isomorphism classes of all <a href="Group_extension" title="wikilink">extensions</a> of <em>G</em> by <em>M</em> in which the induced action of <em>G</em> on <em>M</em> by <a href="inner_automorphism" title="wikilink">inner automorphisms</a> agrees with the given action.</p>
<h3 id="change-of-group">Change of group</h3>

<p>The <a href="Hochschild–Serre_spectral_sequence" title="wikilink">Hochschild–Serre spectral sequence</a> relates the cohomology of a normal subgroup <em>N</em> of <em>G</em> and the quotient <em>G/N</em> to the cohomology of the group <em>G</em> (for (pro-)finite groups <em>G</em>). From it, one gets the <a href="inflation-restriction_exact_sequence" title="wikilink">inflation-restriction exact sequence</a>.</p>
<h3 id="cohomology-of-finite-groups-is-torsion">Cohomology of finite groups is torsion</h3>

<p>The cohomology groups of finite groups are all torsion. Indeed, by <a href="Maschke's_theorem" title="wikilink">Maschke's theorem</a> the category of representations of a finite group is semi-simple over any field of characteristic zero (or more generally, any field whose characteristic does not divide the order of the group), hence, viewing group cohomology as a derived functor in this abelian category, one obtains that it is zero. The other argument is that over a field of characteristic zero, the group algebra of a finite group is a direct sum of matrix algebras (possibly over division algebras which are extensions of the original field), while a matrix algebra is <a href="Morita_equivalent" title="wikilink">Morita equivalent</a> to its base field and hence has trivial cohomology.</p>
<h2 id="history-and-relation-to-other-fields">History and relation to other fields</h2>

<p>The low-dimensional cohomology of a group was classically studied in other guises, long before the notion of group cohomology was formulated in 1943–45. The first theorem of the subject can be identified as <a href="Hilbert's_Theorem_90" title="wikilink">Hilbert's Theorem 90</a> in 1897; this was recast into <em><a href="Emmy_Noether" title="wikilink">Noether</a>'s equations</em> in <a href="Galois_theory" title="wikilink">Galois theory</a> (an appearance of cocycles for <em>H</em><sup>1</sup>). The idea of <em><a href="factor_set" title="wikilink">factor sets</a></em> for the <a href="extension_problem" title="wikilink">extension problem</a> for groups (connected with <em>H</em><sup>2</sup>) arose in the work of <a href="Otto_Hölder" title="wikilink">Hölder</a> (1893), in <a href="Issai_Schur" title="wikilink">Issai Schur</a>'s 1904 study of projective representations, in <a href="Otto_Schreier" title="wikilink">Schreier</a>'s 1926 treatment, and in <a href="Richard_Brauer" title="wikilink">Richard Brauer</a>'s 1928 study of <a href="simple_algebra" title="wikilink">simple algebras</a> and the <a href="Brauer_group" title="wikilink">Brauer group</a>. A fuller discussion of this history may be found in .</p>

<p>In 1941, while studying <em>H</em><sub>2</sub>(<em>G</em>, <strong>Z</strong>) (which plays a special role in groups), <a href="Heinz_Hopf" title="wikilink">Hopf</a> discovered what is now called <strong>Hopf's integral homology formula</strong> , which is identical to Schur's formula for the <a href="Schur_multiplier" title="wikilink">Schur multiplier</a> of a finite, finitely presented group:</p>

<p>

<math display="block" id="Group_cohomology:38">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo>,</mo>
     <mi>𝐙</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≅</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>R</mi>
      <mo>∩</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>F</mi>
       <mo>,</mo>
       <mi>F</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>F</mi>
     <mo>,</mo>
     <mi>R</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">2</cn>
     </apply>
     <interval closure="open">
      <ci>G</ci>
      <ci>𝐙</ci>
     </interval>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <intersect></intersect>
      <ci>R</ci>
      <interval closure="closed">
       <ci>F</ci>
       <ci>F</ci>
      </interval>
     </apply>
     <interval closure="closed">
      <ci>F</ci>
      <ci>R</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{2}(G,\mathbf{Z})\cong(R\cap[F,F])/[F,R]
  </annotation>
 </semantics>
</math>

,</p>

<p>where <em>G</em> ≅ <em>F</em>/<em>R</em> and <em>F</em> is a free group.</p>

<p>Hopf's result led to the independent discovery of group cohomology by several groups in 1943-45: <a href="Samuel_Eilenberg" title="wikilink">Eilenberg</a> and <a href="Saunders_Mac_Lane" title="wikilink">Mac Lane</a> in the USA ; Hopf and <a href="Beno_Eckmann" title="wikilink">Eckmann</a> in Switzerland; and <a href="Hans_Freudenthal" title="wikilink">Freudenthal</a> in the Netherlands . The situation was chaotic because communication between these countries was difficult during World War II.</p>

<p>From a topological point of view, the homology and cohomology of G was first defined as the homology and cohomology of a model for the topological <a href="classifying_space" title="wikilink">classifying space</a> <em>BG</em> as discussed in <a href="#Connections_with_topological_cohomology_theories" title="wikilink">#Connections with topological cohomology theories</a> above. In practice, this meant using topology to produce the chain complexes used in formal algebraic definitions. From a module-theoretic point of view this was integrated into the <a href="Henri_Cartan" title="wikilink">Cartan</a>–<a href="Samuel_Eilenberg" title="wikilink">Eilenberg</a> theory of <a href="homological_algebra" title="wikilink">homological algebra</a> in the early 1950s.</p>

<p>The application in <a href="algebraic_number_theory" title="wikilink">algebraic number theory</a> to <a href="class_field_theory" title="wikilink">class field theory</a> provided theorems valid for general <a href="Galois_extension" title="wikilink">Galois extensions</a> (not just <a href="abelian_extension" title="wikilink">abelian extensions</a>). The cohomological part of class field theory was axiomatized as the theory of <a href="class_formation" title="wikilink">class formations</a>. In turn, this led to the notion of <a href="Galois_cohomology" title="wikilink">Galois cohomology</a> and <a href="étale_cohomology" title="wikilink">étale cohomology</a> (which builds on it) . Some refinements in the theory post-1960 have been made, such as continuous cocycles and <a href="John_Tate" title="wikilink">Tate</a>'s <a href="Tate_cohomology_group" title="wikilink">redefinition</a>, but the basic outlines remain the same. This is a large field, and now basic in the theories of <a href="algebraic_group" title="wikilink">algebraic groups</a>.</p>

<p>The analogous theory for <a href="Lie_algebra" title="wikilink">Lie algebras</a>, called <a href="Lie_algebra_cohomology" title="wikilink">Lie algebra cohomology</a>, was first developed in the late 1940s, by <a class="uri" href="Chevalley" title="wikilink">Chevalley</a>–Eilenberg, and <a href="Jean-Louis_Koszul" title="wikilink">Koszul</a> . It is formally similar, using the corresponding definition of <em>invariant</em> for the action of a Lie algebra. It is much applied in <a href="representation_theory" title="wikilink">representation theory</a>, and is closely connected with the <a href="BRST_quantization" title="wikilink">BRST quantization</a> of <a href="theoretical_physics" title="wikilink">theoretical physics</a>.</p>

<p>Group cohomology theory also has a direct application in condensed matter physics. Just like group theory being the mathematical foundation of <a href="spontaneous_symmetry_breaking" title="wikilink">spontaneous symmetry breaking</a> phases, group cohomology theory is the mathematical foundation of a class of quantum states of matter—short-range entangled states with symmetry. Short-range entangled states with symmetry are also known as <a href="symmetry_protected_topological_order" title="wikilink">symmetry protected topological states</a>.</p>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li>Chapter II of </li>
<li></li>
<li>Chapter VII of </li>
<li></li>
<li></li>
<li>Chapter 6 of </li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Algebraic_number_theory" title="wikilink">Category:Algebraic number theory</a> <a href="Category:Cohomology_theories" title="wikilink">Category:Cohomology theories</a> <a href="Category:Group_theory" title="wikilink">Category:Group theory</a> <a href="Category:Homological_algebra" title="wikilink">Category:Homological algebra</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Section VII.2 of <a href="#Reference-Se1979" title="wikilink">Serre 1979</a><a href="#fnref1">↩</a></li>
<li id="fn2">Page 62 of <a href="#Reference-Mil2008" title="wikilink">Milne 2008</a> or section VII.3 of <a href="#Reference-Se1979" title="wikilink">Serre 1979</a><a href="#fnref2">↩</a></li>
<li id="fn3">Remark II.1.21 of <a href="#Reference-Mil2008" title="wikilink">Milne 2008</a><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
