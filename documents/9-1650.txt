   Concatenated error correction code      Concatenated error correction code   In coding theory , concatenated codes form a class of error-correcting codes that are derived by combining an inner code and an outer code . They were conceived in 1966 by Dave Forney as a solution to the problem of finding a code that has both exponentially decreasing error probability with increasing block length and polynomial-time decoding complexity . 1 Concatenated codes became widely used in space communications in the 1970s.  Background  The field of channel coding is concerned with sending a stream of data at the highest possible rate over a given communications channel , and then decoding the original data reliably at the receiver, using encoding and decoding algorithms that are feasible to implement in a given technology.  Shannon's channel coding theorem shows that over many common channels there exist channel coding schemes that are able to transmit data reliably at all rates   R   R   R   less than a certain threshold   C   C   C   , called the channel capacity of the given channel. In fact, the probability of decoding error can be made to decrease exponentially as the block length   N   N   N   of the coding scheme goes to infinity. However, the complexity of a naive optimum decoding scheme that simply computes the likelihood of every possible transmitted codeword increases exponentially with   N   N   N   , so such an optimum decoder rapidly becomes infeasible.  In his [ http://mitpress.mit.edu/catalog/item/default.asp?tid=5813&ttype; ;=2 doctoral thesis], Dave Forney showed that concatenated codes could be used to achieve exponentially decreasing error probabilities at all data rates less than capacity, with decoding complexity that increases only polynomially with the code block length.  Description  thumb|upright=2|Schematic depiction of a concatenated code built upon an inner code and an outer code.   Let C in be a [ n , k , d ] code, that is, a block code of length n , dimension  k , minimum Hamming distance  d , and rate  r = k / n , over an alphabet A :       C   i  n    :    A  k   →   A  n       normal-:   subscript  C    i  n     normal-→   superscript  A  k    superscript  A  n      C_{in}:A^{k}\rightarrow A^{n}   Let C out be a [ N , K , D ] code over an alphabet B with | B | = | A | k symbols:       C   o  u  t    :    B  K   →   B  N       normal-:   subscript  C    o  u  t     normal-→   superscript  B  K    superscript  B  N      C_{out}:B^{K}\rightarrow B^{N}   The inner code C in takes one of | A | k = | B | possible inputs, encodes into an n -tuple over A , transmits, and decodes into one of | B | possible outputs. We regard this as a (super) channel which can transmit one symbol from the alphabet B . We use this channel N times to transmit each of the N symbols in a codeword of C out . The concatenation of C out (as outer code) with C in (as inner code), denoted C out ∘ C in , is thus a code of length Nn over the alphabet A : 2        C   o  u  t    ∘   C   i  n     :    A   k  K    →   A   n  N        normal-:     subscript  C    o  u  t     subscript  C    i  n      normal-→   superscript  A    k  K     superscript  A    n  N       C_{out}\circ C_{in}:A^{kK}\rightarrow A^{nN}   It maps each input message m = ( m 1 , m 2 , ..., m K ) to a codeword ( C in ( m ' 1 ), C in ( m ' 2 ), ..., C in ( m ' N )), where ( m ' 1 , m ' 2 , ..., m ' N ) = C out ( m 1 , m 2 , ..., m K ).  The key insight in this approach is that if C in is decoded using a maximum-likelihood approach (thus showing an exponentially decreasing error probability with increasing length), and C out is a code with length N = 2 nr that can be decoded in polynomial time of N , then the concatenated code can be decoded in polynomial time of its combined length n 2 nr = O ( N ⋅log( N )) and shows an exponentially decreasing error probability, even if C in has exponential decoding complexity. 3 This is discussed in more detail in section Decoding concatenated codes .  In a generalization of above concatenation, there are N possible inner codes C in , i and the i -th symbol in a codeword of C out is transmitted across the inner channel using the i -th inner code. The Justesen codes are examples of generalized concatenated codes, where the outer code is a Reed–Solomon code .  Properties  1. The distance of the concatenated code C out ∘ C in is at least dD , that is, it is a [ nN , kK , D '] code with D ' ≥ dD .  Proof: Consider two different messages m 1 ≠ m 2 ∈ B K . Let Δ denote the distance between two codewords. Then        Δ   (    C   o  u  t     (   m  1   )    ,    C   o  u  t     (   m  2   )    )    ≥  D   .        normal-Δ      subscript  C    o  u  t     superscript  m  1       subscript  C    o  u  t     superscript  m  2      D    \Delta(C_{out}(m^{1}),C_{out}(m^{2}))\geq D.     Thus, there are at least D positions in which the sequence of N symbols of the codewords C out ( m 1 ) and C out ( m 2 ) differ. For these positions, denoted i , we have        Δ   (    C   i  n     (    C   o  u  t      (   m  1   )   i    )    ,    C   i  n     (    C   o  u  t      (   m  2   )   i    )    )    ≥  d   .        normal-Δ      subscript  C    i  n       subscript  C    o  u  t     subscript   superscript  m  1   i        subscript  C    i  n       subscript  C    o  u  t     subscript   superscript  m  2   i       d    \Delta(C_{in}(C_{out}(m^{1})_{i}),C_{in}(C_{out}(m^{2})_{i}))\geq d.     Consequently, there are at least d ⋅ D positions in the sequence of n ⋅ N symbols taken from the alphabet A in which the two codewords differ, and hence        Δ   (    C   i  n     (    C   o  u  t     (   m  1   )    )    ,    C   i  n     (    C   o  u  t     (   m  2   )    )    )    ≥   d  D    .        normal-Δ      subscript  C    i  n       subscript  C    o  u  t     superscript  m  1        subscript  C    i  n       subscript  C    o  u  t     superscript  m  2         d  D     \Delta(C_{in}(C_{out}(m^{1})),C_{in}(C_{out}(m^{2})))\geq dD.     2. If C out and C in are linear block codes , then C out ∘ C in is also a linear block code.  This property can be easily shown based on the idea of defining a generator matrix for the concatenated code in terms of the generator matrices of C out and C in .  Decoding concatenated codes  A natural concept for a decoding algorithm for concatenated codes is to ﬁrst decode the inner code and then the outer code. For the algorithm to be practical it must be polynomial-time in the final block length. Consider that there is a polynomial-time unique decoding algorithm for the outer code. Now we have to find a polynomial-time decoding algorithm for the inner code. It is understood that polynomial running time here means that running time is polynomial in the final block length. The main idea is that if the inner block length is selected to be logarithmic in the size of the outer code then the decoding algorithm for the inner code may run in exponential time of the inner block length, and we can thus use an exponential-time but optimal maximum likelihood decoder (MLD) for the inner code.  In detail, let the input to the decoder be the vector y = ( y 1 , ..., y N ) ∈ ( A n ) N . Then the decoding algorithm is a two-step process:   Use the MLD of the inner code C in to reconstruct a set of inner code words y ' = ( y ' 1 , ..., y ' N ), with y ' i = MLD C in ( y i ), 1 ≤ i ≤ N .  Run the unique decoding algorithm for C out on y '.   Now, the time complexity of the first step is O ( N ⋅exp( n )), where n = O (log( N )) is the inner block length. In other words, it is N O (1) (i.e., polynomial-time) in terms of the outer block length N . As the outer decoding algorithm in step two is assumed to run in polynomial time the complexity of the overall decoding algorithm is polynomial-time as well.  Remarks  The decoding algorithm described above can be used to correct all errors up to less than dD /4 in number. Using minimum distance decoding , the outer decoder can correct all inputs y ' with less than D /2 symbols y ' i in error. Similarly, the inner code can reliably correct an input y i if less than d /2 inner symbols are erroneous. Thus, for an outer symbol y ' i to be incorrect after inner decoding at least d /2 inner symbols must have been in error, and for the outer code to fail this must have happened for at least D /2 outer symbols. Consequently, the total number of inner symbols that must be received incorrectly for the concatenated code to fail must be at least d /2⋅ D /2 = dD /4.  The algorithm also works if the inner codes are different, e.g., for Justesen codes . The generalized minimum distance algorithm , developed by Forney, can be used to correct up to dD /2 errors. 4 It uses erasure information from the inner code to improve performance of the outer code, and was the first example of an algorithm using soft-decision decoding . 5 6  Applications  Although a simple concatenation scheme was implemented already for the 1971 Mariner Mars orbiter mission, 7 concatenated codes were starting to be regularly used for deep space communication with the Voyager program , which launched two space probes in 1977. 8 Since then, concatenated codes became the workhorse for efficient error correction coding, and stayed so at least until the invention of turbo codes and LDPC codes . 9 10  Typically, the inner code is not a block code but a soft-decision  convolutional  Viterbi-decoded code with a short constraint length. 11 For the outer code, a longer hard-decision block code, frequently a Reed-Solomon code with eight-bit symbols, is used. 12 13 The larger symbol size makes the outer code more robust to error bursts that can occur due to channel impairments, and also because erroneous output of the convolutional code itself is bursty. 14 15 An interleaving layer is usually added between the two codes to spread error bursts across a wider range. 16  The combination of an inner Viterbi convolutional code with an outer Reed–Solomon code (known as an RSV code) was first used in Voyager 2 , 17 18 and it became a popular construction both within and outside of the space sector. It is still notably used today for satellite communications , such as the DVB-S  digital television broadcast standard. 19  In a looser sense, any (serial) combination of two or more codes may be referred to as a concatenated code. For example, within the DVB-S2 standard, a highly efficient LDPC code is combined with an algebraic outer code in order to remove any resilient errors left over from the inner LDPC code due to its inherent error floor . 20  A simple concatenation scheme is also used on the compact disc (CD), where an interleaving layer between two Reed–Solomon codes of different sizes spreads errors across various blocks.  Turbo codes: A parallel concatenation approach  The description above is given for what is now called a serially concatenated code. Turbo codes , as described first in 1993, implemented a parallel concatenation of two convolutional codes, with an interleaver between the two codes and an iterative decoder that passes information forth and back between the codes. 21 This design has a better performance than any previously conceived concatenated codes.  However, a key aspect of turbo codes is their iterated decoding approach. Iterated decoding is now also applied to serial concatenations in order to achieve higher coding gains, such as within serially concatenated convolutional codes (SCCCs). An early form of iterated decoding was implemented with two to five iterations in the "Galileo code" of the Galileo space probe . 22  See also   Justesen code  Zyablov bound  Singleton bound  Gilbert–Varshamov bound   References  Further reading      External links    University at Buffalo Lecture Notes on Coding Theory – Dr. Atri Rudra   "  Category:Error detection and correction  Category:Coding theory  Category:Finite fields  Category:Information theory     ↩    ↩  ↩  ↩   K. Andrews et al., The Development of Turbo and LDPC Codes for Deep-Space Applications , Proceedings of the IEEE, Vol. 95, No. 11, Nov. 2007. ↩    ↩   ↩      R. Ludwig, J. Taylor, Voyager Telecommunications Manual , JPL DESCANSO (Design and Performance Summary Series) , March 2002. ↩  Digital Video Broadcasting (DVB); Framing structure, channel coding and modulation for 11/12 GHz satellite services , ETSI EN 300 421, V1.1.2, August 1997. ↩  Digital Video Broadcasting (DVB); Second generation framing structure, channel coding and modulation systems for Broadcasting, Interactive Services, News Gathering and other broadband satellite applications (DVB-S2) , ETSI EN 302 307, V1.2.1, April 2009. ↩       