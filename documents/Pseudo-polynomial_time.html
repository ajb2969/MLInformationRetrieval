<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1941">Pseudo-polynomial time</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Pseudo-polynomial time</h1>
<hr/>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, a numeric algorithm runs in <strong>pseudo-polynomial time</strong> if its <a href="Computation_time" title="wikilink">running time</a> is <a class="uri" href="polynomial" title="wikilink">polynomial</a> in the <em>numeric value</em> of the input, but is exponential in the <em>length</em> of the input – the number of bits required to represent it.</p>

<p>An <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> problem with known pseudo-polynomial time algorithms is called <a href="weakly_NP-complete" title="wikilink">weakly NP-complete</a>. An <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> problem is called <a href="strongly_NP-complete" title="wikilink">strongly NP-complete</a> if it is proven that it cannot be solved by a pseudo-polynomial time algorithm unless <a class="uri" href="P=NP" title="wikilink">P=NP</a>. The strong/weak kinds of <a href="NP-hard" title="wikilink">NP-hardness</a> are defined analogously.</p>
<h2 id="example">Example</h2>

<p>Consider the problem of <a href="Primality_test" title="wikilink">testing whether a number <em>n</em> is prime</a>, by naively checking whether no number in 

<math display="inline" id="Pseudo-polynomial_time:0">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mn>3</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msqrt>
    <mi>n</mi>
   </msqrt>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">2</cn>
    <cn type="integer">3</cn>
    <ci>normal-…</ci>
    <apply>
     <root></root>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{2,3,\dots,\sqrt{n}\}
  </annotation>
 </semantics>
</math>

 divides 

<math display="inline" id="Pseudo-polynomial_time:1">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 evenly. This approach can take up to  divisions, which is sub-linear in the <em>value of n</em> but exponential in the <em>length of n</em> (which is about 

<math display="inline" id="Pseudo-polynomial_time:2">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log(n)
  </annotation>
 </semantics>
</math>

). For example, a number <em>n</em> slightly less than  would require up to approximately 100,000 divisions, even though the length of <em>n</em> is only 10 digits. Moreover one can easily write down an input (say, a 300-digit number) for which this algorithm is impractical. Since computational complexity measures difficulty with respect to the <em>length</em> of the (encoded) input, this naive algorithm is actually exponential. It <em>is</em>, however, pseudo-polynomial time.</p>

<p>Contrast this algorithm with a true polynomial numeric algorithm — say, the straightforward algorithm for addition: Adding two 9-digit numbers takes around 9 simple steps, and in general the algorithm is truly linear in the length of the input. Compared with the actual numbers being added (in the billions), the algorithm could be called "pseudo-logarithmic time", though such a term is not standard. Thus, adding 300-digit numbers is not impractical. Similarly, long division is quadratic: an <em>m</em>-digit number can be divided by a <em>n</em>-digit number in 

<math display="inline" id="Pseudo-polynomial_time:3">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>m</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(mn)
  </annotation>
 </semantics>
</math>


 steps (see <a href="Big_O_notation" title="wikilink">Big O notation</a>.)</p>

<p>In the case of primality, it turns out there is a different algorithm for <a href="AKS_primality_test" title="wikilink">testing whether <em>n</em> is prime</a> (discovered in 2002) which runs in time 

<math display="inline" id="Pseudo-polynomial_time:4">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>6</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
     <cn type="integer">6</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O((\log{n})^{6})
  </annotation>
 </semantics>
</math>

.</p>

<p>Another example of a problem which can be generally only solved in pseudo-polynomial time is the <a href="Knapsack_problem" title="wikilink">Knapsack problem</a>–unless P=NP.</p>
<h2 id="generalizing-to-non-numeric-problems">Generalizing to non-numeric problems</h2>

<p>Although the notion of pseudo-polynomial time is used almost exclusively for numeric problems, the concept can be generalized: The function <em>m</em> is pseudo-polynomial if <em>m</em>(<em>n</em>) is no greater than a <a href="polynomial_function" title="wikilink">polynomial function</a> of the <a href="problem_size" title="wikilink">problem size</a> <em>n</em> and an additional property of the input, <em>k</em>(<em>n</em>). (Presumably, <em>k</em> is chosen to be something relevant to the problem.) This makes numeric polynomial problems a special case by taking <em>k</em> to be the number of (binary) digits of the input.</p>

<p>The distinction between the value of a number and its length is one of encoding: if numeric inputs are always encoded in <a href="Unary_numeral_system" title="wikilink">unary</a>, then <em>pseudo-polynomial</em> would coincide with <em>polynomial</em>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Strongly_NP-complete" title="wikilink">Strongly NP-complete</a></li>
<li><a href="Quasi-polynomial_time" title="wikilink">Quasi-polynomial time</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>M. R. Garey and D. S. Johnson. <a href="Computers_and_Intractability:_A_Guide_to_the_Theory_of_NP-Completeness" title="wikilink">Computers and Intractability: A Guide to the Theory of NP-Completeness</a>. W.H. Freeman and Company, 1979.</li>
</ul>
<references>
</references>

<p>"</p>

<p><a href="Category:Analysis_of_algorithms" title="wikilink">Category:Analysis of algorithms</a> <a href="Category:Complexity_classes" title="wikilink">Category:Complexity classes</a> <a href="Category:Computational_complexity_theory" title="wikilink">Category:Computational complexity theory</a> <a href="Category:Pseudo-polynomial_time_algorithms" title="wikilink">Category:Pseudo-polynomial time algorithms</a></p>
</body>
</html>
