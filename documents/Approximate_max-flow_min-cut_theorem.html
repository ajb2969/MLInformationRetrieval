<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1429">Approximate max-flow min-cut theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Approximate max-flow min-cut theorem</h1>
<hr/>
<h2 id="muticommodity-flow-problem">Muticommodity flow problem</h2>

<p>A commodity is a pair of source and sink nodes in a network flow problem. For detailed definition of multicommodity flow problem, see <a href="Multi-commodity_flow_problem" title="wikilink">Multi-commodity flow problem</a>. In a multicommodity flow problem, there are 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:0">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

≥1 commodities, each with its own source 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:1">
 <semantics>
  <msub>
   <mi>s</mi>
   <mtext>i</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <mtext>i</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{\text{i}}
  </annotation>
 </semantics>
</math>

, sink 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:2">
 <semantics>
  <msub>
   <mi>t</mi>
   <mtext>i</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <mtext>i</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{\text{i}}
  </annotation>
 </semantics>
</math>

, and demand 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:3">
 <semantics>
  <msub>
   <mi>D</mi>
   <mtext>i</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <mtext>i</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{\text{i}}
  </annotation>
 </semantics>
</math>

. The objective is to simultaneously route 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:4">
 <semantics>
  <msub>
   <mi>D</mi>
   <mtext>i</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <mtext>i</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{\text{i}}
  </annotation>
 </semantics>
</math>

 units of commodity 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:5">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:6">
 <semantics>
  <msub>
   <mi>s</mi>
   <mtext>i</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <mtext>i</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{\text{i}}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:7">
 <semantics>
  <msub>
   <mi>t</mi>
   <mtext>i</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <mtext>i</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{\text{i}}
  </annotation>
 </semantics>
</math>

 for each 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:8">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, such that the total amount of all commodities passing through any edge is no greater than its capacity. (In the case of undirected edges, the sum of the flows in both directions can't exceed the capacity of the edge.).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Specially, a 1-commodity (or single commodity) flow problem is also known as a maximum flow problem (see <a href="Maximum_flow_problem" title="wikilink">Maximum flow problem</a>). According to the famous Ford–Fulkerson algorithm (see <a href="Ford–Fulkerson_algorithm" title="wikilink">Ford–Fulkerson algorithm</a>),the max-flow and min-cut are always equal in a 1-commodity flow problem.</p>
<h3 id="max-flow-and-min-cut">Max-flow and min-cut</h3>

<p>In a multicommodity flow problem, <em>max-flow</em> is the maximum value of 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:9">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:10">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is the common fraction of each commodity that is routed, such that 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:11">
 <semantics>
  <mrow>
   <mi>f</mi>
   <msub>
    <mi>D</mi>
    <mtext>i</mtext>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <mtext>i</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   fD_{\text{i}}
  </annotation>
 </semantics>
</math>

 units of commodity 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:12">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 can be simultaneously routed for each 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:13">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 without violating any capacity constraints. <em>min-cut</em> is the minimum of all cuts of the ratio 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:14">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 of the capacity of the cut to the demand of the cut. Max-flow is always upper bounded by the min-cut for a multicommodify flow problem.</p>
<h3 id="uniform-multicommodity-flow-problem">Uniform multicommodity flow problem</h3>

<p>In a uniform multicommodity flow problem, there is a commodity for every pair of nodes and the demand for every commodity is the same. (Without loss of generality, the demand for every commodity is set to one.) The underlying network and capacities are arbitrary.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h3 id="product-multicommodity-flow-problem">Product multicommodity flow problem</h3>

<p>In a product multicommodity flow problem, there is a nonnegative weight for each node 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:15">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in V
  </annotation>
 </semantics>
</math>

 in graph 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:16">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

. The demand for the commodity between nodes 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:17">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:18">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 is the product of the weights of node 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:19">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 and node 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:20">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

. The uniform multicommodity flow problem is a special case of the product multicommodity flow problem for which the weight is set to 1 for all nodes 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:21">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>∈</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>u</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\in V
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h3 id="duality-of-linear-programming">Duality of linear programming</h3>

<p>In general, the dual of a multicommodity flow problem for a graph 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:22">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is the problem of apportioning a fixed amount of weight (where weights can be considered as distances) to the edges of 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:23">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 such that to maximize the cumulative distance between the source and sink pairs.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> (See <a href="Linear_programming" title="wikilink">Linear programming</a> for detailed introduction of the duality of linear programming.)</p>
<h3 id="history">History</h3>

<p>The research on the relationship between the max-flow and min-cut of multicommodity flow problem has obtained great interest since Ford and Fulkterson's result for 1-commodity flow problems. Hu <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> showed that the max-flow and min-cut are always equal for two commodities. Okamura and Seymour <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> illustrated a 4-commodity flow problem with max-flow equals to 3/4 and min-cut equals 1. Shahrokhi and Matula <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> also proved that the max-flow and min-cut are equal provided the dual of the flow problem satisfies a certain cut condition in a uniform multicommodity flow problem. Many other researchers also showed concrete research results in similar problems <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> <a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> <a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>For a general network flow problem, the max-flow is within a factor of 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:24">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 of the min-cut since each commodity can be optimized separately using 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:25">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/k
  </annotation>
 </semantics>
</math>

 of the capacity of each edge. This is not a good result especially in case of large numbers of commodities.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h2 id="approximate-max-flow-min-cut-theorems">Approximate max-flow min-cut theorems</h2>
<h3 id="theorems-of-uniform-multicommodity-flow-problems">Theorems of uniform multicommodity flow problems</h3>

<p>There are two theorems first introduced by Tom Leighton and Satish Rao in 1988 <a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> and then extended in 1999.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> Theorem 2 gives a tighter bound compared to Theorem 1.</p>

<p><strong>Theorem 1.</strong> <em>For any 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:26">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, there is an 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:27">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-node uniform multicommodity flow problem with max-flow 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:28">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and min-cut 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:29">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 for which 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:30">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>≤</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mfrac>
      <mi>φ</mi>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
     </mfrac>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>f</ci>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <divide></divide>
      <ci>φ</ci>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\leq O(\frac{\varphi}{\log n})
  </annotation>
 </semantics>
</math>

.</em><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p><strong>Theorem 2.</strong> <em>For any uniform multicommodity flow problem, 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:31">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Ω</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mfrac>
      <mi>φ</mi>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
     </mfrac>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>f</mi>
   <mo>≤</mo>
   <mi>φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <ci>normal-Ω</ci>
      <apply>
       <divide></divide>
       <ci>φ</ci>
       <apply>
        <log></log>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <ci>f</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>φ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(\frac{\varphi}{\log n})\leq f\leq\varphi
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:32">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is the max-flow and 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:33">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 is the min-cut of the uniform multicommodity flow problem.</em><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>To prove Theorem 2, both the max-flow and the min-cut should be discussed. For the max-flow, the techniques from duality theory of linear programming have to be employed. According to the duality theory of linear programming, an optimal distance function results in a total weight that is equal to the max-flow of the uniform multicommodity flow problem. For the min-cut, a 3-stage process has to be followed:<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p>Stage 1: Consider the dual of uniform commodity flow problem and use the optimal solution to define a graph with distance labels on the edges.</p>

<p>Stage 2: Starting from a source or a sink, grow a region in the graph until find a cut of small enough capacity separating the root from its mate.</p>

<p>Stage 3: Remove the region and repeat the process of stage 2 until all nodes get processed.</p>
<h3 id="generalized-to-product-multicommodity-flow-problem">Generalized to product multicommodity flow problem</h3>

<p><strong>Theorem 3.</strong> <em>For any product multicommodity flow problem with 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:34">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 commodities, 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:35">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Ω</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mfrac>
      <mi>φ</mi>
      <mrow>
       <mi>log</mi>
       <mi>k</mi>
      </mrow>
     </mfrac>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>f</mi>
   <mo>≤</mo>
   <mi>φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <ci>normal-Ω</ci>
      <apply>
       <divide></divide>
       <ci>φ</ci>
       <apply>
        <log></log>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <ci>f</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>φ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(\frac{\varphi}{\log k})\leq f\leq\varphi
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:36">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is the max-flow and 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:37">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 is the min-cut of the product multicommodity flow problem.</em> <a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>

<p>The proof methodology is similar as it is for Theorem 2, the major difference is to take node weights into consideration.</p>
<h3 id="extended-to-directed-multicommodity-flow-problem">Extended to directed multicommodity flow problem</h3>

<p>In a directed multicommodity flow problem, each edge has a direction, and the flow is restricted to move in the specified direction. In a directed uniform multicommodity flow problem, the demand is set to 1 for every directed edge.</p>

<p><strong>Theorem 4.</strong> <em>For any directed uniform multicommodity flow problem with 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:38">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 nodes, 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:39">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Ω</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mfrac>
      <mi>φ</mi>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
     </mfrac>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>f</mi>
   <mo>≤</mo>
   <mi>φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <ci>normal-Ω</ci>
      <apply>
       <divide></divide>
       <ci>φ</ci>
       <apply>
        <log></log>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <ci>f</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>φ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(\frac{\varphi}{\log n})\leq f\leq\varphi
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:40">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is the max-flow and 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:41">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 is the min-cut of the uniform multicommodity flow problem.</em> <a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>The major difference in the proof methodology compared to Theorem 2 is that, now the edge directions need to be considered when defining distance labels in stage 1 and for growing the regions in stage 2, more details can be found in.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>

<p>Similarly, for product multicommodity flow problem, we have the following extended theorem:</p>

<p><strong>Theorem 5.</strong> <em>For any directed product multicommodity flow problem with 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:42">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 commodities, 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:43">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Ω</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mfrac>
      <mi>φ</mi>
      <mrow>
       <mi>log</mi>
       <mi>k</mi>
      </mrow>
     </mfrac>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>f</mi>
   <mo>≤</mo>
   <mi>φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <ci>normal-Ω</ci>
      <apply>
       <divide></divide>
       <ci>φ</ci>
       <apply>
        <log></log>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <ci>f</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>φ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(\frac{\varphi}{\log k})\leq f\leq\varphi
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:44">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is the max-flow and 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:45">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 is the directed min-cut of the product multicommodity flow problem.</em> <a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>
<h2 id="applications-to-approximation-algorithms">Applications to approximation algorithms</h2>

<p>The above theorems are very useful to design approximation algorithms (see <a href="Approximation_algorithm" title="wikilink">Approximation algorithm</a>) for NP-hard problems (see <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>), such as the graph partition problem and its variations (see <a href="Graph_partition" title="wikilink">Graph partition</a>). Here below we briefly introduce a few examples, and the in-depth elaborations can be found in:<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>
<h3 id="sparsest-cuts">Sparsest cuts</h3>

<p>A sparsest cut of a graph 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:46">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

 is a partition for which the ratio of the number of edges connecting the two partitioned components over the product of the numbers of nodes of both components. This is a NP-hard problem, and it can be approximated to within 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:47">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log n)
  </annotation>
 </semantics>
</math>

 factor using Theorem 2. Also, a sparsest cut problem with weighted edges, weighted nodes or directed edges can be approximated within an 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:48">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>p</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log p)
  </annotation>
 </semantics>
</math>

 factor where 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:49">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is the number of nodes with nonzero weight according to Theorem 3, 4 and 5.</p>
<h3 id="balanced-cuts-and-separators">Balanced cuts and separators</h3>

<p>In some applications, we want to find a small cut in a graph 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:50">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

 that partitions the graph into nearly equal-size pieces. We usually call a cut <em>b-balanced</em> or a (<em>b</em>,1 − <em>b</em>)-<em>separator</em> (for <em>b</em> ≤ 1/2) if 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:51">
 <semantics>
  <mrow>
   <mrow>
    <mi>b</mi>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>V</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>U</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>V</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <ci>b</ci>
      <ci>π</ci>
      <ci>V</ci>
     </apply>
     <apply>
      <times></times>
      <ci>π</ci>
      <ci>U</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>b</ci>
      </apply>
      <ci>π</ci>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\pi(V)\leq\pi(U)\leq(1-b)\pi(V)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:52">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>U</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(U)
  </annotation>
 </semantics>
</math>

 is the sum of the node weights in 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:53">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

. This is also an NP-hard problem. In,<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> there is an approximation algorithm designed for this problem, and the core idea is that 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:54">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 has a <em>b</em>-balanced cut of size 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:55">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, then we find a <em>b</em>′-balanced cut of size 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:56">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>S</mi>
      <mrow>
       <mi>log</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>/</mo>
         <mi>b</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>-</mo>
     <msup>
      <mi>b</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <log></log>
       <apply>
        <divide></divide>
        <ci>n</ci>
        <ci>b</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(S\log(n/b)-b^{\prime})
  </annotation>
 </semantics>
</math>

 for any b' where <em>b</em>′ O(\frac{S\log n}{b-b'}).</p>
<h3 id="vlsi-layout-problems">VLSI layout problems</h3>

<p>It's helpful to find a layout of minimum size when designing a VLSI circuit, such problem can often be modeled as a graph embedding problem. The objective is to find an embedding for which the layout area is minimized. Finding the minimum layout area is also NP-hard. An approximation algorithm is introduced in <a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> and the result is 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:57">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>log</mi>
      <mn>6</mn>
     </msup>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <log></log>
      <cn type="integer">6</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log^{6}n)
  </annotation>
 </semantics>
</math>

 times optimal.</p>
<h3 id="forwarding-index-problem">Forwarding index problem</h3>

<p>Given an 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:58">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-node graph 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:59">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 and an embedding of 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:60">
 <semantics>
  <msub>
   <mi>K</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{n}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:61">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, Chung et al. <a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> defined the <em>forwarding index</em> of the embedding to be the maximum number of paths (each corresponding to an edge of 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:62">
 <semantics>
  <msub>
   <mi>K</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{n}
  </annotation>
 </semantics>
</math>

) that pass through any node of 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:63">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

. The objective is to find an embedding that minimizes the forwarding index. According to the embedding approaches introduced in,<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> it is possible to bound the node and edge-forwarding indices to within an 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:64">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log n)
  </annotation>
 </semantics>
</math>

-factor for every graph 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:65">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="planar-edge-deletion">Planar edge deletion</h3>

<p>Tragoudas<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> uses the approximation algorithm for balanced separators to find a set of 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:66">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>R</mi>
        <mrow>
         <mi>log</mi>
         <mi>n</mi>
        </mrow>
       </mrow>
       <mo>+</mo>
       <msqrt>
        <mrow>
         <mi>n</mi>
         <mi>R</mi>
        </mrow>
       </msqrt>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi>log</mi>
      <mfrac>
       <mi>n</mi>
       <mi>R</mi>
      </mfrac>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>R</ci>
       <apply>
        <log></log>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <root></root>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>R</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <log></log>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <ci>R</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O((R\log n+\sqrt{nR})\log\frac{n}{R})
  </annotation>
 </semantics>
</math>

 edges whose removal from a bounded-degree graph 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:67">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 results in a planar graph, where 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:68">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is the minimum number of edges that need to be removed from 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:69">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 before it becomes planar. It remains an open question if there is a polylog 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:70">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 times optimal approximation algorithm for 

<math display="inline" id="Approximate_max-flow_min-cut_theorem:71">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Multi-commodity_flow_problem" title="wikilink">Multi-commodity flow problem</a></li>
<li><a href="Linear_programming" title="wikilink">Linear programming</a></li>
<li><a href="Ford–Fulkerson_algorithm" title="wikilink">Ford–Fulkerson algorithm</a></li>
<li><a href="Max-flow_min-cut_theorem" title="wikilink">Max-flow min-cut theorem</a></li>
<li><a href="Maximum_flow_problem" title="wikilink">Maximum flow problem</a></li>
<li><a href="Minimum_cut" title="wikilink">Minimum cut</a></li>
<li><a href="Flow_network" title="wikilink">Flow network</a></li>
<li><a href="Approximation_algorithm" title="wikilink">Approximation algorithm</a></li>
<li><a class="uri" href="NP-hard" title="wikilink">NP-hard</a></li>
<li><a href="Graph_partition" title="wikilink">Graph partition</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Network_flow" title="wikilink">Category:Network flow</a> <a href="Category:Mathematical_theorems" title="wikilink">Category:Mathematical theorems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24"></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"></li>
</ol>
</section>
</body>
</html>
