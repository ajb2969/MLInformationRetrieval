<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="702">Min entropy</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Min entropy</h1>
<hr/>

<p><strong>The min entropy,</strong> in <a href="information_theory" title="wikilink">information theory</a>, is the smallest of the <a href="Rényi_entropy" title="wikilink">Rényi family</a> of entropies, corresponding to the <a href="Rényi_entropy#Min-entropy" title="wikilink">most conservative</a> way of measuring the unpredictability of a set of outcomes, as the negative logarithm of the probability of the <em>most likely</em> outcome. The various Rényi entropies are all equal for a uniform distribution, but measure the unpredictability of a nonuniform distribution in different ways. The min entropy is never greater than the ordinary or <a href="Shannon_entropy" title="wikilink">Shannon entropy</a> (which measures the average unpredictability of the outcomes) and that in turn is never greater than the Hartley or <a href="Rényi_entropy#Hartley_entropy" title="wikilink">max entropy</a>, defined as the logarithm of the <em>number</em> of outcomes.</p>

<p>As with the classical Shannon entropy and its quantum generalization, the von Neumann entropy, one can define a conditional versions of min entropy. The conditional quantum min entropy is a one-shot, or conservative, analog of <a href="conditional_quantum_entropy" title="wikilink">conditional quantum entropy</a>.</p>

<p>To interpret a conditional information measure, suppose Alice and Bob were to share a bipartite quantum state 

<math display="inline" id="Min_entropy:0">
 <semantics>
  <msub>
   <mi>ρ</mi>
   <mrow>
    <mi>A</mi>
    <mi>B</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ρ</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{AB}
  </annotation>
 </semantics>
</math>

. Alice has access to system A and Bob to system B. The conditional entropy measures the average uncertainty Bob has about Alice's state upon sampling from his own system. The min entropy can be interpreted as the distance of a state from a maximally entangled state.</p>

<p>This concept is useful in quantum cryptography, in the context of privacy amplification (See for example <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>).</p>
<h2 id="definitions">Definitions</h2>

<p>Definition: Let 

<math display="inline" id="Min_entropy:1">
 <semantics>
  <msub>
   <mi>ρ</mi>
   <mrow>
    <mi>A</mi>
    <mi>B</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ρ</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{AB}
  </annotation>
 </semantics>
</math>

 be a bipartite density operator on the space 

<math display="inline" id="Min_entropy:2">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
    <mi>A</mi>
   </msub>
   <mo>⊗</mo>
   <msub>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
    <mi>B</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℋ</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℋ</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}_{A}\otimes\mathcal{H}_{B}
  </annotation>
 </semantics>
</math>

. The min-entropy of A conditioned on B is defined to be</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Min_entropy:3">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>min</mi>
   </msub>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">|</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ρ</mi>
   </msub>
   <mo>≡</mo>
   <mo>-</mo>
   <msub>
    <mo>inf</mo>
    <msub>
     <mi>σ</mi>
     <mi>B</mi>
    </msub>
   </msub>
   <msub>
    <mi>D</mi>
    <mi>max</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ρ</mi>
     <mrow>
      <mi>A</mi>
      <mi>B</mi>
     </mrow>
    </msub>
    <mo stretchy="false">|</mo>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>I</mi>
     <mi>A</mi>
    </msub>
    <mo>⊗</mo>
    <msub>
     <mi>σ</mi>
     <mi>B</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <min></min>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>ρ</ci>
    </apply>
    <equivalent></equivalent>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">infimum</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <max></max>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <ci>normal-|</ci>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>A</ci>
     </apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>B</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{\min}(A|B)_{\rho}\equiv-\inf_{\sigma_{B}}D_{\max}(\rho_{AB}||I_{A}\otimes%
\sigma_{B})
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where the infimum ranges over all density operators 

<math display="inline" id="Min_entropy:4">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>B</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{B}
  </annotation>
 </semantics>
</math>

 on the space 

<math display="inline" id="Min_entropy:5">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   <mi>B</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ℋ</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}_{B}
  </annotation>
 </semantics>
</math>

. The measure 

<math display="inline" id="Min_entropy:6">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>max</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <max></max>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{\max}
  </annotation>
 </semantics>
</math>

 is the maximum relative entropy defined as</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Min_entropy:7">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mi>max</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ρ</mi>
    <mo stretchy="false">|</mo>
    <mo stretchy="false">|</mo>
    <mi>σ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mo>inf</mo>
    <mi>λ</mi>
   </msub>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>λ</mi>
    <mo>:</mo>
    <mi>ρ</mi>
    <mo>≤</mo>
    <msup>
     <mn>2</mn>
     <mi>λ</mi>
    </msup>
    <mi>σ</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <max></max>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ρ</csymbol>
     <ci>normal-|</ci>
     <ci>normal-|</ci>
     <csymbol cd="unknown">σ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">infimum</csymbol>
     <ci>λ</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">λ</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">ρ</csymbol>
     <leq></leq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>λ</ci>
     </apply>
     <csymbol cd="unknown">σ</csymbol>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{\max}(\rho||\sigma)=\inf_{\lambda}\{\lambda:\rho\leq 2^{\lambda}\sigma\}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>The smooth min entropy is defined in terms of the min entropy.</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Min_entropy:8">
 <semantics>
  <mrow>
   <msubsup>
    <mi>H</mi>
    <mi>min</mi>
    <mi>ϵ</mi>
   </msubsup>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">|</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ρ</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mo>sup</mo>
    <msup>
     <mi>ρ</mi>
     <mo>′</mo>
    </msup>
   </msub>
   <msub>
    <mi>H</mi>
    <mi>min</mi>
   </msub>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">|</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msup>
     <mi>ρ</mi>
     <mo>′</mo>
    </msup>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <min></min>
     </apply>
     <ci>ϵ</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>ρ</ci>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">supremum</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ρ</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <min></min>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ρ</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{\min}^{\epsilon}(A|B)_{\rho}=\sup_{\rho^{\prime}}H_{\min}(A|B)_{\rho^{%
\prime}}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where the sup and inf range over density operators 

<math display="inline" id="Min_entropy:9">
 <semantics>
  <msubsup>
   <mi>ρ</mi>
   <mrow>
    <mi>A</mi>
    <mi>B</mi>
   </mrow>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ρ</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho^{\prime}_{AB}
  </annotation>
 </semantics>
</math>

 which are 

<math display="inline" id="Min_entropy:10">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

-close to 

<math display="inline" id="Min_entropy:11">
 <semantics>
  <msub>
   <mi>ρ</mi>
   <mrow>
    <mi>A</mi>
    <mi>B</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ρ</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{AB}
  </annotation>
 </semantics>
</math>

. This measure of 

<math display="inline" id="Min_entropy:12">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

-close is defined in terms of the purified distance</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Min_entropy:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ρ</mi>
     <mo>,</mo>
     <mi>σ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msqrt>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <mi>F</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ρ</mi>
        <mo>,</mo>
        <mi>σ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <interval closure="open">
      <ci>ρ</ci>
      <ci>σ</ci>
     </interval>
    </apply>
    <apply>
     <root></root>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>F</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <interval closure="open">
         <ci>ρ</ci>
         <ci>σ</ci>
        </interval>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\rho,\sigma)=\sqrt{1-F(\rho,\sigma)^{2}}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where 

<math display="inline" id="Min_entropy:14">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ρ</mi>
    <mo>,</mo>
    <mi>σ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <interval closure="open">
     <ci>ρ</ci>
     <ci>σ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\rho,\sigma)
  </annotation>
 </semantics>
</math>

 is the <a href="fidelity_of_quantum_states" title="wikilink">fidelity</a> measure.</p>

<p>These quantities can be seen as generalizations of the <a href="von_Neumann_entropy" title="wikilink">von Neumann entropy</a>. Indeed, the von Neumann entropy can be expressed as</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Min_entropy:15">
 <semantics>
  <mrow>
   <mi>S</mi>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">|</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ρ</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mo>lim</mo>
    <mrow>
     <mi>ϵ</mi>
     <mo>→</mo>
     <mn>0</mn>
    </mrow>
   </msub>
   <msub>
    <mo>lim</mo>
    <mrow>
     <mi>n</mi>
     <mo>→</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
   </msub>
   <mfrac>
    <mn>1</mn>
    <mi>n</mi>
   </mfrac>
   <msubsup>
    <mi>H</mi>
    <mi>min</mi>
    <mi>ϵ</mi>
   </msubsup>
   <mpadded width="+3.3pt">
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>A</mi>
       <mi>n</mi>
      </msup>
      <mo stretchy="false">|</mo>
      <msup>
       <mi>B</mi>
       <mi>n</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>ρ</mi>
      <mrow>
       <mi></mi>
       <mo>⊗</mo>
       <mi>n</mi>
      </mrow>
     </msup>
    </msub>
   </mpadded>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>ρ</ci>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <limit></limit>
     <apply>
      <ci>normal-→</ci>
      <ci>ϵ</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <limit></limit>
     <apply>
      <ci>normal-→</ci>
      <ci>n</ci>
      <infinity></infinity>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <min></min>
     </apply>
     <ci>ϵ</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <ci>n</ci>
      </apply>
      <ci>normal-|</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>n</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ρ</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(A|B)_{\rho}=\lim_{\epsilon\rightarrow 0}\lim_{n\rightarrow\infty}\frac{1}{n}%
H_{\min}^{\epsilon}(A^{n}|B^{n})_{\rho^{\otimes n}}~{}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>This is called the fully quantum asymptotic equipartition theorem.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The smoothed entropies share many interesting properties with the von Neumann entropy. For example, the smooth min entropy satisfy a data-processing inequality: <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Min_entropy:16">
 <semantics>
  <mrow>
   <msubsup>
    <mi>H</mi>
    <mi>min</mi>
    <mi>ϵ</mi>
   </msubsup>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">|</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ρ</mi>
   </msub>
   <mo>≥</mo>
   <msubsup>
    <mi>H</mi>
    <mi>min</mi>
    <mi>ϵ</mi>
   </msubsup>
   <mpadded width="+3.3pt">
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">|</mo>
      <mi>B</mi>
      <mi>C</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>ρ</mi>
    </msub>
   </mpadded>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <min></min>
     </apply>
     <ci>ϵ</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>ρ</ci>
    </apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <min></min>
     </apply>
     <ci>ϵ</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">B</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>ρ</ci>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{\min}^{\epsilon}(A|B)_{\rho}\geq H_{\min}^{\epsilon}(A|BC)_{\rho}~{}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<h2 id="operational-interpretation-of-smoothed-min-entropy">Operational interpretation of smoothed min entropy</h2>

<p>Henceforth, we shall drop the subscript 

<math display="inline" id="Min_entropy:17">
 <semantics>
  <mi>ρ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

 from the min entropy when it is obvious from the context on what state it is evaluated.</p>
<h3 id="min-entropy-as-uncertainty-about-classical-information">Min-entropy as uncertainty about classical information</h3>

<p>Suppose an agent had access to a quantum system B whose state 

<math display="inline" id="Min_entropy:18">
 <semantics>
  <msubsup>
   <mi>ρ</mi>
   <mi>B</mi>
   <mi>x</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ρ</ci>
     <ci>B</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{B}^{x}
  </annotation>
 </semantics>
</math>

 depends on some classical variable X. Furthermore, suppose that each of its elements 

<math display="inline" id="Min_entropy:19">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is distributed according to some distribution 

<math display="inline" id="Min_entropy:20">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>X</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>X</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{X}(x)
  </annotation>
 </semantics>
</math>

. This can be described by the following state over the system XB.</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Min_entropy:21">
 <semantics>
  <mrow>
   <msub>
    <mi>ρ</mi>
    <mrow>
     <mi>X</mi>
     <mi>B</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>x</mi>
    </msub>
    <mrow>
     <mrow>
      <msub>
       <mi>P</mi>
       <mi>X</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mi>x</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>x</mi>
       <mo fence="true" stretchy="false">|</mo>
      </mrow>
     </mrow>
     <mo>⊗</mo>
     <msubsup>
      <mi>ρ</mi>
      <mi>B</mi>
      <mi>x</mi>
     </msubsup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ρ</ci>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>X</ci>
       </apply>
       <ci>x</ci>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">bra</csymbol>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ρ</ci>
        <ci>B</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{XB}=\sum_{x}P_{X}(x)|x\rangle\langle x|\otimes\rho_{B}^{x}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where 

<math display="inline" id="Min_entropy:22">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>x</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{|x\rangle\}
  </annotation>
 </semantics>
</math>

 form an orthonormal basis. We would like to know what the agent can learn about the classical variable 

<math display="inline" id="Min_entropy:23">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Min_entropy:24">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>g</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">|</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>g</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{g}(X|B)
  </annotation>
 </semantics>
</math>

 be the probability that the agent guesses X when using an optimal measurement strategy</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Min_entropy:25">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>g</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">|</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mi>x</mi>
   </msub>
   <msub>
    <mi>P</mi>
    <mi>X</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>t</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>E</mi>
     <mi>x</mi>
    </msub>
    <msubsup>
     <mi>ρ</mi>
     <mi>B</mi>
     <mi>x</mi>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>g</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>X</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">t</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ρ</ci>
       <ci>B</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{g}(X|B)=\sum_{x}P_{X}(x)tr(E_{x}\rho_{B}^{x})
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where 

<math display="inline" id="Min_entropy:26">
 <semantics>
  <msub>
   <mi>E</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{x}
  </annotation>
 </semantics>
</math>

 is the POVM that maximizes this expression. It can be shown that this optimum can be expressed in terms of the min-entropy as</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Min_entropy:27">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>g</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">|</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mpadded width="+3.3pt">
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <msub>
       <mi>H</mi>
       <mi>min</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">|</mo>
       <mi>B</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
   </mpadded>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>g</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <min></min>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">X</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{g}(X|B)=2^{-H_{\min}(X|B)}~{}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>If the state 

<math display="inline" id="Min_entropy:28">
 <semantics>
  <msub>
   <mi>ρ</mi>
   <mrow>
    <mi>X</mi>
    <mi>B</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ρ</ci>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{XB}
  </annotation>
 </semantics>
</math>

 is a product state i.e. 

<math display="inline" id="Min_entropy:29">
 <semantics>
  <mrow>
   <msub>
    <mi>ρ</mi>
    <mrow>
     <mi>X</mi>
     <mi>B</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>σ</mi>
     <mi>X</mi>
    </msub>
    <mo>⊗</mo>
    <msub>
     <mi>τ</mi>
     <mi>B</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ρ</ci>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{XB}=\sigma_{X}\otimes\tau_{B}
  </annotation>
 </semantics>
</math>

 for some density operators 

<math display="inline" id="Min_entropy:30">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>X</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{X}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Min_entropy:31">
 <semantics>
  <msub>
   <mi>τ</mi>
   <mi>B</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>τ</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau_{B}
  </annotation>
 </semantics>
</math>

, then there is no correlation between the systems X and B. In this case, it turns out that 

<math display="inline" id="Min_entropy:32">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <msub>
       <mi>H</mi>
       <mi>min</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">|</mo>
       <mi>B</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>max</mi>
       <mi>x</mi>
      </msub>
      <msub>
       <mi>P</mi>
       <mi>X</mi>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo rspace="5.8pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <min></min>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">X</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <max></max>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>X</ci>
      </apply>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{-H_{\min}(X|B)}=\max_{x}P_{X}(x)~{}.
  </annotation>
 </semantics>
</math>

</p>
<h4 id="min-entropy-as-distance-from-maximally-entangled-state">Min-entropy as distance from maximally entangled state</h4>

<p>The maximally entangled state 

<math display="inline" id="Min_entropy:33">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msup>
    <mi>ϕ</mi>
    <mo>+</mo>
   </msup>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ϕ</ci>
     <plus></plus>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi^{+}\rangle
  </annotation>
 </semantics>
</math>

 on a bipartite system 

<math display="inline" id="Min_entropy:34">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
    <mi>A</mi>
   </msub>
   <mo>⊗</mo>
   <msub>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
    <mi>B</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℋ</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℋ</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}_{A}\otimes\mathcal{H}_{B}
  </annotation>
 </semantics>
</math>

 is defined as</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Min_entropy:35">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <msup>
      <mi>ϕ</mi>
      <mo>+</mo>
     </msup>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <mi>A</mi>
     <mi>B</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mi>d</mi>
     </msqrt>
    </mfrac>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mi>A</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mi>B</mi>
       </msub>
      </mrow>
     </msub>
     <mrow>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <msub>
        <mi>x</mi>
        <mi>A</mi>
       </msub>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <msub>
        <mi>x</mi>
        <mi>B</mi>
       </msub>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ϕ</ci>
       <plus></plus>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <ci>d</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>A</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>B</ci>
        </apply>
       </list>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>A</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>B</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi^{+}\rangle_{AB}=\frac{1}{\sqrt{d}}\sum_{x_{A},x_{B}}|x_{A}\rangle|x_{B}\rangle
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where 

<math display="inline" id="Min_entropy:36">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>x</mi>
     <mi>A</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{|x_{A}\rangle\}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Min_entropy:37">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>x</mi>
     <mi>B</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{|x_{B}\rangle\}
  </annotation>
 </semantics>
</math>

 form an orthonormal basis for the spaces A and B respectively. For a bipartite quantum state 

<math display="inline" id="Min_entropy:38">
 <semantics>
  <msub>
   <mi>ρ</mi>
   <mrow>
    <mi>A</mi>
    <mi>B</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ρ</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{AB}
  </annotation>
 </semantics>
</math>

, we define the maximum overlap with the maximally entangled state as</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Min_entropy:39">
 <semantics>
  <mrow>
   <msub>
    <mi>q</mi>
    <mi>c</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>d</mi>
   <msub>
    <mi>max</mi>
    <mi class="ltx_font_mathcaligraphic">ℰ</mi>
   </msub>
   <mi>F</mi>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>I</mi>
      <mi>A</mi>
     </msub>
     <mo>⊗</mo>
     <mi class="ltx_font_mathcaligraphic">ℰ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>ρ</mi>
     <mrow>
      <mi>A</mi>
      <mi>B</mi>
     </mrow>
    </msub>
    <mo>,</mo>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>ϕ</mi>
     <mo>+</mo>
    </msup>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msup>
     <mi>ϕ</mi>
     <mo>+</mo>
    </msup>
    <mo stretchy="false">|</mo>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <ci>c</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">d</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <max></max>
     <ci>ℰ</ci>
    </apply>
    <csymbol cd="unknown">F</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>A</ci>
      </apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ϕ</ci>
      <plus></plus>
     </apply>
     <ci>normal-⟩</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ϕ</ci>
      <plus></plus>
     </apply>
     <ci>normal-|</ci>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{c}(A|B)=d\max_{\mathcal{E}}F\left((I_{A}\otimes\mathcal{E})\rho_{AB},|\phi^%
{+}\rangle\langle\phi^{+}|\right)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where the maximum is over all CPTP operations 

<math display="inline" id="Min_entropy:40">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℰ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℰ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}
  </annotation>
 </semantics>
</math>

. This is a measure of how correlated the state 

<math display="inline" id="Min_entropy:41">
 <semantics>
  <msub>
   <mi>ρ</mi>
   <mrow>
    <mi>A</mi>
    <mi>B</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ρ</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{AB}
  </annotation>
 </semantics>
</math>

 is. It can be shown that 

<math display="inline" id="Min_entropy:42">
 <semantics>
  <mrow>
   <msub>
    <mi>q</mi>
    <mi>c</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <msub>
      <mi>H</mi>
      <mi>min</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">|</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <ci>c</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <min></min>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{c}(A|B)=2^{-H_{\min}(A|B)}
  </annotation>
 </semantics>
</math>

. If the information contained in A is classical, this reduces to the expression above for the guessing probability.</p>
<h3 id="proof-of-operational-characterization-of-min-entropy">Proof of operational characterization of min-entropy</h3>

<p>The proof is from a paper by König, Schaffner, Renner '08.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> It involves the machinery of <a href="semidefinite_programming" title="wikilink">semidefinite programs</a>,.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Suppose we are given some bipartite density operator 

<math display="inline" id="Min_entropy:43">
 <semantics>
  <msub>
   <mi>ρ</mi>
   <mrow>
    <mi>A</mi>
    <mi>B</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ρ</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{AB}
  </annotation>
 </semantics>
</math>

. From the definition of the min-entropy, we have</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Min_entropy:44">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>min</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo>-</mo>
   <msub>
    <mo>inf</mo>
    <msub>
     <mi>σ</mi>
     <mi>B</mi>
    </msub>
   </msub>
   <msub>
    <mo>inf</mo>
    <mi>λ</mi>
   </msub>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>λ</mi>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>ρ</mi>
     <mrow>
      <mi>A</mi>
      <mi>B</mi>
     </mrow>
    </msub>
    <mo>≤</mo>
    <msup>
     <mn>2</mn>
     <mi>λ</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>I</mi>
      <mi>A</mi>
     </msub>
     <mo>⊗</mo>
     <msub>
      <mi>σ</mi>
      <mi>B</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="5.8pt" stretchy="false">}</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <min></min>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">infimum</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">infimum</csymbol>
     <ci>λ</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">λ</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <leq></leq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>λ</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>A</ci>
      </apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>B</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{\min}(A|B)=-\inf_{\sigma_{B}}\inf_{\lambda}\{\lambda|\rho_{AB}\leq 2^{%
\lambda}(I_{A}\otimes\sigma_{B})\}~{}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>This can be re-written as</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Min_entropy:45">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mrow>
    <msub>
     <mo>inf</mo>
     <msub>
      <mi>σ</mi>
      <mi>B</mi>
     </msub>
    </msub>
    <mrow>
     <mo>Tr</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>σ</mi>
       <mi>B</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <log></log>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">infimum</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <apply>
      <ci>Tr</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log\inf_{\sigma_{B}}\operatorname{Tr}(\sigma_{B})
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>subject to the conditions</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Min_entropy:46">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mi>B</mi>
   </msub>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>B</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{B}\geq 0
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Min_entropy:47">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>I</mi>
      <mi>A</mi>
     </msub>
     <mo>⊗</mo>
     <msub>
      <mi>σ</mi>
      <mi>B</mi>
     </msub>
    </mrow>
    <mo>≥</mo>
    <mpadded width="+3.3pt">
     <msub>
      <mi>ρ</mi>
      <mrow>
       <mi>A</mi>
       <mi>B</mi>
      </mrow>
     </msub>
    </mpadded>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ρ</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{A}\otimes\sigma_{B}\geq\rho_{AB}~{}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>We notice that the infimum is taken over compact sets and hence can be replaced by a minimum. This can then be expressed succinctly as a semidefinite program. Consider the primal problem</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Min_entropy:48">
 <semantics>
  <mrow>
   <mtext>min:</mtext>
   <mrow>
    <mo>Tr</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>σ</mi>
      <mi>B</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>min:</mtext>
    <apply>
     <ci>Tr</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{min:}\operatorname{Tr}(\sigma_{B})
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Min_entropy:49">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mtext>subject to:</mtext>
     <msub>
      <mi>I</mi>
      <mi>A</mi>
     </msub>
    </mrow>
    <mo>⊗</mo>
    <msub>
     <mi>σ</mi>
     <mi>B</mi>
    </msub>
   </mrow>
   <mo>≥</mo>
   <msub>
    <mi>ρ</mi>
    <mrow>
     <mi>A</mi>
     <mi>B</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <times></times>
      <mtext>subject to:</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>A</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ρ</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{subject to: }I_{A}\otimes\sigma_{B}\geq\rho_{AB}
  </annotation>
 </semantics>
</math>


<dl>
<dd><dl>
<dd>

<math display="inline" id="Min_entropy:50">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>σ</mi>
     <mi>B</mi>
    </msub>
    <mo>≥</mo>
    <mpadded width="+3.3pt">
     <mn>0</mn>
    </mpadded>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>B</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{B}\geq 0~{}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>

<p>This primal problem can also be fully specified by the matrices 

<math display="inline" id="Min_entropy:51">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>ρ</mi>
    <mrow>
     <mi>A</mi>
     <mi>B</mi>
    </mrow>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>I</mi>
    <mi>B</mi>
   </msub>
   <mo>,</mo>
   <msup>
    <mo>Tr</mo>
    <mo>*</mo>
   </msup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ρ</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>B</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Tr</ci>
     <times></times>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\rho_{AB},I_{B},\operatorname{Tr}^{*})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Min_entropy:52">
 <semantics>
  <msup>
   <mo>Tr</mo>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>Tr</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Tr}^{*}
  </annotation>
 </semantics>
</math>

 is the adjoint of the partial trace over A. The action of 

<math display="inline" id="Min_entropy:53">
 <semantics>
  <msup>
   <mo>Tr</mo>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>Tr</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Tr}^{*}
  </annotation>
 </semantics>
</math>

 on operators on B can be written as</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Min_entropy:54">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mo>Tr</mo>
      <mo>*</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>I</mi>
      <mi>A</mi>
     </msub>
     <mo>⊗</mo>
     <mpadded width="+3.3pt">
      <mi>X</mi>
     </mpadded>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Tr</ci>
      <times></times>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>A</ci>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Tr}^{*}(X)=I_{A}\otimes X~{}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>We can express the dual problem as a maximization over operators 

<math display="inline" id="Min_entropy:55">
 <semantics>
  <msub>
   <mi>E</mi>
   <mrow>
    <mi>A</mi>
    <mi>B</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{AB}
  </annotation>
 </semantics>
</math>

 on the space AB as</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Min_entropy:56">
 <semantics>
  <mrow>
   <mtext>max:</mtext>
   <mrow>
    <mo>Tr</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>ρ</mi>
       <mrow>
        <mi>A</mi>
        <mi>B</mi>
       </mrow>
      </msub>
      <msub>
       <mi>E</mi>
       <mrow>
        <mi>A</mi>
        <mi>B</mi>
       </mrow>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>max:</mtext>
    <apply>
     <ci>Tr</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ρ</ci>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>B</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{max:}\operatorname{Tr}(\rho_{AB}E_{AB})
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Min_entropy:57">
 <semantics>
  <mrow>
   <mrow>
    <mtext>subject to:</mtext>
    <mrow>
     <msub>
      <mo>Tr</mo>
      <mi>A</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>E</mi>
       <mrow>
        <mi>A</mi>
        <mi>B</mi>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>I</mi>
    <mi>B</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>subject to:</mtext>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Tr</ci>
       <ci>A</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{subject to: }\operatorname{Tr}_{A}(E_{AB})=I_{B}
  </annotation>
 </semantics>
</math>


<dl>
<dd><dl>
<dd>

<math display="inline" id="Min_entropy:58">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>E</mi>
     <mrow>
      <mi>A</mi>
      <mi>B</mi>
     </mrow>
    </msub>
    <mo>≥</mo>
    <mpadded width="+3.3pt">
     <mn>0</mn>
    </mpadded>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{AB}\geq 0~{}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>

<p>Using the <a href="channel-state_duality" title="wikilink">Choi Jamiolkowski isomorphism</a>, we can define the channel 

<math display="inline" id="Min_entropy:59">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℰ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℰ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}
  </annotation>
 </semantics>
</math>

 such that</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Min_entropy:60">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>I</mi>
      <mi>A</mi>
     </msub>
     <mo>⊗</mo>
     <msup>
      <mi class="ltx_font_mathcaligraphic">ℰ</mi>
      <mo>†</mo>
     </msup>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <msup>
        <mi>ϕ</mi>
        <mo>+</mo>
       </msup>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <msup>
        <mi>ϕ</mi>
        <mo>+</mo>
       </msup>
       <mo fence="true" stretchy="false">|</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>E</mi>
    <mrow>
     <mi>A</mi>
     <mi>B</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>A</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℰ</ci>
       <ci>normal-†</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ϕ</ci>
        <plus></plus>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">bra</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ϕ</ci>
        <plus></plus>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{A}\otimes\mathcal{E}^{\dagger}(|\phi^{+}\rangle\langle\phi^{+}|)=E_{AB}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where the bell state is defined over the space AA'. This means that we can express the objective function of the dual problem as</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Min_entropy:61">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msub>
     <mi>ρ</mi>
     <mrow>
      <mi>A</mi>
      <mi>B</mi>
     </mrow>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>E</mi>
     <mrow>
      <mi>A</mi>
      <mi>B</mi>
     </mrow>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msub>
     <mi>ρ</mi>
     <mrow>
      <mi>A</mi>
      <mi>B</mi>
     </mrow>
    </msub>
    <mo>,</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>I</mi>
       <mi>A</mi>
      </msub>
      <mo>⊗</mo>
      <msup>
       <mi class="ltx_font_mathcaligraphic">ℰ</mi>
       <mo>†</mo>
      </msup>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <msup>
         <mi>ϕ</mi>
         <mo>+</mo>
        </msup>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">⟨</mo>
        <msup>
         <mi>ϕ</mi>
         <mo>+</mo>
        </msup>
        <mo fence="true" stretchy="false">|</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </list>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>I</ci>
        <ci>A</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ℰ</ci>
        <ci>normal-†</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ϕ</ci>
         <plus></plus>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">bra</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ϕ</ci>
         <plus></plus>
        </apply>
       </apply>
      </apply>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\rho_{AB},E_{AB}\rangle=\langle\rho_{AB},I_{A}\otimes\mathcal{E}^{%
\dagger}(|\phi^{+}\rangle\langle\phi^{+}|)\rangle
  </annotation>
 </semantics>
</math>


<dl>
<dd><dl>
<dd>

<math display="inline" id="Min_entropy:62">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msub>
     <mi>I</mi>
     <mi>A</mi>
    </msub>
    <mo>⊗</mo>
    <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ρ</mi>
      <mrow>
       <mi>A</mi>
       <mi>B</mi>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>ϕ</mi>
     <mo>+</mo>
    </msup>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msup>
     <mi>ϕ</mi>
     <mo>+</mo>
    </msup>
    <mo stretchy="false">|</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>A</ci>
     </apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <csymbol cd="unknown">E</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ρ</ci>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>B</ci>
       </apply>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ϕ</ci>
      <plus></plus>
     </apply>
     <ci>normal-⟩</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ϕ</ci>
      <plus></plus>
     </apply>
     <ci>normal-|</ci>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⟩</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\langle I_{A}\otimes\mathcal{E}(\rho_{AB}),|\phi^{+}\rangle\langle\phi^{+}|)\rangle
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>

<p>as desired.</p>

<p>Notice that in the event that the system A is a partly classical state as above, then the quantity that we are after reduces to</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Min_entropy:63">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>max</mi>
     <msub>
      <mi>P</mi>
      <mi>X</mi>
     </msub>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>x</mi>
     <mo fence="true" stretchy="false">|</mo>
     <mrow>
      <mi class="ltx_font_mathcaligraphic">ℰ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msubsup>
        <mi>ρ</mi>
        <mi>B</mi>
        <mi>x</mi>
       </msubsup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mi>x</mi>
     <mo rspace="5.8pt" stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <max></max>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">quantum-operator-product</csymbol>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>ℰ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ρ</ci>
        <ci>B</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max P_{X}(x)\langle x|\mathcal{E}(\rho_{B}^{x})|x\rangle~{}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>We can interpret 

<math display="inline" id="Min_entropy:64">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℰ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℰ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}
  </annotation>
 </semantics>
</math>

 as a guessing strategy and this then reduces to the interpretation given above where an adversary wants to find the string 

<math display="inline" id="Min_entropy:65">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 given access to quantum information via system B.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="von_Neumann_entropy" title="wikilink">von Neumann entropy</a></li>
<li><a href="Generalized_relative_entropy" title="wikilink">Generalized relative entropy</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Quantum_mechanical_entropy" title="wikilink">Category:Quantum mechanical entropy</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Vazirani, Umesh, and Thomas Vidick. "Fully device independent quantum key distribution."  (2012)<a href="#fnref1">↩</a></li>
<li id="fn2">Marco Tomamichel, Roger Colbeck, Renato Renner. "The Fully Quantum Asymptotic Equipartition Property." Information Theory, IEEE Transactions on 55 (2009), p. 5840-5847<a href="#fnref2">↩</a></li>
<li id="fn3">Renato Renner, "Security of Quantum Key Distribution", Ph.D. Thesis, Diss. ETH No. 16242 <a href="#fnref3">↩</a></li>
<li id="fn4">König, R., Renato Renner, and Christian Schaffner. "The operational meaning of min-and max-entropy." Information Theory, IEEE Transactions on 55.9 (2009): 4337-4347. <a href="#fnref4">↩</a></li>
<li id="fn5">John Watrous, Theory of quantum information, Fall 2011, course notes, <a class="uri" href="https://cs.uwaterloo.ca/~watrous/CS766/LectureNotes/07.pdf">https://cs.uwaterloo.ca/~watrous/CS766/LectureNotes/07.pdf</a><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
