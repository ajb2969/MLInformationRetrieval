<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="695">Supervised learning</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Supervised learning</h1>
<hr/>

<p><strong>Supervised learning</strong> is the <a href="machine_learning" title="wikilink">machine learning</a> task of inferring a function from labeled training data.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The <a href="training_set" title="wikilink">training data</a> consist of a set of <em>training examples</em>. In supervised learning, each example is a <em>pair</em> consisting of an input object (typically a vector) and a desired output value (also called the <em>supervisory signal</em>). A supervised learning algorithm analyzes the training data and produces an inferred function, which can be used for mapping new examples. An optimal scenario will allow for the algorithm to correctly determine the class labels for unseen instances. This requires the learning algorithm to generalize from the training data to unseen situations in a "reasonable" way (see <a href="inductive_bias" title="wikilink">inductive bias</a>).</p>

<p>The parallel task in human and animal psychology is often referred to as <a href="concept_learning" title="wikilink">concept learning</a>.</p>
<h2 id="overview">Overview</h2>

<p>In order to solve a given problem of supervised learning, one has to perform the following steps:</p>
<ol>
<li>Determine the type of training examples. Before doing anything else, the user should decide what kind of data is to be used as a training set. In the case of handwriting analysis, for example, this might be a single handwritten character, an entire handwritten word, or an entire line of handwriting.</li>
<li>Gather a training set. The training set needs to be representative of the real-world use of the function. Thus, a set of input objects is gathered and corresponding outputs are also gathered, either from human experts or from measurements.</li>
<li>Determine the input feature representation of the learned function. The accuracy of the learned function depends strongly on how the input object is represented. Typically, the input object is transformed into a feature vector, which contains a number of features that are descriptive of the object. The number of features should not be too large, because of the <a href="curse_of_dimensionality" title="wikilink">curse of dimensionality</a>; but should contain enough information to accurately predict the output.</li>
<li>Determine the structure of the learned function and corresponding learning algorithm. For example, the engineer may choose to use <a href="support_vector_machine" title="wikilink">support vector machines</a> or <a href="Decision_tree_learning" title="wikilink">decision trees</a>.</li>
<li>Complete the design. Run the learning algorithm on the gathered training set. Some supervised learning algorithms require the user to determine certain control parameters. These parameters may be adjusted by optimizing performance on a subset (called a <em>validation</em> set) of the training set, or via <a href="cross-validation_(statistics)" title="wikilink">cross-validation</a>.</li>
<li>Evaluate the accuracy of the learned function. After parameter adjustment and learning, the performance of the resulting function should be measured on a test set that is separate from the training set.</li>
</ol>

<p>A wide range of supervised learning algorithms is available, each with its strengths and weaknesses. There is no single learning algorithm that works best on all supervised learning problems (see the <a href="No_free_lunch_in_search_and_optimization" title="wikilink">No free lunch theorem</a>).</p>

<p>There are four major issues to consider in supervised learning:</p>
<h3 id="bias-variance-tradeoff">Bias-variance tradeoff</h3>

<p>A first issue is the tradeoff between <em>bias</em> and <em>variance</em>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Imagine that we have available several different, but equally good, training data sets. A learning algorithm is biased for a particular input 

<math display="inline" id="Supervised_learning:0">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 if, when trained on each of these data sets, it is systematically incorrect when predicting the correct output for 

<math display="inline" id="Supervised_learning:1">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. A learning algorithm has high variance for a particular input 

<math display="inline" id="Supervised_learning:2">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 if it predicts different output values when trained on different training sets. The prediction error of a learned classifier is related to the sum of the bias and the variance of the learning algorithm.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Generally, there is a tradeoff between bias and variance. A learning algorithm with low bias must be "flexible" so that it can fit the data well. But if the learning algorithm is too flexible, it will fit each training data set differently, and hence have high variance. A key aspect of many supervised learning methods is that they are able to adjust this tradeoff between bias and variance (either automatically or by providing a bias/variance parameter that the user can adjust).</p>
<h3 id="function-complexity-and-amount-of-training-data">Function complexity and amount of training data</h3>

<p>The second issue is the amount of training data available relative to the complexity of the "true" function (classifier or regression function). If the true function is simple, then an "inflexible" learning algorithm with high bias and low variance will be able to learn it from a small amount of data. But if the true function is highly complex (e.g., because it involves complex interactions among many different input features and behaves differently in different parts of the input space), then the function will only be learnable from a very large amount of training data and using a "flexible" learning algorithm with low bias and high variance. Good learning algorithms therefore automatically adjust the bias/variance tradeoff based on the amount of data available and the apparent complexity of the function to be learned.</p>
<h3 id="dimensionality-of-the-input-space">Dimensionality of the input space</h3>

<p>A third issue is the dimensionality of the input space. If the input feature vectors have very high dimension, the learning problem can be difficult even if the true function only depends on a small number of those features. This is because the many "extra" dimensions can confuse the learning algorithm and cause it to have high variance. Hence, high input dimensionality typically requires tuning the classifier to have low variance and high bias. In practice, if the engineer can manually remove irrelevant features from the input data, this is likely to improve the accuracy of the learned function. In addition, there are many algorithms for <a href="feature_selection" title="wikilink">feature selection</a> that seek to identify the relevant features and discard the irrelevant ones. This is an instance of the more general strategy of <a href="dimensionality_reduction" title="wikilink">dimensionality reduction</a>, which seeks to map the input data into a lower-dimensional space prior to running the supervised learning algorithm.</p>
<h3 id="noise-in-the-output-values">Noise in the output values</h3>

<p>A fourth issue is the degree of noise in the desired output values (the supervisory <a href="target_variable" title="wikilink">target variables</a>). If the desired output values are often incorrect (because of human error or sensor errors), then the learning algorithm should not attempt to find a function that exactly matches the training examples. Attempting to fit the data too carefully leads to <a class="uri" href="overfitting" title="wikilink">overfitting</a>. You can overfit even when there are no measurement errors (stochastic noise) if the function you are trying to learn is too complex for your learning model. In such a situation that part of the target function that cannot be modeled "corrupts" your training data - this phenomenon has been called <a href="deterministic_noise" title="wikilink">deterministic noise</a>. When either type of noise is present, it is better to go with a higher bias, lower variance estimator.</p>

<p>In practice, there are several approaches to alleviate noise in the output values such as <a href="early_stopping" title="wikilink">early stopping</a> to prevent <a class="uri" href="overfitting" title="wikilink">overfitting</a> as well as <a href="anomaly_detection" title="wikilink">detecting</a> and removing the noisy training examples prior to training the supervised learning algorithm. There are several algorithms that identify noisy training examples and removing the suspected noisy training examples prior to training has decreased <a href="generalization_error" title="wikilink">generalization error</a> with <a href="statistical_significance" title="wikilink">statistical significance</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="other-factors-to-consider">Other factors to consider</h3>

<p>Other factors to consider when choosing and applying a learning algorithm include the following:</p>
<ol>
<li>Heterogeneity of the data. If the feature vectors include features of many different kinds (discrete, discrete ordered, counts, continuous values), some algorithms are easier to apply than others. Many algorithms, including <a href="Support_Vector_Machines" title="wikilink">Support Vector Machines</a>, <a href="linear_regression" title="wikilink">linear regression</a>, <a href="logistic_regression" title="wikilink">logistic regression</a>, <a href="Artificial_neural_network" title="wikilink">neural networks</a>, and <a href="k-nearest_neighbor_algorithm" title="wikilink">nearest neighbor methods</a>, require that the input features be numerical and scaled to similar ranges (e.g., to the [-1,1] interval). Methods that employ a distance function, such as <a href="k-nearest_neighbor_algorithm" title="wikilink">nearest neighbor methods</a> and <a href="Support_Vector_Machines" title="wikilink">support vector machines with Gaussian kernels</a>, are particularly sensitive to this. An advantage of <a href="Decision_tree_learning" title="wikilink">decision trees</a> is that they easily handle heterogeneous data.</li>
<li>Redundancy in the data. If the input features contain redundant information (e.g., highly correlated features), some learning algorithms (e.g., <a href="linear_regression" title="wikilink">linear regression</a>, <a href="logistic_regression" title="wikilink">logistic regression</a>, and <a href="k-nearest_neighbor_algorithm" title="wikilink">distance based methods</a>) will perform poorly because of numerical instabilities. These problems can often be solved by imposing some form of <a href="Regularization_(mathematics)" title="wikilink">regularization</a>.</li>
<li>Presence of interactions and non-linearities. If each of the features makes an independent contribution to the output, then algorithms based on linear functions (e.g., <a href="linear_regression" title="wikilink">linear regression</a>, <a href="logistic_regression" title="wikilink">logistic regression</a>, <a href="Support_Vector_Machines" title="wikilink">Support Vector Machines</a>, <a href="Naive_Bayes_classifier" title="wikilink">naive Bayes</a>) and distance functions (e.g., <a href="k-nearest_neighbor_algorithm" title="wikilink">nearest neighbor methods</a>, <a href="Support_Vector_Machines" title="wikilink">support vector machines with Gaussian kernels</a>) generally perform well. However, if there are complex interactions among features, then algorithms such as <a href="Decision_tree_learning" title="wikilink">decision trees</a> and <a href="Artificial_neural_network" title="wikilink">neural networks</a> work better, because they are specifically designed to discover these interactions. Linear methods can also be applied, but the engineer must manually specify the interactions when using them.</li>
</ol>

<p>When considering a new application, the engineer can compare multiple learning algorithms and experimentally determine which one works best on the problem at hand (see <a href="Cross-validation_(statistics)" title="wikilink">cross validation</a>). Tuning the performance of a learning algorithm can be very time-consuming. Given fixed resources, it is often better to spend more time collecting additional training data and more informative features than it is to spend extra time tuning the learning algorithms.</p>

<p>The most widely used learning algorithms are <a href="Support_Vector_Machines" title="wikilink">Support Vector Machines</a>, <a href="linear_regression" title="wikilink">linear regression</a>, <a href="logistic_regression" title="wikilink">logistic regression</a>, <a href="Naive_Bayes_classifier" title="wikilink">naive Bayes</a>, <a href="linear_discriminant_analysis" title="wikilink">linear discriminant analysis</a>, <a href="Decision_tree_learning" title="wikilink">decision trees</a>, <a href="k-nearest_neighbor_algorithm" title="wikilink">k-nearest neighbor algorithm</a>, and <a href="Artificial_neural_network" title="wikilink">Neural Networks</a> (<a href="Multilayer_perceptron" title="wikilink">Multilayer perceptron</a>).</p>
<h2 id="how-supervised-learning-algorithms-work">How supervised learning algorithms work</h2>

<p>Given a set of 

<math display="inline" id="Supervised_learning:3">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 training examples of the form 

<math display="inline" id="Supervised_learning:4">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>N</mi>
    </msub>
    <mo rspace="5.3pt">,</mo>
    <msub>
     <mi>y</mi>
     <mi>N</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
    <ci>normal-…</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>N</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>N</ci>
     </apply>
    </interval>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(x_{1},y_{1}),...,(x_{N},\;y_{N})\}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Supervised_learning:5">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 is the <a href="feature_vector" title="wikilink">feature vector</a> of the i-th example and 

<math display="inline" id="Supervised_learning:6">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}
  </annotation>
 </semantics>
</math>

 is its label (i.e., class), a learning algorithm seeks a function 

<math display="inline" id="Supervised_learning:7">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mo>→</mo>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>g</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g:X\to Y
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Supervised_learning:8">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is the input space and 

<math display="inline" id="Supervised_learning:9">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 is the output space. The function 

<math display="inline" id="Supervised_learning:10">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is an element of some space of possible functions 

<math display="inline" id="Supervised_learning:11">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, usually called the <em>hypothesis space</em>. It is sometimes convenient to represent 

<math display="inline" id="Supervised_learning:12">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 using a scoring function 

<math display="inline" id="Supervised_learning:13">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>X</mi>
     <mo>×</mo>
     <mi>Y</mi>
    </mrow>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:X\times Y\to\mathbb{R}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Supervised_learning:14">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is defined as returning the 

<math display="inline" id="Supervised_learning:15">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 value that gives the highest score

<math display="block" id="Supervised_learning:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>arg</mi>
     <mrow>
      <mpadded width="+2.8pt">
       <munder>
        <mi>max</mi>
        <mi>y</mi>
       </munder>
      </mpadded>
      <mi>f</mi>
     </mrow>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <arg></arg>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <max></max>
        <ci>y</ci>
       </apply>
       <ci>f</ci>
      </apply>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)=\arg\max_{y}\;f(x,y)
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Supervised_learning:17">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 denote the space of scoring functions.</p>

<p>Although 

<math display="inline" id="Supervised_learning:18">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Supervised_learning:19">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 can be any space of functions, many learning algorithms are probabilistic models where 

<math display="inline" id="Supervised_learning:20">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 takes the form of a conditional probability model 

<math display="inline" id="Supervised_learning:21">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">g</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)=P(y|x)
  </annotation>
 </semantics>
</math>

, or 

<math display="inline" id="Supervised_learning:22">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 takes the form of a joint probability model 

<math display="inline" id="Supervised_learning:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)=P(x,y)
  </annotation>
 </semantics>
</math>

. For example, <a href="Naive_Bayes_classifier" title="wikilink">naive Bayes</a> and <a href="linear_discriminant_analysis" title="wikilink">linear discriminant analysis</a> are joint probability models, whereas <a href="logistic_regression" title="wikilink">logistic regression</a> is a conditional probability model.</p>

<p>There are two basic approaches to choosing 

<math display="inline" id="Supervised_learning:24">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Supervised_learning:25">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

: <a href="empirical_risk_minimization" title="wikilink">empirical risk minimization</a> and <a href="structural_risk_minimization" title="wikilink">structural risk minimization</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Empirical risk minimization seeks the function that best fits the training data. Structural risk minimize includes a <em>penalty function</em> that controls the bias/variance tradeoff.</p>

<p>In both cases, it is assumed that the training set consists of a sample of <a href="independent_and_identically-distributed_random_variables" title="wikilink">independent and identically distributed pairs</a>, 

<math display="inline" id="Supervised_learning:26">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo rspace="5.3pt">,</mo>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{i},\;y_{i})
  </annotation>
 </semantics>
</math>

. In order to measure how well a function fits the training data, a <a href="loss_function" title="wikilink">loss function</a> 

<math display="inline" id="Supervised_learning:27">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>Y</mi>
     <mo>×</mo>
     <mi>Y</mi>
    </mrow>
    <mo>→</mo>
    <msup>
     <mi>ℝ</mi>
     <mrow>
      <mi></mi>
      <mo>≥</mo>
      <mn>0</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>L</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>Y</ci>
      <ci>Y</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <apply>
       <geq></geq>
       <csymbol cd="latexml">absent</csymbol>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L:Y\times Y\to\mathbb{R}^{\geq 0}
  </annotation>
 </semantics>
</math>

 is defined. For training example 

<math display="inline" id="Supervised_learning:28">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo rspace="5.3pt">,</mo>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{i},\;y_{i})
  </annotation>
 </semantics>
</math>

, the loss of predicting the value 

<math display="inline" id="Supervised_learning:29">
 <semantics>
  <mover accent="true">
   <mi>y</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{y}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Supervised_learning:30">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <mover accent="true">
     <mi>y</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <ci>normal-^</ci>
      <ci>y</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(y_{i},\hat{y})
  </annotation>
 </semantics>
</math>

.</p>

<p>The <em>risk</em> 

<math display="inline" id="Supervised_learning:31">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>g</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <ci>g</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(g)
  </annotation>
 </semantics>
</math>

 of function 

<math display="inline" id="Supervised_learning:32">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is defined as the expected loss of 

<math display="inline" id="Supervised_learning:33">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

. This can be estimated from the training data as</p>

<p>

<math display="block" id="Supervised_learning:34">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>R</mi>
     <mrow>
      <mi>e</mi>
      <mi>m</mi>
      <mi>p</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>g</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>N</mi>
    </mfrac>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>i</mi>
     </munder>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <mrow>
        <mi>g</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <apply>
       <times></times>
       <ci>e</ci>
       <ci>m</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <ci>g</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <ci>L</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <times></times>
         <ci>g</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{emp}(g)=\frac{1}{N}\sum_{i}L(y_{i},g(x_{i}))
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="empirical-risk-minimization">Empirical risk minimization</h3>

<p>In empirical risk minimization, the supervised learning algorithm seeks the function 

<math display="inline" id="Supervised_learning:35">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 that minimizes 

<math display="inline" id="Supervised_learning:36">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>g</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <ci>g</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(g)
  </annotation>
 </semantics>
</math>

. Hence, a supervised learning algorithm can be constructed by applying an <a href="Optimization_(mathematics)" title="wikilink">optimization algorithm</a> to find 

<math display="inline" id="Supervised_learning:37">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

.</p>

<p>When 

<math display="inline" id="Supervised_learning:38">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is a conditional probability distribution 

<math display="inline" id="Supervised_learning:39">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(y|x)
  </annotation>
 </semantics>
</math>

 and the loss function is the negative log likelihood

<math display="block" id="Supervised_learning:40">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mover accent="true">
     <mi>y</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo>-</mo>
   <mi>log</mi>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-,</ci>
     <apply>
      <ci>normal-^</ci>
      <ci>y</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <minus></minus>
    <log></log>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(y,\hat{y})=-\log P(y|x)
  </annotation>
 </semantics>
</math>

, then empirical risk minimization is equivalent to <a href="Maximum_likelihood" title="wikilink">maximum likelihood estimation</a>.</p>

<p>When 

<math display="inline" id="Supervised_learning:41">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 contains many candidate functions or the training set is not sufficiently large, empirical risk minimization leads to high variance and poor generalization. The learning algorithm is able to memorize the training examples without generalizing well. This is called <a class="uri" href="overfitting" title="wikilink">overfitting</a>.</p>
<h3 id="structural-risk-minimization">Structural risk minimization</h3>

<p><a href="Structural_risk_minimization" title="wikilink">Structural risk minimization</a> seeks to prevent overfitting by incorporating a <a href="Regularization_(mathematics)" title="wikilink">regularization penalty</a> into the optimization. The regularization penalty can be viewed as implementing a form of <a href="Occam's_razor" title="wikilink">Occam's razor</a> that prefers simpler functions over more complex ones.</p>

<p>A wide variety of penalties have been employed that correspond to different definitions of complexity. For example, consider the case where the function 

<math display="inline" id="Supervised_learning:42">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is a linear function of the form</p>

<p>

<math display="block" id="Supervised_learning:43">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>d</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>β</mi>
      <mi>j</mi>
     </msub>
     <msub>
      <mi>x</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>d</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)=\sum_{j=1}^{d}\beta_{j}x_{j}
  </annotation>
 </semantics>
</math>

.</p>

<p>A popular regularization penalty is 

<math display="inline" id="Supervised_learning:44">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mi>j</mi>
   </msub>
   <msubsup>
    <mi>β</mi>
    <mi>j</mi>
    <mn>2</mn>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>j</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{j}\beta_{j}^{2}
  </annotation>
 </semantics>
</math>

, which is the squared <a href="Euclidean_norm" title="wikilink">Euclidean norm</a> of the weights, also known as the 

<math display="inline" id="Supervised_learning:45">
 <semantics>
  <msub>
   <mi>L</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{2}
  </annotation>
 </semantics>
</math>

 norm. Other norms include the 

<math display="inline" id="Supervised_learning:46">
 <semantics>
  <msub>
   <mi>L</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{1}
  </annotation>
 </semantics>
</math>

 norm, 

<math display="inline" id="Supervised_learning:47">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mi>j</mi>
   </msub>
   <mrow>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>β</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>j</ci>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{j}|\beta_{j}|
  </annotation>
 </semantics>
</math>

, and the 

<math display="inline" id="Supervised_learning:48">
 <semantics>
  <msub>
   <mi>L</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{0}
  </annotation>
 </semantics>
</math>

 norm, which is the number of non-zero 

<math display="inline" id="Supervised_learning:49">
 <semantics>
  <msub>
   <mi>β</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{j}
  </annotation>
 </semantics>
</math>

s. The penalty will be denoted by 

<math display="inline" id="Supervised_learning:50">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>g</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>g</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(g)
  </annotation>
 </semantics>
</math>

.</p>

<p>The supervised learning optimization problem is to find the function 

<math display="inline" id="Supervised_learning:51">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 that minimizes</p>

<p>

<math display="block" id="Supervised_learning:52">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>J</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>g</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>R</mi>
       <mrow>
        <mi>e</mi>
        <mi>m</mi>
        <mi>p</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>g</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>λ</mi>
      <mi>C</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>g</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>J</ci>
     <ci>g</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <apply>
        <times></times>
        <ci>e</ci>
        <ci>m</ci>
        <ci>p</ci>
       </apply>
      </apply>
      <ci>g</ci>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>C</ci>
      <ci>g</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J(g)=R_{emp}(g)+\lambda C(g).
  </annotation>
 </semantics>
</math>

</p>

<p>The parameter 

<math display="inline" id="Supervised_learning:53">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 controls the bias-variance tradeoff. When 

<math display="inline" id="Supervised_learning:54">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>λ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda=0
  </annotation>
 </semantics>
</math>

, this gives empirical risk minimization with low bias and high variance. When 

<math display="inline" id="Supervised_learning:55">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 is large, the learning algorithm will have high bias and low variance. The value of 

<math display="inline" id="Supervised_learning:56">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 can be chosen empirically via <a href="cross-validation_(statistics)" title="wikilink">cross validation</a>.</p>

<p>The complexity penalty has a Bayesian interpretation as the negative log prior probability of 

<math display="inline" id="Supervised_learning:57">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Supervised_learning:58">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mrow>
    <mrow>
     <mi>log</mi>
     <mi>P</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>g</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <apply>
      <log></log>
      <ci>P</ci>
     </apply>
     <ci>g</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\log P(g)
  </annotation>
 </semantics>
</math>

, in which case 

<math display="inline" id="Supervised_learning:59">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>g</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>J</ci>
    <ci>g</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J(g)
  </annotation>
 </semantics>
</math>

 is the posterior probabability of 

<math display="inline" id="Supervised_learning:60">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="generative-training">Generative training</h2>

<p>The training methods described above are <em>discriminative training</em> methods, because they seek to find a function 

<math display="inline" id="Supervised_learning:61">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 that discriminates well between the different output values (see <a href="discriminative_model" title="wikilink">discriminative model</a>). For the special case where 

<math display="inline" id="Supervised_learning:62">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)=P(x,y)
  </annotation>
 </semantics>
</math>

 is a joint probability distribution and the loss function is the negative log likelihood 

<math display="inline" id="Supervised_learning:63">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mi>i</mi>
     </msub>
     <mrow>
      <mrow>
       <mi>log</mi>
       <mi>P</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <log></log>
       <ci>P</ci>
      </apply>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\sum_{i}\log P(x_{i},y_{i}),
  </annotation>
 </semantics>
</math>

 a risk minimization algorithm is said to perform <em>generative training</em>, because 

<math display="inline" id="Supervised_learning:64">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 can be regarded as a <a href="generative_model" title="wikilink">generative model</a> that explains how the data were generated. Generative training algorithms are often simpler and more computationally efficient than discriminative training algorithms. In some cases, the solution can be computed in closed form as in <a href="Naive_Bayes_classifier" title="wikilink">naive Bayes</a> and <a href="linear_discriminant_analysis" title="wikilink">linear discriminant analysis</a>.</p>
<h2 id="generalizations-of-supervised-learning">Generalizations of supervised learning</h2>

<p>There are several ways in which the standard supervised learning problem can be generalized:</p>
<ol>
<li><a href="Semi-supervised_learning" title="wikilink">Semi-supervised learning</a>: In this setting, the desired output values are provided only for a subset of the training data. The remaining data is unlabeled.</li>
<li><a href="Active_learning_(machine_learning)" title="wikilink">Active learning</a>: Instead of assuming that all of the training examples are given at the start, active learning algorithms interactively collect new examples, typically by making queries to a human user. Often, the queries are based on unlabeled data, which is a scenario that combines semi-supervised learning with active learning.</li>
<li><a href="Structured_prediction" title="wikilink">Structured prediction</a>: When the desired output value is a complex object, such as a parse tree or a labeled graph, then standard methods must be extended.</li>
<li><a href="Learning_to_rank" title="wikilink">Learning to rank</a>: When the input is a set of objects and the desired output is a ranking of those objects, then again the standard methods must be extended.</li>
</ol>
<h2 id="approaches-and-algorithms">Approaches and algorithms</h2>
<ul>
<li><a href="Analytical_learning" title="wikilink">Analytical learning</a></li>
<li><a href="Artificial_neural_network" title="wikilink">Artificial neural network</a></li>
<li><a class="uri" href="Backpropagation" title="wikilink">Backpropagation</a></li>
<li><a href="Boosting_(meta-algorithm)" title="wikilink">Boosting (meta-algorithm)</a></li>
<li><a href="Bayesian_statistics" title="wikilink">Bayesian statistics</a></li>
<li><a href="Case-based_reasoning" title="wikilink">Case-based reasoning</a></li>
<li><a href="Decision_tree_learning" title="wikilink">Decision tree learning</a></li>
<li><a href="Inductive_logic_programming" title="wikilink">Inductive logic programming</a></li>
<li><a href="Gaussian_process_regression" title="wikilink">Gaussian process regression</a></li>
<li><a href="Group_method_of_data_handling" title="wikilink">Group method of data handling</a></li>
<li><a href="Variable_kernel_density_estimation#Use_for_statistical_classification" title="wikilink">Kernel estimators</a></li>
<li><a href="Learning_Automata" title="wikilink">Learning Automata</a></li>
<li><a href="Minimum_message_length" title="wikilink">Minimum message length</a> (<a href="decision_tree" title="wikilink">decision trees</a>, decision graphs, etc.)</li>
<li><a href="Multilinear_subspace_learning" title="wikilink">Multilinear subspace learning</a></li>
<li><a href="Naive_bayes_classifier" title="wikilink">Naive bayes classifier</a></li>
<li><a href="Nearest_neighbor_(pattern_recognition)" title="wikilink">Nearest Neighbor Algorithm</a></li>
<li><a href="Probably_approximately_correct_learning" title="wikilink">Probably approximately correct learning</a> (PAC) learning</li>
<li><a href="Ripple_down_rules" title="wikilink">Ripple down rules</a>, a knowledge acquisition methodology</li>
<li><a href="Symbolic_machine_learning" title="wikilink">Symbolic machine learning</a> algorithms</li>
<li><a href="Subsymbolic_machine_learning" title="wikilink">Subsymbolic machine learning</a> algorithms</li>
<li><a href="Support_vector_machine" title="wikilink">Support vector machines</a></li>
<li><a href="Random_forest" title="wikilink">Random Forests</a></li>
<li><a href="Ensembles_of_Classifiers" title="wikilink">Ensembles of Classifiers</a></li>
<li><a href="Ordinal_classification" title="wikilink">Ordinal classification</a></li>
<li><a href="Data_Pre-processing" title="wikilink">Data Pre-processing</a></li>
<li><a href="Handling_imbalanced_datasets" title="wikilink">Handling imbalanced datasets</a></li>
<li><a href="Statistical_relational_learning" title="wikilink">Statistical relational learning</a></li>
<li><a class="uri" href="Proaftn" title="wikilink">Proaftn</a>, a multicriteria classification algorithm</li>
</ul>
<h2 id="applications">Applications</h2>
<ul>
<li><a class="uri" href="Bioinformatics" title="wikilink">Bioinformatics</a></li>
<li><a class="uri" href="Cheminformatics" title="wikilink">Cheminformatics</a>
<ul>
<li><a href="Quantitative_structure–activity_relationship" title="wikilink">Quantitative structure–activity relationship</a></li>
</ul></li>
<li><a href="Database_marketing" title="wikilink">Database marketing</a></li>
<li><a href="Handwriting_recognition" title="wikilink">Handwriting recognition</a></li>
<li><a href="Information_retrieval" title="wikilink">Information retrieval</a>
<ul>
<li><a href="Learning_to_rank" title="wikilink">Learning to rank</a></li>
</ul></li>
<li>Object recognition in <a href="computer_vision" title="wikilink">computer vision</a></li>
<li><a href="Optical_character_recognition" title="wikilink">Optical character recognition</a></li>
<li><a href="Spamming" title="wikilink">Spam detection</a></li>
<li><a href="Pattern_recognition" title="wikilink">Pattern recognition</a></li>
<li><a href="Speech_recognition" title="wikilink">Speech recognition</a></li>
</ul>
<h2 id="general-issues">General issues</h2>
<ul>
<li><a href="Computational_learning_theory" title="wikilink">Computational learning theory</a></li>
<li><a href="Inductive_bias" title="wikilink">Inductive bias</a></li>
<li><a href="Overfitting_(machine_learning)" title="wikilink">Overfitting (machine learning)</a></li>
<li>(Uncalibrated) <a href="Class_membership_probabilities" title="wikilink">Class membership probabilities</a></li>
<li><a href="Version_space" title="wikilink">Version spaces</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.mloss.org">mloss.org</a>: a directory of open source machine learning software.</li>
</ul>

<p>"</p>

<p><a href="Category:Machine_learning" title="wikilink">Category:Machine learning</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Mehryar_Mohri" title="wikilink">Mehryar Mohri</a>, Afshin Rostamizadeh, Ameet Talwalkar (2012) <em>Foundations of Machine Learning</em>, The MIT Press ISBN 9780262018258.<a href="#fnref1">↩</a></li>
<li id="fn2">S. Geman, E. Bienenstock, and R. Doursat (1992). Neural networks and the bias/variance dilemma. Neural Computation 4, 1–58.<a href="#fnref2">↩</a></li>
<li id="fn3">G. James (2003) Variance and Bias for General Loss Functions, Machine Learning 51, 115-135. (http://www-bcf.usc.edu/~gareth/research/bv.pdf)<a href="#fnref3">↩</a></li>
<li id="fn4">C.E. Brodely and M.A. Friedl (1999). Identifying and Eliminating Mislabeled Training Instances, Journal of Artificial Intelligence Research 11, 131-167. (http://jair.org/media/606/live-606-1803-jair.pdf)<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6">Vapnik, V. N. The Nature of Statistical Learning Theory (2nd Ed.), Springer Verlag, 2000.<a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
