   Shor's algorithm      Shor's algorithm   Shor's algorithm , named after mathematician Peter Shor , is a quantum algorithm (an algorithm that runs on a quantum computer ) for integer factorization formulated in 1994. Informally it solves the following problem: given an integer N , find its prime factors .  On a quantum computer, to factor an integer N , Shor's algorithm runs in polynomial time (the time taken is polynomial in log N , which is the size of the input). 1 Specifically it takes time and quantum gates of order ) using fast multiplication, 2 demonstrating that the integer factorization problem can be efficiently solved on a quantum computer and is thus in the complexity class  BQP . This is substantially faster than the most efficient known classical factoring algorithm, the general number field sieve , which works in sub-exponential time — about . 3 The efficiency of Shor's algorithm is due to the efficiency of the quantum Fourier transform , and modular exponentiation by repeated squarings .  If a quantum computer with a sufficient number of qubits could operate without succumbing to noise and other quantum decoherence phenomena, Shor's algorithm could be used to break public-key cryptography schemes such as the widely used RSA scheme. RSA is based on the assumption that factoring large numbers is computationally intractable. So far as is known, this assumption is valid for classical (non-quantum) computers; no classical algorithm is known that can factor in polynomial time. However, Shor's algorithm shows that factoring is efficient on an ideal quantum computer, so it may be feasible to defeat RSA by constructing a large quantum computer. It was also a powerful motivator for the design and construction of quantum computers and for the study of new quantum computer algorithms. It has also facilitated research on new cryptosystems that are secure from quantum computers, collectively called post-quantum cryptography .  In 2001, Shor's algorithm was demonstrated by a group at IBM, who factored 15 into 3 × 5, using an NMR implementation of a quantum computer with 7 qubits . 4 After IBM's implementation, two independent groups, one at the University of Science and Technology of China , and the other one at the University of Queensland, have implemented Shor's algorithm using photonic qubits, emphasizing that multi-qubit entanglement was observed when running the Shor's algorithm circuits. 5 6 In 2012, the factorization of 15 was repeated. 7 Also in 2012, the factorization of 21 was achieved, setting the record for the largest number factored with a quantum computer. 8 In April 2012, the factorization of 143 was achieved, although this used adiabatic quantum computation rather than Shor's algorithm. 9 It was discovered in November 2014 that this adiabatic quantum computation in 2012 had in fact also factored larger numbers, the largest being 56153, which is currently the record for the largest integer factored on a quantum device. 10 11  Procedure  The problem we are trying to solve is: given an odd composite number    N   N   N   , find an integer   d   d   d   , strictly between   1   1   1   and   N   N   N   , that divides   N   N   N   . We are interested in odd values of   N   N   N   because any even value of   N   N   N   trivially has the number   2   2   2   as a prime factor. We can use a primality testing algorithm to make sure that   N   N   N   is indeed composite.  Moreover, for the algorithm to work, we need   N   N   N   not to be the power of a prime. This can be tested by taking square, cubic, ...,   k   k   k   -roots of   N   N   N   , for    k  ≤    log  2    (  N  )        k    subscript   2   N     k\leq\log_{2}(N)   , and checking that none of these is an integer. (This actually excludes that    N  =   M  k       N   superscript  M  k     N=M^{k}   for some integer   M   M   M   and    k  >  1      k  1    k>1   .)  Since   N   N   N   is not a power of a prime, it is the product of two coprime numbers greater than   1   1   1   . As a consequence of the Chinese remainder theorem , the number   1   1   1   has at least four distinct square roots modulo    N   N   N   , two of them being   1   1   1   and    -  1      1    -1   . The aim of the algorithm is to find a square root   b   b   b   of one, other than   1   1   1   and    -  1      1    -1   ; such a   b   b   b   will lead to a factorization of   N   N   N   , as in other factoring algorithms like the quadratic sieve .  In turn, finding such a   b   b   b   is reduced to finding an element   a   a   a   of even period with a certain additional property (as explained below, it is required that the condition of Step 6 of the classical part does not hold). The quantum algorithm is used for finding the period of randomly chosen elements   a   a   a   , as order-finding is a hard problem on a classical computer.  Shor's algorithm consists of two parts:   A reduction, which can be done on a classical computer, of the factoring problem to the problem of order -finding.  A quantum algorithm to solve the order-finding problem.   Classical part  For example     N  =  15   ,    a  =  7   ,   r  =  4       formulae-sequence    N  15    formulae-sequence    a  7     r  4      N=15,a=7,r=4   ,     g  c  d   (    7  2   ±  1   ,  15  )    =   g  c  d   (   49  ±  1   ,  15  )          g  c  d    plus-or-minus   superscript  7  2   1   15      g  c  d    plus-or-minus  49  1   15      gcd(7^{2}\pm 1,15)=gcd(49\pm 1,15)   , where     g  c  d   (  48  ,  15  )    =  3        g  c  d   48  15    3    gcd(48,15)=3   , and     g  c  d   (  50  ,  15  )    =  5        g  c  d   50  15    5    gcd(50,15)=5   .  Quantum part: Period-finding subroutine  The quantum circuits used for this algorithm are custom designed for each choice of N and each choice of the random a used in f ( x ) = a x  mod  N . Given N , find Q = 2 q such that     N  2   ≤  Q  <   2   N  2           superscript  N  2   Q         2   superscript  N  2       N^{2}\leq Q<2N^{2}   , which implies     Q  /  r   >  N        Q  r   N    Q/r>N   . The input and output qubit registers need to hold superpositions of values from 0 to Q − 1, and so have q qubits each. Using what might appear to be twice as many qubits as necessary guarantees that there are at least N different x which produce the same f ( x ), even as the period r approaches N /2.  Proceed as follows:  Explanation of the algorithm  The algorithm is composed of two parts. The first part of the algorithm turns the factoring problem into the problem of finding the period of a function, and may be implemented classically. The second part finds the period using the quantum Fourier transform, and is responsible for the quantum speedup.  Obtaining factors from period  The integers less than N and coprime with N form a finite Abelian group    G   G   G   under multiplication modulo  N . The size is given by Euler's totient function     ϕ   (  N  )       ϕ  N    \phi(N)   . By the end of step 3, we have an integer a in this group. Since the group is finite, a must have a finite order r , the smallest positive integer such that        a  r   ≡    1    mod   N    .       superscript  a  r     1  mod  N     a^{r}\equiv 1\ \mbox{mod}\ N.\,   Therefore, N  divides (also written | ) a  r − 1 . Suppose we are able to obtain r , and it is even. (If r is odd, see step 5.) Now    b  ≡    a   r  /  2       (   mod  N   )        b   annotated   superscript  a    r  2     pmod  N      b\equiv a^{r/2}\;\;(\mathop{{\rm mod}}N)   is a square root of 1 modulo   N   N   N   , different from 1. This is because   r   r   r   is the order of   a   a   a   modulo   N   N   N   , so     a   r  /  2    ≢   1     (   mod  N   )       not-equivalent-to   superscript  a    r  2     annotated  1   pmod  N      a^{r/2}\not\equiv 1\;\;(\mathop{{\rm mod}}N)   , else the order of   a   a   a   in this group would be    r  /  2      r  2    r/2   . If     a   r  /  2    ≡    -  1      (   mod  N   )         superscript  a    r  2     annotated    1    pmod  N      a^{r/2}\equiv-1\;\;(\mathop{{\rm mod}}N)   , by step 6 we have to restart the algorithm with a different random number   a   a   a   .  Eventually, we must hit an   a   a   a   , of order   r   r   r   in   G   G   G   , such that     b  ≡   a   r  /  2    ≢  1   ,    -  1      (   mod  N   )       formulae-sequence      b   superscript  a    r  2      not-equivalent-to    1     annotated    1    pmod  N      b\equiv a^{r/2}\not\equiv 1,-1\;\;(\mathop{{\rm mod}}N)   . This is because such a   b   b   b   is a square root of 1 modulo   N   N   N   , other than 1 and    -  1      1    -1   , whose existence is guaranteed by the Chinese remainder theorem, since   N   N   N   is not a prime power.  We claim that    d  =   gcd   (   b  -  1   ,  N  )        d   gcd    b  1   N     d=\operatorname{gcd}(b-1,N)   is a proper factor of   N   N   N   , that is,    d  ≠   1  ,  N       d   1  N     d\neq 1,N   . In fact if    d  =  N      d  N    d=N   , then   N   N   N   divides    b  -  1      b  1    b-1   , so that    b  ≡   1     (   mod  N   )        b   annotated  1   pmod  N      b\equiv 1\;\;(\mathop{{\rm mod}}N)   , against the construction of   b   b   b   . If on the other hand    d  =   gcd   (   b  -  1   ,  N  )    =  1        d   gcd    b  1   N        1     d=\operatorname{gcd}(b-1,N)=1   , then by Bézout's identity there are integers    u  ,  v     u  v    u,v   such that         (   b  -  1   )   u   +   N  v    =  1            b  1   u     N  v    1    (b-1)u+Nv=1   . Multiplying both sides by    b  +  1      b  1    b+1   we obtain         (    b  2   -  1   )   u   +   N   (   b  +  1   )   v    =   b  +  1              superscript  b  2   1   u     N    b  1   v      b  1     (b^{2}-1)u+N(b+1)v=b+1   . Since   N   N   N   divides      b  2   -  1   ≡     a  r   -  1      (   mod  N   )           superscript  b  2   1    annotated     superscript  a  r   1    pmod  N      b^{2}-1\equiv a^{r}-1\;\;(\mathop{{\rm mod}}N)   , we obtain that   N   N   N   divides    b  +  1      b  1    b+1   , so that    b  ≡    -  1      (   mod  N   )        b   annotated    1    pmod  N      b\equiv-1\;\;(\mathop{{\rm mod}}N)   , again contradicting the construction of   b   b   b   .  Thus   d   d   d   is the required proper factor of   N   N   N   .  Finding the period  Shor's period-finding algorithm relies heavily on the ability of a quantum computer to be in many states simultaneously. Physicists call this behavior a " superposition " of states. To compute the period of a function f , we evaluate the function at all points simultaneously.  Quantum physics does not allow us to access all this information directly, though. A measurement will yield only one of all possible values, destroying all others. If not for the no cloning theorem , we could first measure f ( x ) without measuring x , and then make a few copies of the resulting state (which is a superposition of states all having the same f ( x )). Measuring x on these states would provide different x values which give the same f ( x ), leading to the period. Because we cannot make exact copies of a quantum state , this method does not work. Therefore we have to carefully transform the superposition to another state that will return the correct answer with high probability. This is achieved by the quantum Fourier transform .  Shor thus had to solve three "implementation" problems. All of them had to be implemented "fast", which means that they can be implemented with a number of quantum gates that is polynomial in    log  N      N    \log N   .   Create a superposition of states. This can be done by applying Hadamard gates to all qubits in the input register. Another approach would be to use the quantum Fourier transform (see below).  Implement the function f as a quantum transform. To achieve this, Shor used repeated squaring for his modular exponentiation transformation. It is important to note that this step is more difficult to implement than the quantum Fourier transform, in that it requires ancillary qubits and substantially more gates to accomplish.  Perform a quantum Fourier transform. By using controlled rotation gates and Hadamard gates, Shor designed a circuit for the quantum Fourier transform (with Q = 2 q ) that uses just      q   (   q  -  1   )    /  2   =   O   (    (   log  Q   )   2   )            q    q  1    2     O   superscript    Q   2      q(q-1)/2=O((\log Q)^{2})   gates. 12   After all these transformations a measurement will yield an approximation to the period r . For simplicity assume that there is a y such that yr/Q is an integer. Then the probability to measure y is 1. To see that we notice that then       e   -    2  π  i  b  y  r   /  Q     =   1        superscript  e        2  π  i  b  y  r   Q     1    e^{-2\pi ibyr/Q}=1\,   for all integers b . Therefore the sum whose square gives us the probability to measure y will be Q/r since b takes roughly Q/r values and thus the probability is    1  /   r  2       1   superscript  r  2     1/r^{2}   . There are r  y such that yr/Q is an integer and also r possibilities for    f   (   x  0   )       f   subscript  x  0     f(x_{0})   , so the probabilities sum to 1.  Note: another way to explain Shor's algorithm is by noting that it is just the quantum phase estimation algorithm in disguise.  The bottleneck  The runtime bottleneck of Shor's algorithm is quantum modular exponentiation , which is by far slower than the quantum Fourier transform and classical pre-/post-processing. There are several approaches to constructing and optimizing circuits for modular exponentiation. The simplest and (currently) most practical approach is to mimic conventional arithmetic circuits with reversible gates , starting with ripple-carry adders. Knowing the base and the modulus of exponentiation facilitates further optimizations. 13 14 Reversible circuits typically use on the order of    n  3     superscript  n  3    n^{3}   gates for   n   n   n   qubits. Alternative techniques asymptotically improve gate counts by using quantum Fourier transforms , but are not competitive with less than 600 qubits due to high constants.  Discrete logarithms  Given prime   p   p   p   with generator   g   g   g   where    r  =     log  g   x      (   mod  p   )        r   annotated    subscript   g   x    pmod  p      r=\log_{g}x\;\;(\mathop{{\rm mod}}p)   , for some r , and we wish to compute r , which is the discrete logarithm       (   ℤ  p   )   ×   ×    (   ℤ  p   )   ×        superscript   subscript  ℤ  p      superscript   subscript  ℤ  p       \left(\mathbb{Z}_{p}\right)^{\times}\times\left(\mathbb{Z}_{p}\right)^{\times}   . Consider the Abelian group      f   (  a  ,  b  )    =     g  a    x   -  b        (   mod  p   )     .        f   a  b     annotated     superscript  g  a    superscript  x    b      pmod  p      f(a,b)=g^{a}x^{-b}\;\;(\mathop{{\rm mod}}p).   where each factor corresponds to modular multiplication of nonzero values, assuming p is prime. Now, consider the function  $$f(a,b) = g^a x^{-b} \pmod{p}.$$  This gives us an Abelian hidden subgroup problem , as f corresponds to a group homomorphism . The kernel corresponds to modular multiples of ( r ,1). So, if we can find the kernel, we can find r .  In popular culture  On the television show Stargate Universe , the lead scientist, Dr. Nicholas Rush , hoped to use Shor's algorithm to crack Destiny 's master code. He taught a quantum cryptography class at the University of California, Berkeley , in which Shor's algorithm was studied.  Shor's algorithm was also a correct answer to a question in a Physics Bowl competition in the episode " The Bat Jar Conjecture " of the TV series The Big Bang Theory .  References  Further reading    .  Phillip Kaye, Raymond Laflamme, Michele Mosca, An introduction to quantum computing , Oxford University Press, 2007, ISBN 0-19-857049-X  "Explanation for the man in the street" by Scott Aaronson , " approved " by Peter Shor. (Shor wrote "Great article, Scott! That’s the best job of explaining quantum computing to the man on the street that I’ve seen."). An alternate metaphor for the QFT was presented in one of the comments . Scott Aaronson suggests the following 12 references as further reading (out of "the 10 10 5000 quantum algorithm tutorials that are already on the web."):   . Revised version of the original paper by Peter Shor ("28 pages, LaTeX. This is an expanded version of a paper that appeared in the Proceedings of the 35th Annual Symposium on Foundations of Computer Science, Santa Fe, NM, Nov. 20--22, 1994. Minor revisions made January, 1996").  Quantum Computing and Shor's Algorithm , Matthew Hayward's Quantum Algorithms Page , 2005-02-17, imsa.edu, LaTeX2HTML version of the original LaTeX document , also available as PDF or postscript document.  Quantum Computation and Shor's Factoring Algorithm , Ronald de Wolf, CWI and University of Amsterdam, January 12, 1999, 9 page postscript document.  Shor's Factoring Algorithm , Notes from Lecture 9 of Berkeley CS 294-2, dated 4 Oct 2004, 7 page postscript document.  Chapter 6 Quantum Computation , 91 page postscript document, Caltech, Preskill, PH229.  Quantum computation: a tutorial by Samuel L. Braunstein .  The Quantum States of Shor's Algorithm , by Neal Young, Last modified: Tue May 21 11:47:38 1996.  III. Breaking RSA Encryption with a Quantum Computer: Shor's Factoring Algorithm , Lecture notes on Quantum computation, Cornell University, Physics 481-681, CS 483; Spring, 2006 by N. David Mermin. Last revised 2006-03-28, 30 page PDF document.  arXiv quant-ph/0303175 Shor's Algorithm for Factoring Large Integers. C. Lavor, L.R.U. Manssur, R. Portugal . Submitted on 29 Mar 2003. This work is a tutorial on Shor's factoring algorithm by means of a worked out example. Some basic concepts of Quantum Mechanics and quantum circuits are reviewed. It is intended for non-specialists which have basic knowledge on undergraduate Linear Algebra. 25 pages, 14 figures, introductory review.  arXiv quant-ph/0010034 Shor's Quantum Factoring Algorithm, Samuel J. Lomonaco, Jr , Submitted October 9, 2000, This paper is a written version of a one hour lecture given on Peter Shor's quantum factoring algorithm. 22 pages.  Chapter 20 Quantum Computation , from Computational Complexity: A Modern Approach , Draft of a book: Dated January 2007, Comments welcome!, Sanjeev Arora and Boaz Barak, Princeton University.  A Step Toward Quantum Computing: Entangling 10 Billion Particles , from "Discover Magazine", Dated January 19, 2011.  Josef Gruska - Quantum Computing Challenges also in Mathematics unlimited: 2001 and beyond , Editors Björn Engquist, Wilfried Schmid, Springer, 2001, ISBN 978-3-540-66913-5   "  Category:Quantum algorithms  Category:Integer factorization algorithms  Category:Quantum information science  Category:Articles containing proofs  Category:Post-quantum cryptography     See also Pseudo-polynomial time . ↩  http://arxiv.org/abs/quant-ph/9602016 - Efficient Networks for Quantum Factoring ↩  MathWorld: Number Field Sieve ↩  ↩  ↩  ↩  http://arxiv.org/pdf/1202.5707v1.pdf - Computing prime factors with a Josephson phase qubit quantum processor ↩  ↩  ↩  ↩  ↩  . ↩  ↩  ↩     