<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1520">Lucas pseudoprime</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Lucas pseudoprime</h1>
<hr/>

<p><strong>Lucas pseudoprime</strong>s and <strong>Fibonacci pseudoprime</strong>s are <a href="composite_number" title="wikilink">composite</a> integers that pass certain tests which all <a href="Prime_number" title="wikilink">primes</a> and very few composite numbers pass: in this case, criteria relative to some <a href="Lucas_sequence" title="wikilink">Lucas sequence</a>.</p>
<h2 id="basic-properties">Basic properties</h2>

<p>Given integers <em>P</em> and <em>Q</em>, where <em>P</em> &gt; 0 and 

<math display="inline" id="Lucas_pseudoprime:0">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>P</mi>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <mrow>
     <mn>4</mn>
     <mi>Q</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">4</cn>
      <ci>Q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=P^{2}-4Q
  </annotation>
 </semantics>
</math>

, let <em>U</em><sub><em>k</em></sub>(<em>P</em>, <em>Q</em>) and <em>V</em><sub><em>k</em></sub>(<em>P</em>, <em>Q</em>) be the corresponding <a href="Lucas_sequence" title="wikilink">Lucas sequences</a>.</p>

<p>Let <em>n</em> be a positive integer and let 

<math display="inline" id="Lucas_pseudoprime:1">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mfrac>
    <mi>D</mi>
    <mi>n</mi>
   </mfrac>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>D</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\tfrac{D}{n}\right)
  </annotation>
 </semantics>
</math>

 be the <a href="Jacobi_symbol" title="wikilink">Jacobi symbol</a>. We define</p>

<p>

<math display="block" id="Lucas_pseudoprime:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mrow>
      <mo>(</mo>
      <mstyle displaystyle="false">
       <mfrac>
        <mi>D</mi>
        <mi>n</mi>
       </mfrac>
      </mstyle>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>δ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <apply>
      <divide></divide>
      <ci>D</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(n)=n-\left(\tfrac{D}{n}\right).
  </annotation>
 </semantics>
</math>

</p>

<p>If <em>n</em> is a <a href="prime_number" title="wikilink">prime</a> such that the <a href="greatest_common_divisor" title="wikilink">greatest common divisor</a> of <em>n</em> and <em>Q</em> (that is, GCD(<em>n, Q</em>)) is 1, then the following congruence condition holds (see page 1391 of <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>):</p>

<p>

<math display="block" id="Lucas_pseudoprime:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow></mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow></mrow>
     <msub>
      <mi>U</mi>
      <mrow>
       <mi>δ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msub>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mn>0</mn>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <mtext></mtext>
     <cn type="integer">1</cn>
     <mtext></mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <apply>
       <times></times>
       <ci>δ</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{ }(1)\text{ }U_{\delta(n)}\equiv 0\;\;(\mathop{{\rm mod}}n).
  </annotation>
 </semantics>
</math>

</p>

<p>If this equation does <em>not</em> hold, then <em>n</em> is <em>not</em> prime. If <em>n</em> is <em>composite</em>, then this equation usually does <em>not</em> hold (see,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> page 1392). These are the key facts that make Lucas sequences useful in <a href="primality_test" title="wikilink">primality testing</a>.</p>

<p>Some good references are chapter 8 of the book by Bressoud and Wagon (with <a class="uri" href="Mathematica" title="wikilink">Mathematica</a> code),<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> pages 142-152 of the book by Crandall and Pomerance,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> and pages 53–74 of the book by Ribenboim .<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="lucas-probable-primes-and-pseudoprimes">Lucas probable primes and pseudoprimes</h2>

<p>A <strong>Lucas probable prime</strong> for a given (<em>P, Q</em>) pair is <em>any</em> positive integer <em>n</em> for which equation (1) above is true (see,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> page 1398).</p>

<p>A <strong>Lucas pseudoprime</strong> for a given (<em>P, Q</em>) pair is a positive <em>composite</em> integer <em>n</em> for which equation (1) is true (see,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> page 1391).</p>

<p>A Lucas probable prime test is most useful if <em>D</em> is chosen such that the Jacobi symbol 

<math display="inline" id="Lucas_pseudoprime:4">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mfrac>
    <mi>D</mi>
    <mi>n</mi>
   </mfrac>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>D</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\tfrac{D}{n}\right)
  </annotation>
 </semantics>
</math>

 is −1 (see pages 1401-1409 of,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> page 1024 of ,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> or pages 266-269 of <a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> ). This is especially important when combining a Lucas test with a <a href="strong_pseudoprime" title="wikilink">strong pseudoprime</a> test, such as the <a href="Baillie-PSW_primality_test" title="wikilink">Baillie-PSW primality test</a>. Typically implementations will use a parameter selection method that ensures this condition (e.g. the Selfridge method recommended in <a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> and described below).</p>

<p>If 

<math display="inline" id="Lucas_pseudoprime:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mi>D</mi>
      <mi>n</mi>
     </mfrac>
     <mo>)</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>D</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\tfrac{D}{n}\right)=-1,
  </annotation>
 </semantics>
</math>

 then equation (1) becomes</p>

<p>

<math display="block" id="Lucas_pseudoprime:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow></mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow></mrow>
     <msub>
      <mi>U</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mn>0</mn>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <mtext></mtext>
     <cn type="integer">2</cn>
     <mtext></mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{ }(2)\text{ }U_{n+1}\equiv 0\;\;(\mathop{{\rm mod}}n).
  </annotation>
 </semantics>
</math>

</p>

<p>If congruence (2) is false, this constitutes a proof that <em>n</em> is composite.</p>

<p>If congruence (2) is true, then <em>n</em> is a Lucas probable prime. In this case, either <em>n</em> prime or it is a Lucas pseudoprime. If congruence (2) is true, then <em>n</em> is <em>likely</em> to be prime (this justifies the term <strong>probable</strong> prime), but this does not <em>prove</em> that <em>n</em> is prime. As is the case with any other probabilistic primality test, if we perform additional Lucas tests with different <em>D</em>, <em>P</em> and <em>Q</em>, then unless one of the tests proves that <em>n</em> is composite, we gain more confidence that <em>n</em> is prime.</p>

<p>Examples: If <em>P</em> = 3, <em>Q</em> = −1, and <em>D</em> = 13, the sequence of <em>U</em>'s is : <em>U<sub>0</sub></em> = 0, <em>U<sub>1</sub></em> = 3, <em>U<sub>2</sub></em> = 10, <em>U<sub>3</sub></em> = 33, etc.</p>

<p>First, let <em>n</em> = 19. The Jacobi symbol 

<math display="inline" id="Lucas_pseudoprime:7">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mfrac>
    <mn>13</mn>
    <mn>19</mn>
   </mfrac>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">13</cn>
    <cn type="integer">19</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\tfrac{13}{19}\right)
  </annotation>
 </semantics>
</math>

 is −1, so δ(<em>n</em>) = 20, <em>U<sub>20</sub></em> = 6616217487 = 19·348221973 and we have</p>

<p>

<math display="block" id="Lucas_pseudoprime:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>U</mi>
     <mn>20</mn>
    </msub>
    <mo>=</mo>
    <mn>6616217487</mn>
    <mo>≡</mo>
    <mrow>
     <mn>0</mn>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mn>19</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <cn type="integer">20</cn>
     </apply>
     <cn type="integer">6616217487</cn>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <cn type="integer">0</cn>
      <apply>
       <ci>pmod</ci>
       <cn type="integer">19</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{20}=6616217487\equiv 0\;\;(\mathop{{\rm mod}}19).
  </annotation>
 </semantics>
</math>

 Therefore, 19 is a Lucas probable prime for this (<em>P, Q</em>) pair. In this case 19 is prime, so it is <em>not</em> a Lucas pseudoprime.</p>

<p>For the next example, let <em>n</em> = 119. We have 

<math display="inline" id="Lucas_pseudoprime:9">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mfrac>
    <mn>13</mn>
    <mn>119</mn>
   </mfrac>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">13</cn>
    <cn type="integer">119</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\tfrac{13}{119}\right)
  </annotation>
 </semantics>
</math>

 = −1, and we can compute</p>

<p>

<math display="block" id="Lucas_pseudoprime:10">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>U</mi>
     <mn>120</mn>
    </msub>
    <mo>≡</mo>
    <mrow>
     <mn>0</mn>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mn>119</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <cn type="integer">120</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">119</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{120}\equiv 0\;\;(\mathop{{\rm mod}}119).
  </annotation>
 </semantics>
</math>

 However, 119 = 7·17 is not prime, so 119 is a Lucas <em>pseudoprime</em> for this (<em>P, Q</em>) pair. In fact, 119 is the smallest pseudoprime for <em>P</em> = 3, <em>Q</em> = −1.</p>

<p>We will see below that, in order to check equation (2) for a given <em>n</em>, we do <em>not</em> need to compute all of the first <em>n</em> + 1 terms in the <em>U</em> sequence.</p>

<p>Let <em>Q</em> = -1, the smallest Lucas pseudoprime to <em>P</em> = 1, 2, 3, ... are</p>
<dl>
<dd>323, 35, 119, 9, 9, 143, 25, 33, 9, 15, 123, 35, 9, 9, 15, 129, 51, 9, 33, 15, 21, 9, 9, 49, 15, 39, 9, 35, 49, 15, 9, 9, 33, 51, 15, 9, 35, 85, 39, 9, 9, 21, 25, 51, 9, 143, 33, 119, 9, 9, 51, 33, 95, 9, 15, 301, 25, 9, 9, 15, 49, 155, 9, 399, 15, 33, 9, 9, 49, 15, 119, 9, ...
</dd>
</dl>
<h2 id="strong-lucas-pseudoprimes">Strong Lucas pseudoprimes</h2>

<p>Now, factor 

<math display="inline" id="Lucas_pseudoprime:11">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>δ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(n)
  </annotation>
 </semantics>
</math>

 into the form 

<math display="inline" id="Lucas_pseudoprime:12">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>⋅</mo>
   <msup>
    <mn>2</mn>
    <mi>s</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>d</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\cdot 2^{s}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Lucas_pseudoprime:13">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 is odd.</p>

<p>A <strong>strong Lucas pseudoprime</strong> for a given (<em>P, Q</em>) pair is an odd composite number <em>n</em> with GCD(<em>n, D</em>) = 1, satisfying one of the conditions</p>

<p>

<math display="block" id="Lucas_pseudoprime:14">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mi>d</mi>
   </msub>
   <mo>≡</mo>
   <mrow>
    <mn>0</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>d</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{d}\equiv 0\;\;(\mathop{{\rm mod}}n)
  </annotation>
 </semantics>
</math>

 or</p>

<p>

<math display="block" id="Lucas_pseudoprime:15">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mrow>
     <mi>d</mi>
     <mo>⋅</mo>
     <msup>
      <mn>2</mn>
      <mi>r</mi>
     </msup>
    </mrow>
   </msub>
   <mo>≡</mo>
   <mrow>
    <mn>0</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <apply>
      <ci>normal-⋅</ci>
      <ci>d</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>r</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{d\cdot 2^{r}}\equiv 0\;\;(\mathop{{\rm mod}}n)
  </annotation>
 </semantics>
</math>

</p>

<p>for some <em>r</em>  A strong Lucas pseudoprime is also a Lucas pseudoprime (for the same (<em>P, Q</em>) pair), but the converse is not necessarily true. Therefore, the <strong>strong</strong> test is a more stringent primality test than equation (1).</p>

<p>We can set <em>Q</em> = -1, then 

<math display="inline" id="Lucas_pseudoprime:16">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{n}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lucas_pseudoprime:17">
 <semantics>
  <msub>
   <mi>V</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{n}
  </annotation>
 </semantics>
</math>

 are <em>P</em>-Fibonacci sequence and <em>P</em>-Lucas sequence, the pseudoprimes can be called <strong>strong Lucas pseudoprime in base <em>P</em></strong>, for example, the least strong Lucas pseudoprime with <em>P</em> = 1, 2, 3, ... are 323, 169, 119, ...</p>

<p>An <strong>extra strong Lucas pseudoprime</strong> <a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> is a strong Lucas pseudoprime for a set of parameters (<em>P</em>, <em>Q</em>) where <em>Q</em> = 1, satisfying one of the conditions</p>

<p>

<math display="block" id="Lucas_pseudoprime:18">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mi>d</mi>
   </msub>
   <mo>≡</mo>
   <mn>0</mn>
   <mrow>
    <mo lspace="8.1pt" stretchy="false">(</mo>
    <mrow>
     <mo>mod</mo>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mtext>and</mtext>
   <msub>
    <mi>V</mi>
    <mi>d</mi>
   </msub>
   <mo>≡</mo>
   <mo>±</mo>
   <mn>2</mn>
   <mrow>
    <mo lspace="8.1pt" stretchy="false">(</mo>
    <mrow>
     <mo>mod</mo>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>d</ci>
    </apply>
    <equivalent></equivalent>
    <cn type="integer">0</cn>
    <apply>
     <ci>pmod</ci>
     <ci>n</ci>
    </apply>
    <mtext>and</mtext>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <ci>d</ci>
    </apply>
    <equivalent></equivalent>
    <csymbol cd="latexml">plus-or-minus</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <ci>pmod</ci>
     <ci>n</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{d}\equiv 0\;\;(\mathop{{\rm mod}}n)\text{ and }V_{d}\equiv\pm 2\;\;(\mathop%
{{\rm mod}}n)
  </annotation>
 </semantics>
</math>

 or</p>

<p>

<math display="block" id="Lucas_pseudoprime:19">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mrow>
     <mi>d</mi>
     <mo>⋅</mo>
     <msup>
      <mn>2</mn>
      <mi>r</mi>
     </msup>
    </mrow>
   </msub>
   <mo>≡</mo>
   <mrow>
    <mn>0</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <apply>
      <ci>normal-⋅</ci>
      <ci>d</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>r</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{d\cdot 2^{r}}\equiv 0\;\;(\mathop{{\rm mod}}n)
  </annotation>
 </semantics>
</math>

</p>

<p>for some 

<math display="inline" id="Lucas_pseudoprime:20">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mi>D</mi>
     <mi>n</mi>
    </mfrac>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>D</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\tfrac{D}{n}\right)=-1
  </annotation>
 </semantics>
</math>

 pair.</p>
<h2 id="implementing-a-lucas-probable-prime-test">Implementing a Lucas probable prime test</h2>

<p>Before embarking on a probable prime test, one usually verifies that <em>n</em>, the number to be tested for primality, is odd, is not a perfect square, and is not divisible by any small prime less than some convenient limit.</p>

<p>In this section, we will assume 

<math display="inline" id="Lucas_pseudoprime:21">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mfrac>
    <mi>D</mi>
    <mi>n</mi>
   </mfrac>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>D</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\tfrac{D}{n}\right)
  </annotation>
 </semantics>
</math>

, so that δ(<em>n</em>) = <em>n</em> + 1.</p>

<p>Given <em>n</em>, one technique for choosing <em>D</em> is to use trial and error to find the first <em>D</em> in the sequence 5, −7, 9, −11, ... such that the Jacobi symbol 

<math display="inline" id="Lucas_pseudoprime:22">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mi>D</mi>
     <mi>n</mi>
    </mfrac>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>D</ci>
     <ci>n</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\tfrac{D}{n}\right)=0
  </annotation>
 </semantics>
</math>

 is −1. (If <em>D</em> and <em>n</em> have a factor in common, then 

<math display="inline" id="Lucas_pseudoprime:23">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>D</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mn>4</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Q</ci>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>D</ci>
     </apply>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=(1-D)/4
  </annotation>
 </semantics>
</math>

). Then set <em>P</em> = 1 and 

<math display="inline" id="Lucas_pseudoprime:24">
 <semantics>
  <msub>
   <mi>U</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{n+1}
  </annotation>
 </semantics>
</math>

. Once we have <em>P</em> and <em>Q</em>, it is a good idea to check that <em>n</em> has no factors in common with <em>P</em> or <em>Q</em>.</p>

<p>Given <em>D</em>, <em>P</em>, and <em>Q</em>, there are recurrence relations that enable us to quickly compute 

<math display="inline" id="Lucas_pseudoprime:25">
 <semantics>
  <msub>
   <mi>V</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{n+1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lucas_pseudoprime:26">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 without having to compute all the intermediate terms; see <a href="Lucas_sequence#Other_relations" title="wikilink">Lucas sequence-Other relations</a>. First, we can double the subscript from 

<math display="inline" id="Lucas_pseudoprime:27">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2k
  </annotation>
 </semantics>
</math>

 to 

<math display="block" id="Lucas_pseudoprime:28">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mrow>
     <mn>2</mn>
     <mi>k</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>U</mi>
     <mi>k</mi>
    </msub>
    <mo>⋅</mo>
    <msub>
     <mi>V</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{2k}=U_{k}\cdot V_{k}
  </annotation>
 </semantics>
</math>

 in one step using the recurrence relations</p>

<p>

<math display="block" id="Lucas_pseudoprime:29">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mrow>
     <mn>2</mn>
     <mi>k</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>V</mi>
     <mi>k</mi>
     <mn>2</mn>
    </msubsup>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <msup>
      <mi>Q</mi>
      <mi>k</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>k</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Q</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{2k}=V_{k}^{2}-2Q^{k}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lucas_pseudoprime:30">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>k</mi>
     </mrow>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>P</mi>
       <mo>⋅</mo>
       <msub>
        <mi>U</mi>
        <mrow>
         <mn>2</mn>
         <mi>k</mi>
        </mrow>
       </msub>
      </mrow>
      <mo>+</mo>
      <msub>
       <mi>V</mi>
       <mrow>
        <mn>2</mn>
        <mi>k</mi>
       </mrow>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>k</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <ci>normal-⋅</ci>
       <ci>P</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>U</ci>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{2k+1}=(P\cdot U_{2k}+V_{2k})/2
  </annotation>
 </semantics>
</math>

. Next, we can increase the subscript by 1 using the recurrences</p>

<p>

<math display="block" id="Lucas_pseudoprime:31">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>k</mi>
     </mrow>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>D</mi>
       <mo>⋅</mo>
       <msub>
        <mi>U</mi>
        <mrow>
         <mn>2</mn>
         <mi>k</mi>
        </mrow>
       </msub>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>P</mi>
       <mo>⋅</mo>
       <msub>
        <mi>V</mi>
        <mrow>
         <mn>2</mn>
         <mi>k</mi>
        </mrow>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>k</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <ci>normal-⋅</ci>
       <ci>D</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>U</ci>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <ci>P</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{2k+1}=(D\cdot U_{2k}+P\cdot V_{2k})/2
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Lucas_pseudoprime:32">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>P</mi>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <mrow>
     <mn>4</mn>
     <mi>Q</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">4</cn>
      <ci>Q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=P^{2}-4Q
  </annotation>
 </semantics>
</math>

. (If either of these numerators is odd, we can make it be even by increasing it by <em>n</em>, because all of these calculations are carried out <a href="modular_arithmetic" title="wikilink">modulo</a> <em>n</em>.) Observe that, for each term that we compute in the <em>U</em> sequence, we compute the corresponding term in the <em>V</em> sequence. As we proceed, we also compute powers of <em>Q</em>.</p>

<p>We use the bits of the binary expansion of <em>n</em> + 1, starting at the leftmost bit, to determine <em>which</em> terms in the <em>U</em> sequence need to be computed. For example, if <em>n</em> + 1 = 44 (= 101100 in binary), we compute <em>U</em><sub>1</sub>, <em>U</em><sub>2</sub>, <em>U</em><sub>4</sub>, <em>U</em><sub>5</sub>, <em>U</em><sub>10</sub>, <em>U</em><sub>11</sub>, <em>U</em><sub>22</sub>, and <em>U</em><sub>44</sub>. We also compute the same-numbered terms in the <em>V</em> sequence and those powers of <em>Q</em>.</p>

<p>By the end of the calculation, we will have computed <em>U<sub>n+1</sub></em>, <em>V<sub>n+1</sub></em>, and <em>Q<sup>n+1</sup></em>. We then check equation (2) using our known value of <em>U<sub>n+1</sub></em>.</p>

<p>When <em>D</em>, <em>P</em>, and <em>Q</em> are chosen as described above, the first 10 Lucas pseudoprimes are (see page 1401 of <a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a>): 323, 377, 1159, 1829, 3827, 5459, 5777, 9071, 9179, and 10877 </p>

<p>The <strong>strong</strong> versions of the Lucas test can be implemented in a similar way.</p>

<p>When <em>D</em>, <em>P</em>, and <em>Q</em> are chosen as described above, the first 10 <em>strong</em> Lucas pseudoprimes are: 5459, 5777, 10877, 16109, 18971, 22499, 24569, 25199, 40309, and 58519 </p>

<p>To calculate a list of <em>extra strong</em> Lucas pseudoprimes, set <em>Q</em> = 1. Then try <em>P</em> = 3, 4, 5, 6, ..., until a value of 

<math display="inline" id="Lucas_pseudoprime:33">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mi>D</mi>
     <mi>n</mi>
    </mfrac>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>D</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\tfrac{D}{n}\right)=-1
  </annotation>
 </semantics>
</math>

 is found so that the Jacobi symbol 

<math display="inline" id="Lucas_pseudoprime:34">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mi>D</mi>
     <mi>n</mi>
    </mfrac>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>D</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\tfrac{D}{n}\right)=-1
  </annotation>
 </semantics>
</math>

. With this method for selecting <em>D</em>, <em>P</em>, and <em>Q</em>, the first 10 <em>extra strong</em> Lucas pseudoprimes are 989, 3239, 5777, 10877, 27971, 29681, 30739, 31631, 39059, and 72389 </p>
<h3 id="checking-additional-congruence-conditions">Checking additional congruence conditions</h3>

<p>If we have checked that equation (2) is true, there are additional congruence conditions we can check that have almost no additional computational cost. If <em>n</em> happens not to be prime, these additional conditions may help discover that fact.</p>

<p>If <em>n</em> is an odd prime and 

<math display="block" id="Lucas_pseudoprime:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow></mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>3</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow></mrow>
     <msub>
      <mi>V</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>Q</mi>
     </mrow>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <mtext></mtext>
     <cn type="integer">3</cn>
     <mtext></mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>Q</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{ }(3)\text{ }V_{n+1}\equiv 2Q\;\;(\mathop{{\rm mod}}n).
  </annotation>
 </semantics>
</math>

, then we have the following (see equation 2 on page 1392 of <a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a>):</p>

<p>

<math display="inline" id="Lucas_pseudoprime:36">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mfrac>
    <mi>D</mi>
    <mi>n</mi>
   </mfrac>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>D</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\tfrac{D}{n}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>Although this congruence condition is not, by definition, part of the Lucas probable prime test, it is almost free to check this condition because, as noted above, the value of <em>V<sub>n+1</sub></em> was computed in the process of computing <em>U<sub>n+1</sub></em>.</p>

<p>If either equation (2) or (3) is false, this constitutes a proof that <em>n</em> is not prime. If <em>both</em> of these conditions are true, then it is even more likely that <em>n</em> is prime than if we had checked only equation (2).</p>

<p>If the above method for choosing <em>D</em> happened to set <em>Q</em> = −1, then we can adjust <em>P</em> and <em>Q</em> so that <em>D</em> and 

<math display="inline" id="Lucas_pseudoprime:37">
 <semantics>
  <msup>
   <mi>Q</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>Q</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q^{n+1}
  </annotation>
 </semantics>
</math>

 remain unchanged and <em>P</em> = <em>Q</em> = 5 (see <a href="Lucas_sequence#Algebraic_relations" title="wikilink">Lucas sequence-Algebraic relations</a>). If we make this adjustment, there is only <em>one</em> composite <em>n</em> 8 for which equation (3) is true (see page 1409 and Table 6 of;<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> this <em>n</em> is 913 = 11·83).</p>

<p>Here is yet another congruence condition that is true for primes and that is trivial to check.</p>

<p>First, recall that 

<math display="inline" id="Lucas_pseudoprime:38">
 <semantics>
  <msub>
   <mi>U</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{n+1}
  </annotation>
 </semantics>
</math>

 is computed during the calculation of 

<math display="inline" id="Lucas_pseudoprime:39">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

. It would be easy to save the previously-computed power of 

<math display="inline" id="Lucas_pseudoprime:40">
 <semantics>
  <msup>
   <mi>Q</mi>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>Q</ci>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q^{(n+1)/2}
  </annotation>
 </semantics>
</math>

, namely, 

<math display="block" id="Lucas_pseudoprime:41">
 <semantics>
  <mrow>
   <msup>
    <mi>Q</mi>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mstyle displaystyle="false">
      <mfrac>
       <mi>Q</mi>
       <mi>n</mi>
      </mfrac>
     </mstyle>
     <mo>)</mo>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Q</ci>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <divide></divide>
      <ci>Q</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q^{(n-1)/2}\equiv\left(\tfrac{Q}{n}\right)\;\;(\mathop{{\rm mod}}n)
  </annotation>
 </semantics>
</math>

.</p>

<p>Next, if <em>n</em> is prime, then, by <a href="Euler's_criterion" title="wikilink">Euler's criterion</a>,</p>

<p>

<math display="inline" id="Lucas_pseudoprime:42">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mfrac>
    <mi>Q</mi>
    <mi>n</mi>
   </mfrac>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>Q</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\tfrac{Q}{n}\right)
  </annotation>
 </semantics>
</math>

 . (Here, 

<math display="block" id="Lucas_pseudoprime:43">
 <semantics>
  <mrow>
   <mrow>
    <mrow></mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>4</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow></mrow>
    <msup>
     <mi>Q</mi>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mi>Q</mi>
    <mo>⋅</mo>
    <msup>
     <mi>Q</mi>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mo>⋅</mo>
     <mrow>
      <mo>(</mo>
      <mstyle displaystyle="false">
       <mfrac>
        <mi>Q</mi>
        <mi>n</mi>
       </mfrac>
      </mstyle>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <times></times>
      <mtext></mtext>
      <cn type="integer">4</cn>
      <mtext></mtext>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Q</ci>
       <apply>
        <divide></divide>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Q</ci>
       <apply>
        <divide></divide>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <apply>
       <ci>normal-⋅</ci>
       <ci>Q</ci>
       <apply>
        <divide></divide>
        <ci>Q</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <ci>pmod</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{ }(4)\text{ }Q^{(n+1)/2}\equiv Q\cdot Q^{(n-1)/2}\equiv Q\cdot\left(%
\tfrac{Q}{n}\right)\;\;(\mathop{{\rm mod}}n)
  </annotation>
 </semantics>
</math>

 is the <a href="Legendre_symbol" title="wikilink">Legendre symbol</a>; if <em>n</em> is prime, this is the same as the Jacobi symbol). Therefore, if <em>n</em> is prime, we must have</p>

<p>

<math display="block" id="Lucas_pseudoprime:44">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow></mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>5</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow></mrow>
     <msub>
      <mi>V</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mi>P</mi>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <mtext></mtext>
     <cn type="integer">5</cn>
     <mtext></mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <ci>P</ci>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{ }(5)\text{ }V_{n}\equiv P\;\;(\mathop{{\rm mod}}n).
  </annotation>
 </semantics>
</math>

 . The Jacobi symbol on the right side is easy to compute, so this congruence is easy to check. If this congruence does not hold, then <em>n</em> cannot be prime.</p>

<p>Additional congruence conditions that must be satisfied if <em>n</em> is prime are described in Section 6 of.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> If <em>any</em> of these conditions fails to hold, then we have proved that <em>n</em> is not prime.</p>
<h2 id="comparison-with-the-miller-rabin-primality-test">Comparison with the Miller-Rabin primality test</h2>

<p><em>k</em> applications of the <a href="Miller-Rabin_primality_test" title="wikilink">Miller-Rabin primality test</a> declare a composite <em>n</em> to be probably prime with a probability at most (1/4)<sup><em>k</em></sup>.</p>

<p>There is a similar probability estimate for the strong Lucas probable prime test.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p>Aside from two trivial exceptions (see below), the fraction of (<em>P</em>,<em>Q</em>) pairs (modulo <em>n</em>) that declare a composite <em>n</em> to be probably prime is at most (4/15).</p>

<p>Therefore, <em>k</em> applications of the strong Lucas test would declare a composite <em>n</em> to be probably prime with a probability at most (4/15)<sup>k</sup>.</p>

<p>There are two trivial exceptions. One is <em>n</em> = 9. The other is when <em>n</em> = <em>p</em>(<em>p</em>+2) is the product of two <a href="twin_prime" title="wikilink">twin primes</a>. Such an <em>n</em> is easy to factor, because in this case, <em>n</em>+1 = (<em>p</em>+1)<sup>2</sup> is a perfect square. One can quickly detect perfect squares using <a href="Newton's_method" title="wikilink">Newton's method</a> for square roots.</p>

<p>By combining a Lucas pseudoprime test with a <a href="Fermat_primality_test" title="wikilink">Fermat primality test</a>, say, to base 2, one can obtain very powerful probabilistic tests for primality, such as the <a href="Baillie-PSW_primality_test" title="wikilink">Baillie-PSW primality test</a>.</p>
<h2 id="fibonacci-pseudoprimes">Fibonacci pseudoprimes</h2>

<p>As noted above, when <em>P</em> = 1 and <em>Q</em> = −1, the numbers in the <em>U</em> sequence are the Fibonacci numbers.</p>

<p>A <strong>Fibonacci pseudoprime</strong> is often (page 264 of,<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> page 142 of,<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> or page 127 of <a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a>) defined as a composite number <em>n</em> for which equation (1) above is true with <em>P</em> = 1 and <em>Q</em> = −1 (but <em>n</em> is not divisible by 5). By this definition, the first ten Fibonacci pseudoprimes are 323, 377, 1891, 3827, 4181, 5777, 6601, 6721, 8149, and 10877 . The references of Anderson and Jacobsen below use this definition.</p>

<p>If <em>n</em> is congruent to 2 or 3 (mod 5), then Bressoud (,<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> pages 272-273) and Crandall and Pomerance (,<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> page 143 and exercise 3.41 on page 168) point out that it is rare for a Fibonacci pseudoprime to also be a <a href="Fermat_pseudoprime" title="wikilink">Fermat pseudoprime</a> base 2. However when <em>n</em> is congruent to 1 or 4 (mod 5), the opposite is true, with over 12% of Fibonacci pseudoprimes under 10<sup>11</sup> also being base-2 Fermat pseudoprimes.</p>

<p>If <em>n</em> is prime and GCD(<em>n</em>, <em>Q</em>) = 1, then (see equation 4 on page 1392 of <a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a>) we also have</p>

<p>

<math display="block" id="Lucas_pseudoprime:45">
 <semantics>
  <mrow>
   <mrow>
    <mrow></mrow>
    <msub>
     <mi>U</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mstyle displaystyle="false">
      <mfrac>
       <mn>2</mn>
       <mi>n</mi>
      </mfrac>
     </mstyle>
     <mo>)</mo>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <mtext></mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{ }U_{n}\equiv\left(\tfrac{2}{n}\right)\;\;(\mathop{{\rm mod}}n)
  </annotation>
 </semantics>
</math>

</p>

<p>This leads to an alternate definition of Fibonacci pseudoprime.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> By this definition, a <strong>Fibonacci pseudoprime</strong> is a composite number <em>n</em> for which equation (5) is true with <em>P</em> = 1 and <em>Q</em> = −1. Using this definition, the first ten Fibonacci pseudoprimes are 705, 2465, 2737, 3745, 4181, 5777, 6721, 10877, 13201, and 15251 (<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> page 129).</p>

<p>It has been shown that there are no even Fibonacci pseudoprimes with the second definition using equation (5).<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> Using the more common first definition with equation (1), they do exist .</p>

<p>A <strong>strong Fibonacci pseudoprime</strong> may be defined as a composite number for which equation (5) holds for all <em>P</em>.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> It follows (<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> page 460) that an odd composite integer is a strong Fibonacci pseudoprime if and only if:</p>
<ol>
<li><em>n</em> is also a <a href="Carmichael_number" title="wikilink">Carmichael number</a></li>
<li>2(<em>p</em><sub><em>i</em></sub> + 1) | (<em>n</em> − 1) or 2(<em>p</em><sub><em>i</em></sub> + 1) | (<em>n</em> − <em>p</em><sub><em>i</em></sub>) for every prime <em>p</em><sub><em>i</em></sub> dividing <em>n</em>.</li>
</ol>

<p>The smallest example of a strong Fibonacci pseudoprime is 443372888629441 = 17·31·41·43·89·97·167·331.</p>
<h2 id="pell-pseudoprimes">Pell pseudoprimes</h2>

<p>A <strong>Pell pseudoprime</strong> may be defined as a composite number <em>n</em> for which equation (1) above is true with <em>P</em> = 2 and <em>Q</em> = −1; the sequence <em>U<sub>n</sub></em> then being the <a href="Pell_sequence" title="wikilink">Pell sequence</a>. The first pseudoprimes are then 35, 169, 385, 779, 899, 961, 1121, 1189, 2419, ...</p>

<p>This differs from the definition in  which may be written as:</p>

<p><span class="LaTeX">$$\text{  } U_n \equiv \left(\tfrac{2}{n}\right) \pmod {n}$$</span></p>

<p>with (<em>P</em>, <em>Q</em>) = (2, -1) again defining <em>U<sub>n</sub></em> as the <a href="Pell_sequence" title="wikilink">Pell sequence</a>. The first pseudoprimes are then 169, 385, 741, 961, 1121, 2001, 3827, 4879, 5719, 6215 ...</p>

<p>A third definition uses equation (5) with (<em>P</em>, <em>Q</em>) = (2, -1), leading to the pseudoprimes 169, 385, 961, 1105, 1121, 3827, 4901, 6265, 6441, 6601, 7107, 7801, 8119, ...</p>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li>Anderson, Peter G. <a href="http://www.cs.rit.edu/usr/local/pub/pga/fpp_and_entry_pts">Fibonacci Pseudoprimes, their factors, and their entry points.</a></li>
<li>Anderson, Peter G. <a href="http://www.cs.rit.edu/usr/local/pub/pga/fibonacci_pp">Fibonacci Pseudoprimes under 2,217,967,487 and their factors.</a></li>
<li>Jacobsen, Dana <a href="http://ntheory.org/pseudoprimes.html">Pseudoprime Statistics, Tables, and Data</a> (data for Lucas, Strong Lucas, AES Lucas, ES Lucas pseudoprimes below 10<sup>14</sup>; Fibonacci and Pell pseudoprimes below 10<sup>12</sup>)</li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Fibonacci_numbers" title="wikilink">Category:Fibonacci numbers</a> <a class="uri" href="Category:Pseudoprimes" title="wikilink">Category:Pseudoprimes</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"><mtpl></mtpl><a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"></li>
</ol>
</section>
</body>
</html>
