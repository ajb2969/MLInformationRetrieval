<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1086">Constraint satisfaction dual problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Constraint satisfaction dual problem</h1>
<hr/>

<p>The <strong>dual problem</strong> is a reformulation of a <a href="constraint_satisfaction_problem" title="wikilink">constraint satisfaction problem</a> expressing each constraint of the original problem as a variable. Dual problems only contain <a href="binary_constraint" title="wikilink">binary constraints</a>, and are therefore solvable by <a href="algorithm" title="wikilink">algorithms</a> tailored for such problems. The <strong>join graphs</strong> and <strong>join trees</strong> of a constraint satisfaction problem are <a href="Graph_(graph_theory)" title="wikilink">graphs</a> representing its dual problem or a problem obtained from the dual problem removing some redundant constraints.</p>
<h2 id="the-dual-problem">The dual problem</h2>

<p>The dual problem of a constraint satisfaction problem contains a variable for each constraint of the original problem. Its domains and constraints are built so to enforce a sort of equivalence to the original problem. In particular, the domain of a variable of the dual problem contains one element for each tuple satisfying the corresponding original constraint. This way, a dual variable can take a value if and only if the corresponding original constraint is satisfied by the corresponding tuple.</p>

<p>The constraints of the dual problem forbid two dual variables to take values that correspond to two incompatible tuples. Without these constraints, one dual variable may take the value corresponding to the tuple 

<math display="inline" id="Constraint_satisfaction_dual_problem:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>y</mi>
    <mo>=</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <eq></eq>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=1,y=2
  </annotation>
 </semantics>
</math>

 while another dual variable takes the value corresponding to 

<math display="inline" id="Constraint_satisfaction_dual_problem:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mo>=</mo>
    <mn>3</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>z</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>y</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <eq></eq>
     <ci>z</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=3,z=1
  </annotation>
 </semantics>
</math>

, which assigns a different value to 

<math display="inline" id="Constraint_satisfaction_dual_problem:2">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

.</p>

<p>More generally, the constraints of the dual problem enforce the same values for all variables shared by two constraints. If two dual variables correspond to constraints sharing some variables, the dual problem contains a constraint between them, enforcing equality of all shared variables.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Csp-dual-1.svg</figcaption>
</figure>
<hr/></td>
<td style="text-align: left;">
<p>The dual variables are the constraints of the original problem.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Csp-dual-2.svg</figcaption>
</figure>
<hr/></td>
<td style="text-align: left;">
<p>The domain of each dual variable is the set of tuples of the corresponding original constraint.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Csp-dual-3.svg</figcaption>
</figure></td>
<td style="text-align: left;">
<p>The dual constraints enforce the dual variables (original constraints) to have values (original tuples) that contain equal values of the original variables. In this example, the original constraints 

<math display="inline" id="Constraint_satisfaction_dual_problem:3">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Constraint_satisfaction_dual_problem:4">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{2}
  </annotation>
 </semantics>
</math>

 share the variable 

<math display="inline" id="Constraint_satisfaction_dual_problem:5">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

. In the dual problem, the variables 

<math display="inline" id="Constraint_satisfaction_dual_problem:6">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Constraint_satisfaction_dual_problem:7">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{2}
  </annotation>
 </semantics>
</math>

 are allowed to have values 

<math display="inline" id="Constraint_satisfaction_dual_problem:8">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1,2)
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Constraint_satisfaction_dual_problem:9">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">2</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (2,1)
  </annotation>
 </semantics>
</math>

 because these values agree on 

<math display="inline" id="Constraint_satisfaction_dual_problem:10">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=2
  </annotation>
 </semantics>
</math>

.</p></td>
</tr>
</tbody>
</table>

<p>In the dual problem, all constraints are binary. They all enforce two values, which are tuples, to agree on one or more original variables.</p>

<p>The <em>dual graph</em> is a representation of how variables are constrained in the dual problem. More precisely, the dual graph contains a node for each dual variable and an edge for every constraint between them. In addition, the edge between two variables is labeled by the original variables that are enforced equal between these two dual variables.</p>

<p>The dual graph can be built directly from the original problem: it contains a vertex for each constraint, and an edge between every two constraints sharing variables; such an edge is labeled by these shared variables.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Csp-dual-graph-1.svg</figcaption>
</figure></td>
<td style="text-align: left;">
<p>A dual graph. An edge between two constraints corresponds to a dual constraint enforcing equality of their shared variables. For example, the edge labeled 

<math display="inline" id="Constraint_satisfaction_dual_problem:11">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>x</ci>
    <ci>y</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,y
  </annotation>
 </semantics>
</math>

 between 

<math display="inline" id="Constraint_satisfaction_dual_problem:12">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Constraint_satisfaction_dual_problem:13">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{2}
  </annotation>
 </semantics>
</math>


 indicates that the dual problem contains a constraint between 

<math display="inline" id="Constraint_satisfaction_dual_problem:14">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Constraint_satisfaction_dual_problem:15">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{2}
  </annotation>
 </semantics>
</math>

, and this constraint enforces values (tuples) that match on 

<math display="inline" id="Constraint_satisfaction_dual_problem:16">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Constraint_satisfaction_dual_problem:17">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

.</p></td>
</tr>
</tbody>
</table>
<h2 id="join-graphs-and-join-trees">Join graphs and join trees</h2>

<p>In the dual graph, some constraints may be unnecessary. Indeed, dual constraints enforces equality of original variables, and some constraints may be redundant because of transitivity of equality. For example, if 

<math display="inline" id="Constraint_satisfaction_dual_problem:18">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{2}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Constraint_satisfaction_dual_problem:19">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1}
  </annotation>
 </semantics>
</math>

 are joined by an edge whose label contains 

<math display="inline" id="Constraint_satisfaction_dual_problem:20">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

, and so are 

<math display="inline" id="Constraint_satisfaction_dual_problem:21">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Constraint_satisfaction_dual_problem:22">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{3}
  </annotation>
 </semantics>
</math>

, equality of 

<math display="inline" id="Constraint_satisfaction_dual_problem:23">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>


 in all three dual variables is guaranteed. As a result, a dual constraint between 

<math display="inline" id="Constraint_satisfaction_dual_problem:24">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{2}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Constraint_satisfaction_dual_problem:25">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{3}
  </annotation>
 </semantics>
</math>

 enforcing equality of 

<math display="inline" id="Constraint_satisfaction_dual_problem:26">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is not necessary, and could be removed if present.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Csp-dual-graph-2.svg</figcaption>
</figure></td>
<td style="text-align: left;">
<p>Since equality of 

<math display="inline" id="Constraint_satisfaction_dual_problem:27">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is enforced by other dual constraints, the one between 

<math display="inline" id="Constraint_satisfaction_dual_problem:28">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{2}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Constraint_satisfaction_dual_problem:29">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{3}
  </annotation>
 </semantics>
</math>

 can be dropped.</p></td>
</tr>
</tbody>
</table>

<p>A graph obtained from the dual graph by removing some redundant edges is called a <em>join graph</em>. If it is a tree, it is called a <em>join tree</em>. The dual problem can be solved from a join graph since all removed edges are redundant. In turn, the problem can be solved efficiently if that join graph is a tree, using algorithms tailored for acyclic constraint satisfaction problems.</p>

<p>Finding a join tree, if any, can be done exploiting the following property: if a dual graph has a join tree, then the maximal-weight <a href="spanning_tree_(mathematics)" title="wikilink">spanning trees</a> of the graph are all join trees, if edges are weighted by the number of variables the corresponding constraints enforce to be equal. An algorithm for finding a join tree, if any, proceeds as follows. In the first step, edges are assigned weights: if two nodes represent constraints that share 

<math display="inline" id="Constraint_satisfaction_dual_problem:30">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 variables, the edge joining them is assigned weight 

<math display="inline" id="Constraint_satisfaction_dual_problem:31">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

. In the second step, a maximal-weight spanning tree is searched for. Once one is found, it is checked whether it enforces the required equality of variables. If this is the case, this spanning tree is a join tree.</p>

<p>Another method for finding out whether a constraint satisfaction problem has a join tree uses the primal graph of the problem, rather than the dual graph. The <em>primal graph</em> of a constraint satisfaction problem is a graph whose nodes are problem variables and whose edges represent the presence of two variables in the same constraint. A join tree for the problem exists if:</p>
<ol>
<li>the primal graph is <a href="Chordal_graph" title="wikilink">chordal</a>;</li>
<li>the variables of every <a href="maximal_clique" title="wikilink">maximal clique</a> of the primal graph are the scope of a constraint and vice versa; this property is called <em>conformality</em>.</li>
</ol>

<p>In turn, chordality can be checked using a <a href="max-cardinality_ordering" title="wikilink">max-cardinality ordering</a> of the variables. Such an ordering can also be used, if the two conditions above are met, for finding a join tree of the problem. Ordering constraints by their highest variable according to the ordering, an algorithm for producing a join tree proceeds from the last to the first constraint; at each step, a constraint is connected to the constraint that shares a maximal number of variables with it among the constraints that precede it in the ordering.</p>
<h2 id="extensions">Extensions</h2>

<p>Not all constraint satisfaction problems have a join tree. However, problems can be modified to acquire a join tree. <a href="Join-tree_clustering" title="wikilink">Join-tree clustering</a> is a specific method to modify problems in such a way they acquire a joint tree. This is done by merging constraints, which typically increases the size of the problem; however, solving the resulting problem is easy, as it is for all problems that have a join tree.</p>

<p><a href="Decomposition_method_(constraint_satisfaction)" title="wikilink">Decomposition methods</a> generalize join-tree clustering by grouping variables in such a way the resulting problem has a join tree. Decomposition methods directly associate a tree with problems; the nodes of this tree are associated variables and/or constraints of the original problem. By merging constraints based on this tree, one can produce a problem that has a join tree, and this join tree can be easily derived from the decomposition tree. Alternatively, one can build a binary acyclic problem directly from the decomposition tree.</p>
<h2 id="references">References</h2>
<ul>
<li>

<p>ISBN 978-1-55860-890-0</p></li>
<li>

<p>ISBN 978-0-387-94883-6</p></li>
<li></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Hidden_transformation" title="wikilink">Hidden transformation</a></li>
</ul>

<p>"</p>

<p><a href="Category:Constraint_programming" title="wikilink">Category:Constraint programming</a></p>
</body>
</html>
