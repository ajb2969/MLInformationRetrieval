<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="972">Positive-definite kernel</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Positive-definite kernel</h1>
<hr/>

<p>In <a href="operator_theory" title="wikilink">operator theory</a>, a branch of <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a <strong>positive definite kernel</strong> is a generalization of a <a href="positive_semidefinite_matrix" title="wikilink">positive-definite matrix</a>.</p>
<h2 id="definition">Definition</h2>

<p>Let</p>

<p>

<math display="block" id="Positive-definite_kernel:0">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>H</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>n</mi>
    <mo>∈</mo>
    <mi>ℤ</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>n</ci>
     </apply>
    </set>
    <apply>
     <in></in>
     <ci>n</ci>
     <ci>ℤ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{H_{n}\}_{n\in{\mathbb{Z}}}
  </annotation>
 </semantics>
</math>

</p>

<p>be a sequence of (complex) <a href="Hilbert_space" title="wikilink">Hilbert spaces</a> and</p>

<p>

<math display="block" id="Positive-definite_kernel:1">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℒ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>H</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>H</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ℒ</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>j</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{L}(H_{i},H_{j})
  </annotation>
 </semantics>
</math>

</p>

<p>be the <a href="bounded_operator" title="wikilink">bounded operators</a> from <em>H<sub>i</sub></em> to <em>H<sub>j</sub></em>.</p>

<p>A map <em>A</em> on 

<math display="inline" id="Positive-definite_kernel:2">
 <semantics>
  <mrow>
   <mi>ℤ</mi>
   <mo>×</mo>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ℤ</ci>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbb{Z}}\times{\mathbb{Z}}
  </annotation>
 </semantics>
</math>

 where</p>

<p>

<math display="block" id="Positive-definite_kernel:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℒ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>H</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>H</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>A</ci>
     <interval closure="open">
      <ci>i</ci>
      <ci>j</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>ℒ</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>j</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(i,j)\in\mathcal{L}(H_{i},H_{j})
  </annotation>
 </semantics>
</math>

</p>

<p>is called a <strong>positive definite kernel</strong> if for all <em>m</em> &gt; 0 and 

<math display="inline" id="Positive-definite_kernel:4">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <msub>
    <mi>H</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{i}\in H_{i}
  </annotation>
 </semantics>
</math>

, the following non-negativity condition holds:</p>

<p>

<math display="block" id="Positive-definite_kernel:5">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mstyle scriptlevel="+1">
      <mtable columnspacing="0.4em" rowspacing="0.2ex">
       <mtr>
        <mtd>
         <mrow>
          <mo>-</mo>
          <mi>m</mi>
          <mo>≤</mo>
          <mi>i</mi>
         </mrow>
        </mtd>
       </mtr>
       <mtr>
        <mtd>
         <mrow>
          <mi>j</mi>
          <mo>≤</mo>
          <mi>m</mi>
         </mrow>
        </mtd>
       </mtr>
      </mtable>
     </mstyle>
    </munder>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>A</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo>,</mo>
       <mi>j</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>h</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo>,</mo>
     <msub>
      <mi>h</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <ci>STACKED</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <minus></minus>
        <csymbol cd="unknown">m</csymbol>
        <leq></leq>
        <csymbol cd="unknown">i</csymbol>
        <ci>italic-</ci>
       </cerror>
       <apply>
        <leq></leq>
        <ci>j</ci>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
     <list>
      <apply>
       <times></times>
       <ci>A</ci>
       <interval closure="open">
        <ci>i</ci>
        <ci>j</ci>
       </interval>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>j</ci>
      </apply>
     </list>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{-m\leq i\quad\,\atop j\leq m}\langle A(i,j)h_{i},h_{j}\rangle\geq 0.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="examples">Examples</h2>

<p>Positive definite kernels provide a framework that encompasses some basic Hilbert space constructions.</p>
<h3 id="reproducing-kernel-hilbert-space">Reproducing kernel Hilbert space</h3>

<p>The definition and characterization of positive kernels extend verbatim to the case where the integers <strong>Z</strong> is replaced by an arbitrary set <em>X</em>. One can then give a fairly general procedure for constructing Hilbert spaces that is itself of some interest.</p>

<p>Consider the set <em>F</em><sub>0</sub>(<em>X</em>) of complex-valued functions <em>f</em>: <em>X</em> → <em>C</em> with finite <a href="support_(mathematics)" title="wikilink">support</a>. With the natural operations, <em>F</em><sub>0</sub>(<em>X</em>) is called the <strong>free vector space</strong> generated by <em>X</em>. Let <em>δ<sub>x</sub></em> be the element in <em>F</em><sub>0</sub>(<em>X</em>) defined by <em>δ<sub>x</sub></em>(<em>y</em>) = <a href="Kronecker_delta" title="wikilink"><em>δ<sub>xy</sub></em></a>. The set {<em>δ<sub>x</sub></em>}<sub><em>x</em> ∈ <em>X</em></sub> is a vector space basis of <em>F</em><sub>0</sub>(<em>X</em>).</p>

<p>Suppose now <em>K</em>: <em>X</em> × <em>X</em> → <em>C</em> is a positive definite kernel, then the Kolmogorov decomposition of <em>K</em> gives a Hilbert space</p>

<p>

<math display="block" id="Positive-definite_kernel:6">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mo>⋅</mo>
    <mo>,</mo>
    <mo>⋅</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>ℋ</ci>
    <list>
     <ci>normal-⋅</ci>
     <ci>normal-⋅</ci>
    </list>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ({\mathcal{H}},\langle\cdot,\cdot\rangle)
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>F</em><sub>0</sub>(<em>X</em>) is "dense" (after possibly taking quotients of the degenerate subspace). Also, ⟨[<em>δ<sub>x</sub></em>], [<em>δ<sub>y</sub></em>]⟩ = <em>K</em>(<em>x</em>,<em>y</em>), which is a special case of the square root factorization claim above. This Hilbert space is called the <strong>reproducing kernel Hilbert space</strong> with kernel <em>K</em> on the set <em>X</em>.</p>

<p>Notice that in this context, we have (from the definition above)</p>

<p>

<math display="block" id="Positive-definite_kernel:7">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>H</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>n</mi>
    <mo>∈</mo>
    <mi>ℤ</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>n</ci>
     </apply>
    </set>
    <apply>
     <in></in>
     <ci>n</ci>
     <ci>ℤ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{H_{n}\}_{n\in{\mathbb{Z}}}
  </annotation>
 </semantics>
</math>

</p>

<p>being replaced by</p>

<p>

<math display="block" id="Positive-definite_kernel:8">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>ℂ</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mi>X</mi>
    </mrow>
   </msub>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <set>
     <ci>ℂ</ci>
    </set>
    <apply>
     <in></in>
     <ci>x</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{{\mathbb{C}}\}_{x\in X}.
  </annotation>
 </semantics>
</math>

</p>

<p>Thus the Kolmogorov decomposition, which is unique up to isomorphism, starts with <em>F</em><sub>0</sub>(<em>X</em>).</p>

<p>One can readily show that every Hilbert space is isomorphic to a reproducing kernel Hilbert space on a set whose cardinality is the Hilbert space dimension of <em>H</em>. Let {<em>e<sub>x</sub></em>}<sub><em>x ∈ X</em></sub> be an orthonormal basis of <em>H</em>. Then the kernel <em>K</em> defined by <em>K</em>(<em>x</em>, <em>y</em>) = ⟨<em>e<sub>x</sub></em>, <em>e<sub>y</sub></em>⟩ = <em>δ<sub>xy</sub></em> reproduces a Hilbert space <em>H</em>. The bijection taking <em>e<sub>x</sub></em> to <em>δ<sub>x</sub></em> extends to a unitary operator from <em>H</em> to ''H' ''.</p>
<h3 id="direct-sum-and-tensor-product">Direct sum and tensor product</h3>

<p>Let <em>H</em>(<em>K</em>, <em>X</em>) denote the Hilbert space corresponding to a positive kernel <em>K</em> on <em>X</em> × <em>X</em>. The structure of <em>H</em>(<em>K</em>, <em>X</em>) is encoded in <em>K</em>. One can thus describe, for example, the <a href="direct_sum_of_Hilbert_spaces" title="wikilink">direct sum</a> and the <a href="tensor_product" title="wikilink">tensor product</a> of two Hilbert spaces via their kernels.</p>

<p>Consider two Hilbert spaces <em>H</em>(<em>K</em>, <em>X</em>) and <em>H</em>(<em>L</em>, <em>Y</em>). The <a href="disjoint_union" title="wikilink">disjoint union</a> of <em>X</em> and <em>Y</em> is the set</p>

<p>

<math display="block" id="Positive-definite_kernel:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>X</mi>
     <mo>⊔</mo>
     <mi>Y</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>ξ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>x</mi>
       <mo>∈</mo>
       <mi>X</mi>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo>∪</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ξ</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>y</mi>
       <mo>∈</mo>
       <mi>Y</mi>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">square-union</csymbol>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <interval closure="open">
       <ci>x</ci>
       <ci>ξ</ci>
      </interval>
      <apply>
       <in></in>
       <ci>x</ci>
       <ci>X</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <interval closure="open">
       <ci>ξ</ci>
       <ci>y</ci>
      </interval>
      <apply>
       <in></in>
       <ci>y</ci>
       <ci>Y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\sqcup Y=\{(x,\xi)|x\in X\}\cup\{(\xi,y)|y\in Y\}.
  </annotation>
 </semantics>
</math>

</p>

<p>Define a kernel</p>

<p>

<math display="block" id="Positive-definite_kernel:10">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>⊕</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">direct-sum</csymbol>
    <ci>K</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\oplus L
  </annotation>
 </semantics>
</math>

</p>

<p>on this disjoint union in a way that is similar to direct sum of positive matrices, and the resulting Hilbert space</p>

<p>

<math display="block" id="Positive-definite_kernel:11">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>K</mi>
     <mo>⊕</mo>
     <mi>L</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>X</mi>
     <mo>⊔</mo>
     <mi>Y</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>K</ci>
      <ci>L</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">square-union</csymbol>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(K\oplus L,X\sqcup Y)
  </annotation>
 </semantics>
</math>

</p>

<p>is then the direct sum, in the sense of Hilbert spaces, of <em>H</em>(<em>K</em>, <em>X</em>) and <em>H</em>(<em>L</em>, <em>Y</em>).</p>

<p>For the tensor product, a suitable kernel</p>

<p>

<math display="block" id="Positive-definite_kernel:12">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>⊗</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <ci>K</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\otimes L
  </annotation>
 </semantics>
</math>

</p>

<p>is defined on the Cartesian product <em>X</em> × <em>Y</em> in a way that extends the <a href="Schur_product" title="wikilink">Schur product</a> of positive matrices:</p>

<p>

<math display="block" id="Positive-definite_kernel:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>K</mi>
       <mo>⊗</mo>
       <mi>L</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>x</mi>
        <mo>′</mo>
       </msup>
       <mo>,</mo>
       <msup>
        <mi>y</mi>
        <mo>′</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <msup>
       <mi>x</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo>,</mo>
      <msup>
       <mi>y</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>K</ci>
      <ci>L</ci>
     </apply>
     <interval closure="open">
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <ci>normal-′</ci>
       </apply>
      </interval>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>K</ci>
     <interval closure="open">
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>normal-′</ci>
      </apply>
     </interval>
     <ci>L</ci>
     <interval closure="open">
      <ci>y</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>normal-′</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (K\otimes L)((x,y),(x^{\prime},y^{\prime}))=K(x,x^{\prime})L(y,y^{\prime}).
  </annotation>
 </semantics>
</math>

</p>

<p>This positive kernel gives the tensor product of <em>H</em>(<em>K</em>, <em>X</em>) and <em>H</em>(<em>L</em>, <em>Y</em>),</p>

<p>

<math display="block" id="Positive-definite_kernel:14">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>K</mi>
     <mo>⊗</mo>
     <mi>L</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>X</mi>
     <mo>×</mo>
     <mi>Y</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>K</ci>
      <ci>L</ci>
     </apply>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(K\otimes L,X\times Y)
  </annotation>
 </semantics>
</math>

</p>

<p>in which the family { [<em>δ<sub>(x,y)</sub></em>] } is a total set, i.e. its linear span is dense.</p>
<h2 id="characterization">Characterization</h2>
<h3 id="motivation">Motivation</h3>

<p>Consider a positive matrix <em>A</em> ∈ <strong>C</strong><sup><em>n × n</em></sup>, whose entries are complex numbers. Every such matrix <em>A</em> has a <a href="square_root_of_a_matrix" title="wikilink">"square root factorization"</a> in the following sense:</p>
<dl>
<dd><em>A</em> = <em>B*B</em> where <em>B</em>: <strong>C</strong><sup><em>n</em></sup> → <em>H<sub>A</sub></em> for some (finite-dimensional) Hilbert space <em>H<sub>A</sub></em>.
</dd>
</dl>

<p>Furthermore, if <em>C</em> and <em>G</em> is another pair, <em>C</em> an operator and <em>G</em> a Hilbert space, for which the above is true, then there exists a unitary operator <em>U</em>: <em>G</em> → <em>H<sub>A</sub></em> such that <em>B = UC</em>.</p>

<p>The can be shown readily as follows. The matrix <em>A</em> induces a degenerate inner product <sub><em>A</em></sub> given by <sub><em>A</em></sub> = . Taking the quotient with respect to the degenerate subspace gives a Hilbert space <em>H<sub>A</sub></em>, a typical element of which is an equivalence class we denote by [<em>x</em>].</p>

<p>Now let <em>B</em>: <strong>C</strong><sup><em>n</em></sup> → <em>H<sub>A</sub></em> be the natural projection map, <em>Bx</em> = [<em>x</em>]. One can calculate directly that</p>

<p>

<math display="block" id="Positive-definite_kernel:15">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mrow>
     <msup>
      <mi>B</mi>
      <mo>*</mo>
     </msup>
     <mi>B</mi>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>B</mi>
      <mi>x</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>B</mi>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>A</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>y</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>A</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mrow>
     <mi>A</mi>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <list>
      <ci>x</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>B</ci>
        <times></times>
       </apply>
       <ci>B</ci>
       <ci>y</ci>
      </apply>
     </list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <apply>
        <times></times>
        <ci>B</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <times></times>
        <ci>B</ci>
        <ci>y</ci>
       </apply>
      </list>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>y</ci>
       </apply>
      </list>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <list>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>y</ci>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x,B^{*}By\rangle=\langle Bx,By\rangle_{A}=\langle[x],[y]\rangle_{A}=%
\langle x,Ay\rangle
  </annotation>
 </semantics>
</math>

.</p>

<p>So <em>B*B</em> = <em>A</em>. If <em>C</em> and <em>G</em> is another such pair, it is clear that the operator <em>U</em>: <em>G</em> → <em>H<sub>A</sub></em> that takes [<em>x</em>]<sub><em>G</em></sub> in <em>G</em> to [<em>x</em>] in <em>H<sub>A</sub></em> has the properties claimed above.</p>

<p>If {<em>e<sub>i</sub></em>} is a given orthonormal basis of <strong>C</strong><sup><em>n</em></sup>, then {<em>B<sub>i</sub></em> = <em>Be<sub>i</sub></em>} are the column vectors of <em>B</em>. The expression <em>A = B*B</em> can be rewritten as <em>A<sub>i, j</sub></em> = <em>B<sub>i</sub>*B<sub>j</sub></em>. By construction, <em>H<sub>A</sub></em> is the linear span of {<em>B<sub>i</sub></em>}.</p>
<h3 id="kolmogorov-decomposition">Kolmogorov decomposition</h3>

<p>This preceding discussion shows that every positive matrix <em>A</em> with complex entries can expressed as a <a href="Gramian_matrix" title="wikilink">Gramian matrix</a>. A similar description can be obtained for general positive definite kernels, with an analogous argument. This is called the <strong>Kolmogorov decomposition</strong>:</p>
<dl>
<dd>Let <em>A</em> be a positive definite kernel. Then there exists a Hilbert space <em>H<sub>A</sub></em>, and a map <em>B</em> defined on <strong>Z</strong> where <em>B</em>(<em>n</em>) lies in 

<math display="inline" id="Positive-definite_kernel:16">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℒ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>H</mi>
      <mi>n</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>H</mi>
      <mi>A</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ℒ</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>A</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{L}(H_{n},H_{A}),
  </annotation>
 </semantics>
</math>

 such that
</dd>
</dl>

<p>

<math display="block" id="Positive-definite_kernel:17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mpadded lspace="10pt" width="+10pt">
       <mi>A</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo>,</mo>
       <mi>j</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <msup>
        <mi>B</mi>
        <mo>*</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>i</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>B</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>j</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mtext>and</mtext>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mi>H</mi>
      <mi>A</mi>
     </msub>
     <mo>=</mo>
     <mrow>
      <munder>
       <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
       <mrow>
        <mi>n</mi>
        <mo>∈</mo>
        <mi>ℤ</mi>
       </mrow>
      </munder>
      <mrow>
       <mi>B</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mpadded width="+2.8pt">
        <msub>
         <mi>H</mi>
         <mi>n</mi>
        </msub>
       </mpadded>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>A</ci>
      <interval closure="open">
       <ci>i</ci>
       <ci>j</ci>
      </interval>
     </apply>
     <list>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>B</ci>
        <times></times>
       </apply>
       <ci>i</ci>
       <ci>B</ci>
       <ci>j</ci>
      </apply>
      <mtext>and</mtext>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <or></or>
       <apply>
        <in></in>
        <ci>n</ci>
        <ci>ℤ</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \quad A(i,j)=B^{*}(i)B(j)\quad\mbox{and}\quad H_{A}=\bigvee_{n\in{\mathbb{Z}}}%
B(n)H_{n}\;,
  </annotation>
 </semantics>
</math>

</p>

<p>where ⋁ denotes disjoint union as defined above. The condition that <em>H<sub>A</sub></em> = ⋁<em>B</em>(<em>n</em>)<em>H<sub>n</sub></em> is referred to as the <strong>minimality condition</strong>. Similar to the scalar case, this requirement implies unitary freedom in the decomposition:</p>
<dl>
<dd>If there is a Hilbert space <em>G</em> and a map <em>C</em> on <strong>Z</strong> that gives a Kolmogorov decomposition of <em>A</em>, then there is a unitary operator
</dd>
</dl>

<p>

<math display="block" id="Positive-definite_kernel:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>U</mi>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mi>G</mi>
      <mo>→</mo>
      <mrow>
       <msub>
        <mi>H</mi>
        <mi>A</mi>
       </msub>
       <mtext>such that</mtext>
      </mrow>
     </mrow>
     <mrow>
      <mrow>
       <mrow>
        <mi>U</mi>
        <mi>C</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mrow>
        <mrow>
         <mi>B</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mtext>for all</mtext>
       </mrow>
      </mrow>
      <mrow>
       <mi>n</mi>
       <mo>∈</mo>
       <mi>ℤ</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>U</ci>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <ci>normal-→</ci>
      <ci>G</ci>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <ci>A</ci>
       </apply>
       <mtext>such that</mtext>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <ci>U</ci>
        <ci>C</ci>
        <ci>n</ci>
       </apply>
       <list>
        <apply>
         <times></times>
         <ci>B</ci>
         <ci>n</ci>
        </apply>
        <mtext>for all</mtext>
       </list>
      </apply>
      <apply>
       <in></in>
       <ci>n</ci>
       <ci>ℤ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U:G\rightarrow H_{A}\quad\mbox{such that}\quad UC(n)=B(n)\quad\mbox{for all}%
\quad n\in{\mathbb{Z}}.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="some-applications">Some applications</h2>
<h3 id="stinespring-dilation-theorem">Stinespring dilation theorem</h3>
<h3 id="embedding-probability-distributions-in-a-rkhs">Embedding probability distributions in a RKHS</h3>

<p>In <a href="machine_learning" title="wikilink">machine learning</a>, a class of algorithms based on the <a href="kernel_embedding_of_distributions" title="wikilink">kernel embedding of distributions</a> has been formulated to represent <a href="probability_distributions" title="wikilink">probability distributions</a> as functions in a RKHS. This embedding thus allows manipulations of the distributions to be done via <a href="Hilbert_space" title="wikilink">Hilbert space</a> operations.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Positive_definite_function_on_a_group" title="wikilink">Positive definite function on a group</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>D.E. Evans and J.T. Lewis, Dilations of irreversible evolutions in algebraic quantum theory, <em>Comm. Dublin Inst. Adv. Studies Ser. A</em>, <strong>24</strong>, 1977.</li>
</ul>
<ul>
<li>B. Sz.-Nagy and C. Foias, <em>Harmonic Analysis of Operators on Hilbert Space,</em> North-Holland, 1970.</li>
</ul>

<p>"</p>

<p><a href="Category:Operator_theory" title="wikilink">Category:Operator theory</a> <a href="Category:Hilbert_space" title="wikilink">Category:Hilbert space</a></p>
</body>
</html>
