<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="181">Polynomial-time approximation scheme</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Polynomial-time approximation scheme</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, a <strong>polynomial-time approximation scheme</strong> (<strong>PTAS</strong>) is a type of <a href="approximation_algorithm" title="wikilink">approximation algorithm</a> for <a href="optimization_problem" title="wikilink">optimization problems</a> (most often, <a class="uri" href="NP-hard" title="wikilink">NP-hard</a> optimization problems).</p>

<p>A PTAS is an algorithm which takes an instance of an optimization problem and a parameter ε &gt; 0 and, in polynomial time, produces a solution that is within a factor 1 + ε of being optimal (or 1 - ε for maximization problems). For example, for the Euclidean <a href="traveling_salesman_problem" title="wikilink">traveling salesman problem</a>, a PTAS would produce a tour with length at most (1 + ε)<em>L</em>, with <em>L</em> being the length of the shortest tour.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The running time of a PTAS is required to be polynomial in <em>n</em> for every fixed ε but can be different for different ε. Thus an algorithm running in time <em><a href="Big_O_notation" title="wikilink">O</a></em>(<em>n</em><sup>1/ε</sup>) or even <em>O</em>(<em>n</em><sup>exp(1/ε)</sup>) counts as a PTAS.</p>
<h2 id="variants">Variants</h2>
<h3 id="deterministic">Deterministic</h3>

<p>A practical problem with PTAS algorithms is that the exponent of the polynomial could increase dramatically as ε shrinks, for example if the runtime is O(<em>n</em><sup>(1/ε)!</sup>). One way of addressing this is to define the <strong>efficient polynomial-time approximation scheme</strong> or <strong>EPTAS</strong>, in which the running time is required to be <em>O</em>(<em>n</em><sup><em>c</em></sup>) for a constant <em>c</em> independent of ε. This ensures that an increase in problem size has the same relative effect on runtime regardless of what ε is being used; however, the constant under the <a href="Big_O_notation" title="wikilink">big-O</a> can still depend on ε arbitrarily. Even more restrictive, and useful in practice, is the <strong>fully polynomial-time approximation scheme</strong> or <strong>FPTAS</strong>, which requires the algorithm to be polynomial in both the problem size <em>n</em> and 1/ε. All problems in FPTAS are <a href="fixed-parameter_tractable" title="wikilink">fixed-parameter tractable</a>. An example of a problem that has an FPTAS is the <a href="knapsack_problem" title="wikilink">knapsack problem</a>.</p>

<p>Any <a href="Strongly_NP-complete" title="wikilink">strongly NP-hard</a> optimization problem with a polynomially bounded objective function cannot have an FPTAS unless P=NP.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> However, the converse fails: e.g. if P does not equal NP, <a href="List_of_knapsack_problems#Multiple_constraints" title="wikilink">knapsack with two constraints</a> is not strongly NP-hard, but has no FPTAS even when the optimal objective is polynomially bounded.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Unless <a href="P_=_NP_problem" title="wikilink">P = NP</a>, it holds that FPTAS ⊊ PTAS ⊊ <a class="uri" href="APX" title="wikilink">APX</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Consequently, under this assumption, APX-hard problems do not have PTASs.</p>

<p>Another deterministic variant of the PTAS is the <strong>quasi-polynomial-time approximation scheme</strong> or <strong>QPTAS</strong>. A QPTAS has time complexity 

<math display="inline" id="Polynomial-time_approximation_scheme:0">
 <semantics>
  <msup>
   <mi>n</mi>
   <mrow>
    <mi>p</mi>
    <mi>o</mi>
    <mi>l</mi>
    <mi>y</mi>
    <mi>l</mi>
    <mi>o</mi>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>o</ci>
     <ci>l</ci>
     <ci>y</ci>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{polylog(n)}
  </annotation>
 </semantics>
</math>

 for each fixed 

<math display="inline" id="Polynomial-time_approximation_scheme:1">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>ϵ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon>0
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="randomized">Randomized</h3>

<p>Some problems which do not have a PTAS may admit a <a href="randomized_algorithm" title="wikilink">randomized algorithm</a> with similar properties, a <strong>polynomial-time randomized approximation scheme</strong> or <strong>PRAS</strong>. A PRAS is an algorithm which takes an instance of an optimization or counting problem and a parameter ε &gt; 0 and, in polynomial time, produces a solution that has a <em>high probability</em> of being within a factor ε of optimal. Conventionally, "high probability" means probability greater than 3/4, though as with most probabilistic complexity classes the definition is robust to variations in this exact value (the bare minimum requirement is generally greater than 1/2). Like a PTAS, a PRAS must have running time polynomial in <em>n</em>, but not necessarily in ε; with further restrictions on the running time in ε, one can define an <strong>efficient polynomial-time randomized approximation scheme</strong> or <strong>EPRAS</strong> similar to the EPTAS, and a <strong>fully polynomial-time randomized approximation scheme</strong> or <strong>FPRAS</strong> similar to the FPTAS.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="as-a-complexity-class">As a complexity class</h2>

<p>The term PTAS may also be used to refer to the class of optimization problems that have a PTAS. PTAS is a subset of <a class="uri" href="APX" title="wikilink">APX</a>, and unless <a href="P_=_NP_problem" title="wikilink">P = NP</a>, it is a strict subset. <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Membership in PTAS can be shown using a <a href="PTAS_reduction" title="wikilink">PTAS reduction</a>, <a class="uri" href="L-reduction" title="wikilink">L-reduction</a>, or <a href="Approximation-preserving_reduction#A-reduction_and_P-reduction" title="wikilink">P-reduction</a>, all of which preserve PTAS membership, and these may also be used to demonstrate PTAS-completeness. On the other hand, showing non-membership in PTAS (namely, the nonexistence of a PTAS), may be done by showing that the problem is APX-hard, after which the existence of a PTAS would show P = NP. APX-hardness is commonly shown via PTAS reduction or <a href="Approximation-preserving_reduction#AP-reduction" title="wikilink">AP-reduction</a>.</p>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li>Complexity Zoo: <a href="https://complexityzoo.uwaterloo.ca/Complexity_Zoo:P#ptas">PTAS</a>, <a href="https://complexityzoo.uwaterloo.ca/Complexity_Zoo:E#eptas">EPTAS</a>, <a href="https://complexityzoo.uwaterloo.ca/Complexity_Zoo:F#fptas">FPTAS</a></li>
<li>Pierluigi Crescenzi, Viggo Kann, Magnús Halldórsson, <a href="Marek_Karpinski" title="wikilink">Marek Karpinski</a>, and Gerhard Woeginger, <a href="http://www.nada.kth.se/~viggo/wwwcompendium/"><em>A compendium of NP optimization problems</em></a> – list which NP optimization problems have PTAS.</li>
</ul>

<p>"</p>

<p><a href="Category:Approximation_algorithms" title="wikilink">Category:Approximation algorithms</a> <a href="Category:Complexity_classes" title="wikilink">Category:Complexity classes</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Sanjeev_Arora" title="wikilink">Sanjeev Arora</a>, Polynomial-time Approximation Schemes for Euclidean TSP and other Geometric Problems, Journal of the ACM 45(5) 753–782, 1998.<a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">. See discussion following Definition 1.30 on [<a class="uri" href="http://books.google.com/books?id=_C8Ly1ya4cgC&amp;pg">http://books.google.com/books?id=_C8Ly1ya4cgC&amp;pg;</a>;=PA20 p. 20].<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
</ol>
</section>
</body>
</html>
