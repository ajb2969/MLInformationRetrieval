<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="697">Riemann–Hilbert problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Riemann–Hilbert problem</h1>
<hr/>
<div class="dablink">

<p>For the original problem of Hilbert concerning the existence of linear differential equations having a given monodromy group see <a href="Hilbert's_twenty-first_problem" title="wikilink">Hilbert's twenty-first problem</a>.</p>
</div>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <strong>Riemann–Hilbert problems</strong>, named after <a href="Bernhard_Riemann" title="wikilink">Bernhard Riemann</a> and <a href="David_Hilbert" title="wikilink">David Hilbert</a>, are a class of problems that arise, <em><a href="inter_alia" title="wikilink">inter alia</a></em>, in the study of <a href="differential_equation" title="wikilink">differential equations</a> in the <a href="complex_plane" title="wikilink">complex plane</a>. Several <a href="existence_theorem" title="wikilink">existence theorems</a> for Riemann–Hilbert problems have been produced by Krein, <a href="Israel_Gohberg" title="wikilink">Gohberg</a> and others (see the book by Clancey and Gohberg (1981)).</p>
<h2 id="the-riemann-problem">The Riemann problem</h2>

<p>Suppose that Σ is a closed simple contour in the complex plane dividing the plane into two parts denoted by Σ<sub>+</sub> (the inside) and Σ<sub>−</sub> (the outside), determined by the <a href="winding_number" title="wikilink">index</a> of the contour with respect to a point. The classical problem, considered in Riemann's PhD dissertation (see ), was that of finding a function</p>

<p>

<math display="block" id="Riemann–Hilbert_problem:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>M</mi>
     <mo>+</mo>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>u</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>i</mi>
     <mi>v</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo rspace="0.8pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <plus></plus>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>u</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>v</ci>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{+}(z)=u(z)+iv(z)\!
  </annotation>
 </semantics>
</math>

</p>

<p>analytic inside Σ<sub>+</sub> such that the boundary values of <em>M</em><sub>+</sub> along Σ satisfy the equation</p>

<p>

<math display="block" id="Riemann–Hilbert_problem:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>u</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>b</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>v</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo rspace="0.8pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>z</ci>
      <ci>u</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <ci>b</ci>
      <ci>z</ci>
      <ci>v</ci>
      <ci>z</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(z)u(z)-b(z)v(z)=c(z)\!
  </annotation>
 </semantics>
</math>

</p>

<p>for all <em>z</em> ∈ Σ, where <em>a</em>, <em>b</em>, and <em>c</em> are given real-valued functions .</p>

<p>By the <a href="Riemann_mapping_theorem" title="wikilink">Riemann mapping theorem</a>, it suffices to consider the case when Σ is the unit circle . In this case, one may seek <em>M</em><sub>+</sub>(<em>z</em>) along with its <a href="Schwarz_reflection" title="wikilink">Schwarz reflection</a>:</p>

<p>

<math display="block" id="Riemann–Hilbert_problem:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>M</mi>
      <mo>-</mo>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mover accent="true">
     <mrow>
      <msub>
       <mi>M</mi>
       <mo>+</mo>
      </msub>
      <mrow>
       <mo>(</mo>
       <msup>
        <mover accent="true">
         <mi>z</mi>
         <mo stretchy="false">¯</mo>
        </mover>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>¯</mo>
    </mover>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <minus></minus>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <plus></plus>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-¯</ci>
        <ci>z</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{-}(z)=\overline{M_{+}\left(\bar{z}^{-1}\right)}.
  </annotation>
 </semantics>
</math>

</p>

<p>On the unit circle Σ, one has 

<math display="inline" id="Riemann–Hilbert_problem:3">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mover accent="true">
     <mi>z</mi>
     <mo stretchy="false">¯</mo>
    </mover>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>z</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <ci>normal-¯</ci>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=1/\bar{z}
  </annotation>
 </semantics>
</math>

, and so</p>

<p>

<math display="block" id="Riemann–Hilbert_problem:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>M</mi>
       <mo>-</mo>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mover accent="true">
      <mrow>
       <msub>
        <mi>M</mi>
        <mo>+</mo>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>¯</mo>
     </mover>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mi>z</mi>
     <mo>∈</mo>
     <mi mathvariant="normal">Σ</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <minus></minus>
      </apply>
      <ci>z</ci>
     </apply>
     <apply>
      <ci>normal-¯</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <plus></plus>
       </apply>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>z</ci>
     <ci>normal-Σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{-}(z)=\overline{M_{+}(z)},\quad z\in\Sigma.
  </annotation>
 </semantics>
</math>

</p>

<p>Hence the problem reduces to finding a pair of functions <em>M</em><sub>+</sub>(<em>z</em>) and <em>M</em><sub>−</sub>(<em>z</em>) analytic, respectively, on the inside and the outside of the unit disc, so that on the unit circle</p>

<p>

<math display="block" id="Riemann–Hilbert_problem:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mfrac>
       <mrow>
        <mrow>
         <mi>a</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>i</mi>
         <mi>b</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mn>2</mn>
      </mfrac>
      <msub>
       <mi>M</mi>
       <mo>+</mo>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mfrac>
       <mrow>
        <mrow>
         <mi>a</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>i</mi>
         <mi>b</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mn>2</mn>
      </mfrac>
      <msub>
       <mi>M</mi>
       <mo>-</mo>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>c</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>a</ci>
         <ci>z</ci>
        </apply>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>b</ci>
         <ci>z</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <plus></plus>
      </apply>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>a</ci>
         <ci>z</ci>
        </apply>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>b</ci>
         <ci>z</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <minus></minus>
      </apply>
      <ci>z</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{a(z)+ib(z)}{2}M_{+}(z)+\frac{a(z)-ib(z)}{2}M_{-}(z)=c(z),
  </annotation>
 </semantics>
</math>

</p>

<p>and, moreover, so that the condition at infinity holds:</p>

<p>

<math display="block" id="Riemann–Hilbert_problem:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder>
      <mo movablelimits="false">lim</mo>
      <mrow>
       <mi>z</mi>
       <mo>→</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
     </munder>
     <mrow>
      <msub>
       <mi>M</mi>
       <mo>-</mo>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mover accent="true">
       <mi>M</mi>
       <mo stretchy="false">¯</mo>
      </mover>
      <mo>+</mo>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>z</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <minus></minus>
      </apply>
      <ci>z</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <ci>M</ci>
      </apply>
      <plus></plus>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lim_{z\to\infty}M_{-}(z)=\bar{M}_{+}(0).
  </annotation>
 </semantics>
</math>

</p>
<h2 id="the-hilbert-problem">The Hilbert problem</h2>

<p>Hilbert's generalization was to consider the problem of attempting to find <em>M</em><sub>+</sub> and <em>M</em><sub>-</sub> analytic, respectively, on the inside and outside of the curve Σ, such that on Σ one has</p>

<p>

<math display="block" id="Riemann–Hilbert_problem:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>α</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>M</mi>
      <mo>+</mo>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>β</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>M</mi>
      <mo>-</mo>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>α</ci>
      <ci>z</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <plus></plus>
      </apply>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <ci>β</ci>
      <ci>z</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <minus></minus>
      </apply>
      <ci>z</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(z)M_{+}(z)+\beta(z)M_{-}(z)=c(z)\,
  </annotation>
 </semantics>
</math>

</p>

<p>where α, β, and <em>c</em> are arbitrary given complex-valued functions (no longer just complex conjugates).</p>
<h2 id="riemannhilbert-problems">Riemann–Hilbert problems</h2>

<p>In the Riemann problem as well as Hilbert's generalization, the contour Σ was simple. A full Riemann–Hilbert problem allows that the contour may be composed of a union of several oriented smooth curves, with no intersections. The + and − sides of the "contour" may then be determined according to the index of a point with respect to Σ. The Riemann–Hilbert problem is to find a pair of functions, <em>M</em><sub>+</sub> and <em>M</em><sub>-</sub> analytic, respectively, on the + and − side of Σ, subject to the equation</p>

<p>

<math display="block" id="Riemann–Hilbert_problem:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>α</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>M</mi>
      <mo>+</mo>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>β</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>M</mi>
      <mo>-</mo>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>α</ci>
      <ci>z</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <plus></plus>
      </apply>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <ci>β</ci>
      <ci>z</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <minus></minus>
      </apply>
      <ci>z</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(z)M_{+}(z)+\beta(z)M_{-}(z)=c(z)\,
  </annotation>
 </semantics>
</math>

</p>

<p>for all <em>z</em>∈Σ.</p>
<h2 id="generalization-factorization-problems">Generalization: factorization problems</h2>

<p>Given an oriented "contour" Σ (technically: an oriented union of smooth curves without points of infinite self-intersection in the complex plane). A <strong><a href="Birkhoff_factorization" title="wikilink">Birkhoff factorization</a> problem</strong> is the following.</p>

<p>Given a matrix function <em>V</em> defined on the contour Σ, to find a holomorphic matrix function M defined on the complement of Σ, such that two conditions be satisfied:</p>
<ol>
<li>If <em>M</em><sub>+</sub> and <em>M</em><sub>−</sub> denote the non-tangential limits of <em>M</em> as we approach Σ, then <em>M</em><sub>+</sub> = <em>M</em><sub>−</sub>V, at all points of non-intersection in Σ.</li>
<li>As <em>z</em> tends to infinity along any direction outside Σ, <em>M</em> tends to the <a href="identity_matrix" title="wikilink">identity matrix</a>.</li>
</ol>

<p>In the simplest case <em>V</em> is smooth and integrable. In more complicated cases it could have singularities. The limits <em>M</em><sub>+</sub> and <em>M</em><sub>−</sub> could be classical and continuous or they could be taken in the <a href="square_integrable" title="wikilink"><em>L</em><sub>2</sub></a> sense.</p>
<h2 id="applications-to-integrability-theory">Applications to Integrability Theory</h2>

<p>Riemann–Hilbert problems have applications to several related classes of problems.</p>

<p>A. <a href="Integrable_model" title="wikilink">Integrable models</a>. The <a href="inverse_scattering" title="wikilink">inverse scattering</a> or inverse spectral problem associated to the Cauchy problem for 1+1 dimensional <a href="partial_differential_equations" title="wikilink">partial differential equations</a> on the line, periodic problems, or even initial-boundary value problems, can be stated as Riemann–Hilbert problems.</p>

<p>B. <a href="Orthogonal_polynomials" title="wikilink">Orthogonal polynomials</a>, <a href="Random_matrices" title="wikilink">Random matrices</a>. Given a weight on a contour, the corresponding orthogonal polynomials can be computed via the solution of a Riemann–Hilbert factorization problem. Furthermore, the distribution of eigenvalues of random matrices in several ensembles is reduced to computations involving orthogonal polynomials (see for example ).</p>

<p>C. Combinatorial <a class="uri" href="probability" title="wikilink">probability</a>. The most celebrated example is the theorem of  on the distribution of the length of the longest increasing subsequence of a random permutation.</p>

<p>In particular, Riemann–Hilbert factorization problems are used to extract asymptotics for the three problems above (say, as time goes to infinity, or as the dispersion coefficient goes to zero, or as the polynomial degree goes to infinity, or as the size of the permutation goes to infinity). There exists a method for extracting the asymptotic behavior of solutions of Riemann–Hilbert problems, analogous to the <a href="method_of_stationary_phase" title="wikilink">method of stationary phase</a> and the <a href="method_of_steepest_descent" title="wikilink">method of steepest descent</a> applicable to exponential integrals.</p>

<p>By analogy with the classical asymptotic methods, one "deforms" Riemann–Hilbert problems which are not explicitly solvable to problems that are. The so-called "nonlinear" method of stationary phase is due to , expanding on a previous idea by  and . A crucial ingredient of the Deift-Zhou analysis is the asymptotic analysis of singular integrals on contours.</p>

<p>An essential extension of the nonlinear method of stationary phase has been the introduction of the so-called finite gap g-function transformation by , which has been crucial in most applications. This was inspired by work of Lax, Levermore and Venakides, who reduced the analysis of the small dispersion limit of the <a href="KdV_equation" title="wikilink">KdV equation</a> to the analysis of a maximization problem for a logarithmic potential under some external field: a variational problem of "electrostatic" type. The g-function is the logarithmic transform of the maximizing "equilibrium" measure. The analysis of the small dispersion limit of KdV has in fact provided the basis for the analysis of most of the work concerning "real" orthogonal polynomials (i.e. with the orthogonality condition defined on the real line) and Hermitian random matrices.</p>

<p>Perhaps the most sophisticated extension of the theory so far is the one applied to the "non self-adjoint" case, i.e. when the underlying Lax operator (the first component of the <a href="Lax_pair" title="wikilink">Lax pair</a>) is not <a class="uri" href="self-adjoint" title="wikilink">self-adjoint</a>, by . In that case, actual "steepest descent contours" are defined and computed. The corresponding variational problem is a max-min problem: one looks for a contour that minimizes the "equilibrium" measure. The study of the variational problem and the proof of a regular solution, under some conditions on the external field, was done in .</p>

<p>An alternative asymptotic analysis of Riemann–Hilbert factorization problems is provided in , especially convenient when jump matrices do not have analytic extensions. Their method is based on the analysis of d-bar problems, rather than the asymptotic analysis of singular integrals on contours. An alternative way of dealing with jump matrices with no analytic extensions was introduced in .</p>

<p>Another extension of the theory appears in  where the underlying space of the Riemann–Hilbert problem is a compact hyperelliptic Riemann surface. The right factorization problem is no more holomorphic, but rather meromorphic, by reason of the Riemann-Roch theorem. The Riemann–Hilbert problem deformation theory is applied to the problem of stability of the infinite periodic <a href="Toda_lattice" title="wikilink">Toda lattice</a> under a "short range" perturbation (for example a perturbation of a finite number of particles).</p>

<p>Most Riemann–Hilbert factorization problems studied in the literature are 2-dimensional, i.e. the unknown matrices are of dimension 2. Higher-dimensional problems have been studied by Kuijlaars and collaborators, see e.g. .</p>
<h2 id="example-scalar-riemann-hilbert-factorization-problem">Example: Scalar Riemann-Hilbert factorization problem</h2>

<p>Suppose <em>V</em>=2, and Σ is a contour from <em>z</em>=-1 to <em>z</em>=1. What is the solution of <em>M</em>?</p>

<p>To solve this, let's take the <a class="uri" href="logarithm" title="wikilink">logarithm</a> of equation 

<math display="inline" id="Riemann–Hilbert_problem:9">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mo>+</mo>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>M</mi>
     <mo>-</mo>
    </msub>
    <mi>V</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <plus></plus>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <minus></minus>
     </apply>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{+}=M_{-}V
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Riemann–Hilbert_problem:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>log</mi>
     <msub>
      <mi>M</mi>
      <mo>+</mo>
     </msub>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>log</mi>
      <msub>
       <mi>M</mi>
       <mo>-</mo>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>log</mi>
     <mn>2.</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <log></log>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <plus></plus>
      </apply>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <log></log>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <minus></minus>
       </apply>
      </apply>
      <ci>z</ci>
     </apply>
     <apply>
      <log></log>
      <cn type="float">2.</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log M_{+}(z)=\log M_{-}(z)+\log 2.
  </annotation>
 </semantics>
</math>

 Since M tends to 1, log M tends to zero as z tends to infinity.</p>

<p>A standard fact about the Cauchy Transform is that 

<math display="inline" id="Riemann–Hilbert_problem:11">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>C</mi>
     <mo>+</mo>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>C</mi>
     <mo>-</mo>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <plus></plus>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <minus></minus>
     </apply>
    </apply>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{+}-C_{-}=I
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Riemann–Hilbert_problem:12">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mo>+</mo>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>C</mi>
    <mo>-</mo>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <plus></plus>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <minus></minus>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{+},C_{-}
  </annotation>
 </semantics>
</math>

 are the limits of the Cauchy transform from above and below Σ; therefore, we get</p>

<p>

<math display="block" id="Riemann–Hilbert_problem:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mrow>
        <mn>2</mn>
        <mi>π</mi>
        <mi>i</mi>
       </mrow>
      </mfrac>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∫</mo>
        <msub>
         <mi mathvariant="normal">Σ</mi>
         <mo>+</mo>
        </msub>
       </msub>
       <mrow>
        <mfrac>
         <mrow>
          <mi>log</mi>
          <mn>2</mn>
         </mrow>
         <mrow>
          <mi>ζ</mi>
          <mo>-</mo>
          <mi>z</mi>
         </mrow>
        </mfrac>
        <mi>d</mi>
        <mi>ζ</mi>
       </mrow>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mrow>
        <mn>2</mn>
        <mi>π</mi>
        <mi>i</mi>
       </mrow>
      </mfrac>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∫</mo>
        <msub>
         <mi mathvariant="normal">Σ</mi>
         <mo>-</mo>
        </msub>
       </msub>
       <mrow>
        <mfrac>
         <mrow>
          <mi>log</mi>
          <mn>2</mn>
         </mrow>
         <mrow>
          <mi>ζ</mi>
          <mo>-</mo>
          <mi>z</mi>
         </mrow>
        </mfrac>
        <mi>d</mi>
        <mi>ζ</mi>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mpadded width="+5.1pt">
       <mn>2</mn>
      </mpadded>
      <mpadded width="+3.4pt">
       <mi>when</mi>
      </mpadded>
      <mi>z</mi>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mi mathvariant="normal">Σ</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>π</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>normal-Σ</ci>
          <plus></plus>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <apply>
           <log></log>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <minus></minus>
           <ci>ζ</ci>
           <ci>z</ci>
          </apply>
         </apply>
         <ci>d</ci>
         <ci>ζ</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>π</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>normal-Σ</ci>
          <minus></minus>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <apply>
           <log></log>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <minus></minus>
           <ci>ζ</ci>
           <ci>z</ci>
          </apply>
         </apply>
         <ci>d</ci>
         <ci>ζ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <log></log>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>when</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <ci>normal-Σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2\pi i}\int_{\Sigma_{+}}\frac{\log{2}}{\zeta-z}d\zeta-\frac{1}{2\pi i%
}\int_{\Sigma_{-}}\frac{\log{2}}{\zeta-z}d\zeta=\log{2}\,\,\,\mathrm{when}\,\,%
z\in\Sigma.
  </annotation>
 </semantics>
</math>

</p>

<p>Because the solution <em>M</em> of a Riemann-Hilbert factorization problem is unique (an easy application of <a href="Liouville's_theorem_(complex_analysis)" title="wikilink">Liouville's theorem (complex analysis)</a>), the <a href="Sokhotski–Plemelj_theorem" title="wikilink">Sokhotski–Plemelj theorem</a> gives the solution. We get</p>

<p>

<math display="block" id="Riemann–Hilbert_problem:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>log</mi>
     <mi>M</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
       <mi>i</mi>
      </mrow>
     </mfrac>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∫</mo>
       <mi mathvariant="normal">Σ</mi>
      </msub>
      <mrow>
       <mfrac>
        <mrow>
         <mi>log</mi>
         <mn>2</mn>
        </mrow>
        <mrow>
         <mi>ζ</mi>
         <mo>-</mo>
         <mi>z</mi>
        </mrow>
       </mfrac>
       <mi>d</mi>
       <mi>ζ</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mi>log</mi>
       <mn>2</mn>
      </mrow>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
       <mi>i</mi>
      </mrow>
     </mfrac>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mrow>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo>-</mo>
        <mi>z</mi>
       </mrow>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mi>z</mi>
       </mrow>
      </msubsup>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mi>ζ</mi>
       </mfrac>
       <mi>d</mi>
       <mi>ζ</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mi>log</mi>
       <mn>2</mn>
      </mrow>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
       <mi>i</mi>
      </mrow>
     </mfrac>
     <mrow>
      <mi>log</mi>
      <mfrac>
       <mrow>
        <mi>z</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mrow>
        <mi>z</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </mfrac>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <log></log>
      <ci>M</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <ci>normal-Σ</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <log></log>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <minus></minus>
          <ci>ζ</ci>
          <ci>z</ci>
         </apply>
        </apply>
        <ci>d</ci>
        <ci>ζ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <log></log>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <int></int>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
          <ci>z</ci>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
         <ci>z</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <ci>ζ</ci>
        </apply>
        <ci>d</ci>
        <ci>ζ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <log></log>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <log></log>
       <apply>
        <divide></divide>
        <apply>
         <minus></minus>
         <ci>z</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <plus></plus>
         <ci>z</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log M=\frac{1}{2\pi i}\int_{\Sigma}\frac{\log{2}}{\zeta-z}d\zeta=\frac{\log 2%
}{2\pi i}\int^{1-z}_{-1-z}\frac{1}{\zeta}d\zeta=\frac{\log 2}{2\pi i}\log{%
\frac{z-1}{z+1}},
  </annotation>
 </semantics>
</math>

</p>

<p>i.e. 

<math display="inline" id="Riemann–Hilbert_problem:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mrow>
       <mi>z</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mrow>
       <mi>z</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </mfrac>
     <mo>)</mo>
    </mrow>
    <mfrac>
     <mrow>
      <mi>log</mi>
      <mn>2</mn>
     </mrow>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
      <mi>i</mi>
     </mrow>
    </mfrac>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>M</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>z</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <plus></plus>
       <ci>z</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <log></log>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M(z)=\left(\frac{z-1}{z+1}\right)^{\frac{\log{2}}{2\pi i}}
  </annotation>
 </semantics>
</math>

 which has a branch cut at contour 

<math display="inline" id="Riemann–Hilbert_problem:16">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

.</p>

<p>Check: 

<math display="inline" id="Riemann–Hilbert_problem:17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>M</mi>
       <mo>+</mo>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>e</mi>
        <mrow>
         <mi>i</mi>
         <mi>π</mi>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
      <mfrac>
       <mrow>
        <mi>log</mi>
        <mn>2</mn>
       </mrow>
       <mrow>
        <mn>2</mn>
        <mi>π</mi>
        <mi>i</mi>
       </mrow>
      </mfrac>
     </msup>
     <mo>=</mo>
     <msup>
      <mi>e</mi>
      <mfrac>
       <mrow>
        <mi>log</mi>
        <mn>2</mn>
       </mrow>
       <mn>2</mn>
      </mfrac>
     </msup>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>M</mi>
       <mo>-</mo>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>e</mi>
        <mrow>
         <mo>-</mo>
         <mrow>
          <mi>i</mi>
          <mi>π</mi>
         </mrow>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
      <mfrac>
       <mrow>
        <mi>log</mi>
        <mn>2</mn>
       </mrow>
       <mrow>
        <mn>2</mn>
        <mi>π</mi>
        <mi>i</mi>
       </mrow>
      </mfrac>
     </msup>
     <mo>=</mo>
     <msup>
      <mi>e</mi>
      <mrow>
       <mo>-</mo>
       <mfrac>
        <mrow>
         <mi>log</mi>
         <mn>2</mn>
        </mrow>
        <mn>2</mn>
       </mfrac>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <plus></plus>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>π</ci>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <log></log>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>π</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <divide></divide>
        <apply>
         <log></log>
         <cn type="integer">2</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <minus></minus>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>π</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <log></log>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>π</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <apply>
          <log></log>
          <cn type="integer">2</cn>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{+}(0)=(e^{i\pi})^{\frac{\log 2}{2\pi i}}=e^{\frac{\log 2}{2}},M_{-}(0)=(e^{%
-i\pi})^{\frac{\log 2}{2\pi i}}=e^{-\frac{\log 2}{2}};
  </annotation>
 </semantics>
</math>


</p>

<p>therefore, 

<math display="inline" id="Riemann–Hilbert_problem:18">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>M</mi>
     <mo>+</mo>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>M</mi>
     <mo>-</mo>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <msup>
     <mi>e</mi>
     <mrow>
      <mi>log</mi>
      <mn>2</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>M</mi>
     <mo>-</mo>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <plus></plus>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <minus></minus>
      </apply>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <log></log>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <minus></minus>
      </apply>
      <cn type="integer">0</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{+}(0)=M_{-}(0)e^{\log{2}}=M_{-}(0)2
  </annotation>
 </semantics>
</math>

.</p>

<p>CAVEAT: If the problem is not scalar one cannot take logarithms. In general explicit solutions are very rare.</p>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Complex_analysis" title="wikilink">Category:Complex analysis</a> <a href="Category:Exactly_solvable_models" title="wikilink">Category:Exactly solvable models</a> <a class="uri" href="Category:Solitons" title="wikilink">Category:Solitons</a> <a href="Category:Scattering_theory" title="wikilink">Category:Scattering theory</a> <a href="Category:Harmonic_analysis" title="wikilink">Category:Harmonic analysis</a> <a href="Category:Microlocal_analysis" title="wikilink">Category:Microlocal analysis</a> <a href="Category:Ordinary_differential_equations" title="wikilink">Category:Ordinary differential equations</a> <a href="Category:Partial_differential_equations" title="wikilink">Category:Partial differential equations</a> <a href="Category:Mathematical_problems" title="wikilink">Category:Mathematical problems</a></p>
</body>
</html>
