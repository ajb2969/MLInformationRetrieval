<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="372">Routing and wavelength assignment</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Routing and wavelength assignment</h1>
<hr/>

<p>The <strong>routing and wavelength assignment</strong> (<strong>RWA</strong>) problem is an <a href="optical_telecommunication" title="wikilink">optical networking</a> problem with the goal of maximizing the number of optical connections.</p>
<h2 id="definition">Definition</h2>

<p>The general objective of the RWA problem is to maximize the number of established connections. Each connection request must be given a route and wavelength. The wavelength must be consistent for the entire path, unless the usage of wavelength converters is assumed. Two connections requests can share the same <a href="optical_link" title="wikilink">optical link</a>, provided a different wavelength is used.</p>

<p>The RWA problem can be formally defined in an <a href="Linear_programming" title="wikilink">integer linear program</a> (ILP). The ILP formulation given here is taken from.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>'''Maximize: '''</p>

<p>

<math display="block" id="Routing_and_wavelength_assignment:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>C</mi>
     <mn>0</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ρ</mi>
     <mo>,</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <msub>
      <mi>N</mi>
      <mrow>
       <mi>s</mi>
       <mi>d</mi>
      </mrow>
     </msub>
    </munderover>
    <msub>
     <mi>m</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <cn type="integer">0</cn>
     </apply>
     <interval closure="open">
      <ci>ρ</ci>
      <ci>q</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <apply>
        <times></times>
        <ci>s</ci>
        <ci>d</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{0}(\rho,q)=\sum_{i=1}^{N_{sd}}m_{i}
  </annotation>
 </semantics>
</math>

</p>

<p><strong>subject to</strong></p>

<p>

<math display="block" id="Routing_and_wavelength_assignment:1">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>m</mi>
     <mi>i</mi>
    </msub>
    <mo>≥</mo>
    <mrow>
     <mn>0</mn>
     <mo>,</mo>
     <mrow>
      <mi>i</mi>
      <mi>n</mi>
      <mi>t</mi>
      <mi>e</mi>
      <mi>g</mi>
      <mi>e</mi>
      <mi>r</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>N</mi>
      <mrow>
       <mi>s</mi>
       <mi>d</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>i</ci>
     </apply>
     <list>
      <cn type="integer">0</cn>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>n</ci>
       <ci>t</ci>
       <ci>e</ci>
       <ci>g</ci>
       <ci>e</ci>
       <ci>r</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <ci>i</ci>
     <list>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <apply>
        <times></times>
        <ci>s</ci>
        <ci>d</ci>
       </apply>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{i}\geq 0,integer,i=1,2,...,N_{sd}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Routing_and_wavelength_assignment:2">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo>∈</mo>
    <mrow>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mrow>
      <mn>1</mn>
      <mo>,</mo>
      <mn>2</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mi>P</mi>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>j</mi>
     <mo>=</mo>
     <mrow>
      <mn>1</mn>
      <mo>,</mo>
      <mn>2</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mi>W</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <list>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </list>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <ci>i</ci>
      <list>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
       <ci>normal-…</ci>
       <ci>P</ci>
      </list>
     </apply>
     <apply>
      <eq></eq>
      <ci>j</ci>
      <list>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
       <ci>normal-…</ci>
       <ci>W</ci>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{ij}\in{0,1},i=1,2,...,P,j=1,2,...,W
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Routing_and_wavelength_assignment:3">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>C</mi>
     <mi>T</mi>
    </msup>
    <mi>B</mi>
   </mrow>
   <mo>≤</mo>
   <msub>
    <mi>l</mi>
    <mrow>
     <mi>W</mi>
     <mo>×</mo>
     <mi>L</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>C</ci>
      <ci>T</ci>
     </apply>
     <ci>B</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>l</ci>
     <apply>
      <times></times>
      <ci>W</ci>
      <ci>L</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{T}B\leq l_{W\times L}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Routing_and_wavelength_assignment:4">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>≤</mo>
   <mrow>
    <msub>
     <mn>1</mn>
     <mi>W</mi>
    </msub>
    <msup>
     <mi>C</mi>
     <mi>T</mi>
    </msup>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>m</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="integer">1</cn>
      <ci>W</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>C</ci>
      <ci>T</ci>
     </apply>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\leq 1_{W}C^{T}A
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Routing_and_wavelength_assignment:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>m</mi>
     <mi>i</mi>
    </msub>
    <mo>≤</mo>
    <mrow>
     <msub>
      <mi>q</mi>
      <mi>i</mi>
     </msub>
     <mi>ρ</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>N</mi>
      <mrow>
       <mi>s</mi>
       <mi>d</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <ci>i</ci>
      </apply>
      <ci>ρ</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>i</ci>
     <list>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <apply>
        <times></times>
        <ci>s</ci>
        <ci>d</ci>
       </apply>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{i}\leq q_{i}\rho,i=1,2,...,N_{sd}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Routing_and_wavelength_assignment:6">
 <semantics>
  <msub>
   <mi>N</mi>
   <mrow>
    <mi>s</mi>
    <mi>d</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{sd}
  </annotation>
 </semantics>
</math>

 is the number of source-destination pairs, while 

<math display="inline" id="Routing_and_wavelength_assignment:7">
 <semantics>
  <msub>
   <mi>m</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{i}
  </annotation>
 </semantics>
</math>

 is the number of connections established for each source-destination pair. 

<math display="inline" id="Routing_and_wavelength_assignment:8">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is the number of links and 

<math display="inline" id="Routing_and_wavelength_assignment:9">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 is the number of wavelengths. 

<math display="inline" id="Routing_and_wavelength_assignment:10">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is the set of paths to route connections. 

<math display="inline" id="Routing_and_wavelength_assignment:11">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>:</mo>
   <mrow>
    <mi>P</mi>
    <mo>×</mo>
    <msub>
     <mi>N</mi>
     <mrow>
      <mi>s</mi>
      <mi>d</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>d</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A:P\times N_{sd}
  </annotation>
 </semantics>
</math>

 is a matrix which shows which source-destination pairs are active, 

<math display="inline" id="Routing_and_wavelength_assignment:12">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>:</mo>
   <mrow>
    <mi>P</mi>
    <mo>×</mo>
    <mi>L</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>B</ci>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B:P\times L
  </annotation>
 </semantics>
</math>

 is a matrix which shows which links are active, and 

<math display="inline" id="Routing_and_wavelength_assignment:13">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>:</mo>
   <mrow>
    <mi>P</mi>
    <mo>×</mo>
    <mi>W</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>C</ci>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>W</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C:P\times W
  </annotation>
 </semantics>
</math>

 is a route and wavelength assignment matrix.</p>

<p>Note that the above formulation assumes that the traffic demands are known <em>a priori</em>. This type of problem is known as Static Lightpath Establishment (SLE). The above formulation also does not consider the signal quality.</p>

<p>It has been shown that the SLE RWA problem is <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> in.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The proof involves a reduction to the 

<math display="inline" id="Routing_and_wavelength_assignment:14">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-graph colorability problem. In other words, solving the SLE RWA problem is as complex as finding the <a href="Graph_coloring" title="wikilink">chromatic number</a> of a general graph. Given that dynamic RWA is more complex than static RWA, it must be the case that dynamic RWA is also NP-complete.</p>

<p>Another NP-complete proof is given in.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> This proof involves a reduction to the <a href="Multi-commodity_flow_problem" title="wikilink">Multi-commodity Flow Problem</a>.</p>

<p>The RWA problem is further complicated by the need to consider signal quality. Many of the optical impairments are nonlinear, so a standard shortest path algorithm can't be used to solve them optimally even if we know the exact state of the network. This is usually not a safe assumption, so solutions need to be efficient using only limited network information.</p>
<h2 id="methodology">Methodology</h2>

<p>Given the complexity of RWA, there are two general methodologies for solving the problem:</p>
<ul>
<li>The first method is solving the routing portion first, and then assigning a wavelength second. Three types of route selection are Fixed Path Routing, Fixed Alternate Routing, and Adaptive Routing.</li>
<li>The second approach is to consider both route selection and wavelength assignment jointly.</li>
</ul>
<h2 id="first-routing-then-wavelength-assignment">First routing, then wavelength assignment</h2>
<h3 id="routing-algorithms">Routing algorithms</h3>
<h4 id="fixed-path-routing">Fixed path routing</h4>

<p>Fixed path routing is the simplest approach to finding a lightpath. The same fixed route for a given source and destination pair is always used. Typically this path is computed ahead of time using a shortest path algorithm, such as <a href="Dijkstra's_Algorithm" title="wikilink">Dijkstra's Algorithm</a>. While this approach is very simple, the performance is usually not sufficient. If resources along the fixed path are in use, future connection requests will be blocked even though other paths may exist.</p>

<p>The SP-1 (Shortest Path, 1 Probe) algorithm is an example of a Fixed Path Routing solution. This algorithm calculates the shortest path using the number of optical routers as the cost function. A single probe is used to establish the connection using the shortest path. The <a href="Analysis_of_algorithms" title="wikilink">running time</a> is the cost of Dijkstra's algorithm

<math display="block" id="Routing_and_wavelength_assignment:15">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>m</mi>
     <mo>+</mo>
     <mrow>
      <mi>n</mi>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <ci>m</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(m+n\log n)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Routing_and_wavelength_assignment:16">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 is the number of edges and 

<math display="inline" id="Routing_and_wavelength_assignment:17">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is the number of routers. The running time is just a constant if a predetermined path is used.</p>

<p>This definition of SP-1 uses the <a href="hop_count" title="wikilink">hop count</a> as the cost function. The SP-1 algorithm could be extended to use different cost functions, such as the number of EDFAs.</p>
<h4 id="fixed-alternate-routing">Fixed alternate routing</h4>

<p>Fixed alternate routing is an extension of fixed path routing. Instead of having just one fixed route for a given source and destination pair, several routes are stored. The probes can be sent in a serial or parallel fashion. For each connection request, the source node attempts to find a connection on each of the paths. If all of the paths fail, then the connection is blocked. If multiple paths are available, only one of them would be utilized.</p>

<p>The SP-

<math display="inline" id="Routing_and_wavelength_assignment:18">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 (Shortest Path, 

<math display="inline" id="Routing_and_wavelength_assignment:19">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 Probes, 

<math display="inline" id="Routing_and_wavelength_assignment:20">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>></mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>p</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p>1
  </annotation>
 </semantics>
</math>

) algorithm is an example of Fixed Alternate Routing. This algorithm calculates the 

<math display="inline" id="Routing_and_wavelength_assignment:21">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 shortest paths using the number of optical routers as the cost function. The running time using <a href="Yen's_algorithm" title="wikilink">Yen's algorithm</a> <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> is 

<math display="inline" id="Routing_and_wavelength_assignment:22">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>p</mi>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>m</mi>
       <mo>+</mo>
       <mrow>
        <mi>n</mi>
        <mrow>
         <mi>log</mi>
         <mi>n</mi>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>n</ci>
     <apply>
      <plus></plus>
      <ci>m</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <log></log>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(pn(m+n\log n))
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Routing_and_wavelength_assignment:23">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 is the number of edges, 

<math display="inline" id="Routing_and_wavelength_assignment:24">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is the number of routers, and 

<math display="inline" id="Routing_and_wavelength_assignment:25">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is the number of paths. The running time is a constant factor if the paths are precomputed.</p>
<h4 id="adaptive-routing">Adaptive routing</h4>

<p>The major issue with both fixed path routing and fixed alternate routing is that neither algorithm takes into account the current state of the network. If the predetermined paths are not available, the connection request will become blocked even though other paths may exist. Fixed Path Routing and Fixed Alternate Routing are both not quality aware. For these reasons, most of the research in RWA is currently taking place in Adaptive algorithms. Five examples of Adaptive Routing are LORA, PABR, IA-BF, IA-FF, and AQoS.</p>

<p>Adaptive algorithms fall into two categories: traditional and physically aware. Traditional adaptive algorithms do not consider signal quality, however, physically aware adaptive algorithms do.</p>
<h4 id="traditional-adaptive-rwa">Traditional adaptive RWA</h4>

<p>The lexicographical <a href="Routing" title="wikilink">routing algorithm</a> (LORA) algorithm was proposed in.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The main idea behind LORA is to route connection requests away from congested areas of the network, increasing the probability that connection requests will be accepted. This is accomplished by setting the cost of each link to be 

<math display="inline" id="Routing_and_wavelength_assignment:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mi>o</mi>
    <mi>s</mi>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>β</mi>
    <mrow>
     <mi>u</mi>
     <mi>s</mi>
     <mi>a</mi>
     <mi>g</mi>
     <mi>e</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>o</ci>
     <ci>s</ci>
     <ci>t</ci>
     <ci>l</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>β</ci>
     <apply>
      <times></times>
      <ci>u</ci>
      <ci>s</ci>
      <ci>a</ci>
      <ci>g</ci>
      <ci>e</ci>
      <ci>l</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   cost(l)=\beta^{usage(l)}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Routing_and_wavelength_assignment:27">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 is parameter that can be dynamically adjusted according to the traffic load and 

<math display="inline" id="Routing_and_wavelength_assignment:28">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mi>s</mi>
   <mi>a</mi>
   <mi>g</mi>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>l</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>u</ci>
    <ci>s</ci>
    <ci>a</ci>
    <ci>g</ci>
    <ci>e</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   usage(l)
  </annotation>
 </semantics>
</math>

 is the number of wavelengths in use on link 

<math display="inline" id="Routing_and_wavelength_assignment:29">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

. A standard shortest path algorithm can then be used to find the path. This requires each <a href="optical_switch" title="wikilink">optical switch</a> to broadcast recent usage information periodically. Note that LORA does not consider any physical impairments.</p>

<p>When 

<math display="inline" id="Routing_and_wavelength_assignment:30">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 is equal to one, the LORA algorithm is identical to the SP algorithm. Increasing the value of 

<math display="inline" id="Routing_and_wavelength_assignment:31">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 will increase the bias towards less used routes. The optimal value of can be calculated using the well-known <a href="hill_climbing" title="wikilink">hill climbing</a> algorithm. The optimal values of 

<math display="inline" id="Routing_and_wavelength_assignment:32">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 were between 1.1 and 1.2 in the proposal.</p>
<h4 id="physically-aware-adaptive-rwa">Physically aware adaptive RWA</h4>

<p>The physically aware backward reservation algorithm (PABR) is an extension of LORA. PABR is able to improve performance in two ways: considering physical impairments and improved wavelength selection. As PABR is searching for an optical path, paths with an unacceptable signal quality due to linear impairments are pruned. In other words, PABR is LORA with an additional quality constraint.</p>

<p>Note that PABR can only consider linear impairments. The nonlinear impairments, on the other hand, would not be possible to estimate in a distributed environment due to their requirement of global traffic knowledge.</p>

<p>PABR also considers signal quality when making the wavelength selection. It accomplishes this by removing from consideration all wavelengths with an unacceptable signal quality level. The approach is called Quality First Fit and it is discussed in the following section.</p>

<p>It should also be noted that both LORA and PABR can be implemented with either single-probing or multi-probing. The maximum number of probes 

<math display="inline" id="Routing_and_wavelength_assignment:33">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is denoted as LORA-

<math display="inline" id="Routing_and_wavelength_assignment:34">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 or PABR-

<math display="inline" id="Routing_and_wavelength_assignment:35">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

. With single-probing, only one path is selected by the route selection. With multi-probing, multiple paths are attempted in parallel, increasing the probability of connection success.</p>
<h4 id="other-routing-approaches">Other routing approaches</h4>

<p><strong>IA-BF</strong> - The Impairment Aware Best Fit (IA-BF) algorithm was proposed in.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> This algorithm is a distributed approach that is dependent upon a large amount of communication to use global information to always pick the shortest available path and wavelength. This is accomplished through the use of serial multi-probing. The shortest available path and wavelength are attempted first, and upon failure, the second shortest available path and wavelength are attempted. This process continues until a successful path and wavelength have been found or all wavelengths have been attempted.</p>

<p>The multi-probing approach will allow IA-BF to outperform both PABR-1 and LORA-1. However, as the number of probes increases, the performance of the algorithms is similar.</p>

<p><strong>IA-FF</strong> - Impairment Aware First Fit (IA-FF) is a <a href="simple_extension" title="wikilink">simple extension</a> of IA-BF. Instead of picking the wavelengths in terms of the minimum cost, the wavelengths are selected in order according to their index. IA-BF tends to outperform IA-FF under most scenarios.</p>

<p><strong>AQoS</strong> - Adaptive Quality of Service (AQoS) was proposed in.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> This algorithm is unique in a couple of ways. First, each node maintains two counters

<math display="block" id="Routing_and_wavelength_assignment:36">
 <semantics>
  <msub>
   <mi>N</mi>
   <mrow>
    <mi>B</mi>
    <mi>E</mi>
    <mi>R</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <apply>
     <times></times>
     <ci>B</ci>
     <ci>E</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{BER}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Routing_and_wavelength_assignment:37">
 <semantics>
  <msub>
   <mi>N</mi>
   <mrow>
    <mi>w</mi>
    <mi>a</mi>
    <mi>v</mi>
    <mi>e</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <apply>
     <times></times>
     <ci>w</ci>
     <ci>a</ci>
     <ci>v</ci>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{wave}
  </annotation>
 </semantics>
</math>

. The purpose of each counter is to determine which issue is a bigger factor in blocking: Path and wavelength availability or Quality requirements. The algorithm chooses routes differently based upon the larger issue.</p>

<p>Another distinction is that AQoS uses the <a href="Q_factor" title="wikilink">Q-factor</a> as the link cost. The cost of the 

<math display="inline" id="Routing_and_wavelength_assignment:38">
 <semantics>
  <msub>
   <mi>i</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>i</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i_{th}
  </annotation>
 </semantics>
</math>

 link is calculated by this formula 

<math display="inline" id="Routing_and_wavelength_assignment:39">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mstyle displaystyle="false">
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <msub>
        <mi>N</mi>
        <mi>i</mi>
       </msub>
      </msubsup>
     </mstyle>
     <mrow>
      <mn>10</mn>
      <mrow>
       <mi>log</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <msubsup>
          <mi>Q</mi>
          <mrow>
           <mi>i</mi>
           <mo>,</mo>
           <mi>j</mi>
          </mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>s</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </msubsup>
         <mo>/</mo>
         <msubsup>
          <mi>Q</mi>
          <mrow>
           <mi>i</mi>
           <mo>,</mo>
           <mi>j</mi>
          </mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>d</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </msubsup>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <msub>
     <mi>N</mi>
     <mi>i</mi>
    </msub>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>N</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">10</cn>
       <apply>
        <log></log>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>Q</ci>
           <list>
            <ci>i</ci>
            <ci>j</ci>
           </list>
          </apply>
          <ci>s</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>Q</ci>
           <list>
            <ci>i</ci>
            <ci>j</ci>
           </list>
          </apply>
          <ci>d</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{i}=\frac{\sum_{j=1}^{N_{i}}10\log[Q_{i,j}^{(s)}/Q_{i,j}^{(d)}]}{N_{i}}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Routing_and_wavelength_assignment:40">
 <semantics>
  <msub>
   <mi>N</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{i}
  </annotation>
 </semantics>
</math>

 is the number of lightpaths on the 

<math display="inline" id="Routing_and_wavelength_assignment:41">
 <semantics>
  <msub>
   <mi>i</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>i</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i_{th}
  </annotation>
 </semantics>
</math>

 link, 

<math display="inline" id="Routing_and_wavelength_assignment:42">
 <semantics>
  <msubsup>
   <mi>Q</mi>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <list>
      <ci>i</ci>
      <ci>j</ci>
     </list>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{i,j}^{(s)}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Routing_and_wavelength_assignment:43">
 <semantics>
  <msubsup>
   <mi>Q</mi>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>d</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <list>
      <ci>i</ci>
      <ci>j</ci>
     </list>
    </apply>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{i,j}^{(d)}
  </annotation>
 </semantics>
</math>

 are the quality factor measurements of the 

<math display="inline" id="Routing_and_wavelength_assignment:44">
 <semantics>
  <msub>
   <mi>j</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>j</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j_{th}
  </annotation>
 </semantics>
</math>

 lightpath at the source and destination nodes of the 

<math display="inline" id="Routing_and_wavelength_assignment:45">
 <semantics>
  <msub>
   <mi>i</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>i</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i_{th}
  </annotation>
 </semantics>
</math>

 link, respectively. The repeated quality factor estimations are computationally very expensive.</p>

<p>This algorithm is single probing approach. The multi-probing approach, which the paper names ALT-AQoS (alternate AQoS) is a simple extension upon the same basic idea.</p>
<h3 id="wavelength-assignment">Wavelength assignment</h3>

<p>Two of the most common methods for wavelength assignment are First Fit and Random Fit. First Fit chooses the available wavelength with the lowest index. Random Fit determines which wavelengths are available and then chooses randomly amongst them. The complexity of both algorithms is 

<math display="inline" id="Routing_and_wavelength_assignment:46">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(w)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Routing_and_wavelength_assignment:47">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 is the number of wavelengths. First Fit outperforms Random Fit.</p>

<p>An extension to First Fit and Random Fit was proposed in <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> to consider signal quality. Quality First Fit and Quality Random Fit eliminate from consideration wavelengths which have an unacceptable signal quality. The complexity of these algorithms is higher though, as up to 

<math display="inline" id="Routing_and_wavelength_assignment:48">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 calls to estimate the Q-factor are required.</p>

<p>There are several other wavelength assignment algorithms: Least Used, Most Used, Min Product, Least Loaded, Max Sum,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> and Relative Capacity Loss.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Most Used outperforms Least Used use significantly, and slightly outperforms First Fit. Min Product, Least Loaded, Max Sum, and Relative Capacity Loss all try to choose a wavelength that minimizes the probability that future requests will be blocked.</p>

<p>A significant disadvantage of these algorithms is that they require a significant communication overhead, making them unpractical to implement unless you have a centralized network structure.</p>
<h2 id="joint-routing-and-wavelength-assignment">Joint routing and wavelength assignment</h2>

<p>An alternate approach to selecting a route and wavelength separately is to consider them jointly. These approaches tend to more theoretical and not very practical. As this is a NP-complete problem, any exact solution is likely not be possible. The approximation techniques usually aren't very useful either, as they will require centralized control and, usually, predefined traffic demands. Two joint approaches are ILP formulation and <a href="Island_hopping" title="wikilink">Island Hopping</a>.</p>

<p>The ILP formulation listed above can be solved using a traditional ILP solver. This is typically done by temporarily relaxing the integer constraints, solving the problem optimally, and converting the real solution to an integer solution. Additional constraints can be added and the process repeated indefinitely using a <a href="branch_and_bound" title="wikilink">branch and bound</a> approach.</p>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Fiber-optic_communications" title="wikilink">Category:Fiber-optic communications</a> <a href="Category:Telecommunication_theory" title="wikilink">Category:Telecommunication theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">H. Zang, J. Jue, and B. Mukherjee, "A Review of Routing and Wavelength Assignment Approaches for Wavelength Routed Optical WDM Networks," {\it Optical Networks Magazine}, January 2000.<a href="#fnref1">↩</a></li>
<li id="fn2">I. Chlamtac, A. Ganz, and G. Karmi, "Lightpath communications: an approach to high bandwidth optical WAN's," {\it IEEE Transactions on Communications}, Vol 40, No 7, pp. 1171-1182, July 1992.<a href="#fnref2">↩</a></li>
<li id="fn3">S. Evan, A. Itai, and A. Shamir, "On the Complexity of Timetable and Multicommodity Flow Problems," SIAM Journal of Computing, Vol 5, pp 691-703, 1976<a href="#fnref3">↩</a></li>
<li id="fn4">M. Pascoal and E. Martins. "A new implementation of Yen’s ranking loopless paths algorithm." 4OR–Quarterly Journal of the Belgian, French and Italian Operations Research Societies, 2003<a href="#fnref4">↩</a></li>
<li id="fn5">W. Lin, "Physically Aware Agile Optical Networks," Ph.D. Dissertation, Montana State University, Bozeman, July 2008.<a href="#fnref5">↩</a></li>
<li id="fn6">Y. Huang, J. Heritage, and B. Mukherjee, "Connection Provisioning With Transmission Impairment Consideration in Optical WDM Networks With High-Speed Channels," Journal of Lightwave Technology, Vol 23, No 3, March 2005.<a href="#fnref6">↩</a></li>
<li id="fn7">T. Deng and S. Subramaniam, "Adaptive QoS Routing in Dynamic Wavelength-Routed Optical Networks," Broadband Networks 2005, pp. 184-193, 2005<a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9">R. Barry and S. Subramaniam, "The MAX-SUM Wavelength Assignment Algorithm for WDM Ring Networks," Proceedings of Optical Fiber Conference, February 1997.<a href="#fnref9">↩</a></li>
<li id="fn10">X. Zhang and C. Qiao, "Wavelength Assignment for Dynamic Traffic in Multi-Fiber WDM Networks," Proceedings of <a href="International_Conference_on_Communications" title="wikilink">International Conference on Communications</a>, Vol 1, pp 406-410, June 1997.<a href="#fnref10">↩</a></li>
</ol>
</section>
</body>
</html>
