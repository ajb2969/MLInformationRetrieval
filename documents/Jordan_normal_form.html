<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1967">Jordan normal form</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Jordan normal form</h1>
<hr/>

<p> In <a href="linear_algebra" title="wikilink">linear algebra</a>, a <strong>Jordan normal form</strong> (often called <strong>Jordan canonical form</strong>)<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> of a <a href="linear_operator" title="wikilink">linear operator</a> on a <a class="uri" href="finite-dimensional" title="wikilink">finite-dimensional</a> <a href="vector_space" title="wikilink">vector space</a> is an <a href="upper_triangular_matrix" title="wikilink">upper triangular matrix</a> of a particular form called a <a href="Jordan_matrix" title="wikilink">Jordan matrix</a>, representing the operator with respect to some <a href="Basis_(linear_algebra)" title="wikilink">basis</a>. Such matrix has each non-zero off-diagonal entry equal to 1, immediately above the main diagonal (on the <a class="uri" href="superdiagonal" title="wikilink">superdiagonal</a>), and with identical diagonal entries to the left and below them. If the vector space is over a <a href="field_(mathematics)" title="wikilink">field</a> <em>K</em>, then a basis with respect to which the matrix has the required form exists <a href="if_and_only_if" title="wikilink">if and only if</a> all <a href="eigenvalue" title="wikilink">eigenvalues</a> of the matrix lie in <em>K</em>, or equivalently if the <a href="characteristic_polynomial" title="wikilink">characteristic polynomial</a> of the operator splits into linear factors over <em>K</em>. This condition is always satisfied if <em>K</em> is the field of <a href="complex_number" title="wikilink">complex numbers</a>. The diagonal entries of the normal form are the eigenvalues of the operator, with the number of times each one occurs being given by its <a href="algebraic_multiplicity" title="wikilink">algebraic multiplicity</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>If the operator is originally given by a <a href="square_matrix" title="wikilink">square matrix</a> <em>M</em>, then its Jordan normal form is also called the Jordan normal form of <em>M</em>. Any square matrix has a Jordan normal form if the field of coefficients is extended to one containing all the eigenvalues of the matrix. In spite of its name, the normal form for a given <em>M</em> is not entirely unique, as it is a <a href="block_diagonal_matrix" title="wikilink">block diagonal matrix</a> formed of <a href="Jordan_block" title="wikilink">Jordan blocks</a>, the order of which is not fixed; it is conventional to group blocks for the same eigenvalue together, but no ordering is imposed among the eigenvalues, nor among the blocks for a given eigenvalue, although the latter could for instance be ordered by weakly decreasing size.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>The <a href="Jordan–Chevalley_decomposition" title="wikilink">Jordan–Chevalley decomposition</a> is particularly simple with respect to a basis for which the operator takes its Jordan normal form. The diagonal form for <a class="uri" href="diagonalizable" title="wikilink">diagonalizable</a> matrices, for instance <a href="normal_matrix" title="wikilink">normal matrices</a>, is a special case of the Jordan normal form.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>The Jordan normal form is named after <a href="Camille_Jordan" title="wikilink">Camille Jordan</a>.</p>
<h2 id="overview">Overview</h2>
<h3 id="notation">Notation</h3>

<p>Some textbooks have the ones on the <a class="uri" href="subdiagonal" title="wikilink">subdiagonal</a>, i.e., immediately below the main diagonal instead of on the superdiagonal. The eigenvalues are still on the main diagonal.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h3 id="motivation">Motivation</h3>

<p>An <em>n</em> × <em>n</em> matrix <em>A</em> is <a href="diagonalizable_matrix" title="wikilink">diagonalizable</a> if and only if the sum of the dimensions of the eigenspaces is <em>n</em>. Or, equivalently, if and only if <em>A</em> has <em>n</em> <a href="linearly_independent" title="wikilink">linearly independent</a> <a class="uri" href="eigenvectors" title="wikilink">eigenvectors</a>. Not all matrices are diagonalizable. Consider the following matrix:</p>

<p>

<math display="inline" id="Jordan_normal_form:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>=</mo>
    <mrow>
     <mo rspace="0pt">[</mo>
     <mpadded width="-3.4pt">
      <mtable>
       <mtr>
        <mtd columnalign="right">
         <mn>5</mn>
        </mtd>
        <mtd columnalign="right">
         <mn>4</mn>
        </mtd>
        <mtd columnalign="right">
         <mn>2</mn>
        </mtd>
        <mtd columnalign="right">
         <mn>1</mn>
        </mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
       </mtr>
       <mtr>
        <mtd columnalign="right">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="right">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="right">
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mtd>
        <mtd columnalign="right">
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
       </mtr>
       <mtr>
        <mtd columnalign="right">
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mtd>
        <mtd columnalign="right">
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mtd>
        <mtd columnalign="right">
         <mn>3</mn>
        </mtd>
        <mtd columnalign="right">
         <mn>0</mn>
        </mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
       </mtr>
       <mtr>
        <mtd columnalign="right">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="right">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="right">
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mtd>
        <mtd columnalign="right">
         <mn>2</mn>
        </mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
        <mtd></mtd>
       </mtr>
      </mtable>
     </mpadded>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <matrix>
      <matrixrow>
       <cn type="integer">5</cn>
       <cn type="integer">4</cn>
       <cn type="integer">2</cn>
       <cn type="integer">1</cn>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
      </matrixrow>
      <matrixrow>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">3</cn>
       <cn type="integer">0</cn>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
      </matrixrow>
      <matrixrow>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">2</cn>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\left[\!\!\!\begin{array}[]{*{20}{r}}5&4&2&1\\
0&1&-1&-1\\
-1&-1&3&0\\
1&1&-1&2\end{array}\!\!\right].
  </annotation>
 </semantics>
</math>

</p>

<p>Including multiplicity, the eigenvalues of <em>A</em> are λ = 1, 2, 4, 4. The <a href="Hamel_dimension" title="wikilink">dimension</a> of the <a href="Kernel_(linear_algebra)" title="wikilink">kernel</a> of (<em>A</em> − 4<strong><a href="identity_matrix" title="wikilink">I<sub>n</sub></a></strong>) is 1 (and not 2), so <em>A</em> is not diagonalizable. However, there is an invertible matrix <em>P</em> such that <em>A</em> = <em>PJP</em><sup>−1</sup>, where</p>

<p>

<math display="block" id="Jordan_normal_form:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>J</mi>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>2</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>4</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>4</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>J</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">2</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">4</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">4</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J=\begin{bmatrix}1&0&0&0\\
0&2&0&0\\
0&0&4&1\\
0&0&0&4\end{bmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>The matrix J is almost diagonal. This is the Jordan normal form of <em>A</em>. The section <a href="#Example" title="wikilink"><em>Example</em></a> below fills in the details of the computation.</p>
<h2 id="complex-matrices">Complex matrices</h2>

<p>In general, a square complex matrix <em>A</em> is <a href="similar_(linear_algebra)" title="wikilink">similar</a> to a <a href="block_diagonal_matrix" title="wikilink">block diagonal matrix</a></p>

<p>

<math display="block" id="Jordan_normal_form:2">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>J</mi>
        <mn>1</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋱</mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>J</mi>
        <mi>p</mi>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>J</ci>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>J</ci>
       <cn type="integer">1</cn>
      </apply>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">absent</csymbol>
     </matrixrow>
     <matrixrow>
      <csymbol cd="latexml">absent</csymbol>
      <ci>normal-⋱</ci>
      <csymbol cd="latexml">absent</csymbol>
     </matrixrow>
     <matrixrow>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>J</ci>
       <ci>p</ci>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J=\begin{bmatrix}J_{1}&&\\
&\ddots&\\
&&J_{p}\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>where each block <em>J</em><sub>i</sub> is a square matrix of the form</p>

<p>

<math display="block" id="Jordan_normal_form:3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>J</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>λ</mi>
         <mi>i</mi>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>λ</mi>
         <mi>i</mi>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋱</mi>
       </mtd>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋱</mi>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>λ</mi>
         <mi>i</mi>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>J</ci>
     <ci>i</ci>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>i</ci>
      </apply>
      <cn type="integer">1</cn>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">absent</csymbol>
     </matrixrow>
     <matrixrow>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-⋱</ci>
      <csymbol cd="latexml">absent</csymbol>
     </matrixrow>
     <matrixrow>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <ci>normal-⋱</ci>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>i</ci>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J_{i}=\begin{bmatrix}\lambda_{i}&1&&\\
&\lambda_{i}&\ddots&\\
&&\ddots&1\\
&&&\lambda_{i}\end{bmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>So there exists an invertible matrix <em>P</em> such that <em>P<sup>−1</sup>AP</em> = <em>J</em> is such that the only non-zero entries of <em>J</em> are on the diagonal and the superdiagonal. <em>J</em> is called the <strong>Jordan normal form</strong> of <em>A</em>. Each <em>J</em><sub><em>i</em></sub> is called a <a href="Jordan_block" title="wikilink">Jordan block</a> of <em>A</em>. In a given Jordan block, every entry on the superdiagonal is 1.</p>

<p>Assuming this result, we can deduce the following properties:</p>
<ul>
<li>Counting multiplicity, the eigenvalues of <em>J</em>, therefore <em>A</em>, are the diagonal entries.</li>
<li>Given an eigenvalue λ<sub><em>i</em></sub>, its <strong><a href="geometric_multiplicity" title="wikilink">geometric multiplicity</a></strong> is the dimension of Ker(<em>A</em> − λ<sub><em>i</em></sub><strong><a href="identity_matrix" title="wikilink">I</a></strong>), and it is the number of Jordan blocks corresponding to λ<sub><em>i</em></sub>.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></li>
<li>The sum of the sizes of all Jordan blocks corresponding to an eigenvalue λ<sub><em>i</em></sub> is its <strong>algebraic multiplicity</strong>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></li>
<li><em>A</em> is diagonalizable if and only if, for every eigenvalue λ of <em>A</em>, its geometric and algebraic multiplicities coincide.</li>
<li>The Jordan block corresponding to λ is of the form λ <strong>I</strong> + <em>N</em>, where <em>N</em> is a <a href="nilpotent_matrix" title="wikilink">nilpotent matrix</a> defined as <em>N</em><sub><em>ij</em></sub> = δ<sub><em>i</em>,<em>j</em>−1</sub> (where δ is the <a href="Kronecker_delta" title="wikilink">Kronecker delta</a>). The nilpotency of <em>N</em> can be exploited when calculating <em>f</em>(<em>A</em>) where <em>f</em> is a complex analytic function. For example, in principle the Jordan form could give a closed-form expression for the exponential exp(<em>A</em>).</li>
<li>The number of Jordan blocks corresponding to λ of size at least <em>j</em> is dim Ker(<em>A - λI)<sup>j</sup> -</em> dim Ker<em>(A - λI)<sup>j-1</sup></em>. Thus, the number of Jordan blocks of size exactly <em>j</em> is</li>
</ul>

<p>

<math display="block" id="Jordan_normal_form:4">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mo>dim</mo>
   <mi>ker</mi>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>-</mo>
     <msub>
      <mi>λ</mi>
      <mi>i</mi>
     </msub>
     <mi>I</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>j</mi>
   </msup>
   <mo>-</mo>
   <mo>dim</mo>
   <mi>ker</mi>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>-</mo>
     <msub>
      <mi>λ</mi>
      <mi>i</mi>
     </msub>
     <mi>I</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>j</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>-</mo>
   <mo>dim</mo>
   <mi>ker</mi>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>-</mo>
     <msub>
      <mi>λ</mi>
      <mi>i</mi>
     </msub>
     <mi>I</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>j</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cn type="integer">2</cn>
    <csymbol cd="latexml">dimension</csymbol>
    <csymbol cd="latexml">kernel</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>i</ci>
      </apply>
      <csymbol cd="unknown">I</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>j</ci>
    </apply>
    <minus></minus>
    <csymbol cd="latexml">dimension</csymbol>
    <csymbol cd="latexml">kernel</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>i</ci>
      </apply>
      <csymbol cd="unknown">I</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <plus></plus>
      <ci>j</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <minus></minus>
    <csymbol cd="latexml">dimension</csymbol>
    <csymbol cd="latexml">kernel</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>i</ci>
      </apply>
      <csymbol cd="unknown">I</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <minus></minus>
      <ci>j</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\dim\ker(A-\lambda_{i}I)^{j}-\dim\ker(A-\lambda_{i}I)^{j+1}-\dim\ker(A-%
\lambda_{i}I)^{j-1}
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>Given an eigenvalue λ<sub><em>i</em></sub>, its multiplicity in the minimal polynomial is the size of its largest Jordan block.</li>
</ul>
<h3 id="generalized-eigenvectors">Generalized eigenvectors</h3>

<p>Consider the matrix <em>A</em> from the example in the previous section. The Jordan normal form is obtained by some similarity transformation <em>P</em><sup>−1</sup><em>AP</em> = <em>J</em>, i.e.</p>

<p>

<math display="block" id="Jordan_normal_form:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded lspace="2.8pt" width="+2.8pt">
      <mi>A</mi>
     </mpadded>
     <mi>P</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>P</mi>
     <mi>J</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>P</ci>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>J</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;AP=PJ.
  </annotation>
 </semantics>
</math>

</p>

<p>Let <em>P</em> have column vectors <em>p</em><sub><em>i</em></sub>, <em>i</em> = 1, ..., 4, then</p>

<p>

<math display="block" id="Jordan_normal_form:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>p</mi>
          <mn>1</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>p</mi>
          <mn>2</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>p</mi>
          <mn>3</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>p</mi>
          <mn>4</mn>
         </msub>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>p</mi>
          <mn>1</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>p</mi>
          <mn>2</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>p</mi>
          <mn>3</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>p</mi>
          <mn>4</mn>
         </msub>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>2</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>4</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>4</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>p</mi>
         <mn>1</mn>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mn>2</mn>
         <msub>
          <mi>p</mi>
          <mn>2</mn>
         </msub>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mn>4</mn>
         <msub>
          <mi>p</mi>
          <mn>3</mn>
         </msub>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <msub>
          <mi>p</mi>
          <mn>3</mn>
         </msub>
         <mo>+</mo>
         <mrow>
          <mn>4</mn>
          <msub>
           <mi>p</mi>
           <mn>4</mn>
          </msub>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>A</ci>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <cn type="integer">3</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <cn type="integer">4</cn>
        </apply>
       </matrixrow>
      </matrix>
     </apply>
     <apply>
      <times></times>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <cn type="integer">3</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <cn type="integer">4</cn>
        </apply>
       </matrixrow>
      </matrix>
      <matrix>
       <matrixrow>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">2</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">4</cn>
        <cn type="integer">1</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">4</cn>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">4</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <cn type="integer">3</cn>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <cn type="integer">3</cn>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">4</cn>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <cn type="integer">4</cn>
         </apply>
        </apply>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\begin{bmatrix}p_{1}&p_{2}&p_{3}&p_{4}\end{bmatrix}=\begin{bmatrix}p_{1}&p_{2%
}&p_{3}&p_{4}\end{bmatrix}\begin{bmatrix}1&0&0&0\\
0&2&0&0\\
0&0&4&1\\
0&0&0&4\end{bmatrix}=\begin{bmatrix}p_{1}&2p_{2}&4p_{3}&p_{3}+4p_{4}\end{%
bmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>We see that</p>

<p>

<math display="block" id="Jordan_normal_form:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo lspace="5.3pt" stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>-</mo>
      <mrow>
       <mn>1</mn>
       <mi>I</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>p</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>A</ci>
      <apply>
       <times></times>
       <cn type="integer">1</cn>
       <ci>I</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;(A-1I)p_{1}=0
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Jordan_normal_form:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo lspace="5.3pt" stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <mi>I</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>p</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>A</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>I</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;(A-2I)p_{2}=0
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Jordan_normal_form:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo lspace="5.3pt" stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>-</mo>
      <mrow>
       <mn>4</mn>
       <mi>I</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>p</mi>
     <mn>3</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>A</ci>
      <apply>
       <times></times>
       <cn type="integer">4</cn>
       <ci>I</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;(A-4I)p_{3}=0
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Jordan_normal_form:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo lspace="5.3pt" stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mo>-</mo>
       <mrow>
        <mn>4</mn>
        <mi>I</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>p</mi>
      <mn>4</mn>
     </msub>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>p</mi>
     <mn>3</mn>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>A</ci>
      <apply>
       <times></times>
       <cn type="integer">4</cn>
       <ci>I</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;(A-4I)p_{4}=p_{3}.
  </annotation>
 </semantics>
</math>

</p>

<p>For <em>i</em> = 1,2,3 we have 

<math display="inline" id="Jordan_normal_form:11">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mo>Ker</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mi>i</mi>
       </msub>
       <mi>I</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <ci>Ker</ci>
     <apply>
      <minus></minus>
      <ci>A</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>i</ci>
       </apply>
       <ci>I</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}\in\operatorname{Ker}(A-\lambda_{i}I)
  </annotation>
 </semantics>
</math>

, i.e. <em>p</em><sub>i</sub> is an eigenvector of <em>A</em> corresponding to the eigenvalue λ<sub>i</sub>. For <em>i</em>=4, multiplying both sides by 

<math display="inline" id="Jordan_normal_form:12">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>A</mi>
    <mo>-</mo>
    <mrow>
     <mn>4</mn>
     <mi>I</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>A</ci>
    <apply>
     <times></times>
     <cn type="integer">4</cn>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A-4I)
  </annotation>
 </semantics>
</math>

 gives</p>

<p>

<math display="block" id="Jordan_normal_form:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mrow>
       <mo lspace="5.3pt" stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mo>-</mo>
        <mrow>
         <mn>4</mn>
         <mi>I</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <msub>
      <mi>p</mi>
      <mn>4</mn>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mo>-</mo>
       <mrow>
        <mn>4</mn>
        <mi>I</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>p</mi>
      <mn>3</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <ci>A</ci>
       <apply>
        <times></times>
        <cn type="integer">4</cn>
        <ci>I</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>A</ci>
      <apply>
       <times></times>
       <cn type="integer">4</cn>
       <ci>I</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;(A-4I)^{2}p_{4}=(A-4I)p_{3}.
  </annotation>
 </semantics>
</math>

 But 

<math display="inline" id="Jordan_normal_form:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>-</mo>
      <mrow>
       <mn>4</mn>
       <mi>I</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>p</mi>
     <mn>3</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>A</ci>
      <apply>
       <times></times>
       <cn type="integer">4</cn>
       <ci>I</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A-4I)p_{3}=0
  </annotation>
 </semantics>
</math>

, so</p>

<p>

<math display="block" id="Jordan_normal_form:15">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo lspace="5.3pt" stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mo>-</mo>
       <mrow>
        <mn>4</mn>
        <mi>I</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <msub>
     <mi>p</mi>
     <mn>4</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <ci>A</ci>
       <apply>
        <times></times>
        <cn type="integer">4</cn>
        <ci>I</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;(A-4I)^{2}p_{4}=0.
  </annotation>
 </semantics>
</math>

 Thus, 

<math display="inline" id="Jordan_normal_form:16">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>4</mn>
   </msub>
   <mo>∈</mo>
   <mo>Ker</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>-</mo>
     <mn>4</mn>
     <mi>I</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">4</cn>
    </apply>
    <in></in>
    <ci>Ker</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <minus></minus>
      <cn type="integer">4</cn>
      <csymbol cd="unknown">I</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{4}\in\operatorname{Ker}(A-4I)^{2}.
  </annotation>
 </semantics>
</math>

</p>

<p>Vectors such as 

<math display="inline" id="Jordan_normal_form:17">
 <semantics>
  <msub>
   <mi>p</mi>
   <mn>4</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{4}
  </annotation>
 </semantics>
</math>

 are called <a href="generalized_eigenvector" title="wikilink">generalized eigenvectors</a> of <em>A</em>.</p>

<p>Thus, given an eigenvalue λ, its corresponding Jordan block gives rise to a <strong><a href="Jordan_chain" title="wikilink">Jordan chain</a></strong>. The <strong>generator</strong>, or <strong>lead vector</strong>, say <em>p<sub>r</sub></em>, of the chain is a generalized eigenvector such that (<em>A</em> − λ <strong>I</strong>)<sup><em>r</em></sup><em>p</em><sub><em>r</em></sub> = 0, where <em>r</em> is the size of the Jordan block. The vector <em>p</em><sub>1</sub> = (<em>A</em> − λ <strong>I</strong>)<sup><em>r</em>−1</sup><em>p</em><sub><em>r</em></sub> is an eigenvector corresponding to λ. In general, <em>p</em><sub><em>i</em></sub> is a preimage of <em>p</em><sub><em>i</em>−1</sub> under <em>A</em> − λ <strong>I</strong>. So the lead vector generates the chain via multiplication by (<em>A</em> − λ <strong>I</strong>).<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>Therefore, the statement that every square matrix <em>A</em> can be put in Jordan normal form is equivalent to the claim that there exists a basis consisting only of eigenvectors and generalized eigenvectors of <em>A</em>.</p>
<h3 id="a-proof">A proof</h3>

<p>We give a proof by induction. The 1 × 1 case is trivial. Let <em>A</em> be an <em>n</em> × <em>n</em> matrix. Take any eigenvalue λ of <em>A</em>. The range of <em>A</em> − λ <strong>I</strong>, denoted by Ran(<em>A</em> − λ <strong>I</strong>), is an <a href="invariant_subspace" title="wikilink">invariant subspace</a> of <em>A</em>. Also, since λ is an eigenvalue of <em>A</em>, the dimension Ran(<em>A</em> − λ <strong>I</strong>), <em>r</em>, is strictly less than <em>n</em>. Let ''A' '' denote the restriction of <em>A</em> to Ran(<em>A</em> − λ <strong>I</strong>), By inductive hypothesis, there exists a basis {<em>p</em><sub>1</sub>, ..., <em>p</em><sub><em>r</em></sub>} such that ''A' '', expressed with respect to this basis, is in Jordan normal form.</p>

<p>Next consider the subspace Ker(<em>A</em> − λ <strong>I</strong>). If</p>

<p>

<math display="block" id="Jordan_normal_form:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>Ran</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mo>-</mo>
        <mrow>
         <mi>λ</mi>
         <mi>I</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∩</mo>
     <mrow>
      <mi>Ker</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mo>-</mo>
        <mrow>
         <mi>λ</mi>
         <mi>I</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <intersect></intersect>
     <apply>
      <times></times>
      <ci>Ran</ci>
      <apply>
       <minus></minus>
       <ci>A</ci>
       <apply>
        <times></times>
        <ci>λ</ci>
        <ci>I</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>Ker</ci>
      <apply>
       <minus></minus>
       <ci>A</ci>
       <apply>
        <times></times>
        <ci>λ</ci>
        <ci>I</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <set>
     <cn type="integer">0</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Ran}(A-\lambda I)\cap\mathrm{Ker}(A-\lambda I)=\{0\},
  </annotation>
 </semantics>
</math>

</p>

<p>the desired result follows immediately from the <a href="rank–nullity_theorem" title="wikilink">rank–nullity theorem</a>. This would be the case, for example, if <em>A</em> was Hermitian.</p>

<p>Otherwise, if</p>

<p>

<math display="block" id="Jordan_normal_form:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>Ran</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mo>-</mo>
        <mrow>
         <mi>λ</mi>
         <mi>I</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∩</mo>
     <mrow>
      <mi>Ker</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mo>-</mo>
        <mrow>
         <mi>λ</mi>
         <mi>I</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>≠</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>Q</ci>
     <apply>
      <intersect></intersect>
      <apply>
       <times></times>
       <ci>Ran</ci>
       <apply>
        <minus></minus>
        <ci>A</ci>
        <apply>
         <times></times>
         <ci>λ</ci>
         <ci>I</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>Ker</ci>
       <apply>
        <minus></minus>
        <ci>A</ci>
        <apply>
         <times></times>
         <ci>λ</ci>
         <ci>I</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <neq></neq>
     <share href="#.cmml">
     </share>
     <set>
      <cn type="integer">0</cn>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=\mathrm{Ran}(A-\lambda I)\cap\mathrm{Ker}(A-\lambda I)\neq\{0\},
  </annotation>
 </semantics>
</math>

</p>

<p>let the dimension of <em>Q</em> be <em>s</em> ≤ <em>r</em>. Each vector in <em>Q</em> is an eigenvector of ''A' '' corresponding to eigenvalue <em>λ</em>. So the Jordan form of ''A' '' must contain <em>s</em> Jordan chains corresponding to <em>s</em> linearly independent eigenvectors. So the basis {<em>p</em><sub>1</sub>, ..., <em>p</em><sub><em>r</em></sub>} must contain <em>s</em> vectors, say {<em>p</em><sub><em>r</em>−<em>s</em>+1</sub>, ..., <em>p</em><sub><em>r</em></sub>}, that are lead vectors in these Jordan chains from the Jordan normal form of <em>A</em>'. We can "extend the chains" by taking the preimages of these lead vectors. (This is the key step of argument; in general, generalized eigenvectors need not lie in Ran(<em>A</em> − λ <strong>I</strong>).) Let <em>q</em><sub><em>i</em></sub> be such that</p>

<p>

<math display="block" id="Jordan_normal_form:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo lspace="5.3pt" stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mo>-</mo>
        <mrow>
         <mi>λ</mi>
         <mi>I</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>q</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>i</mi>
      </msub>
      <mtext>for</mtext>
      <mi>i</mi>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mi>r</mi>
       <mo>-</mo>
       <mi>s</mi>
      </mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>r</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <ci>A</ci>
        <apply>
         <times></times>
         <ci>λ</ci>
         <ci>I</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>q</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
       <mtext>for</mtext>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <ci>r</ci>
        <ci>s</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <list>
     <ci>normal-…</ci>
     <ci>r</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;(A-\lambda I)q_{i}=p_{i}\mbox{ for }i=r-s+1,\ldots,r.
  </annotation>
 </semantics>
</math>

</p>

<p>Clearly no non-trivial linear combination of the <em>q</em><sub><em>i</em></sub> can lie in Ker(<em>A</em> − λ I). Furthermore, no non-trivial linear combination of the <em>q</em><sub><em>i</em></sub> can be in Ran(<em>A</em> − λ <strong>I</strong>), for that would contradict the assumption that each <em>p<sub>i</sub></em> is a lead vector in a Jordan chain. The set {<em>q</em><sub><em>i</em></sub>}, being preimages of the linearly independent set {<em>p</em><sub><em>i</em></sub>} under <em>A</em> − λ <strong>I</strong>, is also linearly independent.</p>

<p>Finally, we can pick any linearly independent set {<em>z</em><sub><em>1</em></sub>, ..., <em>z</em><sub><em>t</em></sub>} that spans</p>

<p>

<math display="block" id="Jordan_normal_form:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded lspace="2.8pt" width="+2.8pt">
      <mi>Ker</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mo>-</mo>
       <mrow>
        <mi>λ</mi>
        <mi>I</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mi>Q</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>Ker</ci>
     <apply>
      <minus></minus>
      <ci>A</ci>
      <apply>
       <times></times>
       <ci>λ</ci>
       <ci>I</ci>
      </apply>
     </apply>
    </apply>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;\mathrm{Ker}(A-\lambda I)/Q.
  </annotation>
 </semantics>
</math>

</p>

<p>By construction, the union of the three sets {<em>p</em><sub>1</sub>, ..., <em>p</em><sub><em>r</em></sub>}, {<em>q</em><sub><em>r</em>−<em>s</em> +1</sub>, ..., <em>q</em><sub><em>r</em></sub>}, and {<em>z</em><sub>1</sub>, ..., <em>z</em><sub><em>t</em></sub>} is linearly independent. Each vector in the union is either an eigenvector or a generalized eigenvector of <em>A</em>. Finally, by rank–nullity theorem, the cardinality of the union is <em>n</em>. In other words, we have found a basis that consists of eigenvectors and generalized eigenvectors of <em>A</em>, and this shows <em>A</em> can be put in Jordan normal form.</p>
<h3 id="uniqueness">Uniqueness</h3>

<p>It can be shown that the Jordan normal form of a given matrix <em>A</em> is unique up to the order of the Jordan blocks.</p>

<p>Knowing the algebraic and geometric multiplicities of the eigenvalues is not sufficient to determine the Jordan normal form of <em>A</em>. Assuming the algebraic multiplicity <em>m</em>(λ) of an eigenvalue λ is known, the structure of the Jordan form can be ascertained by analyzing the ranks of the powers (<em>A</em> − λ I)<sup><em>m</em>(λ)</sup>. To see this, suppose an <em>n</em> × <em>n</em> matrix <em>A</em> has only one eigenvalue λ. So <em>m</em>(λ) = <em>n</em>. The smallest integer <em>k</em><sub>1</sub> such that</p>

<p>

<math display="block" id="Jordan_normal_form:22">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>-</mo>
      <mrow>
       <mi>λ</mi>
       <mi>I</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>k</mi>
     <mn>1</mn>
    </msub>
   </msup>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <ci>A</ci>
      <apply>
       <times></times>
       <ci>λ</ci>
       <ci>I</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A-\lambda I)^{k_{1}}=0
  </annotation>
 </semantics>
</math>

</p>

<p>is the size of the largest Jordan block in the Jordan form of <em>A</em>. (This number <em>k</em><sub>1</sub> is also called the <strong>index</strong> of λ. See discussion in a following section.) The rank of</p>

<p>

<math display="block" id="Jordan_normal_form:23">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mo>-</mo>
     <mrow>
      <mi>λ</mi>
      <mi>I</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <msub>
     <mi>k</mi>
     <mn>1</mn>
    </msub>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <minus></minus>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>I</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A-\lambda I)^{k_{1}-1}
  </annotation>
 </semantics>
</math>

</p>

<p>is the number of Jordan blocks of size <em>k</em><sub>1</sub>. Similarly, the rank of</p>

<p>

<math display="block" id="Jordan_normal_form:24">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mo>-</mo>
     <mrow>
      <mi>λ</mi>
      <mi>I</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <msub>
     <mi>k</mi>
     <mn>1</mn>
    </msub>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <minus></minus>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>I</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A-\lambda I)^{k_{1}-2}
  </annotation>
 </semantics>
</math>

</p>

<p>is twice the number of Jordan blocks of size <em>k</em><sub>1</sub> plus the number of Jordan blocks of size <em>k</em><sub>1</sub>−1. The general case is similar.</p>

<p>This can be used to show the uniqueness of the Jordan form. Let <em>J</em><sub>1</sub> and <em>J</em><sub>2</sub> be two Jordan normal forms of <em>A</em>. Then <em>J</em><sub>1</sub> and <em>J</em><sub>2</sub> are similar and have the same spectrum, including algebraic multiplicities of the eigenvalues. The procedure outlined in the previous paragraph can be used to determine the structure of these matrices. Since the rank of a matrix is preserved by similarity transformation, there is a bijection between the Jordan blocks of <em>J</em><sub>1</sub> and <em>J</em><sub>2</sub>. This proves the uniqueness part of the statement.</p>
<h2 id="real-matrices">Real matrices</h2>

<p>If <em>A</em> is a real matrix, its Jordan form can still be non-real, however there exists a real invertible matrix <em>P</em> such that <em>P<sup>−1</sup>AP</em> = <em>J</em> is a real <a href="block_diagonal_matrix" title="wikilink">block diagonal matrix</a> with each block being a real Jordan block. A real Jordan block is either identical to a complex Jordan block (if the corresponding eigenvalue 

<math display="inline" id="Jordan_normal_form:25">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{i}
  </annotation>
 </semantics>
</math>

 is real), or is a block matrix itself, consisting of 2×2 blocks as follows (for non-real eigenvalue 

<math display="inline" id="Jordan_normal_form:26">
 <semantics>
  <mrow>
   <msub>
    <mi>λ</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi>i</mi>
     <msub>
      <mi>b</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{i}=a_{i}+ib_{i}
  </annotation>
 </semantics>
</math>

). The diagonal blocks are identical, of the form</p>

<p>

<math display="block" id="Jordan_normal_form:27">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mi>i</mi>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>b</mi>
        <mi>i</mi>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <msub>
         <mi>b</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mi>i</mi>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>i</ci>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>i</ci>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}=\begin{bmatrix}a_{i}&b_{i}\\
-b_{i}&a_{i}\\
\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>and describe multiplication by 

<math display="inline" id="Jordan_normal_form:28">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{i}
  </annotation>
 </semantics>
</math>

 in the complex plane. The superdiagonal blocks are 2×2 identity matrices. The full real Jordan block is given by</p>

<p>

<math display="block" id="Jordan_normal_form:29">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>J</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>C</mi>
         <mi>i</mi>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <mi>I</mi>
       </mtd>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>C</mi>
         <mi>i</mi>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋱</mi>
       </mtd>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋱</mi>
       </mtd>
       <mtd columnalign="center">
        <mi>I</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>C</mi>
         <mi>i</mi>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>J</ci>
     <ci>i</ci>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>i</ci>
      </apply>
      <ci>I</ci>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">absent</csymbol>
     </matrixrow>
     <matrixrow>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-⋱</ci>
      <csymbol cd="latexml">absent</csymbol>
     </matrixrow>
     <matrixrow>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <ci>normal-⋱</ci>
      <ci>I</ci>
     </matrixrow>
     <matrixrow>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>i</ci>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J_{i}=\begin{bmatrix}C_{i}&I&&\\
&C_{i}&\ddots&\\
&&\ddots&I\\
&&&C_{i}\\
\end{bmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>This real Jordan form is a consequence of the complex Jordan form. For a real matrix the nonreal eigenvectors and generalized eigenvectors can always be chosen to form <a href="complex_conjugate" title="wikilink">complex conjugate</a> pairs. Taking the real and imaginary part (linear combination of the vector and its conjugate), the matrix has this form with respect to the new basis.</p>
<h2 id="consequences">Consequences</h2>

<p>One can see that the Jordan normal form is essentially a classification result for square matrices, and as such several important results from linear algebra can be viewed as its consequences.</p>
<h3 id="spectral-mapping-theorem">Spectral mapping theorem</h3>

<p>Using the Jordan normal form, direct calculation gives a spectral mapping theorem for the <a href="functional_calculus" title="wikilink">polynomial functional calculus</a>: Let <em>A</em> be an <em>n</em> × <em>n</em> matrix with eigenvalues λ<sub>1</sub>, ..., λ<sub><em>n</em></sub>, then for any polynomial <em>p</em>, <em>p</em>(<em>A</em>) has eigenvalues <em>p</em>(λ<sub>1</sub>), ..., <em>p</em>(λ<sub><em>n</em></sub>).</p>
<h3 id="cayleyhamilton-theorem">Cayley–Hamilton theorem</h3>

<p>The <a href="Cayley–Hamilton_theorem" title="wikilink">Cayley–Hamilton theorem</a> asserts that every matrix <em>A</em> satisfies its characteristic equation: if 

<math display="inline" id="Jordan_normal_form:30">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is the <a href="characteristic_polynomial" title="wikilink">characteristic polynomial</a> of 

<math display="inline" id="Jordan_normal_form:31">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Jordan_normal_form:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>A</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(A)=0
  </annotation>
 </semantics>
</math>

. This can be shown via direct calculation in the Jordan form, since any Jordan block for 

<math display="inline" id="Jordan_normal_form:33">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 is annihilated by <mtpl></mtpl> where 

<math display="inline" id="Jordan_normal_form:34">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 is the multiplicity of the root 

<math display="inline" id="Jordan_normal_form:35">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Jordan_normal_form:36">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, the sum of the sizes of the Jordan blocks for 

<math display="inline" id="Jordan_normal_form:37">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

, and therefore no less than the size of the block in question. The Jordan form can be assumed to exist over a field extending the base field of the matrix, for instance over the <a href="splitting_field" title="wikilink">splitting field</a> of 

<math display="inline" id="Jordan_normal_form:38">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

; this field extension does not change the matrix 

<math display="inline" id="Jordan_normal_form:39">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(A)
  </annotation>
 </semantics>
</math>

 in any way.</p>
<h3 id="minimal-polynomial">Minimal polynomial</h3>

<p>The <a href="Minimal_polynomial_(linear_algebra)" title="wikilink">minimal polynomial</a> P of a square matrix <em>A</em> is the unique <a href="monic_polynomial" title="wikilink">monic polynomial</a> of least degree, <em>m</em>, such that <em>P</em>(<em>A</em>) = 0. Alternatively, the set of polynomials that annihilate a given <em>A</em> form an ideal <em>I</em> in <em>C</em>[<em>x</em>], the <a href="principal_ideal_domain" title="wikilink">principal ideal domain</a> of polynomials with complex coefficients. The monic element that generates <em>I</em> is precisely <em>P</em>.</p>

<p>Let λ<sub>1</sub>, ..., λ<sub><em>q</em></sub> be the distinct eigenvalues of <em>A</em>, and <em>s</em><sub><em>i</em></sub> be the size of the largest Jordan block corresponding to λ<sub><em>i</em></sub>. It is clear from the Jordan normal form that the minimal polynomial of <em>A</em> has degree 

<math display="inline" id="Jordan_normal_form:40">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Σ
  </annotation>
 </semantics>
</math>

<em>s</em><sub><em>i</em></sub>.</p>

<p>While the Jordan normal form determines the minimal polynomial, the converse is not true. This leads to the notion of <strong>elementary divisors</strong>. The elementary divisors of a square matrix <em>A</em> are the characteristic polynomials of its Jordan blocks. The factors of the minimal polynomial <em>m</em> are the elementary divisors of the largest degree corresponding to distinct eigenvalues.</p>

<p>The degree of an elementary divisor is the size of the corresponding Jordan block, therefore the dimension of the corresponding invariant subspace. If all elementary divisors are linear, <em>A</em> is diagonalizable.</p>
<h3 id="invariant-subspace-decompositions">Invariant subspace decompositions</h3>

<p>The Jordan form of a <em>n</em> × <em>n</em> matrix <em>A</em> is block diagonal, and therefore gives a decomposition of the <em>n</em> dimensional Euclidean space into <a href="invariant_subspace" title="wikilink">invariant subspaces</a> of <em>A</em>. Every Jordan block <em>J</em><sub><em>i</em></sub> corresponds to an invariant subspace <em>X</em><sub><em>i</em></sub>. Symbolically, we put</p>

<p>

<math display="block" id="Jordan_normal_form:41">
 <semantics>
  <mrow>
   <msup>
    <mi>ℂ</mi>
    <mi>n</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>k</mi>
    </munderover>
    <msub>
     <mi>X</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℂ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">direct-sum</csymbol>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}^{n}=\bigoplus_{i=1}^{k}X_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>where each <em>X</em><sub><em>i</em></sub> is the span of the corresponding Jordan chain, and <em>k</em> is the number of Jordan chains.</p>

<p>One can also obtain a slightly different decomposition via the Jordan form. Given an eigenvalue λ<sub><em>i</em></sub>, the size of its largest corresponding Jordan block <em>s</em><sub>i</sub> is called the <strong>index</strong> of λ<sub><em>i</em></sub> and denoted by ν(λ<sub><em>i</em></sub>). (Therefore the degree of the minimal polynomial is the sum of all indices.) Define a subspace <em>Y</em><sub><em>i</em></sub> by</p>

<p>

<math display="block" id="Jordan_normal_form:42">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="2.8pt" width="+2.8pt">
     <mi>Y</mi>
    </mpadded>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mo>Ker</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>λ</mi>
      <mi>i</mi>
     </msub>
     <mi>I</mi>
     <mo>-</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>ν</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>λ</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Y</ci>
     <ci>i</ci>
    </apply>
    <eq></eq>
    <ci>Ker</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>i</ci>
      </apply>
      <csymbol cd="unknown">I</csymbol>
      <minus></minus>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <times></times>
      <ci>ν</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;Y_{i}=\operatorname{Ker}(\lambda_{i}I-A)^{\nu(\lambda_{i})}.
  </annotation>
 </semantics>
</math>

</p>

<p>This gives the decomposition</p>

<p>

<math display="block" id="Jordan_normal_form:43">
 <semantics>
  <mrow>
   <msup>
    <mi>ℂ</mi>
    <mi>n</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>l</mi>
    </munderover>
    <msub>
     <mi>Y</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℂ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">direct-sum</csymbol>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>l</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}^{n}=\bigoplus_{i=1}^{l}Y_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>l</em> is the number of distinct eigenvalues of <em>A</em>. Intuitively, we glob together the Jordan block invariant subspaces corresponding to the same eigenvalue. In the extreme case where <em>A</em> is a multiple of the identity matrix we have <em>k</em> = <em>n</em> and <em>l</em> = 1.</p>

<p>The projection onto <em>Y<sub>i</sub></em> and along all the other <em>Y<sub>j</sub></em> ( <em>j</em> ≠ <em>i</em> ) is called <strong>the spectral projection of <em>A</em> at λ<sub><em>i</em></sub></strong> and is usually denoted by <strong><em>P</em>(λ<sub><em>i</em></sub> ; <em>A</em>)</strong>. Spectral projections are mutually orthogonal in the sense that <em>P</em>(λ<sub><em>i</em></sub> ; <em>A</em>) <em>P</em>(λ<sub><em>j</em></sub> ; <em>A</em>) = 0 if <em>i</em> ≠ <em>j</em>. Also they commute with <em>A</em> and their sum is the identity matrix. Replacing every λ<sub><em>i</em></sub> in the Jordan matrix <em>J</em> by one and zeroising all other entries gives <em>P</em>(λ<sub><em>i</em></sub> ; <em>J</em>), moreover if <em>U J U</em><sup>−1</sup> is the similarity transformation such that <em>A</em> = <em>U J U</em><sup>−1</sup> then <em>P</em>(λ<sub><em>i</em></sub> ; <em>A</em>) = <em>U P</em>(λ<sub><em>i</em></sub> ; <em>J</em>) <em>U</em><sup>−1</sup>. They are not confined to finite dimensions. See below for their application to compact operators, and in <a href="holomorphic_functional_calculus" title="wikilink">holomorphic functional calculus</a> for a more general discussion.</p>

<p>Comparing the two decompositions, notice that, in general, <em>l</em> ≤ <em>k</em>. When <em>A</em> is normal, the subspaces <em>X</em><sub><em>i</em></sub>'s in the first decomposition are one-dimensional and mutually orthogonal. This is the <a href="spectral_theorem" title="wikilink">spectral theorem</a> for normal operators. The second decomposition generalizes more easily for general compact operators on Banach spaces.</p>

<p>It might be of interest here to note some properties of the index, ν(<em>λ</em>). More generally, for a complex number λ, its index can be defined as the least non-negative integer ν(λ) such that</p>

<p>

<math display="block" id="Jordan_normal_form:44">
 <semantics>
  <mrow>
   <mi>Ker</mi>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo>-</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>ν</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mo>=</mo>
   <mo>Ker</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo>-</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>m</mi>
   </msup>
   <mo rspace="5.3pt">,</mo>
   <mo>∀</mo>
   <mi>m</mi>
   <mo>≥</mo>
   <mi>ν</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Ker</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <minus></minus>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <times></times>
      <ci>ν</ci>
      <ci>λ</ci>
     </apply>
    </apply>
    <eq></eq>
    <ci>Ker</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <minus></minus>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>m</ci>
    </apply>
    <ci>normal-,</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">m</csymbol>
    <geq></geq>
    <csymbol cd="unknown">ν</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Ker}(\lambda-A)^{\nu(\lambda)}=\operatorname{Ker}(\lambda-A)^{m},\;%
\forall m\geq\nu(\lambda).
  </annotation>
 </semantics>
</math>

</p>

<p>So ν(λ) &gt; 0 if and only if λ is an eigenvalue of <em>A</em>. In the finite-dimensional case, ν(λ) ≤ the algebraic multiplicity of λ.</p>
<h2 id="generalizations">Generalizations</h2>
<h3 id="matrices-with-entries-in-a-field">Matrices with entries in a field</h3>

<p>Jordan reduction can be extended to any square matrix <em>M</em> whose entries lie in a <a href="field_(mathematics)" title="wikilink">field</a> <em>K</em>. The result states that any <em>M</em> can be written as a sum <em>D</em> + <em>N</em> where <em>D</em> is <a href="semisimple_operator" title="wikilink">semisimple</a>, <em>N</em> is <a href="nilpotent_matrix" title="wikilink">nilpotent</a>, and <em>DN</em> = <em>ND</em>. This is called the <a href="Jordan–Chevalley_decomposition" title="wikilink">Jordan–Chevalley decomposition</a>. Whenever <em>K</em> contains the eigenvalues of <em>M</em>, in particular when <em>K</em> is <a href="algebraically_closed" title="wikilink">algebraically closed</a>, the normal form can be expressed explicitly as the <a href="direct_sum" title="wikilink">direct sum</a> of Jordan blocks.</p>

<p>Similar to the case when <em>K</em> is the complex numbers, knowing the dimensions of the kernels of (<em>M</em> − λ<em>I</em>)<sup><em>k</em></sup> for 1 ≤ <em>k</em> ≤ <em>m</em>, where <em>m</em> is the <a href="algebraic_multiplicity" title="wikilink">algebraic multiplicity</a> of the eigenvalue λ, allows one to determine the Jordan form of <em>M</em>. We may view the underlying vector space <em>V</em> as a <em>K</em>[<em>x</em>]-<a href="module_(mathematics)" title="wikilink">module</a> by regarding the action of <em>x</em> on <em>V</em> as application of <em>M</em> and extending by <em>K</em>-linearity. Then the polynomials (<em>x</em> − λ)<sup><em>k</em></sup> are the elementary divisors of <em>M</em>, and the Jordan normal form is concerned with representing <em>M</em> in terms of blocks associated to the elementary divisors.</p>

<p>The proof of the Jordan normal form is usually carried out as an application to the <a href="ring_(mathematics)" title="wikilink">ring</a> <em>K</em>[<em>x</em>] of the <a href="structure_theorem_for_finitely_generated_modules_over_a_principal_ideal_domain" title="wikilink">structure theorem for finitely generated modules over a principal ideal domain</a>, of which it is a corollary.</p>
<h3 id="compact-operators">Compact operators</h3>

<p>In a different direction, for <a href="compact_operator" title="wikilink">compact operators</a> on a <a href="Banach_space" title="wikilink">Banach space</a>, a result analogous to the Jordan normal form holds. One restricts to compact operators because every point <em>x</em> in the spectrum of a compact operator <em>T</em>, the only exception being when <em>x</em> is the limit point of the spectrum, is an eigenvalue. This is not true for bounded operators in general. To give some idea of this generalization, we first reformulate the Jordan decomposition in the language of functional analysis.</p>
<h4 id="holomorphic-functional-calculus">Holomorphic functional calculus</h4>

<p>Let <em>X</em> be a Banach space, <em>L</em>(<em>X</em>) be the bounded operators on <em>X</em>, and σ(<em>T</em>) denote the <a href="spectrum_(functional_analysis)" title="wikilink">spectrum</a> of <em>T</em> ∈ <em>L</em>(<em>X</em>). The <a href="holomorphic_functional_calculus" title="wikilink">holomorphic functional calculus</a> is defined as follows:</p>

<p>Fix a bounded operator <em>T</em>. Consider the family Hol(<em>T</em>) of complex functions that is <a href="Holomorphic_function" title="wikilink">holomorphic</a> on some open set <em>G</em> containing σ(<em>T</em>). Let Γ = {γ<sub><em>i</em></sub>} be a finite collection of <a href="Jordan_curve" title="wikilink">Jordan curves</a> such that σ(<em>T</em>) lies in the <em>inside</em> of Γ, we define <em>f</em>(<em>T</em>) by</p>

<p>

<math display="block" id="Jordan_normal_form:45">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
       <mi>i</mi>
      </mrow>
     </mfrac>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∫</mo>
       <mi mathvariant="normal">Γ</mi>
      </msub>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>z</mi>
          <mo>-</mo>
          <mi>T</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mi>d</mi>
       <mi>z</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Γ</ci>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>z</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>z</ci>
         <ci>T</ci>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>d</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(T)=\frac{1}{2\pi i}\int_{\Gamma}f(z)(z-T)^{-1}dz.
  </annotation>
 </semantics>
</math>

</p>

<p>The open set <em>G</em> could vary with <em>f</em> and need not be connected. The integral is defined as the limit of the Riemann sums, as in the scalar case. Although the integral makes sense for continuous <em>f</em>, we restrict to holomorphic functions to apply the machinery from classical function theory (e.g. the Cauchy integral formula). The assumption that σ(<em>T</em>) lie in the inside of Γ ensures <em>f</em>(<em>T</em>) is well defined; it does not depend on the choice of Γ. The functional calculus is the mapping Φ from Hol(<em>T</em>) to <em>L</em>(<em>X</em>) given by</p>

<p>

<math display="block" id="Jordan_normal_form:46">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded lspace="2.8pt" width="+2.8pt">
      <mi mathvariant="normal">Φ</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;\Phi(f)=f(T).
  </annotation>
 </semantics>
</math>

</p>

<p>We will require the following properties of this functional calculus:</p>
<ol>
<li>Φ extends the polynomial functional calculus.</li>
<li>The <em>spectral mapping theorem</em> holds: σ(<em>f</em>(<em>T</em>)) = <em>f</em>(σ(<em>T</em>)).</li>
<li>Φ is an algebra homomorphism.</li>
</ol>
<h4 id="the-finite-dimensional-case">The finite-dimensional case</h4>

<p>In the finite-dimensional case, σ(<em>T</em>) = {λ<sub><em>i</em></sub>} is a finite discrete set in the complex plane. Let <em>e</em><sub><em>i</em></sub> be the function that is 1 in some open neighborhood of λ<sub><em>i</em></sub> and 0 elsewhere. By property 3 of the functional calculus, the operator</p>

<p>

<math display="block" id="Jordan_normal_form:47">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="2.8pt" width="+2.8pt">
     <mi>e</mi>
    </mpadded>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <ci>i</ci>
    </apply>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;e_{i}(T)
  </annotation>
 </semantics>
</math>

</p>

<p>is a projection. Moreoever, let ν<sub><em>i</em></sub> be the index of λ<sub><em>i</em></sub> and</p>

<p>

<math display="block" id="Jordan_normal_form:48">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>z</mi>
       <mo>-</mo>
       <msub>
        <mi>λ</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>ν</mi>
      <mi>i</mi>
     </msub>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <ci>z</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ν</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(z)=(z-\lambda_{i})^{\nu_{i}}.
  </annotation>
 </semantics>
</math>

</p>

<p>The spectral mapping theorem tells us</p>

<p>

<math display="block" id="Jordan_normal_form:49">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>e</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>T</mi>
       <mo>-</mo>
       <msub>
        <mi>λ</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>ν</mi>
      <mi>i</mi>
     </msub>
    </msup>
    <msub>
     <mi>e</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>T</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>i</ci>
     </apply>
     <ci>T</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <ci>T</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ν</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>i</ci>
     </apply>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(T)e_{i}(T)=(T-\lambda_{i})^{\nu_{i}}e_{i}(T)
  </annotation>
 </semantics>
</math>

</p>

<p>has spectrum {0}. By property 1, <em>f</em>(<em>T</em>) can be directly computed in the Jordan form, and by inspection, we see that the operator <em>f</em>(<em>T</em>)<em>e<sub>i</sub></em>(<em>T</em>) is the zero matrix.</p>

<p>By property 3, <em>f</em>(<em>T</em>) <em>e</em><sub><em>i</em></sub>(<em>T</em>) = <em>e</em><sub><em>i</em></sub>(<em>T</em>) <em>f</em>(<em>T</em>). So <em>e</em><sub><em>i</em></sub>(<em>T</em>) is precisely the projection onto the subspace</p>

<p>

<math display="block" id="Jordan_normal_form:50">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+2.8pt">
      <mi>Ran</mi>
     </mpadded>
     <msub>
      <mi>e</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>Ker</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>T</mi>
        <mo>-</mo>
        <msub>
         <mi>λ</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>ν</mi>
       <mi>i</mi>
      </msub>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Ran</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>i</ci>
     </apply>
     <ci>T</ci>
    </apply>
    <apply>
     <times></times>
     <ci>Ker</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <ci>T</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ν</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Ran}\;e_{i}(T)=\mathrm{Ker}(T-\lambda_{i})^{\nu_{i}}.
  </annotation>
 </semantics>
</math>

</p>

<p>The relation</p>

<p>

<math display="block" id="Jordan_normal_form:51">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo largeop="true" lspace="5.3pt" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <msub>
     <mi>e</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;\sum_{i}e_{i}=1
  </annotation>
 </semantics>
</math>

</p>

<p>implies</p>

<p>

<math display="block" id="Jordan_normal_form:52">
 <semantics>
  <mrow>
   <msup>
    <mi>ℂ</mi>
    <mi>n</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <mpadded width="+2.8pt">
     <munder>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
      <mi>i</mi>
     </munder>
    </mpadded>
    <mrow>
     <mpadded width="+2.8pt">
      <mi>Ran</mi>
     </mpadded>
     <msub>
      <mi>e</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+2.8pt">
     <munder>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
      <mi>i</mi>
     </munder>
    </mpadded>
    <mrow>
     <mi>Ker</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>T</mi>
        <mo>-</mo>
        <msub>
         <mi>λ</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>ν</mi>
       <mi>i</mi>
      </msub>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℂ</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">direct-sum</csymbol>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <ci>Ran</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <ci>i</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">direct-sum</csymbol>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <ci>Ker</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>T</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>λ</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ν</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}^{n}=\bigoplus_{i}\;\mathrm{Ran}\;e_{i}(T)=\bigoplus_{i}\;\mathrm{%
Ker}(T-\lambda_{i})^{\nu_{i}}
  </annotation>
 </semantics>
</math>

</p>

<p>where the index <em>i</em> runs through the distinct eigenvalues of <em>T</em>. This is exactly the invariant subspace decomposition</p>

<p>

<math display="block" id="Jordan_normal_form:53">
 <semantics>
  <mrow>
   <msup>
    <mi>ℂ</mi>
    <mi>n</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
     <mi>i</mi>
    </munder>
    <msub>
     <mi>Y</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℂ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}^{n}=\bigoplus_{i}Y_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>given in a previous section. Each <em>e<sub>i</sub></em>(<em>T</em>) is the projection onto the subspace spanned by the Jordan chains corresponding to λ<sub><em>i</em></sub> and along the subspaces spanned by the Jordan chains corresponding to λ<sub><em>j</em></sub> for <em>j</em> ≠ <em>i</em>. In other words <em>e<sub>i</sub></em>(<em>T</em>) = <em>P</em>(λ<sub><em>i</em></sub>;<em>T</em>). This explicit identification of the operators <em>e<sub>i</sub></em>(<em>T</em>) in turn gives an explicit form of holomorphic functional calculus for matrices:</p>
<dl>
<dd>For all <em>f</em> ∈ Hol(<em>T</em>),
</dd>
</dl>

<p>

<math display="block" id="Jordan_normal_form:54">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mi>i</mi>
       </msub>
       <mo>∈</mo>
       <mrow>
        <mi>σ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>T</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>k</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mrow>
        <msub>
         <mi>ν</mi>
         <mi>i</mi>
        </msub>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </munderover>
      <mrow>
       <mfrac>
        <msup>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>k</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </msup>
        <mrow>
         <mi>k</mi>
         <mo lspace="0pt" rspace="3.5pt">!</mo>
        </mrow>
       </mfrac>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>T</mi>
          <mo>-</mo>
          <msub>
           <mi>λ</mi>
           <mi>i</mi>
          </msub>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>k</mi>
       </msup>
       <msub>
        <mi>e</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>T</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <times></times>
        <ci>σ</ci>
        <ci>T</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ν</ci>
         <ci>i</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <factorial></factorial>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>T</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>λ</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <ci>i</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(T)=\sum_{\lambda_{i}\in\sigma(T)}\sum_{k=0}^{\nu_{i}-1}\frac{f^{(k)}}{k!}(T-%
\lambda_{i})^{k}e_{i}(T).
  </annotation>
 </semantics>
</math>

</p>

<p>Notice that the expression of <em>f</em>(<em>T</em>) is a finite sum because, on each neighborhood of λ<sub><em>i</em></sub>, we have chosen the Taylor series expansion of <em>f</em> centered at λ<sub><em>i</em></sub>.</p>
<h4 id="poles-of-an-operator">Poles of an operator</h4>

<p>Let <em>T</em> be a bounded operator λ be an isolated point of σ(<em>T</em>). (As stated above, when <em>T</em> is compact, every point in its spectrum is an isolated point, except possibly the limit point 0.)</p>

<p>The point λ is called a <strong>pole</strong> of operator <em>T</em> with order ν if the <a href="Resolvent_formalism" title="wikilink">resolvent</a> function <em>R</em><sub><em>T</em></sub> defined by</p>

<p>

<math display="block" id="Jordan_normal_form:55">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mpadded lspace="2.8pt" width="+2.8pt">
      <mi>R</mi>
     </mpadded>
     <mi>T</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>λ</mi>
      <mo>-</mo>
      <mi>T</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>T</ci>
     </apply>
     <ci>λ</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <ci>λ</ci>
      <ci>T</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;R_{T}(\lambda)=(\lambda-T)^{-1}
  </annotation>
 </semantics>
</math>

</p>

<p>has a <a href="pole_(complex_analysis)" title="wikilink">pole</a> of order ν at λ.</p>

<p>We will show that, in the finite-dimensional case, the order of an eigenvalue coincides with its index. The result also holds for compact operators.</p>

<p>Consider the annular region <em>A</em> centered at the eigenvalue λ with sufficiently small radius ε such that the intersection of the open disc <em>B</em><sub>ε</sub>(λ) and σ(<em>T</em>) is {λ}. The resolvent function <em>R</em><sub><em>T</em></sub> is holomorphic on <em>A</em>. Extending a result from classical function theory, <em>R</em><sub><em>T</em></sub> has a <a href="Laurent_series" title="wikilink">Laurent series</a> representation on <em>A</em>:</p>

<p>

<math display="block" id="Jordan_normal_form:56">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>R</mi>
     <mi>T</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mo>-</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>m</mi>
     </msub>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>λ</mi>
        <mo>-</mo>
        <mi>z</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>m</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>T</ci>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <ci>λ</ci>
        <ci>z</ci>
       </apply>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{T}(z)=\sum_{-\infty}^{\infty}a_{m}(\lambda-z)^{m}
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="Jordan_normal_form:57">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mrow>
     <mo>-</mo>
     <mi>m</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
       <mi>i</mi>
      </mrow>
     </mfrac>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∫</mo>
       <mi>C</mi>
      </msub>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>λ</mi>
          <mo>-</mo>
          <mi>z</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mi>m</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>z</mi>
          <mo>-</mo>
          <mi>T</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mi>d</mi>
       <mi>z</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <minus></minus>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <ci>C</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <minus></minus>
          <ci>λ</ci>
          <ci>z</ci>
         </apply>
         <apply>
          <minus></minus>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <minus></minus>
          <ci>z</ci>
          <ci>T</ci>
         </apply>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>d</ci>
        <ci>z</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{-m}=-\frac{1}{2\pi i}\int_{C}(\lambda-z)^{m-1}(z-T)^{-1}dz
  </annotation>
 </semantics>
</math>

 and <em>C</em> is a small circle centered at λ.</p>

<p>By the previous discussion on the functional calculus,</p>

<p>

<math display="block" id="Jordan_normal_form:58">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="2.8pt" width="+2.8pt">
     <mi>a</mi>
    </mpadded>
    <mrow>
     <mo>-</mo>
     <mi>m</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>λ</mi>
        <mo>-</mo>
        <mi>T</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mi>m</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <msub>
      <mi>e</mi>
      <mi>λ</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <minus></minus>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <ci>λ</ci>
        <ci>T</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>λ</ci>
      </apply>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;a_{-m}=-(\lambda-T)^{m-1}e_{\lambda}(T)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Jordan_normal_form:59">
 <semantics>
  <msub>
   <mpadded lspace="2.8pt" width="+2.8pt">
    <mi>e</mi>
   </mpadded>
   <mi>λ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <ci>λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;e_{\lambda}
  </annotation>
 </semantics>
</math>

 is 1 on 

<math display="inline" id="Jordan_normal_form:60">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="2.8pt" width="+2.8pt">
     <mi>B</mi>
    </mpadded>
    <mi>ϵ</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>ϵ</ci>
    </apply>
    <ci>λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;B_{\epsilon}(\lambda)
  </annotation>
 </semantics>
</math>

 and 0 elsewhere.</p>

<p>But we have shown that the smallest positive integer <em>m</em> such that</p>

<p>

<math display="block" id="Jordan_normal_form:61">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mrow>
     <mo>-</mo>
     <mi>m</mi>
    </mrow>
   </msub>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <minus></minus>
      <ci>m</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{-m}\neq 0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Jordan_normal_form:62">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mrow>
     <mo>-</mo>
     <mi>l</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5.6pt">
     <mn>0</mn>
    </mpadded>
    <mrow>
     <mo rspace="5.3pt">∀</mo>
     <mi>l</mi>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <ci>l</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>l</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{-l}=0\;\;\forall\;l\geq m
  </annotation>
 </semantics>
</math>

</p>

<p>is precisely the index of λ, ν(λ). In other words, the function <em>R</em><sub><em>T</em></sub> has a pole of order ν(λ) at λ.</p>
<h2 id="example">Example</h2>

<p>This example shows how to calculate the Jordan normal form of a given matrix. As the next section explains, it is important to do the computation exactly instead of rounding the results.</p>

<p>Consider the matrix</p>

<p>

<math display="block" id="Jordan_normal_form:63">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>5</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>4</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>2</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>3</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>2</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">5</cn>
      <cn type="integer">4</cn>
      <cn type="integer">2</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">3</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">2</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\begin{bmatrix}5&4&2&1\\
0&1&-1&-1\\
-1&-1&3&0\\
1&1&-1&2\end{bmatrix}
  </annotation>
 </semantics>
</math>

 which is mentioned in the beginning of the article.</p>

<p>The <a href="characteristic_polynomial" title="wikilink">characteristic polynomial</a> of <em>A</em> is</p>

<p>

<math display="block" id="Jordan_normal_form:64">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>χ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo movablelimits="false">det</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>λ</mi>
        <mi>I</mi>
       </mrow>
       <mo>-</mo>
       <mi>A</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mrow>
        <msup>
         <mi>λ</mi>
         <mn>4</mn>
        </msup>
        <mo>-</mo>
        <mrow>
         <mn>11</mn>
         <msup>
          <mi>λ</mi>
          <mn>3</mn>
         </msup>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mn>42</mn>
        <msup>
         <mi>λ</mi>
         <mn>2</mn>
        </msup>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mn>64</mn>
       <mi>λ</mi>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mn>32</mn>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>λ</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>λ</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>λ</mi>
        <mo>-</mo>
        <mn>4</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>χ</ci>
      <ci>λ</ci>
     </apply>
     <apply>
      <determinant></determinant>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>λ</ci>
        <ci>I</ci>
       </apply>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>λ</ci>
          <cn type="integer">4</cn>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">11</cn>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>λ</ci>
           <cn type="integer">3</cn>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">42</cn>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>λ</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">64</cn>
        <ci>λ</ci>
       </apply>
      </apply>
      <cn type="integer">32</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>λ</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <minus></minus>
       <ci>λ</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <ci>λ</ci>
        <cn type="integer">4</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi(\lambda)=\det(\lambda I-A)=\lambda^{4}-11\lambda^{3}+42\lambda^{2}-64%
\lambda+32=(\lambda-1)(\lambda-2)(\lambda-4)^{2}.\,
  </annotation>
 </semantics>
</math>

 This shows that the eigenvalues are 1, 2, 4 and 4, according to algebraic multiplicity. The eigenspace corresponding to the eigenvalue 1 can be found by solving the equation <em>Av</em> = <em>λ v</em>. It is spanned by the column vector <em>v</em> = (−1, 1, 0, 0)<sup>T</sup>. Similarly, the eigenspace corresponding to the eigenvalue 2 is spanned by <em>w</em> = (1, −1, 0, 1)<sup>T</sup>. Finally, the eigenspace corresponding to the eigenvalue 4 is also one-dimensional (even though this is a double eigenvalue) and is spanned by <em>x</em> = (1, 0, −1, 1)<sup>T</sup>. So, the <a href="geometric_multiplicity" title="wikilink">geometric multiplicity</a> (i.e., the dimension of the eigenspace of the given eigenvalue) of each of the three eigenvalues is one. Therefore, the two eigenvalues equal to 4 correspond to a single Jordan block, and the Jordan normal form of the matrix <em>A</em> is the <a href="Matrix_addition#Direct_sum" title="wikilink">direct sum</a></p>

<p>

<math display="block" id="Jordan_normal_form:65">
 <semantics>
  <mrow>
   <mrow>
    <mi>J</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>J</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⊕</mo>
     <mrow>
      <msub>
       <mi>J</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>2</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⊕</mo>
     <mrow>
      <msub>
       <mi>J</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>4</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>2</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>4</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>4</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>J</ci>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>J</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>J</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>J</ci>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">4</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <matrix>
      <matrixrow>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">2</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">4</cn>
       <cn type="integer">1</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">4</cn>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J=J_{1}(1)\oplus J_{1}(2)\oplus J_{2}(4)=\begin{bmatrix}1&0&0&0\\
0&2&0&0\\
0&0&4&1\\
0&0&0&4\end{bmatrix}.
  </annotation>
 </semantics>
</math>

 There are three chains. Two have length one: {<em>v</em>} and {<em>w</em>}, corresponding to the eigenvalues 1 and 2, respectively. There is one chain of length two corresponding to the eigenvalue 4. To find this chain, calculate</p>

<p>

<math display="block" id="Jordan_normal_form:66">
 <semantics>
  <mrow>
   <mi>ker</mi>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>-</mo>
     <mn>4</mn>
     <mi>I</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mo rspace="4.2pt">span</mo>
   <mrow>
    <mo>{</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mo>}</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">kernel</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <minus></minus>
      <cn type="integer">4</cn>
      <csymbol cd="unknown">I</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cn type="integer">2</cn>
    </apply>
    <eq></eq>
    <ci>span</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <matrix>
      <matrixrow>
       <cn type="integer">1</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
      </matrixrow>
     </matrix>
     <ci>normal-,</ci>
     <matrix>
      <matrixrow>
       <cn type="integer">1</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <cn type="integer">1</cn>
      </matrixrow>
     </matrix>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ker{(A-4I)}^{2}=\operatorname{span}\,\left\{\begin{bmatrix}1\\
0\\
0\\
0\end{bmatrix},\begin{bmatrix}1\\
0\\
-1\\
1\end{bmatrix}\right\}.
  </annotation>
 </semantics>
</math>

 Pick a vector in the above span that is not in the kernel of <em>A</em> − 4<em>I</em>, e.g., <em>y</em> = (1,0,0,0)<sup>T</sup>. Now, (<em>A</em> − 4<em>I</em>)<em>y</em> = <em>x</em> and (<em>A</em> − 4<em>I</em>)<em>x</em> = 0, so {<em>y</em>, <em>x</em>} is a chain of length two corresponding to the eigenvalue 4.</p>

<p>The transition matrix <em>P</em> such that <em>P</em><sup>−1</sup><em>AP</em> = <em>J</em> is formed by putting these vectors next to each other as follows</p>

<p>

<math display="block" id="Jordan_normal_form:67">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo maxsize="160%" minsize="160%" rspace="4.2pt">[</mo>
    <mpadded width="+1.7pt">
     <mi>v</mi>
    </mpadded>
    <mo mathsize="160%" rspace="4.2pt" stretchy="false">|</mo>
    <mpadded width="+1.7pt">
     <mi>w</mi>
    </mpadded>
    <mo mathsize="160%" rspace="4.2pt" stretchy="false">|</mo>
    <mpadded width="+1.7pt">
     <mi>x</mi>
    </mpadded>
    <mo mathsize="160%" rspace="4.2pt" stretchy="false">|</mo>
    <mpadded width="+1.7pt">
     <mi>y</mi>
    </mpadded>
    <mo maxsize="160%" minsize="160%">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">w</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <matrix>
     <matrixrow>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">1</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
     </matrixrow>
    </matrix>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=\Big[\,v\,\Big|\,w\,\Big|\,x\,\Big|\,y\,\Big]=\begin{bmatrix}-1&1&1&1\\
1&-1&0&0\\
0&0&-1&0\\
0&1&1&0\end{bmatrix}.
  </annotation>
 </semantics>
</math>

 A computation shows that the equation <em>P</em><sup>−1</sup><em>AP</em> = <em>J</em> indeed holds.</p>

<p>

<math display="block" id="Jordan_normal_form:68">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>P</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mi>A</mi>
     <mi>P</mi>
    </mrow>
    <mo>=</mo>
    <mi>J</mi>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>2</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>4</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>4</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>P</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>A</ci>
      <ci>P</ci>
     </apply>
     <ci>J</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <matrix>
      <matrixrow>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">2</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">4</cn>
       <cn type="integer">1</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">4</cn>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}AP=J=\begin{bmatrix}1&0&0&0\\
0&2&0&0\\
0&0&4&1\\
0&0&0&4\end{bmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>If we had interchanged the order of which the chain vectors appeared, that is, changing the order of <em>v</em>, <em>w</em> and {<em>x</em>, <em>y</em>} together, the Jordan blocks would be interchanged. However, the Jordan forms are equivalent Jordan forms.</p>
<h2 id="numerical-analysis">Numerical analysis</h2>

<p>If the matrix <em>A</em> has multiple eigenvalues, or is close to a matrix with multiple eigenvalues, then its Jordan normal form is very sensitive to perturbations. Consider for instance the matrix</p>

<p>

<math display="block" id="Jordan_normal_form:69">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi>ε</mi>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <ci>ε</ci>
      <cn type="integer">1</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\begin{bmatrix}1&1\\
\varepsilon&1\end{bmatrix}.
  </annotation>
 </semantics>
</math>

 If ε = 0, then the Jordan normal form is simply</p>

<p>

<math display="block" id="Jordan_normal_form:70">
 <semantics>
  <mrow>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">1</cn>
     <cn type="integer">1</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}1&1\\
0&1\end{bmatrix}.
  </annotation>
 </semantics>
</math>

 However, for ε ≠ 0, the Jordan normal form is</p>

<p>

<math display="block" id="Jordan_normal_form:71">
 <semantics>
  <mrow>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <msqrt>
         <mi>ε</mi>
        </msqrt>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <msqrt>
         <mi>ε</mi>
        </msqrt>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <ci>ε</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <ci>ε</ci>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}1+\sqrt{\varepsilon}&0\\
0&1-\sqrt{\varepsilon}\end{bmatrix}.
  </annotation>
 </semantics>
</math>

 This <a href="condition_number" title="wikilink">ill conditioning</a> makes it very hard to develop a robust numerical algorithm for the Jordan normal form, as the result depends critically on whether two eigenvalues are deemed to be equal. For this reason, the Jordan normal form is usually avoided in <a href="numerical_analysis" title="wikilink">numerical analysis</a>; the stable <a href="Schur_decomposition" title="wikilink">Schur decomposition</a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> or <a href="pseudospectrum" title="wikilink">pseudospectra</a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> are better alternatives.</p>
<h2 id="powers">Powers</h2>

<p>If <em>n</em> is a <a href="natural_number" title="wikilink">natural number</a>, the <em>n</em><sup>th</sup> power of a matrix in Jordan normal form will be a direct sum of upper triangular matrices, as a result of <a href="Block_matrix" title="wikilink">block multiplication</a>. More specifically, after exponentiation each Jordan block will be an upper triangular block.</p>

<p>For example,</p>

<p>

<math display="block" id="Jordan_normal_form:72">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>2</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>2</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>2</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>5</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>5</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
     <mn>4</mn>
    </msup>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>16</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>32</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>24</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>16</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>32</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>16</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>625</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>500</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>625</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <matrix>
      <matrixrow>
       <cn type="integer">2</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">2</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">2</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">5</cn>
       <cn type="integer">1</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">5</cn>
      </matrixrow>
     </matrix>
     <cn type="integer">4</cn>
    </apply>
    <matrix>
     <matrixrow>
      <cn type="integer">16</cn>
      <cn type="integer">32</cn>
      <cn type="integer">24</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">16</cn>
      <cn type="integer">32</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">16</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">625</cn>
      <cn type="integer">500</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">625</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}2&1&0&0&0\\
0&2&1&0&0\\
0&0&2&0&0\\
0&0&0&5&1\\
0&0&0&0&5\end{bmatrix}^{4}=\begin{bmatrix}16&32&24&0&0\\
0&16&32&0&0\\
0&0&16&0&0\\
0&0&0&625&500\\
0&0&0&0&625\end{bmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>Further, each triangular block will consist of λ<sup><em>n</em></sup> on the main diagonal, 

<math display="inline" id="Jordan_normal_form:73">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mstyle scriptlevel="+1">
    <mtable columnspacing="0.4em" rowspacing="0.2ex">
     <mtr>
      <mtd>
       <mi>n</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd>
       <mn>1</mn>
      </mtd>
     </mtr>
    </mtable>
   </mstyle>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">binomial</csymbol>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\textstyle\left({{n}\atop{1}}\right)}
  </annotation>
 </semantics>
</math>

 times λ<sup><em>n</em>-1</sup> on the upper diagonal, and so on. This expression is valid for negative integer powers as well if one extends the notion of the binomial coefficients 

<math display="inline" id="Jordan_normal_form:74">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mstyle scriptlevel="+1">
     <mtable columnspacing="0.4em" rowspacing="0.2ex">
      <mtr>
       <mtd>
        <mi>n</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mi>k</mi>
       </mtd>
      </mtr>
     </mtable>
    </mstyle>
    <mo>)</mo>
   </mrow>
   <mo>↦</mo>
   <mrow>
    <msup>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mi>n</mi>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>n</mi>
        <mo stretchy="false">|</mo>
       </mrow>
      </mfrac>
      <mo>)</mo>
     </mrow>
     <mi>k</mi>
    </msup>
    <mrow>
     <mo>(</mo>
     <mstyle scriptlevel="+1">
      <mtable columnspacing="0.4em" rowspacing="0.2ex">
       <mtr>
        <mtd>
         <mrow>
          <mo stretchy="false">|</mo>
          <mi>n</mi>
          <mo stretchy="false">|</mo>
         </mrow>
        </mtd>
       </mtr>
       <mtr>
        <mtd>
         <mi>k</mi>
        </mtd>
       </mtr>
      </mtable>
     </mstyle>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <apply>
     <csymbol cd="latexml">binomial</csymbol>
     <ci>n</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <apply>
        <abs></abs>
        <ci>n</ci>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">binomial</csymbol>
      <apply>
       <abs></abs>
       <ci>n</ci>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\textstyle\left({{n}\atop{k}}\right)}\mapsto\left(\frac{n}{|n|}\right)^{k}{%
\textstyle\left({{|n|}\atop{k}}\right)}
  </annotation>
 </semantics>
</math>

.</p>

<p>For example,</p>

<p>

<math display="block" id="Jordan_normal_form:75">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>λ</mi>
          <mn>1</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>λ</mi>
          <mn>1</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>λ</mi>
          <mn>1</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>λ</mi>
          <mn>2</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>λ</mi>
          <mn>2</mn>
         </msub>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
     <mi>n</mi>
    </msup>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msubsup>
         <mi>λ</mi>
         <mn>1</mn>
         <mi>n</mi>
        </msubsup>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mrow>
          <mo>(</mo>
          <mstyle displaystyle="false">
           <mstyle scriptlevel="+1">
            <mtable columnspacing="0.4em" rowspacing="0.2ex">
             <mtr>
              <mtd>
               <mi>n</mi>
              </mtd>
             </mtr>
             <mtr>
              <mtd>
               <mn>1</mn>
              </mtd>
             </mtr>
            </mtable>
           </mstyle>
          </mstyle>
          <mo>)</mo>
         </mrow>
         <msubsup>
          <mi>λ</mi>
          <mn>1</mn>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msubsup>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mrow>
          <mo>(</mo>
          <mstyle displaystyle="false">
           <mstyle scriptlevel="+1">
            <mtable columnspacing="0.4em" rowspacing="0.2ex">
             <mtr>
              <mtd>
               <mi>n</mi>
              </mtd>
             </mtr>
             <mtr>
              <mtd>
               <mn>2</mn>
              </mtd>
             </mtr>
            </mtable>
           </mstyle>
          </mstyle>
          <mo>)</mo>
         </mrow>
         <msubsup>
          <mi>λ</mi>
          <mn>1</mn>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>2</mn>
          </mrow>
         </msubsup>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <msubsup>
         <mi>λ</mi>
         <mn>1</mn>
         <mi>n</mi>
        </msubsup>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mrow>
          <mo>(</mo>
          <mstyle displaystyle="false">
           <mstyle scriptlevel="+1">
            <mtable columnspacing="0.4em" rowspacing="0.2ex">
             <mtr>
              <mtd>
               <mi>n</mi>
              </mtd>
             </mtr>
             <mtr>
              <mtd>
               <mn>1</mn>
              </mtd>
             </mtr>
            </mtable>
           </mstyle>
          </mstyle>
          <mo>)</mo>
         </mrow>
         <msubsup>
          <mi>λ</mi>
          <mn>1</mn>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msubsup>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <msubsup>
         <mi>λ</mi>
         <mn>1</mn>
         <mi>n</mi>
        </msubsup>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <msubsup>
         <mi>λ</mi>
         <mn>2</mn>
         <mi>n</mi>
        </msubsup>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mrow>
          <mo>(</mo>
          <mstyle displaystyle="false">
           <mstyle scriptlevel="+1">
            <mtable columnspacing="0.4em" rowspacing="0.2ex">
             <mtr>
              <mtd>
               <mi>n</mi>
              </mtd>
             </mtr>
             <mtr>
              <mtd>
               <mn>1</mn>
              </mtd>
             </mtr>
            </mtable>
           </mstyle>
          </mstyle>
          <mo>)</mo>
         </mrow>
         <msubsup>
          <mi>λ</mi>
          <mn>2</mn>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msubsup>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <msubsup>
         <mi>λ</mi>
         <mn>2</mn>
         <mi>n</mi>
        </msubsup>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">1</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <cn type="integer">2</cn>
       </apply>
      </matrixrow>
     </matrix>
     <ci>n</ci>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">binomial</csymbol>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">binomial</csymbol>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">binomial</csymbol>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>n</ci>
      </apply>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">binomial</csymbol>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>n</ci>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}\lambda_{1}&1&0&0&0\\
0&\lambda_{1}&1&0&0\\
0&0&\lambda_{1}&0&0\\
0&0&0&\lambda_{2}&1\\
0&0&0&0&\lambda_{2}\end{bmatrix}^{n}=\begin{bmatrix}\lambda_{1}^{n}&{%
\textstyle\left({{n}\atop{1}}\right)}\lambda_{1}^{n-1}&{\textstyle\left({{n}%
\atop{2}}\right)}\lambda_{1}^{n-2}&0&0\\
0&\lambda_{1}^{n}&{\textstyle\left({{n}\atop{1}}\right)}\lambda_{1}^{n-1}&0&0%
\\
0&0&\lambda_{1}^{n}&0&0\\
0&0&0&\lambda_{2}^{n}&{\textstyle\left({{n}\atop{1}}\right)}\lambda_{2}^{n-1}%
\\
0&0&0&0&\lambda_{2}^{n}\end{bmatrix}.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Canonical_basis" title="wikilink">Canonical basis</a></li>
<li><a href="Canonical_form" title="wikilink">Canonical form</a></li>
<li><a href="Frobenius_normal_form" title="wikilink">Frobenius normal form</a></li>
<li><a href="Jordan_matrix" title="wikilink">Jordan matrix</a></li>
<li><a href="Jordan–Chevalley_decomposition" title="wikilink">Jordan–Chevalley decomposition</a></li>
<li><a href="Matrix_decomposition" title="wikilink">Matrix decomposition</a></li>
<li><a href="Modal_matrix" title="wikilink">Modal matrix</a></li>
<li><a href="Weyr_canonical_form" title="wikilink">Weyr canonical form</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li>N. Dunford and J.T. Schwartz, <em>Linear Operators, Part I: General Theory</em>, Interscience, 1958.</li>
<li>Daniel T. Finkbeiner II, <em>Introduction to Matrices and Linear Transformations, Third Edition</em>, Freeman, 1978.</li>
<li></li>
<li><a href="Gene_H._Golub" title="wikilink">Gene H. Golub</a> and <a href="Charles_F._Van_Loan" title="wikilink">Charles F. Van Loan</a>, <em>Matrix Computations</em> (4th ed.), Johns Hopkins University Press, Baltimore, 2012.</li>
<li>Gene H. Golub and J. H. Wilkinson, Ill-conditioned eigensystems and the computation of the Jordan normal form, <em>SIAM Review</em>, vol. 18, nr. 4, pp. 578–619, 1976.</li>
<li></li>
<li>

<p>.</p></li>
<li>Glenn James and Robert C. James, <em>Mathematics Dictionary, Fourth Edition</em>, Van Nostrand Reinhold, 1976.</li>
<li>Saunders MacLane and Garrett Birkhoff, <em>Algebra</em>, MacMillan, 1967.</li>
<li>Anthony N. Michel and Charles J. Herget, <em>Applied Algebra and Functional Analysis</em>, Dover, 1993.</li>
<li></li>
<li>Georgi E. Shilov, <em>Linear Algebra</em>, Dover, 1977.</li>
<li><a href="Igor_Shafarevich" title="wikilink">I. R. Shafarevich</a> &amp; A. O. Remizov (2012) <em>Linear Algebra and Geometry</em>, <a href="Springer_Science+Business_Media" title="wikilink">Springer</a> ISBN 978-3-642-30993-9.</li>
<li><a href="http://mathworld.wolfram.com/JordanCanonicalForm.html"><em>Jordan Canonical Form</em> article at mathworld.wolfram.com</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.mathstools.com/section/main/system_equations_solver">On line tool on Jordan form and matrix diagonalizations</a> by www.mathstools.com</li>
</ul>

<p>"</p>

<p><a href="Category:Linear_algebra" title="wikilink">Category:Linear algebra</a> <a href="Category:Matrix_theory" title="wikilink">Category:Matrix theory</a> <a href="Category:Matrix_normal_forms" title="wikilink">Category:Matrix normal forms</a> <a href="Category:Matrix_decompositions" title="wikilink">Category:Matrix decompositions</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Shilov defines the term <em>Jordan canonical form</em> and in a footnote says that <em>Jordan normal form</em> is synonymous. These terms are sometimes shortened to <em>Jordan form</em>. (Shilov) The term <em>Classical canonical form</em> is also sometimes used in the sense of this article. (James &amp; James, 1976)<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17">See Golub &amp; Van Loan (2014), §7.6.5; or Golub &amp; Wilkinson (1976) for details.<a href="#fnref17">↩</a></li>
<li id="fn18">See Golub &amp; Van Loan (2014), §7.9<a href="#fnref18">↩</a></li>
</ol>
</section>
</body>
</html>
