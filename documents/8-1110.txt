   Probabilistic CTL      Probabilistic CTL   Probabilistic Computation Tree Logic (PCTL) is an extension of computation tree logic (CTL) which allows for probabilistic quantification of described properties. It has been defined in the paper by Hansson and Jonsson. 1  PCTL is a useful logic for stating soft deadline properties, e.g. "after a request for a service, there is at least a 98% probability that the service will be carried out within 2 seconds". Akin CTL suitability for model-checking PCTL extension is widely used as a property specification language for probabilistic model checkers.  PCTL syntax  One of the possible syntax of PCTL is defined as follows:       ϕ  :  :=  p  |  ¬  p  |  ϕ  ∨  ϕ  |  ϕ  ∧  ϕ  |   𝒫    ∼  λ     (  ϕ  𝒰  ϕ  )   |   𝒫    ∼  λ     (  □  ϕ  )      fragments  ϕ  normal-:  assign  p  normal-|   p  normal-|  ϕ   ϕ  normal-|  ϕ   ϕ  normal-|   subscript  𝒫   similar-to  absent  λ     fragments  normal-(  ϕ  U  ϕ  normal-)   normal-|   subscript  𝒫   similar-to  absent  λ     fragments  normal-(  □  ϕ  normal-)     \phi::=p|\neg p|\phi\lor\phi|\phi\land\phi|\mathcal{P}_{\sim\lambda}(\phi%
 \mathcal{U}\phi)|\mathcal{P}_{\sim\lambda}(\square\phi)      Therein,    ∼  ∈   {  <  ,  ≤  ,  ≥  ,  >  }      fragments  similar-to    fragments  normal-{   normal-,   normal-,   normal-,   normal-}     \sim\in\{<,\leq,\geq,>\}   is comparison operator and   λ   λ   \lambda   is a probability threshold. Formulas of PCTL are interpreted over discrete Markov chains . An interpretation structure is a quadruple    K  =   ⟨  S  ,   s  i   ,  𝒯  ,  L  ⟩       K   S   superscript  s  i   𝒯  L     K=\langle S,s^{i},\mathcal{T},L\rangle   , where      S   S   S   is a finite set of states,       s  i   ∈  S       superscript  s  i   S    s^{i}\in S   is an initial state,     𝒯   𝒯   \mathcal{T}   is a transition probability function,    𝒯  :    S  ×  S   →   [  0  ,  1  ]       normal-:  𝒯   normal-→    S  S    0  1      \mathcal{T}:S\times S\to[0,1]   , such that for all    s  ∈  S      s  S    s\in S   we have      ∑    s  ′   ∈  S     𝒯   (  s  ,   s  ′   )     =  1        subscript      superscript  s  normal-′   S      𝒯   s   superscript  s  normal-′      1    \sum_{s^{\prime}\in S}\mathcal{T}(s,s^{\prime})=1   , and     L   L   L   is a labeling function,    L  :   S  →   2  A       normal-:  L   normal-→  S   superscript  2  A      L:S\to 2^{A}   , assigning atomic propositions to states.   A path   σ   σ   \sigma   from a state    s  0     subscript  s  0    s_{0}   is an infinite sequence of states     s  0   →   s  1   →  …  →   s  n   →  …       normal-→   subscript  s  0    subscript  s  1     normal-→    normal-…    normal-→     subscript  s  n     normal-→    normal-…     s_{0}\to s_{1}\to\dots\to s_{n}\to\dots   . The n-th state of the path is denoted as    σ   [  n  ]       σ   delimited-[]  n     \sigma[n]   and the prefix of   σ   σ   \sigma   of length   n   n   n   is denoted as    σ  ↑  n     normal-↑  σ  n    \sigma\uparrow n   .  Probability measure  A probability measure    μ  m     subscript  μ  m    \mu_{m}   of the set of path with the common prefix of length   n   n   n   is equal to the product of transitions probabilitites along the prefix of the path:         μ  m    (   {   σ  ∈  X   :   σ  ↑  n  =   s  0   →  …  →   s  n    }   )    =     𝒯   (   s  0   ,   s  1   )    ×  …  ×  𝒯    (   s   n  -  1    ,   s  n   )           subscript  μ  m    conditional-set    σ  X      normal-↑  σ  n        subscript  s  0     normal-→    normal-…    normal-→     subscript  s  n             𝒯    subscript  s  0    subscript  s  1     normal-…  𝒯     subscript  s    n  1     subscript  s  n       \mu_{m}(\{\sigma\in X:\sigma\uparrow n=s_{0}\to\dots\to s_{n}\})=\mathcal{T}(s%
 _{0},s_{1})\times\dots\times\mathcal{T}(s_{n-1},s_{n})      For    n  =  0      n  0    n=0   the probability measure is equal to      μ  m    (   {   σ  ∈  X   :   σ  ↑  0  =   s  0    }   )    =  1         subscript  μ  m    conditional-set    σ  X      normal-↑  σ  0        subscript  s  0       1    \mu_{m}(\{\sigma\in X:\sigma\uparrow 0=s_{0}\})=1   .  Satisfaction relations  Satisfaction relations    s   ⊧  K   f      subscript  models  K   s  f    s\models_{K}f   ,    σ   ⊧  K   f      subscript  models  K   σ  f    \sigma\models_{K}f   are inductively defined as follows:       s   ⊧  K   a      subscript  models  K   s  a    s\models_{K}a   if and only if    a  ∈   L   (  s  )        a    L  s     a\in L(s)   ,      s   ⊧  K    ¬  f       subscript  models  K   s     f     s\models_{K}\neg f   if and only if not    s   ⊧  K   f      subscript  models  K   s  f    s\models_{K}f   ,      s   ⊧  K     f  1   ∨   f  2        subscript  models  K   s     subscript  f  1    subscript  f  2      s\models_{K}f_{1}\lor f_{2}   if and only if    s   ⊧  K    f  1       subscript  models  K   s   subscript  f  1     s\models_{K}f_{1}   or    s   ⊧  K    f  2       subscript  models  K   s   subscript  f  2     s\models_{K}f_{2}   ,      s   ⊧  K     f  1   ∧   f  2        subscript  models  K   s     subscript  f  1    subscript  f  2      s\models_{K}f_{1}\land f_{2}   if and only if    s   ⊧  K    f  1       subscript  models  K   s   subscript  f  1     s\models_{K}f_{1}   and    s   ⊧  K    f  2       subscript  models  K   s   subscript  f  2     s\models_{K}f_{2}   ,      s   ⊧  K     𝒫    ∼  λ     (    f  1   𝒰   f  2    )        subscript  models  K   s     subscript  𝒫   similar-to  absent  λ       subscript  f  1   𝒰   subscript  f  2       s\models_{K}\mathcal{P}_{\sim\lambda}(f_{1}\mathcal{U}f_{2})   if and only if     μ  m    (   {  σ  :  σ   [  0  ]   =  s  ∧   (  ∃  i  )   σ   [  i  ]    ⊧  K    f  2   ∧   (  ∀  0  ≤  j  <  i  )   σ   [  j  ]    ⊧  K    f  1   }   )   ∼  λ     fragments   subscript  μ  m    fragments  normal-(   fragments  normal-{  σ  normal-:  σ   fragments  normal-[  0  normal-]    s    fragments  normal-(   i  normal-)   σ   fragments  normal-[  i  normal-]    subscript  models  K    subscript  f  2     fragments  normal-(  for-all  0   j   i  normal-)   σ   fragments  normal-[  j  normal-]    subscript  models  K    subscript  f  1   normal-}   normal-)   similar-to  λ    \mu_{m}(\{\sigma:\sigma[0]=s\land(\exists i)\sigma[i]\models_{K}f_{2}\land(%
 \forall 0\leq j   , and      s   ⊧  K     𝒫    ∼  λ     (   □  f   )        subscript  models  K   s     subscript  𝒫   similar-to  absent  λ      normal-□  f      s\models_{K}\mathcal{P}_{\sim\lambda}(\square f)   if and only if     μ  m    (   {  σ  :  σ   [  0  ]   =  s  ∧   (  ∀  i  ≥  0  )   σ   [  i  ]    ⊧  K   f  }   )   ∼  λ     fragments   subscript  μ  m    fragments  normal-(   fragments  normal-{  σ  normal-:  σ   fragments  normal-[  0  normal-]    s    fragments  normal-(  for-all  i   0  normal-)   σ   fragments  normal-[  i  normal-]    subscript  models  K   f  normal-}   normal-)   similar-to  λ    \mu_{m}(\{\sigma:\sigma[0]=s\land(\forall i\geq 0)\sigma[i]\models_{K}f\})\sim\lambda   .   References    "  Category:Temporal logic     Hansson, Hans, and Bengt Jonsson. "A logic for reasoning about time and reliability." Formal aspects of computing 6.5 (1994): 512-535. ↩     