   Probabilistic CTL      Probabilistic CTL   Probabilistic Computation Tree Logic (PCTL) is an extension of computation tree logic (CTL) which allows for probabilistic quantification of described properties. It has been defined in the paper by Hansson and Jonsson. 1  PCTL is a useful logic for stating soft deadline properties, e.g. "after a request for a service, there is at least a 98% probability that the service will be carried out within 2 seconds". Akin CTL suitability for model-checking PCTL extension is widely used as a property specification language for probabilistic model checkers.  PCTL syntax  One of the possible syntax of PCTL is defined as follows:       Ï•  :  :=  p  |  Â¬  p  |  Ï•  âˆ¨  Ï•  |  Ï•  âˆ§  Ï•  |   ğ’«    âˆ¼  Î»     (  Ï•  ğ’°  Ï•  )   |   ğ’«    âˆ¼  Î»     (  â–¡  Ï•  )      fragments  Ï•  normal-:  assign  p  normal-|   p  normal-|  Ï•   Ï•  normal-|  Ï•   Ï•  normal-|   subscript  ğ’«   similar-to  absent  Î»     fragments  normal-(  Ï•  U  Ï•  normal-)   normal-|   subscript  ğ’«   similar-to  absent  Î»     fragments  normal-(  â–¡  Ï•  normal-)     \phi::=p|\neg p|\phi\lor\phi|\phi\land\phi|\mathcal{P}_{\sim\lambda}(\phi%
 \mathcal{U}\phi)|\mathcal{P}_{\sim\lambda}(\square\phi)      Therein,    âˆ¼  âˆˆ   {  <  ,  â‰¤  ,  â‰¥  ,  >  }      fragments  similar-to    fragments  normal-{   normal-,   normal-,   normal-,   normal-}     \sim\in\{<,\leq,\geq,>\}   is comparison operator and   Î»   Î»   \lambda   is a probability threshold. Formulas of PCTL are interpreted over discrete Markov chains . An interpretation structure is a quadruple    K  =   âŸ¨  S  ,   s  i   ,  ğ’¯  ,  L  âŸ©       K   S   superscript  s  i   ğ’¯  L     K=\langle S,s^{i},\mathcal{T},L\rangle   , where      S   S   S   is a finite set of states,       s  i   âˆˆ  S       superscript  s  i   S    s^{i}\in S   is an initial state,     ğ’¯   ğ’¯   \mathcal{T}   is a transition probability function,    ğ’¯  :    S  Ã—  S   â†’   [  0  ,  1  ]       normal-:  ğ’¯   normal-â†’    S  S    0  1      \mathcal{T}:S\times S\to[0,1]   , such that for all    s  âˆˆ  S      s  S    s\in S   we have      âˆ‘    s  â€²   âˆˆ  S     ğ’¯   (  s  ,   s  â€²   )     =  1        subscript      superscript  s  normal-â€²   S      ğ’¯   s   superscript  s  normal-â€²      1    \sum_{s^{\prime}\in S}\mathcal{T}(s,s^{\prime})=1   , and     L   L   L   is a labeling function,    L  :   S  â†’   2  A       normal-:  L   normal-â†’  S   superscript  2  A      L:S\to 2^{A}   , assigning atomic propositions to states.   A path   Ïƒ   Ïƒ   \sigma   from a state    s  0     subscript  s  0    s_{0}   is an infinite sequence of states     s  0   â†’   s  1   â†’  â€¦  â†’   s  n   â†’  â€¦       normal-â†’   subscript  s  0    subscript  s  1     normal-â†’    normal-â€¦    normal-â†’     subscript  s  n     normal-â†’    normal-â€¦     s_{0}\to s_{1}\to\dots\to s_{n}\to\dots   . The n-th state of the path is denoted as    Ïƒ   [  n  ]       Ïƒ   delimited-[]  n     \sigma[n]   and the prefix of   Ïƒ   Ïƒ   \sigma   of length   n   n   n   is denoted as    Ïƒ  â†‘  n     normal-â†‘  Ïƒ  n    \sigma\uparrow n   .  Probability measure  A probability measure    Î¼  m     subscript  Î¼  m    \mu_{m}   of the set of path with the common prefix of length   n   n   n   is equal to the product of transitions probabilitites along the prefix of the path:         Î¼  m    (   {   Ïƒ  âˆˆ  X   :   Ïƒ  â†‘  n  =   s  0   â†’  â€¦  â†’   s  n    }   )    =     ğ’¯   (   s  0   ,   s  1   )    Ã—  â€¦  Ã—  ğ’¯    (   s   n  -  1    ,   s  n   )           subscript  Î¼  m    conditional-set    Ïƒ  X      normal-â†‘  Ïƒ  n        subscript  s  0     normal-â†’    normal-â€¦    normal-â†’     subscript  s  n             ğ’¯    subscript  s  0    subscript  s  1     normal-â€¦  ğ’¯     subscript  s    n  1     subscript  s  n       \mu_{m}(\{\sigma\in X:\sigma\uparrow n=s_{0}\to\dots\to s_{n}\})=\mathcal{T}(s%
 _{0},s_{1})\times\dots\times\mathcal{T}(s_{n-1},s_{n})      For    n  =  0      n  0    n=0   the probability measure is equal to      Î¼  m    (   {   Ïƒ  âˆˆ  X   :   Ïƒ  â†‘  0  =   s  0    }   )    =  1         subscript  Î¼  m    conditional-set    Ïƒ  X      normal-â†‘  Ïƒ  0        subscript  s  0       1    \mu_{m}(\{\sigma\in X:\sigma\uparrow 0=s_{0}\})=1   .  Satisfaction relations  Satisfaction relations    s   âŠ§  K   f      subscript  models  K   s  f    s\models_{K}f   ,    Ïƒ   âŠ§  K   f      subscript  models  K   Ïƒ  f    \sigma\models_{K}f   are inductively defined as follows:       s   âŠ§  K   a      subscript  models  K   s  a    s\models_{K}a   if and only if    a  âˆˆ   L   (  s  )        a    L  s     a\in L(s)   ,      s   âŠ§  K    Â¬  f       subscript  models  K   s     f     s\models_{K}\neg f   if and only if not    s   âŠ§  K   f      subscript  models  K   s  f    s\models_{K}f   ,      s   âŠ§  K     f  1   âˆ¨   f  2        subscript  models  K   s     subscript  f  1    subscript  f  2      s\models_{K}f_{1}\lor f_{2}   if and only if    s   âŠ§  K    f  1       subscript  models  K   s   subscript  f  1     s\models_{K}f_{1}   or    s   âŠ§  K    f  2       subscript  models  K   s   subscript  f  2     s\models_{K}f_{2}   ,      s   âŠ§  K     f  1   âˆ§   f  2        subscript  models  K   s     subscript  f  1    subscript  f  2      s\models_{K}f_{1}\land f_{2}   if and only if    s   âŠ§  K    f  1       subscript  models  K   s   subscript  f  1     s\models_{K}f_{1}   and    s   âŠ§  K    f  2       subscript  models  K   s   subscript  f  2     s\models_{K}f_{2}   ,      s   âŠ§  K     ğ’«    âˆ¼  Î»     (    f  1   ğ’°   f  2    )        subscript  models  K   s     subscript  ğ’«   similar-to  absent  Î»       subscript  f  1   ğ’°   subscript  f  2       s\models_{K}\mathcal{P}_{\sim\lambda}(f_{1}\mathcal{U}f_{2})   if and only if     Î¼  m    (   {  Ïƒ  :  Ïƒ   [  0  ]   =  s  âˆ§   (  âˆƒ  i  )   Ïƒ   [  i  ]    âŠ§  K    f  2   âˆ§   (  âˆ€  0  â‰¤  j  <  i  )   Ïƒ   [  j  ]    âŠ§  K    f  1   }   )   âˆ¼  Î»     fragments   subscript  Î¼  m    fragments  normal-(   fragments  normal-{  Ïƒ  normal-:  Ïƒ   fragments  normal-[  0  normal-]    s    fragments  normal-(   i  normal-)   Ïƒ   fragments  normal-[  i  normal-]    subscript  models  K    subscript  f  2     fragments  normal-(  for-all  0   j   i  normal-)   Ïƒ   fragments  normal-[  j  normal-]    subscript  models  K    subscript  f  1   normal-}   normal-)   similar-to  Î»    \mu_{m}(\{\sigma:\sigma[0]=s\land(\exists i)\sigma[i]\models_{K}f_{2}\land(%
 \forall 0\leq j   , and      s   âŠ§  K     ğ’«    âˆ¼  Î»     (   â–¡  f   )        subscript  models  K   s     subscript  ğ’«   similar-to  absent  Î»      normal-â–¡  f      s\models_{K}\mathcal{P}_{\sim\lambda}(\square f)   if and only if     Î¼  m    (   {  Ïƒ  :  Ïƒ   [  0  ]   =  s  âˆ§   (  âˆ€  i  â‰¥  0  )   Ïƒ   [  i  ]    âŠ§  K   f  }   )   âˆ¼  Î»     fragments   subscript  Î¼  m    fragments  normal-(   fragments  normal-{  Ïƒ  normal-:  Ïƒ   fragments  normal-[  0  normal-]    s    fragments  normal-(  for-all  i   0  normal-)   Ïƒ   fragments  normal-[  i  normal-]    subscript  models  K   f  normal-}   normal-)   similar-to  Î»    \mu_{m}(\{\sigma:\sigma[0]=s\land(\forall i\geq 0)\sigma[i]\models_{K}f\})\sim\lambda   .   References    "  Category:Temporal logic     Hansson, Hans, and Bengt Jonsson. "A logic for reasoning about time and reliability." Formal aspects of computing 6.5 (1994): 512-535. â†©     