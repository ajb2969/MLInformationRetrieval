<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1388">Sliced inverse regression</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Sliced inverse regression</h1>
<hr/>

<p><strong>Sliced inverse regression (SIR)</strong> is a tool for <a href="dimension_reduction" title="wikilink">dimension reduction</a> in the field of <a href="multivariate_statistics" title="wikilink">multivariate statistics</a>.</p>

<p>In <a class="uri" href="statistics" title="wikilink">statistics</a>, <a href="regression_analysis" title="wikilink">regression analysis</a> is a popular way of studying the relationship between a response variable <em>y</em> and its explanatory variable 

<math display="inline" id="Sliced_inverse_regression:0">
 <semantics>
  <munder accentunder="true">
   <mi>x</mi>
   <mo>¯</mo>
  </munder>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underline{x}
  </annotation>
 </semantics>
</math>

, which is a <em>p</em>-dimensional vector. There are several approaches which come under the term of regression. For example parametric methods include multiple linear regression; non-parametric techniques include <a href="local_smoothing" title="wikilink">local smoothing</a>.</p>

<p>With high-dimensional data (as <em>p</em> grows), the number of observations needed to use local smoothing methods escalates exponentially. Reducing the number of dimensions makes the operation computable. <a href="Dimension_reduction" title="wikilink">Dimension reduction</a> aims to show only the most important directions of the data. SIR uses the inverse regression curve, 

<math display="inline" id="Sliced_inverse_regression:1">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+1.7pt">
     <munder accentunder="true">
      <mi>x</mi>
      <mo>¯</mo>
     </munder>
    </mpadded>
    <mo rspace="4.2pt" stretchy="false">|</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\underline{x}\,|\,y)
  </annotation>
 </semantics>
</math>

 to perform a weighted principal component analysis, with which one identifies the effective dimension reducing directions.</p>

<p>This article first introduces the reader to the subject of dimension reduction and how it is performed using the model here. There is then a short review on inverse regression, which later brings these pieces together.</p>
<h2 id="model">Model</h2>

<p>Given a response variable 

<math display="inline" id="Sliced_inverse_regression:2">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>Y</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,Y
  </annotation>
 </semantics>
</math>

 and a (random) vector 

<math display="inline" id="Sliced_inverse_regression:3">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>∈</mo>
   <msup>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\R</mtext>
    </merror>
    <mi>p</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>X</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <mtext>\R</mtext>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\in\R^{p}
  </annotation>
 </semantics>
</math>

 of explanatory variables, <strong>SIR</strong> is based on the model</p>

<p>

<math display="inline" id="Sliced_inverse_regression:4">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msubsup>
        <mi>β</mi>
        <mn>1</mn>
        <mo>⊤</mo>
       </msubsup>
       <mi>X</mi>
      </mrow>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mrow>
       <msubsup>
        <mi>β</mi>
        <mi>k</mi>
        <mo>⊤</mo>
       </msubsup>
       <mi>X</mi>
      </mrow>
      <mo>,</mo>
      <mi>ε</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Y</ci>
    <list>
     <apply>
      <times></times>
      <ci>f</ci>
      <vector>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>β</ci>
          <cn type="integer">1</cn>
         </apply>
         <csymbol cd="latexml">top</csymbol>
        </apply>
        <ci>X</ci>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>β</ci>
          <ci>k</ci>
         </apply>
         <csymbol cd="latexml">top</csymbol>
        </apply>
        <ci>X</ci>
       </apply>
       <ci>ε</ci>
      </vector>
     </apply>
     <cn type="integer">1</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y=f(\beta_{1}^{\top}X,\ldots,\beta_{k}^{\top}X,\varepsilon)\quad\quad\quad%
\quad\quad(1)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Sliced_inverse_regression:5">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>β</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{1},\ldots,\beta_{k}
  </annotation>
 </semantics>
</math>

 are unknown projection vectors. 

<math display="inline" id="Sliced_inverse_regression:6">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>k</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,k
  </annotation>
 </semantics>
</math>

 is an unknown number (the dimensionality of the space we try to reduce our data to) and, of course, as we want to reduce dimension, smaller than 

<math display="inline" id="Sliced_inverse_regression:7">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>p</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,p
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Sliced_inverse_regression:8">
 <semantics>
  <mpadded lspace="2.8pt" width="+2.8pt">
   <mi>f</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;f
  </annotation>
 </semantics>
</math>

 is an unknown function on 

<math display="inline" id="Sliced_inverse_regression:9">
 <semantics>
  <msup>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\R</mtext>
   </merror>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <mtext>\R</mtext>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \R^{k+1}
  </annotation>
 </semantics>
</math>

, as it only depends on 

<math display="inline" id="Sliced_inverse_regression:10">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>k</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,k
  </annotation>
 </semantics>
</math>

 arguments, and 

<math display="inline" id="Sliced_inverse_regression:11">
 <semantics>
  <mi>ε</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

 is the error with 

<math display="inline" id="Sliced_inverse_regression:12">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>ε</mi>
    <mo stretchy="false">|</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">ε</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">0</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[\varepsilon|X]=0
  </annotation>
 </semantics>
</math>

 and finite variance 

<math display="inline" id="Sliced_inverse_regression:13">
 <semantics>
  <msup>
   <mi>σ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>σ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}
  </annotation>
 </semantics>
</math>

. The model describes an ideal solution, where 

<math display="inline" id="Sliced_inverse_regression:14">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>Y</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,Y
  </annotation>
 </semantics>
</math>

 depends on 

<math display="inline" id="Sliced_inverse_regression:15">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>∈</mo>
   <msup>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\R</mtext>
    </merror>
    <mi>p</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>X</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <mtext>\R</mtext>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\in\R^{p}
  </annotation>
 </semantics>
</math>

 only through a 

<math display="inline" id="Sliced_inverse_regression:16">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>k</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,k
  </annotation>
 </semantics>
</math>

 dimensional subspace. I.e. one can reduce to dimension of the explanatory variable from 

<math display="inline" id="Sliced_inverse_regression:17">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>p</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,p
  </annotation>
 </semantics>
</math>

 to a smaller number 

<math display="inline" id="Sliced_inverse_regression:18">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>k</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,k
  </annotation>
 </semantics>
</math>

 without losing any information.</p>

<p>An equivalent version of 

<math display="inline" id="Sliced_inverse_regression:19">
 <semantics>
  <mrow>
   <mo lspace="4.2pt" stretchy="false">(</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,(1)
  </annotation>
 </semantics>
</math>

 is: the conditional distribution of 

<math display="inline" id="Sliced_inverse_regression:20">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>Y</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,Y
  </annotation>
 </semantics>
</math>

 given 

<math display="inline" id="Sliced_inverse_regression:21">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,X
  </annotation>
 </semantics>
</math>

 depends on 

<math display="inline" id="Sliced_inverse_regression:22">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,X
  </annotation>
 </semantics>
</math>

 only through the 

<math display="inline" id="Sliced_inverse_regression:23">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>k</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,k
  </annotation>
 </semantics>
</math>

 dimensional random vector 

<math display="inline" id="Sliced_inverse_regression:24">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msubsup>
     <mi>β</mi>
     <mn>1</mn>
     <mo>⊤</mo>
    </msubsup>
    <mi>X</mi>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <msubsup>
     <mi>β</mi>
     <mi>k</mi>
     <mo>⊤</mo>
    </msubsup>
    <mi>X</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <cn type="integer">1</cn>
      </apply>
      <csymbol cd="latexml">top</csymbol>
     </apply>
     <ci>X</ci>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>k</ci>
      </apply>
      <csymbol cd="latexml">top</csymbol>
     </apply>
     <ci>X</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\beta_{1}^{\top}X,\ldots,\beta_{k}^{\top}X)
  </annotation>
 </semantics>
</math>

. This perfectly reduced vector can be seen as informative as the original 

<math display="inline" id="Sliced_inverse_regression:25">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,X
  </annotation>
 </semantics>
</math>

 in explaining 

<math display="inline" id="Sliced_inverse_regression:26">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>Y</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,Y
  </annotation>
 </semantics>
</math>

.</p>

<p>The unknown 

<math display="inline" id="Sliced_inverse_regression:27">
 <semantics>
  <mrow>
   <msubsup>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi>β</mi>
    </mpadded>
    <mi>i</mi>
    <mo>′</mo>
   </msubsup>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-′</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\beta_{i}^{\prime}s
  </annotation>
 </semantics>
</math>

 are called the <em>effective dimension reducing directions</em> (EDR-directions). The space that is spanned by these vectors is denoted the <em>effective dimension reducing space</em> (EDR-space).</p>
<h2 id="relevant-linear-algebra-background">Relevant linear algebra background</h2>

<p>To be able to visualize the model, note a short review on vector spaces:</p>

<p>For the definition of a vector space and some further properties I will refer to the article <a href="http://teachwiki.wiwi.hu-berlin.de/index.php/Basic_Linear_Algebra_and_Gram-Schmidt_Orthogonalization|Basic">Linear Algebra and Gram-Schmidt Orthogonalization</a> or any textbook in linear algebra and mention only the most important facts for understanding the model.</p>

<p>As the EDR-space is a 

<math display="inline" id="Sliced_inverse_regression:28">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>k</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,k
  </annotation>
 </semantics>
</math>

dimensional subspace, we need to know what a subspace is. A subspace of 

<math display="inline" id="Sliced_inverse_regression:29">
 <semantics>
  <msup>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\R</mtext>
   </merror>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <mtext>\R</mtext>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \R^{n}
  </annotation>
 </semantics>
</math>

 is defined as a subset 

<math display="inline" id="Sliced_inverse_regression:30">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>∈</mo>
   <msup>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\R</mtext>
    </merror>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>U</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <mtext>\R</mtext>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U\in\R^{n}
  </annotation>
 </semantics>
</math>

, if it holds that</p>

<p>

<math display="block" id="Sliced_inverse_regression:31">
 <semantics>
  <mrow>
   <mrow>
    <munder accentunder="true">
     <mi>a</mi>
     <mo>¯</mo>
    </munder>
    <mo>,</mo>
    <munder accentunder="true">
     <mi>b</mi>
     <mo>¯</mo>
    </munder>
   </mrow>
   <mo>∈</mo>
   <mi>U</mi>
   <mo>⇒</mo>
   <mrow>
    <munder accentunder="true">
     <mi>a</mi>
     <mo>¯</mo>
    </munder>
    <mo>+</mo>
    <munder accentunder="true">
     <mi>b</mi>
     <mo>¯</mo>
    </munder>
   </mrow>
   <mo>∈</mo>
   <mi>U</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <list>
      <apply>
       <ci>normal-¯</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <ci>normal-¯</ci>
       <ci>b</ci>
      </apply>
     </list>
     <ci>U</ci>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <ci>normal-¯</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <ci>normal-¯</ci>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <ci>U</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underline{a},\underline{b}\in U\Rightarrow\underline{a}+\underline{b}\in U
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Sliced_inverse_regression:32">
 <semantics>
  <mrow>
   <mrow>
    <munder accentunder="true">
     <mi>a</mi>
     <mo>¯</mo>
    </munder>
    <mo>∈</mo>
    <mi>U</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>λ</mi>
    <mo>∈</mo>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\R</mtext>
    </merror>
    <mo>⇒</mo>
    <mrow>
     <mi>λ</mi>
     <munder accentunder="true">
      <mi>a</mi>
      <mo>¯</mo>
     </munder>
    </mrow>
    <mo>∈</mo>
    <mi>U</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <ci>normal-¯</ci>
      <ci>a</ci>
     </apply>
     <ci>U</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <in></in>
      <ci>λ</ci>
      <mtext>\R</mtext>
     </apply>
     <apply>
      <ci>normal-⇒</ci>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <ci>λ</ci>
       <apply>
        <ci>normal-¯</ci>
        <ci>a</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <ci>U</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underline{a}\in U,\lambda\in\R\Rightarrow\lambda\underline{a}\in U
  </annotation>
 </semantics>
</math>

</p>

<p>Given 

<math display="inline" id="Sliced_inverse_regression:33">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <munder accentunder="true">
      <mi>a</mi>
      <mo>¯</mo>
     </munder>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <munder accentunder="true">
      <mi>a</mi>
      <mo>¯</mo>
     </munder>
     <mi>r</mi>
    </msub>
   </mrow>
   <mo>∈</mo>
   <msup>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\R</mtext>
    </merror>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <ci>a</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <ci>a</ci>
      </apply>
      <ci>r</ci>
     </apply>
    </list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <mtext>\R</mtext>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underline{a}_{1},\ldots,\underline{a}_{r}\in\R^{n}
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Sliced_inverse_regression:34">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>:=</mo>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <munder accentunder="true">
       <mi>a</mi>
       <mo>¯</mo>
      </munder>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <munder accentunder="true">
       <mi>a</mi>
       <mo>¯</mo>
      </munder>
      <mi>r</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>V</ci>
    <apply>
     <times></times>
     <ci>L</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-¯</ci>
        <ci>a</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-¯</ci>
        <ci>a</ci>
       </apply>
       <ci>r</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V:=L(\underline{a}_{1},\ldots,\underline{a}_{r})
  </annotation>
 </semantics>
</math>

, the set of all linear combinations of these vectors, is called a linear subspace and is therefore a vector space. One says, the vectors 

<math display="inline" id="Sliced_inverse_regression:35">
 <semantics>
  <mrow>
   <msub>
    <munder accentunder="true">
     <mi>a</mi>
     <mo>¯</mo>
    </munder>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <munder accentunder="true">
     <mi>a</mi>
     <mo>¯</mo>
    </munder>
    <mi>r</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <ci>a</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <ci>a</ci>
     </apply>
     <ci>r</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underline{a}_{1},\ldots,\underline{a}_{r}
  </annotation>
 </semantics>
</math>

 span 

<math display="inline" id="Sliced_inverse_regression:36">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>V</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,V
  </annotation>
 </semantics>
</math>

. But the vectors that span a space 

<math display="inline" id="Sliced_inverse_regression:37">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>V</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,V
  </annotation>
 </semantics>
</math>

 are not unique. This leads us to the concept of a basis and the dimension of a vector space:</p>

<p>A set 

<math display="inline" id="Sliced_inverse_regression:38">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <munder accentunder="true">
      <mi>b</mi>
      <mo>¯</mo>
     </munder>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <munder accentunder="true">
      <mi>b</mi>
      <mo>¯</mo>
     </munder>
     <mi>r</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>B</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <ci>b</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <ci>b</ci>
      </apply>
      <ci>r</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B=\{\underline{b}_{1},\ldots,\underline{b}_{r}\}
  </annotation>
 </semantics>
</math>

 of linear independent vectors of a vector space 

<math display="inline" id="Sliced_inverse_regression:39">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>V</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,V
  </annotation>
 </semantics>
</math>

 is called <em>basis</em> of 

<math display="inline" id="Sliced_inverse_regression:40">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>V</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,V
  </annotation>
 </semantics>
</math>

, if it holds that</p>

<p>

<math display="block" id="Sliced_inverse_regression:41">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>:=</mo>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <munder accentunder="true">
       <mi>b</mi>
       <mo>¯</mo>
      </munder>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <munder accentunder="true">
       <mi>b</mi>
       <mo>¯</mo>
      </munder>
      <mi>r</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>V</ci>
    <apply>
     <times></times>
     <ci>L</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-¯</ci>
        <ci>b</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-¯</ci>
        <ci>b</ci>
       </apply>
       <ci>r</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V:=L(\underline{b}_{1},\ldots,\underline{b}_{r})
  </annotation>
 </semantics>
</math>

</p>

<p>The dimension of 

<math display="inline" id="Sliced_inverse_regression:42">
 <semantics>
  <mrow>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mi>V</mi>
   </mpadded>
   <mspace width="veryverythickmathspace">
   </mspace>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi></mi>
     <mo>∈</mo>
     <msup>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\R</mtext>
      </merror>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">annotated</csymbol>
    <ci>V</ci>
    <apply>
     <in></in>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <mtext>\R</mtext>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,V(\in\R^{n})
  </annotation>
 </semantics>
</math>

 is equal to the maximum number of linearly independent vectors in 

<math display="inline" id="Sliced_inverse_regression:43">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>V</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,V
  </annotation>
 </semantics>
</math>

. A set of 

<math display="inline" id="Sliced_inverse_regression:44">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>n</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,n
  </annotation>
 </semantics>
</math>

 linear independent vectors of 

<math display="inline" id="Sliced_inverse_regression:45">
 <semantics>
  <msup>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\R</mtext>
   </merror>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <mtext>\R</mtext>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \R^{n}
  </annotation>
 </semantics>
</math>

 set up a basis of 

<math display="inline" id="Sliced_inverse_regression:46">
 <semantics>
  <msup>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\R</mtext>
   </merror>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <mtext>\R</mtext>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \R^{n}
  </annotation>
 </semantics>
</math>

. The dimension of a vector space is unique, as the basis itself is not. Several bases can span the same space. Of course also dependent vectors span a space, but the linear combinations of the latter can give only rise to the set of vectors lying on a straight line. As we are searching for a 

<math display="inline" id="Sliced_inverse_regression:47">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>k</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,k
  </annotation>
 </semantics>
</math>

dimensional subspace, we are interested in finding 

<math display="inline" id="Sliced_inverse_regression:48">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>k</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,k
  </annotation>
 </semantics>
</math>

 linearly independent vectors that span the 

<math display="inline" id="Sliced_inverse_regression:49">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>k</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,k
  </annotation>
 </semantics>
</math>

dimensional subspace we want to project our data on.</p>
<h2 id="curse-of-dimensionality">Curse of dimensionality</h2>

<p>The reason why we want to reduce the dimension of the data is due to the "<a href="curse_of_dimensionality" title="wikilink">curse of dimensionality</a>" and of course, for graphical purposes. The curse of dimensionality is due to rapid increase in volume adding more dimensions to a (mathematical) space. For example, consider 100 observations from support 

<math display="inline" id="Sliced_inverse_regression:50">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0,1]
  </annotation>
 </semantics>
</math>

, which cover the interval quite well, and compare it to 100 observations from the corresponding 

<math display="inline" id="Sliced_inverse_regression:51">
 <semantics>
  <mn>10</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">10</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   10
  </annotation>
 </semantics>
</math>

 dimensional unit hypersquare, which are isolated points in a vast empty space. It is easy to draw inferences about the underlying properties of the data in the first case, whereas in the latter, it is not. For more information about the curse of dimensionality, see <a href="Curse_of_dimensionality" title="wikilink">Curse of dimensionality</a>.</p>
<h2 id="inverse-regression">Inverse regression</h2>

<p>Computing the inverse regression curve (IR) means instead of looking for</p>
<ul>
<li>

<math display="inline" id="Sliced_inverse_regression:52">
 <semantics>
  <mrow>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mi>E</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>Y</mi>
    <mo stretchy="false">|</mo>
    <mi>X</mi>
    <mo>=</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">X</csymbol>
     <eq></eq>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,E[Y|X=x]
  </annotation>
 </semantics>
</math>

, which is a curve in 

<math display="inline" id="Sliced_inverse_regression:53">
 <semantics>
  <msup>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\R</mtext>
   </merror>
   <mi>p</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <mtext>\R</mtext>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \R^{p}
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>we calculate</p>
<ul>
<li>

<math display="inline" id="Sliced_inverse_regression:54">
 <semantics>
  <mrow>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mi>E</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>X</mi>
    <mo stretchy="false">|</mo>
    <mi>Y</mi>
    <mo>=</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">Y</csymbol>
     <eq></eq>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,E[X|Y=y]
  </annotation>
 </semantics>
</math>

, which is also a curve in 

<math display="inline" id="Sliced_inverse_regression:55">
 <semantics>
  <msup>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\R</mtext>
   </merror>
   <mi>p</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <mtext>\R</mtext>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \R^{p}
  </annotation>
 </semantics>
</math>

, but consisting of 

<math display="inline" id="Sliced_inverse_regression:56">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>p</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,p
  </annotation>
 </semantics>
</math>

 one-dimensional regressions.</li>
</ul>

<p>The center of the inverse regression curve is located at 

<math display="inline" id="Sliced_inverse_regression:57">
 <semantics>
  <mrow>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mi>E</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>X</mi>
     <mo stretchy="false">|</mo>
     <mi>Y</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">E</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">X</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">Y</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,E[E[X|Y]]=E[X]
  </annotation>
 </semantics>
</math>

. Therefore, the centered inverse regression curve is</p>
<ul>
<li>

<math display="inline" id="Sliced_inverse_regression:58">
 <semantics>
  <mrow>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mi>E</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>X</mi>
    <mo stretchy="false">|</mo>
    <mi>Y</mi>
    <mo>=</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>-</mo>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">Y</csymbol>
     <eq></eq>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <minus></minus>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,E[X|Y=y]-E[X]
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>which is a 

<math display="inline" id="Sliced_inverse_regression:59">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>p</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,p
  </annotation>
 </semantics>
</math>

 dimensional curve in 

<math display="inline" id="Sliced_inverse_regression:60">
 <semantics>
  <msup>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\R</mtext>
   </merror>
   <mi>p</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <mtext>\R</mtext>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \R^{p}
  </annotation>
 </semantics>
</math>

. In what follows we will consider this centered inverse regression curve and we will see that it lies on a 

<math display="inline" id="Sliced_inverse_regression:61">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>k</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,k
  </annotation>
 </semantics>
</math>

dimensional subspace spanned by 

<math display="inline" id="Sliced_inverse_regression:62">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi mathvariant="normal">Σ</mi>
    </mpadded>
    <mrow>
     <mi>x</mi>
     <mi>x</mi>
    </mrow>
   </msub>
   <msubsup>
    <mi>β</mi>
    <mi>i</mi>
    <mo>′</mo>
   </msubsup>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-′</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\Sigma_{xx}\beta_{i}\,^{\prime}s
  </annotation>
 </semantics>
</math>

.</p>

<p>But before seeing that this holds true, we will have a look at how the inverse regression curve is computed within the SIR-Algorithm, which will be introduced in detail later. What comes is the "sliced" part of SIR. We estimate the inverse regression curve by dividing the range of 

<math display="inline" id="Sliced_inverse_regression:63">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>Y</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,Y
  </annotation>
 </semantics>
</math>

 into 

<math display="inline" id="Sliced_inverse_regression:64">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>H</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,H
  </annotation>
 </semantics>
</math>

 nonoverlapping intervals (slices), to afterwards compute the sample means 

<math display="inline" id="Sliced_inverse_regression:65">
 <semantics>
  <msub>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mover accent="true">
     <mi>m</mi>
     <mo stretchy="false">^</mo>
    </mover>
   </mpadded>
   <mi>h</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>m</ci>
    </apply>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\hat{m}_{h}
  </annotation>
 </semantics>
</math>

 of each slice. <strong>These sample means are used as a crude estimate of the IR-curve</strong>, denoted as 

<math display="inline" id="Sliced_inverse_regression:66">
 <semantics>
  <mrow>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mi>m</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,m(y)
  </annotation>
 </semantics>
</math>

. There are several ways to define the slices, either in a way that in each slice are equally much observations, or we define a fixed range for each slice, so that we then get different proportions of the 

<math display="inline" id="Sliced_inverse_regression:67">
 <semantics>
  <mrow>
   <msubsup>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi>y</mi>
    </mpadded>
    <mi>i</mi>
    <mo>′</mo>
   </msubsup>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-′</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,y_{i}\,^{\prime}s
  </annotation>
 </semantics>
</math>

 that fall into each slice.</p>
<h2 id="inverse-regression-versus-dimension-reduction">Inverse regression versus dimension reduction</h2>

<p>As just mentioned, the centered inverse regression curve lies on a 

<math display="inline" id="Sliced_inverse_regression:68">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>k</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,k
  </annotation>
 </semantics>
</math>

dimensional subspace spanned by 

<math display="inline" id="Sliced_inverse_regression:69">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi mathvariant="normal">Σ</mi>
    </mpadded>
    <mrow>
     <mi>x</mi>
     <mi>x</mi>
    </mrow>
   </msub>
   <msubsup>
    <mi>β</mi>
    <mi>i</mi>
    <mo>′</mo>
   </msubsup>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-′</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\Sigma_{xx}\beta_{i}\,^{\prime}s
  </annotation>
 </semantics>
</math>

 (and therefore also the crude estimate we compute). This is the connection between our Model and Inverse Regression. We shall see that this is true, with only one condition on the design distribution that must hold. This condition is, that:</p>

<p>

<math display="block" id="Sliced_inverse_regression:70">
 <semantics>
  <mrow>
   <mo rspace="4.2pt">∀</mo>
   <munder accentunder="true">
    <mi>b</mi>
    <mo>¯</mo>
   </munder>
   <mo>∈</mo>
   <msup>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\R</mtext>
    </merror>
    <mi>p</mi>
   </msup>
   <mo rspace="4.2pt">:</mo>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msup>
     <mi>b</mi>
     <mo>⊤</mo>
    </msup>
    <mi>X</mi>
    <mo stretchy="false">|</mo>
    <msubsup>
     <mi>β</mi>
     <mn>1</mn>
     <mo>⊤</mo>
    </msubsup>
    <mi>X</mi>
    <mo>=</mo>
    <msubsup>
     <mi>β</mi>
     <mn>1</mn>
     <mo>⊤</mo>
    </msubsup>
    <mi>x</mi>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msubsup>
     <mi>β</mi>
     <mi>k</mi>
     <mo>⊤</mo>
    </msubsup>
    <mi>X</mi>
    <mo>=</mo>
    <msubsup>
     <mi>β</mi>
     <mi>k</mi>
     <mo>⊤</mo>
    </msubsup>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>c</mi>
    <mn>0</mn>
   </msub>
   <mo>+</mo>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>k</mi>
   </munderover>
   <msub>
    <mi>c</mi>
    <mi>i</mi>
   </msub>
   <msubsup>
    <mi>β</mi>
    <mi>i</mi>
    <mo>⊤</mo>
   </msubsup>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <ci>normal-¯</ci>
     <ci>b</ci>
    </apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <mtext>\R</mtext>
     <ci>p</ci>
    </apply>
    <ci>normal-:</ci>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <csymbol cd="latexml">top</csymbol>
     </apply>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <cn type="integer">1</cn>
      </apply>
      <csymbol cd="latexml">top</csymbol>
     </apply>
     <csymbol cd="unknown">X</csymbol>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <cn type="integer">1</cn>
      </apply>
      <csymbol cd="latexml">top</csymbol>
     </apply>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>k</ci>
      </apply>
      <csymbol cd="latexml">top</csymbol>
     </apply>
     <csymbol cd="unknown">X</csymbol>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>k</ci>
      </apply>
      <csymbol cd="latexml">top</csymbol>
     </apply>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">0</cn>
    </apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>i</ci>
     </apply>
     <csymbol cd="latexml">top</csymbol>
    </apply>
    <csymbol cd="unknown">x</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\,\underline{b}\in\R^{p}:\,E[b^{\top}X|\beta_{1}^{\top}X=\beta_{1}^{%
\top}x,\ldots,\beta_{k}^{\top}X=\beta_{k}^{\top}x)=c_{0}+\sum_{i=1}^{k}c_{i}%
\beta_{i}^{\top}x
  </annotation>
 </semantics>
</math>

</p>

<p>I.e. the conditional expectation is linear in 

<math display="inline" id="Sliced_inverse_regression:71">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>β</mi>
     <mn>1</mn>
    </msub>
    <mi>X</mi>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>β</mi>
     <mi>k</mi>
    </msub>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>X</ci>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>k</ci>
     </apply>
     <ci>X</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{1}X,\ldots,\beta_{k}X
  </annotation>
 </semantics>
</math>


, that is, for some constants 

<math display="inline" id="Sliced_inverse_regression:72">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>c</mi>
    <mi>K</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>K</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{0},\ldots,c_{K}
  </annotation>
 </semantics>
</math>

. This condition is satisfied when the distribution of 

<math display="inline" id="Sliced_inverse_regression:73">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,X
  </annotation>
 </semantics>
</math>

 is elliptically symmetric (e.g. the normal distribution). This seems to be a pretty strong requirement. It could help, for example, to closer examine the distribution of the data, so that outliers can be removed or clusters can be separated before analysis</p>

<p>Given this condition and 

<math display="inline" id="Sliced_inverse_regression:74">
 <semantics>
  <mrow>
   <mo lspace="4.2pt" stretchy="false">(</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,(1)
  </annotation>
 </semantics>
</math>

, it is indeed true that the centered inverse regression curve 

<math display="inline" id="Sliced_inverse_regression:75">
 <semantics>
  <mrow>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mi>E</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>X</mi>
    <mo stretchy="false">|</mo>
    <mi>Y</mi>
    <mo>=</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>-</mo>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">Y</csymbol>
     <eq></eq>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <minus></minus>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,E[X|Y=y]-E[X]
  </annotation>
 </semantics>
</math>

 is contained in the linear subspace spanned by 

<math display="inline" id="Sliced_inverse_regression:76">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi mathvariant="normal">Σ</mi>
    </mpadded>
    <mrow>
     <mi>x</mi>
     <mi>x</mi>
    </mrow>
   </msub>
   <msub>
    <mi>β</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>K</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>k</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">k</csymbol>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <csymbol cd="unknown">K</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\Sigma_{xx}\beta_{k}(k=1,\ldots,K)
  </annotation>
 </semantics>
</math>


, where 

<math display="inline" id="Sliced_inverse_regression:77">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi mathvariant="normal">Σ</mi>
    </mpadded>
    <mrow>
     <mi>x</mi>
     <mi>x</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>C</mi>
    <mi>o</mi>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>o</ci>
     <ci>v</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\Sigma_{xx}=Cov(X)
  </annotation>
 </semantics>
</math>

. The proof is provided by Duan and Li in <em>Journal of the American Statistical Association</em> (1991).</p>
<h2 id="estimation-of-the-edr-directions">Estimation of the EDR-directions</h2>

<p>After having had a look at all the theoretical properties, our aim is now to estimate the EDR-directions. For that purpose, we conduct a (weighted) principal component analysis for the sample means 

<math display="inline" id="Sliced_inverse_regression:78">
 <semantics>
  <mrow>
   <msubsup>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mover accent="true">
      <mi>m</mi>
      <mo stretchy="false">^</mo>
     </mover>
    </mpadded>
    <mi>h</mi>
    <mo>′</mo>
   </msubsup>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>m</ci>
      </apply>
      <ci>h</ci>
     </apply>
     <ci>normal-′</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\hat{m}_{h}\,^{\prime}s
  </annotation>
 </semantics>
</math>

, after having standardized 

<math display="inline" id="Sliced_inverse_regression:79">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,X
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Sliced_inverse_regression:80">
 <semantics>
  <mrow>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mi>Z</mi>
   </mpadded>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi mathvariant="normal">Σ</mi>
     <mrow>
      <mi>x</mi>
      <mi>x</mi>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>X</mi>
      <mo>-</mo>
      <mrow>
       <mi>E</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Z</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Σ</ci>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <set>
      <apply>
       <minus></minus>
       <ci>X</ci>
       <apply>
        <times></times>
        <ci>E</ci>
        <ci>X</ci>
       </apply>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,Z=\Sigma_{xx}^{-1/2}\{X-E(X)\}
  </annotation>
 </semantics>
</math>

. Corresponding to the theorem above, the IR-curve 

<math display="inline" id="Sliced_inverse_regression:81">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi>m</mi>
    </mpadded>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>Z</mi>
    <mo stretchy="false">|</mo>
    <mi>Y</mi>
    <mo>=</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">1</cn>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">Z</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">Y</csymbol>
     <eq></eq>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,m_{1}(y)=E[Z|Y=y]
  </annotation>
 </semantics>
</math>


 lies in the space spanned by 

<math display="inline" id="Sliced_inverse_regression:82">
 <semantics>
  <mrow>
   <mo lspace="4.2pt" stretchy="false">(</mo>
   <msub>
    <mi>η</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>η</mi>
    <mi>k</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>η</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>η</ci>
     <ci>k</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,(\eta_{1},\ldots,\eta_{k})
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Sliced_inverse_regression:83">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi>η</mi>
    </mpadded>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi mathvariant="normal">Σ</mi>
     <mrow>
      <mi>x</mi>
      <mi>x</mi>
     </mrow>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msubsup>
    <msub>
     <mi>β</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>η</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Σ</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\eta_{i}=\Sigma^{1/2}_{xx}\beta_{i}
  </annotation>
 </semantics>
</math>

. (Due to the terminology introduced before, the 

<math display="inline" id="Sliced_inverse_regression:84">
 <semantics>
  <mrow>
   <msubsup>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi>η</mi>
    </mpadded>
    <mi>i</mi>
    <mo>′</mo>
   </msubsup>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>η</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-′</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\eta_{i}\,^{\prime}s
  </annotation>
 </semantics>
</math>

 are called the <em>standardized effective dimension reducing directions</em>.) As a consequence, the covariance matrix 

<math display="inline" id="Sliced_inverse_regression:85">
 <semantics>
  <mrow>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mi>c</mi>
   </mpadded>
   <mi>o</mi>
   <mi>v</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>Z</mi>
     <mo stretchy="false">|</mo>
     <mi>Y</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">c</csymbol>
    <csymbol cd="unknown">o</csymbol>
    <csymbol cd="unknown">v</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">E</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">Z</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">Y</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,cov[E[Z|Y]]
  </annotation>
 </semantics>
</math>

 is degenerate in any direction orthogonal to the 

<math display="inline" id="Sliced_inverse_regression:86">
 <semantics>
  <mrow>
   <msubsup>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi>η</mi>
    </mpadded>
    <mi>i</mi>
    <mo>′</mo>
   </msubsup>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>η</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-′</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\eta_{i}\,^{\prime}s
  </annotation>
 </semantics>
</math>


. Therefore, the eigenvectors 

<math display="inline" id="Sliced_inverse_regression:87">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi>η</mi>
    </mpadded>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>K</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>η</ci>
     <ci>k</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">k</csymbol>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <csymbol cd="unknown">K</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\eta_{k}(k=1,\ldots,K)
  </annotation>
 </semantics>
</math>

 associated with the 

<math display="inline" id="Sliced_inverse_regression:88">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>K</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,K
  </annotation>
 </semantics>
</math>

 largest eigenvalues are the standardized EDR-directions.</p>

<p>Back to PCA. That is, we calculate the estimate for 

<math display="inline" id="Sliced_inverse_regression:89">
 <semantics>
  <mrow>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mi>C</mi>
   </mpadded>
   <mi>o</mi>
   <mi>v</mi>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <msub>
      <mi>m</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>o</ci>
    <ci>v</ci>
    <set>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>y</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,Cov\{m_{1}(y)\}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Sliced_inverse_regression:90">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>V</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>n</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>S</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>n</mi>
       <mi>s</mi>
      </msub>
      <msub>
       <mover accent="true">
        <mi>z</mi>
        <mo stretchy="false">¯</mo>
       </mover>
       <mi>s</mi>
      </msub>
      <msubsup>
       <mover accent="true">
        <mi>z</mi>
        <mo stretchy="false">¯</mo>
       </mover>
       <mi>s</mi>
       <mo>⊤</mo>
      </msubsup>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-^</ci>
     <ci>V</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>S</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>s</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-¯</ci>
         <ci>z</ci>
        </apply>
        <ci>s</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-¯</ci>
          <ci>z</ci>
         </apply>
         <ci>s</ci>
        </apply>
        <csymbol cd="latexml">top</csymbol>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{V}=n^{-1}\sum_{i=1}^{S}n_{s}\bar{z}_{s}\bar{z}_{s}^{\top}
  </annotation>
 </semantics>
</math>

</p>

<p>and identify the eigenvalues 

<math display="inline" id="Sliced_inverse_regression:91">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>λ</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>λ</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\lambda}_{i}
  </annotation>
 </semantics>
</math>


 and the eigenvectors 

<math display="inline" id="Sliced_inverse_regression:92">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>η</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>η</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\eta}_{i}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Sliced_inverse_regression:93">
 <semantics>
  <mover accent="true">
   <mi>V</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{V}
  </annotation>
 </semantics>
</math>

, which are the standardized EDR-directions. (For more details about that see next section: Algorithm.) Remember that the main idea of PC transformation is to find the most informative projections that maximize variance!</p>

<p>Note that in some situations SIR does not find the EDR-directions. One can overcome this difficulty by considering the conditional covariance 

<math display="inline" id="Sliced_inverse_regression:94">
 <semantics>
  <mrow>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mi>C</mi>
   </mpadded>
   <mi>o</mi>
   <mi>v</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">|</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <csymbol cd="unknown">o</csymbol>
    <csymbol cd="unknown">v</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,Cov(X|Y)
  </annotation>
 </semantics>
</math>

. The principle remains the same as before, but one investigates the IR-curve with the conditional covariance instead of the conditional expectation. For further details and an example where SIR fails, see Härdle and Simar (2003).</p>
<h2 id="algorithm">Algorithm</h2>

<p>The algorithm to estimate the EDR-directions via SIR is as follows. It is taken from the textbook <em>Applied Multivariate Statistical Analysis</em> (Härdle and Simar 2003)</p>

<p><strong>1.</strong> Let 

<math display="inline" id="Sliced_inverse_regression:95">
 <semantics>
  <msub>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mi mathvariant="normal">Σ</mi>
   </mpadded>
   <mrow>
    <mi>x</mi>
    <mi>x</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Σ</ci>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\Sigma_{xx}
  </annotation>
 </semantics>
</math>

 be the covariance matrix of 

<math display="inline" id="Sliced_inverse_regression:96">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,X
  </annotation>
 </semantics>
</math>


. Standardize 

<math display="inline" id="Sliced_inverse_regression:97">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,X
  </annotation>
 </semantics>
</math>

 to</p>

<p>

<math display="block" id="Sliced_inverse_regression:98">
 <semantics>
  <mrow>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mi>Z</mi>
   </mpadded>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi mathvariant="normal">Σ</mi>
     <mrow>
      <mi>x</mi>
      <mi>x</mi>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>X</mi>
      <mo>-</mo>
      <mrow>
       <mi>E</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Z</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Σ</ci>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <set>
      <apply>
       <minus></minus>
       <ci>X</ci>
       <apply>
        <times></times>
        <ci>E</ci>
        <ci>X</ci>
       </apply>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,Z=\Sigma_{xx}^{-1/2}\{X-E(X)\}
  </annotation>
 </semantics>
</math>

</p>

<p>(We can therefore rewrite 

<math display="inline" id="Sliced_inverse_regression:99">
 <semantics>
  <mrow>
   <mo lspace="4.2pt" stretchy="false">(</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,(1)
  </annotation>
 </semantics>
</math>

 as</p>

<p>

<math display="block" id="Sliced_inverse_regression:100">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msubsup>
       <mi>η</mi>
       <mn>1</mn>
       <mo>⊤</mo>
      </msubsup>
      <mi>Z</mi>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <msubsup>
       <mi>η</mi>
       <mi>k</mi>
       <mo>⊤</mo>
      </msubsup>
      <mi>Z</mi>
     </mrow>
     <mo>,</mo>
     <mi>ε</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Y</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>η</ci>
         <cn type="integer">1</cn>
        </apply>
        <csymbol cd="latexml">top</csymbol>
       </apply>
       <ci>Z</ci>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>η</ci>
         <ci>k</ci>
        </apply>
        <csymbol cd="latexml">top</csymbol>
       </apply>
       <ci>Z</ci>
      </apply>
      <ci>ε</ci>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y=f(\eta_{1}^{\top}Z,\ldots,\eta_{k}^{\top}Z,\varepsilon)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Sliced_inverse_regression:101">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi>η</mi>
    </mpadded>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>β</mi>
      <mi>k</mi>
     </msub>
     <msubsup>
      <mi mathvariant="normal">Σ</mi>
      <mrow>
       <mi>x</mi>
       <mi>x</mi>
      </mrow>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msubsup>
    </mrow>
    <mrow>
     <mo rspace="5.3pt">∀</mo>
     <mi>k</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>η</ci>
     <ci>k</ci>
    </apply>
    <list>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Σ</ci>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>k</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\eta_{k}=\beta_{k}\Sigma_{xx}^{1/2}\quad\forall\;k
  </annotation>
 </semantics>
</math>


 For the standardized variable Z it holds that 

<math display="inline" id="Sliced_inverse_regression:102">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi>E</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>Z</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>Z</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,E[Z]=0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sliced_inverse_regression:103">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi>C</mi>
    </mpadded>
    <mi>o</mi>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>o</ci>
     <ci>v</ci>
     <ci>Z</ci>
    </apply>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,Cov(Z)=I
  </annotation>
 </semantics>
</math>

.)</p>

<p><strong>2.</strong> Divide the range of 

<math display="inline" id="Sliced_inverse_regression:104">
 <semantics>
  <msub>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mi>y</mi>
   </mpadded>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,y_{i}
  </annotation>
 </semantics>
</math>

 into 

<math display="inline" id="Sliced_inverse_regression:105">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>S</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,S
  </annotation>
 </semantics>
</math>

 nonoverlapping slices 

<math display="inline" id="Sliced_inverse_regression:106">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi>H</mi>
    </mpadded>
    <mi>s</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo rspace="5.3pt">.</mo>
   <msub>
    <mi>n</mi>
    <mi>s</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>s</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>s</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,H_{s}(s=1,\ldots,S).\;n_{s}
  </annotation>
 </semantics>
</math>


 is the number of observations within each slice and 

<math display="inline" id="Sliced_inverse_regression:107">
 <semantics>
  <msub>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mi>I</mi>
   </mpadded>
   <msub>
    <mi>H</mi>
    <mi>s</mi>
   </msub>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,I_{H_{s}}
  </annotation>
 </semantics>
</math>

 the indicator function for this slice:</p>

<p>

<math display="block" id="Sliced_inverse_regression:108">
 <semantics>
  <mrow>
   <msub>
    <mi>n</mi>
    <mi>s</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>I</mi>
      <msub>
       <mi>H</mi>
       <mi>s</mi>
      </msub>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <ci>s</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{s}=\sum_{i=1}^{n}I_{H_{s}}(y_{i})
  </annotation>
 </semantics>
</math>

</p>

<p><strong>3.</strong> Compute the mean of 

<math display="inline" id="Sliced_inverse_regression:109">
 <semantics>
  <msub>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mi>z</mi>
   </mpadded>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,z_{i}
  </annotation>
 </semantics>
</math>

 over all slices, which is a crude estimate 

<math display="inline" id="Sliced_inverse_regression:110">
 <semantics>
  <msub>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mover accent="true">
     <mi>m</mi>
     <mo stretchy="false">^</mo>
    </mover>
   </mpadded>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>m</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\hat{m}_{1}
  </annotation>
 </semantics>
</math>

 of the inverse regression curve 

<math display="inline" id="Sliced_inverse_regression:111">
 <semantics>
  <msub>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mi>m</mi>
   </mpadded>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,m_{1}
  </annotation>
 </semantics>
</math>


:</p>

<p>

<math display="block" id="Sliced_inverse_regression:112">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mover accent="true">
      <mi>z</mi>
      <mo stretchy="false">¯</mo>
     </mover>
    </mpadded>
    <mi>s</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>n</mi>
     <mi>s</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>z</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>I</mi>
       <msub>
        <mi>H</mi>
        <mi>s</mi>
       </msub>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <ci>z</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>s</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>I</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>H</ci>
         <ci>s</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\bar{z}_{s}=n_{s}^{-1}\sum_{i=1}^{n}z_{i}I_{H_{s}}(y_{i})
  </annotation>
 </semantics>
</math>

</p>

<p><strong>4.</strong> Calculate the estimate for 

<math display="inline" id="Sliced_inverse_regression:113">
 <semantics>
  <mrow>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mi>C</mi>
   </mpadded>
   <mi>o</mi>
   <mi>v</mi>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <msub>
      <mi>m</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>o</ci>
    <ci>v</ci>
    <set>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>y</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,Cov\{m_{1}(y)\}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Sliced_inverse_regression:114">
 <semantics>
  <mrow>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mover accent="true">
     <mi>V</mi>
     <mo stretchy="false">^</mo>
    </mover>
   </mpadded>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>n</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>S</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>n</mi>
       <mi>s</mi>
      </msub>
      <msub>
       <mover accent="true">
        <mi>z</mi>
        <mo stretchy="false">¯</mo>
       </mover>
       <mi>s</mi>
      </msub>
      <msubsup>
       <mover accent="true">
        <mi>z</mi>
        <mo stretchy="false">¯</mo>
       </mover>
       <mi>s</mi>
       <mo>⊤</mo>
      </msubsup>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-^</ci>
     <ci>V</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>S</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>s</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-¯</ci>
         <ci>z</ci>
        </apply>
        <ci>s</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-¯</ci>
          <ci>z</ci>
         </apply>
         <ci>s</ci>
        </apply>
        <csymbol cd="latexml">top</csymbol>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\hat{V}=n^{-1}\sum_{i=1}^{S}n_{s}\bar{z}_{s}\bar{z}_{s}^{\top}
  </annotation>
 </semantics>
</math>

</p>

<p><strong>5.</strong> Identify the eigenvalues 

<math display="inline" id="Sliced_inverse_regression:115">
 <semantics>
  <msub>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mover accent="true">
     <mi>λ</mi>
     <mo stretchy="false">^</mo>
    </mover>
   </mpadded>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>λ</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\hat{\lambda}_{i}
  </annotation>
 </semantics>
</math>

 and the eigenvectors 

<math display="inline" id="Sliced_inverse_regression:116">
 <semantics>
  <msub>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mover accent="true">
     <mi>η</mi>
     <mo stretchy="false">^</mo>
    </mover>
   </mpadded>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>η</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\hat{\eta}_{i}
  </annotation>
 </semantics>
</math>


 of 

<math display="inline" id="Sliced_inverse_regression:117">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mover accent="true">
    <mi>V</mi>
    <mo stretchy="false">^</mo>
   </mover>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\hat{V}
  </annotation>
 </semantics>
</math>

, which are the standardized EDR-directions.</p>

<p><strong>6.</strong> Transform the standardized EDR-directions back to the original scale. The estimates for the EDR-directions are given by:</p>

<p>

<math display="block" id="Sliced_inverse_regression:118">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mover accent="true">
      <mi>β</mi>
      <mo stretchy="false">^</mo>
     </mover>
    </mpadded>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mover accent="true">
      <mi mathvariant="normal">Σ</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mi>x</mi>
      <mi>x</mi>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </mrow>
    </msubsup>
    <msub>
     <mover accent="true">
      <mi>η</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>β</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>normal-Σ</ci>
       </apply>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>η</ci>
      </apply>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\hat{\beta}_{i}=\hat{\Sigma}_{xx}^{-1/2}\hat{\eta}_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>(which are not necessarily orthogonal)</p>

<p>For examples, see the book by Härdle and Simar (2003).</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Curse_of_dimensionality" title="wikilink">Curse of dimensionality</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Li, K-C. (1991) "Sliced Inverse Regression for Dimension Reduction", <a href="Journal_of_the_American_Statistical_Association" title="wikilink">Journal of the American Statistical Association</a>, 86, 316–327 <a href="http://www.jstor.org/stable/2290563">Jstor</a></li>
</ul>
<ul>
<li>Cook, R.D. and Sanford Weisberg, S. (1991) "Sliced Inverse Regression for Dimension Reduction: Comment", <a href="Journal_of_the_American_Statistical_Association" title="wikilink">Journal of the American Statistical Association</a>, 86, 328–332 <a href="http://www.jstor.org/stable/2290564">Jstor</a></li>
</ul>
<ul>
<li>Härdle, W. and Simar, L. (2003) <em>Applied Multivariate Statistical Analysis</em>, Springer Verlag. ISBN 3-540-03079-4</li>
</ul>
<ul>
<li>Kurzfassung zur Vorlesung Mathematik II im Sommersemester 2005, A. Brandt</li>
</ul>
<h2 id="external-links">External links</h2>

<p>"</p>

<p><a href="Category:Regression_analysis" title="wikilink">Category:Regression analysis</a> <a href="Category:Dimension_reduction" title="wikilink">Category:Dimension reduction</a></p>
</body>
</html>
