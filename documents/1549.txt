   KCDSA      KCDSA   KCDSA ( Korean Certificate-based Digital Signature Algorithm ) is a digital signature algorithm created by a team led by the Korea Internet & Security Agency (KISA). It is an ElGamal variant, similar to the Digital Signature Algorithm and GOST R 34.10-94 . The standard algorithm is implemented over    G  F   (  p  )       G  F  p    GF(p)   , but an elliptic curve variant ( EC-KCDSA ) is also specified.  KCDSA requires a collision-resistant cryptographic hash function that can produce a variable-sized output (from 128 to 256 bits, in 32-bit increments). HAS-160 , another Korean standard, is the suggested choice.  Domain parameters      p   p   p   : a large prime such that     |  p  |   =   512  +   256  i          p     512    256  i      |p|=512+256i   for    i  =   0  ,  1  ,  …  ,  6       i   0  1  normal-…  6     i=0,1,\dots,6   .     q   q   q   : a prime factor of    p  -  1      p  1    p-1   such that     |  q  |   =   128  +   32  j          q     128    32  j      |q|=128+32j   for    j  =   0  ,  1  ,  …  ,  4       j   0  1  normal-…  4     j=0,1,\dots,4   .     g   g   g   : a base element of order    q  ∈   G  F   (  p  )        q    G  F  p     q\in GF(p)   .   User parameters      x   x   x   : signer's private signature key such that    x  ∈   Z  q       x   subscript  Z  q     x\in Z_{q}   .     y   y   y   : signer's public verification key computed by     y  =    g   x  ¯       (   mod  p   )     ,      y   annotated   superscript  g   normal-¯  x     pmod  p      y=g^{\bar{x}}\;\;(\mathop{{\rm mod}}p),   where     x  ¯   =    x   -  1       (   mod  q   )         normal-¯  x    annotated   superscript  x    1     pmod  q      \bar{x}=x^{-1}\;\;(\mathop{{\rm mod}}q)   .     z   z   z   : a hash-value of Cert Data , i.e.,    z  =   h   (   C  e  r  t  D  a  t  a   )        z    h    C  e  r  t  D  a  t  a      z=h(CertData)   .   Signing   Signer randomly picks an integer    k  ∈   Z  q       k   subscript  Z  q     k\in Z_{q}   and computes    w  =    g  k   mod  p       w   modulo   superscript  g  k   p     w=g^{k}\mod{p}     Then computes the firs part    r  =   h   (  w  )        r    h  w     r=h(w)     Then computes the second part    s  =  x   (  k  -  r  ⊕  h   (  z  |  |  m  )   )    (   mod  q   )      fragments  s   x   fragments  normal-(  k   r  direct-sum  h   fragments  normal-(  z  normal-|  normal-|  m  normal-)   normal-)    pmod  q     s=x(k-r\oplus h(z||m))\;\;(\mathop{{\rm mod}}q)     The signature is    (  r  ,  s  )     r  s    (r,s)      Verifying   Verifier computes    e  =  r  ⊕  h   (  z  |  |  m  )      fragments  e   r  direct-sum  h   fragments  normal-(  z  normal-|  normal-|  m  normal-)     e=r\oplus h(z||m)     Then he checks if    r  =   h   (     y  s   ⋅   g  e    mod  p   )        r    h   modulo   normal-⋅   superscript  y  s    superscript  g  e    p      r=h(y^{s}\cdot g^{e}\mod{p})      External links   KCDSA specification and analysis   "  Category:Digital signature schemes  Category:Elliptic curve cryptography  Category:Public-key cryptography   