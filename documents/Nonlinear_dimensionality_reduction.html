<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1916">Nonlinear dimensionality reduction</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Nonlinear dimensionality reduction</h1>
<hr/>

<p><a class="uri" href="High-dimensional" title="wikilink">High-dimensional</a> data, meaning data that requires more than two or three dimensions to represent, can be difficult to interpret. One approach to simplification is to assume that the data of interest lie on an embedded non-linear <a class="uri" href="manifold" title="wikilink">manifold</a> within the higher-dimensional space. If the manifold is of low enough dimension, the data can be visualised in the low-dimensional space.</p>
<figure><b>(Figure)</b>
<figcaption>Top-left: a 3D dataset of 1000 points in a spiraling band (a.k.a. the <a href="Swiss_roll" title="wikilink">Swiss roll</a>) with a rectangular hole in the middle. Top-right: the original 2D manifold used to generate the 3D dataset. Bottom left and right: 2D recoveries of the manifold respectively using the <a href="Nonlinear_dimensionality_reduction#Locally-linear_embedding" title="wikilink">LLE</a> and <a href="Nonlinear_dimensionality_reduction#Hessian_Locally-Linear_Embedding_(Hessian_LLE)" title="wikilink">Hessian LLE</a> algorithms as implemented by the Modular Data Processing toolkit.</figcaption>
</figure>

<p>Below is a summary of some of the important algorithms from the history of manifold learning and <strong>nonlinear dimensionality reduction</strong> (NLDR).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Many of these non-linear <a href="dimensionality_reduction" title="wikilink">dimensionality reduction</a> methods are related to the linear methods listed below. Non-linear methods can be broadly classified into two groups: those that provide a mapping (either from the high-dimensional space to the low-dimensional embedding or vice versa), and those that just give a visualisation. In the context of <a href="machine_learning" title="wikilink">machine learning</a>, mapping methods may be viewed as a preliminary <a href="feature_extraction" title="wikilink">feature extraction</a> step, after which <a href="Pattern_recognition#Algorithms" title="wikilink"> pattern recognition algorithms</a> are applied. Typically those that just give a visualisation are based on proximity data – that is, <a class="uri" href="distance" title="wikilink">distance</a> measurements.</p>
<h2 id="linear-methods">Linear methods</h2>
<ul>
<li><a href="Independent_component_analysis" title="wikilink">Independent component analysis</a> (ICA).</li>
<li><a href="Principal_component_analysis" title="wikilink">Principal component analysis</a> (PCA) (also called <a href="Karhunen–Loève_transform" title="wikilink">Karhunen–Loève transform</a> — KLT).</li>
<li><a href="Singular_value_decomposition" title="wikilink">Singular value decomposition</a> (SVD).</li>
<li><a href="Factor_analysis" title="wikilink">Factor analysis</a>.</li>
</ul>
<h2 id="uses-for-nldr">Uses for NLDR</h2>

<p>Consider a dataset represented as a matrix (or a database table), such that each row represents a set of attributes (or features or dimensions) that describe a particular instance of something. If the number of attributes is large, then the space of unique possible rows is exponentially large. Thus, the larger the dimensionality, the more difficult it becomes to sample the space. This causes many problems. Algorithms that operate on high-dimensional data tend to have a very high time complexity. Many machine learning algorithms, for example, struggle with high-dimensional data. This has become known as the <a href="curse_of_dimensionality" title="wikilink">curse of dimensionality</a>. Reducing data into fewer dimensions often makes analysis algorithms more efficient, and can help machine learning algorithms make more accurate predictions.</p>

<p>Humans often have difficulty comprehending data in many dimensions. Thus, reducing data to a small number of dimensions is useful for visualization purposes.</p>
<figure><b>(Figure)</b>
<figcaption> Plot of the two-dimensional points that results from using a NLDR algorithm. In this case, Manifold Sculpting used to reduce the data into just two dimensions (rotation and scale).</figcaption>
</figure>

<p>The reduced-dimensional representations of data are often referred to as "intrinsic variables". This description implies that these are the values from which the data was produced. For example, consider a dataset that contains images of a letter 'A', which has been scaled and rotated by varying amounts. Each image has 32x32 pixels. Each image can be represented as a vector of 1024 pixel values. Each row is a sample on a two-dimensional manifold in 1024-dimensional space (a <a href="Hamming_space" title="wikilink">Hamming space</a>). The intrinsic dimensionality is two, because two variables (rotation and scale) were varied in order to produce the data. Information about the shape or look of a letter 'A' is not part of the intrinsic variables because it is the same in every instance. Nonlinear dimensionality reduction will discard the correlated information (the letter 'A') and recover only the varying information (rotation and scale). The image to the right shows sample images from this dataset (to save space, not all input images are shown), and a plot of the two-dimensional points that results from using a NLDR algorithm (in this case, Manifold Sculpting was used) to reduce the data into just two dimensions.</p>
<figure><b>(Figure)</b>
<figcaption>PCA (a linear dimensionality reduction algorithm) is used to reduce this same dataset into two dimensions, the resulting values are not so well organized.</figcaption>
</figure>

<p>By comparison, if PCA (a linear dimensionality reduction algorithm) is used to reduce this same dataset into two dimensions, the resulting values are not so well organized. This demonstrates that the high-dimensional vectors (each representing a letter 'A') that sample this manifold vary in a non-linear manner.</p>

<p>It should be apparent, therefore, that NLDR has several applications in the field of computer-vision. For example, consider a robot that uses a camera to navigate in a closed static environment. The images obtained by that camera can be considered to be samples on a manifold in high-dimensional space, and the intrinsic variables of that manifold will represent the robot's position and orientation. This utility is not limited to robots. <a href="Dynamical_systems" title="wikilink">Dynamical systems</a>, a more general class of systems, which includes robots, are defined in terms of a manifold. Active research in NLDR seeks to unfold the observation manifolds associated with dynamical systems to develop techniques for modeling such systems and enable them to operate autonomously.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="manifold-learning-algorithms">Manifold learning algorithms</h2>

<p>Some of the more prominent manifold learning algorithms are listed below (in approximately chronological order). An algorithm may learn an <em>internal model</em> of the data, which can be used to map points unavailable at training time into the embedding in a process often called out-of-sample extension.</p>
<h3 id="sammons-mapping">Sammon's mapping</h3>

<p><a href="Sammon's_mapping" title="wikilink">Sammon's mapping</a> is one of the first and most popular NLDR techniques.</p>
<figure><b>(Figure)</b>
<figcaption>Approximation of a principal curve by one-dimensional <a href="Self-organizing_map" title="wikilink">SOM</a> (a <a href="broken_line" title="wikilink">broken line</a> with red squares, 20 nodes). The first <a href="Principal_component_analysis" title="wikilink">principal component</a> is presented by a blue straight line. Data points are the small grey circles. For PCA, the <a href="Fraction_of_variance_unexplained" title="wikilink">Fraction of variance unexplained</a> in this example is 23.23%, for SOM it is 6.86%.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></figcaption>
</figure>
<h3 id="self-organizing-map">Self-organizing map</h3>

<p>The <a href="self-organizing_map" title="wikilink">self-organizing map</a> (SOM, also called <em>Kohonen map</em>) and its probabilistic variant <a href="generative_topographic_mapping" title="wikilink">generative topographic mapping</a> (GTM) use a point representation in the embedded space to form a <a href="latent_variable_model" title="wikilink">latent variable model</a> based on a non-linear mapping from the embedded space to the high-dimensional space.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> These techniques are related to work on <a href="density_networks" title="wikilink">density networks</a>, which also are based around the same probabilistic model.</p>
<h3 id="principal-curves-and-manifolds">Principal curves and manifolds</h3>
<figure><b>(Figure)</b>
<figcaption> Application of principal curves: Nonlinear quality of life index.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Points represent data of the <a href="United_Nations" title="wikilink">UN</a> 171 countries in 4-dimensional space formed by the values of 4 indicators: <a href="Gross_domestic_product" title="wikilink">gross product per capita</a>, <a href="life_expectancy" title="wikilink">life expectancy</a>, <a href="infant_mortality" title="wikilink">infant mortality</a>, <a class="uri" href="tuberculosis" title="wikilink">tuberculosis</a> incidence. Different forms and colors correspond to various geographical locations. Red bold line represents the <strong>principal curve</strong>, approximating the dataset. This principal curve was produced by the method of <a href="elastic_map" title="wikilink">elastic map</a>. Software is available for free non-commercial use.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></figcaption>
</figure>

<p><strong><a href="Principal_curve" title="wikilink">Principal curves</a> and manifolds</strong> give the natural geometric framework for nonlinear dimensionality reduction and extend the geometric interpretation of PCA by explicitly constructing an embedded manifold, and by encoding using standard geometric projection onto the manifold. This approach was proposed by <a href="Trevor_Hastie" title="wikilink">Trevor Hastie</a> in his thesis (1984)<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> and developed further by many authors.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> How to define the "simplicity" of the manifold is problem-dependent, however, it is commonly measured by the intrinsic dimensionality and/or the smoothness of the manifold. Usually, the principal manifold is defined as a solution to an optimization problem. The objective function includes a quality of data approximation and some penalty terms for the bending of the manifold. The popular initial approximations are generated by linear PCA, Kohonen's SOM or autoencoders. The <a href="elastic_map" title="wikilink">elastic map</a> method provides the <a href="expectation-maximization_algorithm" title="wikilink">expectation-maximization algorithm</a> for principal <a href="manifold_learning" title="wikilink">manifold learning</a> with minimization of quadratic energy functional at the "maximization" step.</p>
<h3 id="autoencoders">Autoencoders</h3>

<p>An <a class="uri" href="autoencoder" title="wikilink">autoencoder</a> is a feed-forward <a href="neural_network" title="wikilink">neural network</a> which is trained to approximate the identity function. That is, it is trained to map from a vector of values to the same vector. When used for dimensionality reduction purposes, one of the hidden layers in the network is limited to contain only a small number of network units. Thus, the network must learn to encode the vector into a small number of dimensions and then decode it back into the original space. Thus, the first half of the network is a model which maps from high to low-dimensional space, and the second half maps from low to high-dimensional space. Although the idea of autoencoders is quite old, training of deep autoencoders has only recently become possible through the use of <a href="restricted_Boltzmann_machine" title="wikilink">restricted Boltzmann machines</a> and stacked denoising autoencoders. Related to autoencoders is the <a class="uri" href="NeuroScale" title="wikilink">NeuroScale</a> algorithm, which uses stress functions inspired by <a href="multidimensional_scaling" title="wikilink">multidimensional scaling</a> and <a href="Sammon_mapping" title="wikilink">Sammon mappings</a> (see below) to learn a non-linear mapping from the high-dimensional to the embedded space. The mappings in NeuroScale are based on <a href="radial_basis_function_network" title="wikilink">radial basis function networks</a>.</p>
<h3 id="gaussian-process-latent-variable-models">Gaussian process latent variable models</h3>

<p><a href="Gaussian_process_latent_variable_model" title="wikilink">Gaussian process latent variable models</a> (GPLVM)<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> are probabilistic dimensionality reduction methods that use Gaussian Processes (GPs) to find a lower dimensional non-linear embedding of high dimensional data. They are an extension of the Probabilistic formulation of PCA. The model is defined probabilistically and the latent variables are then marginalized and parameters are obtained by maximizing the likelihood. Like kernel PCA they use a kernel function to form a non linear mapping (in the form of a <a href="Gaussian_process" title="wikilink">Gaussian process</a>). However in the GPLVM the mapping is from the embedded(latent) space to the data space (like density networks and GTM) whereas in kernel PCA it is in the opposite direction. It was originally proposed for visualization of high dimensional data but has been extended to construct a shared manifold model between two observation spaces.</p>
<h3 id="curvilinear-component-analysis">Curvilinear component analysis</h3>

<p><a href="Curvilinear_component_analysis" title="wikilink">Curvilinear component analysis</a> (CCA)<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> looks for the configuration of points in the output space that preserves original distances as much as possible while focusing on small distances in the output space (conversely to <a href="Sammon's_mapping" title="wikilink">Sammon's mapping</a> which focus on small distances in original space).</p>

<p>It should be noticed that CCA, as an iterative learning algorithm, actually starts with focus on large distances (like the Sammon algorithm), then gradually change focus to small distances. The small distance information will overwrite the large distance information, if compromises between the two have to be made.</p>

<p>The stress function of CCA is related to a sum of right Bregman divergences<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h3 id="curvilinear-distance-analysis">Curvilinear distance analysis</h3>

<p>CDA<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> trains a self-organizing neural network to fit the manifold and seeks to preserve <a href="geodesic_distance" title="wikilink">geodesic distances</a> in its embedding. It is based on Curvilinear Component Analysis (which extended Sammon's mapping), but uses geodesic distances instead.</p>
<h3 id="diffeomorphic-dimensionality-reduction">Diffeomorphic dimensionality reduction</h3>

<p>Diffeomorphic Dimensionality Reduction or <em>Diffeomap</em><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> learns a smooth diffeomorphic mapping which transports the data onto a lower-dimensional linear subspace. The methods solves for a smooth time indexed vector field such that flows along the field which start at the data points will end at a lower-dimensional linear subspace, thereby attempting to preserve pairwise differences under both the forward and inverse mapping.</p>
<h3 id="kernel-principal-component-analysis">Kernel principal component analysis</h3>

<p>Perhaps the most widely used algorithm for manifold learning is <a href="kernel_principal_component_analysis" title="wikilink">kernel PCA</a>.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> It is a combination of <a href="Principal_component_analysis" title="wikilink">Principal component analysis</a> and the <a href="kernel_trick" title="wikilink">kernel trick</a>. PCA begins by computing the covariance matrix of the 

<math display="inline" id="Nonlinear_dimensionality_reduction:0">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\times n
  </annotation>
 </semantics>
</math>

 matrix 

<math display="inline" id="Nonlinear_dimensionality_reduction:1">
 <semantics>
  <mi>𝐗</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐗</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{X}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Nonlinear_dimensionality_reduction:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>m</mi>
     </mfrac>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>m</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>𝐱</mi>
        <mi>i</mi>
       </msub>
       <msubsup>
        <mi>𝐱</mi>
        <mi>i</mi>
        <mi>𝖳</mi>
       </msubsup>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>m</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐱</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐱</ci>
         <ci>i</ci>
        </apply>
        <ci>𝖳</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=\frac{1}{m}\sum_{i=1}^{m}{\mathbf{x}_{i}\mathbf{x}_{i}^{\mathsf{T}}}.
  </annotation>
 </semantics>
</math>

</p>

<p>It then projects the data onto the first <em>k</em> eigenvectors of that matrix. By comparison, KPCA begins by computing the covariance matrix of the data after being transformed into a higher-dimensional space,</p>

<p>

<math display="block" id="Nonlinear_dimensionality_reduction:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>m</mi>
     </mfrac>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>m</mi>
      </munderover>
      <mrow>
       <mi mathvariant="normal">Φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>𝐱</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi mathvariant="normal">Φ</mi>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>𝐱</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>𝖳</mi>
       </msup>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>m</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Φ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐱</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-Φ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐱</ci>
         <ci>i</ci>
        </apply>
        <ci>𝖳</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=\frac{1}{m}\sum_{i=1}^{m}{\Phi(\mathbf{x}_{i})\Phi(\mathbf{x}_{i})^{\mathsf{%
T}}}.
  </annotation>
 </semantics>
</math>

</p>

<p>It then projects the transformed data onto the first <em>k</em> eigenvectors of that matrix, just like PCA. It uses the kernel trick to factor away much of the computation, such that the entire process can be performed without actually computing 

<math display="inline" id="Nonlinear_dimensionality_reduction:4">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Φ</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(\mathbf{x})
  </annotation>
 </semantics>
</math>

. Of course 

<math display="inline" id="Nonlinear_dimensionality_reduction:5">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 must be chosen such that it has a known corresponding kernel. Unfortunately, it is not trivial to find a good kernel for a given problem, so KPCA does not yield good results with some problems when using standard kernels. For example, it is known to perform poorly with these kernels on the <a href="Swiss_roll" title="wikilink">Swiss roll</a> manifold. However, one can view certain other methods that perform well in such settings (e.g., Laplacian Eigenmaps, LLE) as special cases of kernel PCA by constructing a data-dependent kernel matrix.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>KPCA has an internal model, so it can be used to map points onto its embedding that were not available at training time.</p>
<h3 id="isomap">Isomap</h3>

<p><a class="uri" href="Isomap" title="wikilink">Isomap</a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> is a combination of the <a href="Floyd–Warshall_algorithm" title="wikilink">Floyd–Warshall algorithm</a> with classic <a href="Multidimensional_Scaling" title="wikilink">Multidimensional Scaling</a>. Classic Multidimensional Scaling (MDS) takes a matrix of pair-wise distances between all points, and computes a position for each point. Isomap assumes that the pair-wise distances are only known between neighboring points, and uses the Floyd–Warshall algorithm to compute the pair-wise distances between all other points. This effectively estimates the full matrix of pair-wise <a href="geodesic_distance" title="wikilink">geodesic distances</a> between all of the points. Isomap then uses classic MDS to compute the reduced-dimensional positions of all the points.</p>

<p>Landmark-Isomap is a variant of this algorithm that uses landmarks to increase speed, at the cost of some accuracy.</p>
<h3 id="locally-linear-embedding">Locally-linear embedding</h3>

<p><a href="Locally-Linear_Embedding" title="wikilink">Locally-Linear Embedding</a> (LLE)<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> was presented at approximately the same time as Isomap. It has several advantages over Isomap, including faster optimization when implemented to take advantage of <a href="sparse_matrix" title="wikilink">sparse matrix</a> algorithms, and better results with many problems. LLE also begins by finding a set of the nearest neighbors of each point. It then computes a set of weights for each point that best describe the point as a linear combination of its neighbors. Finally, it uses an eigenvector-based optimization technique to find the low-dimensional embedding of points, such that each point is still described with the same linear combination of its neighbors. LLE tends to handle non-uniform sample densities poorly because there is no fixed unit to prevent the weights from drifting as various regions differ in sample densities. LLE has no internal model.</p>

<p>LLE computes the barycentric coordinates of a point <em>X</em><sub><em>i</em></sub> based on its neighbors <em>X</em><sub><em>j</em></sub>. The original point is reconstructed by a linear combination, given by the weight matrix <em>W</em><sub><em>ij</em></sub>, of its neighbors. The reconstruction error is given by the cost function <em>E</em>(<em>W</em>).</p>

<p>

<math display="block" id="Nonlinear_dimensionality_reduction:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>W</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <msub>
        <mi>𝐗</mi>
        <mi>i</mi>
       </msub>
       <mo>-</mo>
       <mrow>
        <munder>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mi>j</mi>
        </munder>
        <mrow>
         <msub>
          <mi>𝐖</mi>
          <mrow>
           <mi>i</mi>
           <mi>j</mi>
          </mrow>
         </msub>
         <msub>
          <mi>𝐗</mi>
          <mi>j</mi>
         </msub>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>𝟤</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>W</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐗</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <ci>j</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐖</ci>
           <apply>
            <times></times>
            <ci>i</ci>
            <ci>j</ci>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐗</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(W)=\sum_{i}|{\mathbf{X}_{i}-\sum_{j}{\mathbf{W}_{ij}\mathbf{X}_{j}}|}^{%
\mathsf{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>The weights <em>W</em><sub><em>ij</em></sub> refer to the amount of contribution the point <em>X</em><sub><em>j</em></sub> has while reconstructing the point <em>X</em><sub><em>i</em></sub>. The cost function is minimized under two constraints: (a) Each data point <em>X</em><sub><em>i</em></sub> is reconstructed only from its neighbors, thus enforcing <em>W</em><sub><em>ij</em></sub> to be zero if point <em>X</em><sub><em>j</em></sub> is not a neighbor of the point <em>X</em><sub><em>i</em></sub> and (b) The sum of every row of the weight matrix equals 1.</p>

<p>

<math display="block" id="Nonlinear_dimensionality_reduction:7">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>j</mi>
    </munder>
    <msub>
     <mi>𝐖</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐖</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{j}{\mathbf{W}_{ij}}=1
  </annotation>
 </semantics>
</math>

</p>

<p>The original data points are collected in a <em>D</em> dimensional space and the goal of the algorithm is to reduce the dimensionality to <em>d</em> such that <em>D</em> &gt;&gt; <em>d</em>. The same weights <em>W</em><sub><em>ij</em></sub> that reconstructs the <em>i</em>th data point in the <em>D</em> dimensional space will be used to reconstruct the same point in the lower <em>d</em> dimensional space. A neighborhood preserving map is created based on this idea. Each point X<sub>i</sub> in the <em>D</em> dimensional space is mapped onto a point Y<sub>i</sub> in the <em>d</em> dimensional space by minimizing the cost function</p>

<p>

<math display="block" id="Nonlinear_dimensionality_reduction:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <msub>
        <mi>𝐘</mi>
        <mi>i</mi>
       </msub>
       <mo>-</mo>
       <mrow>
        <munder>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mi>j</mi>
        </munder>
        <mrow>
         <msub>
          <mi>𝐖</mi>
          <mrow>
           <mi>i</mi>
           <mi>j</mi>
          </mrow>
         </msub>
         <msub>
          <mi>𝐘</mi>
          <mi>j</mi>
         </msub>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>𝟤</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐘</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <ci>j</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐖</ci>
           <apply>
            <times></times>
            <ci>i</ci>
            <ci>j</ci>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐘</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(Y)=\sum_{i}|{\mathbf{Y}_{i}-\sum_{j}{\mathbf{W}_{ij}\mathbf{Y}_{j}}|}^{%
\mathsf{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>In this cost function, unlike the previous one, the weights W<sub>ij</sub> are kept fixed and the minimization is done on the points Y<sub>i</sub> to optimize the coordinates. This minimization problem can be solved by solving a sparse <em>N</em> X <em>N</em> <a href="Eigendecomposition_of_a_matrix" title="wikilink">eigen value problem</a> (<em>N</em> being the number of data points), whose bottom <em>d</em> nonzero eigen vectors provide an orthogonal set of coordinates. Generally the data points are reconstructed from <em>K</em> nearest neighbors, as measured by <a href="Euclidean_distance" title="wikilink">Euclidean distance</a>. For such an implementation the algorithm has only one free parameter <em>K,</em> which can be chosen by cross validation.</p>
<h3 id="laplacian-eigenmaps">Laplacian eigenmaps</h3>

<p>Laplacian Eigenmaps<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> uses spectral techniques to perform dimensionality reduction. This technique relies on the basic assumption that the data lies in a low-dimensional manifold in a high-dimensional space.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> This algorithm cannot embed out of sample points, but techniques based on <a href="Reproducing_kernel_Hilbert_space" title="wikilink">Reproducing kernel Hilbert space</a> regularization exist for adding this capability.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> Such techniques can be applied to other nonlinear dimensionality reduction algorithms as well.</p>

<p>Traditional techniques like principal component analysis do not consider the intrinsic geometry of the data. Laplacian eigenmaps builds a graph from neighborhood information of the data set. Each data point serves as a node on the graph and connectivity between nodes is governed by the proximity of neighboring points (using e.g. the <a href="k-nearest_neighbor_algorithm" title="wikilink">k-nearest neighbor algorithm</a>). The graph thus generated can be considered as a discrete approximation of the low-dimensional manifold in the high-dimensional space. Minimization of a cost function based on the graph ensures that points close to each other on the manifold are mapped close to each other in the low-dimensional space, preserving local distances. The eigenfunctions of the <a href="Laplace–Beltrami_operator" title="wikilink">Laplace–Beltrami operator</a> on the manifold serve as the embedding dimensions, since under mild conditions this operator has a countable spectrum that is a basis for square integrable functions on the manifold (compare to <a href="Fourier_series" title="wikilink">Fourier series</a> on the unit circle manifold). Attempts to place Laplacian eigenmaps on solid theoretical ground have met with some success, as under certain nonrestrictive assumptions, the graph Laplacian matrix has been shown to converge to the Laplace–Beltrami operator as the number of points goes to infinity.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> Matlab code for Laplacian Eigenmaps can be found in algorithms<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> and the PhD thesis of Belkin can be found at the <a href="Ohio_State_University" title="wikilink">Ohio State University</a>.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>

<p>In classification applications, low dimension manifolds can be used to model data classes which can be defined from sets of observed instances. Each observed instance can be described by two independent factors termed ’content’ and ’style’, where ’content’ is the invariant factor related to the essence of the class and ’style’ expresses variations in that class between instances.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> Unfortunately, Laplacian Eigenmaps may fail to produce a coherent representation of a class of interest when training data consist of instances varying signiﬁcantly in terms of style.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> In the case of classes which are represented by multivariate sequences, Structural Laplacian Eigenmaps has been proposed to overcome this issue by adding additional constraints within the Laplacian Eigenmaps neighborhood information graph to better reﬂect the intrinsic structure of the class.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> More specifically, the graph is used to encode both the sequential structure of the multivariate sequences and, to minimise stylistic variations, proximity between data points of different sequences or even within a sequence, if it contains repetitions. Using <a href="dynamic_time_warping" title="wikilink">dynamic time warping</a>, proximity is detected by ﬁnding correspondences between and within sections of the multivariate sequences that exhibit high similarity. Experiments conducted on <a href="vision-based_activity_recognition" title="wikilink">vision-based activity recognition</a>, object orientation classification and human 3D pose recovery applications have demonstrate the added value of Structural Laplacian Eigenmaps when dealing with multivariate sequence data.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> An extension of Structural Laplacian Eigenmaps, Generalized Laplacian Eigenmaps led to the generation of manifolds where one of the dimensions specifically represents variations in style. This has proved particularly valuable in applications such as tracking of the human articulated body and silhouette extraction.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>
<h3 id="manifold-alignment">Manifold alignment</h3>

<p><a href="Manifold_alignment" title="wikilink">Manifold alignment</a> takes advantage of the assumption that disparate data sets produced by similar generating processes will share a similar underlying manifold representation. By learning projections from each original space to the shared manifold, correspondences are recovered and knowledge from one domain can be transferred to another. Most manifold alignment techniques consider only two data sets, but the concept extends to arbitrarily many initial data sets.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></p>
<h3 id="diffusion-maps">Diffusion maps</h3>

<p><a href="Diffusion_map" title="wikilink">Diffusion maps</a> leverages the relationship between heat diffusion and a random walk (<a href="Markov_Chain" title="wikilink">Markov Chain</a>); an analogy is drawn between the diffusion operator on a manifold and a Markov transition matrix operating on functions defined on the graph whose nodes were sampled from the manifold.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> In particular let a data set be represented by 

<math display="inline" id="Nonlinear_dimensionality_reduction:9">
 <semantics>
  <mrow>
   <mi>𝐗</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Ω</mi>
   <mo>⊂</mo>
   <msup>
    <mi>𝐑</mi>
    <mi>𝐃</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>𝐗</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <ci>normal-Ω</ci>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐑</ci>
      <ci>𝐃</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{X}=[x_{1},x_{2},\ldots,x_{n}]\in\Omega\subset\mathbf{R^{D}}
  </annotation>
 </semantics>
</math>

. The underlying assumption of diffusion map is that the data although high-dimensional, lies on a low-dimensional manifold of dimensions 

<math display="inline" id="Nonlinear_dimensionality_reduction:10">
 <semantics>
  <mi>𝐝</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐝</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{d}
  </annotation>
 </semantics>
</math>

.<strong>X</strong> represents the data set and let 

<math display="inline" id="Nonlinear_dimensionality_reduction:11">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 represent the distribution of the data points on <strong>X</strong>. In addition to this lets define a <strong>kernel</strong> which represents some notion of affinity of the points in <strong>X</strong>. The kernel 

<math display="inline" id="Nonlinear_dimensionality_reduction:12">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{k}
  </annotation>
 </semantics>
</math>

 has the following properties<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></p>

<p>

<math display="block" id="Nonlinear_dimensionality_reduction:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>k</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>k</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>k</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>k</ci>
     <interval closure="open">
      <ci>y</ci>
      <ci>x</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(x,y)=k(y,x),\,
  </annotation>
 </semantics>
</math>

</p>

<p><em>k</em> is symmetric</p>

<p>

<math display="block" id="Nonlinear_dimensionality_reduction:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mn>0</mn>
    <mrow>
     <mo>∀</mo>
     <mi>x</mi>
    </mrow>
    <mo>,</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>k</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <list>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>x</ci>
     </apply>
     <ci>y</ci>
     <ci>k</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(x,y)\geq 0\qquad\forall x,y,k
  </annotation>
 </semantics>
</math>

</p>

<p><em>k</em> is positivity preserving</p>

<p>Thus one can think of the individual data points as the nodes of a graph and the kernel <em>k</em> defining some sort of affinity on that graph. The graph is symmetric by construction since the kernel is symmetric. It is easy to see here that from the tuple {<strong>X</strong>,<strong>k</strong>} one can construct a reversible <a href="Markov_Chain" title="wikilink">Markov Chain</a>. This technique is fairly popular in a variety of fields and is known as the graph laplacian.</p>

<p>The graph <strong>K</strong> = (<em>X</em>,<em>E</em>) can be constructed for example using a Gaussian kernel.</p>

<p>

<math display="block" id="Nonlinear_dimensionality_reduction:15">
 <semantics>
  <mrow>
   <msub>
    <mi>K</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <msup>
        <mi>e</mi>
        <mrow>
         <mo>-</mo>
         <mrow>
          <msubsup>
           <mrow>
            <mo>∥</mo>
            <mrow>
             <msub>
              <mi>x</mi>
              <mi>i</mi>
             </msub>
             <mo>-</mo>
             <msub>
              <mi>x</mi>
              <mi>j</mi>
             </msub>
            </mrow>
            <mo>∥</mo>
           </mrow>
           <mn>2</mn>
           <mn>2</mn>
          </msubsup>
          <mo>/</mo>
          <msup>
           <mi>σ</mi>
           <mn>2</mn>
          </msup>
         </mrow>
        </mrow>
       </msup>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
        </mrow>
        <mo>∼</mo>
        <msub>
         <mi>x</mi>
         <mi>j</mi>
        </msub>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="latexml">norm</csymbol>
           <apply>
            <minus></minus>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <ci>i</ci>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <ci>j</ci>
            </apply>
           </apply>
          </apply>
          <cn type="integer">2</cn>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>σ</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">similar-to</csymbol>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{ij}=\begin{cases}e^{-\|x_{i}-x_{j}\|^{2}_{2}/\sigma^{2}}&\text{if }x_{i}%
\sim x_{j}\\
0&\text{otherwise}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>In this above equation 

<math display="inline" id="Nonlinear_dimensionality_reduction:16">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>∼</mo>
   <msub>
    <mi>x</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}\sim x_{j}
  </annotation>
 </semantics>
</math>

 denotes that 

<math display="inline" id="Nonlinear_dimensionality_reduction:17">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 is a nearest neighbor of 

<math display="inline" id="Nonlinear_dimensionality_reduction:18">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}
  </annotation>
 </semantics>
</math>

. In reality <a class="uri" href="Geodesic" title="wikilink">Geodesic</a> distance should be used to actually measure distances on the <a class="uri" href="manifold" title="wikilink">manifold</a>. Since the exact structure of the manifold is not available, the geodesic distance is approximated by euclidean distances with only nearest neighbors. The choice 

<math display="inline" id="Nonlinear_dimensionality_reduction:19">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 modulates our notion of proximity in the sense that if 

<math display="inline" id="Nonlinear_dimensionality_reduction:20">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mn>2</mn>
   </msub>
   <mo>≫</mo>
   <mi>σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">much-greater-than</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|x_{i}-x_{j}\|_{2}\gg\sigma
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Nonlinear_dimensionality_reduction:21">
 <semantics>
  <mrow>
   <msub>
    <mi>K</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{ij}=0
  </annotation>
 </semantics>
</math>

 and if 

<math display="inline" id="Nonlinear_dimensionality_reduction:22">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mn>2</mn>
   </msub>
   <mo>≪</mo>
   <mi>σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">much-less-than</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|x_{i}-x_{j}\|_{2}\ll\sigma
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Nonlinear_dimensionality_reduction:23">
 <semantics>
  <mrow>
   <msub>
    <mi>K</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{ij}=1
  </annotation>
 </semantics>
</math>

. The former means that very little diffusion has taken place while the latter implies that the diffusion process is nearly complete. Different strategies to choose 

<math display="inline" id="Nonlinear_dimensionality_reduction:24">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 can be found in.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> If 

<math display="inline" id="Nonlinear_dimensionality_reduction:25">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 has to faithfully represent a Markov matrix, then it has to be normalized by the corresponding <a href="degree_matrix" title="wikilink">degree matrix</a> 

<math display="inline" id="Nonlinear_dimensionality_reduction:26">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Nonlinear_dimensionality_reduction:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>D</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mi>K</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>D</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=D^{-1}K.\,
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Nonlinear_dimensionality_reduction:28">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 now represents a Markov chain. 

<math display="inline" id="Nonlinear_dimensionality_reduction:29">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x_{i},x_{j})
  </annotation>
 </semantics>
</math>

 is the probability of transitioning from 

<math display="inline" id="Nonlinear_dimensionality_reduction:30">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Nonlinear_dimensionality_reduction:31">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}
  </annotation>
 </semantics>
</math>

 in one a time step. Similarly the probability of transitioning from 

<math display="inline" id="Nonlinear_dimensionality_reduction:32">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Nonlinear_dimensionality_reduction:33">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}
  </annotation>
 </semantics>
</math>

 in <strong>t</strong> time steps is given by 

<math display="inline" id="Nonlinear_dimensionality_reduction:34">
 <semantics>
  <mrow>
   <msup>
    <mi>P</mi>
    <mi>t</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <ci>t</ci>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{t}(x_{i},x_{j})
  </annotation>
 </semantics>
</math>

. Here 

<math display="inline" id="Nonlinear_dimensionality_reduction:35">
 <semantics>
  <msup>
   <mi>P</mi>
   <mi>t</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>P</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{t}
  </annotation>
 </semantics>
</math>

 is the matrix 

<math display="inline" id="Nonlinear_dimensionality_reduction:36">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 multiplied to itself t times. Now the Markov matrix 

<math display="inline" id="Nonlinear_dimensionality_reduction:37">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 constitutes some notion of local geometry of the data set <strong>X</strong>. The major difference between diffusion maps and <a href="principal_component_analysis" title="wikilink">principal component analysis</a> is that only local features of the data is considered in diffusion maps as opposed to taking correlations of the entire data set.</p>

<p>

<math display="inline" id="Nonlinear_dimensionality_reduction:38">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 defines a random walk on the data set which means that the kernel captures some local geometry of data set. The Markov chain defines fast and slow directions of propagation, based on the values taken by the kernel, and as one propagates the walk forward in time, the local geometry information aggregates in the same way as local transitions (defined by differential equations) of the dynamical system.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> The concept of diffusion arises from the definition of a family diffusion distance {

<math display="inline" id="Nonlinear_dimensionality_reduction:39">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{t}
  </annotation>
 </semantics>
</math>

}

<math display="inline" id="Nonlinear_dimensionality_reduction:40">
 <semantics>
  <msub>
   <mi></mi>
   <mrow>
    <mi>t</mi>
    <mo>∈</mo>
    <mi>N</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <in></in>
     <ci>t</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}_{t\in N}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Nonlinear_dimensionality_reduction:41">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>D</mi>
     <mi>t</mi>
     <mn>2</mn>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo fence="true">||</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>p</mi>
        <mi>t</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mo>⋅</mo>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>p</mi>
        <mi>t</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo>,</mo>
        <mo>⋅</mo>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo fence="true">||</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>D</ci>
       <ci>t</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>t</ci>
        </apply>
        <interval closure="open">
         <ci>x</ci>
         <ci>normal-⋅</ci>
        </interval>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>t</ci>
        </apply>
        <interval closure="open">
         <ci>y</ci>
         <ci>normal-⋅</ci>
        </interval>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{t}^{2}(x,y)=||p_{t}(x,\cdot)-p_{t}(y,\cdot)||^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>For a given value of t 

<math display="inline" id="Nonlinear_dimensionality_reduction:42">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{t}
  </annotation>
 </semantics>
</math>

 defines a distance between any two points of the data set. This means that the value of 

<math display="inline" id="Nonlinear_dimensionality_reduction:43">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mi>t</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>t</ci>
    </apply>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{t}(x,y)
  </annotation>
 </semantics>
</math>

 will be small if there are many paths that connect <strong>x</strong> to <strong>y</strong> and vice versa. The quantity 

<math display="inline" id="Nonlinear_dimensionality_reduction:44">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mi>t</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>t</ci>
    </apply>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{t}(x,y)
  </annotation>
 </semantics>
</math>

 involves summing over of all paths of length t, as a result of which 

<math display="inline" id="Nonlinear_dimensionality_reduction:45">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{t}
  </annotation>
 </semantics>
</math>

 is extremely robust to noise in the data as opposed to geodesic distance. 

<math display="inline" id="Nonlinear_dimensionality_reduction:46">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{t}
  </annotation>
 </semantics>
</math>

 takes into account all the relation between points x and y while calculating the distance and serves as a better notion of proximity than just <a href="Euclidean_distance" title="wikilink">Euclidean distance</a> or even geodesic distance.</p>
<h3 id="hessian-locally-linear-embedding-hessian-lle">Hessian Locally-Linear Embedding (Hessian LLE)</h3>

<p>Like LLE, <a href="Hessian_LLE" title="wikilink">Hessian LLE</a><a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> is also based on sparse matrix techniques. It tends to yield results of a much higher quality than LLE. Unfortunately, it has a very costly computational complexity, so it is not well-suited for heavily-sampled manifolds. It has no internal model.</p>
<h3 id="modified-locally-linear-embedding-mlle">Modified Locally-Linear Embedding (MLLE)</h3>

<p>Modified LLE (MLLE)<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> is another LLE variant which uses multiple weights in each neighborhood to address the local weight matrix conditioning problem which leads to distortions in LLE maps. MLLE produces robust projections similar to Hessian LLE, but without the significant additional computational cost.</p>
<h3 id="relational-perspective-map">Relational perspective map</h3>

<p>Relational perspective map is a <a href="multidimensional_scaling" title="wikilink">multidimensional scaling</a> algorithm. The algorithm finds a configuration of data points on a manifold by simulating a multi-particle dynamic system on a closed manifold, where data points are mapped to particles and distances (or dissimilarity) between data points represent a repulsive force. As the manifold gradually grows in size the multi-particle system cools down gradually and converges to a configuration that reflects the distance information of the data points.</p>

<p>Relational perspective map was inspired by a physical model in which positively charged particles move freely on the surface of a ball. Guided by the <a href="Charles-Augustin_de_Coulomb" title="wikilink">Coulomb</a> <a href="Coulomb's_law" title="wikilink">force</a> between particles, the minimal energy configuration of the particles will reflect the strength of repulsive forces between the particles.</p>

<p>The Relational perspective map was introduced in.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> The algorithm firstly used the flat <a class="uri" href="torus" title="wikilink">torus</a> as the image manifold, then it has been extended (in the software <a href="http://www.VisuMap.com">VisuMap</a> to use other types of closed manifolds, like the <a class="uri" href="sphere" title="wikilink">sphere</a>, <a href="projective_space" title="wikilink">projective space</a>, and <a href="Klein_bottle" title="wikilink">Klein bottle</a>, as image manifolds.</p>
<h3 id="local-tangent-space-alignment">Local tangent space alignment</h3>

<p><a href="local_tangent_space_alignment" title="wikilink">LTSA</a><a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> is based on the intuition that when a manifold is correctly unfolded, all of the tangent hyperplanes to the manifold will become aligned. It begins by computing the <em>k</em>-nearest neighbors of every point. It computes the tangent space at every point by computing the <em>d</em>-first principal components in each local neighborhood. It then optimizes to find an embedding that aligns the tangent spaces.</p>
<h3 id="local-multidimensional-scaling">Local multidimensional scaling</h3>

<p>Local Multidimensional Scaling<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> performs <a href="multidimensional_scaling" title="wikilink">multidimensional scaling</a> in local regions, and then uses convex optimization to fit all the pieces together.</p>
<h3 id="maximum-variance-unfolding">Maximum variance unfolding</h3>

<p><a href="Maximum_Variance_Unfolding" title="wikilink">Maximum Variance Unfolding</a> was formerly known as Semidefinite Embedding. The intuition for this algorithm is that when a manifold is properly unfolded, the variance over the points is maximized. This algorithm also begins by finding the <em>k</em>-nearest neighbors of every point. It then seeks to solve the problem of maximizing the distance between all non-neighboring points, constrained such that the distances between neighboring points are preserved. The primary contribution of this algorithm is a technique for casting this problem as a semidefinite programming problem. Unfortunately, semidefinite programming solvers have a high computational cost. The Landmark–MVU variant of this algorithm uses landmarks to increase speed with some cost to accuracy. It has no model.</p>
<h3 id="nonlinear-pca">Nonlinear PCA</h3>

<p>Nonlinear PCA<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> (NLPCA) uses <a class="uri" href="backpropagation" title="wikilink">backpropagation</a> to train a multi-layer perceptron to fit to a manifold. Unlike typical MLP training, which only updates the weights, NLPCA updates both the weights and the inputs. That is, both the weights and inputs are treated as latent values. After training, the latent inputs are a low-dimensional representation of the observed vectors, and the MLP maps from that low-dimensional representation to the high-dimensional observation space.</p>
<h3 id="data-driven-high-dimensional-scaling">Data-driven high-dimensional scaling</h3>

<p>Data-Driven High Dimensional Scaling (DD-HDS)<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> is closely related to <a href="Sammon's_mapping" title="wikilink">Sammon's mapping</a> and curvilinear component analysis except that (1) it simultaneously penalizes false neighborhoods and tears by focusing on small distances in both original and output space, and that (2) it accounts for <a href="concentration_of_measure" title="wikilink">concentration of measure</a> phenomenon by adapting the weighting function to the distance distribution.</p>
<h3 id="manifold-sculpting">Manifold sculpting</h3>

<p>Manifold Sculpting<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> uses <a href="graduated_optimization" title="wikilink">graduated optimization</a> to find an embedding. Like other algorithms, it computes the <em>k</em>-nearest neighbors and tries to seek an embedding that preserves relationships in local neighborhoods. It slowly scales variance out of higher dimensions, while simultaneously adjusting points in lower dimensions to preserve those relationships. If the rate of scaling is small, it can find very precise embeddings. It boasts higher empirical accuracy than other algorithms with several problems. It can also be used to refine the results from other manifold learning algorithms. It struggles to unfold some manifolds, however, unless a very slow scaling rate is used. It has no model.</p>
<h3 id="t-distributed-stochastic-neighbor-embedding">t-distributed stochastic neighbor embedding</h3>

<p><a href="t-distributed_stochastic_neighbor_embedding" title="wikilink">t-distributed stochastic neighbor embedding</a> (t-SNE) <a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> is widely used. It is one of a family of stochastic neighbor embedding methods.</p>
<h3 id="rankvisu">RankVisu</h3>

<p>RankVisu<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a> is designed to preserve rank of neighborhood rather than distance. RankVisu is especially useful on difficult tasks (when the preservation of distance cannot be achieved satisfyingly). Indeed, the rank of neighborhood is less informative than distance (ranks can be deduced from distances but distances cannot be deduced from ranks) and its preservation is thus easier.</p>
<h3 id="topologically-constrained-isometric-embedding">Topologically constrained isometric embedding</h3>

<p><a href="Topologically_Constrained_Isometric_Embedding" title="wikilink">Topologically Constrained Isometric Embedding</a> (TCIE)<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a> is an algorithm based approximating geodesic distances after filtering geodesics inconsistent with the Euclidean metric. Aimed at correcting the distortions caused when Isomap is used to map intrinsically non-convex data, TCIE uses weight least-squares MDS in order to obtain a more accurate mapping. The TCIE algorithm first detects possible boundary points in the data, and during computation of the geodesic length marks inconsistent geodesics, to be given a small weight in the weighted <a href="Stress_majorization" title="wikilink">Stress majorization</a> that follows.</p>
<h2 id="methods-based-on-proximity-matrices">Methods based on proximity matrices</h2>

<p>A method based on proximity matrices is one where the data is presented to the algorithm in the form of a <a href="similarity_matrix" title="wikilink">similarity matrix</a> or a <a href="distance_matrix" title="wikilink">distance matrix</a>. These methods all fall under the broader class of <a href="Multidimensional_scaling#Types" title="wikilink">metric multidimensional scaling</a>. The variations tend to be differences in how the proximity data is computed; for example, <a class="uri" href="Isomap" title="wikilink">Isomap</a>, <a href="locally_linear_embeddings" title="wikilink">locally linear embeddings</a>, <a href="maximum_variance_unfolding" title="wikilink">maximum variance unfolding</a>, and <a href="Sammon's_projection" title="wikilink">Sammon mapping</a> (which is not in fact a mapping) are examples of metric multidimensional scaling methods.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Discriminant_analysis" title="wikilink">Discriminant analysis</a></li>
<li><a href="Elastic_map" title="wikilink">Elastic map</a><a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a></li>
<li><a href="Feature_learning" title="wikilink">Feature learning</a></li>
<li><a href="Growing_self-organizing_map" title="wikilink">Growing self-organizing map</a> (GSOM)</li>
<li><a href="Multilinear_subspace_learning" title="wikilink">Multilinear subspace learning</a> (MSL)</li>
<li><a href="Pairwise_distance_methods" title="wikilink">Pairwise distance methods</a></li>
<li><a href="Self-organizing_map" title="wikilink">Self-organizing map</a> (SOM)</li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://isomap.stanford.edu/">Isomap</a></li>
<li><a href="http://www.ncrg.aston.ac.uk/GTM/">Generative Topographic Mapping</a></li>
<li><a href="http://www.miketipping.com/thesis.htm">Mike Tipping's Thesis</a></li>
<li><a href="http://www.dcs.shef.ac.uk/~neil/gplvm/">Gaussian Process Latent Variable Model</a></li>
<li><a href="http://www.cs.toronto.edu/~roweis/lle/">Locally Linear Embedding</a></li>
<li><a href="http://www.visumap.net/index.aspx?p=Resources/RpmOverview">Relational Perspective Map</a></li>
<li><a href="http://waffles.sourceforge.net/">Waffles</a> is an open source C++ library containing implementations of LLE, Manifold Sculpting, and some other manifold learning algorithms.</li>
<li><a href="http://shogun-toolbox.org/edrt/">Efficient Dimensionality Reduction Toolkit homepage</a></li>
<li><a href="http://sy.lespi.free.fr/DD-HDS-homepage.html">DD-HDS homepage</a></li>
<li><a href="http://sy.lespi.free.fr/RankVisu-homepage.html">RankVisu homepage</a></li>
<li><a href="http://tx.technion.ac.il/~rc/diffusion_maps.pdf">Short review of Diffusion Maps</a></li>
<li><a href="http://www.nlpca.org/">Nonlinear PCA by autoencoder neural networks</a></li>
</ul>

<p>"</p>

<p><a href="Category:Multivariate_statistics" title="wikilink">Category:Multivariate statistics</a> <a class="uri" href="Category:Dimension" title="wikilink">Category:Dimension</a> <a href="Category:Dimension_reduction" title="wikilink">Category:Dimension reduction</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">John A. Lee, Michel Verleysen, Nonlinear Dimensionality Reduction, Springer, 2007.<a href="#fnref1">↩</a></li>
<li id="fn2">Gashler, M. and Martinez, T., <a href="http://axon.cs.byu.edu/papers/gashler2011ijcnn2.pdf">Temporal Nonlinear Dimensionality Reduction</a>, In <em>Proceedings of the International Joint Conference on Neural Networks IJCNN'11</em>, pp. 1959–1966, 2011<a href="#fnref2">↩</a></li>
<li id="fn3">The illustration is prepared using free software: E.M. Mirkes, <a href="http://www.math.le.ac.uk/people/ag153/homepage/PCA_SOM/PCA_SOM.html">Principal Component Analysis and Self-Organizing Maps: applet</a>. University of Leicester, 2011<a href="#fnref3">↩</a></li>
<li id="fn4">Yin, Hujun; <a href="http://pca.narod.ru/contentsgkwz.htm"><em>Learning Nonlinear Principal Manifolds by Self-Organising Maps</em></a>, in A.N. Gorban, B. Kégl, D.C. Wunsch, and A. Zinovyev (Eds.), <em>Principal Manifolds for Data Visualization and Dimension Reduction</em>, Lecture Notes in Computer Science and Engineering (LNCSE), vol. 58, Berlin, Germany: Springer, 2007, Ch. 3, pp. 68-95. ISBN 978-3-540-73749-0<a href="#fnref4">↩</a></li>
<li id="fn5">A. N. Gorban, A. Zinovyev, <a href="http://arxiv.org/abs/1001.1122">Principal manifolds and graphs in practice: from molecular biology to dynamical systems</a>, <a href="International_Journal_of_Neural_Systems" title="wikilink">International Journal of Neural Systems</a>, Vol. 20, No. 3 (2010) 219–232.<a href="#fnref5">↩</a></li>
<li id="fn6">A. Zinovyev, <a href="http://bioinfo-out.curie.fr/projects/vidaexpert/">ViDaExpert</a> - Multidimensional Data Visualization Tool (free for non-commercial use). <a href="Curie_Institute_(Paris)" title="wikilink">Institut Curie</a>, Paris.<a href="#fnref6">↩</a></li>
<li id="fn7">A. Zinovyev, <a href="http://www.ihes.fr/~zinovyev/vida/ViDaExpert/ViDaOverView.pdf">ViDaExpert overview</a>, <a href="http://www.ihes.fr">IHES</a> (<a href="Institut_des_Hautes_Études_Scientifiques" title="wikilink">Institut des Hautes Études Scientifiques</a>), Bures-Sur-Yvette, Île-de-France.<a href="#fnref7">↩</a></li>
<li id="fn8">T. Hastie, Principal Curves and Surfaces, Ph.D Dissertation, Stanford Linear Accelerator Center, Stanford University, Stanford, California, US, November 1984.<a href="#fnref8">↩</a></li>
<li id="fn9"><a href="Alexander_Nikolaevich_Gorban" title="wikilink">A.N. Gorban</a>, B. Kégl, D.C. Wunsch, A. Zinovyev (Eds.), <a href="http://pca.narod.ru/contentsgkwz.htm">Principal Manifolds for Data Visualisation and Dimension Reduction</a>, Lecture Notes in Computer Science and Engineering (LNCSE), Vol. 58, Springer, Berlin – Heidelberg – New York, 2007. ISBN 978-3-540-73749-0<a href="#fnref9">↩</a></li>
<li id="fn10">N. Lawrence, <a href="http://jmlr.csail.mit.edu/papers/v6/lawrence05a.html">Probabilistic Non-linear Principal Component Analysis with Gaussian Process Latent Variable Models</a>, Journal of Machine Learning Research 6(Nov):1783–1816, 2005.<a href="#fnref10">↩</a></li>
<li id="fn11">P. Demartines and J. Hérault, Curvilinear Component Analysis: A Self-Organizing Neural Network for Nonlinear Mapping of Data Sets, IEEE Transactions on Neural Networks, Vol. 8(1), 1997, pp. 148–154<a href="#fnref11">↩</a></li>
<li id="fn12">Jigang Sun, Malcolm Crowe, and Colin Fyfe, <a href="http://www.dice.ucl.ac.be/Proceedings/esann/esannpdf/es2010-107.pdf">Curvilinear component analysis and Bregman divergences</a>, In European Symposium on Artificial Neural Networks (Esann), pages 81–86. d-side publications, 2010<a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14">Christian Walder and Bernhard Schölkopf, Diffeomorphic Dimensionality Reduction, Advances in Neural Information Processing Systems 22, 2009, pp. 1713–1720, MIT Press<a href="#fnref14">↩</a></li>
<li id="fn15">B. Schölkopf, A. Smola, K.-R. Müller, Nonlinear Component Analysis as a Kernel Eigenvalue Problem. ''Neural Computation ''10(5):1299-1319, 1998, <a href="MIT_Press" title="wikilink">MIT Press</a> Cambridge, MA, USA, <a class="uri" href="doi:10.1162/089976698300017467" title="wikilink">doi:10.1162/089976698300017467</a><a href="#fnref15">↩</a></li>
<li id="fn16">Jihun Ham, Daniel D. Lee, Sebastian Mika, Bernhard Schölkopf. A kernel view of the dimensionality reduction of manifolds. Proceedings of the 21st International Conference on Machine Learning, Banff, Canada, 2004. <a class="uri" href="doi:10.1145/1015330.1015417" title="wikilink">doi:10.1145/1015330.1015417</a><a href="#fnref16">↩</a></li>
<li id="fn17">J. B. Tenenbaum, V. de Silva, J. C. Langford, A Global Geometric Framework for Nonlinear Dimensionality Reduction, Science 290, (2000), 2319–2323.<a href="#fnref17">↩</a></li>
<li id="fn18">S. T. Roweis and L. K. Saul, Nonlinear Dimensionality Reduction by Locally Linear Embedding, Science Vol 290, 22 December 2000, 2323–2326.<a href="#fnref18">↩</a></li>
<li id="fn19">Mikhail Belkin and <a href="Partha_Niyogi" title="wikilink">Partha Niyogi</a>, Laplacian Eigenmaps and Spectral Techniques for Embedding and Clustering, Advances in Neural Information Processing Systems 14, 2001, p. 586–691, MIT Press<a href="#fnref19">↩</a></li>
<li id="fn20">Mikhail Belkin Problems of Learning on Manifolds, PhD Thesis, Department of Mathematics, The University Of Chicago, August 2003<a href="#fnref20">↩</a></li>
<li id="fn21">Bengio et al. "Out-of-Sample Extensions for LLE, Isomap, MDS, Eigenmaps, and Spectral Clustering" in Advances in Neural Information Processing Systems (2004)<a href="#fnref21">↩</a></li>
<li id="fn22">Mikhail Belkin Problems of Learning on Manifolds, PhD Thesis, Department of Mathematics, The <a href="University_Of_Chicago" title="wikilink">University Of Chicago</a>, August 2003<a href="#fnref22">↩</a></li>
<li id="fn23"><a href="http://www.cse.ohio-state.edu/~mbelkin/algorithms/algorithms.html">Ohio-state.edu</a><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="http://www.cse.ohio-state.edu/~mbelkin/papers/papers.html#thesis">Ohio-state.edu</a><a href="#fnref24">↩</a></li>
<li id="fn25">J. Tenenbaum and W. Freeman, Separating style and content with bilinear models, Neural Computation, vol. 12, 2000.<a href="#fnref25">↩</a></li>
<li id="fn26">M. Lewandowski, J. Martinez-del Rincon, D. Makris, and J.-C. Nebel, Temporal extension of laplacian eigenmaps for unsupervised dimensionality reduction of time series, Proceedings of the International Conference on Pattern Recognition (ICPR), 2010<a href="#fnref26">↩</a></li>
<li id="fn27">M. Lewandowski, D. Makris, S.A. Velastin and J.-C. Nebel, Structural Laplacian Eigenmaps for Modeling Sets of Multivariate Sequences, IEEE Transactions on Cybernetics, 44(6): 936-949, 2014<a href="#fnref27">↩</a></li>
<li id="fn28"></li>
<li id="fn29">J. Martinez-del-Rincon, M. Lewandowski, J.-C. Nebel and D. Makris, Generalized Laplacian Eigenmaps for Modeling and Tracking Human Motions, IEEE Transactions on Cybernetics, 44(9), pp 1646-1660, 2014<a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31">Diffusion Maps and Geometric Harmonics, Stephane Lafon, PhD Thesis, <a href="Yale_University" title="wikilink">Yale University</a>, May 2004<a href="#fnref31">↩</a></li>
<li id="fn32">Diffusion Maps, Ronald R. Coifman and Stephane Lafon,: Science, 19 June 2006<a href="#fnref32">↩</a></li>
<li id="fn33">B. Bah, "Diffusion Maps: Applications and Analysis", Masters Thesis, University of Oxford<a href="#fnref33">↩</a></li>
<li id="fn34"></li>
<li id="fn35">D. Donoho and C. Grimes, "Hessian eigenmaps: Locally linear embedding techniques for high-dimensional data" Proc Natl Acad Sci U S A. 2003 May 13; 100(10): 5591–5596<a href="#fnref35">↩</a></li>
<li id="fn36">Z. Zhang and J. Wang, "MLLE: Modified Locally Linear Embedding Using Multiple Weights" <a class="uri" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.70.382">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.70.382</a><a href="#fnref36">↩</a></li>
<li id="fn37">James X. Li, <a href="http://www.palgrave-journals.com/ivs/journal/v3/n1/pdf/9500051a.pdf">Visualizing high-dimensional data with relational perspective map</a>, Information Visualization (2004) 3, 49–59<a href="#fnref37">↩</a></li>
<li id="fn38"><a href="#fnref38">↩</a></li>
<li id="fn39">J Venna and S Kaski, Local multidimensional scaling, Neural Networks, 2006<a href="#fnref39">↩</a></li>
<li id="fn40">Scholz, M. Kaplan, F. Guy, C. L. Kopka, J. Selbig, J., Non-linear PCA: a missing data approach, In <em>Bioinformatics</em>, Vol. 21, Number 20, pp. 3887–3895, Oxford University Press, 2005<a href="#fnref40">↩</a></li>
<li id="fn41">S. Lespinats, M. Verleysen, A. Giron, B. Fertil, DD-HDS: a tool for visualization and exploration of high-dimensional data, IEEE Transactions on Neural Networks 18 (5) (2007) 1265–1279.<a href="#fnref41">↩</a></li>
<li id="fn42">Gashler, M. and Ventura, D. and Martinez, T., <em><a href="http://axon.cs.byu.edu/papers/gashler2007nips.pdf">Iterative Non-linear Dimensionality Reduction with Manifold Sculpting</a></em>, In Platt, J.C. and Koller, D. and Singer, Y. and Roweis, S., editor, Advances in Neural Information Processing Systems 20, pp. 513–520, MIT Press, Cambridge, MA, 2008<a href="#fnref42">↩</a></li>
<li id="fn43"><a href="#fnref43">↩</a></li>
<li id="fn44">Lespinats S., Fertil B., Villemain P. and Herault J., Rankvisu: Mapping from the neighbourhood network, Neurocomputing, vol. 72 (13–15), pp. 2964–2978, 2009.<a href="#fnref44">↩</a></li>
<li id="fn45">Rosman G., Bronstein M. M., Bronstein A. M. and Kimmel R., Nonlinear Dimensionality Reduction by Topologically Constrained Isometric Embedding, International Journal of Computer Vision, Volume 89, Number 1, 56–68, 2010<a href="#fnref45">↩</a></li>
<li id="fn46"><a href="http://bioinfo-out.curie.fr/projects/elmap/">ELastic MAPs</a><a href="#fnref46">↩</a></li>
</ol>
</section>
</body>
</html>
