<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="712">Belief propagation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Belief propagation</h1>
<hr/>

<p><strong>Belief propagation</strong>, also known as <strong>sum-product message passing</strong> is a <a href="Message-passing_method" title="wikilink">message passing</a> <a class="uri" href="algorithm" title="wikilink">algorithm</a> for performing <a class="uri" href="inference" title="wikilink">inference</a> on <a href="graphical_model" title="wikilink">graphical models</a>, such as <a href="Bayesian_network" title="wikilink">Bayesian networks</a> and <a href="Markov_random_field" title="wikilink">Markov random fields</a>. It calculates the <a href="marginal_distribution" title="wikilink">marginal distribution</a> for each unobserved node, conditional on any observed nodes. Belief propagation is commonly used in <a href="artificial_intelligence" title="wikilink">artificial intelligence</a> and <a href="information_theory" title="wikilink">information theory</a> and has demonstrated empirical success in numerous applications including <a href="low-density_parity-check_codes" title="wikilink">low-density parity-check codes</a>, <a href="turbo_codes" title="wikilink">turbo codes</a>, <a href="Thermodynamic_free_energy" title="wikilink">free energy</a> approximation, and <a class="uri" href="satisfiability" title="wikilink">satisfiability</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The algorithm was first proposed by <a href="Judea_Pearl" title="wikilink">Judea Pearl</a> in 1982,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> who formulated this algorithm on <a href="Tree_(graph_theory)" title="wikilink">trees</a>, and was later extended to <a href="polytree" title="wikilink">polytrees</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> It has since been shown to be a useful approximate algorithm on general graphs.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>If <em>X</em>={<em>X</em><sub><em>i</em></sub>} is a set of <a href="Discrete_probability_distribution" title="wikilink">discrete</a> <a href="random_variable" title="wikilink">random variables</a> with a <a href="joint_distribution" title="wikilink">joint</a> <a href="Probability_mass_function" title="wikilink">mass function</a> <em>p</em>, the <a href="marginal_distribution" title="wikilink">marginal distribution</a> of a single <em>X</em><sub><em>i</em></sub> is simply the summation of <em>p</em> over all other variables:</p>

<p>

<math display="block" id="Belief_propagation:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>p</mi>
      <msub>
       <mi>X</mi>
       <mi>i</mi>
      </msub>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
      <mrow>
       <msup>
        <mi>ùê±</mi>
        <mo>‚Ä≤</mo>
       </msup>
       <mo>:</mo>
       <mrow>
        <msubsup>
         <mi>x</mi>
         <mi>i</mi>
         <mo>‚Ä≤</mo>
        </msubsup>
        <mo>=</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>ùê±</mi>
        <mo>‚Ä≤</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <ci>normal-:</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ùê±</ci>
        <ci>normal-‚Ä≤</ci>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <ci>normal-‚Ä≤</ci>
         </apply>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ùê±</ci>
       <ci>normal-‚Ä≤</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{X_{i}}(x_{i})=\sum_{\mathbf{x}^{\prime}:x^{\prime}_{i}=x_{i}}p(\mathbf{x}^{%
\prime}).
  </annotation>
 </semantics>
</math>

</p>

<p>However, this quickly becomes computationally prohibitive: if there are 100 binary variables, then one needs to sum over 2<sup>99</sup>¬†‚âà¬†6.338¬†√ó¬†10<sup>29</sup> possible values. By exploiting the polytree structure, belief propagation allows the marginals to be computed much more efficiently.</p>
<h2 id="description-of-the-sum-product-algorithm">Description of the sum-product algorithm</h2>

<p>Variants of the belief propagation algorithm exist for several types of graphical models (<a href="Bayesian_networks" title="wikilink">Bayesian networks</a> and <a href="Markov_random_fields" title="wikilink">Markov random fields</a>,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> in particular). We describe here the variant that operates on a <a href="factor_graph" title="wikilink">factor graph</a>. A factor graph is a <a href="bipartite_graph" title="wikilink">bipartite graph</a> containing nodes corresponding to variables <em>V</em> and factors <em>F</em>, with edges between variables and the factors in which they appear. We can write the joint mass function:</p>

<p>

<math display="block" id="Belief_propagation:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ùê±</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">‚àè</mo>
     <mrow>
      <mi>a</mi>
      <mo>‚àà</mo>
      <mi>F</mi>
     </mrow>
    </munder>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>a</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>ùê±</mi>
       <mi>a</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>ùê±</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <in></in>
       <ci>a</ci>
       <ci>F</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ùê±</ci>
       <ci>a</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\mathbf{x})=\prod_{a\in F}f_{a}(\mathbf{x}_{a})
  </annotation>
 </semantics>
</math>

</p>

<p>where <strong>x</strong><sub><em>a</em></sub> is the vector of neighbouring variable nodes to the factor node <em>a</em>. Any <a href="Bayesian_network" title="wikilink">Bayesian network</a> or <a href="Markov_random_field" title="wikilink">Markov random field</a> can be represented as a factor graph.</p>

<p>The algorithm works by passing real valued functions called <em>messages</em> along the edges between the hidden nodes. More precisely, if <em>v</em> is a variable node and <em>a</em> is a factor node connected to <em>v</em> in the factor graph, the messages from <em>v</em> to <em>a</em>, (denoted by 

<math display="inline" id="Belief_propagation:2">
 <semantics>
  <msub>
   <mi>Œº</mi>
   <mrow>
    <mi>v</mi>
    <mo>‚Üí</mo>
    <mi>a</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Œº</ci>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>v</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{v\to a}
  </annotation>
 </semantics>
</math>

) and from <em>a</em> to <em>v</em> (

<math display="inline" id="Belief_propagation:3">
 <semantics>
  <msub>
   <mi>Œº</mi>
   <mrow>
    <mi>a</mi>
    <mo>‚Üí</mo>
    <mi>v</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Œº</ci>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>a</ci>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{a\to v}
  </annotation>
 </semantics>
</math>

), are real-valued functions whose domain is Dom(<em>v</em>), the set of values that can be taken by the random variable associated with <em>v</em>. These messages contain the "influence" that one variable exerts on another. The messages are computed differently depending on whether the node receiving the message is a variable node or a factor node. Keeping the same notation:</p>
<ul>
<li>A message from a variable node <em>v</em> to a factor node <em>a</em> is the product of the messages from all other neighbouring factor nodes (except the recipient; alternatively one can say the recipient sends as message the constant function equal to "1"):</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Belief_propagation:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>‚àÄ</mo>
      <msub>
       <mi>x</mi>
       <mi>v</mi>
      </msub>
     </mrow>
     <mo>‚àà</mo>
     <mrow>
      <mi>D</mi>
      <mi>o</mi>
      <mi>m</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="5.3pt">,</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>Œº</mi>
       <mrow>
        <mi>v</mi>
        <mo>‚Üí</mo>
        <mi>a</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>v</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">‚àè</mo>
       <mrow>
        <msup>
         <mi>a</mi>
         <mo>*</mo>
        </msup>
        <mo>‚àà</mo>
        <mrow>
         <mrow>
          <mi>N</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>v</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>‚àñ</mo>
         <mrow>
          <mo stretchy="false">{</mo>
          <mi>a</mi>
          <mo stretchy="false">}</mo>
         </mrow>
        </mrow>
       </mrow>
      </msub>
      <mrow>
       <msub>
        <mi>Œº</mi>
        <mrow>
         <msup>
          <mi>a</mi>
          <mo>*</mo>
         </msup>
         <mo>‚Üí</mo>
         <mi>v</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>v</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>v</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>D</ci>
      <ci>o</ci>
      <ci>m</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Œº</ci>
       <apply>
        <ci>normal-‚Üí</ci>
        <ci>v</ci>
        <ci>a</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>v</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <in></in>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>a</ci>
         <times></times>
        </apply>
        <apply>
         <setdiff></setdiff>
         <apply>
          <times></times>
          <ci>N</ci>
          <ci>v</ci>
         </apply>
         <set>
          <ci>a</ci>
         </set>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Œº</ci>
        <apply>
         <ci>normal-‚Üí</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>a</ci>
          <times></times>
         </apply>
         <ci>v</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>v</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x_{v}\in Dom(v),\;\mu_{v\to a}(x_{v})=\prod_{a^{*}\in N(v)\setminus\{a%
\}}\mu_{a^{*}\to v}(x_{v}).
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>where <em>N</em>(<em>v</em>) is the set of neighbouring (factor) nodes to <em>v</em>. If 

<math display="inline" id="Belief_propagation:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>N</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚àñ</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>a</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <setdiff></setdiff>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>v</ci>
    </apply>
    <set>
     <ci>a</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N(v)\setminus\{a\}
  </annotation>
 </semantics>
</math>

 is empty, then 

<math display="inline" id="Belief_propagation:6">
 <semantics>
  <mrow>
   <msub>
    <mi>Œº</mi>
    <mrow>
     <mi>v</mi>
     <mo>‚Üí</mo>
     <mi>a</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>v</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Œº</ci>
     <apply>
      <ci>normal-‚Üí</ci>
      <ci>v</ci>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{v\to a}(x_{v})
  </annotation>
 </semantics>
</math>

 is set to the uniform distribution.
</dd>
</dl>
<ul>
<li>A message from a factor node <em>a</em> to a variable node <em>v</em> is the product of the factor with messages from all other nodes, marginalised over all variables except the one associated with <em>v</em>:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Belief_propagation:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>‚àÄ</mo>
      <msub>
       <mi>x</mi>
       <mi>v</mi>
      </msub>
     </mrow>
     <mo>‚àà</mo>
     <mrow>
      <mi>D</mi>
      <mi>o</mi>
      <mi>m</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="5.3pt">,</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>Œº</mi>
       <mrow>
        <mi>a</mi>
        <mo>‚Üí</mo>
        <mi>v</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>v</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">‚àë</mo>
       <mrow>
        <msubsup>
         <mi>ùê±</mi>
         <mi>a</mi>
         <mo>‚Ä≤</mo>
        </msubsup>
        <mo>:</mo>
        <mrow>
         <msubsup>
          <mi>x</mi>
          <mi>v</mi>
          <mo>‚Ä≤</mo>
         </msubsup>
         <mo>=</mo>
         <msub>
          <mi>x</mi>
          <mi>v</mi>
         </msub>
        </mrow>
       </mrow>
      </msub>
      <mrow>
       <msub>
        <mi>f</mi>
        <mi>a</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msubsup>
         <mi>ùê±</mi>
         <mi>a</mi>
         <mo>‚Ä≤</mo>
        </msubsup>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <msub>
         <mo largeop="true" symmetric="true">‚àè</mo>
         <mrow>
          <msup>
           <mi>v</mi>
           <mo>*</mo>
          </msup>
          <mo>‚àà</mo>
          <mrow>
           <mrow>
            <mi>N</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>a</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo>‚àñ</mo>
           <mrow>
            <mo stretchy="false">{</mo>
            <mi>v</mi>
            <mo stretchy="false">}</mo>
           </mrow>
          </mrow>
         </mrow>
        </msub>
        <mrow>
         <msub>
          <mi>Œº</mi>
          <mrow>
           <msup>
            <mi>v</mi>
            <mo>*</mo>
           </msup>
           <mo>‚Üí</mo>
           <mi>a</mi>
          </mrow>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <msubsup>
           <mi>x</mi>
           <msup>
            <mi>v</mi>
            <mo>*</mo>
           </msup>
           <mo>‚Ä≤</mo>
          </msubsup>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>v</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>D</ci>
      <ci>o</ci>
      <ci>m</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Œº</ci>
       <apply>
        <ci>normal-‚Üí</ci>
        <ci>a</ci>
        <ci>v</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>v</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <ci>normal-:</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>ùê±</ci>
          <ci>normal-‚Ä≤</ci>
         </apply>
         <ci>a</ci>
        </apply>
        <apply>
         <eq></eq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>x</ci>
           <ci>normal-‚Ä≤</ci>
          </apply>
          <ci>v</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>v</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>a</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ùê±</ci>
         <ci>normal-‚Ä≤</ci>
        </apply>
        <ci>a</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <csymbol cd="latexml">product</csymbol>
         <apply>
          <in></in>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>v</ci>
           <times></times>
          </apply>
          <apply>
           <setdiff></setdiff>
           <apply>
            <times></times>
            <ci>N</ci>
            <ci>a</ci>
           </apply>
           <set>
            <ci>v</ci>
           </set>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Œº</ci>
          <apply>
           <ci>normal-‚Üí</ci>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>v</ci>
            <times></times>
           </apply>
           <ci>a</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>x</ci>
           <ci>normal-‚Ä≤</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>v</ci>
           <times></times>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x_{v}\in Dom(v),\;\mu_{a\to v}(x_{v})=\sum_{\mathbf{x}^{\prime}_{a}:x^%
{\prime}_{v}=x_{v}}f_{a}(\mathbf{x}^{\prime}_{a})\prod_{v^{*}\in N(a)\setminus%
\{v\}}\mu_{v^{*}\to a}(x^{\prime}_{v^{*}}).
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>where <em>N</em>(<em>a</em>) is the set of neighbouring (variable) nodes to <em>a</em>. If 

<math display="inline" id="Belief_propagation:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>N</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚àñ</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>v</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <setdiff></setdiff>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>a</ci>
    </apply>
    <set>
     <ci>v</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N(a)\setminus\{v\}
  </annotation>
 </semantics>
</math>

 is empty then 

<math display="inline" id="Belief_propagation:9">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Œº</mi>
     <mrow>
      <mi>a</mi>
      <mo>‚Üí</mo>
      <mi>v</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>v</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>f</mi>
     <mi>a</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>v</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Œº</ci>
      <apply>
       <ci>normal-‚Üí</ci>
       <ci>a</ci>
       <ci>v</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>v</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{a\to v}(x_{v})=f_{a}(x_{v})
  </annotation>
 </semantics>
</math>

, since in this case 

<math display="inline" id="Belief_propagation:10">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>v</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mi>a</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{v}=x_{a}
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>

<p>As shown by the previous formula: the complete marginalisation is reduced to a sum of products of simpler terms than the ones appearing in the full joint distribution. This is the reason why it is called the sum-product algorithm.</p>

<p>In a typical run, each message will be updated iteratively from the previous value of the neighbouring messages. Different scheduling can be used for updating the messages. In the case where the graphical model is a tree, an optimal scheduling allows to reach convergence after computing each messages only once (see next sub-section). When the factor graph has cycles, such an optimal scheduling does not exist, and a typical choice is to update all messages simultaneously at each iteration.</p>

<p>Upon convergence (if convergence happened), the estimated marginal distribution of each node is proportional to the product of all messages from adjoining factors (missing the normalization constant):</p>

<p>

<math display="block" id="Belief_propagation:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>p</mi>
      <msub>
       <mi>X</mi>
       <mi>v</mi>
      </msub>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>v</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>‚àù</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àè</mo>
      <mrow>
       <mi>a</mi>
       <mo>‚àà</mo>
       <mrow>
        <mi>N</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>v</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <msub>
       <mi>Œº</mi>
       <mrow>
        <mi>a</mi>
        <mo>‚Üí</mo>
        <mi>v</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>v</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proportional-to</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>v</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <in></in>
       <ci>a</ci>
       <apply>
        <times></times>
        <ci>N</ci>
        <ci>v</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Œº</ci>
       <apply>
        <ci>normal-‚Üí</ci>
        <ci>a</ci>
        <ci>v</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{X_{v}}(x_{v})\propto\prod_{a\in N(v)}\mu_{a\to v}(x_{v}).
  </annotation>
 </semantics>
</math>

</p>

<p>Likewise, the estimated joint marginal distribution of the set of variables belonging to one factor is proportional to the product of the factor and the messages from the variables:</p>

<p>

<math display="block" id="Belief_propagation:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>p</mi>
      <msub>
       <mi>X</mi>
       <mi>a</mi>
      </msub>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>ùê±</mi>
       <mi>a</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>‚àù</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>a</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>ùê±</mi>
       <mi>a</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">‚àè</mo>
       <mrow>
        <mi>v</mi>
        <mo>‚àà</mo>
        <mrow>
         <mi>N</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>a</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </munder>
      <mrow>
       <msub>
        <mi>Œº</mi>
        <mrow>
         <mi>v</mi>
         <mo>‚Üí</mo>
         <mi>a</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>v</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proportional-to</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>a</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùê±</ci>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùê±</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <in></in>
        <ci>v</ci>
        <apply>
         <times></times>
         <ci>N</ci>
         <ci>a</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Œº</ci>
        <apply>
         <ci>normal-‚Üí</ci>
         <ci>v</ci>
         <ci>a</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>v</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{X_{a}}(\mathbf{x}_{a})\propto f_{a}(\mathbf{x}_{a})\prod_{v\in N(a)}\mu_{v%
\to a}(x_{v}).
  </annotation>
 </semantics>
</math>

</p>

<p>In the case where the factor graph is acyclic (i.e. is a tree or a forest), these estimated marginal actually converge to the true marginals in a finite number of iterations. This can be shown by <a href="mathematical_induction" title="wikilink">mathematical induction</a>.</p>
<h3 id="exact-algorithm-for-trees">Exact algorithm for trees</h3>

<p>In the case when the <a href="factor_graph" title="wikilink">factor graph</a> is a <a href="tree_(graph_theory)" title="wikilink">tree</a>, the belief propagation algorithm will compute the exact marginals. Furthermore, with proper scheduling of the message updates, it will terminate after 2 steps. This optimal scheduling can be described as follows:</p>

<p>Before starting, the graph is orientated by designating one node as the <em>root</em>; any non-root node which is connected to only one other node is called a <em>leaf</em>.</p>

<p>In the first step, messages are passed inwards: starting at the leaves, each node passes a message along the (unique) edge towards the root node. The tree structure guarantees that it is possible to obtain messages from all other adjoining nodes before passing the message on. This continues until the root has obtained messages from all of its adjoining nodes.</p>

<p>The second step involves passing the messages back out: starting at the root, messages are passed in the reverse direction. The algorithm is completed when all leaves have received their messages.</p>
<h3 id="approximate-algorithm-for-general-graphs">Approximate algorithm for general graphs</h3>

<p>Curiously, although it was originally designed for acyclic graphical models, it was found that the Belief Propagation algorithm can be used in general <a href="graph_(mathematics)" title="wikilink">graphs</a>. The algorithm is then sometimes called "loopy" belief propagation, because graphs typically contain <a href="cycle_(graph_theory)" title="wikilink">cycles</a>, or loops. The initialization and scheduling of message updates must be adjusted slightly (compared with the previously described schedule for acyclic graphs) because graphs might not contain any leaves. Instead, one initializes all variable messages to 1 and uses the same message definitions above, updating all messages at every iteration (although messages coming from known leaves or tree-structured subgraphs may no longer need updating after sufficient iterations). It is easy to show that in a tree, the message definitions of this modified procedure will converge to the set of message definitions given above within a number of iterations equal to the <a class="uri" href="diameter" title="wikilink">diameter</a> of the tree.</p>

<p>The precise conditions under which loopy belief propagation will converge are still not well understood; it is known that on graphs containing a single loop it converges in most cases, but the probabilities obtained might be incorrect.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Several sufficient (but not necessary) conditions for convergence of loopy belief propagation to a unique fixed point exist.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> There exist graphs which will fail to converge, or which will oscillate between multiple states over repeated iterations. Techniques like <a href="EXIT_chart" title="wikilink">EXIT charts</a> can provide an approximate visualisation of the progress of belief propagation and an approximate test for convergence.</p>

<p>There are other approximate methods for marginalization including <a href="Variational_Bayesian_methods" title="wikilink">variational methods</a> and <a href="Monte_Carlo_method" title="wikilink">Monte Carlo methods</a>.</p>

<p>One method of exact marginalization in general graphs is called the <a href="junction_tree" title="wikilink">junction tree</a> algorithm, which is simply belief propagation on a modified graph guaranteed to be a tree. The basic premise is to eliminate cycles by clustering them into single nodes.</p>
<h2 id="related-algorithm-and-complexity-issues">Related algorithm and complexity issues</h2>

<p>A similar algorithm is commonly referred to as the <a href="Viterbi_algorithm" title="wikilink">Viterbi algorithm</a>, but also known as a special case of the max-product or min-sum algorithm, which solves the related problem of maximization, or most probable explanation. Instead of attempting to solve the marginal, the goal here is to find the values 

<math display="inline" id="Belief_propagation:13">
 <semantics>
  <mi>ùê±</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùê±</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 that maximises the global function (i.e. most probable values in a probabilistic setting), and it can be defined using the <a href="arg_max" title="wikilink">arg max</a>:</p>

<p>

<math display="block" id="Belief_propagation:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder>
      <mrow>
       <mpadded width="+1.7pt">
        <mi>arg</mi>
       </mpadded>
       <mi>max</mi>
      </mrow>
      <mi>ùê±</mi>
     </munder>
     <mi>g</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ùê±</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <times></times>
       <ci>arg</ci>
       <ci>max</ci>
      </apply>
      <ci>ùê±</ci>
     </apply>
     <ci>g</ci>
    </apply>
    <ci>ùê±</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname*{arg\,max}_{\mathbf{x}}g(\mathbf{x}).
  </annotation>
 </semantics>
</math>

</p>

<p>An algorithm that solves this problem is nearly identical to belief propagation, with the sums replaced by maxima in the definitions.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>It is worth noting that <a class="uri" href="inference" title="wikilink">inference</a> problems like marginalization and maximization are <a class="uri" href="NP-hard" title="wikilink">NP-hard</a> to solve exactly and approximately (at least for <a href="approximation_error" title="wikilink">relative error</a>) in a graphical model. More precisely, the marginalization problem defined above is <a href="Sharp-P-complete" title="wikilink">#P-complete</a> and maximization is <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>.</p>

<p>The memory usage of belief propagation can be reduced through the use of the <a href="Island_algorithm" title="wikilink">Island algorithm</a> (at a small cost in time complexity).</p>
<h2 id="relation-to-free-energy">Relation to free energy</h2>

<p>The sum-product algorithm is related to the calculation of <a href="Thermodynamic_free_energy" title="wikilink">free energy</a> in <a class="uri" href="thermodynamics" title="wikilink">thermodynamics</a>. Let <em>Z</em> be the <a href="partition_function_(mathematics)" title="wikilink">partition function</a>. A probability distribution</p>

<p>

<math display="block" id="Belief_propagation:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ùêó</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>Z</mi>
    </mfrac>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àè</mo>
      <msub>
       <mi>f</mi>
       <mi>j</mi>
      </msub>
     </munder>
     <mrow>
      <msub>
       <mi>f</mi>
       <mi>j</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>ùêó</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>Z</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\mathbf{X})=\frac{1}{Z}\prod_{f_{j}}f_{j}(x_{j})
  </annotation>
 </semantics>
</math>

</p>

<p>(as per the factor graph representation) can be viewed as a measure of the <a href="internal_energy" title="wikilink">internal energy</a> present in a system, computed as</p>

<p>

<math display="block" id="Belief_propagation:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ùêó</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">‚àè</mo>
       <msub>
        <mi>f</mi>
        <mi>j</mi>
       </msub>
      </munder>
      <mrow>
       <msub>
        <mi>f</mi>
        <mi>j</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>j</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>ùêó</ci>
    </apply>
    <apply>
     <times></times>
     <log></log>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbf{X})=\log\prod_{f_{j}}f_{j}(x_{j}).
  </annotation>
 </semantics>
</math>

</p>

<p>The free energy of the system is then</p>

<p>

<math display="block" id="Belief_propagation:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mo>=</mo>
    <mrow>
     <mi>U</mi>
     <mo>-</mo>
     <mi>H</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
       <mi>ùêó</mi>
      </munder>
      <mrow>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ùêó</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>E</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ùêó</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
       <mi>ùêó</mi>
      </munder>
      <mrow>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ùêó</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mi>log</mi>
        <mi>P</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ùêó</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>F</ci>
     <apply>
      <minus></minus>
      <ci>U</ci>
      <ci>H</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>ùêó</ci>
       </apply>
       <apply>
        <times></times>
        <ci>P</ci>
        <ci>ùêó</ci>
        <ci>E</ci>
        <ci>ùêó</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>ùêó</ci>
       </apply>
       <apply>
        <times></times>
        <ci>P</ci>
        <ci>ùêó</ci>
        <apply>
         <log></log>
         <ci>P</ci>
        </apply>
        <ci>ùêó</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F=U-H=\sum_{\mathbf{X}}P(\mathbf{X})E(\mathbf{X})+\sum_{\mathbf{X}}P(\mathbf{X%
})\log P(\mathbf{X}).
  </annotation>
 </semantics>
</math>

</p>

<p>It can then be shown that the points of convergence of the sum-product algorithm represent the points where the free energy in such a system is minimized. Similarly, it can be shown that a fixed point of the iterative belief propagation algorithm in graphs with cycles is a stationary point of a free energy approximation.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="generalized-belief-propagation-gbp">Generalized belief propagation (GBP)</h2>

<p>Belief propagation algorithms are normally presented as message update equations on a factor graph, involving messages between variable nodes and their neighboring factor nodes and vice versa. Considering messages between <em>regions</em> in a graph is one way of generalizing the belief propagation algorithm.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> There are several ways of defining the set of regions in a graph that can exchange messages. One method uses ideas introduced by <a href="Ryoichi_Kikuchi" title="wikilink">Kikuchi</a> in the physics literature, and is known as Kikuchi's <a href="cluster_variation_method" title="wikilink">cluster variation method</a>.</p>

<p>Improvements in the performance of belief propagation algorithms are also achievable by breaking the replicas symmetry in the distributions of the fields (messages). This generalization leads to a new kind of algorithm called <a href="survey_propagation" title="wikilink">survey propagation</a> (SP), which have proved to be very efficient in <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> problems like <a class="uri" href="satisfiability" title="wikilink">satisfiability</a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> and <a href="graph_coloring" title="wikilink">graph coloring</a>.</p>

<p>The cluster variational method and the survey propagation algorithms are two different improvements to belief propagation. The name <a href="generalized_survey_propagation" title="wikilink">generalized survey propagation</a> (GSP) is waiting to be assigned to the algorithm that merges both generalizations.</p>
<h2 id="gaussian-belief-propagation-gabp">Gaussian belief propagation (GaBP)</h2>

<p>Gaussian belief propagation is a variant of the belief propagation algorithm when the underlying <a href="normal_distribution" title="wikilink">distributions are Gaussian</a>. The first work analyzing this special model was the seminal work of Weiss and Freeman <a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>The GaBP algorithm solves the following marginalization problem:</p>

<p>

<math display="block" id="Belief_propagation:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>Z</mi>
    </mfrac>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">‚à´</mo>
      <mrow>
       <mi>j</mi>
       <mo>‚â†</mo>
       <mi>i</mi>
      </mrow>
     </msub>
     <mrow>
      <mrow>
       <mi>exp</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mo>-</mo>
          <mrow>
           <mrow>
            <mn>1</mn>
            <mo>/</mo>
            <mn>2</mn>
           </mrow>
           <msup>
            <mi>x</mi>
            <mi>T</mi>
           </msup>
           <mi>A</mi>
           <mi>x</mi>
          </mrow>
         </mrow>
         <mo>+</mo>
         <mrow>
          <msup>
           <mi>b</mi>
           <mi>T</mi>
          </msup>
          <mi>x</mi>
         </mrow>
        </mrow>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mi>d</mi>
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>Z</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <neq></neq>
        <ci>j</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <exp></exp>
        <apply>
         <plus></plus>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <apply>
            <divide></divide>
            <cn type="integer">1</cn>
            <cn type="integer">2</cn>
           </apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>x</ci>
            <ci>T</ci>
           </apply>
           <ci>A</ci>
           <ci>x</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>b</ci>
           <ci>T</ci>
          </apply>
          <ci>x</ci>
         </apply>
        </apply>
       </apply>
       <ci>d</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x_{i})=\frac{1}{Z}\int_{j\neq i}\exp(-1/2x^{T}Ax+b^{T}x)\,dx_{j}
  </annotation>
 </semantics>
</math>

</p>

<p>where Z is a normalization constant, <em>A</em> is a symmetric positive definite matrix (inverse covariance matrix a.k.a. precision matrix) and <em>b</em> is the shift vector.</p>

<p>Equivalently, it can be shown that using the Gaussian model, the solution of the marginalization problem is equivalent to the <a href="Maximum_A_Posteriori" title="wikilink">MAP</a> assignment problem:</p>

<p>

<math display="block" id="Belief_propagation:19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+5pt">
      <munder accentunder="true">
       <mo>argmax</mo>
       <mo>ùë•</mo>
      </munder>
     </mpadded>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>Z</mi>
     </mfrac>
     <mrow>
      <mi>exp</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mo>-</mo>
         <mrow>
          <mrow>
           <mn>1</mn>
           <mo>/</mo>
           <mn>2</mn>
          </mrow>
          <msup>
           <mi>x</mi>
           <mi>T</mi>
          </msup>
          <mi>A</mi>
          <mi>x</mi>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msup>
          <mi>b</mi>
          <mi>T</mi>
         </msup>
         <mi>x</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>x</ci>
      <ci>argmax</ci>
     </apply>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>Z</ci>
     </apply>
     <apply>
      <exp></exp>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <ci>T</ci>
         </apply>
         <ci>A</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>b</ci>
         <ci>T</ci>
        </apply>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underset{x}{\operatorname{argmax}}\ P(x)=\frac{1}{Z}\exp(-1/2x^{T}Ax+b^{T}x).
  </annotation>
 </semantics>
</math>

</p>

<p>This problem is also equivalent to the following minimization problem of the quadratic form:</p>

<p>

<math display="block" id="Belief_propagation:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <munder accentunder="true">
        <mo>min</mo>
        <mo>ùë•</mo>
       </munder>
       <mn>1</mn>
      </mrow>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
     <msup>
      <mi>x</mi>
      <mi>T</mi>
     </msup>
     <mi>A</mi>
     <mi>x</mi>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msup>
      <mi>b</mi>
      <mi>T</mi>
     </msup>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <ci>x</ci>
        <ci>min</ci>
       </apply>
       <cn type="float">1</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>T</ci>
     </apply>
     <ci>A</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <ci>T</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underset{x}{\operatorname{min}}\ 1/2x^{T}Ax-b^{T}x.
  </annotation>
 </semantics>
</math>

</p>

<p>Which is also equivalent to the linear system of equations</p>

<p>

<math display="block" id="Belief_propagation:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mi>x</mi>
    </mrow>
    <mo>=</mo>
    <mi>b</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>x</ci>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ax=b.
  </annotation>
 </semantics>
</math>

</p>

<p>Convergence of the GaBP algorithm is easier to analyze (relatively to the general BP case) and there are two known sufficient convergence conditions. The first one was formulated by Weiss et al. in the year 2000, when the information matrix A is <a href="diagonally_dominant" title="wikilink">diagonally dominant</a>. The second convergence condition was formulated by Johnson et al.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> in 2006, when the <a href="spectral_radius" title="wikilink">spectral radius</a> of the matrix</p>

<p>

<math display="block" id="Belief_propagation:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>œÅ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>I</mi>
      <mo>-</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <msup>
         <mi>D</mi>
         <mrow>
          <mo>-</mo>
          <mrow>
           <mn>1</mn>
           <mo>/</mo>
           <mn>2</mn>
          </mrow>
         </mrow>
        </msup>
        <mi>A</mi>
        <msup>
         <mi>D</mi>
         <mrow>
          <mo>-</mo>
          <mrow>
           <mn>1</mn>
           <mo>/</mo>
           <mn>2</mn>
          </mrow>
         </mrow>
        </msup>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mpadded width="+1.7pt">
    <mn>1</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>œÅ</ci>
     <apply>
      <minus></minus>
      <ci>I</ci>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>D</ci>
         <apply>
          <minus></minus>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
        <ci>A</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>D</ci>
         <apply>
          <minus></minus>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(I-|D^{-1/2}AD^{-1/2}|)<1\,
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>D</em> = diag(<em>A</em>). Later, Su and Wu established the necessary and sufficient convergence conditions for synchronous GaBP and damped GaBP, as well as another sufficient convergence condition for asynchronous GaBP. For each case, the convergence condition involves verifying 1) a set (determined by A) being non-empty, 2) the spectral radius of a certain matrix being smaller than one, and 3) the singularity issue (when converting BP message into belief) does not occur.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>The GaBP algorithm was linked to the linear algebra domain,<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> and it was shown that the GaBP algorithm can be viewed as an iterative algorithm for solving the linear system of equations <em>Ax</em> = <em>b</em> where <em>A</em> is the information matrix and <em>b</em> is the shift vector. Empirically, the GaBP algorithm is shown to converge faster than classical iterative methods like the Jacobi method, the <a href="Gauss‚ÄìSeidel_method" title="wikilink">Gauss‚ÄìSeidel method</a>, <a href="successive_over-relaxation" title="wikilink">successive over-relaxation</a>, and others.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> Additionally, the GaBP algorithm is shown to be immune to numerical problems of the preconditioned <a href="Conjugate_gradient_method" title="wikilink">conjugate gradient</a> method <a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<h2 id="references">References</h2>
<h2 id="notes">Notes</h2>
<ul>
<li>Frey, Brendan (1998). <em>Graphical Models for Machine Learning and Digital Communication</em>. MIT Press</li>
<li>L√∂liger, Hans-Andrea (2004). <em>An Introduction to Factor Graphs</em>. IEEE Signal Proc. Mag. Vol.21. pages 28‚Äì41</li>
<li><a href="David_J.C._MacKay" title="wikilink">David J.C. MacKay</a> (2003). Exact Marginalization in Graphs. In David J.C. MacKay, <em>Information Theory, Inference, and Learning Algorithms</em>, pp.¬†334‚Äì340. Cambridge: Cambridge University Press.</li>
<li>Mackenzie, Dana (2005). <a href="http://www.newscientist.com/channel/info-tech/mg18725071.400"><em>Communication Speed Nears Terminal Velocity</em></a> New Scientist. 9 July 2005. Issue 2507 (Registration required)</li>
<li></li>
<li></li>
<li></li>
<li>Koch, Volker M. (2007). [<a class="uri" href="http://www.volker-koch.com/diss/">http://www.volker-koch.com/diss/</a><em>A Factor Graph Approach to Model-Based Signal Separation</em>] --- A tutorial-style dissertation</li>
<li></li>
<li>Bickson, Danny. (2009). [<a class="uri" href="http://www.cs.cmu.edu/~bickson/gabp/index.html">http://www.cs.cmu.edu/~bickson/gabp/index.html</a><em>Gaussian Belief Propagation Resource Page</em>] --- Webpage containing recent publications as well as Matlab source code.</li>
<li>Coughlan, James. (2009). [<a class="uri" href="http://computerrobotvision.org/2009/tutorial_day/crv09_belief_propagation_v2.pdf">http://computerrobotvision.org/2009/tutorial_day/crv09_belief_propagation_v2.pdf</a><em>A Tutorial Introduction to Belief Propagation</em>].</li>
</ul>

<p>"</p>

<p><a href="Category:Graph_algorithms" title="wikilink">Category:Graph algorithms</a> <a href="Category:Graphical_models" title="wikilink">Category:Graphical models</a> <a href="Category:Coding_theory" title="wikilink">Category:Coding theory</a> <a href="Category:Probability_theory" title="wikilink">Category:Probability theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"><a href="#fnref2">‚Ü©</a></li>
<li id="fn3"><a href="#fnref3">‚Ü©</a></li>
<li id="fn4"><a href="#fnref4">‚Ü©</a></li>
<li id="fn5"><a href="#fnref5">‚Ü©</a></li>
<li id="fn6"><a href="#fnref6">‚Ü©</a></li>
<li id="fn7"><a href="#fnref7">‚Ü©</a></li>
<li id="fn8"><a href="#fnref8">‚Ü©</a></li>
<li id="fn9"><a href="#fnref9">‚Ü©</a></li>
<li id="fn10"></li>
<li id="fn11"><a href="#fnref11">‚Ü©</a></li>
<li id="fn12"><a href="#fnref12">‚Ü©</a></li>
<li id="fn13"><a href="#fnref13">‚Ü©</a></li>
<li id="fn14"><a href="#fnref14">‚Ü©</a></li>
<li id="fn15">Gaussian belief propagation solver for systems of linear equations. By O. Shental, D. Bickson, P. H. Siegel, J. K. Wolf, and D. Dolev, IEEE Int. Symp. on Inform. Theory (ISIT), Toronto, Canada, July 2008. <a class="uri" href="http://www.cs.huji.ac.il/labs/danss/p2p/gabp/">http://www.cs.huji.ac.il/labs/danss/p2p/gabp/</a><a href="#fnref15">‚Ü©</a></li>
<li id="fn16">Linear Detection via Belief Propagation. Danny Bickson, Danny Dolev, Ori Shental, Paul H. Siegel and Jack K. Wolf. In the 45th Annual Allerton Conference on Communication, Control, and Computing, Allerton House, Illinois, 7 Sept.. <a class="uri" href="http://www.cs.huji.ac.il/labs/danss/p2p/gabp/">http://www.cs.huji.ac.il/labs/danss/p2p/gabp/</a><a href="#fnref16">‚Ü©</a></li>
<li id="fn17">Distributed large scale network utility maximization. D. Bickson, Y. Tock, A. Zymnis, S. Boyd and D. Dolev. In the International symposium on information theory (ISIT), July 2009. <a class="uri" href="http://www.cs.huji.ac.il/labs/danss/p2p/gabp/">http://www.cs.huji.ac.il/labs/danss/p2p/gabp/</a><a href="#fnref17">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
