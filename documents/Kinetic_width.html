<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="183">Kinetic width</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Kinetic width</h1>
<hr/>

<p>A <strong>kinetic width</strong> data structure is a <a href="kinetic_data_structure" title="wikilink">kinetic data structure</a> which maintains the <a class="uri" href="width" title="wikilink">width</a> of a set of moving points. In 2D, the width of a point set is the minimum distance between two parallel lines that contain the point set in the strip between them. For the two dimensional case, the kinetic data structure for <a href="kinetic_convex_hull" title="wikilink">kinetic convex hull</a> can be used to construct a kinetic data structure for the width of a point set that is <a href="Kinetic_data_structure#Performance" title="wikilink">responsive</a>, <a href="Kinetic_data_structure#Performance" title="wikilink">compact</a> and <a href="Kinetic_data_structure#Performance" title="wikilink">efficient</a>.</p>
<h2 id="d-case">2D case</h2>

<p>Consider the parallel lines which contain the point set in the strip between them and are of minimal distance apart. One of the lines must contain an edge 

<math display="inline" id="Kinetic_width:0">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ab
  </annotation>
 </semantics>
</math>

 of the convex hull, and the other line must go through a point c of the convex hull such that (a,c) and (b,c) are <a href="antipodal_pairs" title="wikilink">antipodal pairs</a>. ab and c are referred to as an antipodal edge-vertex pair. Consider the <a href="Duality_(projective_geometry)" title="wikilink">dual</a> of the point set. The points dualize to lines and the convex hull of the points dualizes to the upper and lower envelope of the set of lines. The vertices of the upper convex hull dualize to segments on the upper envelope. The vertices of the lower convex hull dualize to segments on the lower envelope. The range of slopes of the supporting lines of a point on the hull dualize to the x-interval of segment that point dualizes to. When viewed in this dualized fashion the antipodal pairs, are pairs of segments, one from the upper envelope, one from the lower, with overlapping x ranges. Now, the upper and lower envelopes can be viewed as two different x-ordered lists of non overlapping intervals. If these two lists are merged, the antipodal pairs are the overlaps in the merged list. If a pair 

<math display="inline" id="Kinetic_width:1">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ab
  </annotation>
 </semantics>
</math>

 and c is an antipodal edge-vertex pair, then the x-interval for a and b must both intersect the x-interval for c. This means that the common endpoint of the x intervals for a and b must lie within the x-interval for c.</p>

<p>The endpoints of both of the sets of x-intervals can be maintained in a <a href="kinetic_sorted_list" title="wikilink">kinetic sorted list</a>. When points swap, the list of antipodal edge-point pairs are updated appropriately. The upper and lower envelopes can be maintained using the standard data structure for <a href="kinetic_convex_hull" title="wikilink">kinetic convex hull</a>. The minimum distance between edge-point pairs can be maintained with a <a href="kinetic_tournament" title="wikilink">kinetic tournament</a>. Thus, using kinetic convex hull to maintain the upper and lower envelopes, a kinetic sorted list on these intervals to maintain the antipodal edge-vertex pairs, and a kinetic tournament to maintain the pair of minimum distance apart, the diameter of a moving point set can be maintained.</p>

<p>This data structure is <a href="Kinetic_data_structure#Performance" title="wikilink">responsive</a>, <a href="Kinetic_data_structure#Performance" title="wikilink">compact</a> and <a href="Kinetic_data_structure#Performance" title="wikilink">efficient</a>. The data structure uses 

<math display="inline" id="Kinetic_width:2">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 space because the kinetic convex hull, sorted list, and tournament data structures all use 

<math display="inline" id="Kinetic_width:3">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 space. In all of the data structures, events, inserts, and deletes can be handled in 

<math display="inline" id="Kinetic_width:4">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>log</mi>
      <mn>2</mn>
     </msup>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log^{2}n)
  </annotation>
 </semantics>
</math>

 time, so the data structure are responsive, requiring 

<math display="inline" id="Kinetic_width:5">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>log</mi>
      <mn>2</mn>
     </msup>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log^{2}n)
  </annotation>
 </semantics>
</math>

 per event. The data structure is efficient because the total number of events is 

<math display="inline" id="Kinetic_width:6">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mrow>
      <mn>2</mn>
      <mo>+</mo>
      <mi>ϵ</mi>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <plus></plus>
      <cn type="integer">2</cn>
      <ci>ϵ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2+\epsilon})
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Kinetic_width:7">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>ϵ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon>0
  </annotation>
 </semantics>
</math>

 and the width of a point set can change 

<math display="inline" id="Kinetic_width:8">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(n^{2})
  </annotation>
 </semantics>
</math>

 times, even if the points are moving linearly. This data structure is not <a href="Kinetic_data_structure#Performance" title="wikilink">local</a> because one point may be in many antipodal edge-vertex pairs, and thus appear many times in the kinetic tournament.</p>

<p>The existence of a local kinetic data structure for width is open.</p>
<h2 id="higher-dimensions">Higher Dimensions</h2>

<p>Efficiently maintaining the kinetic width of a point set in dimensions higher than 2 is an open problem. Efficient <a href="kinetic_convex_hull" title="wikilink">kinetic convex hull</a> in dimensions higher than 2 is also an open problem.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="related-problems">Related Problems</h2>
<ul>
<li><a href="Kinetic_diameter" title="wikilink">Kinetic diameter</a></li>
<li><a href="Kinetic_minimum_box" title="wikilink">Kinetic minimum box</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>

<p>P. K. Agarwal, L. J. Guibas, J. Hershberger, and E. Verach. Maintaining the extent of a moving set of points.</p>

<p>"</p>

<p><a href="Category:Articles_created_via_the_Article_Wizard" title="wikilink">Category:Articles created via the Article Wizard</a> <a href="Category:Kinetic_data_structures" title="wikilink">Category:Kinetic data structures</a> <a href="Category:Geometric_data_structures" title="wikilink">Category:Geometric data structures</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
