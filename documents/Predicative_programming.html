<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="599">Predicative programming</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Predicative programming</h1>
<hr/>

<p><strong>Predicative programming</strong> is a methodology for program <a href="specification_language" title="wikilink">specification</a> and <a href="program_refinement" title="wikilink">refinement</a>. The central idea of predicative programming is that each specification is a predicate (generally written as a boolean expression) that is true of acceptable behaviours and false of unacceptable behaviours. It follows that refinement is reversed implication universally quantified over behaviours:</p>

<p>

<math display="block" id="Predicative_programming:0">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo>⊑</mo>
    <mi>Q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>b</mi>
    <mo>⋅</mo>
    <mi>Q</mi>
    <mo>⇒</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <csymbol cd="latexml">square-image-of-or-equals</csymbol>
     <csymbol cd="unknown">Q</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-⋅</ci>
     <csymbol cd="unknown">Q</csymbol>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P\sqsubseteq Q)\equiv(\forall b\cdot Q\Rightarrow P)
  </annotation>
 </semantics>
</math>

 Commands in a programming language are considered to be a special case of specifications—special only because they are compilable. For example in an environment where the program variables are 

<math display="inline" id="Predicative_programming:1">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Predicative_programming:2">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Predicative_programming:3">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

, the command 

<math display="inline" id="Predicative_programming:4">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>:=</mo>
   <mrow>
    <mi>y</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x:=y+1\,\!
  </annotation>
 </semantics>
</math>

 is considered equivalent to the predicate (represented here by a boolean expression)</p>

<p>

<math display="block" id="Predicative_programming:5">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo>∧</mo>
    <msup>
     <mi>y</mi>
     <mo>′</mo>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>y</mi>
    <mo>∧</mo>
    <msup>
     <mi>z</mi>
     <mo>′</mo>
    </msup>
   </mrow>
   <mo>=</mo>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <and></and>
      <apply>
       <plus></plus>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <and></and>
      <ci>y</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}=y+1\land y^{\prime}=y\land z^{\prime}=z
  </annotation>
 </semantics>
</math>

 in which 

<math display="inline" id="Predicative_programming:6">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Predicative_programming:7">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Predicative_programming:8">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 represent the initial values of the program variables and 

<math display="inline" id="Predicative_programming:9">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Predicative_programming:10">
 <semantics>
  <msup>
   <mi>y</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>y</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Predicative_programming:11">
 <semantics>
  <msup>
   <mi>z</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>z</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{\prime}
  </annotation>
 </semantics>
</math>

 represent the final values of the program variables. Thus</p>

<p>

<math display="block" id="Predicative_programming:12">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
   <mo>></mo>
   <mi>y</mi>
   <mo>⊑</mo>
   <mi>x</mi>
   <mo>:=</mo>
   <mrow>
    <mi>y</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <gt></gt>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>y</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">square-image-of-or-equals</csymbol>
     <share href="#.cmml">
     </share>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}>y\sqsubseteq x:=y+1
  </annotation>
 </semantics>
</math>

</p>
<h2 id="bibliography">Bibliography</h2>
<ul>
<li>E.C.R. Hehner, <em>a Practical Theory of Programming</em>, Springer-Verlag 1993. Most recent edition online at <a href="http://www.cs.toronto.edu/~hehner/aPToP">a Practical Theory of Programming</a>.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cs.toronto.edu/~hehner/publist.html">Publications by </a><a href="Eric_Hehner" title="wikilink">Eric Hehner</a>.</li>
</ul>

<p>"</p>

<p><a href="Category:Formal_methods" title="wikilink">Category:Formal methods</a> <a href="Category:Formal_specification_languages" title="wikilink">Category:Formal specification languages</a> <a href="Category:Logical_calculi" title="wikilink">Category:Logical calculi</a></p>
</body>
</html>
