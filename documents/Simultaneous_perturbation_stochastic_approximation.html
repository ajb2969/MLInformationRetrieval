<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1039">Simultaneous perturbation stochastic approximation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Simultaneous perturbation stochastic approximation</h1>
<hr/>

<p><strong>Simultaneous perturbation stochastic approximation</strong> (SPSA) is an <a class="uri" href="algorithmic" title="wikilink">algorithmic</a> method for optimizing systems with multiple unknown <a class="uri" href="parameters" title="wikilink">parameters</a>. It is a type of <a href="stochastic_approximation" title="wikilink">stochastic approximation</a> algorithm. As an optimization method, it is appropriately suited to large-scale population models, adaptive modeling, simulation <a class="uri" href="optimization" title="wikilink">optimization</a>, and <a href="atmospheric_model" title="wikilink">atmospheric modeling</a>. Many examples are presented at the SPSA website <a class="uri" href="http://www.jhuapl.edu/SPSA">http://www.jhuapl.edu/SPSA</a>. A comprehensive recent book on the subject is Bhatnagar et al. (2013). An early paper on the subject is Spall (1987) and the foundational paper providing the key theory and justification is Spall (1992).</p>

<p>SPSA is a descent method capable of finding global minima, sharing this property with other methods as simulated annealing. Its main feature is the gradient approximation that requires only two measurements of the objective function, regardless of the dimension of the optimization problem. Recall that we want to find the optimal control 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:0">
 <semantics>
  <msup>
   <mi>u</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>u</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u^{*}
  </annotation>
 </semantics>
</math>

 with loss function 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:1">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>J</ci>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J(u)
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Simultaneous_perturbation_stochastic_approximation:2">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>u</mi>
     <mo>*</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>arg</mi>
      <mrow>
       <munder>
        <mi>min</mi>
        <mrow>
         <mi>u</mi>
         <mo>∈</mo>
         <mi>U</mi>
        </mrow>
       </munder>
       <mi>J</mi>
      </mrow>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>u</ci>
     <times></times>
    </apply>
    <apply>
     <times></times>
     <apply>
      <arg></arg>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <min></min>
        <apply>
         <in></in>
         <ci>u</ci>
         <ci>U</ci>
        </apply>
       </apply>
       <ci>J</ci>
      </apply>
     </apply>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u^{*}=\arg\min_{u\in U}J(u).
  </annotation>
 </semantics>
</math>

</p>

<p>Both <a href="Finite_Differences_Stochastic_Approximation" title="wikilink">Finite Differences Stochastic Approximation</a> (FDSA) and SPSA use the same iterative process:</p>

<p>

<math display="block" id="Simultaneous_perturbation_stochastic_approximation:3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>u</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>u</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>n</mi>
      </msub>
      <msub>
       <mover accent="true">
        <mi>g</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>u</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>g</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{n+1}=u_{n}-a_{n}\hat{g}_{n}(u_{n}),
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:4">
 <semantics>
  <mrow>
   <msub>
    <mi>u</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>u</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>u</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>u</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>p</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>n</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>n</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>n</ci>
       </apply>
       <ci>p</ci>
      </apply>
     </vector>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{n}=((u_{n})_{1},(u_{n})_{2},\ldots,(u_{n})_{p})^{T}
  </annotation>
 </semantics>
</math>

 represents the 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:5">
 <semantics>
  <msup>
   <mi>n</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{th}
  </annotation>
 </semantics>
</math>

 iterate, 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:6">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>u</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>g</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{g}_{n}(u_{n})
  </annotation>
 </semantics>
</math>

 is the estimate of the gradient of the objective function 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mo>∂</mo>
     <mrow>
      <mo>∂</mo>
      <mi>u</mi>
     </mrow>
    </mfrac>
    <mi>J</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>u</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <partialdiff></partialdiff>
      <apply>
       <partialdiff></partialdiff>
       <ci>u</ci>
      </apply>
     </apply>
     <ci>J</ci>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(u)=\frac{\partial}{\partial u}J(u)
  </annotation>
 </semantics>
</math>

 evaluated at 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:8">
 <semantics>
  <msub>
   <mi>u</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {u_{n}}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:9">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>a</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a_{n}\}
  </annotation>
 </semantics>
</math>

 is a positive number sequence converging to 0. If 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:10">
 <semantics>
  <msub>
   <mi>u</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{n}
  </annotation>
 </semantics>
</math>

 is a <em>p</em>-dimensional vector, the 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:11">
 <semantics>
  <msup>
   <mi>i</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>i</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i^{th}
  </annotation>
 </semantics>
</math>

 component of the <a class="uri" href="symmetric" title="wikilink">symmetric</a> finite difference gradient estimator is:</p>
<dl>
<dd><strong>FD:</strong> 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mover accent="true">
        <msub>
         <mi>g</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">^</mo>
       </mover>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>u</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mi>J</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>u</mi>
          <mi>n</mi>
         </msub>
         <mo>+</mo>
         <mrow>
          <msub>
           <mi>c</mi>
           <mi>n</mi>
          </msub>
          <msub>
           <mi>e</mi>
           <mi>i</mi>
          </msub>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>J</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>u</mi>
          <mi>n</mi>
         </msub>
         <mo>-</mo>
         <mrow>
          <msub>
           <mi>c</mi>
           <mi>n</mi>
          </msub>
          <msub>
           <mi>e</mi>
           <mi>i</mi>
          </msub>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mrow>
      <mn>2</mn>
      <msub>
       <mi>c</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <times></times>
      <apply>
       <ci>normal-^</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>J</ci>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>c</ci>
          <ci>n</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>e</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>J</ci>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>c</ci>
          <ci>n</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>e</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\hat{g_{n}}(u_{n}))_{i}=\frac{J(u_{n}+c_{n}e_{i})-J(u_{n}-c_{n}e_{i})}{2c_{n}},
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p><em>1 ≤i ≤p</em>, where 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:13">
 <semantics>
  <msub>
   <mi>e</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{i}
  </annotation>
 </semantics>
</math>

 is the unit vector with a 1 in the 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:14">
 <semantics>
  <msup>
   <mi>i</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>i</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i^{th}
  </annotation>
 </semantics>
</math>

 place, and 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:15">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{n}
  </annotation>
 </semantics>
</math>

is a small positive number that decreases with <em>n</em>. With this method, <em>2p</em> evaluations of <em>J</em> for each 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:16">
 <semantics>
  <msub>
   <mi>g</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{n}
  </annotation>
 </semantics>
</math>

 are needed. Clearly, when <em>p</em> is large, this estimator loses efficiency.</p>

<p>Let now 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:17">
 <semantics>
  <msub>
   <mi mathvariant="normal">Δ</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Δ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta_{n}
  </annotation>
 </semantics>
</math>

 be a random perturbation vector. The 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:18">
 <semantics>
  <msup>
   <mi>i</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>i</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i^{th}
  </annotation>
 </semantics>
</math>

 component of the stochastic perturbation gradient estimator is:</p>
<dl>
<dd><strong>SP:</strong> 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:19">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mover accent="true">
        <msub>
         <mi>g</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">^</mo>
       </mover>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>u</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mi>J</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>u</mi>
          <mi>n</mi>
         </msub>
         <mo>+</mo>
         <mrow>
          <msub>
           <mi>c</mi>
           <mi>n</mi>
          </msub>
          <msub>
           <mi mathvariant="normal">Δ</mi>
           <mi>n</mi>
          </msub>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>J</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>u</mi>
          <mi>n</mi>
         </msub>
         <mo>-</mo>
         <mrow>
          <msub>
           <mi>c</mi>
           <mi>n</mi>
          </msub>
          <msub>
           <mi mathvariant="normal">Δ</mi>
           <mi>n</mi>
          </msub>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mrow>
      <mn>2</mn>
      <msub>
       <mi>c</mi>
       <mi>n</mi>
      </msub>
      <msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi mathvariant="normal">Δ</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>i</mi>
      </msub>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <times></times>
      <apply>
       <ci>normal-^</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>J</ci>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>c</ci>
          <ci>n</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>normal-Δ</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>J</ci>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>c</ci>
          <ci>n</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>normal-Δ</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Δ</ci>
        <ci>n</ci>
       </apply>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\hat{g_{n}}(u_{n}))_{i}=\frac{J(u_{n}+c_{n}\Delta_{n})-J(u_{n}-c_{n}\Delta_{n%
})}{2c_{n}(\Delta_{n})_{i}}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>Remark that FD perturbs only one direction at a time, while the SP estimator disturbs all directions at the same time (the numerator is identical in all <em>p</em> components). The number of loss function measurements needed in the SPSA method for each 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:20">
 <semantics>
  <msub>
   <mi>g</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{n}
  </annotation>
 </semantics>
</math>

 is always 2, independent of the <a class="uri" href="dimension" title="wikilink">dimension</a> <em>p</em>. Thus, SPSA uses <em>p</em> times fewer function evaluations than FDSA, which makes it a lot more efficient.</p>

<p>Simple experiments with <em>p=2</em> showed that SPSA converges in the same number of iterations as FDSA. The latter follows <a href="Approximation" title="wikilink">approximately</a> the <a class="uri" href="steepest" title="wikilink">steepest</a> descent direction, behaving like the gradient method. On the other hand, SPSA, with the random search direction, does not follow exactly the gradient path. In average though, it tracks it nearly because the gradient approximation is an almost <a class="uri" href="unbiased" title="wikilink">unbiased</a> estimator of the gradient, as shown in the following lemma.</p>
<h2 id="convergence-lemma">Convergence lemma</h2>

<p>Denote by</p>

<p>

<math display="block" id="Simultaneous_perturbation_stochastic_approximation:21">
 <semantics>
  <mrow>
   <msub>
    <mi>b</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mover accent="true">
      <mi>g</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>u</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>-</mo>
   <mo>∇</mo>
   <mi>J</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>u</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <ci>n</ci>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>g</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <minus></minus>
    <ci>normal-∇</ci>
    <csymbol cd="unknown">J</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{n}=E[\hat{g}_{n}|u_{n}]-\nabla J(u_{n})
  </annotation>
 </semantics>
</math>

</p>

<p>the bias in the estimator 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:22">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>g</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>g</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{g}_{n}
  </annotation>
 </semantics>
</math>

. Assume that 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:23">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi mathvariant="normal">Δ</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Δ</ci>
      <ci>n</ci>
     </apply>
     <ci>i</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(\Delta_{n})_{i}\}
  </annotation>
 </semantics>
</math>

 are all mutually independent with zero-mean, bounded second moments, and 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:24">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi mathvariant="normal">Δ</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">|</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Δ</ci>
        <ci>n</ci>
       </apply>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(|(\Delta_{n})_{i}|^{-1})
  </annotation>
 </semantics>
</math>

 uniformly bounded. Then 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:25">
 <semantics>
  <msub>
   <mi>b</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>b</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{n}
  </annotation>
 </semantics>
</math>

→0 w.p. 1.</p>
<h2 id="sketch-of-the-proof">Sketch of the proof</h2>

<p>The main <a class="uri" href="idea" title="wikilink">idea</a> is to use conditioning on 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:26">
 <semantics>
  <msub>
   <mi mathvariant="normal">Δ</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Δ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta_{n}
  </annotation>
 </semantics>
</math>

 to express 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:27">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mover accent="true">
        <mi>g</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>g</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[(\hat{g}_{n})_{i}]
  </annotation>
 </semantics>
</math>

 and then to use a second order Taylor expansion of 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:28">
 <semantics>
  <mrow>
   <mi>J</mi>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>u</mi>
       <mi>n</mi>
      </msub>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>c</mi>
        <mi>n</mi>
       </msub>
       <msub>
        <mi mathvariant="normal">Δ</mi>
        <mi>n</mi>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>J</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Δ</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J(u_{n}+c_{n}\Delta_{n})_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:29">
 <semantics>
  <mrow>
   <mi>J</mi>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>u</mi>
       <mi>n</mi>
      </msub>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>c</mi>
        <mi>n</mi>
       </msub>
       <msub>
        <mi mathvariant="normal">Δ</mi>
        <mi>n</mi>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>J</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Δ</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J(u_{n}-c_{n}\Delta_{n})_{i}
  </annotation>
 </semantics>
</math>

. After algebraic manipulations using the zero mean and the independence of 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:30">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi mathvariant="normal">Δ</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Δ</ci>
      <ci>n</ci>
     </apply>
     <ci>i</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(\Delta_{n})_{i}\}
  </annotation>
 </semantics>
</math>

, we get</p>

<p>

<math display="block" id="Simultaneous_perturbation_stochastic_approximation:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mover accent="true">
         <mi>g</mi>
         <mo stretchy="false">^</mo>
        </mover>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>g</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>i</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msubsup>
       <mi>c</mi>
       <mi>n</mi>
       <mn>2</mn>
      </msubsup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>g</ci>
        </apply>
        <ci>n</ci>
       </apply>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <ci>n</ci>
      </apply>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>n</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[(\hat{g}_{n})_{i}]=(g_{n})_{i}+O(c_{n}^{2})
  </annotation>
 </semantics>
</math>

</p>

<p>The result follows from the <a class="uri" href="hypothesis" title="wikilink">hypothesis</a> that 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:32">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{n}
  </annotation>
 </semantics>
</math>

→0.</p>

<p>Next we resume some of the hypotheses under which 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:33">
 <semantics>
  <msub>
   <mi>u</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{t}
  </annotation>
 </semantics>
</math>

 converges in <a class="uri" href="probability" title="wikilink">probability</a> to the set of global minima of 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:34">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>J</ci>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J(u)
  </annotation>
 </semantics>
</math>

. The efficiency of the method depends on the shape of 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:35">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>J</ci>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J(u)
  </annotation>
 </semantics>
</math>

, the values of the parameters 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:36">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{k}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:37">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{k}
  </annotation>
 </semantics>
</math>

 and the distribution of the perturbation terms 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:38">
 <semantics>
  <msub>
   <mi mathvariant="normal">Δ</mi>
   <mrow>
    <mi>k</mi>
    <mi>i</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Δ</ci>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta_{ki}
  </annotation>
 </semantics>
</math>

. First, the algorithm parameters must satisfy the following conditions:</p>
<ul>
<li>

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:39">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{t}
  </annotation>
 </semantics>
</math>

 &gt;0, 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:40">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{t}
  </annotation>
 </semantics>
</math>

→0 when t→∝ and 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:41">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>t</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <msub>
     <mi>a</mi>
     <mi>t</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{t=1}^{\infty}a_{t}=\infty
  </annotation>
 </semantics>
</math>

. A good choice would be 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:42">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mi>t</mi>
    </msub>
    <mo>=</mo>
    <mfrac>
     <mi>a</mi>
     <mi>t</mi>
    </mfrac>
   </mrow>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <divide></divide>
     <ci>a</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{t}=\frac{a}{t};
  </annotation>
 </semantics>
</math>

 a&gt;0;</li>
<li>

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:43">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mi>c</mi>
    <msup>
     <mi>t</mi>
     <mi>γ</mi>
    </msup>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <divide></divide>
     <ci>c</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <ci>γ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{t}=\frac{c}{t^{\gamma}}
  </annotation>
 </semantics>
</math>

, where c&gt;0, 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:44">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo>∈</mo>
   <mrow>
    <mo>[</mo>
    <mfrac>
     <mn>1</mn>
     <mn>6</mn>
    </mfrac>
    <mo>,</mo>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>γ</ci>
    <interval closure="closed">
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">6</cn>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma\in\left[\frac{1}{6},\frac{1}{2}\right]
  </annotation>
 </semantics>
</math>

;</li>
<li>

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:45">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>t</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mfrac>
       <msub>
        <mi>a</mi>
        <mi>t</mi>
       </msub>
       <msub>
        <mi>c</mi>
        <mi>t</mi>
       </msub>
      </mfrac>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo><</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{t=1}^{\infty}(\frac{a_{t}}{c_{t}})^{2}<\infty
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:46">
 <semantics>
  <msub>
   <mi mathvariant="normal">Δ</mi>
   <mrow>
    <mi>t</mi>
    <mi>i</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Δ</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta_{ti}
  </annotation>
 </semantics>
</math>

 must be mutually independent zero-mean random variables, symmetrically distributed about zero, with 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:47">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Δ</mi>
    <mrow>
     <mi>k</mi>
     <mi>i</mi>
    </mrow>
   </msub>
   <mo><</mo>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
   <mo><</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Δ</ci>
      <apply>
       <times></times>
       <ci>k</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta_{ki}<a_{1}<\infty
  </annotation>
 </semantics>
</math>

. The inverse first and second moments of the 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:48">
 <semantics>
  <msub>
   <mi mathvariant="normal">Δ</mi>
   <mrow>
    <mi>t</mi>
    <mi>i</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Δ</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta_{ti}
  </annotation>
 </semantics>
</math>

 must be finite.</li>
</ul>

<p>A good choice for 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:49">
 <semantics>
  <msub>
   <mi mathvariant="normal">Δ</mi>
   <mrow>
    <mi>k</mi>
    <mi>i</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Δ</ci>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta_{ki}
  </annotation>
 </semantics>
</math>

 is Bernoulli +-1 with probability 0.5 (other choices are possible too). The uniform and normal distributions do not satisfy the finite inverse moment conditions, so can not be used.</p>

<p>The loss function <em>J(u)</em> must be thrice continuously <a class="uri" href="differentiable" title="wikilink">differentiable</a> and the individual elements of the third derivative must be bounded

<math display="block" id="Simultaneous_perturbation_stochastic_approximation:50">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msup>
      <mi>J</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>3</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo><</mo>
   <msub>
    <mi>a</mi>
    <mn>3</mn>
   </msub>
   <mo><</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>J</ci>
        <cn type="integer">3</cn>
       </apply>
       <ci>u</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |J^{(3)}(u)|<a_{3}<\infty
  </annotation>
 </semantics>
</math>

. Also, <em>|J(u)|→∝</em> as <em>u→∝</em>.</p>

<p>In addition, 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:51">
 <semantics>
  <mrow>
   <mo>∇</mo>
   <mi>J</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-∇</ci>
    <ci>J</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla J
  </annotation>
 </semantics>
</math>

 must be Lipschitz continuous, bounded and the ODE 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:52">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>u</mi>
    <mo>˙</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-˙</ci>
     <ci>u</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{u}=g(u)
  </annotation>
 </semantics>
</math>

 must have a unique solution for each initial condition. Under these conditions and a few others, 

<math display="inline" id="Simultaneous_perturbation_stochastic_approximation:53">
 <semantics>
  <msub>
   <mi>u</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{k}
  </annotation>
 </semantics>
</math>

 <a href="Convergence_(mathematics)" title="wikilink">converges</a> in probability to the set of global minima of J(u) (see Maryak and Chin, 2008).</p>
<h2 id="references">References</h2>
<ul>
<li>Bhatnagar, S., Prasad, H. L., and Prashanth, L. A. (2013), <em>Stochastic Recursive Algorithms for Optimization: Simultaneous Perturbation Methods</em>, Springer <a href="http://link.springer.com/book/10.1007/978-1-4471-4285-0">1</a>.</li>
<li>Hirokami, T., Maeda, Y., Tsukada, H. (2006) "Parameter estimation using simultaneous perturbation stochastic approximation", Electrical Engineering in Japan, 154 (2), 30–3 <a href="http://dx.doi.org/10.1002/eej.20239">2</a></li>
<li>Maryak, J.L., and Chin, D.C. (2008), "Global Random Optimization by Simultaneous Perturbation Stochastic Approximation," <em>IEEE Transactions on Automatic Control</em>, vol. 53, pp. 780-783.</li>
<li>Spall, J. C. (1987), “A Stochastic Approximation Technique for Generating Maximum Likelihood Parameter Estimates,” <em>Proceedings of the American Control Conference</em>, Minneapolis, MN, June 1987, pp. 1161–1167.</li>
<li>Spall, J. C. (1992), “Multivariate Stochastic Approximation Using a Simultaneous Perturbation Gradient Approximation,” <em>IEEE Transactions on Automatic Control</em>, vol. 37(3), pp. 332–341.</li>
<li>Spall, J.C. (1998). "Overview of the Simultaneous Perturbation Method for Efficient Optimization" <a href="http://www.jhuapl.edu/SPSA/PDF-SPSA/Spall_An_Overview.PDF">2</a>. <em>Johns Hopkins APL Technical Digest</em>, 19(4), 482–492.</li>
<li>Spall, J.C. (2003) <em>Introduction to Stochastic Search and Optimization: Estimation, Simulation, and Control</em>, Wiley. ISBN 0-471-33052-3 (Chapter 7)</li>
</ul>
<references>
</references>

<p>"</p>

<p><a href="Category:Numerical_climate_and_weather_models" title="wikilink">Category:Numerical climate and weather models</a> <a href="Category:Stochastic_algorithms" title="wikilink">Category:Stochastic algorithms</a> <a href="Category:Optimization_algorithms_and_methods" title="wikilink">Category:Optimization algorithms and methods</a></p>
</body>
</html>
