<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1451">Elliptic curve only hash</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Elliptic curve only hash</h1>
<hr/>

<p><strong>The elliptic curve only hash (ECOH)</strong> algorithm was submitted as a candidate for SHA-3 in the <a href="NIST_hash_function_competition" title="wikilink">NIST hash function competition</a>. However, it was rejected in the beginning of the competition since a <a href="Preimage_attack" title="wikilink">second pre-image attack</a> was found.</p>

<p>The ECOH is based on the <a class="uri" href="MuHASH" title="wikilink">MuHASH</a> <a href="hash_algorithm" title="wikilink">hash algorithm</a>, that has not yet been successfully <a href="Cryptanalytic_attack" title="wikilink">attacked</a>. However, MuHASH is too inefficient for practical use and changes had to be made. The main difference is that where MuHASH applies a <a href="random_oracle" title="wikilink">random oracle</a> , ECOH applies a <a href="Padding_(cryptography)" title="wikilink">padding</a> function. Assuming random oracles, finding a <a href="Collision_resistance" title="wikilink">collision</a> in MuHASH implies solving the <a href="discrete_logarithm_problem" title="wikilink">discrete logarithm problem</a>. MuHASH is thus a <a href="Provably_secure_cryptographic_hash_function" title="wikilink">provably secure hash</a>, i.e. we know that finding a collision is at least <a href="Complexity_class" title="wikilink">as hard</a> as some hard known mathematical problem.</p>

<p>ECOH does not use random oracles and its security is not strictly directly related to the discrete logarithm problem, yet it is still based on mathematical functions. ECOH is related to the Semaev's problem of finding low degree solutions to the summation polynomial equations over binary field, called the <strong>Summation Polynomial Problem</strong>. An efficient algorithm to solve this problem has not been given so far. Although the problem was not proven to be <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>, it is assumed that such an algorithm does not exist. Under certain assumptions, finding a collision in ECOH may be also viewed as an instance of the <a href="subset_sum_problem" title="wikilink">subset sum problem</a>. Besides solving the Summation Polynomial Problem, there exists another way how to find second pre-images and thus collisions, <strong>Wagner's generalized birthday attack</strong>.</p>

<p>ECOH is a nice example of hash function that is based on mathematical functions (with the <a href="Provably_secure_cryptographic_hash_function" title="wikilink">provable security</a> approach) rather than on classical ad hoc mixing of bits to obtain the hash.</p>
<h2 id="the-algorithm">The algorithm</h2>

<p>Given 

<math display="inline" id="Elliptic_curve_only_hash:0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, ECOH divides the message 

<math display="inline" id="Elliptic_curve_only_hash:1">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 into 

<math display="inline" id="Elliptic_curve_only_hash:2">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 blocks 

<math display="inline" id="Elliptic_curve_only_hash:3">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">‚Ä¶</mi>
   <mo>,</mo>
   <msub>
    <mi>M</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-‚Ä¶</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{0},\ldots,M_{n-1}
  </annotation>
 </semantics>
</math>

. If the last block is incomplete, it is padded with single 1 and then appropriate number of 0. Let furthermore 

<math display="inline" id="Elliptic_curve_only_hash:4">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 be a function that maps a message block and an integer to an elliptic curve point. Then using the mapping 

<math display="inline" id="Elliptic_curve_only_hash:5">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, each block is transformed to an <a href="elliptic_curve" title="wikilink">elliptic curve</a> point 

<math display="inline" id="Elliptic_curve_only_hash:6">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}
  </annotation>
 </semantics>
</math>

, and these points are <a href="Elliptic_curve#The_group_law" title="wikilink">added</a> together with two more points. One additional point 

<math display="inline" id="Elliptic_curve_only_hash:7">
 <semantics>
  <msub>
   <mi>X</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1}
  </annotation>
 </semantics>
</math>

 contains the padding and depends only on the message length. The second additional point 

<math display="inline" id="Elliptic_curve_only_hash:8">
 <semantics>
  <msub>
   <mi>X</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{2}
  </annotation>
 </semantics>
</math>

 depends on the message length and the XOR of all message blocks. The result is <a class="uri" href="truncated" title="wikilink">truncated</a> to get the hash 

<math display="inline" id="Elliptic_curve_only_hash:9">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="inline" id="Elliptic_curve_only_hash:10">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="right">
     <msub>
      <mi>P</mi>
      <mi>i</mi>
     </msub>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo>:</mo>
      <mo>=</mo>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>M</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <mi>i</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <msub>
      <mi>X</mi>
      <mn>1</mn>
     </msub>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo>:</mo>
      <mo>=</mo>
      <msup>
       <mi>P</mi>
       <mo>‚Ä≤</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <msub>
      <mi>X</mi>
      <mn>2</mn>
     </msub>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo>:</mo>
      <mo>=</mo>
      <msup>
       <mi>P</mi>
       <mo>*</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>M</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mi>Q</mi>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo>:</mo>
      <mo>=</mo>
      <mstyle displaystyle="true">
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </munderover>
      </mstyle>
      <msub>
       <mi>P</mi>
       <mi>i</mi>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>X</mi>
       <mn>1</mn>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>X</mi>
       <mn>2</mn>
      </msub>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mi>R</mi>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo>:</mo>
      <mo>=</mo>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Q</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>i</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-:</ci>
      <eq></eq>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-,</ci>
       <csymbol cd="unknown">i</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-:</ci>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>P</ci>
       <ci>normal-‚Ä≤</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-:</ci>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>P</ci>
       <times></times>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-,</ci>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <ci>Q</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-:</ci>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>i</ci>
      </apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <cn type="integer">1</cn>
      </apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <cn type="integer">2</cn>
      </apply>
     </cerror>
    </matrixrow>
    <matrixrow>
     <ci>R</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-:</ci>
      <eq></eq>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">Q</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{aligned}\displaystyle P_{i}&\displaystyle{}:=P(M_{i},i)\\
\displaystyle X_{1}&\displaystyle{}:=P^{\prime}(n)\\
\displaystyle X_{2}&\displaystyle{}:=P^{*}(M_{i},n)\\
\displaystyle Q&\displaystyle{}:=\sum_{i=0}^{n-1}P_{i}+X_{1}+X_{2}\\
\displaystyle R&\displaystyle{}:=f(Q)\end{aligned}
  </annotation>
 </semantics>
</math>

</p>

<p>The two extra points are computed by 

<math display="inline" id="Elliptic_curve_only_hash:11">
 <semantics>
  <msup>
   <mi>P</mi>
   <mo>‚Ä≤</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>P</ci>
    <ci>normal-‚Ä≤</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{\prime}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Elliptic_curve_only_hash:12">
 <semantics>
  <msup>
   <mi>P</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>P</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{*}
  </annotation>
 </semantics>
</math>

 . 

<math display="inline" id="Elliptic_curve_only_hash:13">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 adds all the elliptic curve points and the two extra points together. Finally, the result is passed through an output transformation function f to get the hash result 

<math display="inline" id="Elliptic_curve_only_hash:14">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

. To read more about this algorithm, see <a href="http://ehash.iaik.tugraz.at/uploads/a/a5/Ecoh.pdf">"ECOH: the Elliptic Curve Only Hash"</a>.</p>
<h3 id="examples">Examples</h3>

<p>Four ECOH algorithms were proposed, ECOH-224, ECOH-256, ECOH-384 and ECOH-512. The number represents the size of the message digest. They differ in the length of parameters, block size and in the used elliptic curve. The first two uses the elliptic curve B-283

<math display="block" id="Elliptic_curve_only_hash:15">
 <semantics>
  <mrow>
   <msup>
    <mi>X</mi>
    <mn>283</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>X</mi>
    <mn>12</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>X</mi>
    <mn>7</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>X</mi>
    <mn>5</mn>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <cn type="integer">283</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <cn type="integer">12</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <cn type="integer">7</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <cn type="integer">5</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{283}+X^{12}+X^{7}+X^{5}+1
  </annotation>
 </semantics>
</math>

, with parameters (128, 64, 64). ECOH-384 uses the curve B-409

<math display="block" id="Elliptic_curve_only_hash:16">
 <semantics>
  <mrow>
   <msup>
    <mi>X</mi>
    <mn>409</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>X</mi>
    <mn>87</mn>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <cn type="integer">409</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <cn type="integer">87</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{409}+X^{87}+1
  </annotation>
 </semantics>
</math>

, with parameters (192, 64, 64). ECOH-512 uses the curve B-571

<math display="block" id="Elliptic_curve_only_hash:17">
 <semantics>
  <mrow>
   <msup>
    <mi>X</mi>
    <mn>571</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>X</mi>
    <mn>10</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>X</mi>
    <mn>5</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>X</mi>
    <mn>2</mn>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <cn type="integer">571</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <cn type="integer">10</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <cn type="integer">5</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{571}+X^{10}+X^{5}+X^{2}+1
  </annotation>
 </semantics>
</math>

, with parameters (256, 128, 128). It can hash messages of bit length up to 

<math display="inline" id="Elliptic_curve_only_hash:18">
 <semantics>
  <msup>
   <mn>2</mn>
   <mn>128</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <cn type="integer">128</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{128}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="properties">Properties</h2>
<ul>
<li><strong>Incrementality</strong>: ECOH of a message can be updated quickly, given a small change in the message and an intermediate value in ECOH computation.</li>
<li><strong>Parallelizability</strong>: This means the computation of the 

<math display="inline" id="Elliptic_curve_only_hash:19">
 <semantics>
  <mrow>
   <msubsup>
    <mi>P</mi>
    <mi>i</mi>
    <mo>‚Ä≤</mo>
   </msubsup>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-‚Ä≤</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}^{\prime}s
  </annotation>
 </semantics>
</math>

 can be done on parallel systems.</li>
<li><strong>Speed</strong>: The ECOH algorithm is about thousand times slower than <a class="uri" href="SHA-1" title="wikilink">SHA-1</a>. However, given the developments in desktop hardware towards <a href="Parallel_computing" title="wikilink">parallelization</a> and <a href="CLMUL_instruction_set" title="wikilink">carryless multiplication</a>, ECOH may in a few years be as fast as SHA-1 for long messages. For short messages, ECOH is relatively slow, unless extensive tables are used.</li>
</ul>
<h2 id="security-of-ecoh">Security of ECOH</h2>

<p>The ECOH hash functions are based on concrete mathematical functions. They were designed such that the problem of finding collisions should be <a href="Polynomial-time_reduction" title="wikilink">reducible</a> to a known and hard mathematical problem (the <a href="subset_sum_problem" title="wikilink">subset sum problem</a>). It means that if one could find collisions, one would be able to solve the underlying mathematical problem which is assumed to be hard and unsolvable in <a href="polynomial_time" title="wikilink">polynomial time</a>. Functions with these properties are known <a href="Provably_secure_cryptographic_hash_function" title="wikilink">provably secure</a> and are quite unique among the rest of hash functions. Nevertheless second pre-image (and thus a collision) was later found because the assumptions given in the proof were too strong.</p>
<h3 id="semaev-summation-polynomial">Semaev Summation Polynomial</h3>

<p>One way of finding collisions or second pre-images is solving <strong>Semaev Summation Polynomials</strong>. For a given elliptic curve E, there exists polynomials 

<math display="inline" id="Elliptic_curve_only_hash:20">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{n}
  </annotation>
 </semantics>
</math>

 that are symmetric in 

<math display="inline" id="Elliptic_curve_only_hash:21">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 variables and that vanish exactly when evaluated at abscissae of points whose sum is 0 in 

<math display="inline" id="Elliptic_curve_only_hash:22">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

. So far, an efficient algorithm to solve this problem does not exist and it is assumed to be hard (but not proven to be <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>).</p>

<p>More formally: Let 

<math display="inline" id="Elliptic_curve_only_hash:23">
 <semantics>
  <mi>ùêÖ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêÖ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{F}
  </annotation>
 </semantics>
</math>

 be a finite field, 

<math display="inline" id="Elliptic_curve_only_hash:24">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 be an elliptic curve with <a href="Weierstrass's_elliptic_functions" title="wikilink">Weierstrass equation</a> having coefficients in 

<math display="inline" id="Elliptic_curve_only_hash:25">
 <semantics>
  <mi>ùêÖ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêÖ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{F}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Elliptic_curve_only_hash:26">
 <semantics>
  <mi>O</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>O</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O
  </annotation>
 </semantics>
</math>

 be the point of infinity. It is known that there exists a multivariable polynomial 

<math display="inline" id="Elliptic_curve_only_hash:27">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mi>N</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>N</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{n}(X_{1},\ldots,X_{N})
  </annotation>
 </semantics>
</math>

 if and only if there exist y_1,\ldots,y_n such that 

<math display="inline" id="Elliptic_curve_only_hash:28">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>O</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
     </interval>
     <ci>normal-‚Ä¶</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </interval>
    </apply>
    <ci>O</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1},y_{1})+\ldots+(x_{n},y_{n})=O
  </annotation>
 </semantics>
</math>

. This polynomial has degree 

<math display="inline" id="Elliptic_curve_only_hash:29">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n-2}
  </annotation>
 </semantics>
</math>

 in each variable. The problem is to find this polynomial.</p>
<h3 id="provable-security-discussion">Provable security discussion</h3>

<p>The problem of finding collisions in ECOH is similar to the <a href="subset_sum_problem" title="wikilink">subset sum problem</a>. Solving a subset sum problem is almost as hard as the <a href="discrete_logarithm" title="wikilink">discrete logarithm</a> problem. It is generally assumed that this is not doable in <a href="polynomial_time" title="wikilink">polynomial time</a>. However a significantly loose heuristic must be assumed, more specifically, one of the involved parameters in the computation is not necessarily random but has a particular structure. If one adopts this loose heuristic, then finding an internal ECOH collision may be viewed as an instance of the <a href="subset_sum_problem" title="wikilink">subset sum problem</a>.</p>

<p>A second pre-image attack exists in the form of generalized birthday attack.</p>
<h3 id="second-pre-image-attack">Second pre-image attack</h3>

<p><strong>Description of the attack</strong>: This is a Wagner‚Äôs Generalized <a href="Birthday_attack" title="wikilink">Birthday Attack</a>. It requires 2<sup>143</sup> time for ECOH-224 and ECOH-256, 2<sup>206</sup> time for ECOH-384, and 2<sup>287</sup> time for ECOH-512. The attack sets the checksum block to a fixed value and uses a collision search on the elliptic curve points. For this attack we have a message <em>M</em> and try to find a <em>M</em>' that hashes to the same message. We first split the message length into six blocks. So 

<math display="inline" id="Elliptic_curve_only_hash:30">
 <semantics>
  <mrow>
   <msup>
    <mi>M</mi>
    <mo>‚Ä≤</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>M</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>M</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>M</mi>
     <mn>3</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>M</mi>
     <mn>4</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>M</mi>
     <mn>5</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>M</mi>
     <mn>6</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>M</ci>
     <ci>normal-‚Ä≤</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">5</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">6</cn>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M^{\prime}=(M_{1},M_{2},M_{3},M_{4},M_{5},M_{6})
  </annotation>
 </semantics>
</math>

. Let <em>K</em> be a natural number. We choose <em>K</em> different numbers for 

<math display="inline" id="Elliptic_curve_only_hash:31">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>M</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>M</mi>
    <mn>1</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">1</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M_{0},M_{1})
  </annotation>
 </semantics>
</math>

 and define 

<math display="inline" id="Elliptic_curve_only_hash:32">
 <semantics>
  <msub>
   <mi>M</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{2}
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Elliptic_curve_only_hash:33">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mn>2</mn>
   </msub>
   <mo>:=</mo>
   <mrow>
    <msub>
     <mi>M</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>M</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{2}:=M_{0}+M_{1}
  </annotation>
 </semantics>
</math>

. We compute the <em>K</em> corresponding elliptic curve points 

<math display="inline" id="Elliptic_curve_only_hash:34">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>M</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>M</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>M</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mn>2</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>P</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">0</cn>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">1</cn>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">2</cn>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(M_{0},0)+P(M_{1},1)+P(M_{2},2)
  </annotation>
 </semantics>
</math>

 and store them in a list. We then choose <em>K</em> different random values for 

<math display="inline" id="Elliptic_curve_only_hash:35">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>M</mi>
    <mn>3</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>M</mi>
    <mn>4</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">4</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M_{3},M_{4})
  </annotation>
 </semantics>
</math>

, define 

<math display="inline" id="Elliptic_curve_only_hash:36">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mn>5</mn>
   </msub>
   <mo>:=</mo>
   <mrow>
    <msub>
     <mi>M</mi>
     <mn>3</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>M</mi>
     <mn>4</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">5</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{5}:=M_{3}+M_{4}
  </annotation>
 </semantics>
</math>

, we compute 

<math display="inline" id="Elliptic_curve_only_hash:37">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>-</mo>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo>-</mo>
   <msub>
    <mi>X</mi>
    <mn>2</mn>
   </msub>
   <mo>-</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>M</mi>
      <mn>3</mn>
     </msub>
     <mo>,</mo>
     <mn>3</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>M</mi>
      <mn>4</mn>
     </msub>
     <mo>,</mo>
     <mn>4</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>M</mi>
      <mn>5</mn>
     </msub>
     <mo>,</mo>
     <mn>5</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>Q</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <cn type="integer">3</cn>
      </apply>
      <cn type="integer">3</cn>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <cn type="integer">4</cn>
      </apply>
      <cn type="integer">4</cn>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <cn type="integer">5</cn>
      </apply>
      <cn type="integer">5</cn>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q-X_{1}-X_{2}-P(M_{3},3)-P(M_{4},4)-P(M_{5},5)
  </annotation>
 </semantics>
</math>

, and store them in a second list. Note that the target <em>Q</em> is known. 

<math display="inline" id="Elliptic_curve_only_hash:38">
 <semantics>
  <msub>
   <mi>X</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1}
  </annotation>
 </semantics>
</math>

 only depends on the length of the message which we have fixed. 

<math display="inline" id="Elliptic_curve_only_hash:39">
 <semantics>
  <msub>
   <mi>X</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{2}
  </annotation>
 </semantics>
</math>

 depends on the length and the XOR of all message blocks, but we choose the message blocks such that this is always zero. Thus, 

<math display="inline" id="Elliptic_curve_only_hash:40">
 <semantics>
  <msub>
   <mi>X</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{2}
  </annotation>
 </semantics>
</math>

 is fixed for all our tries.</p>

<p>If <em>K</em> is larger than the square root of the number of points on the elliptic curve then we expect one <a class="uri" href="collision" title="wikilink">collision</a> between the two lists. This gives us a message 

<math display="inline" id="Elliptic_curve_only_hash:41">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>M</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>M</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>M</mi>
    <mn>3</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>M</mi>
    <mn>4</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>M</mi>
    <mn>5</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>M</mi>
    <mn>6</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">4</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">5</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">6</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M_{1},M_{2},M_{3},M_{4},M_{5},M_{6})
  </annotation>
 </semantics>
</math>

 with: 

<math display="inline" id="Elliptic_curve_only_hash:42">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mn>5</mn>
     </msubsup>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>M</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <mi>i</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Q</ci>
    <apply>
     <plus></plus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <cn type="integer">5</cn>
      </apply>
      <apply>
       <times></times>
       <ci>P</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>M</ci>
         <ci>i</ci>
        </apply>
        <ci>i</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=\sum_{i=0}^{5}P(M_{i},i)+X_{1}+X_{2}
  </annotation>
 </semantics>
</math>

 This means that this message leads to the target value <em>Q</em> and thus to a second preimage, which was the question. The workload we have to do here is two times <em>K</em> partial hash computations. For more info, see <a href="http://eprint.iacr.org/2009/168.pdf">"A Second Pre-image Attack Against Elliptic Curve Only Hash (ECOH)"</a>.</p>

<p>Actual parameters:</p>
<ul>
<li>ECOH-224 and ECOH-256 use the elliptic curve B-283 with approximately 

<math display="inline" id="Elliptic_curve_only_hash:43">
 <semantics>
  <msup>
   <mn>2</mn>
   <mn>283</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <cn type="integer">283</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{283}
  </annotation>
 </semantics>
</math>

 points on the curve. We choose 

<math display="inline" id="Elliptic_curve_only_hash:44">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mn>142</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>K</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <cn type="integer">142</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K=2^{142}
  </annotation>
 </semantics>
</math>

 and get an attack with complexity 

<math display="inline" id="Elliptic_curve_only_hash:45">
 <semantics>
  <msup>
   <mn>2</mn>
   <mn>143</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <cn type="integer">143</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{143}
  </annotation>
 </semantics>
</math>

.</li>
<li>ECOH-384 uses the elliptic curve B-409 with approximately 

<math display="inline" id="Elliptic_curve_only_hash:46">
 <semantics>
  <msup>
   <mn>2</mn>
   <mn>409</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <cn type="integer">409</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{409}
  </annotation>
 </semantics>
</math>

 points on the curve. Choosing 

<math display="inline" id="Elliptic_curve_only_hash:47">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mn>205</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>K</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <cn type="integer">205</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K=2^{205}
  </annotation>
 </semantics>
</math>

 gives an attack with complexity 

<math display="inline" id="Elliptic_curve_only_hash:48">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mn>206</mn>
   </msup>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <cn type="integer">206</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{206}.
  </annotation>
 </semantics>
</math>

</li>
<li>ECOH-512 uses the elliptic curve B-571 with approximately 

<math display="inline" id="Elliptic_curve_only_hash:49">
 <semantics>
  <msup>
   <mn>2</mn>
   <mn>571</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <cn type="integer">571</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{571}
  </annotation>
 </semantics>
</math>

 points on the curve. Choosing 

<math display="inline" id="Elliptic_curve_only_hash:50">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mn>286</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>K</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <cn type="integer">286</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K=2^{286}
  </annotation>
 </semantics>
</math>

 gives an attack with complexity 

<math display="inline" id="Elliptic_curve_only_hash:51">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mn>287</mn>
   </msup>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <cn type="integer">287</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{287}.
  </annotation>
 </semantics>
</math>

</li>
</ul>
<h2 id="ecoh2">ECOH2</h2>

<p>The official <a href="http://csrc.nist.gov/groups/ST/hash/sha-3/Round1/documents/ECOH_Comments.pdf">comments</a> on ECOH included a proposal called ECOH2 that doubles the elliptic curve size in an effort to stop the Halcrow-Ferguson second preimage attack with a prediction of improved or similar performance.</p>
<h2 id="references">References</h2>
<ul>
<li>Daniel R. L. Brown, Matt Campagna, Rene Struik (2008). <a href="http://ehash.iaik.tugraz.at/uploads/a/a5/Ecoh.pdf">"ECOH: the Elliptic Curve Only Hash"</a>.</li>
<li>Michael A. Halcrow, Niels Ferguson (2009). <a href="http://eprint.iacr.org/2009/168.pdf">"A Second Pre-image Attack Against Elliptic Curve Only Hash (ECOH)"</a>.</li>
</ul>
<h2 id="see-also">See also</h2>

<p><a href="Provably_secure_cryptographic_hash_function" title="wikilink">Provably secure cryptographic hash function</a></p>

<p>"</p>

<p><a href="Category:Cryptographic_hash_functions" title="wikilink">Category:Cryptographic hash functions</a></p>
</body>
</html>
