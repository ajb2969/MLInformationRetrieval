<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1876">Box–Muller transform</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Box–Muller transform</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Visualisation of the Box-Muller transform — the coloured points in the unit square (u1, u2), drawn as circles, are mapped to a 2D Gaussian (z0, z1), drawn as crosses. The plots at the margins are the probability distribution functions of z0 and z1. Note that z0 and z1 are unbounded; they appear to be in [-3,3] due to the choice of the illustrated points.</figcaption>
</figure>

<p>The <strong>Box–Muller transform</strong> (by <a href="George_E._P._Box" title="wikilink">George Edward Pelham Box</a> and Mervin Edgar Muller 1958)<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> is a <a href="pseudo-random_number_sampling" title="wikilink">pseudo-random number sampling</a> method for generating pairs of <a href="statistical_independence" title="wikilink">independent</a>, standard, <a href="normal_distribution" title="wikilink">normally distributed</a> (zero <a href="expected_value" title="wikilink">expectation</a>, unit <a class="uri" href="variance" title="wikilink">variance</a>) random numbers, given a source of <a href="Uniform_distribution_(continuous)" title="wikilink">uniformly distributed</a> random numbers.</p>

<p>It is commonly expressed in two forms. The basic form as given by Box and Muller takes two samples from the uniform distribution on the interval (0, 1] and maps them to two standard, normally distributed samples. The polar form takes two samples from a different interval, [−1, +1], and maps them to two normally distributed samples without the use of sine or cosine functions.</p>

<p>The Box–Muller transform was developed as a more computationally efficient alternative to the <a href="inverse_transform_sampling_method" title="wikilink">inverse transform sampling method</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The <a href="Ziggurat_algorithm" title="wikilink">Ziggurat algorithm</a> gives an even more efficient method.</p>
<h2 id="basic-form">Basic form</h2>

<p>Suppose <em>U</em><sub>1</sub> and <em>U</em><sub>2</sub> are independent <a href="random_variable" title="wikilink">random variables</a> that are <a href="uniform_distribution_(continuous)" title="wikilink">uniformly distributed</a> in the <a href="Interval_(mathematics)" title="wikilink">interval</a> (0, 1). Let</p>

<p>

<math display="block" id="Box–Muller_transform:0">
 <semantics>
  <mrow>
   <msub>
    <mi>Z</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mi>cos</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi mathvariant="normal">Θ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msqrt>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <mrow>
        <mi>ln</mi>
        <msub>
         <mi>U</mi>
         <mn>1</mn>
        </msub>
       </mrow>
      </mrow>
     </mrow>
    </msqrt>
    <mrow>
     <mi>cos</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
       <msub>
        <mi>U</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <ci>R</ci>
      <apply>
       <cos></cos>
       <ci>normal-Θ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <root></root>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <ln></ln>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>U</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <cos></cos>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>U</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{0}=R\cos(\Theta)=\sqrt{-2\ln U_{1}}\cos(2\pi U_{2})\,
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Box–Muller_transform:1">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Z</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mi>sin</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi mathvariant="normal">Θ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msqrt>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mn>2</mn>
        <mrow>
         <mi>ln</mi>
         <msub>
          <mi>U</mi>
          <mn>1</mn>
         </msub>
        </mrow>
       </mrow>
      </mrow>
     </msqrt>
     <mrow>
      <mi>sin</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>2</mn>
        <mi>π</mi>
        <msub>
         <mi>U</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>R</ci>
      <apply>
       <sin></sin>
       <ci>normal-Θ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <root></root>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <ln></ln>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>U</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <sin></sin>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>U</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{1}=R\sin(\Theta)=\sqrt{-2\ln U_{1}}\sin(2\pi U_{2}).\,
  </annotation>
 </semantics>
</math>

</p>

<p>Then <em>Z</em><sub>0</sub> and <em>Z</em><sub>1</sub> are <a href="statistical_independence" title="wikilink">independent</a> random variables with a <a href="standard_normal_distribution" title="wikilink">standard normal distribution</a>.</p>

<p>The derivation<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> is based on the fact that, in a two-dimensional Cartesian system where X and Y coordinates are described by two independent and normally distributed random variables, the random variables for <em>R</em><sup>2</sup> and Θ (shown above) in the corresponding polar coordinates are also independent and can be expressed as</p>

<p>

<math display="block" id="Box–Muller_transform:2">
 <semantics>
  <mrow>
   <msup>
    <mi>R</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <mo>⋅</mo>
     <mrow>
      <mi>ln</mi>
      <mpadded width="+1.7pt">
       <msub>
        <mi>U</mi>
        <mn>1</mn>
       </msub>
      </mpadded>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-⋅</ci>
      <cn type="integer">2</cn>
      <apply>
       <ln></ln>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>U</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{2}=-2\cdot\ln U_{1}\,
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Box–Muller_transform:3">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Θ</mi>
    <mo>=</mo>
    <mrow>
     <mn>2</mn>
     <mi>π</mi>
     <msub>
      <mi>U</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Θ</ci>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>π</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta=2\pi U_{2}.\,
  </annotation>
 </semantics>
</math>

</p>

<p>Because <em>R</em><sup>2</sup> is the square of the norm of the standard <a href="bivariate_normal" title="wikilink">bivariate normal</a> variable (X, Y), it has the <a href="chi-squared_distribution" title="wikilink">chi-squared distribution</a> with two degrees of freedom. In the special case of two degrees of freedom, the chi-squared distribution coincides with the <a href="exponential_distribution" title="wikilink">exponential distribution</a>, and the equation for <em>R</em><sup>2</sup> above is a simple way of generating the required exponential variate.</p>
<h2 id="polar-form">Polar form</h2>

<p> The polar form was first proposed by J. Bell<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> and then modified by R. Knop.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> While several different versions of the polar method have been described, the version of R. Knop will be described here because it is the most widely used, in part due to its inclusion in <a href="Numerical_Recipes" title="wikilink">Numerical Recipes</a>.</p>

<p>Given <em>u</em> and <em>v</em>, independent and uniformly distributed in the closed interval [−1, +1], set <em>s</em> = <em>R</em><sup>2</sup> = <em>u</em><sup>2</sup> + <em>v</em><sup>2</sup>. (Clearly  If <em>s</em> = 0 or <em>s</em> ≥ 1, throw <em>u</em> and <em>v</em> away and try another pair (<em>u</em>, <em>v</em>). Because <em>u</em> and <em>v</em> are uniformly distributed and because only points within the unit circle have been admitted, the values of <em>s</em> will be uniformly distributed in the open interval (0, 1), too. The latter can be seen by calculating the cumulative distribution function for <em>s</em> in the interval (0, 1). This is the area of a circle with radius 

<math display="inline" id="Box–Muller_transform:4">
 <semantics>
  <msqrt>
   <mi>s</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\sqrt{s}
  </annotation>
 </semantics>
</math>

, divided by 

<math display="inline" id="Box–Muller_transform:5">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\pi
  </annotation>
 </semantics>
</math>


. From this we find the probability density function to have the constant value 1 on the interval (0, 1). Equally so, the angle θ divided by 

<math display="inline" id="Box–Muller_transform:6">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>π</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>π</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle 2\pi
  </annotation>
 </semantics>
</math>

 is uniformly distributed in the interval [0, 1) and independent of <em>s</em>.</p>

<p>We now identify the value of <em>s</em> with that of <em>U</em><sub>1</sub> and 

<math display="inline" id="Box–Muller_transform:7">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mo>/</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>2</mn>
     <mi>π</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>θ</ci>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>π</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\theta/(2\pi)
  </annotation>
 </semantics>
</math>

 with that of <em>U</em><sub>2</sub> in the basic form. As shown in the figure, the values of 

<math display="inline" id="Box–Muller_transform:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>cos</mi>
    <mi>θ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>cos</mi>
    <mrow>
     <mn>2</mn>
     <mi>π</mi>
     <msub>
      <mi>U</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <cos></cos>
     <ci>θ</ci>
    </apply>
    <apply>
     <cos></cos>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>π</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\cos\theta=\cos 2\pi U_{2}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Box–Muller_transform:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>sin</mi>
    <mi>θ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>sin</mi>
    <mrow>
     <mn>2</mn>
     <mi>π</mi>
     <msub>
      <mi>U</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <sin></sin>
     <ci>θ</ci>
    </apply>
    <apply>
     <sin></sin>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>π</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\sin\theta=\sin 2\pi U_{2}
  </annotation>
 </semantics>
</math>

 in the basic form can be replaced with the ratios 

<math display="inline" id="Box–Muller_transform:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>cos</mi>
    <mi>θ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>u</mi>
    <mo>/</mo>
    <mi>R</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>u</mi>
    <mo>/</mo>
    <msqrt>
     <mi>s</mi>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <cos></cos>
      <ci>θ</ci>
     </apply>
     <apply>
      <divide></divide>
      <ci>u</ci>
      <ci>R</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <ci>u</ci>
      <apply>
       <root></root>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\cos\theta=u/R=u/\sqrt{s}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Box–Muller_transform:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>sin</mi>
    <mi>θ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>v</mi>
    <mo>/</mo>
    <mi>R</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>v</mi>
    <mo>/</mo>
    <msqrt>
     <mi>s</mi>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <sin></sin>
      <ci>θ</ci>
     </apply>
     <apply>
      <divide></divide>
      <ci>v</ci>
      <ci>R</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <ci>v</ci>
      <apply>
       <root></root>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\sin\theta=v/R=v/\sqrt{s}
  </annotation>
 </semantics>
</math>

, respectively. The advantage is that calculating the trigonometric functions directly can be avoided. This is helpful when trigonometric functions are more expensive to compute than the single division that replaces each one.</p>

<p>Just as the basic form produces two standard normal deviates, so does this alternate calculation.</p>

<p>

<math display="block" id="Box–Muller_transform:12">
 <semantics>
  <mrow>
   <msub>
    <mi>z</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msqrt>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <mrow>
        <mi>ln</mi>
        <msub>
         <mi>U</mi>
         <mn>1</mn>
        </msub>
       </mrow>
      </mrow>
     </mrow>
    </msqrt>
    <mrow>
     <mi>cos</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
       <msub>
        <mi>U</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msqrt>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <mrow>
        <mi>ln</mi>
        <mi>s</mi>
       </mrow>
      </mrow>
     </mrow>
    </msqrt>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mi>u</mi>
      <msqrt>
       <mi>s</mi>
      </msqrt>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>u</mi>
    <mo>⋅</mo>
    <msqrt>
     <mfrac>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mn>2</mn>
        <mrow>
         <mi>ln</mi>
         <mi>s</mi>
        </mrow>
       </mrow>
      </mrow>
      <mi>s</mi>
     </mfrac>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <root></root>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <ln></ln>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>U</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <cos></cos>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>U</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <root></root>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <ln></ln>
          <ci>s</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <ci>u</ci>
       <apply>
        <root></root>
        <ci>s</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-⋅</ci>
      <ci>u</ci>
      <apply>
       <root></root>
       <apply>
        <divide></divide>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <apply>
           <ln></ln>
           <ci>s</ci>
          </apply>
         </apply>
        </apply>
        <ci>s</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{0}=\sqrt{-2\ln U_{1}}\cos(2\pi U_{2})=\sqrt{-2\ln s}\left(\frac{u}{\sqrt{s}%
}\right)=u\cdot\sqrt{\frac{-2\ln s}{s}}
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Box–Muller_transform:13">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>z</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <msqrt>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mn>2</mn>
        <mrow>
         <mi>ln</mi>
         <msub>
          <mi>U</mi>
          <mn>1</mn>
         </msub>
        </mrow>
       </mrow>
      </mrow>
     </msqrt>
     <mrow>
      <mi>sin</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>2</mn>
        <mi>π</mi>
        <msub>
         <mi>U</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msqrt>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mn>2</mn>
        <mrow>
         <mi>ln</mi>
         <mi>s</mi>
        </mrow>
       </mrow>
      </mrow>
     </msqrt>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mi>v</mi>
       <msqrt>
        <mi>s</mi>
       </msqrt>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>v</mi>
     <mo>⋅</mo>
     <msqrt>
      <mfrac>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mn>2</mn>
         <mrow>
          <mi>ln</mi>
          <mi>s</mi>
         </mrow>
        </mrow>
       </mrow>
       <mi>s</mi>
      </mfrac>
     </msqrt>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <root></root>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <ln></ln>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>U</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <sin></sin>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>U</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <root></root>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <ln></ln>
          <ci>s</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <ci>v</ci>
       <apply>
        <root></root>
        <ci>s</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-⋅</ci>
      <ci>v</ci>
      <apply>
       <root></root>
       <apply>
        <divide></divide>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <apply>
           <ln></ln>
           <ci>s</ci>
          </apply>
         </apply>
        </apply>
        <ci>s</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{1}=\sqrt{-2\ln U_{1}}\sin(2\pi U_{2})=\sqrt{-2\ln s}\left(\frac{v}{\sqrt{s}%
}\right)=v\cdot\sqrt{\frac{-2\ln s}{s}}.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="contrasting-the-two-forms">Contrasting the two forms</h2>

<p>The polar method differs from the basic method in that it is a type of <a href="rejection_sampling" title="wikilink">rejection sampling</a>. It throws away some generated random numbers, but it is typically faster than the basic method because it is simpler to compute (provided that the random number generator is relatively fast) and is more numerically robust.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> It avoids the use of trigonometric functions, which are comparatively expensive in many computing environments. It throws away 1 − π/4 ≈ 21.46% of the total input uniformly distributed random number pairs generated, i.e. throws away 4/π − 1 ≈ 27.32% uniformly distributed random number pairs per <a href="normal_distribution" title="wikilink">Gaussian</a> random number pair generated, requiring 4/π ≈ 1.2732 input random numbers per output random number.</p>

<p>The basic form requires two multiplications, 1/2 logarithm, 1/2 square root, and one trigonometric function for each normal variate.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> On some processors, the cosine and sine of the same argument can be calculated in parallel using a single instruction. Notably for Intel-based machines, one can use the fsincos assembler instruction or the expi instruction (usually available from C as an <a href="intrinsic_function" title="wikilink">intrinsic function</a>), to calculate complex</p>

<p>

<math display="block" id="Box–Muller_transform:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>i</mi>
       <mi>z</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mi>e</mi>
     <mrow>
      <mi>i</mi>
      <mi>z</mi>
     </mrow>
    </msup>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>cos</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>i</mi>
      <mrow>
       <mi>sin</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>exp</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>z</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <cos></cos>
       <ci>z</ci>
      </apply>
      <apply>
       <times></times>
       <ci>i</ci>
       <apply>
        <sin></sin>
        <ci>z</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{exp}(iz)=e^{iz}=\cos(z)+i\sin(z),\,
  </annotation>
 </semantics>
</math>

</p>

<p>and just separate the real and imaginary parts.</p>

<p>The polar form requires 3/2 multiplications, 1/2 logarithm, 1/2 square root, and 1/2 division for each normal variate. The effect is to replace one multiplication and one trigonometric function with a single division.</p>
<h2 id="tails-truncation">Tails truncation</h2>

<p>When a computer is used to produce a uniform random variable it will inevitably have some inaccuracies because there is a lower bound on how close numbers can be to 0. If the generator uses 32 bits per output value, the smallest non-zero number that can be generated is 

<math display="inline" id="Box–Muller_transform:15">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mo>-</mo>
    <mn>32</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <minus></minus>
     <cn type="integer">32</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{-32}
  </annotation>
 </semantics>
</math>


. When 

<math display="inline" id="Box–Muller_transform:16">
 <semantics>
  <msub>
   <mi>U</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Box–Muller_transform:17">
 <semantics>
  <msub>
   <mi>U</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{2}
  </annotation>
 </semantics>
</math>

 are equal to this the Box–Muller transform produces a normal random variable equal to 

<math display="inline" id="Box–Muller_transform:18">
 <semantics>
  <mrow>
   <mrow>
    <msqrt>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <mrow>
        <mi>ln</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msup>
          <mn>2</mn>
          <mrow>
           <mo>-</mo>
           <mn>32</mn>
          </mrow>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </msqrt>
    <mrow>
     <mi>cos</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
       <msup>
        <mn>2</mn>
        <mrow>
         <mo>-</mo>
         <mn>32</mn>
        </mrow>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mn>6.66</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <root></root>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <ln></ln>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <cn type="integer">2</cn>
          <apply>
           <minus></minus>
           <cn type="integer">32</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <cos></cos>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <apply>
         <minus></minus>
         <cn type="integer">32</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="float">6.66</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{-2\ln(2^{-32})}\cos(2\pi 2^{-32})\approx 6.66
  </annotation>
 </semantics>
</math>

 This means that the algorithm will not produce random variables more than 6.66 standard deviations from the mean. This corresponds to a proportion of 

<math display="inline" id="Box–Muller_transform:19">
 <semantics>
  <mrow>
   <mn>2.74</mn>
   <mo>×</mo>
   <msup>
    <mn>10</mn>
    <mrow>
     <mo>-</mo>
     <mn>11</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="float">2.74</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">10</cn>
     <apply>
      <minus></minus>
      <cn type="integer">11</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2.74\times 10^{-11}
  </annotation>
 </semantics>
</math>

 lost due to the truncation.</p>
<h2 id="implementation">Implementation</h2>

<p>The standard Box-Muller transform generates values from the standard normal distribution (<em>i.e.</em> <a href="standard_normal_deviate" title="wikilink">standard normal deviates</a>) with mean <em>0</em> and standard deviation <em>1</em>. The implementation below in standard <a href="C++_(programming_language)" title="wikilink">C++</a> generates values from any normal distribution with mean 

<math display="inline" id="Box–Muller_transform:20">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>


 and variance 

<math display="inline" id="Box–Muller_transform:21">
 <semantics>
  <msup>
   <mi>σ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>σ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Box–Muller_transform:22">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

 is a standard normal deviate, then 

<math display="inline" id="Box–Muller_transform:23">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>Z</mi>
     <mi>σ</mi>
    </mrow>
    <mo>+</mo>
    <mi>μ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>Z</ci>
      <ci>σ</ci>
     </apply>
     <ci>μ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=Z\sigma+\mu
  </annotation>
 </semantics>
</math>

 will have a normal distribution with mean 

<math display="inline" id="Box–Muller_transform:24">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 and standard deviation 

<math display="inline" id="Box–Muller_transform:25">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>


. Note that because the random number generator <code>rand</code> has not been <a href="Random_seed" title="wikilink">seeded</a>, the same series of values will always be returned from the <code>generateGaussianNoise</code> function.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include <cstdlib></cstdlib></span>
<span class="ot">#include <cmath></cmath></span>
<span class="ot">#include <limits></limits></span>
<span class="dt">double</span> generateGaussianNoise(<span class="dt">double</span> mu, <span class="dt">double</span> sigma)
{
    <span class="dt">const</span> <span class="dt">double</span> epsilon = std::numeric_limits&lt;<span class="dt">double</span>&gt;::min();
    <span class="dt">const</span> <span class="dt">double</span> tau = <span class="fl">2.</span><span class="dv">0</span>*<span class="fl">3.</span><span class="dv">14159265358979323846</span>;

    <span class="dt">static</span> <span class="dt">double</span> z0, z1;
    <span class="dt">static</span> <span class="dt">bool</span> generate;
    generate = !generate;

    <span class="kw">if</span> (!generate)
        <span class="kw">return</span> z1 * sigma + mu;

    <span class="dt">double</span> u1, u2;
    <span class="kw">do</span>
    {
        u1 = rand() * (<span class="fl">1.</span><span class="dv">0</span> / RAND_MAX);
        u2 = rand() * (<span class="fl">1.</span><span class="dv">0</span> / RAND_MAX);
    }
    <span class="kw">while</span> ( u1 &lt;= epsilon );

    z0 = sqrt(<span class="fl">-2.</span><span class="dv">0</span> * log(u1)) * cos(tau * u2);
    z1 = sqrt(<span class="fl">-2.</span><span class="dv">0</span> * log(u1)) * sin(tau * u2);
    <span class="kw">return</span> z0 * sigma + mu;
}
<!--<span class="dt"-->double</code></pre></div></body>&gt;
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Inverse_transform_sampling" title="wikilink">Inverse transform sampling</a></li>
<li><a href="Marsaglia_polar_method" title="wikilink">Marsaglia polar method</a>, similar transform to Box-Muller, which uses Cartesian coordinates, instead of polar coordinates</li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Transforms" title="wikilink">Category:Transforms</a> <a href="Category:Non-uniform_random_numbers" title="wikilink">Category:Non-uniform random numbers</a> <a href="Category:Articles_with_example_C++_code" title="wikilink">Category:Articles with example C++ code</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">[<a class="uri" href="http://projecteuclid.org/DPubS/Repository/1.0/Disseminate?view=body&amp;id">http://projecteuclid.org/DPubS/Repository/1.0/Disseminate?view=body&amp;id;</a>;=pdf_1&amp;handle;=euclid.aoms/1177706645 G. E. P. Box and Mervin E. Muller, <em>A Note on the Generation of Random Normal Deviates</em>, The Annals of Mathematical Statistics (1958), Vol. 29, No. 2 pp. 610–611]<a href="#fnref1">↩</a></li>
<li id="fn2">Kloeden and Platen, <em>Numerical Solutions of Stochastic Differential Equations</em>, pp. 11–12<a href="#fnref2">↩</a></li>
<li id="fn3">Sheldon Ross, <em>A First Course in Probability</em>, (2002), pp. 279–81<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="http://portal.acm.org/citation.cfm?doid=363397.363547">J. Bell: 'Algorithm 334: Normal random deviates', Communications of the ACM, vol. 11, No. 7. 1968</a><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="http://portal.acm.org/citation.cfm?doid=362946.362996">R. Knopp: 'Remark on algorithm 334 [G5</a>: normal random deviates', Communications of the ACM, vol. 12, No. 5. 1969]<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="ftp://ftp.taygeta.com/pub/publications/randnum.tar.Z">Everett F. Carter, Jr., <em>The Generation and Application of Random Numbers</em>, Forth Dimensions (1994), Vol. 16, No. 1 &amp; 2.</a><a href="#fnref6">↩</a></li>
<li id="fn7">Note that the evaluation of 2<em>πU</em><sub>1</sub> is counted as a single multiplication because the value of 2<em>π</em> can be computed in advance and used repeatedly.<a href="#fnref7">↩</a></li>
</ol>
</section>


