<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="595">Phong reflection model</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Phong reflection model</h1>
<hr/>

<p>The <strong>Phong reflection model</strong> (also called <strong>Phong illumination</strong> or <strong>Phong lighting</strong>) is an <a href="Empirical_modelling" title="wikilink">empirical model</a> of the <a href="illumination_model" title="wikilink">local illumination</a> of points on a <a class="uri" href="surface" title="wikilink">surface</a>. In <a href="3D_computer_graphics" title="wikilink">3D computer graphics</a>, it is sometimes ambiguously referred to as "Phong shading", in particular if the model is used in combination with the <a href="Phong_shading" title="wikilink">interpolation method of the same name</a> and in the context of <a href="pixel_shader" title="wikilink">pixel shaders</a> or other places where a lighting calculation can be referred to as “<a class="uri" href="shading" title="wikilink">shading</a>”.</p>
<h2 id="history">History</h2>

<p>The Phong reflection model was developed by <a href="Bui_Tuong_Phong" title="wikilink">Bui Tuong Phong</a> at the <a href="University_of_Utah" title="wikilink">University of Utah</a>, who published it in his 1973 Ph.D. dissertation.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> It was published in conjunction with a method for interpolating the calculation for each individual <a class="uri" href="pixel" title="wikilink">pixel</a> that is rasterized from a polygonal surface model; the interpolation technique is known as <a href="Phong_shading" title="wikilink">Phong shading</a>, even when it is used with a reflection model other than Phong's. Phong's methods were considered radical at the time of their introduction, but have since become the de facto baseline shading method for many rendering applications. Phong's methods have proven popular due to their generally efficient use of computation time per rendered pixel.</p>
<h2 id="description">Description</h2>

<p>Phong reflection is an empirical model of local illumination. It describes the way a surface reflects light as a combination of the <a href="diffuse_reflection" title="wikilink">diffuse reflection</a> of rough surfaces with the <a href="specular_reflection" title="wikilink">specular reflection</a> of shiny surfaces. It is based on <a href="Bui_Tuong_Phong" title="wikilink">Bui Tuong Phong</a>'s informal observation that shiny surfaces have small intense <a href="specular_highlight" title="wikilink">specular highlights</a>, while dull surfaces have large highlights that fall off more gradually. The model also includes an <em>ambient</em> term to account for the small amount of light that is scattered about the entire scene.</p>
<figure><b>(Figure)</b>
<figcaption>Visual illustration of the Phong equation: here the light is white, the ambient and diffuse colors are both blue, and the specular color is white, reflecting a small part of the light hitting the surface, but only in very narrow highlights. The intensity of the diffuse component varies with the direction of the surface, and the ambient component is uniform (independent of direction).</figcaption>
</figure>

<p>For each light source in the scene, components 

<math display="inline" id="Phong_reflection_model:0">
 <semantics>
  <msub>
   <mi>i</mi>
   <mtext>s</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>i</ci>
    <mtext>s</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i_{\text{s}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Phong_reflection_model:1">
 <semantics>
  <msub>
   <mi>i</mi>
   <mtext>d</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>i</ci>
    <mtext>d</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i_{\text{d}}
  </annotation>
 </semantics>
</math>

 are defined as the intensities (often as <a class="uri" href="RGB" title="wikilink">RGB</a> values) of the specular and diffuse components of the light sources, respectively. A single term 

<math display="inline" id="Phong_reflection_model:2">
 <semantics>
  <msub>
   <mi>i</mi>
   <mtext>a</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>i</ci>
    <mtext>a</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i_{\text{a}}
  </annotation>
 </semantics>
</math>

 controls the ambient lighting; it is sometimes computed as a sum of contributions from all light sources.</p>

<p>For each <em>material</em> in the scene, the following parameters are defined:</p>

<p>

<math display="block" id="Phong_reflection_model:3">
 <semantics>
  <msub>
   <mi>k</mi>
   <mtext>s</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <mtext>s</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{\text{s}}
  </annotation>
 </semantics>
</math>

, which is a specular reflection constant, the ratio of reflection of the specular term of incoming light,</p>

<p>

<math display="block" id="Phong_reflection_model:4">
 <semantics>
  <msub>
   <mi>k</mi>
   <mtext>d</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <mtext>d</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{\text{d}}
  </annotation>
 </semantics>
</math>

, which is a diffuse reflection constant, the ratio of reflection of the diffuse term of incoming light (<a href="Lambertian_reflectance" title="wikilink">Lambertian reflectance</a>),</p>

<p>

<math display="block" id="Phong_reflection_model:5">
 <semantics>
  <msub>
   <mi>k</mi>
   <mtext>a</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <mtext>a</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{\text{a}}
  </annotation>
 </semantics>
</math>

, which is an ambient reflection constant, the ratio of reflection of the ambient term present in all points in the scene rendered, and</p>

<p>

<math display="block" id="Phong_reflection_model:6">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

, which is a <em>shininess</em> constant for this material, which is larger for surfaces that are smoother and more mirror-like. When this constant is large the specular highlight is small.</p>
<figure><b>(Figure)</b>
<figcaption>Vectors for calculating Phong and Blinn–Phong shading</figcaption>
</figure>

<p>Furthermore, we have</p>
<dl>
<dd>lights, which is the <a href="set_(mathematics)" title="wikilink">set</a> of all light sources,
</dd>
<dd>

<math display="inline" id="Phong_reflection_model:7">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>L</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>L</ci>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{L}_{m}
  </annotation>
 </semantics>
</math>

, which is the direction vector from the point on the surface toward each light source (

<math display="inline" id="Phong_reflection_model:8">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 specifies the light source),
</dd>
<dd>

<math display="inline" id="Phong_reflection_model:9">
 <semantics>
  <mover accent="true">
   <mi>N</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{N}
  </annotation>
 </semantics>
</math>

, which is the <a href="Surface_normal" title="wikilink">normal</a> at this point on the surface,
</dd>
<dd>

<math display="inline" id="Phong_reflection_model:10">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>R</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>R</ci>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{R}_{m}
  </annotation>
 </semantics>
</math>

, which is the direction that a perfectly reflected ray of light would take from this point on the surface, and
</dd>
<dd>

<math display="inline" id="Phong_reflection_model:11">
 <semantics>
  <mover accent="true">
   <mi>V</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{V}
  </annotation>
 </semantics>
</math>

, which is the direction pointing towards the viewer (such as a virtual camera).
</dd>
</dl>

<p>Then the Phong reflection model provides an equation for computing the illumination of each surface point 

<math display="inline" id="Phong_reflection_model:12">
 <semantics>
  <msub>
   <mi>I</mi>
   <mtext>p</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <mtext>p</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{\text{p}}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Phong_reflection_model:13">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>I</mi>
     <mtext>p</mtext>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>k</mi>
       <mtext>a</mtext>
      </msub>
      <msub>
       <mi>i</mi>
       <mtext>a</mtext>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mpadded width="+2.8pt">
         <mi>m</mi>
        </mpadded>
        <mo rspace="5.3pt">∈</mo>
        <mtext>lights</mtext>
       </mrow>
      </munder>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <msub>
          <mi>k</mi>
          <mtext>d</mtext>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mover accent="true">
             <mi>L</mi>
             <mo stretchy="false">^</mo>
            </mover>
            <mi>m</mi>
           </msub>
           <mo>⋅</mo>
           <mover accent="true">
            <mi>N</mi>
            <mo stretchy="false">^</mo>
           </mover>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <msub>
          <mi>i</mi>
          <mrow>
           <mi>m</mi>
           <mo>,</mo>
           <mtext>d</mtext>
          </mrow>
         </msub>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msub>
          <mi>k</mi>
          <mtext>s</mtext>
         </msub>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <msub>
             <mover accent="true">
              <mi>R</mi>
              <mo stretchy="false">^</mo>
             </mover>
             <mi>m</mi>
            </msub>
            <mo>⋅</mo>
            <mover accent="true">
             <mi>V</mi>
             <mo stretchy="false">^</mo>
            </mover>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi>α</mi>
         </msup>
         <msub>
          <mi>i</mi>
          <mrow>
           <mi>m</mi>
           <mo>,</mo>
           <mtext>s</mtext>
          </mrow>
         </msub>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <mtext>p</mtext>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <mtext>a</mtext>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>i</ci>
       <mtext>a</mtext>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>m</ci>
        <mtext>lights</mtext>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>k</ci>
         <mtext>d</mtext>
        </apply>
        <apply>
         <ci>normal-⋅</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <ci>normal-^</ci>
           <ci>L</ci>
          </apply>
          <ci>m</ci>
         </apply>
         <apply>
          <ci>normal-^</ci>
          <ci>N</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>i</ci>
         <list>
          <ci>m</ci>
          <mtext>d</mtext>
         </list>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>k</ci>
         <mtext>s</mtext>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <ci>normal-⋅</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <apply>
            <ci>normal-^</ci>
            <ci>R</ci>
           </apply>
           <ci>m</ci>
          </apply>
          <apply>
           <ci>normal-^</ci>
           <ci>V</ci>
          </apply>
         </apply>
         <ci>α</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>i</ci>
         <list>
          <ci>m</ci>
          <mtext>s</mtext>
         </list>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{\text{p}}=k_{\text{a}}i_{\text{a}}+\sum_{m\;\in\;\text{lights}}(k_{\text{d}%
}(\hat{L}_{m}\cdot\hat{N})i_{m,\text{d}}+k_{\text{s}}(\hat{R}_{m}\cdot\hat{V})%
^{\alpha}i_{m,\text{s}}).
  </annotation>
 </semantics>
</math>

</p>

<p>where the direction vector 

<math display="inline" id="Phong_reflection_model:14">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>R</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>R</ci>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{R}_{m}
  </annotation>
 </semantics>
</math>

 is calculated as the <a href="Specular_reflection#Direction_of_reflection" title="wikilink">reflection</a> of 

<math display="inline" id="Phong_reflection_model:15">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>L</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>L</ci>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{L}_{m}
  </annotation>
 </semantics>
</math>

 on the surface characterized by the surface normal 

<math display="inline" id="Phong_reflection_model:16">
 <semantics>
  <mover accent="true">
   <mi>N</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{N}
  </annotation>
 </semantics>
</math>

 using</p>

<p>

<math display="block" id="Phong_reflection_model:17">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>R</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>m</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mover accent="true">
         <mi>L</mi>
         <mo stretchy="false">^</mo>
        </mover>
        <mi>m</mi>
       </msub>
       <mo>⋅</mo>
       <mover accent="true">
        <mi>N</mi>
        <mo stretchy="false">^</mo>
       </mover>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mover accent="true">
      <mi>N</mi>
      <mo stretchy="false">^</mo>
     </mover>
    </mrow>
    <mo>-</mo>
    <msub>
     <mover accent="true">
      <mi>L</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>m</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>R</ci>
     </apply>
     <ci>m</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>L</ci>
        </apply>
        <ci>m</ci>
       </apply>
       <apply>
        <ci>normal-^</ci>
        <ci>N</ci>
       </apply>
      </apply>
      <apply>
       <ci>normal-^</ci>
       <ci>N</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>L</ci>
      </apply>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{R}_{m}=2(\hat{L}_{m}\cdot\hat{N})\hat{N}-\hat{L}_{m}
  </annotation>
 </semantics>
</math>

</p>

<p>and the hats indicate that the vectors are <a href="Unit_vector" title="wikilink">normalized</a>. The diffuse term is not affected by the viewer direction (

<math display="inline" id="Phong_reflection_model:18">
 <semantics>
  <mover accent="true">
   <mi>V</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{V}
  </annotation>
 </semantics>
</math>

). The specular term is large only when the viewer direction (

<math display="inline" id="Phong_reflection_model:19">
 <semantics>
  <mover accent="true">
   <mi>V</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{V}
  </annotation>
 </semantics>
</math>

) is aligned with the reflection direction 

<math display="inline" id="Phong_reflection_model:20">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>R</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>R</ci>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{R}_{m}
  </annotation>
 </semantics>
</math>

. Their alignment is measured by the 

<math display="inline" id="Phong_reflection_model:21">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 power of the cosine of the angle between them. The cosine of the angle between the normalized vectors 

<math display="inline" id="Phong_reflection_model:22">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>R</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>R</ci>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{R}_{m}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Phong_reflection_model:23">
 <semantics>
  <mover accent="true">
   <mi>V</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{V}
  </annotation>
 </semantics>
</math>

 is equal to their <a href="dot_product" title="wikilink">dot product</a>. When 

<math display="inline" id="Phong_reflection_model:24">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is large, in the case of a nearly mirror-like reflection, the specular highlight will be small, because any viewpoint not aligned with the reflection will have a cosine less than one which rapidly approaches zero when raised to a high power.</p>

<p>Although the above formulation is the common way of presenting the Phong reflection model, each term should only be included if the term's dot product is positive. (Additionally, the specular term should only be included if the dot product of the diffuse term is positive.)</p>

<p>When the color is represented as <a class="uri" href="RGB" title="wikilink">RGB</a> values, as often is the case in <a href="computer_graphics" title="wikilink">computer graphics</a>, this equation is typically modeled separately for R, G and B intensities, allowing different reflections constants 

<math display="inline" id="Phong_reflection_model:25">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mtext>a</mtext>
   </msub>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <mtext>a</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{\text{a}},
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Phong_reflection_model:26">
 <semantics>
  <msub>
   <mi>k</mi>
   <mtext>d</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <mtext>d</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{\text{d}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Phong_reflection_model:27">
 <semantics>
  <msub>
   <mi>k</mi>
   <mtext>s</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <mtext>s</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{\text{s}}
  </annotation>
 </semantics>
</math>

 for the different <a href="Channel_(digital_image)" title="wikilink">color channels</a>.</p>
<h3 id="computationally-more-efficient-alterations">Computationally more efficient alterations</h3>

<p>When implementing the Phong reflection model, there are a number of methods for approximating the model, rather than implementing the exact formulas, which can speed up the calculation; for example, the <a href="Blinn–Phong_reflection_model" title="wikilink">Blinn–Phong reflection model</a> is a modification of the Phong reflection model, which is more efficient if the viewer and the light source are treated to be at infinity.</p>

<p>Another approximation<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> also addresses the computation of the specular term since the calculation of the power term may be computationally expensive. Considering that the specular term should be taken into account only if its dot product is positive, it can be approximated by realizing that</p>

<p>

<math display="block" id="Phong_reflection_model:28">
 <semantics>
  <mrow>
   <mi>max</mi>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo>,</mo>
     <msub>
      <mover accent="true">
       <mi>R</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mi>m</mi>
     </msub>
     <mo>⋅</mo>
     <mover accent="true">
      <mi>V</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>α</mi>
   </msup>
   <mo>=</mo>
   <mi>max</mi>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo>-</mo>
     <mi>λ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>β</mi>
     <mi>γ</mi>
    </mrow>
   </msup>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo>(</mo>
     <mi>max</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo>,</mo>
       <mn>1</mn>
       <mo>-</mo>
       <mi>λ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>β</mi>
     </msup>
     <mo>)</mo>
    </mrow>
    <mi>γ</mi>
   </msup>
   <mo>≈</mo>
   <mi>max</mi>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo>-</mo>
     <mi>β</mi>
     <mi>λ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>γ</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <max></max>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cn type="integer">0</cn>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>R</ci>
       </apply>
       <ci>m</ci>
      </apply>
      <ci>normal-⋅</ci>
      <apply>
       <ci>normal-^</ci>
       <ci>V</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>α</ci>
    </apply>
    <eq></eq>
    <max></max>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cn type="integer">0</cn>
      <ci>normal-,</ci>
      <cn type="integer">1</cn>
      <minus></minus>
      <csymbol cd="unknown">λ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <times></times>
      <ci>β</ci>
      <ci>γ</ci>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <max></max>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <cn type="integer">0</cn>
        <ci>normal-,</ci>
        <cn type="integer">1</cn>
        <minus></minus>
        <csymbol cd="unknown">λ</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>β</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>γ</ci>
    </apply>
    <approx></approx>
    <max></max>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cn type="integer">0</cn>
      <ci>normal-,</ci>
      <cn type="integer">1</cn>
      <minus></minus>
      <csymbol cd="unknown">β</csymbol>
      <csymbol cd="unknown">λ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>γ</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max(0,\hat{R}_{m}\cdot\hat{V})^{\alpha}=\max(0,1-\lambda)^{\beta\gamma}=\left%
(\max(0,1-\lambda)^{\beta}\right)^{\gamma}\approx\max(0,1-\beta\lambda)^{\gamma}
  </annotation>
 </semantics>
</math>

</p>

<p>for 

<math display="inline" id="Phong_reflection_model:29">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <msub>
      <mover accent="true">
       <mi>R</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mi>m</mi>
     </msub>
     <mo>⋅</mo>
     <mover accent="true">
      <mi>V</mi>
      <mo stretchy="false">^</mo>
     </mover>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>λ</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>R</ci>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <ci>normal-^</ci>
       <ci>V</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda=1-\hat{R}_{m}\cdot\hat{V}
  </annotation>
 </semantics>
</math>

, for a sufficiently large, fixed integer 

<math display="inline" id="Phong_reflection_model:30">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

 (typically 4 will be enough), where 

<math display="inline" id="Phong_reflection_model:31">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>=</mo>
   <mrow>
    <mi>α</mi>
    <mo>/</mo>
    <mpadded width="+1.7pt">
     <mi>γ</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>β</ci>
    <apply>
     <divide></divide>
     <ci>α</ci>
     <ci>γ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta=\alpha/\gamma\,
  </annotation>
 </semantics>
</math>

 is a real number (not necessarily an integer). The value 

<math display="inline" id="Phong_reflection_model:32">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 can be further approximated as 

<math display="inline" id="Phong_reflection_model:33">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mover accent="true">
         <mi>R</mi>
         <mo stretchy="false">^</mo>
        </mover>
        <mi>m</mi>
       </msub>
       <mo>-</mo>
       <mover accent="true">
        <mi>V</mi>
        <mo stretchy="false">^</mo>
       </mover>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⋅</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mover accent="true">
         <mi>R</mi>
         <mo stretchy="false">^</mo>
        </mover>
        <mi>m</mi>
       </msub>
       <mo>-</mo>
       <mover accent="true">
        <mi>V</mi>
        <mo stretchy="false">^</mo>
       </mover>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>λ</ci>
    <apply>
     <divide></divide>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>R</ci>
        </apply>
        <ci>m</ci>
       </apply>
       <apply>
        <ci>normal-^</ci>
        <ci>V</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>R</ci>
        </apply>
        <ci>m</ci>
       </apply>
       <apply>
        <ci>normal-^</ci>
        <ci>V</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda=(\hat{R}_{m}-\hat{V})\cdot(\hat{R}_{m}-\hat{V})/2
  </annotation>
 </semantics>
</math>

; this squared distance between the vectors 

<math display="inline" id="Phong_reflection_model:34">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>R</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>R</ci>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{R}_{m}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Phong_reflection_model:35">
 <semantics>
  <mover accent="true">
   <mi>V</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{V}
  </annotation>
 </semantics>
</math>

 is much less sensitive to normalization errors in those vectors than is Phong's dot-product-based 

<math display="inline" id="Phong_reflection_model:36">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <msub>
      <mover accent="true">
       <mi>R</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mi>m</mi>
     </msub>
     <mo>⋅</mo>
     <mover accent="true">
      <mi>V</mi>
      <mo stretchy="false">^</mo>
     </mover>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>λ</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>R</ci>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <ci>normal-^</ci>
       <ci>V</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda=1-\hat{R}_{m}\cdot\hat{V}
  </annotation>
 </semantics>
</math>

.</p>

<p>The 

<math display="inline" id="Phong_reflection_model:37">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

 value can be chosen to be a fixed power of 2, 

<math display="inline" id="Phong_reflection_model:38">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>γ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma=2^{n}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Phong_reflection_model:39">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is a small integer; then the expression 

<math display="inline" id="Phong_reflection_model:40">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <mi>β</mi>
      <mi>λ</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>γ</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>β</ci>
      <ci>λ</ci>
     </apply>
    </apply>
    <ci>γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1-\beta\lambda)^{\gamma}
  </annotation>
 </semantics>
</math>

 can be efficiently calculated by squaring 

<math display="inline" id="Phong_reflection_model:41">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <mi>β</mi>
     <mi>λ</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <times></times>
     <ci>β</ci>
     <ci>λ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1-\beta\lambda)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Phong_reflection_model:42">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 times. Here the <em>shininess</em> parameter is 

<math display="inline" id="Phong_reflection_model:43">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

, proportional to the original parameter 

<math display="inline" id="Phong_reflection_model:44">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

.</p>

<p>This method substitutes a few multiplications for a variable exponentiation, and removes the need for an accurate reciprocal-square-root-based vector normalization.</p>
<h2 id="inverse-phong-reflection-model">Inverse Phong reflection model</h2>

<p>The Phong reflection model in combination with <a href="Phong_shading" title="wikilink">Phong shading</a> is an approximation of shading of objects in real life. This means that the Phong equation can relate the shading seen in a <a class="uri" href="photograph" title="wikilink">photograph</a> with the surface normals of the visible object. Inverse refers to the wish to estimate the surface normals given a rendered image, natural or computer-made.</p>

<p>The Phong reflection model contains many parameters, such as the surface diffuse reflection parameter (<a class="uri" href="albedo" title="wikilink">albedo</a>) which may vary within the object. Thus the normals of an object in a photograph can only be determined, by introducing additional information such as the number of lights, light directions and reflection parameters.</p>

<p>For example we have a cylindrical object, for instance a finger, and wish to compute the normal 

<math display="inline" id="Phong_reflection_model:45">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>N</mi>
     <mi>x</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>N</mi>
     <mi>z</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <interval closure="closed">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <ci>z</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=[N_{x},N_{z}]
  </annotation>
 </semantics>
</math>

 on a line on the object. We assume only one light, no specular reflection, and uniform known (approximated) reflection parameters. We can then simplify the Phong equation to:</p>

<p>

<math display="block" id="Phong_reflection_model:46">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>I</mi>
     <mi>p</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>C</mi>
     <mi>a</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>C</mi>
      <mi>d</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mrow>
         <mi>L</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>⋅</mo>
        <mi>N</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>p</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>d</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <times></times>
         <ci>L</ci>
         <ci>x</ci>
        </apply>
        <ci>N</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{p}(x)=C_{a}+C_{d}(L(x)\cdot N(x))
  </annotation>
 </semantics>
</math>

</p>

<p>With 

<math display="inline" id="Phong_reflection_model:47">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>a</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{a}
  </annotation>
 </semantics>
</math>

 a constant equal to the ambient light and 

<math display="inline" id="Phong_reflection_model:48">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>d</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{d}
  </annotation>
 </semantics>
</math>

 a constant equal to the diffusion reflection. We can re-write the equation to:</p>

<p>

<math display="block" id="Phong_reflection_model:49">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>I</mi>
        <mi>p</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <msub>
       <mi>C</mi>
       <mi>a</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <msub>
     <mi>C</mi>
     <mi>d</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <mi>N</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>I</ci>
        <ci>p</ci>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>a</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>d</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <ci>L</ci>
       <ci>x</ci>
      </apply>
      <ci>N</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (I_{p}(x)-C_{a})/C_{d}=L(x)\cdot N(x)
  </annotation>
 </semantics>
</math>

</p>

<p>Which can be rewritten for a line through the cylindrical object as:</p>

<p>

<math display="block" id="Phong_reflection_model:50">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>I</mi>
       <mi>p</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>C</mi>
       <mi>a</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <msub>
     <mi>C</mi>
     <mi>d</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>L</mi>
      <mi>x</mi>
     </msub>
     <msub>
      <mi>N</mi>
      <mi>x</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>L</mi>
      <mi>z</mi>
     </msub>
     <msub>
      <mi>N</mi>
      <mi>z</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>a</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>d</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <ci>z</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (I_{p}-C_{a})/C_{d}=L_{x}N_{x}+L_{z}N_{z}
  </annotation>
 </semantics>
</math>

</p>

<p>For instance if the light direction is 45 degrees above the object 

<math display="inline" id="Phong_reflection_model:51">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0.71</mn>
    <mo>,</mo>
    <mn>0.71</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <interval closure="closed">
     <cn type="float">0.71</cn>
     <cn type="float">0.71</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=[0.71,0.71]
  </annotation>
 </semantics>
</math>

 we get two equations with two unknowns.</p>

<p>

<math display="block" id="Phong_reflection_model:52">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>I</mi>
       <mi>p</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>C</mi>
       <mi>a</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <msub>
     <mi>C</mi>
     <mi>d</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>0.71</mn>
     <msub>
      <mi>N</mi>
      <mi>x</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>0.71</mn>
     <msub>
      <mi>N</mi>
      <mi>z</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>a</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>d</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="float">0.71</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="float">0.71</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (I_{p}-C_{a})/C_{d}=0.71N_{x}+0.71N_{z}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Phong_reflection_model:53">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>=</mo>
   <msqrt>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msubsup>
       <mi>N</mi>
       <mi>x</mi>
       <mn>2</mn>
      </msubsup>
      <mo>+</mo>
      <msubsup>
       <mi>N</mi>
       <mi>z</mi>
       <mn>2</mn>
      </msubsup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <cn type="integer">1</cn>
    <apply>
     <root></root>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>N</ci>
        <ci>x</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>N</ci>
        <ci>z</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1=\sqrt{(N_{x}^{2}+N_{z}^{2})}
  </annotation>
 </semantics>
</math>

</p>

<p>Because of the powers of two in the equation there are two possible solutions for the normal direction. Thus some prior information of the geometry is needed to define the correct normal direction. The normals are directly related to angles of inclination of the line on the object surface. Thus the normals allow the calculation of the relative surface heights of the line on the object using a line integral, if we assume a continuous surface.</p>

<p>If the object is not cylindrical, we have three unknown normal values 

<math display="inline" id="Phong_reflection_model:54">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>N</mi>
     <mi>x</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>N</mi>
     <mi>y</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>N</mi>
     <mi>z</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <ci>z</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=[N_{x},N_{y},N_{z}]
  </annotation>
 </semantics>
</math>

. Then the two equations still allow the normal to rotate around the view vector, thus additional constraints are needed from prior geometric information. For instance in face recognition those geometric constraints can be obtained using <a href="principal_component_analysis" title="wikilink">principal component analysis</a> (PCA) on a database of depth-maps of faces, allowing only surface normals solutions which are found in a normal population.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="applications">Applications</h2>

<p>As already implied, the Phong reflection model is often used together with <a href="Phong_shading" title="wikilink">Phong shading</a> to shade surfaces in <a href="3D_computer_graphics" title="wikilink">3D computer graphics</a> software. Apart from this, it may also be used for other purposes. For example, it has been used to model the reflection of <a href="thermal_radiation" title="wikilink">thermal radiation</a> from the <a href="Pioneer_program" title="wikilink">Pioneer probes</a> in an attempt to explain the <a href="Pioneer_anomaly" title="wikilink">Pioneer anomaly</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="List_of_common_shading_algorithms" title="wikilink">List of common shading algorithms</a></li>
<li><a href="Blinn–Phong_shading_model" title="wikilink">Blinn–Phong shading model</a> – alteration of the Phong reflection model to trade precision with computing efficiency</li>
<li><a href="Phong_shading" title="wikilink">Phong shading</a> – shading technique that interpolates normal vectors rather than intensities</li>
<li><a href="Gamma_correction" title="wikilink">Gamma correction</a></li>
<li><a href="Bidirectional_reflectance_distribution_function" title="wikilink">Bidirectional reflectance distribution function</a> – another reflection model</li>
<li><a href="Specular_highlight" title="wikilink">Specular highlight</a> – other specular lighting equations</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://michal.is/projects/phong-reflection-model-matlab/">Phong reflection model in Matlab</a></li>
<li>[<a class="uri" href="http://www.sunandblackcat.com/tipFullView.php?l=eng&amp;topicid">http://www.sunandblackcat.com/tipFullView.php?l=eng&amp;topicid;</a>;=30 Phong reflection model in GLSL]</li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Computer_graphics_algorithms" title="wikilink">Category:Computer graphics algorithms</a> <a class="uri" href="Category:Shading" title="wikilink">Category:Shading</a> <a href="Category:Vietnamese_inventions" title="wikilink">Category:Vietnamese inventions</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Bui Tuong Phong, <a href="http://www.cs.northwestern.edu/~ago820/cs395/Papers/Phong_1975.pdf">Illumination for computer generated pictures</a>, Communications of ACM 18 (1975), no. 6, 311–317.<a href="#fnref1">↩</a></li>
<li id="fn2">University of Utah School of Computing, <a class="uri" href="http://www.cs.utah.edu/school/history/#phong-ref">http://www.cs.utah.edu/school/history/#phong-ref</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
