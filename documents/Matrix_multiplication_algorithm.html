<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="11">Matrix multiplication algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Matrix multiplication algorithm</h1>
<hr/>

<p>Because <a href="matrix_multiplication" title="wikilink">matrix multiplication</a> is such a central operation in many <a href="numerical_algorithm" title="wikilink">numerical algorithms</a>, much work has been invested in making <strong>matrix multiplication algorithms</strong> efficient. Applications of matrix multiplication in computational problems are found in many fields including <a href="scientific_computing" title="wikilink">scientific computing</a> and <a href="pattern_recognition" title="wikilink">pattern recognition</a> and in seemingly unrelated problems such counting the paths through a <a href="Graph_(graph_theory)" title="wikilink">graph</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Many different algorithms have been designed for multiplying matrices on different types of hardware, including <a href="parallel_computing" title="wikilink">parallel</a> and <a href="distributed_computing" title="wikilink">distributed</a> systems, where the computational work is spread over multiple processors (perhaps over a network).</p>

<p>Directly applying the mathematical definition of matrix multiplication gives an algorithm that <a href="Analysis_of_algorithms" title="wikilink">takes time</a> on the order of <mtpl></mtpl> to multiply two 

<math display="inline" id="Matrix_multiplication_algorithm:0">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">×</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-×</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n×n
  </annotation>
 </semantics>
</math>

 matrices (<mtpl></mtpl> in <a href="big_O_notation" title="wikilink">big O notation</a>). Better asymptotic bounds on the time required to multiply matrices have been known since the work of Strassen in the 1960s, but it is still unknown what the optimal time is (i.e., what the <a href="Computational_complexity_theory" title="wikilink">complexity of the problem</a> is).</p>
<h2 id="iterative-algorithm">Iterative algorithm</h2>

<p>The <a href="Matrix_multiplication#General_definition_of_the_matrix_product" title="wikilink">definition of matrix multiplication</a> is that if 

<math display="inline" id="Matrix_multiplication_algorithm:1">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=AB
  </annotation>
 </semantics>
</math>

 for an 

<math display="inline" id="Matrix_multiplication_algorithm:2">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">×</mi>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-×</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n×m
  </annotation>
 </semantics>
</math>

 matrix 

<math display="inline" id="Matrix_multiplication_algorithm:3">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and an 

<math display="inline" id="Matrix_multiplication_algorithm:4">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi mathvariant="normal">×</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>normal-×</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m×p
  </annotation>
 </semantics>
</math>

 matrix 

<math display="inline" id="Matrix_multiplication_algorithm:5">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Matrix_multiplication_algorithm:6">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is an 

<math display="inline" id="Matrix_multiplication_algorithm:7">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">×</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-×</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n×p
  </annotation>
 </semantics>
</math>

 matrix with entries</p>

<p>

<math display="block" id="Matrix_multiplication_algorithm:8">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>m</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>i</mi>
       <mi>k</mi>
      </mrow>
     </msub>
     <msub>
      <mi>b</mi>
      <mrow>
       <mi>k</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <apply>
        <times></times>
        <ci>k</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{ij}=\sum_{k=1}^{m}a_{ik}b_{kj}
  </annotation>
 </semantics>
</math>

.</p>

<p>From this, a simple algorithm can be constructed which loops over the indices 

<math display="inline" id="Matrix_multiplication_algorithm:9">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 from 1 through 

<math display="inline" id="Matrix_multiplication_algorithm:10">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Matrix_multiplication_algorithm:11">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 from 1 through 

<math display="inline" id="Matrix_multiplication_algorithm:12">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, computing the above using a nested loop:</p>
<div style="margin-left: 35px; width: 600px">
<ul>
<li>Input: matrices 

<math display="inline" id="Matrix_multiplication_algorithm:13">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Matrix_multiplication_algorithm:14">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

</li>
<li>Let 

<math display="inline" id="Matrix_multiplication_algorithm:15">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 be a new matrix of the appropriate size</li>
<li>For 

<math display="inline" id="Matrix_multiplication_algorithm:16">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 from 1 to 

<math display="inline" id="Matrix_multiplication_algorithm:17">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

:
<ul>
<li>For 

<math display="inline" id="Matrix_multiplication_algorithm:18">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 from 1 to 

<math display="inline" id="Matrix_multiplication_algorithm:19">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

:
<ul>
<li>Let 

<math display="inline" id="Matrix_multiplication_algorithm:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mi>u</mi>
    <mi>m</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>u</ci>
     <ci>m</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   sum=0
  </annotation>
 </semantics>
</math>

</li>
<li>For 

<math display="inline" id="Matrix_multiplication_algorithm:21">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 from 1 to 

<math display="inline" id="Matrix_multiplication_algorithm:22">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

:
<ul>
<li>Set <mtpl></mtpl></li>
</ul></li>
<li>Set <mtpl></mtpl></li>
</ul></li>
</ul></li>
<li>Return 

<math display="inline" id="Matrix_multiplication_algorithm:23">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

</li>
</ul>
</div>

<p>This algorithms takes <a href="time_complexity" title="wikilink">time</a> 

<math display="inline" id="Matrix_multiplication_algorithm:24">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>m</mi>
     <mi>p</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>m</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Θ(nmp)
  </annotation>
 </semantics>
</math>

 (in <a href="asymptotic_notation" title="wikilink">asymptotic notation</a>),<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> or <mtpl></mtpl> in the case of square matrices, all of shape 

<math display="inline" id="Matrix_multiplication_algorithm:25">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">×</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-×</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n×n
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h3 id="cache-behavior">Cache behavior</h3>

<p>The three loops in iterative matrix multiplication can be arbitrarily swapped with each other without an effect on correctness or asymptotic running time. The order can have an impact on practical performance due to the <a href="locality_of_reference" title="wikilink">memory access patterns</a> and <a href="CPU_cache" title="wikilink">cache</a> use of the algorithm;<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> which order is best also depends on whether the matrices are stored in <a href="row-major_order" title="wikilink">row-major order</a>, column-major order, or a mix of both.</p>

<p>In particular, in the idealized case of a <a href="CPU_cache#Associativity" title="wikilink">fully associative cache</a> consisting of 

<math display="inline" id="Matrix_multiplication_algorithm:26">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 cache lines of 

<math display="inline" id="Matrix_multiplication_algorithm:27">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 bytes each, the above algorithm is suboptimal for 

<math display="inline" id="Matrix_multiplication_algorithm:28">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Matrix_multiplication_algorithm:29">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 stored in row-major order. When 

<math display="inline" id="Matrix_multiplication_algorithm:30">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>></mo>
   <mrow>
    <mi>M</mi>
    <mi mathvariant="normal">∕</mi>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>n</ci>
    <apply>
     <times></times>
     <ci>M</ci>
     <ci>normal-∕</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n>M∕b
  </annotation>
 </semantics>
</math>

, every iteration of the inner loop (a simultaneous sweep through a row of 

<math display="inline" id="Matrix_multiplication_algorithm:31">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and a column of 

<math display="inline" id="Matrix_multiplication_algorithm:32">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

) incurs a cache miss when accessing an element of 

<math display="inline" id="Matrix_multiplication_algorithm:33">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

. This means the algorithm incurs <mtpl></mtpl> cache misses in the worst case. , the speed of memories compared to that of processors is such that the cache misses, rather than the actual calculations, dominate the running time.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="divide-and-conquer-algorithm">Divide and conquer algorithm</h2>

<p>An alternative to the iterative algorithm is the <a href="divide_and_conquer" title="wikilink">divide and conquer</a> algorithm for matrix multiplication. This relies on the <a href="block_matrix" title="wikilink">block partitioning</a></p>

<p>

<math display="block" id="Matrix_multiplication_algorithm:34">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>C</mi>
         <mn>11</mn>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>C</mi>
         <mn>12</mn>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>C</mi>
         <mn>21</mn>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>C</mi>
         <mn>22</mn>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mo>=</mo>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>A</mi>
          <mn>11</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>A</mi>
          <mn>12</mn>
         </msub>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>A</mi>
          <mn>21</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>A</mi>
          <mn>22</mn>
         </msub>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo rspace="4.2pt">,</mo>
    <mrow>
     <mi>B</mi>
     <mo>=</mo>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>B</mi>
          <mn>11</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>B</mi>
          <mn>12</mn>
         </msub>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>B</mi>
          <mn>21</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>B</mi>
          <mn>22</mn>
         </msub>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>C</ci>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <cn type="integer">11</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <cn type="integer">12</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <cn type="integer">21</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <cn type="integer">22</cn>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <ci>A</ci>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <cn type="integer">11</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <cn type="integer">12</cn>
        </apply>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <cn type="integer">21</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <cn type="integer">22</cn>
        </apply>
       </matrixrow>
      </matrix>
     </apply>
     <apply>
      <eq></eq>
      <ci>B</ci>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>B</ci>
         <cn type="integer">11</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>B</ci>
         <cn type="integer">12</cn>
        </apply>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>B</ci>
         <cn type="integer">21</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>B</ci>
         <cn type="integer">22</cn>
        </apply>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=\begin{pmatrix}C_{11}&C_{12}\\
C_{21}&C_{22}\\
\end{pmatrix},\,A=\begin{pmatrix}A_{11}&A_{12}\\
A_{21}&A_{22}\\
\end{pmatrix},\,B=\begin{pmatrix}B_{11}&B_{12}\\
B_{21}&B_{22}\\
\end{pmatrix}
  </annotation>
 </semantics>
</math>

.</p>

<p>which works for all square matrices whose dimensions are powers of two, i.e., the shapes are <mtpl></mtpl> for some 

<math display="inline" id="Matrix_multiplication_algorithm:35">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

. The matrix product is now</p>

<p>

<math display="block" id="Matrix_multiplication_algorithm:36">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>C</mi>
        <mn>11</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>C</mi>
        <mn>12</mn>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>C</mi>
        <mn>21</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>C</mi>
        <mn>22</mn>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>A</mi>
         <mn>11</mn>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>A</mi>
         <mn>12</mn>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>A</mi>
         <mn>21</mn>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>A</mi>
         <mn>22</mn>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>B</mi>
         <mn>11</mn>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>B</mi>
         <mn>12</mn>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>B</mi>
         <mn>21</mn>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>B</mi>
         <mn>22</mn>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mrow>
         <msub>
          <mi>A</mi>
          <mn>11</mn>
         </msub>
         <msub>
          <mi>B</mi>
          <mn>11</mn>
         </msub>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msub>
          <mi>A</mi>
          <mn>12</mn>
         </msub>
         <msub>
          <mi>B</mi>
          <mn>21</mn>
         </msub>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mrow>
         <msub>
          <mi>A</mi>
          <mn>11</mn>
         </msub>
         <msub>
          <mi>B</mi>
          <mn>12</mn>
         </msub>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msub>
          <mi>A</mi>
          <mn>12</mn>
         </msub>
         <msub>
          <mi>B</mi>
          <mn>22</mn>
         </msub>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mrow>
         <msub>
          <mi>A</mi>
          <mn>21</mn>
         </msub>
         <msub>
          <mi>B</mi>
          <mn>11</mn>
         </msub>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msub>
          <mi>A</mi>
          <mn>22</mn>
         </msub>
         <msub>
          <mi>B</mi>
          <mn>21</mn>
         </msub>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mrow>
         <msub>
          <mi>A</mi>
          <mn>21</mn>
         </msub>
         <msub>
          <mi>B</mi>
          <mn>12</mn>
         </msub>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msub>
          <mi>A</mi>
          <mn>22</mn>
         </msub>
         <msub>
          <mi>B</mi>
          <mn>22</mn>
         </msub>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <cn type="integer">11</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <cn type="integer">12</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <cn type="integer">21</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <cn type="integer">22</cn>
       </apply>
      </matrixrow>
     </matrix>
     <apply>
      <times></times>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <cn type="integer">11</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <cn type="integer">12</cn>
        </apply>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <cn type="integer">21</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <cn type="integer">22</cn>
        </apply>
       </matrixrow>
      </matrix>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>B</ci>
         <cn type="integer">11</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>B</ci>
         <cn type="integer">12</cn>
        </apply>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>B</ci>
         <cn type="integer">21</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>B</ci>
         <cn type="integer">22</cn>
        </apply>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <matrix>
      <matrixrow>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>A</ci>
          <cn type="integer">11</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>B</ci>
          <cn type="integer">11</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>A</ci>
          <cn type="integer">12</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>B</ci>
          <cn type="integer">21</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>A</ci>
          <cn type="integer">11</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>B</ci>
          <cn type="integer">12</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>A</ci>
          <cn type="integer">12</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>B</ci>
          <cn type="integer">22</cn>
         </apply>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>A</ci>
          <cn type="integer">21</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>B</ci>
          <cn type="integer">11</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>A</ci>
          <cn type="integer">22</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>B</ci>
          <cn type="integer">21</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>A</ci>
          <cn type="integer">21</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>B</ci>
          <cn type="integer">12</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>A</ci>
          <cn type="integer">22</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>B</ci>
          <cn type="integer">22</cn>
         </apply>
        </apply>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{pmatrix}C_{11}&C_{12}\\
C_{21}&C_{22}\\
\end{pmatrix}=\begin{pmatrix}A_{11}&A_{12}\\
A_{21}&A_{22}\\
\end{pmatrix}\begin{pmatrix}B_{11}&B_{12}\\
B_{21}&B_{22}\\
\end{pmatrix}=\begin{pmatrix}A_{11}B_{11}+A_{12}B_{21}&A_{11}B_{12}+A_{12}B_{2%
2}\\
A_{21}B_{11}+A_{22}B_{21}&A_{21}B_{12}+A_{22}B_{22}\\
\end{pmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>which consists of eight multiplications of pairs of submatrices, followed by an addition step. The divide and conquer algorithm computes the smaller multiplications <a href="recursion" title="wikilink">recursively</a>, using the <a href="scalar_multiplication" title="wikilink">scalar multiplication</a> <mtpl> <em>a</em><sub>11</sub><em>b</em><sub>11</sub>}}</mtpl> as its base case.</p>

<p>The complexity of this algorithm as a function of 

<math display="inline" id="Matrix_multiplication_algorithm:37">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is given by the recurrence<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>

<math display="block" id="Matrix_multiplication_algorithm:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Θ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Θ</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(1)=\Theta(1)
  </annotation>
 </semantics>
</math>

;</p>

<p>

<math display="block" id="Matrix_multiplication_algorithm:39">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>8</mn>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi mathvariant="normal">Θ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>n</mi>
       <mn>2</mn>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">8</cn>
      <ci>T</ci>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Θ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(n)=8T(n/2)+\Theta(n^{2})
  </annotation>
 </semantics>
</math>

,</p>

<p>accounting for the eight recursive calls on matrices of size 

<math display="inline" id="Matrix_multiplication_algorithm:40">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n/2
  </annotation>
 </semantics>
</math>

 and <mtpl></mtpl> to sum the four pairs of resulting matrices element-wise. Application of the <a href="master_theorem" title="wikilink">master theorem</a> shows this recursion to have the solution <mtpl></mtpl>, the same as the iterative algorithm.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="non-square-matrices">Non-square matrices</h3>

<p>A variant of this algorithm that works for matrices of arbitrary shapes and is faster in practice<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> splits matrices in two instead of four submatrices, as follows.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Let matrix shapes be 

<math display="inline" id="Matrix_multiplication_algorithm:41">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">×</mi>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-×</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n×m
  </annotation>
 </semantics>
</math>


 for 

<math display="inline" id="Matrix_multiplication_algorithm:42">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Matrix_multiplication_algorithm:43">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi mathvariant="normal">×</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>normal-×</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m×p
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Matrix_multiplication_algorithm:44">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

. Splitting a matrix means dividing it into two parts of equal size, or as close to equal sizes as possible in the case of odd dimensions.</p>
<div style="margin-left: 35px; width: 600px">
<ul>
<li>Base case: 

<math display="inline" id="Matrix_multiplication_algorithm:45">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi>a</mi>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>m</mi>
    <mo>,</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>a</ci>
    <ci>x</ci>
    <vector>
     <ci>n</ci>
     <ci>m</ci>
     <ci>p</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   max(n,m,p)
  </annotation>
 </semantics>
</math>

 below some threshold, use an <a href="loop_unrolling" title="wikilink">unrolled</a> version of the iterative algorithm.</li>
</ul>
<ul>
<li>Recursive cases:</li>
</ul>

<p>:* If 

<math display="inline" id="Matrix_multiplication_algorithm:46">
 <semantics>
  <mrow>
   <mrow>
    <mi>m</mi>
    <mi>a</mi>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo>,</mo>
     <mi>m</mi>
     <mo>,</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>a</ci>
     <ci>x</ci>
     <vector>
      <ci>n</ci>
      <ci>m</ci>
      <ci>p</ci>
     </vector>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   max(n,m,p)=n
  </annotation>
 </semantics>
</math>


, split 

<math display="inline" id="Matrix_multiplication_algorithm:47">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 horizontally:</p>
<dl>
<dd><dl>
<dd><math>C = \begin{pmatrix} A_1 \\ A_2 \end{pmatrix} {B}
</math></dd>
</dl>
</dd>
</dl>

<p><code>         = \begin{pmatrix} A_1 B \\ A_2 B \end{pmatrix}</code></p>

<p>:* Else, if 

<math display="inline" id="Matrix_multiplication_algorithm:48">
 <semantics>
  <mrow>
   <mrow>
    <mi>m</mi>
    <mi>a</mi>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo>,</mo>
     <mi>m</mi>
     <mo>,</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>a</ci>
     <ci>x</ci>
     <vector>
      <ci>n</ci>
      <ci>m</ci>
      <ci>p</ci>
     </vector>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   max(n,m,p)=p
  </annotation>
 </semantics>
</math>

, split 

<math display="inline" id="Matrix_multiplication_algorithm:49">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 vertically:</p>
<dl>
<dd><dl>
<dd><math>C = A \begin{pmatrix} B_1 &amp; B_2 \end{pmatrix}
</math></dd>
</dl>
</dd>
</dl>

<p><code>         = \begin{pmatrix} A B_1 &amp; A B_2 \end{pmatrix}  </code></p>

<p>:* Otherwise, 

<math display="inline" id="Matrix_multiplication_algorithm:50">
 <semantics>
  <mrow>
   <mrow>
    <mi>m</mi>
    <mi>a</mi>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo>,</mo>
     <mi>m</mi>
     <mo>,</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>a</ci>
     <ci>x</ci>
     <vector>
      <ci>n</ci>
      <ci>m</ci>
      <ci>p</ci>
     </vector>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   max(n,m,p)=m
  </annotation>
 </semantics>
</math>

. Split 

<math display="inline" id="Matrix_multiplication_algorithm:51">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>


 vertically and 

<math display="inline" id="Matrix_multiplication_algorithm:52">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 horizontally:</p>
<dl>
<dd><dl>
<dd><math>C = \begin{pmatrix} A_1 &amp; A_2 \end{pmatrix} \begin{pmatrix} B_1 \\ B_2 \end{pmatrix}
</math></dd>
</dl>
</dd>
</dl>

<p><code>         = A_1 B_1 + A_2 B_2</code></p>
</div>
<h3 id="cache-behavior-1">Cache behavior</h3>

<p>The cache miss rate of recursive matrix multiplication is the same as that of a <a href="Loop_tiling" title="wikilink">tiled</a> iterative version, but unlike that algorithm, the recursive algorithm is <a href="Cache-oblivious_matrix_multiplication" title="wikilink">cache-oblivious</a>:<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> there is no tuning parameter required to get optimal cache performance, and it behaves well in a <a class="uri" href="multiprogramming" title="wikilink">multiprogramming</a> environment where cache sizes are effectively dynamic due to other processes taking up cache space.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> (The simple iterative algorithm is cache-oblivious as well, but much slower in practice if the matrix layout is not adapted to the algorithm.)</p>
<h2 id="sub-cubic-algorithms">Sub-cubic algorithms</h2>
<figure><b>(Figure)</b>
<figcaption>The bound on 

<math display="inline" id="Matrix_multiplication_algorithm:53">
 <semantics>
  <mi>ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ω
  </annotation>
 </semantics>
</math>

 over time.</figcaption>
</figure>

<p>Algorithms exist that provide better running times than the straightforward ones. The first to be discovered was <a href="Strassen_algorithm" title="wikilink">Strassen's algorithm</a>, devised by <a href="Volker_Strassen" title="wikilink">Volker Strassen</a> in 1969 and often referred to as "fast matrix multiplication". It is based on a way of multiplying two 

<math display="inline" id="Matrix_multiplication_algorithm:54">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi mathvariant="normal">×</mi>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>normal-×</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2×2
  </annotation>
 </semantics>
</math>

-matrices which requires only 7 multiplications (instead of the usual 8), at the expense of several additional addition and subtraction operations. Applying this recursively gives an algorithm with a multiplicative cost of 

<math display="inline" id="Matrix_multiplication_algorithm:55">
 <semantics>
  <mrow>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>n</mi>
      <mrow>
       <msub>
        <mi>log</mi>
        <mn>2</mn>
       </msub>
       <mn>7</mn>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>n</mi>
      <mn>2.807</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">7</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="float">2.807</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{\log_{2}7})\approx O(n^{2.807})
  </annotation>
 </semantics>
</math>

. Strassen's algorithm is more complex, and the <a href="numerical_stability" title="wikilink">numerical stability</a> is reduced compared to the naïve algorithm,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> but it is faster in cases where 

<math display="inline" id="Matrix_multiplication_algorithm:56">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>></mo>
   <mn>100</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>n</ci>
    <cn type="integer">100</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n>100
  </annotation>
 </semantics>
</math>


 or so<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> and appears in several libraries, such as <a href="Basic_Linear_Algebra_Subprograms" title="wikilink">BLAS</a>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> It is very useful for large matrices over exact domains such as finite fields, where numerical stability is not an issue.</p>

<p>The current <mtpl></mtpl> algorithm with the lowest known exponent 

<math display="inline" id="Matrix_multiplication_algorithm:57">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is a generalization of the <a href="Coppersmith–Winograd_algorithm" title="wikilink">Coppersmith–Winograd algorithm</a> that has an asymptotic complexity of <mtpl></mtpl>, by François Le Gall.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> The Le Gall algorithm, and the <a href="Coppersmith–Winograd_algorithm" title="wikilink">Coppersmith–Winograd algorithm</a> on which it is based, are similar to Strassen's algorithm: a way is devised for multiplying two 

<math display="inline" id="Matrix_multiplication_algorithm:58">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mi mathvariant="normal">×</mi>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <ci>normal-×</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k×k
  </annotation>
 </semantics>
</math>

-matrices with fewer than <mtpl></mtpl> multiplications, and this technique is applied recursively. However, the constant coefficient hidden by the <a href="Big_O_notation" title="wikilink">Big O notation</a> is so large that these algorithms are only worthwhile for matrices that are too large to handle on present-day computers.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p>Since any algorithm for multiplying two 

<math display="inline" id="Matrix_multiplication_algorithm:59">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">×</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-×</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n×n
  </annotation>
 </semantics>
</math>

-matrices has to process all <mtpl></mtpl>-entries, there is an asymptotic lower bound of <mtpl></mtpl> operations. Raz proves a lower bound of <mtpl></mtpl> for bounded coefficient arithmetic circuits over the real or complex numbers.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>

<p>Cohn <em>et al.</em> put methods such as the Strassen and Coppersmith–Winograd algorithms in an entirely different <a href="group_theory" title="wikilink">group-theoretic</a> context, by utilising triples of subsets of finite groups which satisfy a disjointness property called the <a href="Triple_product_property" title="wikilink">triple product property (TPP)</a>. They show that if families of <a href="wreath_product" title="wikilink">wreath products</a> of <a href="Abelian_group" title="wikilink">Abelian groups</a> with symmetric groups realise families of subset triples with a simultaneous version of the TPP, then there are matrix multiplication algorithms with essentially quadratic complexity.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> Most researchers believe that this is indeed the case.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> However, Alon, Shpilka and <a href="Chris_Umans" title="wikilink">Chris Umans</a> have recently shown that some of these conjectures implying fast matrix multiplication are incompatible with another plausible conjecture, the <a href="sunflower_conjecture" title="wikilink">sunflower conjecture</a>.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>

<p><a href="Freivalds'_algorithm" title="wikilink">Freivalds' algorithm</a> is a simple Monte Carlo algorithm that, given matrices 

<math display="inline" id="Matrix_multiplication_algorithm:60">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Matrix_multiplication_algorithm:61">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Matrix_multiplication_algorithm:62">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

, verifies in <mtpl></mtpl> time if 

<math display="inline" id="Matrix_multiplication_algorithm:63">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>B</mi>
   </mrow>
   <mo>=</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   AB=C
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="parallel-and-distributed-algorithms">Parallel and distributed algorithms</h2>
<h3 id="shared-memory-parallelism">Shared-memory parallelism</h3>

<p>The <a href="#Divide_and_conquer_algorithm" title="wikilink">divide and conquer algorithm</a> sketched earlier can be <a href="parallel_algorithm" title="wikilink">parallelized</a> in two ways for <a href="shared-memory_multiprocessor" title="wikilink">shared-memory multiprocessors</a>. These are based on the fact that the eight recursive matrix multiplications in</p>

<p>

<math display="block" id="Matrix_multiplication_algorithm:64">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <mrow>
        <msub>
         <mi>A</mi>
         <mn>11</mn>
        </msub>
        <msub>
         <mi>B</mi>
         <mn>11</mn>
        </msub>
       </mrow>
       <mo>+</mo>
       <mrow>
        <msub>
         <mi>A</mi>
         <mn>12</mn>
        </msub>
        <msub>
         <mi>B</mi>
         <mn>21</mn>
        </msub>
       </mrow>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mrow>
        <msub>
         <mi>A</mi>
         <mn>11</mn>
        </msub>
        <msub>
         <mi>B</mi>
         <mn>12</mn>
        </msub>
       </mrow>
       <mo>+</mo>
       <mrow>
        <msub>
         <mi>A</mi>
         <mn>12</mn>
        </msub>
        <msub>
         <mi>B</mi>
         <mn>22</mn>
        </msub>
       </mrow>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <mrow>
        <msub>
         <mi>A</mi>
         <mn>21</mn>
        </msub>
        <msub>
         <mi>B</mi>
         <mn>11</mn>
        </msub>
       </mrow>
       <mo>+</mo>
       <mrow>
        <msub>
         <mi>A</mi>
         <mn>22</mn>
        </msub>
        <msub>
         <mi>B</mi>
         <mn>21</mn>
        </msub>
       </mrow>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mrow>
        <msub>
         <mi>A</mi>
         <mn>21</mn>
        </msub>
        <msub>
         <mi>B</mi>
         <mn>12</mn>
        </msub>
       </mrow>
       <mo>+</mo>
       <mrow>
        <msub>
         <mi>A</mi>
         <mn>22</mn>
        </msub>
        <msub>
         <mi>B</mi>
         <mn>22</mn>
        </msub>
       </mrow>
      </mrow>
     </mtd>
    </mtr>
   </mtable>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">11</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <cn type="integer">11</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">12</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <cn type="integer">21</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">11</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <cn type="integer">12</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">12</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <cn type="integer">22</cn>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">21</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <cn type="integer">11</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">22</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <cn type="integer">21</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">21</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <cn type="integer">12</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">22</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <cn type="integer">22</cn>
       </apply>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{pmatrix}A_{11}B_{11}+A_{12}B_{21}&A_{11}B_{12}+A_{12}B_{22}\\
A_{21}B_{11}+A_{22}B_{21}&A_{21}B_{12}+A_{22}B_{22}\\
\end{pmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>can be performed independently of each other, as can the four summations (although the algorithm needs to "join" the multiplications before doing the summations). Exploiting the full parallelism of the problem, one obtains an algorithm that can be expressed in <a href="fork–join_model" title="wikilink">fork–join style</a> <a class="uri" href="pseudocode" title="wikilink">pseudocode</a>:<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>
<div style="margin-left: 35px; width: 600px">

<p><strong>Procedure</strong> 

<math display="inline" id="Matrix_multiplication_algorithm:65">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi>u</mi>
   <mi>l</mi>
   <mi>t</mi>
   <mi>i</mi>
   <mi>p</mi>
   <mi>l</mi>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo>,</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>u</ci>
    <ci>l</ci>
    <ci>t</ci>
    <ci>i</ci>
    <ci>p</ci>
    <ci>l</ci>
    <ci>y</ci>
    <vector>
     <ci>C</ci>
     <ci>A</ci>
     <ci>B</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   multiply(C,A,B)
  </annotation>
 </semantics>
</math>

:</p>
<ul>
<li>Base case: if 

<math display="inline" id="Matrix_multiplication_algorithm:66">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=1
  </annotation>
 </semantics>
</math>

, set <mtpl></mtpl> (or multiply a small block matrix).</li>
<li>Otherwise, allocate space for a new matrix 

<math display="inline" id="Matrix_multiplication_algorithm:67">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 of shape 

<math display="inline" id="Matrix_multiplication_algorithm:68">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">×</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-×</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n×n
  </annotation>
 </semantics>
</math>

, then:
<ul>
<li>Partition 

<math display="inline" id="Matrix_multiplication_algorithm:69">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 into <mtpl></mtpl>, <mtpl></mtpl>, <mtpl></mtpl>, <mtpl></mtpl>.</li>
<li>Partition 

<math display="inline" id="Matrix_multiplication_algorithm:70">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 into <mtpl></mtpl>, <mtpl></mtpl>, <mtpl></mtpl>, <mtpl></mtpl>.</li>
<li>Partition 

<math display="inline" id="Matrix_multiplication_algorithm:71">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 into <mtpl></mtpl>, <mtpl></mtpl>, <mtpl></mtpl>, <mtpl></mtpl>.</li>
<li>Partition 

<math display="inline" id="Matrix_multiplication_algorithm:72">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 into <mtpl></mtpl>, <mtpl></mtpl>, <mtpl></mtpl>, <mtpl></mtpl>.</li>
<li>Parallel execution:
<ul>
<li><em>Fork</em> <mtpl></mtpl>.</li>
<li><em>Fork</em> <mtpl></mtpl>.</li>
<li><em>Fork</em> <mtpl></mtpl>.</li>
<li><em>Fork</em> <mtpl></mtpl>.</li>
<li><em>Fork</em> <mtpl></mtpl>.</li>
<li><em>Fork</em> <mtpl></mtpl>.</li>
<li><em>Fork</em> <mtpl></mtpl>.</li>
<li><em>Fork</em> <mtpl></mtpl>.</li>
</ul></li>
<li><em>Join</em> (wait for parallel forks to complete).</li>
<li>

<math display="inline" id="Matrix_multiplication_algorithm:73">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi>d</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo>,</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>d</ci>
    <ci>d</ci>
    <interval closure="open">
     <ci>C</ci>
     <ci>T</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   add(C,T)
  </annotation>
 </semantics>
</math>

.</li>
<li>Deallocate 

<math display="inline" id="Matrix_multiplication_algorithm:74">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

.</li>
</ul></li>
</ul>

<p><strong>Procedure</strong> 

<math display="inline" id="Matrix_multiplication_algorithm:75">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi>d</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo>,</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>d</ci>
    <ci>d</ci>
    <interval closure="open">
     <ci>C</ci>
     <ci>T</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   add(C,T)
  </annotation>
 </semantics>
</math>

 adds 

<math display="inline" id="Matrix_multiplication_algorithm:76">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 into 

<math display="inline" id="Matrix_multiplication_algorithm:77">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

, element-wise:</p>
<ul>
<li>Base case: if 

<math display="inline" id="Matrix_multiplication_algorithm:78">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=1
  </annotation>
 </semantics>
</math>

, set <mtpl></mtpl> (or do a short loop, perhaps unrolled).</li>
<li>Otherwise:
<ul>
<li>Partition 

<math display="inline" id="Matrix_multiplication_algorithm:79">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 into <mtpl></mtpl>, <mtpl></mtpl>, <mtpl></mtpl>, <mtpl></mtpl>.</li>
<li>Partition 

<math display="inline" id="Matrix_multiplication_algorithm:80">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 into <mtpl></mtpl>, <mtpl></mtpl>, <mtpl></mtpl>, <mtpl></mtpl>.</li>
<li>In parallel:
<ul>
<li><em>Fork</em> <mtpl></mtpl>.</li>
<li><em>Fork</em> <mtpl></mtpl>.</li>
<li><em>Fork</em> <mtpl></mtpl>.</li>
<li><em>Fork</em> <mtpl></mtpl>.</li>
</ul></li>
<li><em>Join</em>.</li>
</ul></li>
</ul>
</div>

<p>Here, <em>fork</em> is a keyword that signal a computation may be run in parallel with the rest of the function call, while <em>join</em> waits for all previously "forked" computations to complete. 

<math display="inline" id="Matrix_multiplication_algorithm:81">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mi>a</mi>
   <mi>r</mi>
   <mi>t</mi>
   <mi>i</mi>
   <mi>t</mi>
   <mi>i</mi>
   <mi>o</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>a</ci>
    <ci>r</ci>
    <ci>t</ci>
    <ci>i</ci>
    <ci>t</ci>
    <ci>i</ci>
    <ci>o</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   partition
  </annotation>
 </semantics>
</math>

 achieves its goal by pointer manipulation only.</p>

<p>This algorithm has a <a href="critical_path_length" title="wikilink">critical path length</a> of <mtpl></mtpl> steps, meaning it takes that much time on an ideal machine with an infinite number of processors; therefore, it has a maximum possible <a class="uri" href="speedup" title="wikilink">speedup</a> of <mtpl></mtpl> on any real computer. The algorithm isn't practical due to the communication cost inherent in moving data to and from the temporary matrix 

<math display="inline" id="Matrix_multiplication_algorithm:82">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

, but a more practical variant achieves <mtpl></mtpl> speedup, without using a temporary.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>
<figure><b>(Figure)</b>
<figcaption>Block matrix multiplication. In the 2D algorithm, each processor is responsible for one submatrix of 

<math display="inline" id="Matrix_multiplication_algorithm:83">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

. In the 3D algorithm, every pair of submatrices from 

<math display="inline" id="Matrix_multiplication_algorithm:84">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Matrix_multiplication_algorithm:85">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 that is multiplied is assigned to one processor.</figcaption>
</figure>
<h3 id="communication-avoiding-and-distributed-algorithms">Communication-avoiding and distributed algorithms</h3>

<p>On modern architectures with hierarchical memory, the cost of loading and storing input matrix elements tends to dominate the cost of arithmetic. On a single machine this is the amount of data transferred between RAM and cache, while on a distributed memory multi-node machine it is the amount transferred between nodes; in either case it is called the <em>communication bandwidth</em>. The naïve algorithm using three nested loops uses <mtpl></mtpl> communication bandwidth.</p>

<p><a href="Cannon's_algorithm" title="wikilink">Cannon's algorithm</a>, also known as the <em>2D algorithm</em>, partitions each input matrix into a block matrix whose elements are submatrices of size 

<math display="inline" id="Matrix_multiplication_algorithm:86">
 <semantics>
  <mrow>
   <msqrt>
    <mi>M</mi>
   </msqrt>
   <mo>/</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <root></root>
     <ci>M</ci>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{M}{/3}
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Matrix_multiplication_algorithm:87">
 <semantics>
  <mrow>
   <msqrt>
    <mi>M</mi>
   </msqrt>
   <mo>/</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <root></root>
     <ci>M</ci>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{M}{/3}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Matrix_multiplication_algorithm:88">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is the size of fast memory.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> The naïve algorithm is then used over the block matrices, computing products of submatrices entirely in fast memory. This reduces communication bandwidth to <mtpl></mtpl>, which is asymptotically optimal (for algorithms performing <mtpl></mtpl> computation).<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a><a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>

<p>In a distributed setting with 

<math display="inline" id="Matrix_multiplication_algorithm:89">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 processors arranged in a 

<math display="inline" id="Matrix_multiplication_algorithm:90">
 <semantics>
  <msqrt>
   <mi>p</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{p}
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Matrix_multiplication_algorithm:91">
 <semantics>
  <msqrt>
   <mi>p</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{p}
  </annotation>
 </semantics>
</math>

 2D mesh, one submatrix of the result can be assigned to each processor, and the product can be computed with each processor transmitting <mtpl></mtpl> words, which is asymptotically optimal assuming that each node stores the minimum <mtpl></mtpl> elements.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> This can be improved by the <em>3D algorithm,</em> which arranges the processors in a 3D cube mesh, assigning every product of two input submatrices to a single processor. The result submatrices are then generated by performing a reduction over each row.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> This algorithm transmits <mtpl></mtpl> words per processor, which is asymptotically optimal.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> However, this requires replicating each input matrix element <mtpl></mtpl> times, and so requires a factor of <mtpl></mtpl> more memory than is needed to store the inputs. This algorithm can be combined with Strassen to further reduce runtime.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> "2.5D" algorithms provide a continuous tradeoff between memory usage and communication bandwidth.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> On modern distributed computing environments such as <a class="uri" href="MapReduce" title="wikilink">MapReduce</a>, specialized multiplication algorithms have been developed.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p>
<h3 id="algorithms-for-meshes">Algorithms for meshes</h3>

<p>There are a variety of algorithms for multiplication on <a href="Mesh_networking" title="wikilink">meshes</a>. For multiplication of two n×n on a standard two-dimensional mesh using the 2D <a href="Cannon's_algorithm" title="wikilink">Cannon's algorithm</a>, one can complete the multiplication in 3n-2 steps although this is reduced to half this number for repeated computations.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> The standard array is inefficient because the data from the two matrices does not arrive simultaneously and it must be padded with zeroes.</p>

<p>The result is even faster on a two-layered cross-wired mesh, where only 2n-1 steps are needed.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> The performance improves further for repeated computations leading to 100% efficiency.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> The cross-wired mesh array may be seen as a special case of a non-planar (i.e. multilayered) processing structure.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> </p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Computational_complexity_of_mathematical_operations" title="wikilink">Computational complexity of mathematical operations</a></li>
<li><a href="CYK_algorithm#Valiant's_algorithm" title="wikilink">CYK algorithm, §Valiant's algorithm</a></li>
<li><a href="Matrix_chain_multiplication" title="wikilink">Matrix chain multiplication</a></li>
<li><a href="Sparse_matrix-vector_multiplication" title="wikilink">Sparse matrix-vector multiplication</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Matrix_multiplication_algorithms" title="wikilink"> </a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15">. The original algorithm was presented by <a href="Don_Coppersmith" title="wikilink">Don Coppersmith</a> and <a href="Shmuel_Winograd" title="wikilink">Shmuel Winograd</a> in 1990, has an asymptotic complexity of <mtpl></mtpl>. It was improved in 2013 to <mtpl></mtpl> by Virginia Vassilevska Williams, giving a time only slightly worse than Le Gall's improvement: <a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="Ran_Raz" title="wikilink">Ran Raz</a>. On the complexity of matrix product. In Proceedings of the thirty-fourth annual ACM symposium on Theory of computing. ACM Press, 2002. .<a href="#fnref18">↩</a></li>
<li id="fn19">Henry Cohn, <a href="Robert_Kleinberg" title="wikilink">Robert Kleinberg</a>, <a href="Balázs_Szegedy" title="wikilink">Balázs Szegedy</a>, and Chris Umans. Group-theoretic Algorithms for Matrix Multiplication. . <em>Proceedings of the 46th Annual Symposium on Foundations of Computer Science</em>, 23–25 October 2005, Pittsburgh, PA, IEEE Computer Society, pp. 379–388.<a href="#fnref19">↩</a></li>
<li id="fn20">Henry Cohn, Chris Umans. A Group-theoretic Approach to Fast Matrix Multiplication. . <em>Proceedings of the 44th Annual IEEE Symposium on Foundations of Computer Science</em>, 11–14 October 2003, Cambridge, MA, IEEE Computer Society, pp. 438–449.<a href="#fnref20">↩</a></li>
<li id="fn21"></li>
<li id="fn22"><a href="Noga_Alon" title="wikilink">Alon</a>, Shpilka, Umans, <a href="http://eccc.hpi-web.de/report/2011/067/">On Sunflowers and Matrix Multiplication</a><a href="#fnref22">↩</a></li>
<li id="fn23"></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25">Lynn Elliot Cannon, <em>[<a class="uri" href="http://portal.acm.org/citation.cfm?coll=GUIDE&amp;dl">http://portal.acm.org/citation.cfm?coll=GUIDE&amp;dl;</a>;=GUIDE&amp;id;=905686 A cellular computer to implement the Kalman Filter Algorithm]</em>, Technical report, Ph.D. Thesis, Montana State University, 14 July 1969.<a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"></li>
<li id="fn31"></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33"><a href="#fnref33">↩</a></li>
<li id="fn34">Bae, S.E., T.-W. Shinn, T. Takaoka (2014) A faster parallel algorithm for matrix multiplication on a mesh array. Procedia Computer Science 29: 2230-2240<a href="#fnref34">↩</a></li>
<li id="fn35">Kak, S. (1988) A two-layered mesh array for matrix multiplication. Parallel Computing 6: 383-385<a href="#fnref35">↩</a></li>
<li id="fn36">Kak, S. (2014) Efficiency of matrix multiplication on the cross-wired mesh array. <a class="uri" href="http://arxiv.org/abs/1411.3273">http://arxiv.org/abs/1411.3273</a><a href="#fnref36">↩</a></li>
<li id="fn37">Kak, S. (1988) Multilayered array computing. Information Sciences 45: 347-365<a href="#fnref37">↩</a></li>
</ol>
</section>
</body>
</html>
