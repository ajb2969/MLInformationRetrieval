<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="37">P/poly</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>P/poly</h1>
<hr/>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, <strong>P/poly</strong> is the <a href="complexity_class" title="wikilink">complexity class</a> of <a href="formal_language" title="wikilink">languages</a> recognized by a polynomial-time <a href="Turing_machine" title="wikilink">Turing machine</a> with a polynomial-bounded <a href="advice_(complexity)" title="wikilink">advice</a> function. It is also equivalently defined as the class <strong>PSIZE</strong> of languages that have a polynomial-size circuits.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> This means that the machine that recognizes a language may use a different advice function or use a different circuit depending on the length of the input, and that the advice function or circuit will vary only on the size of the input.</p>

<p>For example, the popular <a href="Miller–Rabin_primality_test" title="wikilink">Miller–Rabin primality test</a> can be formulated as a <strong>P/poly</strong> algorithm: the "advice" is a list of candidate <em>a</em> values to test. It is possible to precompute a list of at most <em>n</em> values such that every composite <em>n</em>-bit number will be certain to have a witness <em>a</em> in the list. For example, if we're testing a 32-bit number, it is enough to test <em>a</em> = 2, 7, and 61.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> This follows from the fact that for each composite <em>n</em>, 3/4s of all possible <em>a</em> values are witnesses; a simple counting argument similar to the one in the proof that <strong>BPP</strong> in <strong>P/poly</strong> below shows that there <em>exists</em> a suitable list of <em>a</em> values for every input size, although finding it may be expensive.</p>

<p>Note that <strong>P/poly</strong>, unlike other polynomial-time classes such as <strong><a href="P_(complexity)" title="wikilink">P</a></strong> or <strong><a href="Bounded-error_probabilistic_polynomial" title="wikilink">BPP</a></strong>, is not generally considered a practical class for computing. Indeed, it contains every <a href="undecidable_problem" title="wikilink">undecidable</a> <a href="unary_language" title="wikilink">unary language</a>, none of which can be solved in general by real computers. On the other hand, if the input length is bounded by a relatively small number and the advice strings are short, it can be used to model practical algorithms with a separate expensive preprocessing phase and a fast processing phase, as in the example above.</p>
<h2 id="importance-of-ppoly">Importance of P/poly</h2>

<p><strong>P/poly</strong> is an important class for several reasons. For theoretical computer science, there are several important properties that depend on <strong>P/poly</strong>:</p>
<ul>
<li>If <strong><a href="NP_(complexity)" title="wikilink">NP</a></strong> ⊆ <strong>P/poly</strong> then <strong>PH</strong> (the <a href="polynomial_hierarchy" title="wikilink">polynomial hierarchy</a>) collapses to 

<math display="inline" id="P::poly:0">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mn>2</mn>
   <mi mathvariant="normal">P</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{2}^{\rm P}
  </annotation>
 </semantics>
</math>

. This result is the <a href="Karp–Lipton_theorem" title="wikilink">Karp–Lipton theorem</a>; furthermore, <strong>NP</strong> ⊆ <strong>P/poly</strong> implies <strong><a href="Arthur-Merlin_protocol" title="wikilink">AM</a></strong> = <strong>MA</strong> <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></li>
<li>If <strong><a class="uri" href="PSPACE" title="wikilink">PSPACE</a></strong> ⊆ <strong>P/poly</strong> then <strong>PSPACE</strong> = 

<math display="inline" id="P::poly:1">
 <semantics>
  <mrow>
   <msubsup>
    <mi mathvariant="normal">Σ</mi>
    <mn>2</mn>
    <mi mathvariant="normal">P</mi>
   </msubsup>
   <mo>∩</mo>
   <msubsup>
    <mi mathvariant="normal">Π</mi>
    <mn>2</mn>
    <mi mathvariant="normal">P</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <intersect></intersect>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-P</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Π</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{2}^{\rm P}\cap\Pi_{2}^{\rm P}
  </annotation>
 </semantics>
</math>

, even <strong>PSPACE</strong> = <strong>MA</strong>.</li>
</ul>
<dl>
<dd>Proof: Consider a language <em>L</em> from <strong>PSPACE</strong>. It is known that there exists an <a href="IP_(complexity)" title="wikilink">interactive proof system</a> for <em>L</em>, where actions of the prover can be carried out by a <strong>PSPACE</strong> machine. By assumption, the prover can be replaced by a polynomial-size circuit. Therefore, <em>L</em> has a <strong>MA</strong> protocol: Merlin sends the circuit as proof, and Arthur can simulate the <strong>IP</strong> protocol himself without any additional help.
</dd>
</dl>
<ul>
<li>If <strong>P<sup><a href="Sharp_P" title="wikilink">#P</a></sup></strong> ⊆ <strong>P/poly</strong> then <strong>P<sup>#P</sup></strong> = <strong>MA</strong>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The proof is similar to above, based on an interactive protocol for permanent and <a href="Permanent_is_sharp-P-complete" title="wikilink">#P-completeness of permanent</a>.</li>
<li>If <strong><a class="uri" href="EXPTIME" title="wikilink">EXPTIME</a></strong> ⊆ <strong>P/poly</strong> then <strong>EXPTIME</strong> = 

<math display="inline" id="P::poly:2">
 <semantics>
  <mrow>
   <msubsup>
    <mi mathvariant="normal">Σ</mi>
    <mn>2</mn>
    <mi mathvariant="normal">P</mi>
   </msubsup>
   <mo>∩</mo>
   <msubsup>
    <mi mathvariant="normal">Π</mi>
    <mn>2</mn>
    <mi mathvariant="normal">P</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <intersect></intersect>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-P</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Π</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{2}^{\rm P}\cap\Pi_{2}^{\rm P}
  </annotation>
 </semantics>
</math>

 (Meyer's theorem), even <strong>EXPTIME</strong> = <strong>MA</strong>.</li>
<li>If <strong><a class="uri" href="NEXPTIME" title="wikilink">NEXPTIME</a></strong> ⊆ <strong>P/poly</strong> then <strong>NEXPTIME</strong> = <strong>EXPTIME</strong>, even <strong>NEXPTIME</strong> = <strong>MA</strong>. Conversely, <strong>NEXPTIME</strong> = <strong>MA</strong> implies <strong>NEXPTIME</strong> ⊆ <strong>P/poly</strong><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></li>
<li>If <strong>EXP</strong><sup><strong>NP</strong></sup> ⊆ <strong>P/poly</strong> then <strong>EXP</strong><sup><strong>NP</strong></sup> = 

<math display="inline" id="P::poly:3">
 <semantics>
  <mrow>
   <msubsup>
    <mi mathvariant="normal">Σ</mi>
    <mn>2</mn>
    <mi mathvariant="normal">P</mi>
   </msubsup>
   <mo>∩</mo>
   <msubsup>
    <mi mathvariant="normal">Π</mi>
    <mn>2</mn>
    <mi mathvariant="normal">P</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <intersect></intersect>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-P</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Π</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{2}^{\rm P}\cap\Pi_{2}^{\rm P}
  </annotation>
 </semantics>
</math>

 (Buhrman, Homer) <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></li>
<li>It is known that <strong>MA</strong><sub>EXP</sub>, an exponential version of <strong><a href="Arthur-Merlin_protocol" title="wikilink">MA</a></strong>, is not contained in <strong>P/poly</strong>.</li>
</ul>
<dl>
<dd>Proof: If <strong>MA</strong><sub>EXP</sub> ⊆ <strong>P/poly</strong> then <strong>PSPACE</strong> = <strong>MA</strong> (see above). By <a href="padding_argument" title="wikilink">padding</a>, <strong>EXPSPACE</strong> = <strong>MA</strong><sub>EXP</sub>, therefore <strong>EXPSPACE</strong> ⊆ <strong>P/poly</strong> but this can be proven false with diagonalization.
</dd>
</dl>

<p>One of the most interesting reasons that <strong>P/poly</strong> is important is the property that if <strong>NP</strong> is not a subset of <strong>P/poly</strong>, then <strong>P</strong> ≠ <strong>NP</strong>. This observation was the center of many attempts to prove <strong>P</strong> ≠ <strong>NP</strong>. It is known that for a random oracle <em>A</em>, <strong>NP</strong><sup><em>A</em></sup> is not a subset of <strong>P</strong><sup>A</sup><strong>/poly</strong> with probability 1. <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p><strong>P/poly</strong> is also used in the field of <a class="uri" href="cryptography" title="wikilink">cryptography</a>. Security is often defined 'against' <strong>P/poly</strong> adversaries. Besides including most practical models of computation like <strong>BPP</strong>, this also admits the possibility that adversaries can do heavy precomputation for inputs up to a certain length, as in the construction of <a href="rainbow_table" title="wikilink">rainbow tables</a>.</p>

<p>Although not all languages in <strong>P/poly</strong> are <a href="sparse_language" title="wikilink">sparse languages</a>, there is a <a href="polynomial-time_Turing_reduction" title="wikilink">polynomial-time Turing reduction</a> from any language in <strong>P/poly</strong> to a sparse language.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="adlemans-theorem">Adleman's theorem</h2>

<p>Adleman's theorem, proved by <a href="Leonard_Adleman" title="wikilink">Leonard Adleman</a>, states that <strong><a href="Bounded-error_probabilistic_polynomial" title="wikilink">BPP</a></strong> ⊆ <strong>P/poly</strong>, where <strong>BPP</strong> is the set of problems solvable with randomized algorithms with two-sided error in polynomial time.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Variants of the theorem show that <strong><a href="BPL_(complexity)" title="wikilink">BPL</a></strong> is contained in <strong><a class="uri" href="L/poly" title="wikilink">L/poly</a></strong> and <strong>AM</strong> is contained in <strong>NP/poly</strong>.</p>
<h3 id="proof">Proof</h3>

<p>Let <em>L</em> be a language in <strong>BPP</strong>, and let <em>M</em>(<em>x</em>,<em>r</em>) be a polynomial-time algorithm that decides <em>L</em> with error ≤ 1/3 (where <em>x</em> is the input string and <em>r</em> is a set of random bits).</p>

<p>Construct a new machine <em>M{{'}}</em>(<em>x</em>,<em>R</em>), which runs <em>M</em> 18<em>n</em> times (where <em>n</em> is the input length and <em>R</em> is a sequence of 18<em>n</em> independently random <em>r</em>s). Thus, <em>M{{'}}</em> is also polynomial-time, and has an error probability ≤ 1/<em>e</em><sup><em>n</em></sup> by Chernoff's bound (see <a href="Bounded-error_probabilistic_polynomial" title="wikilink">BPP</a>). If we can fix <em>R</em> then we obtain an algorithm that is deterministic.</p>

<p>If Bad(<em>x</em>) is defined as {<em>R</em>: <em>M{{'}}</em>(<em>x</em>,<em>R</em>) is incorrect}, we have:</p>

<p>

<math display="block" id="P::poly:4">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mpadded width="+1.7pt">
    <mi>x</mi>
   </mpadded>
   <msub>
    <mtext>Prob</mtext>
    <mi>R</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>R</mi>
    <mo>∈</mo>
    <mtext>Bad</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≤</mo>
   <mfrac>
    <mn>1</mn>
    <msup>
     <mi>e</mi>
     <mi>n</mi>
    </msup>
   </mfrac>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext>Prob</mtext>
     <ci>R</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">R</csymbol>
     <in></in>
     <mtext>Bad</mtext>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <leq></leq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\,\mbox{Prob}_{R}[R\in\mbox{Bad}(x)]\leq\frac{1}{e^{n}}.
  </annotation>
 </semantics>
</math>

</p>

<p>The input size is <em>n</em>, so there are 2<sup><em>n</em></sup> possible inputs. Thus, the probability that a random <em>R</em> is bad for at least one input <em>x</em> is</p>

<p>

<math display="block" id="P::poly:5">
 <semantics>
  <mrow>
   <msub>
    <mtext>Prob</mtext>
    <mi>R</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mo>∃</mo>
    <mpadded width="+1.7pt">
     <mi>x</mi>
    </mpadded>
    <mi>R</mi>
    <mo>∈</mo>
    <mtext>Bad</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≤</mo>
   <mfrac>
    <msup>
     <mn>2</mn>
     <mi>n</mi>
    </msup>
    <msup>
     <mi>e</mi>
     <mi>n</mi>
    </msup>
   </mfrac>
   <mo><</mo>
   <mn>1.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext>Prob</mtext>
     <ci>R</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <exists></exists>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">R</csymbol>
     <in></in>
     <mtext>Bad</mtext>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <leq></leq>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <lt></lt>
    <cn type="float">1.</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{Prob}_{R}[\exists x\,R\in\mbox{Bad}(x)]\leq\frac{2^{n}}{e^{n}}<1.
  </annotation>
 </semantics>
</math>

</p>

<p>In words, the probability that <em>R</em> is bad for some <em>x</em> is less than 1, therefore there must be an <em>R</em> that is good for all <em>x</em>. Take such an <em>R</em> to be the advice string in our <strong>P/poly</strong> algorithm.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="L/poly" title="wikilink">L/poly</a>, a <a href="logarithmic_space" title="wikilink">logarithmic space</a> analogue of P/poly that captures the complexity of polynomial size <a href="branching_program" title="wikilink">branching programs</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Complexity_classes" title="wikilink">Category:Complexity classes</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"><a href="http://www.daimi.au.dk/~bromille/CT06/complex3.pdf">Lecture notes on computational complexity by Peter Bro Miltersen</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://primes.utm.edu/prove/prove2_3.html">Finding primes &amp; proving primality</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="http://cse.unl.edu/~cbourke/pubs/EXPnote.pdf">A Note on the Karp-Lipton Collapse for the Exponential Hierarchy</a><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9">Jin-Yi Cai. <a href="http://pages.cs.wisc.edu/~jyc/02-810notes/lecture11.pdf">Lecture 11: P/poly, Sparse Sets, and Mahaney's Theorem</a>. CS 810: Introduction to Complexity Theory. The University of Wisconsin–Madison. September 18, 2003.<a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
</ol>
</section>
</body>
</html>
