<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1043">Constraint satisfaction problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Constraint satisfaction problem</h1>
<hr/>

<p><strong>Constraint satisfaction problems</strong> (CSPs) are mathematical problems defined as a set of objects whose state must satisfy a number of constraints or limitations. CSPs represent the entities in a problem as a homogeneous collection of finite constraints over <a href="Variable_(mathematics)" title="wikilink">variables</a>, which is solved by <a href="constraint_satisfaction" title="wikilink">constraint satisfaction</a> methods. CSPs are the subject of intense research in both <a href="artificial_intelligence" title="wikilink">artificial intelligence</a> and <a href="operations_research" title="wikilink">operations research</a>, since the regularity in their formulation provides a common basis to analyze and solve problems of many seemingly unrelated families. <a href="Complexity_of_constraint_satisfaction" title="wikilink">CSPs often exhibit high complexity</a>, requiring a combination of <a class="uri" href="heuristics" title="wikilink">heuristics</a> and <a href="combinatorial_search" title="wikilink">combinatorial search</a> methods to be solved in a reasonable time. The <a href="boolean_satisfiability_problem" title="wikilink">boolean satisfiability problem</a> (SAT), the <a href="Satisfiability_Modulo_Theories" title="wikilink">Satisfiability Modulo Theories</a> (SMT) and <a href="answer_set_programming" title="wikilink">answer set programming</a> (ASP) can be roughly thought of as certain forms of the constraint satisfaction problem.</p>

<p>Examples of simple problems that can be modeled as a constraint satisfaction problem</p>
<ul>
<li><a href="Eight_queens_puzzle" title="wikilink">Eight queens puzzle</a></li>
<li><a href="Graph_colouring" title="wikilink">Map coloring problem</a></li>
<li><a class="uri" href="Sudoku" title="wikilink">Sudoku</a>, <a class="uri" href="Futoshiki" title="wikilink">Futoshiki</a>, <a class="uri" href="Kakuro" title="wikilink">Kakuro</a> (Cross Sums), <a class="uri" href="Numbrix" title="wikilink">Numbrix</a>, <a class="uri" href="Hidato" title="wikilink">Hidato</a> and many other <a href="logic_puzzle" title="wikilink">logic puzzles</a>.</li>
</ul>

<p>Examples demonstrating the above are often provided with tutorials of ASP, boolean SAT and SMT solvers. In the general case, constraint problems can be much harder, and may not be expressible in some of these simpler systems.</p>

<p>"Real life" examples include <a href="automated_planning" title="wikilink">automated planning</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and <a href="resource_allocation" title="wikilink">resource allocation</a>.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>Formally, a constraint satisfaction problem is defined as a triple 

<math display="inline" id="Constraint_satisfaction_problem:0">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>X</mi>
   <mo>,</mo>
   <mi>D</mi>
   <mo>,</mo>
   <mi>C</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>X</ci>
    <ci>D</ci>
    <ci>C</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle X,D,C\rangle
  </annotation>
 </semantics>
</math>

, where <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>

<math display="block" id="Constraint_satisfaction_problem:1">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=\{X_{1},\ldots,X_{n}\}
  </annotation>
 </semantics>
</math>

 is a set of variables,</p>

<p>

<math display="block" id="Constraint_satisfaction_problem:2">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>D</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>D</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>n</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=\{D_{1},\ldots,D_{n}\}
  </annotation>
 </semantics>
</math>

 is a set of the respective domains of values, and</p>

<p>

<math display="block" id="Constraint_satisfaction_problem:3">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>C</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>C</mi>
     <mi>m</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>m</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=\{C_{1},\ldots,C_{m}\}
  </annotation>
 </semantics>
</math>

 is a set of constraints. Each variable 

<math display="inline" id="Constraint_satisfaction_problem:4">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}
  </annotation>
 </semantics>
</math>

 can take on the values in the nonempty domain 

<math display="inline" id="Constraint_satisfaction_problem:5">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{i}
  </annotation>
 </semantics>
</math>

. Every constraint 

<math display="inline" id="Constraint_satisfaction_problem:6">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>j</mi>
   </msub>
   <mo>∈</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>j</ci>
    </apply>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{j}\in C
  </annotation>
 </semantics>
</math>

 is in turn a pair 

<math display="inline" id="Constraint_satisfaction_problem:7">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <msub>
    <mi>t</mi>
    <mi>j</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>R</mi>
    <mi>j</mi>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>j</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle t_{j},R_{j}\rangle
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Constraint_satisfaction_problem:8">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mi>j</mi>
   </msub>
   <mo>⊂</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>j</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{j}\subset X
  </annotation>
 </semantics>
</math>

 is a subset of 

<math display="inline" id="Constraint_satisfaction_problem:9">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 variables and 

<math display="inline" id="Constraint_satisfaction_problem:10">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{j}
  </annotation>
 </semantics>
</math>

 is an 

<math display="inline" id="Constraint_satisfaction_problem:11">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-ary <a href="relation_(mathematics)" title="wikilink">relation</a> on the corresponding subset of domains 

<math display="inline" id="Constraint_satisfaction_problem:12">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{j}
  </annotation>
 </semantics>
</math>

. An <em>evaluation</em> of the variables is a function from a subset of variables to a particular set of values in the corresponding subset of domains. An evaluation 

<math display="inline" id="Constraint_satisfaction_problem:13">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 satisfies a constraint 

<math display="inline" id="Constraint_satisfaction_problem:14">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <msub>
    <mi>t</mi>
    <mi>j</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>R</mi>
    <mi>j</mi>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>j</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle t_{j},R_{j}\rangle
  </annotation>
 </semantics>
</math>

 if the values assigned to the variables 

<math display="inline" id="Constraint_satisfaction_problem:15">
 <semantics>
  <msub>
   <mi>t</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{j}
  </annotation>
 </semantics>
</math>

 satisfies the relation 

<math display="inline" id="Constraint_satisfaction_problem:16">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{j}
  </annotation>
 </semantics>
</math>

.</p>

<p>An evaluation is <em>consistent</em> if it does not violate any of the constraints. An evaluation is <em>complete</em> if it includes all variables. An evaluation is a <em>solution</em> if it is consistent and complete; such an evaluation is said to <em>solve</em> the constraint satisfaction problem.</p>
<h2 id="resolution-of-csps">Resolution of CSPs</h2>

<p>Constraint satisfaction problems on finite domains are typically solved using a form of <a href="Search_algorithm" title="wikilink">search</a>. The most used techniques are variants of <a class="uri" href="backtracking" title="wikilink">backtracking</a>, <a href="constraint_propagation" title="wikilink">constraint propagation</a>, and <a href="Local_search_(optimization)" title="wikilink">local search</a>.</p>

<p><a class="uri" href="Backtracking" title="wikilink">Backtracking</a> is a recursive algorithm. It maintains a partial assignment of the variables. Initially, all variables are unassigned. At each step, a variable is chosen, and all possible values are assigned to it in turn. For each value, the consistency of the partial assignment with the constraints is checked; in case of consistency, a <a href="Recursion" title="wikilink">recursive</a> call is performed. When all values have been tried, the algorithm backtracks. In this basic backtracking algorithm, consistency is defined as the satisfaction of all constraints whose variables are all assigned. Several variants of backtracking exists. <a class="uri" href="Backmarking" title="wikilink">Backmarking</a> improves the efficiency of checking consistency. <a class="uri" href="Backjumping" title="wikilink">Backjumping</a> allows saving part of the search by backtracking "more than one variable" in some cases. <a href="Constraint_learning" title="wikilink">Constraint learning</a> infers and saves new constraints that can be later used to avoid part of the search. <a href="Look-ahead_(backtracking)" title="wikilink">Look-ahead</a> is also often used in backtracking to attempt to foresee the effects of choosing a variable or a value, thus sometimes determining in advance when a subproblem is satisfiable or unsatisfiable.</p>

<p><a href="Constraint_propagation" title="wikilink">Constraint propagation</a> techniques are methods used to modify a constraint satisfaction problem. More precisely, they are methods that enforce a form of <a href="local_consistency" title="wikilink">local consistency</a>, which are conditions related to the consistency of a group of variables and/or constraints. Constraint propagation has various uses. First, it turns a problem into one that is equivalent but is usually simpler to solve. Second, it may prove satisfiability or unsatisfiability of problems. This is not guaranteed to happen in general; however, it always happens for some forms of constraint propagation and/or for some certain kinds of problems. The most known and used form of local consistency are <a href="arc_consistency" title="wikilink">arc consistency</a>, <a href="hyper-arc_consistency" title="wikilink">hyper-arc consistency</a>, and <a href="path_consistency" title="wikilink">path consistency</a>. The most popular constraint propagation method is the <a href="AC-3_algorithm" title="wikilink">AC-3 algorithm</a>, which enforces arc consistency.</p>

<p><a href="Local_search_(optimization)" title="wikilink">Local search</a> methods are incomplete satisfiability algorithms. They may find a solution of a problem, but they may fail even if the problem is satisfiable. They work by iteratively improving a complete assignment over the variables. At each step, a small number of variables are changed value, with the overall aim of increasing the number of constraints satisfied by this assignment. The <a href="min-conflicts_algorithm" title="wikilink">min-conflicts algorithm</a> is a local search algorithm specific for CSPs and based in that principle. In practice, local search appears to work well when these changes are also affected by random choices. Integration of search with local search have been developed, leading to <a href="Hybrid_algorithm_(constraint_satisfaction)" title="wikilink">hybrid algorithms</a>.</p>
<h2 id="theoretical-aspects-of-csps">Theoretical aspects of CSPs</h2>
<h3 id="decision-problems">Decision problems</h3>

<p>CSPs are also studied in <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a> and <a href="finite_model_theory" title="wikilink">finite model theory</a>. An important question is whether for each set of relations, the set of all CSPs that can be represented using only relations chosen from that set is either in <a href="P_(complexity)" title="wikilink">P</a> or <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>. If such a <a class="uri" href="dichotomy" title="wikilink">dichotomy</a> theorem is true, then CSPs provide one of the largest known subsets of <a href="NP_(complexity)" title="wikilink">NP</a> which avoids <a class="uri" href="NP-intermediate" title="wikilink">NP-intermediate</a> problems, whose existence was demonstrated by <a href="Ladner's_theorem" title="wikilink">Ladner's theorem</a> under the assumption that <a href="P_versus_NP_problem" title="wikilink">P ≠ NP</a>. <a href="Schaefer's_dichotomy_theorem" title="wikilink">Schaefer's dichotomy theorem</a> handles the case when all the available relations are <a href="boolean_operators" title="wikilink">boolean operators</a>, that is, for domain size 2. Schaefer's dichotomy theorem was recently generalized to a larger class of relations.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Most classes of CSPs that are known to be tractable are those where the <a class="uri" href="hypergraph" title="wikilink">hypergraph</a> of constraints has bounded <a class="uri" href="treewidth" title="wikilink">treewidth</a> (and there are no restrictions on the set of constraint relations), or where the constraints have arbitrary form but there exist essentially non-unary polymorphisms of the set of constraint relations.</p>

<p>Every CSP can also be considered as a <a href="conjunctive_query" title="wikilink">conjunctive query</a> containment problem.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h3 id="function-problems">Function problems</h3>

<p>A similar situation exists between the functional classes <a href="FP_(complexity)" title="wikilink">FP</a> and <a href="Sharp-P" title="wikilink">#P</a>. By a generalization of <a href="Ladner's_theorem" title="wikilink">Ladner's theorem</a>, there are also problems in neither FP nor <a href="Sharp-P-complete" title="wikilink">#P-complete</a> as long as FP ≠ #P. As in the decision case, a problem in the #CSP is defined by a set of relations. Each problem takes as input a <a href="Boolean_logic" title="wikilink">Boolean</a> formula as input and the task is to compute the number of satisfying assignments. This can be further generalized by using larger domain sizes and attaching a weight to each satisfying assignment and computing the sum of these weights. It is known that any complex weighted #CSP problem is either in FP or #P-hard.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="variants-of-csps">Variants of CSPs</h2>

<p>The classic model of Constraint Satisfaction Problem defines a model of static, inflexible constraints. This rigid model is a shortcoming that makes it difficult to represent problems easily.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Several modifications of the basic CSP definition have been proposed to adapt the model to a wide variety of problems.</p>
<h3 id="dynamic-csps">Dynamic CSPs</h3>

<p><strong>Dynamic CSPs</strong><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> (<em><a class="uri" href="DCSP" title="wikilink">DCSP</a></em>s) are useful when the original formulation of a problem is altered in some way, typically because the set of constraints to consider evolves because of the environment.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> DCSPs are viewed as a sequence of static CSPs, each one a transformation of the previous one in which variables and constraints can be added (restriction) or removed (relaxation). Information found in the initial formulations of the problem can be used to refine the next ones. The solving method can be classified according to the way in which information is transferred:</p>
<ul>
<li>Oracles: the solution found to previous CSPs in the sequence are used as heuristics to guide the resolution of the current CSP from scratch.</li>
<li>Local repair: each CSP is calculated starting from the partial solution of the previous one and repairing the inconsistent constraints with <a href="Local_search_(optimization)" title="wikilink">local search</a>.</li>
<li>Constraint recording: new constraints are defined in each stage of the search to represent the learning of inconsistent group of decisions. Those constraints are carried over the new CSP problems.</li>
</ul>
<h3 id="flexible-csps">Flexible CSPs</h3>

<p>Classic CSPs treat constraints as hard, meaning that they are <em>imperative</em> (each solution must satisfy all them) and <em>inflexible</em> (in the sense that they must be completely satisfied or else they are completely violated). <strong>Flexible CSP</strong>s relax those assumptions, partially <em>relaxing</em> the constraints and allowing the solution to not comply with all them. This is similar to preferences in <a href="preference-based_planning" title="wikilink">preference-based planning</a>. Some types of flexible CSPs include:</p>
<ul>
<li>MAX-CSP, where a number of constraints are allowed to be violated, and the quality of a solution is measured by the number of satisfied constraints.</li>
<li><a href="Weighted_constraint_satisfaction_problem" title="wikilink">Weighted CSP</a>, a MAX-CSP in which each violation of a constraint is weighted according to a predefined preference. Thus satisfying constraint with more weight is preferred.</li>
<li>Fuzzy CSP model constraints as <a href="fuzzy_logic" title="wikilink">fuzzy</a> relations in which the satisfaction of a constraint is a continuous function of its variables' values, going from fully satisfied to fully violated.</li>
</ul>
<h3 id="decentralized-csps">Decentralized CSPs</h3>

<p>In DCSPs<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> each constraint variable is thought of as having a separate geographic location. Strong constraints are placed on information exchange between variables, requiring the use of fully distributed algorithms to solve the constraint satisfaction problem.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Constraint_programming" title="wikilink">Constraint programming</a></li>
<li><a href="Declarative_programming" title="wikilink">Declarative programming</a></li>
<li><a href="DisCSP" title="wikilink">Distributed Constraint Satisfaction Problem</a> (DisCSP)</li>
<li><a href="Unique_games_conjecture" title="wikilink">Unique games conjecture</a></li>
<li><a href="Weighted_constraint_satisfaction_problem" title="wikilink">Weighted constraint satisfaction problem</a> (WCSP)</li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
</ul>
<ul>
<li><a href="http://4c.ucc.ie/web/outreach/tutorial.html">CSP Tutorial</a></li>
</ul>
<ul>
<li>

<p>ISBN 0-12-701610-4</p></li>
<li></li>
<li>

<p>ISBN 1-55860-890-7</p></li>
<li>

<p>ISBN 0-521-82583-0</p></li>
<li>

<p>ISBN 978-1-84821-106-3</p></li>
<li>Tomás Feder, <a href="http://theory.stanford.edu/~tomas/consmod.pdf"><em>Constraint satisfaction: a personal perspective</em></a>, manuscript.</li>
<li><a href="http://4c.ucc.ie/web/archive/index.jsp">Constraints archive</a></li>
<li><a href="http://www.nlsde.buaa.edu.cn/~kexu/benchmarks/benchmarks.htm">Forced Satisfiable CSP Benchmarks of Model RB</a></li>
<li><a href="http://www.cril.univ-artois.fr/~lecoutre/research/benchmarks/benchmarks.html">Benchmarks -- XML representation of CSP instances</a></li>
<li><a href="http://www.ps.uni-sb.de/Papers/abstracts/tackDiss.html">Constraint Propagation</a> - Dissertation by Guido Tack giving a good survey of theory and implementation issues</li>
</ul>

<p>"</p>

<p><a href="Category:Constraint_programming" title="wikilink">Category:Constraint programming</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.cs.st-andrews.ac.uk/~ianm/docs/Thesis.ppt">Dynamic Flexible Constraint Satisfaction and Its Application to AI Planning</a>, Ian Miguel - slides.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7">Dechter, R. and Dechter, A., Belief Maintenance in Dynamic Constraint Networks In Proc. of AAAI-88, 37-42. <a href="http://www.ics.uci.edu/%7Ecsp/r5.pdf">1</a><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="http://www.aaai.org/Papers/AAAI/1994/AAAI94-302.pdf">Solution reuse in dynamic constraint satisfaction problems</a>, Thomas Schiex<a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
</ol>
</section>
</body>
</html>
