<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1427">Inverse iteration</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Inverse iteration</h1>
<hr/>

<p>In <a href="numerical_analysis" title="wikilink">numerical analysis</a>, <strong>inverse iteration</strong> is an <a href="Iterative_method" title="wikilink">iterative</a> <a href="eigenvalue_algorithm" title="wikilink">eigenvalue algorithm</a>. It allows one to find an approximate <a class="uri" href="eigenvector" title="wikilink">eigenvector</a> when an approximation to a corresponding <a class="uri" href="eigenvalue" title="wikilink">eigenvalue</a> is already known. The method is conceptually similar to the <a href="power_method" title="wikilink">power method</a> and is also known as the <strong>inverse power method</strong>. It appears to have originally been developed to compute resonance frequencies in the field of structural mechanics. <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The inverse power iteration algorithm starts with an approximation 

<math display="inline" id="Inverse_iteration:0">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 for the <a class="uri" href="eigenvalue" title="wikilink">eigenvalue</a> corresponding to the desired <a class="uri" href="eigenvector" title="wikilink">eigenvector</a> and a vector <em>b</em><sub>0</sub>, either a randomly selected vector or an approximation to the eigenvector. The method is described by the iteration</p>

<p>

<math display="block" id="Inverse_iteration:1">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>b</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>A</mi>
         <mo>-</mo>
         <mrow>
          <mi>μ</mi>
          <mi>I</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <msub>
       <mi>b</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <msub>
      <mi>C</mi>
      <mi>k</mi>
     </msub>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <ci>A</ci>
        <apply>
         <times></times>
         <ci>μ</ci>
         <ci>I</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{k+1}=\frac{(A-\mu I)^{-1}b_{k}}{C_{k}},
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>C<sub>k</sub></em> are some constants usually chosen as 

<math display="inline" id="Inverse_iteration:2">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>C</mi>
     <mi>k</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>A</mi>
         <mo>-</mo>
         <mrow>
          <mi>μ</mi>
          <mi>I</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <msub>
       <mi>b</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mo>∥</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <ci>A</ci>
        <apply>
         <times></times>
         <ci>μ</ci>
         <ci>I</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{k}=\|(A-\mu I)^{-1}b_{k}\|.
  </annotation>
 </semantics>
</math>

 Since eigenvectors are defined up to multiplication by constant, the choice of <em>C<sub>k</sub></em> can be arbitrary in theory; practical aspects of the choice of 

<math display="inline" id="Inverse_iteration:3">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{k}
  </annotation>
 </semantics>
</math>

 are discussed below.</p>

<p>At every iteration, the vector <em>b</em><sub><em>k</em></sub> is multiplied by the inverse of the matrix 

<math display="inline" id="Inverse_iteration:4">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>A</mi>
    <mo>-</mo>
    <mrow>
     <mi>μ</mi>
     <mi>I</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>μ</ci>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A-\mu I)
  </annotation>
 </semantics>
</math>

 and normalized. It is exactly the same formula as in the <a href="power_method" title="wikilink">power method</a>, except replacing the matrix <em>A</em> by 

<math display="inline" id="Inverse_iteration:5">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>-</mo>
      <mrow>
       <mi>μ</mi>
       <mi>I</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <minus></minus>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>μ</ci>
      <ci>I</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A-\mu I)^{-1}.
  </annotation>
 </semantics>
</math>

 The closer the approximation 

<math display="inline" id="Inverse_iteration:6">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 to the eigenvalue is chosen, the faster the algorithm converges; however, incorrect choice of 

<math display="inline" id="Inverse_iteration:7">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 can lead to slow convergence or to the convergence to an eigenvector other than the one desired. In practice, the method is used when a good approximation for the eigenvalue is known, and hence one needs only few (quite often just one) iterations.</p>
<h2 id="theory-and-convergence">Theory and convergence</h2>

<p>The basic idea of the <a href="power_iteration" title="wikilink">power iteration</a> is choosing an initial vector <em>b</em> (either an <a class="uri" href="eigenvector" title="wikilink">eigenvector</a> approximation or a <a class="uri" href="random" title="wikilink">random</a> vector) and iteratively calculating 

<math display="inline" id="Inverse_iteration:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>b</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mn>2</mn>
    </msup>
    <mi>b</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mn>3</mn>
    </msup>
    <mi>b</mi>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>b</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>b</ci>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ab,A^{2}b,A^{3}b,...
  </annotation>
 </semantics>
</math>

. Except for a set of zero <a href="Measure_(mathematics)" title="wikilink">measure</a>, for any initial vector, the result will converge to an <a class="uri" href="eigenvector" title="wikilink">eigenvector</a> corresponding to the dominant <a class="uri" href="eigenvalue" title="wikilink">eigenvalue</a>.</p>

<p>The inverse iteration does the same for the matrix 

<math display="inline" id="Inverse_iteration:9">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mo>-</mo>
     <mrow>
      <mi>μ</mi>
      <mi>I</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <minus></minus>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>μ</ci>
      <ci>I</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A-\mu I)^{-1}
  </annotation>
 </semantics>
</math>

, so it converges to eigenvector corresponding to the dominant eigenvalue of the matrix 

<math display="inline" id="Inverse_iteration:10">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mo>-</mo>
     <mrow>
      <mi>μ</mi>
      <mi>I</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <minus></minus>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>μ</ci>
      <ci>I</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A-\mu I)^{-1}
  </annotation>
 </semantics>
</math>

. Eigenvalues of this matrix are 

<math display="inline" id="Inverse_iteration:11">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mn>1</mn>
       </msub>
       <mo>-</mo>
       <mi>μ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mi>n</mi>
       </msub>
       <mo>-</mo>
       <mi>μ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>μ</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>n</ci>
      </apply>
      <ci>μ</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda_{1}-\mu)^{-1},...,(\lambda_{n}-\mu)^{-1},
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Inverse_iteration:12">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{i}
  </annotation>
 </semantics>
</math>

 are eigenvalues of <em>A</em>. The largest of these numbers corresponds to the smallest of 

<math display="inline" id="Inverse_iteration:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>λ</mi>
       <mn>1</mn>
      </msub>
      <mo>-</mo>
      <mi>μ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>λ</mi>
       <mi>n</mi>
      </msub>
      <mo>-</mo>
      <mi>μ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>μ</ci>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <ci>n</ci>
     </apply>
     <ci>μ</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda_{1}-\mu),...,(\lambda_{n}-\mu).
  </annotation>
 </semantics>
</math>

 It is obvious that the eigenvectors of <em>A</em> and of 

<math display="inline" id="Inverse_iteration:14">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mo>-</mo>
     <mrow>
      <mi>μ</mi>
      <mi>I</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <minus></minus>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>μ</ci>
      <ci>I</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A-\mu I)^{-1}
  </annotation>
 </semantics>
</math>

 are the same.</p>

<p><strong>Conclusion</strong>: The method converges to the eigenvector of the matrix <em>A</em> corresponding to the closest eigenvalue to 

<math display="inline" id="Inverse_iteration:15">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu.
  </annotation>
 </semantics>
</math>

</p>

<p>In particular taking 

<math display="inline" id="Inverse_iteration:16">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>μ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu=0
  </annotation>
 </semantics>
</math>

 we see that 

<math display="inline" id="Inverse_iteration:17">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mi>k</mi>
    </mrow>
   </msup>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <apply>
      <minus></minus>
      <ci>k</ci>
     </apply>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A)^{-k}b
  </annotation>
 </semantics>
</math>

 converges to the eigenvector corresponding to the eigenvalue of <em>A</em> with the smallest absolute value.</p>
<h3 id="speed-of-convergence">Speed of convergence</h3>

<p>Let us analyze the <a href="rate_of_convergence" title="wikilink">rate of convergence</a> of the method.</p>

<p>The <a href="power_method" title="wikilink">power method</a> is known to <a href="Rate_of_convergence#Convergence_speed_for_iterative_methods" title="wikilink">converge linearly</a> to the limit, more precisely:</p>

<p>

<math display="inline" id="Inverse_iteration:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Distance</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>b</mi>
       <mi>ideal</mi>
      </msup>
      <mo>,</mo>
      <msubsup>
       <mi>b</mi>
       <mrow>
        <mpadded width="+3.3pt">
         <mi>Power</mi>
        </mpadded>
        <mi>Method</mi>
       </mrow>
       <mi>k</mi>
      </msubsup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo>(</mo>
      <msup>
       <mrow>
        <mo>|</mo>
        <mfrac>
         <msub>
          <mi>λ</mi>
          <mi>subdominant</mi>
         </msub>
         <msub>
          <mi>λ</mi>
          <mi>dominant</mi>
         </msub>
        </mfrac>
        <mo>|</mo>
       </mrow>
       <mi>k</mi>
      </msup>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Distance</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <ci>ideal</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <times></times>
        <ci>Power</ci>
        <ci>Method</ci>
       </apply>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <ci>subdominant</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <ci>dominant</ci>
        </apply>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Distance}(b^{\mathrm{ideal}},b^{k}_{\mathrm{Power~{}Method}})=O\left(%
\left|\frac{\lambda_{\mathrm{subdominant}}}{\lambda_{\mathrm{dominant}}}\right%
|^{k}\right),
  </annotation>
 </semantics>
</math>

</p>

<p>hence for the inverse iteration method similar result sounds as:</p>

<p>

<math display="inline" id="Inverse_iteration:19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Distance</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>b</mi>
       <mi>ideal</mi>
      </msup>
      <mo>,</mo>
      <msubsup>
       <mi>b</mi>
       <mrow>
        <mpadded width="+3.3pt">
         <mi>Inverse</mi>
        </mpadded>
        <mi>iteration</mi>
       </mrow>
       <mi>k</mi>
      </msubsup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo>(</mo>
      <msup>
       <mrow>
        <mo>|</mo>
        <mfrac>
         <mrow>
          <mi>μ</mi>
          <mo>-</mo>
          <msub>
           <mi>λ</mi>
           <mrow>
            <mpadded width="+3.3pt">
             <mi>closest</mi>
            </mpadded>
            <mpadded width="+3.3pt">
             <mi>to</mi>
            </mpadded>
            <mi>μ</mi>
           </mrow>
          </msub>
         </mrow>
         <mrow>
          <mi>μ</mi>
          <mo>-</mo>
          <msub>
           <mi>λ</mi>
           <mrow>
            <mpadded width="+3.3pt">
             <mi>second</mi>
            </mpadded>
            <mpadded width="+3.3pt">
             <mi>closest</mi>
            </mpadded>
            <mpadded width="+3.3pt">
             <mi>to</mi>
            </mpadded>
            <mi>μ</mi>
           </mrow>
          </msub>
         </mrow>
        </mfrac>
        <mo>|</mo>
       </mrow>
       <mi>k</mi>
      </msup>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Distance</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <ci>ideal</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <times></times>
        <ci>Inverse</ci>
        <ci>iteration</ci>
       </apply>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <divide></divide>
        <apply>
         <minus></minus>
         <ci>μ</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>λ</ci>
          <apply>
           <times></times>
           <ci>closest</ci>
           <ci>to</ci>
           <ci>μ</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>μ</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>λ</ci>
          <apply>
           <times></times>
           <ci>second</ci>
           <ci>closest</ci>
           <ci>to</ci>
           <ci>μ</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Distance}(b^{\mathrm{ideal}},b^{k}_{\mathrm{Inverse~{}iteration}})=O%
\left(\left|\frac{\mu-\lambda_{\mathrm{closest~{}to~{}}\mu}}{\mu-\lambda_{%
\mathrm{second~{}closest~{}to~{}}\mu}}\right|^{k}\right).
  </annotation>
 </semantics>
</math>

</p>

<p>This is a key formula for understanding the method's convergence. It shows that if 

<math display="inline" id="Inverse_iteration:20">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 is chosen close enough to some eigenvalue 

<math display="inline" id="Inverse_iteration:21">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

, for example 

<math display="inline" id="Inverse_iteration:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>μ</mi>
    <mo>-</mo>
    <mi>λ</mi>
   </mrow>
   <mo>=</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>μ</ci>
     <ci>λ</ci>
    </apply>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu-\lambda=\epsilon
  </annotation>
 </semantics>
</math>

 each iteration will improve the accuracy 

<math display="inline" id="Inverse_iteration:23">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>ϵ</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>/</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>λ</mi>
      <mo>+</mo>
      <mi>ϵ</mi>
     </mrow>
     <mo>-</mo>
     <msub>
      <mi>λ</mi>
      <mrow>
       <mpadded width="+3.3pt">
        <mi>closest</mi>
       </mpadded>
       <mpadded width="+3.3pt">
        <mi>to</mi>
       </mpadded>
       <mi>λ</mi>
      </mrow>
     </msub>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <abs></abs>
     <ci>ϵ</ci>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <ci>λ</ci>
       <ci>ϵ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <apply>
        <times></times>
        <ci>closest</ci>
        <ci>to</ci>
        <ci>λ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\epsilon|/|\lambda+\epsilon-\lambda_{\mathrm{closest~{}to~{}}\lambda}|
  </annotation>
 </semantics>
</math>

 times. (We use that for small enough 

<math display="inline" id="Inverse_iteration:24">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 "closest to 

<math display="inline" id="Inverse_iteration:25">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

" and "closest to 

<math display="inline" id="Inverse_iteration:26">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

" is the same.) For small enough 

<math display="inline" id="Inverse_iteration:27">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>ϵ</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\epsilon|
  </annotation>
 </semantics>
</math>

 it is approximately the same as 

<math display="inline" id="Inverse_iteration:28">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>ϵ</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>/</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>λ</mi>
     <mo>-</mo>
     <msub>
      <mi>λ</mi>
      <mrow>
       <mpadded width="+3.3pt">
        <mi>closest</mi>
       </mpadded>
       <mpadded width="+3.3pt">
        <mi>to</mi>
       </mpadded>
       <mi>λ</mi>
      </mrow>
     </msub>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <abs></abs>
     <ci>ϵ</ci>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <ci>λ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <apply>
        <times></times>
        <ci>closest</ci>
        <ci>to</ci>
        <ci>λ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\epsilon|/|\lambda-\lambda_{\mathrm{closest~{}to~{}}\lambda}|
  </annotation>
 </semantics>
</math>

. Hence if one is able to find 

<math display="inline" id="Inverse_iteration:29">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

, such the 

<math display="inline" id="Inverse_iteration:30">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 will be small enough, then very few iterations may be satisfactory.</p>
<h3 id="complexity">Complexity</h3>

<p>The inverse iteration algorithm requires solving a <a href="System_of_linear_equations" title="wikilink">linear system</a> or calculation of the inverse matrix. For non-structured matrices (not sparse, not Toeplitz,...) this requires 

<math display="inline" id="Inverse_iteration:31">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3})
  </annotation>
 </semantics>
</math>

 operations.</p>
<h2 id="implementation-options">Implementation options</h2>

<p>The method is defined by the formula:</p>

<p>

<math display="block" id="Inverse_iteration:32">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>b</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>A</mi>
         <mo>-</mo>
         <mrow>
          <mi>μ</mi>
          <mi>I</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <msub>
       <mi>b</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <msub>
      <mi>C</mi>
      <mi>k</mi>
     </msub>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <ci>A</ci>
        <apply>
         <times></times>
         <ci>μ</ci>
         <ci>I</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{k+1}=\frac{(A-\mu I)^{-1}b_{k}}{C_{k}},
  </annotation>
 </semantics>
</math>

</p>

<p>There are, however, multiple options for its implementation.</p>
<h3 id="calculate-inverse-matrix-or-solve-system-of-linear-equations">Calculate inverse matrix or solve system of linear equations</h3>

<p>We can rewrite the formula in the following way:</p>

<p>

<math display="block" id="Inverse_iteration:33">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mo>-</mo>
       <mrow>
        <mi>μ</mi>
        <mi>I</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>b</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <msub>
      <mi>b</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>C</mi>
      <mi>k</mi>
     </msub>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>A</ci>
      <apply>
       <times></times>
       <ci>μ</ci>
       <ci>I</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A-\mu I)b_{k+1}=\frac{b_{k}}{C_{k}},
  </annotation>
 </semantics>
</math>

</p>

<p>emphasizing that to find the next approximation 

<math display="inline" id="Inverse_iteration:34">
 <semantics>
  <msub>
   <mi>b</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>b</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{k+1}
  </annotation>
 </semantics>
</math>

 we may solve a system of linear equations. There are two options: one may choose an algorithm that solves a linear system, or one may calculate the inverse 

<math display="inline" id="Inverse_iteration:35">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mo>-</mo>
     <mrow>
      <mi>μ</mi>
      <mi>I</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <minus></minus>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>μ</ci>
      <ci>I</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A-\mu I)^{-1}
  </annotation>
 </semantics>
</math>

 and then apply it to the vector. Both options have complexity <em>O(n<sup>3</sup>)</em>, the exact number depends on the chosen method.</p>

<p>The choice depends also on the number of iterations. Naively, if at each iteration one solves a linear system, the complexity will be <em>k*O(n<sup>3</sup>)</em>, where <em>k</em> is number of iterations; similarly, calculating the inverse matrix and applying it at each iteration is of complexity <em>k*O(n<sup>3</sup>)</em>. Note, however, that if the eigenvalue estimate 

<math display="inline" id="Inverse_iteration:36">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 remains constant, then we may reduce the complexity to <em>O(n<sup>3</sup>) + k*O(n<sup>2</sup>)</em> with either method. Calculating the inverse matrix once, and storing it to apply at each iteration is of complexity <em>O(n<sup>3</sup>) + k*O(n<sup>2</sup>)</em>. Storing an <a href="LU_decomposition" title="wikilink">LU decomposition</a> of 

<math display="inline" id="Inverse_iteration:37">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>A</mi>
    <mo>-</mo>
    <mrow>
     <mi>μ</mi>
     <mi>I</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>μ</ci>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A-\mu I)
  </annotation>
 </semantics>
</math>

 and using <a href="Triangular_matrix#Forward_and_back_substitution" title="wikilink">forward and back substitution</a> to solve the system of equations at each iteration is also of complexity <em>O(n<sup>3</sup>) + k*O(n<sup>2</sup>)</em>.</p>

<p>Inverting the matrix will typically have a greater initial cost, but lower cost at each iteration. Conversely, solving systems of linear equations will typically have a lesser initial cost, but require more operations for each iteration.</p>
<h3 id="tridiagonalization-hessenberg-form">Tridiagonalization, <a href="Hessenberg_form" title="wikilink">Hessenberg form</a></h3>

<p>If it is necessary to perform many iterations (or few iterations, but for many eigenvectors), then it might be wise to bring the matrix to the upper <a href="Hessenberg_form" title="wikilink">Hessenberg form</a> first (for symmetric matrix this will be <a href="tridiagonal_matrix" title="wikilink">tridiagonal form</a>). Which costs 

<math display="inline" id="Inverse_iteration:38">
 <semantics>
  <mrow>
   <mrow>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mfrac>
        <mn>10</mn>
        <mn>3</mn>
       </mfrac>
      </mtd>
     </mtr>
    </mtable>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>n</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <apply>
        <divide></divide>
        <cn type="integer">10</cn>
        <cn type="integer">3</cn>
       </apply>
      </matrixrow>
     </matrix>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{matrix}\frac{10}{3}\end{matrix}n^{3}+O(n^{2})
  </annotation>
 </semantics>
</math>

 arithmetic operations using a technique based on <a href="Householder_transformation" title="wikilink">Householder reduction</a>), with a finite sequence of orthogonal similarity transforms, somewhat like a two-sided QR decomposition.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> (For QR decomposition, the Householder rotations are multiplied only on the left, but for the Hessenberg case they are multiplied on both left and right.) For <a href="symmetric_matrix" title="wikilink">symmetric matrices</a> this procedure costs 

<math display="inline" id="Inverse_iteration:39">
 <semantics>
  <mrow>
   <mrow>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mfrac>
        <mn>4</mn>
        <mn>3</mn>
       </mfrac>
      </mtd>
     </mtr>
    </mtable>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>n</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <apply>
        <divide></divide>
        <cn type="integer">4</cn>
        <cn type="integer">3</cn>
       </apply>
      </matrixrow>
     </matrix>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{matrix}\frac{4}{3}\end{matrix}n^{3}+O(n^{2})
  </annotation>
 </semantics>
</math>

 arithmetic operations using a technique based on Householder reduction.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>Solution of the system of linear equations for the <a href="tridiagonal_matrix" title="wikilink">tridiagonal matrix</a> costs <em>O(n)</em> operations, so the complexity grows like <em>O(n<sup>3</sup>)+k*O(n)</em>, where <em>k</em> is the iteration number, which is better than for the direct inversion. However for few iterations such transformation may not be practical.</p>

<p>Also transformation to the <a href="Hessenberg_form" title="wikilink">Hessenberg form</a> involves square roots and the division operation, which are not universally supported by hardware.</p>
<h3 id="choice-of-the-normalization-constant-ck">Choice of the normalization constant <em>C<sub>k</sub></em></h3>

<p>On general purpose processors (e.g. produced by Intel) the execution time of addition, multiplication and division is approximately equal. But on embedded and/or low energy consuming hardware (<a href="digital_signal_processor" title="wikilink">digital signal processors</a>, <a class="uri" href="FPGA" title="wikilink">FPGA</a>, <a href="Application-specific_integrated_circuit" title="wikilink">ASIC</a>) division may not be supported by hardware, and so should be avoided. Choosing <em>C<sub>k</sub>=2<sup>n<sub>k</sub></sup></em> allows fast division without explicit hardware support, as division by a power of 2 may be implemented as either a <a href="Bitwise_operation#Bit_shifts" title="wikilink">bit shift</a> (for <a href="fixed-point_arithmetic" title="wikilink">fixed-point arithmetic</a>) or subtraction of <em>k</em> from the exponent (for <a href="Floating_point" title="wikilink">floating-point arithmetic</a>).</p>

<p>When implementing the algorithm using <a href="fixed-point_arithmetic" title="wikilink">fixed-point arithmetic</a>, the choice of the constant <em>C<sub>k</sub></em> is especially important. Small values will lead to fast growth of the norm of <em>b<sub>k</sub></em> and to <a href="Integer_overflow" title="wikilink">overflow</a>; large values of <em>C<sub>k</sub></em> will cause the vector <em>b<sub>k</sub></em> to tend toward zero.</p>
<h2 id="usage">Usage</h2>

<p>The main application of the method is the situation when an approximation to an eigenvalue is found and one needs to find the corresponding approximate eigenvector. In such situation the inverse iteration is the main and probably the only method to use. So typically the method is used in combination with some other methods which allows to find approximate eigenvalues: the standard example is the <a href="bisection_eigenvalue_algorithm" title="wikilink">bisection eigenvalue algorithm</a>, another example is the <a href="Rayleigh_quotient_iteration" title="wikilink">Rayleigh quotient iteration</a> which is actually the same inverse iteration with the choice of the approximate eigenvalue as the <a href="Rayleigh_quotient" title="wikilink">Rayleigh quotient</a> corresponding to the vector obtained on the previous step of the iteration.</p>

<p>There are some situations where the method can be used by itself, however they are quite marginal.</p>

<p>Dominant eigenvector. The dominant eigenvalue can be easily estimated for any matrix. For any <a href="Matrix_norm#Induced_norm" title="wikilink">induced norm</a> it is true that 

<math display="inline" id="Inverse_iteration:40">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mi>A</mi>
     <mo>∥</mo>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>λ</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <ci>A</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>λ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\|A\right\|\geq|\lambda|,
  </annotation>
 </semantics>
</math>

 for any eigenvalue 

<math display="inline" id="Inverse_iteration:41">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

. So taking the norm of the matrix as an approximate eigenvalue one can see that the method will converge to the dominant eigenvector.</p>

<p>Estimates based on statistics. In some real-time applications one needs to find eigenvectors for matrices with a speed may be millions matrices per second. In such applications typically the statistics of matrices is known in advance and one can take as approximate eigenvalue the average eigenvalue for some large matrix sample, or better one calculates the mean ratio of the eigenvalue to the trace or the norm of the matrix and eigenvalue is estimated as trace or norm multiplied on the average value the their ratio. Clearly such method can be used with much care and only in situations when the mistake in calculations is allowed. Actually such idea can be combined with other methods to avoid too big errors.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Power_iteration" title="wikilink">Power iteration</a></li>
<li><a href="Rayleigh_quotient_iteration" title="wikilink">Rayleigh quotient iteration</a></li>
<li><a href="List_of_numerical_analysis_topics#Eigenvalue_algorithms" title="wikilink">List of eigenvalue algorithms</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.physics.arizona.edu/~restrepo/475A/Notes/sourcea/node81.html">Inverse Iteration to find eigenvectors</a>, physics.arizona.edu</li>
<li><a href="http://math.fullerton.edu/mathews/n2003/PowerMethodMod.html">The Power Method for Eigenvectors</a>, math.fullerton.edu</li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_linear_algebra" title="wikilink">Category:Numerical linear algebra</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Ernst Pohlhausen, <em>Berechnung der Eigenschwingungen statisch-bestimmter Fachwerke</em>, ZAMM - Zeitschrift für Angewandte Mathematik und Mechanik 1, 28-42 (1921).<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3">Lloyd N. Trefethen and David Bau, <em>Numerical Linear Algebra</em> (SIAM, 1997).<a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"></li>
</ol>
</section>
</body>
</html>
