<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="97">Programming Computable Functions</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Programming Computable Functions</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, <strong>Programming Computable Functions</strong>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> or <strong>PCF</strong>, is a <a href="type_system" title="wikilink">typed</a> <a href="Functional_programming" title="wikilink">functional language</a> introduced in an unpublished 1969 manuscript by <a href="Dana_Scott" title="wikilink">Dana Scott</a>. It can be considered to be an extended version of the <a href="typed_lambda_calculus" title="wikilink">typed lambda calculus</a> or a simplified version of modern typed functional languages such as <a href="ML_programming_language" title="wikilink">ML</a>.</p>

<p>A <a href="fully_abstract" title="wikilink">fully abstract</a> model for PCF was first given by <a href="Robin_Milner" title="wikilink">Milner</a> (1977). However, since Milner's model was essentially based on the syntax of PCF it was considered less than satisfactory (Ong, 1995). The first two fully abstract models not employing syntax were formulated during the 1990s. These models are based on <a href="game_semantics" title="wikilink">game semantics</a> (Hyland and Ong, 2000; Abramsky, Jagadeesan, and Malacaria, 2000) and <a href="Kripke_logical_relations" title="wikilink">Kripke logical relations</a> (O'Hearn and Riecke, 1995). For a time it was felt that neither of these models was completely satisfactory, since they were not effectively presentable. However, <a href="Ralph_Loader" title="wikilink">Ralph Loader</a> demonstrated that no effectively presentable fully abstract model could exist, since the question of program equivalence in the finitary fragment of PCF is not decidable.</p>
<h2 id="syntax">Syntax</h2>

<p>The <em>types</em> of PCF are inductively defined as</p>
<ul>
<li><strong>nat</strong> is a type</li>
<li>For types <em>σ</em> and <em>τ</em>, there is a type <em>σ</em> → <em>τ</em></li>
</ul>

<p>A <em>context</em> is a list of pairs <em>x : σ</em>, where <em>x</em> is a variable name and <em>σ</em> is a type, such that no variable name is duplicated. One then defines typing judgments of terms-in-context in the usual way for the following syntactical constructs:</p>
<ul>
<li>Variables (if <em>x : σ</em> is part of a context <em>Γ</em>, then <em>Γ</em> ⊢ <em>x</em> : <em>σ</em>)</li>
<li>Application (of a term of type <em>σ</em> → <em>τ</em> to a term of type <em>σ</em>)</li>
<li><a class="uri" href="λ-abstraction" title="wikilink">λ-abstraction</a></li>
<li>The <strong><a href="Fixed-point_combinator#Y_combinator" title="wikilink">Y</a></strong> fixed point combinator (making terms of type <em>σ</em> out of terms of type <em>σ</em> → <em>σ</em>)</li>
<li>The successor (<strong>succ</strong>) and predecessor (<strong>pred</strong>) operations on <strong>nat</strong> and the constant <strong>0</strong></li>
<li>The conditional <strong>if</strong> with the typing rule:</li>
</ul>

<p>

<math display="block" id="Programming_Computable_Functions:0">
 <semantics>
  <mfrac>
   <mrow>
    <mpadded width="+2.8pt">
     <mi mathvariant="normal">Γ</mi>
    </mpadded>
    <mo rspace="5.3pt">⊢</mo>
    <mpadded width="+2.8pt">
     <mi>t</mi>
    </mpadded>
    <mo>:</mo>
    <mrow>
     <mtext>𝐧𝐚𝐭</mtext>
     <mo rspace="22.5pt">,</mo>
     <mpadded width="+2.8pt">
      <mi mathvariant="normal">Γ</mi>
     </mpadded>
    </mrow>
    <mo rspace="5.3pt">⊢</mo>
    <mpadded width="+2.8pt">
     <msub>
      <mi>s</mi>
      <mn>0</mn>
     </msub>
    </mpadded>
    <mo>:</mo>
    <mrow>
     <mi>σ</mi>
     <mo rspace="22.5pt">,</mo>
     <mpadded width="+2.8pt">
      <mi mathvariant="normal">Γ</mi>
     </mpadded>
    </mrow>
    <mo rspace="5.3pt">⊢</mo>
    <mpadded width="+2.8pt">
     <msub>
      <mi>s</mi>
      <mn>1</mn>
     </msub>
    </mpadded>
    <mo>:</mo>
    <mi>σ</mi>
   </mrow>
   <mrow>
    <mpadded width="+2.8pt">
     <mi mathvariant="normal">Γ</mi>
    </mpadded>
    <mo rspace="5.3pt">⊢</mo>
    <mrow>
     <mtext>𝐢𝐟</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo>,</mo>
      <msub>
       <mi>s</mi>
       <mn>0</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>s</mi>
       <mn>1</mn>
      </msub>
      <mo rspace="5.3pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>:</mo>
    <mi>σ</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <share href="#.cmml">
      </share>
      <list>
       <mtext>nat</mtext>
       <ci>normal-Γ</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <share href="#.cmml">
      </share>
      <list>
       <ci>σ</ci>
       <ci>normal-Γ</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <share href="#.cmml">
      </share>
      <ci>σ</ci>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <vector>
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <cn type="integer">1</cn>
        </apply>
       </vector>
      </apply>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <share href="#.cmml">
      </share>
      <ci>σ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\Gamma\;\vdash\;t\;:\textbf{nat},\quad\quad\Gamma\;\vdash\;s_{0}\;:%
\sigma,\quad\quad\Gamma\;\vdash\;s_{1}\;:\sigma}{\Gamma\;\vdash\;\textbf{if}(t%
,s_{0},s_{1})\;:\sigma}
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd>(<strong>nat</strong>s will be interpreted as booleans here with a convention like zero denoting truth, and any other number denoting falsity)
</dd>
</dl>
<h2 id="semantics">Semantics</h2>
<h3 id="denotational-semantics">Denotational semantics</h3>

<p>A relatively straightforward semantics for the language is the <strong>Scott model</strong>. In this model,</p>
<ul>
<li>Types are interpreted as certain <a href="domain_theory" title="wikilink">domains</a>.
<ul>
<li>

<math display="inline" id="Programming_Computable_Functions:1">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="0.8pt" stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mtext>𝐧𝐚𝐭</mtext>
     <mo rspace="0.8pt" stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:=</mo>
   <msub>
    <mi>ℕ</mi>
    <mo>⊥</mo>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <mtext>nat</mtext>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℕ</ci>
     <csymbol cd="latexml">bottom</csymbol>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\![\textbf{nat}]\!]:=\mathbb{N}_{\bot}
  </annotation>
 </semantics>
</math>

 (the natural numbers with a bottom element adjoined, with the flat ordering)</li>
<li>

<math display="inline" id="Programming_Computable_Functions:2">
 <semantics>
  <mrow>
   <mo rspace="0.8pt" stretchy="false">[</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>σ</mi>
    <mo>→</mo>
    <mpadded width="+1.7pt">
     <mi>τ</mi>
    </mpadded>
    <mo rspace="0.8pt" stretchy="false">]</mo>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-[</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">σ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">τ</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-]</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\![\sigma\to\tau\,]\!]
  </annotation>
 </semantics>
</math>

 is interpreted as the domain of <a class="uri" href="Scott-continuous" title="wikilink">Scott-continuous</a> functions from 

<math display="inline" id="Programming_Computable_Functions:3">
 <semantics>
  <mrow>
   <mo rspace="0.8pt" stretchy="false">[</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>σ</mi>
    <mo rspace="0.8pt" stretchy="false">]</mo>
   </mrow>
   <mo rspace="4.2pt" stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\![\sigma]\!]\,
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Programming_Computable_Functions:4">
 <semantics>
  <mrow>
   <mo rspace="0.8pt" stretchy="false">[</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>τ</mi>
    <mo rspace="0.8pt" stretchy="false">]</mo>
   </mrow>
   <mo rspace="4.2pt" stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\![\tau]\!]\,
  </annotation>
 </semantics>
</math>

</li>
</ul></li>
</ul>
<ul>
<li>A context 

<math display="inline" id="Programming_Computable_Functions:5">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>σ</mi>
     <mn>1</mn>
    </msub>
    <mo rspace="5.3pt">,</mo>
    <mi mathvariant="normal">…</mi>
    <mo rspace="5.3pt">,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>:</mo>
   <msub>
    <mi>σ</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}:\sigma_{1},\;\dots,\;x_{n}:\sigma_{n}
  </annotation>
 </semantics>
</math>

 is interpreted as the product 

<math display="inline" id="Programming_Computable_Functions:6">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="0.8pt" stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>σ</mi>
      <mn>1</mn>
     </msub>
     <mo rspace="0.8pt" stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>×</mo>
   <mpadded width="+2.8pt">
    <mi mathvariant="normal">…</mi>
   </mpadded>
   <mo>×</mo>
   <mrow>
    <mo rspace="0.8pt" stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>σ</mi>
      <mi>n</mi>
     </msub>
     <mo rspace="0.8pt" stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\![\sigma_{1}]\!]\times\;\dots\;\times[\![\sigma_{n}]\!]
  </annotation>
 </semantics>
</math>

</li>
<li>Terms in context 

<math display="inline" id="Programming_Computable_Functions:7">
 <semantics>
  <mrow>
   <mpadded width="+2.8pt">
    <mi mathvariant="normal">Γ</mi>
   </mpadded>
   <mo rspace="5.3pt">⊢</mo>
   <mpadded width="+2.8pt">
    <mi>x</mi>
   </mpadded>
   <mo rspace="5.3pt">:</mo>
   <mi>σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <ci>normal-Γ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\;\vdash\;x\;:\;\sigma
  </annotation>
 </semantics>
</math>

 are interpreted as continuous functions 

<math display="inline" id="Programming_Computable_Functions:8">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="0.8pt" stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi mathvariant="normal">Γ</mi>
     <mo rspace="0.8pt" stretchy="false">]</mo>
    </mrow>
    <mo rspace="5.3pt" stretchy="false">]</mo>
   </mrow>
   <mo rspace="5.3pt">→</mo>
   <mrow>
    <mo rspace="0.8pt" stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>σ</mi>
     <mo rspace="0.8pt" stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>normal-Γ</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>σ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\![\Gamma]\!]\;\to\;[\![\sigma]\!]
  </annotation>
 </semantics>
</math>


<ul>
<li>Variable terms are interpreted as projections</li>
<li>Lambda abstraction and application are interpreted by making use of the <a href="cartesian_closed" title="wikilink">cartesian closed</a> structure of the category of domains and continuous functions</li>
<li><strong>Y</strong> is interpreted by taking the <a href="least_fixed_point" title="wikilink">least fixed point</a> of the argument</li>
</ul></li>
</ul>

<p>This model is not <a href="fully_abstract" title="wikilink">fully abstract</a> for PCF; but it is fully abstract for the language obtained by adding a <em><a href="parallel_or" title="wikilink">parallel or</a></em> operator to PCF (p. 293 in the Hyland and Ong 2000 reference below).</p>
<h2 id="notes">Notes</h2>
<references group="note">
</references>
<h2 id="references">References</h2>
<ul>
<li>{{ cite journal</li>
</ul>

<p><code>| first = Dana S.</code><br/>
<code>| last = Scott</code><br/>
<code>| authorlink = Dana Scott</code><br/>
<code>| title = A type-theoretic alternative to CUCH, ISWIM, OWHY</code><br/>
<code>| journal = </code><em><code>Unpublished</code> <code>manuscript</code></em><br/>
<code>| url = </code><a href="http://www.cs.cmu.edu/~kw/scans/scott93tcs.pdf"><code>http://www.cs.cmu.edu/~kw/scans/scott93tcs.pdf</code></a><br/>
<code>| year = 1969</code><br/>
<code>| ref = harv}} Republished in </code></p>
<ul>
<li>{{ cite journal</li>
</ul>

<p><code>| first = Gordon D.</code><br/>
<code>| last = Plotkin</code><br/>
<code>| authorlink = Gordon Plotkin</code><br/>
<code>| title = LCF considered to be a programming language</code><br/>
<code>| journal = Theoretical Computer Science</code><br/>
<code>| year = 1977</code><br/>
<code>| pages = 223–255</code><br/>
<code>| volume = 5</code><br/>
<code>| doi = 10.1016/0304-3975(77)90044-5</code><br/>
<code>| url = </code><a href="http://homepages.inf.ed.ac.uk/gdp/publications/LCF.pdf"><code>http://homepages.inf.ed.ac.uk/gdp/publications/LCF.pdf</code></a><br/>
<code>| ref = harv}}</code></p>
<ul>
<li></li>
<li>{{ cite journal</li>
</ul>

<p><code>| author = Abramsky, S., Jagadeesan, R., and Malacaria, P.</code><br/>
<code>| title = Full Abstraction for PCF</code><br/>
<code>| journal = Information and Computation</code><br/>
<code>| year= 2000</code><br/>
<code>| pages = 409–470</code><br/>
<code>| volume = 163</code><br/>
<code>| issue = 2</code><br/>
<code>| doi = 10.1006/inco.2000.2930}}</code></p>
<ul>
<li>{{ cite journal</li>
</ul>

<p><code>| author = Hyland, J. M. E. and Ong, C.-H. L.</code><br/>
<code>| title = On Full Abstraction for PCF</code><br/>
<code>| journal = Information and Computation</code><br/>
<code>| year= 2000</code><br/>
<code>| pages = 285–408</code><br/>
<code>| volume = 163</code><br/>
<code>| issue = 2</code><br/>
<code>| doi = 10.1006/inco.2000.2917}}</code></p>
<ul>
<li>{{ cite journal</li>
</ul>

<p><code>| author = O'Hearn, P. W. and Riecke, J. G</code><br/>
<code>| title = Kripke Logical Relations and PCF</code><br/>
<code>| journal = Information and Computation</code><br/>
<code>| year = 1995</code><br/>
<code>| pages = 107–116</code><br/>
<code>| volume = 120</code><br/>
<code>| issue = 1</code><br/>
<code>| doi = 10.1006/inco.1995.1103}}</code></p>
<ul>
<li>{{ cite journal</li>
</ul>

<p><code>| author = Loader, R.</code><br/>
<code>| title = Finitary PCF is not decidable</code><br/>
<code>| journal = Theoretical Computer Science</code><br/>
<code>| year= 2001</code><br/>
<code>| pages = 341–364</code><br/>
<code>| volume = 266</code><br/>
<code>| issue = 1-2</code><br/>
<code>| doi = 10.1016/S0304-3975(00)00194-8}}</code></p>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cs.bham.ac.uk/~mhe/papers/RNC3.pdf">Introduction to RealPCF</a></li>
<li><a href="http://www.cs.pomona.edu/classes/cs131/Parsers/parsePCF.sml">Lexer and Parser for PCF written in SML</a></li>
</ul>

<p>"</p>

<p><a href="Category:1977_in_computer_science" title="wikilink">Category:1977 in computer science</a> <a href="Category:Academic_programming_languages" title="wikilink">Category:Academic programming languages</a> <a href="Category:Educational_programming_languages" title="wikilink">Category:Educational programming languages</a> <a href="Category:Functional_languages" title="wikilink">Category:Functional languages</a> <a href="Category:Programming_language_theory" title="wikilink">Category:Programming language theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">"PCF is a programming language for computable functions, based on LCF, Scott’s logic of computable functions" . <em>Programming Computable Functions</em> is used by . It is also referred to as <em>Programming with Computable Functions</em> or <em>Programming language for Computable Functions</em>.<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
