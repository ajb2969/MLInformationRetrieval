   Elliptic Curve Digital Signature Algorithm      Elliptic Curve Digital Signature Algorithm   In cryptography , the Elliptic Curve Digital Signature Algorithm ( ECDSA ) offers a variant of the Digital Signature Algorithm (DSA) which uses elliptic curve cryptography .  Key and signature-size comparison to DSA  As with elliptic-curve cryptography in general, the bit size of the public key believed to be needed for ECDSA is about twice the size of the security level, in bits. For example, at a security level of 80 bits (meaning an attacker requires the equivalent of about    2  80     superscript  2  80    2^{80}   operations to find the private key) the size of a DSA public key is at least 1024 bits, whereas the size of an ECDSA public key would be 160 bits. On the other hand, the signature size is the same for both DSA and ECDSA    4  t      4  t    4t   bits, where   t   t   t   is the security level measured in bits, that is, about 320 bits for a security level of 80 bits.  Signature generation algorithm  Suppose Alice wants to send a signed message to Bob . Initially, they must agree on the curve parameters    (  CURVE  ,  G  ,  n  )     CURVE  G  n    (\textrm{CURVE},G,n)   . In addition to the field and equation of the curve, we need   G   G   G   , a base point of prime order on the curve;   n   n   n   is the multiplicative order of the point   G   G   G   .      Parameter        CURVE   the elliptic curve field and equation used     G   elliptic curve base point, a generator of the elliptic curve with large prime order n     n   integer order of G , means that     n  ×  G   =  O        n  G   O    n\times G=O        Alice creates a key pair, consisting of a private key integer    d  A     subscript  d  A    d_{A}   , randomly selected in the interval    [  1  ,   n  -  1   ]     1    n  1     [1,n-1]   ; and a public key curve point     Q  A   =    d  A   ×  G        subscript  Q  A      subscript  d  A   G     Q_{A}=d_{A}\times G   . We use   ×     \times   to denote elliptic curve point multiplication by a scalar .  For Alice to sign a message   m   m   m   , she follows these steps:   Calculate    e  =   HASH   (  m  )        e    HASH  m     e=\textrm{HASH}(m)   , where HASH is a cryptographic hash function , such as SHA-2 .  Let   z   z   z   be the    L  n     subscript  L  n    L_{n}   leftmost bits of   e   e   e   , where    L  n     subscript  L  n    L_{n}   is the bit length of the group order   n   n   n   .  Select a cryptographically secure random integer   k   k   k   from    [  1  ,   n  -  1   ]     1    n  1     [1,n-1]   .  Calculate the curve point     (   x  1   ,   y  1   )   =   k  ×  G         subscript  x  1    subscript  y  1      k  G     (x_{1},y_{1})=k\times G   .  Calculate    r  =     x  1    mod  n       r   modulo   subscript  x  1   n     r=x_{1}\,\bmod\,n   . If    r  =  0      r  0    r=0   , go back to step 3.  Calculate    s  =     k   -  1     (   z  +   r   d  A     )    mod  n       s   modulo     superscript  k    1      z    r   subscript  d  A      n     s=k^{-1}(z+rd_{A})\,\bmod\,n   . If    s  =  0      s  0    s=0   , go back to step 3.  The signature is the pair    (  r  ,  s  )     r  s    (r,s)   .   When computing   s   s   s   , the string   z   z   z   resulting from    HASH   (  m  )       HASH  m    \textrm{HASH}(m)   shall be converted to an integer. Note that   z   z   z   can be greater than   n   n   n   but not longer . 1  As the standard notes, it is crucial to select different   k   k   k   for different signatures, otherwise the equation in step 6 can be solved for    d  A     subscript  d  A    d_{A}   , the private key: Given two signatures    (  r  ,  s  )     r  s    (r,s)   and    (  r  ,   s  ′   )     r   superscript  s  normal-′     (r,s^{\prime})   , employing the same unknown   k   k   k   for different known messages   m   m   m   and    m  ′     superscript  m  normal-′    m^{\prime}   , an attacker can calculate   z   z   z   and    z  ′     superscript  z  normal-′    z^{\prime}   , and since     s  -   s  ′    =    k   -  1     (   z  -   z  ′    )          s   superscript  s  normal-′       superscript  k    1      z   superscript  z  normal-′       s-s^{\prime}=k^{-1}(z-z^{\prime})   (all operations in this paragraph are done modulo   n   n   n   ) the attacker can find    k  =    z  -   z  ′     s  -   s  ′         k      z   superscript  z  normal-′      s   superscript  s  normal-′       k=\frac{z-z^{\prime}}{s-s^{\prime}}   . Since    s  =    k   -  1     (   z  +   r   d  A     )        s     superscript  k    1      z    r   subscript  d  A        s=k^{-1}(z+rd_{A})   , the attacker can now calculate the private key     d  A   =     s  k   -  z   r        subscript  d  A         s  k   z   r     d_{A}=\frac{sk-z}{r}   . This implementation failure was used, for example, to extract the signing key used in the PlayStation 3 gaming-console. 2 Another way ECDSA signature may leak private keys is when   k   k   k   is generated by faulty random number generator . Such failure of RNG caused users of Android Bitcoin Wallet to lose their funds in August 2013. 3 To ensure that   k   k   k   is unique for each message one may bypass RNG completely and generate deterministic signatures by deriving   k   k   k   from both the message and the private key. 4  Signature verification algorithm  For Bob to authenticate Alice's signature, he must have a copy of her public-key curve point    Q  A     subscript  Q  A    Q_{A}   . Bob can verify    Q  A     subscript  Q  A    Q_{A}   is a valid curve point as follows:   Check that    Q  A     subscript  Q  A    Q_{A}   is not equal to the identity element   O   O   O   , and its coordinates are otherwise valid  Check that    Q  A     subscript  Q  A    Q_{A}   lies on the curve  Check that     n  ×   Q  A    =  O        n   subscript  Q  A    O    n\times Q_{A}=O      After that, Bob follows these steps:   Verify that   r   r   r   and   s   s   s   are integers in    [  1  ,   n  -  1   ]     1    n  1     [1,n-1]   . If not, the signature is invalid.  Calculate    e  =   HASH   (  m  )        e    HASH  m     e=\textrm{HASH}(m)   , where HASH is the same function used in the signature generation.  Let   z   z   z   be the    L  n     subscript  L  n    L_{n}   leftmost bits of   e   e   e   .  Calculate    w  =     s   -  1     mod  n       w   modulo   superscript  s    1    n     w=s^{-1}\,\bmod\,n   .  Calculate     u  1   =    z   w    mod  n        subscript  u  1    modulo    z  w   n     u_{1}=zw\,\bmod\,n   and     u  2   =    r   w    mod  n        subscript  u  2    modulo    r  w   n     u_{2}=rw\,\bmod\,n   .  Calculate the curve point     (   x  1   ,   y  1   )   =     u  1   ×  G   +    u  2   ×   Q  A           subscript  x  1    subscript  y  1         subscript  u  1   G      subscript  u  2    subscript  Q  A       (x_{1},y_{1})=u_{1}\times G+u_{2}\times Q_{A}   .  The signature is valid if    r  ≡    x  1      (   mod  n   )        r   annotated   subscript  x  1    pmod  n      r\equiv x_{1}\;\;(\mathop{{\rm mod}}n)   , invalid otherwise.   Note that using Straus's algorithm (also known as Shamir's trick), a sum of two scalar multiplications      u  1   ×  G   +    u  2   ×   Q  A           subscript  u  1   G      subscript  u  2    subscript  Q  A      u_{1}\times G+u_{2}\times Q_{A}   can be calculated faster than two scalar multiplications done independently. 5  Correctness of the algorithm  It is not immediately obvious why verification even functions correctly. To see why, denote as   C   C   C   the curve point computed in step 6 of verification,      C  =     u  1   ×  G   +    u  2   ×   Q  A         C       subscript  u  1   G      subscript  u  2    subscript  Q  A       C=u_{1}\times G+u_{2}\times Q_{A}     From the definition of the public key as     Q  A   =    d  A   ×  G        subscript  Q  A      subscript  d  A   G     Q_{A}=d_{A}\times G   ,      C  =     u  1   ×  G   +     u  2    d  A    ×  G        C       subscript  u  1   G        subscript  u  2    subscript  d  A    G      C=u_{1}\times G+u_{2}d_{A}\times G     Because elliptic curve scalar multiplication distributes over addition,      C  =    (    u  1   +    u  2    d  A     )   ×  G       C       subscript  u  1      subscript  u  2    subscript  d  A     G     C=(u_{1}+u_{2}d_{A})\times G     Expanding the definition of    u  1     subscript  u  1    u_{1}   and    u  2     subscript  u  2    u_{2}   from verification step 4,      C  =    (    z   s   -  1     +   r   d  A    s   -  1      )   ×  G       C        z   superscript  s    1       r   subscript  d  A    superscript  s    1      G     C=(zs^{-1}+rd_{A}s^{-1})\times G     Collecting the common term    s   -  1      superscript  s    1     s^{-1}   ,      C  =     (   z  +   r   d  A     )    s   -  1     ×  G       C        z    r   subscript  d  A      superscript  s    1     G     C=(z+rd_{A})s^{-1}\times G     Expanding the definition of   s   s   s   from signature step 6,      C  =     (   z  +   r   d  A     )     (   z  +   r   d  A     )    -  1      (   k   -  1    )    -  1     ×  G       C        z    r   subscript  d  A      superscript    z    r   subscript  d  A       1     superscript   superscript  k    1      1     G     C=(z+rd_{A})(z+rd_{A})^{-1}(k^{-1})^{-1}\times G     Since the inverse of an inverse is the original element, and the product of an element's inverse and the element is the identity, we are left with      C  =   k  ×  G       C    k  G     C=k\times G     From the definition of   r   r   r   , this is verification step 6.  This shows only that a correctly signed message will verify correctly; many other properties are required for a secure signature algorithm.  Security  In December 2010, a group calling itself fail0verflow announced recovery of the ECDSA private key used by Sony to sign software for the PlayStation 3 game console. However, this attack only worked because Sony did not properly implement the algorithm, because   k   k   k   was static instead of random. As pointed out in the Signature generation algorithm Section above, this makes    d  A     subscript  d  A    d_{A}   solvable and the entire algorithm useless. 6  On March 29, 2011, two researchers published an IACR paper 7 demonstrating that it is possible to retrieve a TLS private key of a server using OpenSSL that authenticates with Elliptic Curves DSA over a binary field via a timing attack . 8 The vulnerability was fixed in OpenSSL 1.0.0e. 9  In August 2013, it was revealed that bugs in some implementations of the Java class SecureRandom sometimes generated collisions in the k value. As discussed above, this allowed solution of the private key, in turn allowing stealing bitcoins from the containing wallet on Android app implementations, which use Java and rely on ECDSA to authenticate transactions. 10  This issue can be prevented by deterministic generation of k , as described by RFC 6979.  See also   Elliptic curve cryptography  EdDSA   Notes  References   Accredited Standards Committee X9 , American National Standard X9.62-2005, Public Key Cryptography for the Financial Services Industry, The Elliptic Curve Digital Signature Algorithm (ECDSA) , November 16, 2005.  Certicom Research, Standards for efficient cryptography, SEC 1: Elliptic Curve Cryptography , Version 2.0, May 21, 2009.  López, J. and Dahab, R. An Overview of Elliptic Curve Cryptography , Technical Report IC-00-10, State University of Campinas, 2000.  Daniel J. Bernstein, Pippenger's exponentiation algorithm , 2002.  Daniel R. L. Brown, Generic Groups, Collision Resistance, and ECDSA , Designs, Codes and Cryptography, 35 , 119–152, 2005. ePrint version  Ian F. Blake, Gadiel Seroussi, and Nigel P. Smart, editors, Advances in Elliptic Curve Cryptography , London Mathematical Society Lecture Note Series 317, Cambridge University Press, 2005.    External links   Digital Signature Standard; includes info on ECDSA   "  Category:Digital signature schemes  Category:Elliptic curve cryptography     NIST FIPS 186-4, July 2013, pp. 19 and 26 ↩  Console Hacking 2010 - PS3 Epic Fail , page 123–128 ↩  ↩  ↩  ↩  ↩  ↩  Vulnerability Note VU#536044 - OpenSSL leaks ECDSA private key through a remote timing attack ↩  ↩  ↩     