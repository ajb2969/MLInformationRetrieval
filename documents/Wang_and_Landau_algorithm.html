<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="537">Wang and Landau algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Wang and Landau algorithm</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>The <strong>Wang and Landau algorithm</strong>, proposed by Fugao Wang and <a href="David_P._Landau" title="wikilink">David P. Landau</a>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> is a <a href="Monte_Carlo_method" title="wikilink">Monte Carlo method</a> designed to calculate the <a href="density_of_states" title="wikilink">density of states</a> of a system. The method performs a non-markovian random walk to build the density of states by quickly visiting all the available energy spectrum. The Wang and Landau algorithm is an important method to obtain the density of states required to perform a <a href="multicanonical_ensemble" title="wikilink">multicanonical simulation</a>.</p>

<p>The Wang–Landau algorithm can be applied to any system which is characterized by a cost (or energy) function. For instance, it has been applied to the solution of numerical integrals<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and the folding of proteins.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The Wang-Landau Sampling is related to the <a class="uri" href="Metadynamics" title="wikilink">Metadynamics</a> algorithm.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="overview">Overview</h2>

<p>The Wang and Landau algorithm is used to obtain the <a href="density_of_states" title="wikilink">density of states</a> of a system characterized by a cost function. It uses a non-markovian <a href="stochastic_process" title="wikilink">stochastic process</a> which asymptotically converges to a <a href="multicanonical_ensemble" title="wikilink">multicanonical ensemble</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> (I.e. to a <a href="Metropolis-Hastings_algorithm" title="wikilink">Metropolis-Hastings algorithm</a> with sampling distribution inverse to the density of states.) The major consequence is that this sampling distribution leads to a simulation where the energy barriers are invisible. This means that the algorithm visits all the accessible states (favorable and less favorable) much faster than a metropolis algorithm.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="algorithm">Algorithm</h2>

<p>Consider a system defined on a phase space 

<math display="inline" id="Wang_and_Landau_algorithm:0">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

, and a cost function, E, (e.g. the energy), bounded on a spectrum 

<math display="inline" id="Wang_and_Landau_algorithm:1">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Γ</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>E</mi>
     <mi>min</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>E</mi>
     <mi>max</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <ci>E</ci>
     <ci>normal-Γ</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <interval closure="closed">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <min></min>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <max></max>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\in\Gamma=[E_{\min},E_{\max}]
  </annotation>
 </semantics>
</math>

, which has an associated density of states 

<math display="inline" id="Wang_and_Landau_algorithm:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>ρ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>E</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>E</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>ρ</ci>
     <ci>E</ci>
    </apply>
    <apply>
     <exp></exp>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>E</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(E)\equiv\exp(S(E))
  </annotation>
 </semantics>
</math>

, which is to be computed. Because Wang and Landau algorithm works in discrete spectra,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> the spectrum 

<math display="inline" id="Wang_and_Landau_algorithm:3">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

 is divided in N discrete values with a difference between them of 

<math display="inline" id="Wang_and_Landau_algorithm:4">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>


, such that</p>

<p>

<math display="block" id="Wang_and_Landau_algorithm:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>N</mi>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <msub>
       <mi>E</mi>
       <mi>max</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>E</mi>
       <mi>min</mi>
      </msub>
     </mrow>
     <mi mathvariant="normal">Δ</mi>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <max></max>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <min></min>
      </apply>
     </apply>
     <ci>normal-Δ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=\frac{E_{\max}-E_{\min}}{\Delta},
  </annotation>
 </semantics>
</math>

.</p>

<p>Given this discrete spectrum, the algorithm is initialized by:</p>
<ul>
<li>setting all entries of the entropy to zero, 

<math display="inline" id="Wang_and_Landau_algorithm:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>E</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>N</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <eq></eq>
     <ci>i</ci>
     <list>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
      <ci>normal-…</ci>
      <ci>N</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(E_{i})=0\ \ i=1,2,...,N
  </annotation>
 </semantics>
</math>

</li>
<li>initializing 

<math display="inline" id="Wang_and_Landau_algorithm:7">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>f</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=1
  </annotation>
 </semantics>
</math>

 and</li>
<li>initializing the system randomly, by putting in a random configuration 

<math display="inline" id="Wang_and_Landau_algorithm:8">
 <semantics>
  <mrow>
   <mi>𝒓</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>𝒓</ci>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{r}\in\Omega
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>The algorithm then performs a <a href="multicanonical_ensemble" title="wikilink">multicanonical ensemble</a> like simulation:<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> a <a href="Metropolis-Hastings_algorithm" title="wikilink">Metropolis-Hastings</a> random walk in the phase space of the system with a probability distribution given by 

<math display="inline" id="Wang_and_Landau_algorithm:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝒓</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>ρ</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>𝒓</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>S</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>E</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>𝒓</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>𝒓</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>ρ</ci>
      </apply>
      <apply>
       <times></times>
       <ci>E</ci>
       <ci>𝒓</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <exp></exp>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>S</ci>
        <apply>
         <times></times>
         <ci>E</ci>
         <ci>𝒓</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\boldsymbol{r})=1/\rho(E(\boldsymbol{r}))=\exp(-S(E(\boldsymbol{r})))
  </annotation>
 </semantics>
</math>


 and a probability of proposing a new state given by a probability distribution 

<math display="inline" id="Wang_and_Landau_algorithm:10">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝒓</mi>
    <mo>→</mo>
    <msup>
     <mi>𝒓</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">g</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝒓</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(\boldsymbol{r}\rightarrow\boldsymbol{r}^{\prime})
  </annotation>
 </semantics>
</math>

. A histogram 

<math display="inline" id="Wang_and_Landau_algorithm:11">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(E)
  </annotation>
 </semantics>
</math>

 of visited energies is stored. Like in the Metropolis-Hastings algorithm, a proposal-acceptance step is performed, and consists in (see <a href="Metropolis–Hastings_algorithm#Overview" title="wikilink">Metropolis–Hastings algorithm overview</a>):</p>
<ol>
<li>proposing a state 

<math display="inline" id="Wang_and_Landau_algorithm:12">
 <semantics>
  <mrow>
   <msup>
    <mi>𝒓</mi>
    <mo>′</mo>
   </msup>
   <mo>∈</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝒓</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{r}^{\prime}\in\Omega
  </annotation>
 </semantics>
</math>

 according to 

<math display="inline" id="Wang_and_Landau_algorithm:13">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝒓</mi>
    <mo>→</mo>
    <msup>
     <mi>𝒓</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">g</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝒓</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(\boldsymbol{r}\rightarrow\boldsymbol{r}^{\prime})
  </annotation>
 </semantics>
</math>

</li>
<li>accept/refuse the proposed state according to</li>
</ol>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Wang_and_Landau_algorithm:14">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝒓</mi>
    <mo>→</mo>
    <msup>
     <mi>𝒓</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>min</mi>
   <mrow>
    <mo>(</mo>
    <mn>1</mn>
    <mo>,</mo>
    <msup>
     <mi>e</mi>
     <mrow>
      <mi>S</mi>
      <mo>-</mo>
      <msup>
       <mi>S</mi>
       <mo>′</mo>
      </msup>
     </mrow>
    </msup>
    <mfrac>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>𝒓</mi>
        <mo>′</mo>
       </msup>
       <mo>→</mo>
       <mi>𝒓</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>𝒓</mi>
       <mo>→</mo>
       <msup>
        <mi>𝒓</mi>
        <mo>′</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝒓</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <min></min>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <ci>S</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>S</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">g</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝒓</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>normal-→</ci>
        <csymbol cd="unknown">r</csymbol>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">g</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">r</csymbol>
        <ci>normal-→</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝒓</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(\boldsymbol{r}\rightarrow\boldsymbol{r}^{\prime})=\min\left(1,e^{S-S^{\prime%
}}\frac{g(\boldsymbol{r}^{\prime}\rightarrow\boldsymbol{r})}{g(\boldsymbol{r}%
\rightarrow\boldsymbol{r}^{\prime})}\right)
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>where 

<math display="inline" id="Wang_and_Landau_algorithm:15">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>𝒓</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>𝒓</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=S(E(\boldsymbol{r}))
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Wang_and_Landau_algorithm:16">
 <semantics>
  <mrow>
   <msup>
    <mi>S</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>𝒓</mi>
        <mo>′</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝒓</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{\prime}=S(E(\boldsymbol{r}^{\prime}))
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
</dd>
</dl>

<p>After each proposal-acceptance step, the system transits to some value 

<math display="inline" id="Wang_and_Landau_algorithm:17">
 <semantics>
  <msub>
   <mi>E</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{i}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Wang_and_Landau_algorithm:18">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>E</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(E_{i})
  </annotation>
 </semantics>
</math>

 is incremented by one and the following update is performed:</p>

<p>

<math display="block" id="Wang_and_Landau_algorithm:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>E</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>←</mo>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>E</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi>f</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(E_{i})\leftarrow S(E_{i})+f
  </annotation>
 </semantics>
</math>

.</p>

<p>This is the crucial step of the algorithm, and it is what make this Wang and Landau algorithm non-markovian: the <a href="stochastic_process" title="wikilink">stochastic process</a> now depends on the history of the process. Hence the next time there is a proposal to a state with that particular energy 

<math display="inline" id="Wang_and_Landau_algorithm:20">
 <semantics>
  <msub>
   <mi>E</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{i}
  </annotation>
 </semantics>
</math>

, that proposal is now more likely refused; in this sense, the algorithm forces the system to visit all the spectrum equally.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> The consequence is that the histogram 

<math display="inline" id="Wang_and_Landau_algorithm:21">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(E)
  </annotation>
 </semantics>
</math>

 is more and more flat. However, this flatness depends on how well approximated the calculated entropy is to the exact entropy, which naturally depends on the value of f.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> To better and better approximate the exact entropy (and thus histogram's flatness), f is decreased after M proposal-acceptance steps:</p>

<p>

<math display="block" id="Wang_and_Landau_algorithm:22">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>←</mo>
   <mrow>
    <mi>f</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>f</ci>
    <apply>
     <divide></divide>
     <ci>f</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\leftarrow f/2
  </annotation>
 </semantics>
</math>

.</p>

<p>It was later shown that updating the f by constantly dividing by two can lead to saturation errors.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> A small modification to the Wang and Landau method to avoid this problem is to use the f factor proportional to 

<math display="inline" id="Wang_and_Landau_algorithm:23">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/t
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Wang_and_Landau_algorithm:24">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>


 is proportional to the number of steps of the simulation.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h2 id="test-system">Test system</h2>

<p>We want to obtain the DOS for the <a href="harmonic_oscillator" title="wikilink">harmonic oscillator</a> potential.</p>

<p>

<math display="block" id="Wang_and_Landau_algorithm:25">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(x)=x^{2},\,
  </annotation>
 </semantics>
</math>

</p>

<p>The analytical DOS is given by,</p>

<p>

<math display="block" id="Wang_and_Landau_algorithm:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>E</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mi>δ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>E</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <msub>
         <mi>E</mi>
         <mn>0</mn>
        </msub>
       </mrow>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mi>δ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>x</mi>
         <mn>2</mn>
        </msup>
        <mo>-</mo>
        <msub>
         <mi>E</mi>
         <mn>0</mn>
        </msub>
       </mrow>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>E</ci>
     </apply>
     <apply>
      <int></int>
      <apply>
       <times></times>
       <ci>δ</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>E</ci>
         <ci>x</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>E</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>d</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <int></int>
      <apply>
       <times></times>
       <ci>δ</ci>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>E</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>d</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(E)=\int\delta(E(x)-E_{0})\,dx=\int\delta(x^{2}-E_{0})\,dx,
  </annotation>
 </semantics>
</math>

</p>

<p>by performing the last integral we obtain,</p>

<p>

<math display="block" id="Wang_and_Landau_algorithm:27">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>E</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∝</mo>
    <msup>
     <mi>E</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </mrow>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proportional-to</csymbol>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>E</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>E</ci>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(E)\propto E^{-1/2},
  </annotation>
 </semantics>
</math>

</p>

<p>in general, the DOS for a multidimensional harmonic oscillator will be given by some power of <em>E</em>, the exponent will be a function of the dimension of the system.</p>

<p>Hence, we can use a simple harmonic oscillator potential to test the accuracy of Wang–Landau algorithm because we know already the analytic form of the density of states. Therefore we compare the density of states 

<math display="inline" id="Wang_and_Landau_algorithm:28">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ρ</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(E)
  </annotation>
 </semantics>
</math>

 obtained by the Wang–Landau algorithm with 

<math display="inline" id="Wang_and_Landau_algorithm:29">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(E)
  </annotation>
 </semantics>
</math>


.</p>
<h2 id="sample-code">Sample code</h2>

<p>The following is a sample code of the Wang–Landau algorithm in <a href="Python_(programming_language)" title="wikilink">Python</a>, considering that the proposal is such that</p>

<p>

<math display="block" id="Wang_and_Landau_algorithm:30">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>𝒙</mi>
       <mo>′</mo>
      </msup>
      <mo>→</mo>
      <mi>𝒙</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝒙</mi>
      <mo>→</mo>
      <msup>
       <mi>𝒙</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">g</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝒙</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>normal-→</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">g</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-→</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝒙</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{g(\boldsymbol{x}^{\prime}\rightarrow\boldsymbol{x})}{g(\boldsymbol{x}%
\rightarrow\boldsymbol{x}^{\prime})}=1
  </annotation>
 </semantics>
</math>

</p>

<p>The code considers a "system" which is the underlying system being studied.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">
currentEnergy <span class="op">=</span> system.randomConfiguration() <span class="co"># a random initial configuration</span>

<span class="cf">while</span> (f <span class="op">&gt;</span> epsilon):
    system.proposeConfiguration() <span class="co"># a proposed configuration is proposed</span>
    proposedEnergy <span class="op">=</span> system.proposedEnergy() <span class="co"># the energy of the proposed configuration computed</span>

    <span class="cf">if</span> (random() <span class="op">&lt;</span> exp(entropy[currentEnergy]<span class="op">-</span>entropy[proposedEnergy])):
        <span class="co"># if accepted, update the energy and the system:</span>
        currentEnergy <span class="op">=</span> proposedEnergy
        system.acceptProposedConfiguration()
    <span class="cf">else</span>:
        <span class="co"># if rejected</span>
        system.rejectProposedConfiguration()
    
    H[currentEnergy] <span class="op">+=</span> <span class="dv">1</span>
    entropy[currentEnergy] <span class="op">+=</span> f
    
    <span class="cf">if</span> (isFlat(H)): <span class="co"># isFlat tests whether the histogram is flat (e.g. 95% flatness)</span>
        H[:] <span class="op">=</span> <span class="dv">0</span>
        f <span class="op">*=</span> <span class="fl">0.5</span> <span class="co"># refine the f parameter</span></code></pre></div>
<h2 id="wang-and-landau-molecular-dynamics">Wang and Landau molecular dynamics</h2>

<p>It should be noted that the Wang and Landau algorithm can be implemented not only in a Monte Carlo simulation but also in a molecular dynamics simulation. To do this would require an escalation of the temperature of the system as follows:</p>

<p>

<math display="block" id="Wang_and_Landau_algorithm:31">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>T</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>E</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mrow>
         <mo>∂</mo>
         <mi>S</mi>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>E</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>/</mo>
       <mrow>
        <mo>∂</mo>
        <mi>E</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>E</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>E</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <partialdiff></partialdiff>
        <ci>S</ci>
       </apply>
       <ci>E</ci>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <ci>E</ci>
      </apply>
     </apply>
     <ci>T</ci>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{\prime}(E)\rightarrow(\partial S(E)/\partial E)T(E),
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Wang_and_Landau_algorithm:32">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(E)
  </annotation>
 </semantics>
</math>

 is the entropy of the system, 

<math display="inline" id="Wang_and_Landau_algorithm:33">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(E)
  </annotation>
 </semantics>
</math>

 the micro-canonical temperature and 

<math display="inline" id="Wang_and_Landau_algorithm:34">
 <semantics>
  <mrow>
   <msup>
    <mi>T</mi>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{\prime}(E)
  </annotation>
 </semantics>
</math>


 is the "scaled" temperature used in the simulation.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Markov_chain_Monte_Carlo" title="wikilink">Category:Markov chain Monte Carlo</a> <a href="Category:Statistical_algorithms" title="wikilink">Category:Statistical algorithms</a> <a href="Category:Computational_physics" title="wikilink">Category:Computational physics</a> <a href="Category:Articles_with_example_Python_code" title="wikilink">Category:Articles with example Python code</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5">Junghans, Christoph, Danny Perez, and Thomas Vogel. "Molecular Dynamics in the Multicanonical Ensemble: Equivalence of Wang–Landau Sampling, Statistical Temperature Molecular Dynamics, and Metadynamics." Journal of Chemical Theory and Computation 10.5 (2014): 1843-1847.<a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
</ol>
</section>
</body>

