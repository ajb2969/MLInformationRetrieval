<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1165">Lehmer–Schur algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Lehmer–Schur algorithm</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the <strong>Lehmer–Schur algorithm</strong> (named after <a href="Derrick_Henry_Lehmer" title="wikilink">Derrick Henry Lehmer</a> and <a href="Issai_Schur" title="wikilink">Issai Schur</a>) is a <a href="root-finding_algorithm" title="wikilink">root-finding algorithm</a> extending the idea of enclosing roots like in the one-dimensional <a href="bisection_method" title="wikilink">bisection method</a> to the complex plane. It uses the Schur–Cohn test to test increasingly smaller disks for the presence or absence of roots. Alternative methods like Wilf's algorithm apply different tests to differently shaped areas but keep the idea of descent by subdivision.</p>
<h2 id="the-lehmer-method">The Lehmer method</h2>

<p>The Schur–Cohn test described below allows to determine if a polynomial has no roots in the unit disk and in some cases to determine the exact number of roots. The method proposed by Lehmer test for the presence of roots of a polynomial 

<math display="inline" id="Lehmer–Schur_algorithm:0">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(z)
  </annotation>
 </semantics>
</math>

 on a collection of disks 

<math display="inline" id="Lehmer–Schur_algorithm:1">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mo>,</mo>
    <mi>ρ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <interval closure="open">
     <ci>c</ci>
     <ci>ρ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(c,\rho)
  </annotation>
 </semantics>
</math>

 in the complex plane by applying the Schur–Cohn test to the shifted and scaled polynomial 

<math display="inline" id="Lehmer–Schur_algorithm:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>c</mi>
      <mo>+</mo>
      <mrow>
       <mi>ρ</mi>
       <mi>z</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <plus></plus>
     <ci>c</ci>
     <apply>
      <times></times>
      <ci>ρ</ci>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(c+\rho z).
  </annotation>
 </semantics>
</math>

</p>

<p>Starting with <em>c</em>=0 and ρ=1, the radius in increased or decreased by factors of 2 until the annulus 

<math display="inline" id="Lehmer–Schur_algorithm:3">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mo>≤</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>z</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mn>2</mn>
    <mi>ρ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <ci>ρ</ci>
     <apply>
      <abs></abs>
      <ci>z</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>ρ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho\leq|z|\leq 2\rho
  </annotation>
 </semantics>
</math>

 is found to contain roots. Then the method is recursively applied to the 8 disks with center 

<math display="inline" id="Lehmer–Schur_algorithm:4">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>5</mn>
     <mn>3</mn>
    </mfrac>
    <mi>ρ</mi>
    <msup>
     <mi>e</mi>
     <mrow>
      <mi>i</mi>
      <mfrac>
       <mrow>
        <mi>k</mi>
        <mi>π</mi>
       </mrow>
       <mn>4</mn>
      </mfrac>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">5</cn>
      <cn type="integer">3</cn>
     </apply>
     <ci>ρ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>k</ci>
         <ci>π</ci>
        </apply>
        <cn type="integer">4</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{k}=\frac{5}{3}\rho e^{i\frac{k\pi}{4}}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Lehmer–Schur_algorithm:5">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mn>7</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <cn type="integer">7</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=0,1,\dots,7
  </annotation>
 </semantics>
</math>

 and initial radius 

<math display="inline" id="Lehmer–Schur_algorithm:6">
 <semantics>
  <mi>ρ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

 (originally 

<math display="inline" id="Lehmer–Schur_algorithm:7">
 <semantics>
  <mrow>
   <mfrac>
    <mn>5</mn>
    <mn>6</mn>
   </mfrac>
   <mi>ρ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">5</cn>
     <cn type="integer">6</cn>
    </apply>
    <ci>ρ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{5}{6}\rho
  </annotation>
 </semantics>
</math>

, which is slightly too small to cover the full annulus).</p>

<p>If after some recursions a small disk is found that contains only one root, this root is further approximated using <a href="Newton's_method" title="wikilink">Newton's method</a> and then the polynomial is deflated by splitting off the corresponding linear factor. After that, the whole procedure is restarted.</p>
<h3 id="schur-transformation-of-polynomials">Schur transformation of polynomials</h3>

<p>Consider, as before, a polynomial with complex coefficients</p>

<p>

<math display="block" id="Lehmer–Schur_algorithm:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>n</mi>
      </msub>
      <msup>
       <mi>z</mi>
       <mi>n</mi>
      </msup>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">…</mi>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mn>1</mn>
      </msub>
      <mi>z</mi>
     </mrow>
     <mo>+</mo>
     <msub>
      <mi>a</mi>
      <mn>0</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>z</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(z)=a_{n}z^{n}+\dots+a_{1}z+a_{0}.
  </annotation>
 </semantics>
</math>

 Denote the reverse conjugate polynomial as 

<math display="inline" id="Lehmer–Schur_algorithm:9">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>p</mi>
     <mo>*</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>z</mi>
     <mi>n</mi>
    </msup>
    <mover accent="true">
     <mi>p</mi>
     <mo stretchy="false">¯</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>z</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>z</mi>
     <mi>n</mi>
    </msup>
    <mover accent="true">
     <mi>p</mi>
     <mo>¯</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mover accent="true">
       <mi>z</mi>
       <mo stretchy="false">¯</mo>
      </mover>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <times></times>
      </apply>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <ci>normal-¯</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <ci>normal-¯</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-¯</ci>
        <ci>z</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{*}(z)=z^{n}\bar{p}(z^{-1})=z^{n}\overline{p}(\bar{z}^{-1})
  </annotation>
 </semantics>
</math>

. Then the Schur transform 

<math display="inline" id="Lehmer–Schur_algorithm:10">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Tp
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Lehmer–Schur_algorithm:11">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is the polynomial</p>

<p>

<math display="block" id="Lehmer–Schur_algorithm:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>T</mi>
       <mi>p</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mover accent="true">
        <mi>a</mi>
        <mo stretchy="false">¯</mo>
       </mover>
       <mn>0</mn>
      </msub>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>n</mi>
      </msub>
      <msup>
       <mi>p</mi>
       <mo>*</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>p</ci>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-¯</ci>
        <ci>a</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <ci>p</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <times></times>
      </apply>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Tp)(z)=\bar{a}_{0}p(z)-a_{n}p^{*}(z).
  </annotation>
 </semantics>
</math>

 Since the highest degree coefficients cancel, 

<math display="inline" id="Lehmer–Schur_algorithm:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>deg</mi>
    <mrow>
     <mi>T</mi>
     <mi>p</mi>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <mi>deg</mi>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="latexml">degree</csymbol>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">degree</csymbol>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \deg Tp<\deg p
  </annotation>
 </semantics>
</math>

, and the constant coefficient of 

<math display="inline" id="Lehmer–Schur_algorithm:14">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Tp
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Lehmer–Schur_algorithm:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>δ</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>T</mi>
       <mi>p</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>a</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo>-</mo>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>a</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>p</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{1}=(Tp)(0)=|a_{0}|^{2}-|a_{n}|^{2}.
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dt>Lemma</dt>
<dd>If 

<math display="inline" id="Lehmer–Schur_algorithm:16">
 <semantics>
  <mrow>
   <msub>
    <mi>δ</mi>
    <mn>1</mn>
   </msub>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>δ</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{1}>0
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Lehmer–Schur_algorithm:17">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lehmer–Schur_algorithm:18">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Tp
  </annotation>
 </semantics>
</math>

 have the same number of roots inside the unit disk and on the unit circle.
</dd>
</dl>
<dl>
<dd>If 

<math display="inline" id="Lehmer–Schur_algorithm:19">
 <semantics>
  <mrow>
   <msub>
    <mi>δ</mi>
    <mn>1</mn>
   </msub>
   <mo><</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>δ</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{1}<0
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Lehmer–Schur_algorithm:20">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 has the same number of roots inside the unit disk as 

<math display="inline" id="Lehmer–Schur_algorithm:21">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Tp
  </annotation>
 </semantics>
</math>

 (and 

<math display="inline" id="Lehmer–Schur_algorithm:22">
 <semantics>
  <msup>
   <mi>p</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>p</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{*}
  </annotation>
 </semantics>
</math>

) has outside, and both have the same number of roots on the unit circle.
</dd>
</dl>

<p>This result is a consequence of <a href="Rouché's_theorem" title="wikilink">Rouché's theorem</a>.</p>
<h3 id="schurcohn-test">Schur–Cohn test</h3>

<p>Apply the Schur transform repeatedly, 

<math display="inline" id="Lehmer–Schur_algorithm:23">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>T</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>p</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>T</mi>
       <mi>k</mi>
      </msup>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>p</ci>
    </apply>
    <apply>
     <times></times>
     <ci>T</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>T</ci>
       <ci>k</ci>
      </apply>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{k+1}p=T(T^{k}p)
  </annotation>
 </semantics>
</math>

, let <em>K</em> be the first index with 

<math display="inline" id="Lehmer–Schur_algorithm:24">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>T</mi>
     <mrow>
      <mi>K</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>p</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <apply>
       <plus></plus>
       <ci>K</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>p</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{K+1}p=0
  </annotation>
 </semantics>
</math>

. Denote 

<math display="inline" id="Lehmer–Schur_algorithm:25">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>deg</mi>
    <mrow>
     <msup>
      <mi>T</mi>
      <mi>k</mi>
     </msup>
     <mi>p</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">degree</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>T</ci>
       <ci>k</ci>
      </apply>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{k}=\deg T^{k}p
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Lehmer–Schur_algorithm:26">
 <semantics>
  <mrow>
   <msub>
    <mi>δ</mi>
    <mi>k</mi>
   </msub>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>δ</ci>
     <ci>k</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{k}>0
  </annotation>
 </semantics>
</math>

.</p>
<dl>
<dt>Theorem</dt>
<dd>If 

<math display="inline" id="Lehmer–Schur_algorithm:27">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 for all <em>k</em> = 1, 2, ..., <em>K</em>, then 

<math display="inline" id="Lehmer–Schur_algorithm:28">
 <semantics>
  <mrow>
   <msub>
    <mi>δ</mi>
    <mover accent="true">
     <mi>k</mi>
     <mo stretchy="false">¯</mo>
    </mover>
   </msub>
   <mo><</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>δ</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{\bar{k}}<0
  </annotation>
 </semantics>
</math>

 has no roots inside the unit disk.
</dd>
</dl>
<dl>
<dd>If 

<math display="inline" id="Lehmer–Schur_algorithm:29">
 <semantics>
  <mrow>
   <msub>
    <mi>δ</mi>
    <mi>k</mi>
   </msub>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>δ</ci>
     <ci>k</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{k}>0
  </annotation>
 </semantics>
</math>

 exactly once, 

<math display="inline" id="Lehmer–Schur_algorithm:30">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>≠</mo>
   <mover accent="true">
    <mi>k</mi>
    <mo stretchy="false">¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>k</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\neq\bar{k}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Lehmer–Schur_algorithm:31">
 <semantics>
  <msub>
   <mi>d</mi>
   <mover accent="true">
    <mi>k</mi>
    <mo stretchy="false">¯</mo>
   </mover>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{\bar{k}}
  </annotation>
 </semantics>
</math>

, then <em>p</em> has 

<math display="inline" id="Lehmer–Schur_algorithm:32">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>T</mi>
     <mover accent="true">
      <mi>k</mi>
      <mo stretchy="false">¯</mo>
     </mover>
    </msup>
    <mi>p</mi>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <msup>
     <mi>T</mi>
     <mi>K</mi>
    </msup>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <ci>p</ci>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <ci>K</ci>
     </apply>
     <ci>p</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{\bar{k}}p,\dots,T^{K}p
  </annotation>
 </semantics>
</math>

 roots inside the unit disk.
</dd>
</dl>

<p>The first follows from the root number preserving property of the Schur transform. For the second, 

<math display="inline" id="Lehmer–Schur_algorithm:33">
 <semantics>
  <mrow>
   <msup>
    <mi>T</mi>
    <mover accent="true">
     <mi>k</mi>
     <mo stretchy="false">¯</mo>
    </mover>
   </msup>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{\bar{k}}p
  </annotation>
 </semantics>
</math>

 have no roots inside the unit disk or on the unit circle. 

<math display="inline" id="Lehmer–Schur_algorithm:34">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mover accent="true">
     <mi>k</mi>
     <mo stretchy="false">¯</mo>
    </mover>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>deg</mi>
    <mrow>
     <msup>
      <mi>T</mi>
      <mover accent="true">
       <mi>k</mi>
       <mo stretchy="false">¯</mo>
      </mover>
     </msup>
     <mi>p</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">degree</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>T</ci>
       <apply>
        <ci>normal-¯</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{\bar{k}}=\deg T^{\bar{k}}p
  </annotation>
 </semantics>
</math>

 has 

<math display="inline" id="Lehmer–Schur_algorithm:35">
 <semantics>
  <mrow>
   <msup>
    <mi>T</mi>
    <mrow>
     <mover accent="true">
      <mi>k</mi>
      <mo stretchy="false">¯</mo>
     </mover>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <apply>
      <minus></minus>
      <apply>
       <ci>normal-¯</ci>
       <ci>k</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{\bar{k}-1}p
  </annotation>
 </semantics>
</math>

 roots outside the unit disk, so that 

<math display="inline" id="Lehmer–Schur_algorithm:36">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>T</mi>
     <mrow>
      <mover accent="true">
       <mi>k</mi>
       <mo stretchy="false">¯</mo>
      </mover>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
    </msup>
    <mi>p</mi>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mi>T</mi>
    <mi>p</mi>
   </mrow>
   <mo>,</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <apply>
       <minus></minus>
       <apply>
        <ci>normal-¯</ci>
        <ci>k</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>p</ci>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>p</ci>
    </apply>
    <ci>p</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{\bar{k}-2}p,\dots,Tp,p
  </annotation>
 </semantics>
</math>

 and thus also <span class="LaTeX">$T^{\bar k-2}p,\dots,Tp,p$</span> have the same number of roots inside the unit disk.</p>
<h2 id="variations-on-the-subdivision-idea">Variations on the subdivision idea</h2>
<h3 id="wilfs-global-bisection-algorithm">Wilf's global bisection algorithm</h3>

<p>The aim of this algorithm is to find the roots of a function of one complex variable inside any rectangular region of the function's <a href="Holomorphic_function" title="wikilink">holomorphicity</a> (<em>i.e.</em>, <a href="Analytic_function" title="wikilink">analyticity</a>).</p>

<p>The rectangle in question is quadrisected into four, <a href="Congruence_(geometry)" title="wikilink">congruent</a> quarter rectangles. For each quarter, the image of the boundary is a curve in the complex plane. The <a href="argument_principle" title="wikilink">argument principle</a> is then applied to this path to find the <a href="winding_number" title="wikilink">winding number</a> about the origin. Given that the function is <a href="Analytic_function" title="wikilink">analytic</a> within each of these quarters, a nonzero <a href="winding_number" title="wikilink">winding number</a> <em>N</em> (always an integer) identifies <em>N</em> zeros of the function inside the quarter in question by <a href="Rouché's_theorem" title="wikilink">Rouché's theorem</a>, each zero counted as many times as its <a href="Multiplicity_(mathematics)" title="wikilink">multiplicity</a>.</p>

<p>Analogously with the bisection method, the algorithm is then applied recursively to any quarter whose boundary has nonzero winding number to further refine the estimates of the zeros. The recursion is repeated until the zero-containing rectangles are either small enough that their centres give sufficiently accurate zero estimates or, alternatively, that another root-finding algorithm can be applied to the estimates to further refine them.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="https://svn.ece.lsu.edu/svn/dmk/trunk/benchmarks/simtools/scpu2k/gap/polystff.g">GAP Library, Lehrstuhl D fuer Mathematik, RWTH Aachen, Germany</a></li>
<li><a href="Jan_van_Leeuwen" title="wikilink">Jan van Leeuwen</a> (January 1979): <a href="http://www.cs.uu.nl/research/techreps/repo/CS-1979/1979-01.pdf">"On program efficiency and algebraic complexity"</a> (or: how to compute the Schur transform of a complex polynomial). technical report RUU-CS-79~1. Department of Computer Science, University of Utrecht</li>
</ul>

<p>"</p>

<p><a href="Category:Root-finding_algorithms" title="wikilink">Category:Root-finding algorithms</a></p>
</body>
</html>
