<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1621">Wheel factorization</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Wheel factorization</h1>
<hr/>

<p><mtpl></mtpl> <strong>Wheel factorization</strong> is a method for performing a preliminary reduction in the number of potential primes from the initial set of all natural numbers 2 and greater; possibly prior to passing the result list of potential primes to the <a href="Sieve_of_Eratosthenes" title="wikilink">Sieve of Eratosthenes</a> or other sieve that separates <a href="prime_number" title="wikilink">prime numbers</a> from <a href="Composite_number" title="wikilink">composites</a>, but may further be used as a prime number <strong>wheel sieve</strong> in its own right by recursively applying the factorization wheel generation <a class="uri" href="algorithm" title="wikilink">algorithm</a>. Much definitive work on wheel factorization, sieves using wheel factorization, and wheel sieve, was done by Paul Pritchard<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> in formulating a series of different algorithms. To demonstrate the use of the factorization wheel graphically, one starts by writing the natural numbers around circles as shown in the adjacent diagram. Prime numbers in the innermost circle have their multiples in similar positions as themselves in the other circles, forming spokes of primes and their multiples. Multiples of the prime numbers in the innermost circle form spokes of composite numbers in the outer circles.</p>
<h2 id="sample-graphical-procedure">Sample Graphical Procedure</h2>
<ol>
<li>Find the first few prime numbers to form the basis of the factorization wheel. They are known or perhaps determined from previous applications of smaller factorization wheels or by quickly finding them using the <a href="Sieve_of_Eratosthenes" title="wikilink">Sieve of Eratosthenes</a>.</li>
<li>Multiply the base prime numbers together to give the result <em>n</em> which is the circumference of the factorization wheel.</li>
<li>Write the numbers 1 to <em>n</em> in a circle. This will be the inner-most circle representing one rotation of the wheel.</li>
<li>From the numbers 1 to <em>n</em> in the innermost circle, strike off all multiples of the base primes from step one as applied in step 2. This composite number elimination can be accomplished either by use of a sieve such as the Sieve of Eratosthenes or as the result of applications of smaller factorization wheels.</li>
<li>Taking <em>x</em> to be the number of circles written so far, continue to write <em>xn</em> + 1 to <em>xn</em> + <em>n</em> in concentric circles around the inner-most circle, such that <em>xn</em> + 1 is in the same position as (<em>x</em> − 1)<em>n</em> + 1.</li>
<li>Repeat step 5 until the largest rotation circle spans the largest number to be tested for primality.</li>
<li>Strike off the number 1.</li>
<li>Strike off the spokes of the prime numbers as found in step 1 and applied in step 2 in all outer circles without striking off the prime numbers in the inner-most circle (in circle 1).</li>
<li>Strike off the spokes of all multiples of prime numbers struck from the inner circle 1 in step 4 in the same way as striking off the spokes of the base primes in step 8.</li>
<li>The remaining numbers in the wheel are mostly prime numbers (they are collectively called "relatively" prime). Use other methods such as the Sieve of Eratosthenes or further application of larger factorization wheels to remove the remaining non-primes.</li>
</ol>
<h2 id="example-using-the-above-procedure">Example using the above procedure</h2>

<p> 1. Find the first 2 prime numbers: 2 and 3.</p>

<p>2. <em>n</em> = 2 × 3 = 6</p>

<p>3.</p>

<p><code> 1  2  3  4  5  6</code></p>

<p>4. strike off factors of 2 and 3 which are 4 and 6 as factors of 2; 6 as the only factor of 3 is already stricken:</p>

<p><code> 1  2  3  </code><s><code>4</code></s><code>  5  </code><s><code>6</code></s></p>

<p>5. <em>x</em> = 1.<br/>
<em>xn</em> + 1 = 1 · 6 + 1 = 7.<br/>
 (<em>x</em> + 1)<em>n</em> = (1 + 1) · 6 = 12.<br/>
 Write 7 to 12 with 7 aligned with 1.</p>

<p><code> 1  2  3  </code><s><code>4</code></s><code>  5  </code><s><code>6</code></s><br/>
<code> 7  8  9 10 11 12</code></p>

<p>6. <em>x</em> = 2.<br/>
<em>xn</em> + 1 = 2 · 6 + 1 = 13.<br/>
 (<em>x</em> + 1)<em>n</em> = (2 + 1) · 6 = 18.<br/>
 Write 13 to 18.<br/>
 Repeat for the next few lines.</p>

<p><code> 1  2  3  </code><s><code>4</code></s><code>  5  </code><s><code>6</code></s><br/>
<code> 7  8  9 10 11 12</code><br/>
<code>13 14 15 16 17 18</code><br/>
<code>19 20 21 22 23 24</code><br/>
<code>25 26 27 28 29 30</code></p>

<p>7 and 8. Sieving</p>

<p><code> </code><s><code>1</code></s><code>  2  3  </code><s><code>4</code></s><code>  5  </code><s><code>6</code></s><br/>
<code> 7  </code><s><code>8</code></s><code> </code><s><code>9</code></s><code> 10 11 12</code><br/>
<code>13 </code><s><code>14</code></s><code> </code><s><code>15</code></s><code> 16 17 18</code><br/>
<code>19 </code><s><code>20</code></s><code> </code><s><code>21</code></s><code> 22 23 24</code><br/>
<code>25 </code><s><code>26</code></s><code> </code><s><code>27</code></s><code> 28 29 30</code></p>

<p>9. Sieving</p>

<p><code> </code><s><code>1</code></s><code>  2  3  </code><s><code>4</code></s><code>  5  </code><s><code>6</code></s><br/>
<code> 7  </code><s><code>8</code></s><code> </code><s><code>9</code></s><code> </code><s><code>10</code></s><code> 11 </code><s><code>12</code></s><br/>
<code>13 </code><s><code>14</code></s><code> </code><s><code>15</code></s><code> </code><s><code>16</code></s><code> 17 </code><s><code>18</code></s><br/>
<code>19 </code><s><code>20</code></s><code> </code><s><code>21</code></s><code> </code><s><code>22</code></s><code> 23 </code><s><code>24</code></s><br/>
<code>25 </code><s><code>26</code></s><code> </code><s><code>27</code></s><code> </code><s><code>28</code></s><code> 29 </code><s><code>30</code></s></p>

<p>10. The resulting list contains a non-prime number of 25 which is 5<sup>2</sup>. Use other methods such as a sieve to eliminate it to arrive at</p>

<p><code>2 3 5 7 11 13 17 19 23 29</code></p>

<p>Note that by using exactly the next prime number of 5 wheel cycles and eliminating the multiple(s) of that prime (and only that prime) from the resulting list, we have obtained the base wheel as per step 4 for a factorization wheel with base primes of 2, 3, and 5; this is one wheel in advance of the previous 2/3 factorization wheel. One could then follow the steps to step 10 using the next succeeding prime of 7 cycles and only eliminating the multiples of 7 from the resulting list in step 10 (leaving some "relative" primes in this case and all successive cases - i.e some not true fully qualified primes), to get the next further advanced wheel, recursively repeating the steps as necessary to get successively larger wheels.</p>
<h2 id="analysis-and-computer-implementation">Analysis and computer implementation</h2>

<p>Formally, the method makes use of the following insights: First, that the set of base primes unioned with its (infinite) set of coprimes is a superset of the primes. Second, that the infinite set of coprimes can be ennumerated easily from the coprimes to the base set between 2 and the base set product. (Note that 1 requires special handling.)</p>

<p>As seen in the example above, the result of repeated applications of the above recursive procedure from steps 4 to 10 can be a wheel list which spans any desired sieving range (to which it can be truncated) and the resulting list then includes only the multiples of primes higher than one past the last used base primes.</p>

<p>Note that once a wheel spans the desired upper limit of the sieving range, one can stop generating further wheels and use the information in that wheel to cull the remaining composite numbers from that last wheel list using a Sieve of Eratosthenes type technique but using the gap pattern inherent to the wheel to avoid redundant culls; some optimizations may be able to be made based on the fact that (will be proven in the next section) that there will be no repeat culling of any composite number: each remaining composite will be culled exactly once. Alternatively, one can continue to generate truncated wheel lists using primes up to the square root of the desired sieve range, in which case all remaining number representations in the wheel will be prime; however, although this method is as efficient as to never culling composite numbers more than once, it loses much time external to the normally considered culling operations in processing the successive wheel sweeps so as to take much longer. The elimination of composite numbers by a factorization wheel is based on the following: Given a number k &gt; n, we know that k is not prime if k mod n and n are not relatively prime. From that, the fraction of numbers that the wheel sieve eliminates can be determined (although not all need be physically struck off; many can be culled automatically in the operations of copying of lesser wheels to greater wheels) as 1 - <a href="Euler's_totient_function" title="wikilink">phi</a> (n) / n, which is also the efficiency of the sieve.</p>

<p>Since it is known<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>

<math display="block" id="Wheel_factorization:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo movablelimits="false">lim</mo>
     <mrow>
      <mo movablelimits="false">inf</mo>
      <mrow>
       <mfrac>
        <mrow>
         <mi>φ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mi>n</mi>
       </mfrac>
       <mrow>
        <mi>log</mi>
        <mrow>
         <mi>log</mi>
         <mi>n</mi>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mi>γ</mi>
     </mrow>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <limit></limit>
     <apply>
      <csymbol cd="latexml">infimum</csymbol>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>φ</ci>
         <ci>n</ci>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <log></log>
        <apply>
         <log></log>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <ci>γ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lim\inf\frac{\varphi(n)}{n}\log\log n=e^{-\gamma}.
  </annotation>
 </semantics>
</math>

 where γ is <a href="Euler–Mascheroni_constant" title="wikilink">Euler's constant</a>,   γ = 0.577215665...,   e<sup>−γ</sup> = 0.56145948... . Thus phi(n) / n goes to zero slowly as n increases to infinity and it can be seen that this efficiency rises very slowly to 100% for infinitely large n. From the properties of phi, it can easily be seen that the most efficient sieve smaller than x is the one where 

<math display="inline" id="Wheel_factorization:1">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>p</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>p</mi>
     <mn>2</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>p</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo><</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>n</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=p_{1}p_{2}...p_{i}<x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Wheel_factorization:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mo>*</mo>
    <msub>
     <mi>p</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
   <mo>≥</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n*p_{i+1}>=x
  </annotation>
 </semantics>
</math>

 (i.e wheel generation can stop when the last wheel passes or has a sufficient circumference to include the highest number in the sieving range).</p>

<p>To be of maximum use on a computer, we want the numbers that are smaller than n and relatively prime to it as a set. Using a few observations, the set can easily be generated :</p>
<ol>
<li>Start with 

<math display="inline" id="Wheel_factorization:3">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <cn type="integer">1</cn>
    </apply>
    <set>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{1}=\{1\}
  </annotation>
 </semantics>
</math>

, which is the set for 

<math display="inline" id="Wheel_factorization:4">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=1
  </annotation>
 </semantics>
</math>

 with 2 as the first prime. This initial set means that all numbers starting at two up are included as "relative" primes as the circumference of the wheel is 1.</li>
<li>Following sets are 

<math display="inline" id="Wheel_factorization:5">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <cn type="integer">2</cn>
    </apply>
    <set>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{2}=\{1\}
  </annotation>
 </semantics>
</math>

 which means that it starts at 3 for all odd numbers with the factors of 2 eliminated (circumference of 2), 

<math display="inline" id="Wheel_factorization:6">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mn>6</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>5</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <cn type="integer">6</cn>
    </apply>
    <set>
     <cn type="integer">1</cn>
     <cn type="integer">5</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{6}=\{1,5\}
  </annotation>
 </semantics>
</math>

 has the factors of 2 and 3 eliminated (circumference of 6) as for the initial base wheel in the example above and so on.</li>
<li>Let 

<math display="inline" id="Wheel_factorization:7">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mi>n</mi>
   </msub>
   <mo>+</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>n</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{n}+k
  </annotation>
 </semantics>
</math>

 be the set where k has been added to each element of 

<math display="inline" id="Wheel_factorization:8">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{n}
  </annotation>
 </semantics>
</math>

.</li>
<li>Then 

<math display="inline" id="Wheel_factorization:9">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mrow>
     <mi>n</mi>
     <msub>
      <mi>p</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>F</mi>
     <msub>
      <mi>p</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <mrow>
        <mrow>
         <mrow>
          <mrow>
           <msub>
            <mi>S</mi>
            <mi>n</mi>
           </msub>
           <mo>∪</mo>
           <msub>
            <mi>S</mi>
            <mi>n</mi>
           </msub>
          </mrow>
          <mo>+</mo>
          <mi>n</mi>
         </mrow>
         <mo>∪</mo>
         <msub>
          <mi>S</mi>
          <mi>n</mi>
         </msub>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mn>2</mn>
         <mi>n</mi>
        </mrow>
       </mrow>
       <mo>∪</mo>
       <mi mathvariant="normal">…</mi>
       <mo>∪</mo>
       <msub>
        <mi>S</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>n</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>p</mi>
          <mrow>
           <mi>i</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <union></union>
        <apply>
         <plus></plus>
         <apply>
          <union></union>
          <apply>
           <plus></plus>
           <apply>
            <union></union>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>S</ci>
             <ci>n</ci>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>S</ci>
             <ci>n</ci>
            </apply>
           </apply>
           <ci>n</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>S</ci>
           <ci>n</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>n</ci>
         </apply>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>S</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>n</ci>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <apply>
           <plus></plus>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{np_{i+1}}=F_{p_{i+1}}[S_{n}\cup S_{n}+n\cup S_{n}+2n\cup...\cup S_{n}+n(p_{%
i+1}-1)]
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Wheel_factorization:10">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{x}
  </annotation>
 </semantics>
</math>

 represents the operation of removing all multiples of x.</li>
<li>1 and 

<math display="inline" id="Wheel_factorization:11">
 <semantics>
  <msub>
   <mi>p</mi>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i+1}
  </annotation>
 </semantics>
</math>

 will be the two smallest of 

<math display="inline" id="Wheel_factorization:12">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{n}
  </annotation>
 </semantics>
</math>

 when 

<math display="inline" id="Wheel_factorization:13">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>></mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n>2
  </annotation>
 </semantics>
</math>

 removing the need to compute prime numbers separately although the algorithm does need to keep a record of all eliminated base primes which are no longer included in the succeeding sets.</li>
<li>All sets where the circumference n &gt; 2 are symmetrical around 

<math display="inline" id="Wheel_factorization:14">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n/2
  </annotation>
 </semantics>
</math>

, reducing storage requirements. The following algorithm does not use this fact, but it is based on the fact that the gaps between successive numbers in each set are symmetrical around the half way point.</li>
</ol>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Sieve_of_Sundaram" title="wikilink">Sieve of Sundaram</a></li>
<li><a href="Sieve_theory" title="wikilink">Sieve theory</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://primes.utm.edu/glossary/page.php?sort=WheelFactorization">Wheel Factorization</a></li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.52.835">Improved Incremental Prime Number Sieves</a> by Paul Pritchard</li>
</ul>

<p>"</p>

<p><a href="Category:Primality_tests" title="wikilink">Category:Primality tests</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Pritchard, Paul, "Linear prime-number sieves: a family tree," <em>Sci. Comput. Programming</em> <strong>9</strong>:1 (1987), pp. 17–35.<a href="#fnref1">↩</a></li>
<li id="fn2">Paul Pritchard, A sublinear additive sieve for finding prime numbers, Communications of the ACM 24 (1981), 18–23. MR 82c:10011<a href="#fnref2">↩</a></li>
<li id="fn3">Paul Pritchard, Explaining the wheel sieve, Acta Informatica 17 (1982), 477–485. MR 84g:10015<a href="#fnref3">↩</a></li>
<li id="fn4">Paul Pritchard, Fast compact prime number sieves (among others), Journal of Algorithms 4 (1983), 332–344. MR 85h:11080<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
