<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="704">Sonar signal processing</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Sonar signal processing</h1>
<hr/>

<p>No matter the <a href="active_sonar" title="wikilink">active sonar</a> or <a href="passive_sonar" title="wikilink">passive sonar</a>, when receiving the acoustic signal reflected from the target, the information included in the signal can not be directly collected and used without technical <a href="signal_processing" title="wikilink">signal processing</a>. To extract the efficient and useful informations from the mixed signal, some steps should be taken to transfer sonar data from raw acoustic data reception to detection output. Thus, for the active sonar, six steps are needed during the signal processing system.</p>

<p> </p>
<h2 id="signal-generation">Signal generation</h2>

<p>To actually generate in hardware as signal pulse typical analog implementations are oscillators and voltage controlled <a class="uri" href="oscillators" title="wikilink">oscillators</a> (VCO) which are followed by modulators. Amplitude modulation is used to weight the pulse envelopes and to translate the signal spectrum up to some suitable carrier frequency for transmission.</p>

<p>First, in sonar system, the acoustic pressure field can be represented as 

<math display="inline" id="Sonar_signal_processing:0">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo>,</mo>
    <mover accent="true">
     <mi>r</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <interval closure="open">
     <ci>t</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>r</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(t,\vec{r})
  </annotation>
 </semantics>
</math>

. The field function include four variables: time 

<math display="inline" id="Sonar_signal_processing:1">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 and spatial coordinate 

<math display="inline" id="Sonar_signal_processing:2">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>r</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-→</ci>
     <ci>r</ci>
    </apply>
    <vector>
     <ci>x</ci>
     <ci>y</ci>
     <ci>z</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}\vec{r}=(x,y,z)
  </annotation>
 </semantics>
</math>

. Thus, according to the <a href="Fourier_transform" title="wikilink">Fourier transform</a>, in frequency domain</p>

<p>

<math display="inline" id="Sonar_signal_processing:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>w</mi>
      <mo>,</mo>
      <mover accent="true">
       <mi>k</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo largeop="true" movablelimits="false" rspace="4.2pt" symmetric="true">⨌</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>s</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo>,</mo>
         <mover accent="true">
          <mi>r</mi>
          <mo stretchy="false">→</mo>
         </mover>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>⋅</mo>
       <msup>
        <mi>e</mi>
        <mrow>
         <mo>-</mo>
         <mrow>
          <mi>j</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mrow>
             <mi>w</mi>
             <mi>t</mi>
            </mrow>
            <mo>-</mo>
            <mrow>
             <mover accent="true">
              <mi>k</mi>
              <mo stretchy="false">→</mo>
             </mover>
             <mover accent="true">
              <mi>r</mi>
              <mo stretchy="false">→</mo>
             </mover>
            </mrow>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </msup>
      </mrow>
      <mi>d</mi>
      <mover accent="true">
       <mi>x</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mi>d</mi>
      <mi>t</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>s</ci>
     <interval closure="open">
      <ci>w</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>k</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">quadruple-integral</csymbol>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <ci>s</ci>
        <interval closure="open">
         <ci>t</ci>
         <apply>
          <ci>normal-→</ci>
          <ci>r</ci>
         </apply>
        </interval>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>j</ci>
          <apply>
           <minus></minus>
           <apply>
            <times></times>
            <ci>w</ci>
            <ci>t</ci>
           </apply>
           <apply>
            <times></times>
            <apply>
             <ci>normal-→</ci>
             <ci>k</ci>
            </apply>
            <apply>
             <ci>normal-→</ci>
             <ci>r</ci>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>d</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>x</ci>
      </apply>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}s(w,\vec{k})=\iiiint\limits\,s(t,\vec{r})\cdot e^{-j(wt-\vec{k}\vec{r})}d%
\vec{x}dt,
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Sonar_signal_processing:4">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>k</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>k</mi>
      <mi>x</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>k</mi>
      <mi>y</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>k</mi>
      <mi>z</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-→</ci>
     <ci>k</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <ci>z</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{k}=(k_{x},k_{y},k_{z}),
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Sonar_signal_processing:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo>,</mo>
      <mover accent="true">
       <mi>r</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo largeop="true" movablelimits="false" rspace="4.2pt" symmetric="true">⨌</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>s</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>w</mi>
         <mo>,</mo>
         <mover accent="true">
          <mi>k</mi>
          <mo stretchy="false">→</mo>
         </mover>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>⋅</mo>
       <msup>
        <mi>e</mi>
        <mrow>
         <mi>j</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mrow>
            <mi>w</mi>
            <mi>t</mi>
           </mrow>
           <mo>-</mo>
           <mrow>
            <mover accent="true">
             <mi>k</mi>
             <mo stretchy="false">→</mo>
            </mover>
            <mover accent="true">
             <mi>r</mi>
             <mo stretchy="false">→</mo>
            </mover>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </msup>
      </mrow>
      <mi>d</mi>
      <mover accent="true">
       <mi>k</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mi>d</mi>
      <mi>w</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>s</ci>
     <interval closure="open">
      <ci>t</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>r</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">quadruple-integral</csymbol>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <ci>s</ci>
        <interval closure="open">
         <ci>w</ci>
         <apply>
          <ci>normal-→</ci>
          <ci>k</ci>
         </apply>
        </interval>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <times></times>
         <ci>j</ci>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <ci>w</ci>
           <ci>t</ci>
          </apply>
          <apply>
           <times></times>
           <apply>
            <ci>normal-→</ci>
            <ci>k</ci>
           </apply>
           <apply>
            <ci>normal-→</ci>
            <ci>r</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>d</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>k</ci>
      </apply>
      <ci>d</ci>
      <ci>w</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}s(t,\vec{r})=\iiiint\limits\,s(w,\vec{k})\cdot e^{j(wt-\vec{k}\vec{r})}d\vec%
{k}dw,
  </annotation>
 </semantics>
</math>

</p>

<p>In the formula 

<math display="inline" id="Sonar_signal_processing:6">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 is temporal frequency and 

<math display="inline" id="Sonar_signal_processing:7">
 <semantics>
  <mover accent="true">
   <mi>k</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{k}
  </annotation>
 </semantics>
</math>

 is spacial frequency. We often define 

<math display="inline" id="Sonar_signal_processing:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo>,</mo>
      <mover accent="true">
       <mi>r</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>j</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mi>w</mi>
          <mi>t</mi>
         </mrow>
         <mo>-</mo>
         <mrow>
          <mover accent="true">
           <mi>k</mi>
           <mo stretchy="false">→</mo>
          </mover>
          <mover accent="true">
           <mi>r</mi>
           <mo stretchy="false">→</mo>
          </mover>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>s</ci>
     <interval closure="open">
      <ci>t</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>r</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>j</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>w</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <ci>normal-→</ci>
          <ci>k</ci>
         </apply>
         <apply>
          <ci>normal-→</ci>
          <ci>r</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(t,\vec{r})=e^{-j(wt-\vec{k}\vec{r})},
  </annotation>
 </semantics>
</math>

 as elemental signal, for the reason that any 4-D can be generated by taking a linear combination of elemental signals. Obviously, the direction of 

<math display="inline" id="Sonar_signal_processing:9">
 <semantics>
  <mover accent="true">
   <mi>k</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{k}
  </annotation>
 </semantics>
</math>

 gives the direction of propagation of waves, and the speed of the waves is</p>
<figure><b>(Figure)</b>
<figcaption>Wave length.png</figcaption>
</figure>

<p>

<math display="inline" id="Sonar_signal_processing:10">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>=</mo>
   <mfrac>
    <mi>w</mi>
    <mrow>
     <mo stretchy="false">|</mo>
     <mover accent="true">
      <mi>k</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo stretchy="false">|</mo>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>v</ci>
    <apply>
     <divide></divide>
     <ci>w</ci>
     <apply>
      <abs></abs>
      <apply>
       <ci>normal-→</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v=\frac{w}{|\vec{k}|}
  </annotation>
 </semantics>
</math>

</p>

<p>The wavelength is</p>

<p>

<math display="inline" id="Sonar_signal_processing:11">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mn>2</mn>
     <mi>π</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mover accent="true">
      <mi>k</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo stretchy="false">|</mo>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>λ</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>π</ci>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <ci>normal-→</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda=\frac{2\pi}{|\vec{k}|}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="temporal-sampling">Temporal sampling</h2>

<p>In modern world, digital computer do contribute a lot to higher speed and efficiency in data analysis . Thus, it is necessary to convert an analog signal into a digital signal by sample the signal in time domain . The operation can be realized by three devices: a digital conversion device, a dynamic range controller and a digital conversion device.</p>

<p>For simplicity, the sampling is done at equal time intervals. In order to prevent the distortion (that is aliasing in frequency domain)after reconstruct the signal from sampled signal, one must sample at a faster rate .The sampling rate, which can well preserves the information content of an analog signal 

<math display="inline" id="Sonar_signal_processing:12">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo>,</mo>
    <mover accent="true">
     <mi>r</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <interval closure="open">
     <ci>t</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>r</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(t,\vec{r})
  </annotation>
 </semantics>
</math>

, is submitted to the Nyquist–Shannon sampling theorem . Assuming the sampling period is T, thus after temporal sampling, the signal is</p>

<p>

<math display="inline" id="Sonar_signal_processing:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mi>T</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>r</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo>,</mo>
     <mrow>
      <mi>n</mi>
      <mi>T</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>r</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>s</ci>
      <interval closure="open">
       <apply>
        <ci>normal-→</ci>
        <ci>r</ci>
       </apply>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>T</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(t)=r(nT)=s(\vec{r},nT)
  </annotation>
 </semantics>
</math>

 n is the integer.</p>
<h2 id="spatial-sampling-and-beamforming">Spatial sampling and <a class="uri" href="beamforming" title="wikilink">beamforming</a></h2>

<p>It is really an important part for good system performance in sonar system to have appropriate sensor array and beamformer. To infer information about the acoustic field it is necessary to sample the field in space and time. Temporal sampling has already been discussed in a previous section. The sensor array samples the spatial domain, while the beanformer integrate the sensor’s output in an special way to enhance detection and estimation performance of the system.The input to the beamformer is a set of time series, while the output of the beamformer is another set of time series or a set of Fourier coefficient.</p>

<p>

<math display="inline" id="Sonar_signal_processing:14">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>r</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mover accent="true">
       <mi>x</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>i</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>s</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-→</ci>
        <ci>x</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{i}(t)=s(\vec{x}_{i},t)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Sonar_signal_processing:15">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>i</mi>
     <mi>D</mi>
    </mrow>
    <mo>,</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-→</ci>
       <ci>x</ci>
      </apply>
      <ci>i</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </vector>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <vector>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>D</ci>
      </apply>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{x}_{i}=(x_{i},0,0)=(iD,0,0)
  </annotation>
 </semantics>
</math>

</p>

<p>For a desired direction 

<math display="inline" id="Sonar_signal_processing:16">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>k</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mo>=</mo>
   <msub>
    <mover accent="true">
     <mi>k</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-→</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-→</ci>
      <ci>k</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{k}=\vec{k}_{0}
  </annotation>
 </semantics>
</math>

,Set 

<math display="inline" id="Sonar_signal_processing:17">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <msub>
      <mover accent="true">
       <mi>k</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mn>0</mn>
     </msub>
     <mi>w</mi>
    </mfrac>
    <msub>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-→</ci>
        <ci>k</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <ci>w</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-→</ci>
       <ci>x</ci>
      </apply>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{i}=\frac{\vec{k}_{0}}{w}\vec{x}_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>Beamforming is one kind of filtering that can be applied to isolate signal components that are propagating in a particular direction.. In the picture is the most simple beamformer-the weighted delay-and-sum beamformer, which can be accomplished by an array of receivers or sensors. Every triangle is a sensor to sample in spacial domain. After spacial sampling, the sample signal will be weighted and the result is summing all the weighted signals. Assuming an array of M sensors distributed in space, such that the 

<math display="inline" id="Sonar_signal_processing:18">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

th sensor is located at the position of 

<math display="inline" id="Sonar_signal_processing:19">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>=</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>M</mi>
    <mo>-</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <eq></eq>
     <cn type="integer">0</cn>
     <ci>normal-,</ci>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <csymbol cd="unknown">M</csymbol>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}(i=0,1,...,M-1)
  </annotation>
 </semantics>
</math>

 and the signal received by it is denoted 

<math display="inline" id="Sonar_signal_processing:20">
 <semantics>
  <mrow>
   <msub>
    <mi>r</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>i</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{i}(t)
  </annotation>
 </semantics>
</math>

.Thus after beamforming, the signal is</p>

<p>

<math display="inline" id="Sonar_signal_processing:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>b</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>M</mi>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mrow>
        <mi>M</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mrow>
     </msubsup>
     <mrow>
      <msub>
       <mi>w</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>r</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <msub>
         <mi>t</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>b</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>M</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <apply>
         <minus></minus>
         <ci>M</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b(t)=\frac{1}{M}\sum_{i=0}^{i=M-1}{w_{i}r_{i}(t-t_{i})}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="bandshifting">Bandshifting</h2>

<p>Bandshifting is employed in active and passive sonar to reduce the complexity of the hardware and software required for subsequent processing. For example，in active sonars the received signal is contained in a very narrow band of frequencies, typically about 2 kHz, centered at some high frequency, typically about 50 kHz. To avoid having to sample the received process at the Nyquist rate of 100 kHz, it is more efficient to demodulate the process to baseband and then employ sampling of the <a href="complex_envelope" title="wikilink">complex envelope</a> at only 2 kHz.</p>
<h2 id="filtering-and-smoothing">Filtering and smoothing</h2>

<p>Filters and smoothen are used extensively in modem sonar systems, After sampling, the signal is converted from analog signal into a discrete time signal, thus digital filters are only into consideration. What’s more, although some filters are time varying or adaptive, most of the filters are linear shift invariant. Digital filters used in sonar signal processors perform two major functions, the filtering of waveforms to modify the frequency content and the smoothing of waveforms to reduce the effects of noise. The two generic types of digital filters are FIR and infinite impulse response (IIR) filters . Input-output relationship of an FIR filter is</p>

<p>

<math display="inline" id="Sonar_signal_processing:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mi>k</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>k</ci>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(n)=\sum_{k=0}^{N-1}{h(k)x(n-k)}
  </annotation>
 </semantics>
</math>

 (1-D)</p>

<p>

<math display="inline" id="Sonar_signal_processing:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>n</mi>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <msub>
       <mi>k</mi>
       <mn>1</mn>
      </msub>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <msub>
       <mi>M</mi>
       <mn>1</mn>
      </msub>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <msub>
        <mi>k</mi>
        <mn>2</mn>
       </msub>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <msub>
        <mi>M</mi>
        <mn>2</mn>
       </msub>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>k</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>k</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>n</mi>
         <mn>1</mn>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>k</mi>
         <mn>1</mn>
        </msub>
       </mrow>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>n</mi>
         <mn>2</mn>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>k</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>k</ci>
          <cn type="integer">2</cn>
         </apply>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>M</ci>
         <cn type="integer">2</cn>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>h</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>k</ci>
         <cn type="integer">2</cn>
        </apply>
       </interval>
       <ci>x</ci>
       <interval closure="open">
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>k</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(n1,n2)=\sum_{k_{1}=0}^{M_{1}-1}\sum_{k_{2}=0}^{M_{2}-1}{h(k_{1},k_{2})x(n_{1%
}-k_{1},n_{2}-k_{2})}
  </annotation>
 </semantics>
</math>

 (2-D)</p>

<p>Input-output relationship of an IIR filter is</p>

<p>

<math display="inline" id="Sonar_signal_processing:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>k</mi>
      </msub>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mi>k</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>M</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mrow>
      <msub>
       <mi>b</mi>
       <mi>k</mi>
      </msub>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mi>k</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>k</ci>
       </apply>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>M</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
       <ci>y</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(n)=\sum_{k=0}^{N-1}{a_{k}x(n-k)}+\sum_{k=0}^{M-1}{b_{k}y(n-k)}
  </annotation>
 </semantics>
</math>

 (1-D)</p>

<p>

<math display="inline" id="Sonar_signal_processing:25">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>n</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>n</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <msub>
        <mi>r</mi>
        <mn>1</mn>
       </msub>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <msub>
        <mi>N</mi>
        <mn>1</mn>
       </msub>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <msub>
         <mi>r</mi>
         <mn>2</mn>
        </msub>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mrow>
        <msub>
         <mi>N</mi>
         <mn>2</mn>
        </msub>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
      <mrow>
       <mi>a</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>r</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>r</mi>
         <mn>2</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>n</mi>
          <mn>1</mn>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>r</mi>
          <mn>1</mn>
         </msub>
        </mrow>
        <mo>,</mo>
        <mrow>
         <msub>
          <mi>n</mi>
          <mn>2</mn>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>r</mi>
          <mn>2</mn>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <msub>
        <mi>l</mi>
        <mn>1</mn>
       </msub>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <msub>
        <mi>M</mi>
        <mn>1</mn>
       </msub>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <msub>
         <mi>l</mi>
         <mn>2</mn>
        </msub>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mrow>
        <msub>
         <mi>M</mi>
         <mn>2</mn>
        </msub>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
      <mrow>
       <mi>b</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>l</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>l</mi>
         <mn>2</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>y</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>l</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>l</mi>
         <mn>2</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <cn type="integer">1</cn>
         </apply>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>N</ci>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>r</ci>
           <cn type="integer">2</cn>
          </apply>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>N</ci>
          <cn type="integer">2</cn>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>a</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <cn type="integer">2</cn>
         </apply>
        </interval>
        <ci>x</ci>
        <interval closure="open">
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>r</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>n</ci>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>r</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>l</ci>
          <cn type="integer">1</cn>
         </apply>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>M</ci>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>l</ci>
           <cn type="integer">2</cn>
          </apply>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>M</ci>
          <cn type="integer">2</cn>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>b</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>l</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>l</ci>
          <cn type="integer">2</cn>
         </apply>
        </interval>
        <ci>y</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>l</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>l</ci>
          <cn type="integer">2</cn>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(n_{1},n_{2})=\sum_{r_{1}=0}^{N_{1}-1}\sum_{r_{2}=0}^{N_{2}-1}{a(r_{1},r_{2})%
x(n_{1}-r_{1},n_{2}-r_{2})}-\sum_{l_{1}=0}^{M_{1}-1}\sum_{l_{2}=0}^{M_{2}-1}{b%
(l_{1},l_{2})y(l_{1},l_{2})}
  </annotation>
 </semantics>
</math>

 (2-D)</p>

<p>Both FIR filters and IIR filters have there advantages and disadvantages. First, the computational requirements of a sonar processor are more severe when implementing FIR filters. Second, for an IIR filter, linear phase is always difficult to obtain, so FIR filter is stable as opposed to an IIR filter. What’s more, FIR filters are more easily designed using the windowing technique.</p>
<h2 id="decision-processing">Decision processing</h2>

<p>In a word, the goal of the sonar is to extract the informations and data from acoustic space-time field, and put them into designed and prescribed process so that we can apply the different cases into one fixed pattern. Thus, to realize the goal, the final stage of sonar system consists of the following functions:</p>
<ol>
<li>Detection:Sonar detection determine if there is noise around the target.</li>
<li>Classification:Sonar classification distinguish a detected target signal.</li>
<li>Parameter estimation and tracking:Estimation in sonar is often associated with the localization of a target which has already been detected.</li>
<li>Normalization: Normalization is to make the noise-only response of the detection statistic as uniform as possible.</li>
<li>Display processing:Display processing addresses the operability and data management problems of the sonar system.</li>
</ol>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Filter" title="wikilink">Filter</a></li>
<li><a href="Echo_sounding" title="wikilink">Echo sounding</a></li>
<li><a href="Passive_Radar" title="wikilink">Passive Radar</a></li>
<li><a class="uri" href="Radar" title="wikilink">Radar</a></li>
<li><a href="Scientific_Echosounder" title="wikilink">Scientific Echosounder</a></li>
<li><a href="Signal_Processing" title="wikilink">Signal Processing</a></li>
<li><a href="Digital_Signal_Processing" title="wikilink">Digital Signal Processing</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>William C. Knight. Digital Digital Processing for Sonar. IEEE PROCEEDINGS.Vol-69.No-11, NOV 1981</li>
<li>N. N. de Moura, J. M. de Seixas and Ricardo Ramos (2011). Passive Sonar Signal Detection and Classification Based on Independent Component Analysis, Sonar Systems, Prof. Nikolai Kolev (Ed.), ISBN 978-953-307- 345-3, InTech, Available f rom:<a class="uri" href="http://www.intechopen.com/books/sonar-systems/passive-sonar-signal">http://www.intechopen.com/books/sonar-systems/passive-sonar-signal</a> detection- and13-11-15 Sonar signal processing Wikimedia Commons <a class="uri" href="https://commons.wikimedia.org/wiki/Sonar_signal_processing">https://commons.wikimedia.org/wiki/Sonar_signal_processing</a> 5/5 classification-based-on-independent-component-analysis</li>
<li>Hossein Peyvandi. Sonar Systems and Underwater Signal Processing: Classic and Modern Approaches.Scientific Applied College of Telecommunication, Tehran.</li>
</ul>

<p>"</p>

<p><a href="Category:Sonar" title="wikilink"> </a> <a href="Category:Multidimensional_signal_processing" title="wikilink">Category:Multidimensional signal processing</a></p>
</body>
</html>
