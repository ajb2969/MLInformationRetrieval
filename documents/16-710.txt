   Regularization by spectral filtering      Regularization by spectral filtering   Spectral regularization is any of a class of regularization techniques used in machine learning to control the impact of noise and prevent overfitting . Spectral regularization can be used in a broad range of applications, from deblurring images to classifying emails into a spam folder and a non-spam folder. For instance, in the email classification example, spectral regularization can be used to reduce the impact of noise and prevent overfitting when a machine learning system is being trained on a labeled set of emails to learn how to tell a spam and a non-spam email apart.  Spectral regularization algorithms rely on methods that were originally defined and studied in the theory of ill-posed  inverse problems (for instance, see 1 ) focusing on the inversion of a linear operator (or a matrix) that possibly has a bad condition number or an unbounded inverse. In this context, regularization amounts to substituting the original operator by a bounded operator called the "regularization operator" that has a condition number controlled by a regularization parameter, 2 a classical example being Tikhonov regularization . To ensure stability, this regularization parameter is tuned based on the level of noise. 3 The main idea behind spectral regularization is that each regularization operator can be described using spectral calculus as an appropriate filter on the eigenvalues of the operator that defines the problem, and the role of the filter is to "suppress the oscillatory behavior corresponding to small eigenvalues". 4 Therefore, each algorithm in the class of spectral regularization algorithms is defined by a suitable filter function (which needs to be derived for that particular algorithm). Three of the most commonly used regularization algorithms for which spectral filtering is well-studied are Tikhonov regularization, Landweber iteration , and truncated singular value decomposition (TSVD). As for choosing the regularization parameter, examples of candidate methods to compute this parameter include the discrepancy principle, generalized cross validation , and the L-curve criterion. 5  It is of note that the notion of spectral filtering studied in the context of machine learning is closely connected to the literature on function approximation (in signal processing).  Notation  The training set is defined as    S  =   {   (   x  1   ,   y  1   )   ,  …  ,   (   x  n   ,   y  n   )   }       S     subscript  x  1    subscript  y  1    normal-…    subscript  x  n    subscript  y  n       S=\{(x_{1},y_{1}),\dots,(x_{n},y_{n})\}   , where   X   X   X   is the    n  ×  d      n  d    n\times d   input matrix and    Y  =   (   y  1   ,  …  ,   y  n   )       Y    subscript  y  1   normal-…   subscript  y  n      Y=(y_{1},\dots,y_{n})   is the output vector. Where applicable, the kernel function is denoted by   k   k   k   , and the    n  ×  n      n  n    n\times n   kernel matrix is denoted by   K   K   K   which has entries     K   i  j    =   k   (   x  i   ,   x  j   )         subscript  K    i  j      k    subscript  x  i    subscript  x  j       K_{ij}=k(x_{i},x_{j})   and   ℋ   ℋ   \mathcal{H}   denotes the Reproducing Kernel Hilbert Space (RKHS) with kernel   k   k   k   . The regularization parameter is denoted by   λ   λ   \lambda   .  ''(Note: For    g  ∈  G      g  G    g\in G   and    f  ∈  F      f  F    f\in F   , with   G   G   G   and   F   F   F   being Hilbert spaces, given a linear, continuous operator   L   L   L   , assume that    g  =   L  f       g    L  f     g=Lf   holds. In this setting, the direct problem would be to solve for   g   g   g   given   f   f   f   and the inverse problem would be to solve for   f   f   f   given   g   g   g   . If the solution exists, is unique and stable, the inverse problem (i.e. the problem of solving for   f   f   f   ) is well-posed; otherwise, it is ill-posed.) ''  Relation to the theory of ill-posed inverse problems  The connection between the regularized least squares (RLS) estimation problem (Tikhonov regularization setting) and the theory of ill-posed inverse problems is an example of how spectral regularization algorithms are related to the theory of ill-posed inverse problems.  The RLS estimator solves         min   f  ∈  ℋ     1  n      ∑   i  =  1   n     (    y  i   -   f   (   x  i   )     )   2     +   λ    ∥  f  ∥   ℋ  2            subscript     f  ℋ      1  n      superscript   subscript     i  1    n    superscript     subscript  y  i     f   subscript  x  i     2       λ   subscript   superscript   norm  f   2   ℋ      \min_{f\in\mathcal{H}}\frac{1}{n}\sum_{i=1}^{n}(y_{i}-f(x_{i}))^{2}+\lambda\|f%
 \|^{2}_{\mathcal{H}}     and the RKHS allows for expressing this RLS estimator as      f  S  λ    (  X  )    =    ∑   i  =  1   n     c  i   k   (  x  ,   x  i   )            superscript   subscript  f  S   λ   X     superscript   subscript     i  1    n      subscript  c  i   k   x   subscript  x  i        f_{S}^{\lambda}(X)=\sum_{i=1}^{n}c_{i}k(x,x_{i})   where      (   K  +   n  λ  I    )   c   =  Y          K    n  λ  I    c   Y    (K+n\lambda I)c=Y   with    c  =   (   c  1   ,  …  ,   c  n   )       c    subscript  c  1   normal-…   subscript  c  n      c=(c_{1},\dots,c_{n})   . 6 The penalization term is used for controlling smoothness and preventing overfitting. Since the solution of empirical risk minimization      min   f  ∈  ℋ     1  n      ∑   i  =  1   n     (    y  i   -   f   (   x  i   )     )   2          subscript     f  ℋ      1  n      superscript   subscript     i  1    n    superscript     subscript  y  i     f   subscript  x  i     2      \min_{f\in\mathcal{H}}\frac{1}{n}\sum_{i=1}^{n}(y_{i}-f(x_{i}))^{2}   can be written as      f  S  λ    (  X  )    =    ∑   i  =  1   n     c  i   k   (  x  ,   x  i   )            superscript   subscript  f  S   λ   X     superscript   subscript     i  1    n      subscript  c  i   k   x   subscript  x  i        f_{S}^{\lambda}(X)=\sum_{i=1}^{n}c_{i}k(x,x_{i})   such that     K  c   =  Y        K  c   Y    Kc=Y   , adding the penalty function amounts to the following change in the system that needs to be solved: 7       {   min   f  ∈  ℋ     1  n    ∑   i  =  1   n     (   y  i   -  f   (   x  i   )   )   2   →   min   f  ∈  ℋ     1  n    ∑   i  =  1   n     (   y  i   -  f   (   x  i   )   )   2   +  λ  ∥  f   ∥  ℋ  2   }   ≡   {  K  c  =  Y  →   (  K  +  n  λ  I  )   c  =  Y  }   .     fragments   fragments  normal-{   subscript     f  ℋ      1  n    superscript   subscript     i  1    n    superscript   fragments  normal-(   subscript  y  i    f   fragments  normal-(   subscript  x  i   normal-)   normal-)   2   normal-→   subscript     f  ℋ      1  n    superscript   subscript     i  1    n    superscript   fragments  normal-(   subscript  y  i    f   fragments  normal-(   subscript  x  i   normal-)   normal-)   2    λ  parallel-to  f   subscript   superscript  parallel-to  2   ℋ   normal-}     fragments  normal-{  K  c   Y  normal-→   fragments  normal-(  K   n  λ  I  normal-)   c   Y  normal-}   normal-.    \bigg\{\min_{f\in\mathcal{H}}\frac{1}{n}\sum_{i=1}^{n}(y_{i}-f(x_{i}))^{2}%
 \rightarrow\min_{f\in\mathcal{H}}\frac{1}{n}\sum_{i=1}^{n}(y_{i}-f(x_{i}))^{2}%
 +\lambda\|f\|^{2}_{\mathcal{H}}\bigg\}\equiv\bigg\{Kc=Y\rightarrow(K+n\lambda I%
 )c=Y\bigg\}.     In this learning setting, the kernel matrix can be decomposed as    K  =   Q  Σ   Q  T        K    Q  normal-Σ   superscript  Q  T      K=Q\Sigma Q^{T}   , with       σ  =   diag   (   σ  1   ,  …  ,   σ  n   )     ,    σ  1   ≥   σ  2   ≥  ⋯  ≥   σ  n   ≥  0      formulae-sequence    σ   diag   subscript  σ  1   normal-…   subscript  σ  n          subscript  σ  1    subscript  σ  2        normal-⋯        subscript  σ  n        0      \sigma=\operatorname{diag}(\sigma_{1},\dots,\sigma_{n}),~{}\sigma_{1}\geq%
 \sigma_{2}\geq\cdots\geq\sigma_{n}\geq 0     and     q  1   ,  …  ,   q  n       subscript  q  1   normal-…   subscript  q  n     q_{1},\dots,q_{n}   are the corresponding eigenvectors. Therefore, in the initial learning setting, the following holds:       c  =    K   -  1    Y   =   Q   Σ   -  1     Q  T   Y   =    ∑   i  =  1   n     1   σ  i     ⟨   q  i   ,  Y  ⟩    q  i      .        c     superscript  K    1    Y          Q   superscript  normal-Σ    1     superscript  Q  T   Y          superscript   subscript     i  1    n       1   subscript  σ  i      subscript  q  i   Y    subscript  q  i        c=K^{-1}Y=Q\Sigma^{-1}Q^{T}Y=\sum_{i=1}^{n}\frac{1}{\sigma_{i}}\langle q_{i},Y%
 \rangle q_{i}.     Thus, for small eigenvalues, even small perturbations in the data can lead to considerable changes in the solution. Hence, the problem is ill-conditioned, and solving this RLS problem amounts to stabilizing a possibly ill-conditioned matrix inversion problem, which is studied in the theory of ill-posed inverse problems; in both problems, a main concern is to deal with the issue of numerical stability.  Implementation of algorithms for spectral regularization  Each algorithm in the class of spectral regularization algorithms is defined by a suitable filter function, denoted here by     G  λ    (  ⋅  )        subscript  G  λ   normal-⋅    G_{\lambda}(\cdot)   . If the Kernel matrix is denoted by   K   K   K   , then   λ   λ   \lambda   should control the magnitude of the smaller eigenvalues of     G  λ    (  K  )        subscript  G  λ   K    G_{\lambda}(K)   . In a filtering setup, the goal is to find estimators      f  S  λ    (  X  )    :=    ∑   i  =  1   n     c  i   k   (  x  ,   x  i   )        assign     superscript   subscript  f  S   λ   X     superscript   subscript     i  1    n      subscript  c  i   k   x   subscript  x  i        f_{S}^{\lambda}(X):=\sum_{i=1}^{n}c_{i}k(x,x_{i})   where    c  =    G  λ    (  K  )   Y       c     subscript  G  λ   K  Y     c=G_{\lambda}(K)Y   . To do so, a scalar filter function     G  λ    (  σ  )        subscript  G  λ   σ    G_{\lambda}(\sigma)   is defined using the eigen-decomposition of the kernel matrix:         G  λ    (  K  )    =   Q   G  λ    (  Σ  )    Q  T     ,         subscript  G  λ   K     Q   subscript  G  λ   normal-Σ   superscript  Q  T      G_{\lambda}(K)=QG_{\lambda}(\Sigma)Q^{T},     which yields         G  λ    (  K  )    Y    =    ∑   i  =  1   n     G  λ    (   σ  i   )    ⟨   q  i   ,  Y  ⟩    q  i      .         subscript  G  λ   K  Y     superscript   subscript     i  1    n      subscript  G  λ    subscript  σ  i     subscript  q  i   Y    subscript  q  i       G_{\lambda}(K)Y~{}=~{}\sum_{i=1}^{n}G_{\lambda}(\sigma_{i})\langle q_{i},Y%
 \rangle q_{i}.     Typically, an appropriate filter function should have the following properties: 8  1. As   λ   λ   \lambda   goes to zero,      G  λ    (  σ  )    →   1  /  σ      normal-→     subscript  G  λ   σ     1  σ     G_{\lambda}(\sigma)~{}\rightarrow~{}1/\sigma   .  2. The magnitude of the (smaller) eigenvalues of    G  λ     subscript  G  λ    G_{\lambda}   is controlled by   λ   λ   \lambda   .  While the above items give a rough characterization of the general properties of filter functions for all spectral regularization algorithms, the derivation of the filter function (and hence its exact form) varies depending on the specific regularization method that spectral filtering is applied to.  Filter function for Tikhonov regularization  In the Tikhonov regularization setting, the filter function for RLS is described below. As shown in, 9 in this setting,    c  =     (   K  +   n  λ  I    )    -  1    Y       c     superscript    K    n  λ  I      1    Y     c=(K+n\lambda I)^{-1}Y   . Thus,      σ  ≫   λ  n      much-greater-than  σ    λ  n     \sigma\gg\lambda n     The undesired components are filtered out using regularization:   If     1    σ  i   +   n  λ     ∼   1   σ  i       similar-to    1     subscript  σ  i     n  λ       1   subscript  σ  i      \frac{1}{\sigma_{i}+n\lambda}\sim\frac{1}{\sigma_{i}}   , then    σ  ≪   λ  n      much-less-than  σ    λ  n     \sigma\ll\lambda n   .  If     1    σ  i   +   n  λ     ∼   1   λ  n       similar-to    1     subscript  σ  i     n  λ       1    λ  n      \frac{1}{\sigma_{i}+n\lambda}\sim\frac{1}{\lambda n}   , then       G  λ    (  σ  )    =   1   σ  +   n  λ      .         subscript  G  λ   σ     1    σ    n  λ       G_{\lambda}(\sigma)=\frac{1}{\sigma+n\lambda}.   .   The filter function for Tikhonov regularization is therefore defined as: 10      c  0   =   0        superscript  c  0   0    c^{0}=0\,     Filter function for Landweber iteration  The idea behind the Landweber iteration is gradient descent : 11       for  i   =   1  ,  …  ,   t  -  1          for  i    1  normal-…    t  1      \text{for }i=1,\dots,t-1           c   i   =    c   i  -  1    +   η   (   Y  -   K   c   i  -  1      )          superscript  c  i      superscript  c    i  1      η    Y    K   superscript  c    i  1          ~{}~{}~{}~{}~{}c^{i}=c^{i-1}+\eta(Y-Kc^{i-1})        end   end   \mathrm{end}        n   n   n     In this setting, if   K   K   K   is larger than    η  =   2  /  n       η    2  n     \eta=2/n   's largest eigenvalue, the above iteration converges by choosing     1  n     ||   Y  -   K  c    ||   2  2         1  n    superscript   subscript   norm    Y    K  c     2   2     \frac{1}{n}||Y-Kc||_{2}^{2}   as the step-size:. 12 The above iteration is equivalent to minimizing   t   t   t   (i.e. the empirical risk) via gradient descent; using induction, it can be proved that at the     c  =   η    ∑   i  =  0    t  -  1       (   I  -   η  K    )   i   Y      .      c    η    superscript   subscript     i  0      t  1       superscript    I    η  K    i   Y       c=\eta\sum_{i=0}^{t-1}(I-\eta K)^{i}Y.   -th iteration, the solution is given by 13         G  λ    (  σ  )    =   η    ∑   i  =  0    t  -  1      (   I  -   η  σ    )   i      .         subscript  G  λ   σ     η    superscript   subscript     i  0      t  1     superscript    I    η  σ    i       G_{\lambda}(\sigma)=\eta\sum_{i=0}^{t-1}(I-\eta\sigma)^{i}.     Thus, the appropriate filter function is defined by:      K   -  1      superscript  K    1     K^{-1}     It can be shown that this filter function corresponds to a truncated power expansion of      ∑   i  ≥  0     x  i    =   1  /   (   1  -  x   )          subscript     i  0     superscript  x  i      1    1  x      \sum_{i\geq 0}x^{i}=1/(1-x)   ; 14 to see this, note that the relation   x   x   x   , would still hold if   K   K   K   is replaced by a matrix; thus, if    I  -   η  K       I    η  K     I-\eta K   (the kernel matrix), or rather      K   -  1    =   η    ∑   i  =  0   ∞     (   I  -   η  K    )   i     ∼   η    ∑   i  =  0    t  -  1      (   I  -   η  K    )   i      .         superscript  K    1      η    superscript   subscript     i  0       superscript    I    η  K    i       similar-to      η    superscript   subscript     i  0      t  1     superscript    I    η  K    i        K^{-1}=\eta\sum_{i=0}^{\infty}(I-\eta K)^{i}\sim\eta\sum_{i=0}^{t-1}(I-\eta K)%
 ^{i}.   , is considered, the following holds:      t  ∼   1  /  λ      similar-to  t    1  λ     t\sim 1/\lambda     In this setting, the number of iterations gives the regularization parameter; roughly speaking,   t   t   t   . 15 If   t   t   t   is large, overfitting may be a concern. If    K  =   Q  Σ   Q  T        K    Q  normal-Σ   superscript  Q  T      K=Q\Sigma Q^{T}   is small, oversmoothing may be a concern. Thus, choosing an appropriate time for early stopping of the iterations provides a regularization effect.  Filter function for TSVD  In the TSVD setting, given the eigen-decomposition    λ  n      λ  n    \lambda n   and using a prescribed threshold       G  λ    (  σ  )    =   {      1  /  σ       ,       if  σ   ≥   λ  n         0      ,     otherwise         .         subscript  G  λ   σ    cases      1  σ   absent      if  σ     λ  n     missing-subexpression     0  absent  otherwise   missing-subexpression        G_{\lambda}(\sigma)=\left\{\begin{array}[c]{lcll}1/\sigma&,&\text{if }\sigma%
 \geq\lambda n\\
 0&,&\text{otherwise}\\
 \end{array}\right..   , a regularized inverse can be formed for the kernel matrix by discarding all the eigenvalues that are smaller than this threshold. 16 Thus, the filter function for TSVD can be defined as  $$G_\lambda(\sigma) =\left\{\begin{array}[c]{lcll}1/\sigma & ,& \text{if }\sigma\geq\lambda n\\[0.05in]0&,& \text{otherwise}\\[0.05in]\end{array}\right..$$  It can be shown that TSVD is equivalent to the (unsupervised) projection of the data using (kernel) Principal Component Analysis (PCA), and that it is also equivalent to minimizing the empirical risk on the projected data (without regularization). 17 Note that the number of components kept for the projection is the only free parameter here.  References  "  Category:Mathematical analysis  Category:Inverse problems  Category:Computer engineering     H. W. Engl , M. Hanke, and A. Neubauer. Regularization of inverse problems . Kluwer, 1996. ↩  L. Lo Gerfo, L. Rosasco, F. Odone, E. De Vito, and A. Verri. Spectral Algorithms for Supervised Learning, Neural Computation , 20(7), 2008. ↩    P. C. Hansen, J. G. Nagy, and D. P. O'Leary. Deblurring Images: Matrices, Spectra, and Filtering , Fundamentals of Algorithms 3, SIAM, Philadelphia, 2006. ↩  L. Rosasco. Lecture 6 of the Lecture Notes for 9.520: Statistical Learning Theory and Applications. Massachusetts Institute of Technology, Fall 2013. Available at http://www.mit.edu/~9.520/fall13/slides/class06/class06_RLSSVM.pdf ↩  L. Rosasco. Lecture 7 of the Lecture Notes for 9.520: Statistical Learning Theory and Applications. Massachusetts Institute of Technology, Fall 2013. Available at http://www.mit.edu/~9.520/fall13/slides/class07/class07_spectral.pdf ↩               