   Meet-in-the-middle attack      Meet-in-the-middle attack   The Meet-in-the-Middle attack (MITM) is a generic space–time tradeoff  cryptographic attack.  Description  MITM is a generic attack, applicable on several cryptographic systems. The internal structure of a specific system is therefore unimportant to this attack.  An attacker requires the ability to encrypt and decrypt, and the possession of pairs of plaintexts and corresponding ciphertexts.  When trying to improve the security of a block cipher, a tempting idea is to simply use several independent keys to encrypt the data several times using a sequence of functions (encryptions). Then one might think that this doubles or even n -tuples the security of the multiple-encryption scheme, depending on the number of encryptions the data must go through.  The Meet-in-the-Middle attack attempts to find a value using both of the range (ciphertext) and domain (plaintext) of the composition of several functions (or block ciphers) such that the forward mapping through the first functions is the same as the backward mapping (inverse image) through the last functions, quite literally meeting in the middle of the composed function.  The Multidimensional MITM (MD-MITM) uses a combination of several simultaneous MITM-attacks like described above, where the meeting happens in multiple positions in the composed function.  An exhaustive search on all possible combination of keys (simple brute-force) would take 2 k·j attempts if j encryptions has been used with different keys in each encryption, where each key is k bits long. MITM or MD-MITM improves on this performance.  History  It was first developed as an attack on an attempted expansion of a block cipher by Diffie and Hellman in 1977. 1  Diffie and Hellman, however, devised a space-time tradeoff that could break the scheme in only double the time to break the single-encryption scheme.  In 2011, Bo Zhu and Guang Gong investigated the Multidimensional Meet-in-the-Middle attack and presented new attacks on the block ciphers GOST , KTANTAN and Hummingbird-2 . 2  MITM (1D-MITM)  Assume the attacker knows a set of plaintext P and ciphertext C that satisfies the following:     C   C   \displaystyle C     where ENC is the encryption function, DEC the decryption function defined as ENC −1 (inverse mapping) and k 1 and k 2 are two keys.  The attacker can then compute ENC k 1 (P) for all possible keys k 1 and then decrypt the ciphertext by computing DEC k 2 (C) for each k 2 . Any matches between these two resulting sets are likely to reveal the correct keys. (To speed up the comparison, the ENC k 1 (P) set can be stored in an in-memory lookup table, then each DEC k 2 (C) can be matched against the values in the lookup table to find the candidate keys)  This attack is one of the reasons why DES was replaced by Triple DES — "Double DES" does not provide much additional security against exhaustive key search for an attacker with 2 56 space. 3 However, Triple DES with a "triple length" (168-bit) key is vulnerable to a meet-in-the-middle attack in 2 56 space and 2 112 operations. 4  thumb|upright=1.5|An illustration of 1D-MITM attack  Once the matches are discovered, they can be verified with a second test-set of plaintext and ciphertext.  MITM algorithm  Compute the following:         S  u  b  C  i  p  h  e   r  1    =   E  N   C   f  1     (   k   f  1    ,  P  )     ,    ∀   k   f  1     ∈  K      formulae-sequence      S  u  b  C  i  p  h  e   subscript  r  1      E  N   subscript  C   subscript  f  1      subscript  k   subscript  f  1    P        for-all   subscript  k   subscript  f  1     K     SubCipher_{1}=ENC_{f_{1}}(k_{f_{1}},P),\;\forall k_{f_{1}}\in K   :  and save each    S  u  b  C  i  p  h  e   r  1       S  u  b  C  i  p  h  e   subscript  r  1     SubCipher_{1}   together with corresponding    k   f  1      subscript  k   subscript  f  1     k_{f_{1}}   in a set A         S  u  b  C  i  p  h  e   r  1    =   D  E   C   b  1     (   k   b  1    ,  C  )     ,    ∀   k   b  1     ∈  K      formulae-sequence      S  u  b  C  i  p  h  e   subscript  r  1      D  E   subscript  C   subscript  b  1      subscript  k   subscript  b  1    C        for-all   subscript  k   subscript  b  1     K     SubCipher_{1}=DEC_{b_{1}}(k_{b_{1}},C),\;\forall k_{b_{1}}\in K   :  and compare each new    S  u  b  C  i  p  h  e   r  1       S  u  b  C  i  p  h  e   subscript  r  1     SubCipher_{1}   with the set A    When a match is found, keep k f 1 ,k b 1 as candidate key-pair in a table T . Test pairs in T on a new pair of (P,C) to confirm validity. If the key-pair does not work on this new pair, do MITM again on a new pair of (P,C) .  MITM complexity  If the keysize is k , this attack uses only 2 k+1 encryptions (and decryptions) (and O(2 k ) memory in case a look-up table have been built for the set of forward computations) in contrast to the naive attack, which needs 2 2·k encryptions but O(1) space.  Multidimensional-MITM  While 1D-MITM can be efficient, a more sophisticated attack has been developed: Multi Dimensional-Meet In The Middle attack , also abbreviated MD-MITM . This is more preferred when the data has been encrypted using more than 2 encryptions with different keys. Instead of meeting in the middle (one place in the sequence), the MD-MITM attack attempts to reach several specific intermediate states using the forward and backward computations at several positions in the cipher. 5  Assume that the attack has to be mounted on a block cipher, where the encryption and decryption is defined as before:      C  =   E  N   C   k  n     (   E  N   C   k   n  -  1      (   …   (   E  N   C   k  1     (  P  )    )   …   )    )        C    E  N   subscript  C   subscript  k  n      E  N   subscript  C   subscript  k    n  1       normal-…    E  N   subscript  C   subscript  k  1    P   normal-…       C=ENC_{k_{n}}(ENC_{k_{n-1}}(...(ENC_{k_{1}}(P))...))        P  =   D  E   C   k  1     (   D  E   C   k  2     (   …   (   D  E   C   k  n     (  C  )    )   …   )    )        P    D  E   subscript  C   subscript  k  1      D  E   subscript  C   subscript  k  2      normal-…    D  E   subscript  C   subscript  k  n    C   normal-…       P=DEC_{k_{1}}(DEC_{k_{2}}(...(DEC_{k_{n}}(C))...))     that is a plaintext P is encrypted multiple times using a repetition of the same block cipher  thumb|center|upright=4|An illustration of MD-MITM attack  The MD-MITM has been used for cryptanalysis of among many, the GOST block cipher , where it has been shown that a 3D-MITM has significantly reduced the time complexity for an attack on it. 6  MD-MITM algorithm  Compute the following:        S  u  b  C  i  p  h  e   r  1    =   E  N   C   f  1     (   k   f  1    ,  P  )          S  u  b  C  i  p  h  e   subscript  r  1      E  N   subscript  C   subscript  f  1      subscript  k   subscript  f  1    P      SubCipher_{1}=ENC_{f_{1}}(k_{f_{1}},P)   ∀    k   f  1      subscript  k   subscript  f  1     k_{f_{1}}   ∈   K   K   K    :    and save each    S  u  b  C  i  p  h  e   r  1       S  u  b  C  i  p  h  e   subscript  r  1     SubCipher_{1}   together with corresponding    k   f  1      subscript  k   subscript  f  1     k_{f_{1}}   in a set    H  1     subscript  H  1    H_{1}   .         S  u  b  C  i  p  h  e   r   n  +  1     =   D  E   C   b   n  +  1      (   k   b   n  +  1     ,  C  )          S  u  b  C  i  p  h  e   subscript  r    n  1       D  E   subscript  C   subscript  b    n  1       subscript  k   subscript  b    n  1     C      SubCipher_{n+1}=DEC_{b_{n+1}}(k_{b_{n+1}},C)   ∀    k   b   n  +  1       subscript  k   subscript  b    n  1      k_{b_{n+1}}   ∈   K   K   K    :    and save each    S  u  b  C  i  p  h  e   r   n  +  1        S  u  b  C  i  p  h  e   subscript  r    n  1      SubCipher_{n+1}   together with corresponding    k   b   n  +  1       subscript  k   subscript  b    n  1      k_{b_{n+1}}   in a set    H   n  +  1      subscript  H    n  1     H_{n+1}   .   For each possible guess on the intermediate state    s  1     subscript  s  1    s_{1}   compute the following:        S  u  b  C  i  p  h  e   r  1    =   D  E   C   b  1     (   k   b  1    ,   s  1   )          S  u  b  C  i  p  h  e   subscript  r  1      D  E   subscript  C   subscript  b  1      subscript  k   subscript  b  1     subscript  s  1       SubCipher_{1}=DEC_{b_{1}}(k_{b_{1}},s_{1})   ∀    k   b  1      subscript  k   subscript  b  1     k_{b_{1}}   ∈   K   K   K    :    and for each match between this    S  u  b  C  i  p  h  e   r  1       S  u  b  C  i  p  h  e   subscript  r  1     SubCipher_{1}   and the set    H  1     subscript  H  1    H_{1}   , save    k   b  1      subscript  k   subscript  b  1     k_{b_{1}}   and    k   f  1      subscript  k   subscript  f  1     k_{f_{1}}   in a new set    T  1     subscript  T  1    T_{1}   .         S  u  b  C  i  p  h  e   r  2    =   E  N   C   f  2     (   k   f  2    ,   s  1   )          S  u  b  C  i  p  h  e   subscript  r  2      E  N   subscript  C   subscript  f  2      subscript  k   subscript  f  2     subscript  s  1       SubCipher_{2}=ENC_{f_{2}}(k_{f_{2}},s_{1})   ∀    k   f  2      subscript  k   subscript  f  2     k_{f_{2}}   ∈   K   K   K    :    and save each    S  u  b  C  i  p  h  e   r  2       S  u  b  C  i  p  h  e   subscript  r  2     SubCipher_{2}   together with corresponding    k   f  2      subscript  k   subscript  f  2     k_{f_{2}}   in a set    H  2     subscript  H  2    H_{2}   .    For each possible guess on an intermediate state    s  2     subscript  s  2    s_{2}   compute the following:  1     S  u  b  C  i  p  h  e   r  2    =   D  E   C   b  2     (   k   b  2    ,   s  2   )          S  u  b  C  i  p  h  e   subscript  r  2      D  E   subscript  C   subscript  b  2      subscript  k   subscript  b  2     subscript  s  2       SubCipher_{2}=DEC_{b_{2}}(k_{b_{2}},s_{2})   ∀    k   b  2      subscript  k   subscript  b  2     k_{b_{2}}   ∈   K   K   K      and for each match between this    S  u  b  C  i  p  h  e   r  2       S  u  b  C  i  p  h  e   subscript  r  2     SubCipher_{2}   and the set    H  2     subscript  H  2    H_{2}   , check also whether  it matches with    T  1     subscript  T  1    T_{1}   and then save the combination of sub-keys together in a new set    T  2     subscript  T  2    T_{2}   .         2 ...        For each possible guess on an intermediate state    s  n     subscript  s  n    s_{n}   compute the following:  '''a)     S  u  b  C  i  p  h  e   r  n    =   D  E   C   b  n     (   k   b  n    ,   s  n   )          S  u  b  C  i  p  h  e   subscript  r  n      D  E   subscript  C   subscript  b  n      subscript  k   subscript  b  n     subscript  s  n       SubCipher_{n}=DEC_{b_{n}}(k_{b_{n}},s_{n})   ∀    k   b  n      subscript  k   subscript  b  n     k_{b_{n}}   ∈   K   K   K   '''  and for each match between this    S  u  b  C  i  p  h  e   r  n       S  u  b  C  i  p  h  e   subscript  r  n     SubCipher_{n}   and the set    H  n     subscript  H  n    H_{n}   , check also whether  it matches with    T   n  -  1      subscript  T    n  1     T_{n-1}   , save    k   b  n      subscript  k   subscript  b  n     k_{b_{n}}   and    k   f  n      subscript  k   subscript  f  n     k_{f_{n}}   in a new set      T  n     subscript  T  n    T_{n}   .           b)     S  u  b  C  i  p  h  e   r   n  +  1     =   E  N   C    f  n   +  1     (   k    f  n   +  1    ,   s  n   )          S  u  b  C  i  p  h  e   subscript  r    n  1       E  N   subscript  C     subscript  f  n   1      subscript  k     subscript  f  n   1     subscript  s  n       SubCipher_{n+1}=ENC_{f_{n}+1}(k_{f_{n}+1},s_{n})   ∀    k   f   n  +  1       subscript  k   subscript  f    n  1      k_{f_{n+1}}   ∈   K   K   K      and for each match between this    S  u  b  C  i  p  h  e   r   n  +  1        S  u  b  C  i  p  h  e   subscript  r    n  1      SubCipher_{n+1}   and the set    H   n  +  1      subscript  H    n  1     H_{n+1}   , check also  whether it matches with    T  n     subscript  T  n    T_{n}   . If this is the case then:"       Use the found combination of sub-keys    (   k   f  1    ,   k   b  1    ,   k   f  2    ,   k   b  2    ,  …  ,   k   f   n  +  1     ,   k   b   n  +  1     )      subscript  k   subscript  f  1     subscript  k   subscript  b  1     subscript  k   subscript  f  2     subscript  k   subscript  b  2    normal-…   subscript  k   subscript  f    n  1      subscript  k   subscript  b    n  1       (k_{f_{1}},k_{b_{1}},k_{f_{2}},k_{b_{2}},...,k_{f_{n+1}},k_{b_{n+1}})   on another pair of plaintext/ciphertext to verify the correctness of the key.  Note the nested element in the algorithm. The guess on every possible value on s j is done for each guess on the previous s j-1 . This make up an element of exponential complexity to overall time complexity of this MD-MITM attack.  MD-MITM complexity  Time complexity of this attack without brute force, is     2   |   k   f  1    |    +   2   |   k   b   n  +  1     |    +   2   |   s  1   |         superscript  2     subscript  k   subscript  f  1       superscript  2     subscript  k   subscript  b    n  1        superscript  2     subscript  s  1       2^{|k_{f_{1}}|}+2^{|k_{b_{n+1}}|}+2^{|s_{1}|}   ⋅    (   2   |   k   b  1    |    +   2   |   k   f  2    |    +   2   |   s  2   |       fragments  normal-(   superscript  2     subscript  k   subscript  b  1        superscript  2     subscript  k   subscript  f  2        superscript  2     subscript  s  2       (2^{|k_{b_{1}}|}+2^{|k_{f_{2}}|}+2^{|s_{2}|}   ⋅     (   2   |   k   b  2    |    +   2   |   k   f  3    |    +  …  )   )     fragments   fragments  normal-(   superscript  2     subscript  k   subscript  b  2        superscript  2     subscript  k   subscript  f  3       normal-…  normal-)   normal-)    (2^{|k_{b_{2}}|}+2^{|k_{f_{3}}|}+...))     Regarding the memory complexity, it is easy to see that     T  2   ,   T  3   ,  …  ,   T  n       subscript  T  2    subscript  T  3   normal-…   subscript  T  n     T_{2},T_{3},...,T_{n}   are much smaller than the first built table of candidate values    T  1     subscript  T  1    T_{1}   as i increases, the candidate values contained in    T  i     subscript  T  i    T_{i}   must satisfy more conditions thereby fewer candidates will pass on to the end destination    T  n     subscript  T  n    T_{n}   .  An upper bound of the memory complexity of MD-MITM is then       2   |   k   f  1    |    +   2   |   k   b   n  +  1     |    +    2    |  k  |   -   |   s  n   |     …        superscript  2     subscript  k   subscript  f  1       superscript  2     subscript  k   subscript  b    n  1          superscript  2      k      subscript  s  n      normal-…     2^{|k_{f_{1}}|}+2^{|k_{b_{n+1}}|}+2^{|k|-|s_{n}|}...     where   k   k   k   denotes the length of the whole key (combined).  The data complexity depends on the probability that a wrong key may pass (obtain a false positive), which is    1  /   2   |  l  |        1   superscript  2    l      1/2^{|l|}   , where   l   l   l   is the intermediate state in the first MITM phase. The size of the intermediate state and the block size is often the same! Considering also how many keys that are left for testing after the first MITM-phase, it is     2   |  k  |    /   2   |  l  |         superscript  2    k     superscript  2    l      2^{|k|}/2^{|l|}   .  Therefore after the first MITM phase, there are    2    |  k  |   -  b      superscript  2      k   b     2^{|k|-b}   ⋅     2   -  b    =   2    |  k  |   -   2  b          superscript  2    b     superscript  2      k     2  b       2^{-b}=2^{|k|-2b}   ,where $|b|$ is the block size.  For each time the final candidate value of the keys are tested on a new plaintext/ciphertext-pair, the amount of keys that will pass will be multiplied by the probability that a key may pass which is    1  /   2   |  b  |        1   superscript  2    b      1/2^{|b|}   .  The part of brute force testing (testing the candidate key on new (P,C) -pairs, have time complexity     2    |  k  |   -  b    +   2    |  k  |   -   2  b     +   2    |  k  |   -   3  b     +   2    |  k  |   -   4  b          superscript  2      k   b     superscript  2      k     2  b      superscript  2      k     3  b      superscript  2      k     4  b       2^{|k|-b}+2^{|k|-2b}+2^{|k|-3b}+2^{|k|-4b}   ...  ,clearly for increasing multiples of b in the exponent, number tends to zero.  The conclusion on data complexity is by similar reasoning restricted by that around ⌈     |  k  |   /  n        k   n    |k|/n   ⌉ (P,C) -pairs.  Below is a specific example of how a 2D-MITM is mounted:  A general example of 2D-MITM  This is a general description of how 2D-MITM is mounted on a block cipher encryption.  In Two-dimensional MITM (2D-MITM) the method is to reach 2 intermediate states inside the multiple encryption of the plaintext. See below figure:  thumb|upright=2|An illustration of 2D-MITM attack  2D-MITM algorithm  Compute the following:   '     S  u  b  C  i  p  h  e   r  1    =   E  N   C   f  1     (   k   f  1    ,  P  )          S  u  b  C  i  p  h  e   subscript  r  1      E  N   subscript  C   subscript  f  1      subscript  k   subscript  f  1    P      SubCipher_{1}=ENC_{f_{1}}(k_{f_{1}},P)   ∀    k   f  1      subscript  k   subscript  f  1     k_{f_{1}}   ∈   K   K   K    '    and save each    S  u  b  C  i  p  h  e   r  1       S  u  b  C  i  p  h  e   subscript  r  1     SubCipher_{1}   together with corresponding    k   f  1      subscript  k   subscript  f  1     k_{f_{1}}   in a set A    '''     S  u  b  C  i  p  h  e   r  2    =   D  E   C   b  2     (   k   b  2    ,  C  )          S  u  b  C  i  p  h  e   subscript  r  2      D  E   subscript  C   subscript  b  2      subscript  k   subscript  b  2    C      SubCipher_{2}=DEC_{b_{2}}(k_{b_{2}},C)   ∀    k   b  2      subscript  k   subscript  b  2     k_{b_{2}}   ∈   K   K   K       and save each    S  u  b  C  i  p  h  e   r  2       S  u  b  C  i  p  h  e   subscript  r  2     SubCipher_{2}   together with corresponding    k   b  2      subscript  k   subscript  b  2     k_{b_{2}}   in a set B.   For each possible guess on an intermediate state s between    S  u  b  C  i  p  h  e   r  1       S  u  b  C  i  p  h  e   subscript  r  1     SubCipher_{1}   and    S  u  b  C  i  p  h  e   r  2       S  u  b  C  i  p  h  e   subscript  r  2     SubCipher_{2}   compute the following:   1     S  u  b  C  i  p  h  e   r  1    =   D  E   C   b  1     (   k   b  1    ,  s  )          S  u  b  C  i  p  h  e   subscript  r  1      D  E   subscript  C   subscript  b  1      subscript  k   subscript  b  1    s      SubCipher_{1}=DEC_{b_{1}}(k_{b_{1}},s)   ∀    k   b  1      subscript  k   subscript  b  1     k_{b_{1}}   ∈   K   K   K     and for each match between this    S  u  b  C  i  p  h  e   r  1       S  u  b  C  i  p  h  e   subscript  r  1     SubCipher_{1}   and the set A, save    k   b  1      subscript  k   subscript  b  1     k_{b_{1}}   and    k   f  1      subscript  k   subscript  f  1     k_{f_{1}}   in a new set T.      2     S  u  b  C  i  p  h  e   r  2    =   E  N   C   f  2     (   k   f  2    ,  s  )          S  u  b  C  i  p  h  e   subscript  r  2      E  N   subscript  C   subscript  f  2      subscript  k   subscript  f  2    s      SubCipher_{2}=ENC_{f_{2}}(k_{f_{2}},s)   ∀    k   f  2      subscript  k   subscript  f  2     k_{f_{2}}   ∈   K   K   K     and for each match between this    S  u  b  C  i  p  h  e   r  2       S  u  b  C  i  p  h  e   subscript  r  2     SubCipher_{2}   and the set B, check also whether it matches with T for  if this is the case then:     Use the found combination of sub-keys    (   k   f  1    ,   k   b  1    ,   k   f  2    ,   k   b  2    )      subscript  k   subscript  f  1     subscript  k   subscript  b  1     subscript  k   subscript  f  2     subscript  k   subscript  b  2      (k_{f_{1}},k_{b_{1}},k_{f_{2}},k_{b_{2}})   on another pair of plaintext/ciphertext to verify the correctness of the key.  2D-MITM complexity  Time complexity of this attack without brute force, is     2   |   k   f  1    |    +   2   |   k   b  2    |    +    2   |  s  |    ⋅   (    2   |   k   b  1    |    +   2   |   k   f  2    |     )         superscript  2     subscript  k   subscript  f  1       superscript  2     subscript  k   subscript  b  2       normal-⋅   superscript  2    s       superscript  2     subscript  k   subscript  b  1       superscript  2     subscript  k   subscript  f  2          2^{|k_{f_{1}}|}+2^{|k_{b_{2}}|}+2^{|s|}\cdot\left(2^{|k_{b_{1}}|}+2^{|k_{f_{2}%
 }|}\right)   where |⋅| denotes the length.  Main memory consumption is restricted by the construction of the sets A and B where T is much smaller than the others.  For data complexity see subsection on complexity for MD-MITM.  See also   Space–time tradeoff  Birthday attack  Triple DES  Data Encryption Standard  GOST  Brute-force attack   References  "  Category:Cryptographic attacks      ↩   ↩  ↩  ↩      