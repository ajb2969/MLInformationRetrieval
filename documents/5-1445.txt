   Normalization property (abstract rewriting)      Normalization property (abstract rewriting)   In mathematical logic and theoretical computer science , a rewrite system has the strong normalization property or is terminating (in short: the normalization or the termination ) if every term is strongly normalizing ; that is, if every sequence of rewrites eventually terminates to an irreducible term also called a normal form . A rewrite system may also have the weak normalization property , meaning that for every term, there exists at least one particular sequence of rewrites that eventually yields a normal form, i.e., an irreducible term.  Lambda calculus  Untyped lambda calculus  The pure untyped lambda calculus does not satisfy the strong normalization property, and not even the weak normalization property. Consider the term     λ  x   .   x  x  x      formulae-sequence    λ  x     x  x  x     \lambda x.xxx   . It has the following rewrite rule: For any term   t   t   t   ,       (  λ  x  .  x  x  x  )   t  →  t  t  t     fragments   fragments  normal-(  λ  x  normal-.  x  x  x  normal-)   t  normal-→  t  t  t    (\mathbf{\lambda}x.xxx)t\rightarrow ttt     But consider what happens when we apply     λ  x   .   x  x  x      formulae-sequence    λ  x     x  x  x     \lambda x.xxx   to itself:           (  λ  x  .  x  x  x  )    (  λ  x  .  x  x  x  )      fragments   fragments  normal-(  λ  x  normal-.  x  x  x  normal-)    fragments  normal-(  λ  x  normal-.  x  x  x  normal-)     (\mathbf{\lambda}x.xxx)(\lambda x.xxx)          →   (  λ  x  .  x  x  x  )    (  λ  x  .  x  x  x  )    (  λ  x  .  x  x  x  )      fragments  normal-→   fragments  normal-(  λ  x  normal-.  x  x  x  normal-)    fragments  normal-(  λ  x  normal-.  x  x  x  normal-)    fragments  normal-(  λ  x  normal-.  x  x  x  normal-)     \rightarrow(\mathbf{\lambda}x.xxx)(\lambda x.xxx)(\lambda x.xxx)             →   (  λ  x  .  x  x  x  )    (  λ  x  .  x  x  x  )    (  λ  x  .  x  x  x  )    (  λ  x  .  x  x  x  )      fragments  normal-→   fragments  normal-(  λ  x  normal-.  x  x  x  normal-)    fragments  normal-(  λ  x  normal-.  x  x  x  normal-)    fragments  normal-(  λ  x  normal-.  x  x  x  normal-)    fragments  normal-(  λ  x  normal-.  x  x  x  normal-)     \rightarrow(\mathbf{\lambda}x.xxx)(\lambda x.xxx)(\lambda x.xxx)(\lambda x.xxx)             →   (  λ  x  .  x  x  x  )    (  λ  x  .  x  x  x  )    (  λ  x  .  x  x  x  )    (  λ  x  .  x  x  x  )    (  λ  x  .  x  x  x  )      fragments  normal-→   fragments  normal-(  λ  x  normal-.  x  x  x  normal-)    fragments  normal-(  λ  x  normal-.  x  x  x  normal-)    fragments  normal-(  λ  x  normal-.  x  x  x  normal-)    fragments  normal-(  λ  x  normal-.  x  x  x  normal-)    fragments  normal-(  λ  x  normal-.  x  x  x  normal-)     \rightarrow(\mathbf{\lambda}x.xxx)(\lambda x.xxx)(\lambda x.xxx)(\lambda x.xxx%
 )(\lambda x.xxx)              →   …      normal-→  absent  normal-…    \rightarrow\ \ldots\,        Therefore the term     (  λ  x  .  x  x  x  )    (  λ  x  .  x  x  x  )      fragments   fragments  normal-(  λ  x  normal-.  x  x  x  normal-)    fragments  normal-(  λ  x  normal-.  x  x  x  normal-)     (\lambda x.xxx)(\lambda x.xxx)   is neither strongly nor weakly normalizing.  Typed lambda calculus  Various systems of typed lambda calculus including the simply typed lambda calculus , Jean-Yves Girard 's System F , and Thierry Coquand 's calculus of constructions are strongly normalizing.  A lambda calculus system with the normalization property can be viewed as a programming language with the property that every program terminates . Although this is a very useful property, it has a drawback: a programming language with the normalization property cannot be Turing complete . That means that there are computable functions that cannot be defined in the simply typed lambda calculus (and similarly there are computable functions that cannot be computed in the calculus of constructions or System F ). As an example, it is impossible to define a self-interpreter in any of the calculi cited above. 1 2  See also   Typed lambda calculus  Rewriting  Total functional programming  Barendregt–Geuvers–Klop conjecture  Newman's lemma   References    316 pages.   "  Category:Lambda calculus  Category:Logic in computer science     Conor McBride (May 2003), "on termination" (posted to the Haskell-Cafe mailing list). ↩  Andrej Bauer (June 2014), Answer to: A total language that only a Turing complete language can interpret (posted to the Theoretical Computer Science StackExchange site) ↩     