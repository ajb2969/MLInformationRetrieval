<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="801">Block walking</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Block walking</h1>
<hr/>

<p>In <a href="combinatorics" title="wikilink">combinatorial mathematics</a>, <strong>block walking</strong> is a method useful in thinking about sums of combinations graphically as "walks" on <a href="Pascal's_triangle" title="wikilink">Pascal's triangle</a>. As the name suggests, block walking problems involve counting the number of ways an individual can walk from one corner A of a city block to another corner B of another city block given restrictions on the number of blocks the person may walk, the directions the person may travel, the distance from A to B, et cetera.</p>
<h2 id="an-example-block-walking-problem">An example block walking problem</h2>

<p>Suppose such an individual, say "Fred", must walk exactly <em>k</em> blocks to get to a point B that is exactly <em>k</em> blocks from A. It is convenient to regard Fred's starting point A as the <a href="Origin_(mathematics)" title="wikilink">origin</a>, 

<math display="inline" id="Block_walking:0">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>0</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">0</cn>
    <cn type="integer">0</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (0,0)
  </annotation>
 </semantics>
</math>

, of a <a href="lattice_(group)" title="wikilink">rectangular array</a> of <a href="lattice_points" title="wikilink">lattice points</a> and B as some lattice point 

<math display="inline" id="Block_walking:1">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>e</mi>
   <mo>,</mo>
   <mi>n</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>e</ci>
    <ci>n</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (e,n)
  </annotation>
 </semantics>
</math>

, e units "East" and <em>n</em> units "North" of A, where 

<math display="inline" id="Block_walking:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mo>+</mo>
    <mi>n</mi>
   </mrow>
   <mo>=</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <ci>e</ci>
     <ci>n</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e+n=k
  </annotation>
 </semantics>
</math>

 and both 

<math display="inline" id="Block_walking:3">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Block_walking:4">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 are nonnegative.</p>
<h3 id="solution-by-brute-force">Solution by brute force</h3>

<p>A <a href="brute_force_(mathematics)" title="wikilink">"brute force"</a> solution to this problem may be obtained by systematically counting the number of ways Fred can reach each point 

<math display="inline" id="Block_walking:5">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=(x_{1},x_{2})
  </annotation>
 </semantics>
</math>

 where</p>

<p>

<math display="block" id="Block_walking:6">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>≤</mo>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq x_{1}\leq e
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Block_walking:7">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>≤</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq x_{2}\leq n
  </annotation>
 </semantics>
</math>

</p>

<p>without backtracking (i.e. only traveling North or East from one point to another) until a pattern is observed. For example, the number of ways Fred could go from 

<math display="inline" id="Block_walking:8">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>0</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">0</cn>
    <cn type="integer">0</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (0,0)
  </annotation>
 </semantics>
</math>


 to 

<math display="inline" id="Block_walking:9">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>0</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">1</cn>
    <cn type="integer">0</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1,0)
  </annotation>
 </semantics>
</math>

 or (0,1) is exactly one; to (1,1) is two; to (2,0) or (0,2) is one; to (1,2) or (2,1) is three; and so on. Actually, you could receive the number of ways to get to a particular point by adding up the number of ways you can get to the point south of it and the number of ways you can get to the point west of it.(With the starting point being zero and all the points directly north and south of it one.) In general, one soon discovers that the number of paths from A to any such X corresponds to an entry of <a href="Pascal's_Triangle" title="wikilink">Pascal's Triangle</a>.</p>
<h3 id="combinatorial-solution">Combinatorial solution</h3>

<p>Since the problem involves counting a finite, discrete number of paths between lattice points, it is reasonable to assume a <a href="Combinatorial_proof" title="wikilink">combinatorial solution</a> exists to the problem. Towards this end, we note that for Fred to still be on a path that will take him from A to B over 

<math display="inline" id="Block_walking:10">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 blocks, at any point X he must either travel along one of the unit vectors  and . For the sake of clarity, let 

<math display="inline" id="Block_walking:11">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>0</mn>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>E</ci>
    <list>
     <cn type="integer">1</cn>
     <cn type="integer">0</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E=\langle 1,0\rangle
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Block_walking:12">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=\langle 0,1\rangle
  </annotation>
 </semantics>
</math>

. Given the coordinates of B, regardless of the path Fred travels he must walk along the vectors E and N exactly 

<math display="inline" id="Block_walking:13">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Block_walking:14">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 times, respectively. As such, the problem reduces to finding the number of distinct rearrangements of the word</p>

<p>

<math display="block" id="Block_walking:15">
 <semantics>
  <mrow>
   <mover>
    <mover accent="true">
     <mrow>
      <mi>E</mi>
      <mi>E</mi>
      <mi mathvariant="normal">⋯</mi>
      <mi>E</mi>
     </mrow>
     <mo movablelimits="false">⏞</mo>
    </mover>
    <mrow>
     <mi>e</mi>
     <mtext>times</mtext>
    </mrow>
   </mover>
   <munder>
    <munder accentunder="true">
     <mrow>
      <mi>N</mi>
      <mi>N</mi>
      <mi mathvariant="normal">⋯</mi>
      <mi>N</mi>
     </mrow>
     <mo movablelimits="false">⏟</mo>
    </munder>
    <mrow>
     <mi>n</mi>
     <mtext>times</mtext>
    </mrow>
   </munder>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-⏞</ci>
      <apply>
       <times></times>
       <ci>E</ci>
       <ci>E</ci>
       <ci>normal-⋯</ci>
       <ci>E</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>e</ci>
      <mtext>times</mtext>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-⏟</ci>
      <apply>
       <times></times>
       <ci>N</ci>
       <ci>N</ci>
       <ci>normal-⋯</ci>
       <ci>N</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <mtext>times</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overbrace{EE\cdots E}^{e\text{ times}}\underbrace{NN\cdots N}_{n\text{ times}}
  </annotation>
 </semantics>
</math>

, which is equivalent to finding the number of ways to choose 

<math display="inline" id="Block_walking:16">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 indistinct objects from a group of 

<math display="inline" id="Block_walking:17">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

. Thus the total number of paths Fred could take from A to B traveling only 

<math display="inline" id="Block_walking:18">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>


 blocks is</p>

<p>

<math display="block" id="Block_walking:19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mtable columnspacing="0.4em" rowspacing="0.2ex">
      <mtr>
       <mtd>
        <mi>k</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mi>e</mi>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mtable columnspacing="0.4em" rowspacing="0.2ex">
      <mtr>
       <mtd>
        <mi>k</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mi>n</mi>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mi>k</mi>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
     <mrow>
      <mrow>
       <mi>e</mi>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
      <mrow>
       <mi>n</mi>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">binomial</csymbol>
      <ci>k</ci>
      <ci>e</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">binomial</csymbol>
      <ci>k</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <factorial></factorial>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <factorial></factorial>
        <ci>e</ci>
       </apply>
       <apply>
        <factorial></factorial>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\left({{k}\atop{e}}\right)}={\left({{k}\atop{n}}\right)}=\frac{k!}{e!n!}.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="other-problems-with-known-block-walking-combinatorial-proofs">Other problems with known block walking combinatorial proofs</h2>
<ul>
<li>Proving that</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Block_walking:20">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mpadded width="+5pt">
     <msup>
      <mrow>
       <mo>(</mo>
       <mstyle scriptlevel="+1">
        <mtable columnspacing="0.4em" rowspacing="0.2ex">
         <mtr>
          <mtd>
           <mi>n</mi>
          </mtd>
         </mtr>
         <mtr>
          <mtd>
           <mi>k</mi>
          </mtd>
         </mtr>
        </mtable>
       </mstyle>
       <mo>)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mpadded>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mstyle scriptlevel="+1">
     <mtable columnspacing="0.4em" rowspacing="0.2ex">
      <mtr>
       <mtd>
        <mrow>
         <mn>2</mn>
         <mi>n</mi>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mi>n</mi>
       </mtd>
      </mtr>
     </mtable>
    </mstyle>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">binomial</csymbol>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">binomial</csymbol>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{k=0}^{n}{n\choose k}^{2}\ ={2n\choose n}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>can be done with a straightforward application of block walking.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>
</dd>
</dl>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Lattice_path" title="wikilink">Lattice path</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a class="uri" href="Category:Combinatorics" title="wikilink">Category:Combinatorics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Lehoczky, Sandor and Richard Rusczyk. <em>The Art of Problem Solving, Volume II</em>. Page 231.<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
