<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="185">Envy-free</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Envy-free</h1>
<hr/>

<p>An <strong>envy-free division</strong> is a division of a resource among several partners such that every partner feels that his allocated share is at least as good as any other share. The term is used especially in problems of <a href="fair_division" title="wikilink">fair division</a>.</p>

<p>The concept was introduced to the problem of <a href="fair_cake-cutting" title="wikilink">fair cake-cutting</a> by <a href="George_Gamow" title="wikilink">George Gamow</a> and <a href="Marvin_Stern" title="wikilink">Marvin Stern</a> in 1958.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Later, it was introduced to the economics problem of <a href="resource_allocation" title="wikilink">resource allocation</a> by <a href="Duncan_Foley" title="wikilink">Duncan Foley</a> in 1967.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Currently it is studied in both these contexts.</p>
<h2 id="definitions">Definitions</h2>

<p>Consider a set of <em>n</em> agents. Each agent <em>i</em> receives a certain allocation <em>A<sub>i</sub></em> (e.g. a piece of cake or a bundle of resources). Each agent <em>i</em> has a certain subjective preference relation i'' over pieces/bundles (i.e. 

<math display="inline" id="Envy-free:0">
 <semantics>
  <mrow>
   <mi>A</mi>
   <msub>
    <mo><</mo>
    <mi>i</mi>
   </msub>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <lt></lt>
     <ci>i</ci>
    </apply>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A<_{i}B
  </annotation>
 </semantics>
</math>

 means that agent <em>i</em> prefers piece B to piece A).</p>

<p>We say that agent <em>i</em> <strong>envies</strong> agent <em>k</em> if <em>i</em> prefers the piece of <em>k</em> over his own piece, i.e.:</p>
<dl>
<dd><dl>
<dd><em>A<sub>i</sub></em> i'' <em>A<sub>k</sub></em>
</dd>
</dl>
</dd>
</dl>

<p>Specifically, if the preference of the agent is determined by a value functions <em>V<sub>i</sub></em>, then we say that agent <em>i</em> envies agent <em>k</em> if:</p>
<dl>
<dd><dl>
<dd><em>V<sub>i</sub></em>(<em>A<sub>i</sub></em>) i<em>(</em>A<sub>k</sub>'')
</dd>
</dl>
</dd>
</dl>

<p>An allocation {<em>A<sub>1</sub></em>, ..., <em>A<sub>n</sub></em>} is called <strong>envy-free</strong> if there is no agent that envies another agent.</p>

<p>In the context of <a href="fair_cake-cutting" title="wikilink">fair cake-cutting</a>, envy-freeness means that each partner believes that their share is at least as <em>large</em> as any other share. In the context of <a href="chore_division" title="wikilink">chore division</a>, envy-freeness means that each partner believes their share is at least as <em>small</em> as any other share. The crucial issue is that no partner would wish to swap their share with any other partner.</p>
<h2 id="envy-free-cake-cutting">Envy-free cake-cutting</h2>

<p>When there are two partners, the <a href="divide_and_choose" title="wikilink">divide and choose</a> protocol guarantees an envy-free division of a cake. When there are three or more partners, envy-free cake-cutting becomes much more challenging. Two major variants of the problem have been studied:</p>
<ol>
<li>In one variant, the pieces must be connected. The 'cake' can be considered a 1-dimensional interval, and each partner must receive a single interval. If there are <em>n</em> partners, only <em>n</em>-1 cuts are needed.</li>
<li>In another variant, the pieces may be disconnected, i.e. each partner can receive any number of pieces.</li>
</ol>
<h2 id="connected-pieces">Connected pieces</h2>
<h3 id="existence-proof">Existence proof</h3>

<p>An envy-free division for <em>n</em> agents with connected pieces always exists under the following mild assumptions:<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<ul>
<li>No agent prefers an empty piece over a non-empty piece.</li>
<li>The preferences of the agents are continuous.</li>
</ul>

<p>Note that it is <em>not</em> required that the preferences of the agents are represented by an <a href="additive_map" title="wikilink">additive function</a>.</p>

<p>The main concept in the proof is the <em><a class="uri" href="simplex" title="wikilink">simplex</a> of partitions</em>. Suppose the cake is the interval [0,1]. Each partition with connected pieces can be uniquely represented by <em>n</em>-1 numbers in [0,1] which represent the cut locations. The union of all partitions is a simplex.</p>

<p>For each partition, each agent has one or more pieces which he weakly prefers. E.g., for the partition represented by "0.3,0.5", one agent may prefer piece #1 (the piece [0,0.3]) while another agent might prefer piece #2 (the piece [0.3,0.5]) while a third agent might prefer both piece #1 and piece #2 (which means that he is indifferent between them but likes any of them more than piece #3).</p>

<p>For every agent, the partition simplex is covered by <em>n</em> parts, possibly overlapping at their boundaries, such that for all partitions in part <em>i</em>, the agent prefers piece <em>i</em>. In the interior of part <em>i</em>, the agent prefers <em>only</em> piece <em>i</em>, while in the boundary of part <em>i</em>, the agent also prefers some other pieces. So for every <em>i</em>, there is a certain region in the partition simplex in which at least one agent prefers only piece <em>i</em>. Call this region <em>U</em><sub><em>i</em></sub>. Using a certain topological lemma, it is possible to prove that the intersection of all <em>U</em><sub><em>i</em></sub>'s is non-empty. Hence, there is a partition in which every piece is the unique preference of an agent. Since the number of pieces equals the number of agents, we can allocate each piece to the agent that prefers it and get an envy-free allocation.</p>
<h3 id="procedures">Procedures</h3>

<p>For three agents, an envy-free division can be found by the <a href="Stromquist_three-knives_procedure" title="wikilink">Stromquist three-knives procedure</a>.</p>

<p>For <em>n</em> agents, an approximate envy-free division can be found by <a href="Simmons–Su_protocols#Cake_cutting" title="wikilink">Simmons' cake-cutting protocol</a>. The protocol uses a <em>simplex of partitions</em> similar to the one used in Stromquist's existence proof. It generates a sequence of partitions which converges to an envy-free partition. Alternatively, for every desired tolerance, it is possible to find a division which is envy-free up to that tolerance. E.g, if land is divided and the partners agree that a difference of 1 centimeter is not relevant to them, then it is possible to find an envy-free division which is envy-free plus-or-minus 1 centimeter.</p>
<h3 id="hardness-result">Hardness result</h3>

<p>An envy-free division with connected pieces for 3 or more agents cannot be found by a finite protocol. <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The reason this result doesn't contradict the previously mentioned algorithms is that they are not finite in the mathematical sense.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>The impossibility proof uses a <em>rigid measure system</em> (RMS) - a system of <em>n</em> value measures, for which an envy-free division must cut the cake at very specific locations. Then, finding an envy-free division amounts to finding these specific locations. Assuming the cake is the real interval [0,1], finding an envy-free division using queries to the agents is equivalent to finding a real number in the interval [0,1] using yes/no questions, which obviously might take an infinite time.</p>

<p>A RMS for 3 agents can be constructed as follows. Let x, y, s, and t be parameters satisfying:</p>
<ul>
<li>0 &lt; x &lt; y &lt; 1</li>
<li>0 &lt; s &lt; 1/3 &lt; t &lt; 1/2</li>
<li>s + 2t = 1.</li>
</ul>

<p>Construct a set of three measures with these two properties:</p>
<ol>
<li>The density of each measure is always strictly between √2/2 and √2.</li>
<li>The values of the pieces determined by <em>x</em> and <em>y</em> are as in the table:</li>
</ol>
<dl>
<dd>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Agent</p></th>
<th style="text-align: left;">
<p>[0,<em>x</em>]</p></th>
<th style="text-align: left;">
<p>[<em>x</em>,<em>y</em>]</p></th>
<th style="text-align: left;">
<p>[<em>y</em>,1]</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>A</p></td>
<td style="text-align: left;">
<p><em>t</em></p></td>
<td style="text-align: left;">
<p><em>t</em></p></td>
<td style="text-align: left;">
<p><em>s</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>B</p></td>
<td style="text-align: left;">
<p><em>s</em></p></td>
<td style="text-align: left;">
<p><em>t</em></p></td>
<td style="text-align: left;">
<p><em>t</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>C</p></td>
<td style="text-align: left;">
<p><em>t</em></p></td>
<td style="text-align: left;">
<p><em>s</em></p></td>
<td style="text-align: left;">
<p><em>t</em></p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>Then, every envy-free division among the three agents A, B and C must have cuts at <em>x</em> and <em>y</em> (there are exactly two such divisions). All other options lead to envy: if cuts are made to the left of <em>x</em> and to the right of <em>y</em>, then agents A and B both insist on getting the middle piece; if cuts are made to the right of <em>x</em> and to the left of <em>y</em>, then no agent would accept the middle piece; if cuts are made to the right of <em>x</em> and to the right of <em>y</em>, then both A and C prefer the leftmost piece to the rightmost piece, so agent B must agree to accept the rightmost piece, but in that case, both A and C insist on the leftmost piece. The fourth case (cuts to the left of <em>x</em> and to the left of <em>y</em>) is symmetric.</p>

<p>For every RMS, every agent <em>i</em> and every constant ε&gt;0, there is a slightly different RMS with the following properties:</p>
<ul>
<li>The new value measure of agent <em>i</em> is completely identical to his old value measure;</li>
<li>The new value measures of the other two agents are identical to their old value measure everywhere <em>except</em> in an ε-neighbourhood of <em>x</em> and <em>y</em>.</li>
</ul>

<p>This implies that, if all queries answered so far were outside the ε-neighbourhood of <em>x</em> and <em>y</em>, then agent <em>i</em> has no way to know whether he is in the old RMS or in the new RMS.</p>

<p>Equipped with this knowledge, an adversary can trick every envy-free division protocol to go on forever:</p>
<ol>
<li>Start with any RMS, e.g. with parameters <em>x</em>=1/3, <em>y</em>=2/3, <em>s</em>=0.3 and <em>t</em>=0.35.</li>
<li>As long as the protocol makes cuts at points other than <em>x</em> and <em>y</em>, let it continue.</li>
<li>Whenever the protocol asks agent <em>i</em> to make a cut at <em>x</em> or <em>y</em>, switch to a different RMS with <em>x'≠x</em> and <em>y'≠y</em>, making sure that the values are the same for all previously made cuts.</li>
</ol>

<p>Thus the protocol can never make cuts at the correct <em>x</em> and <em>y</em> required for an envy-free division.</p>
<h3 id="hardness-of-approximation">Hardness of approximation</h3>

<p>While an envy-free division with connected pieces can be approximated to any precision using a finite protocol (e.g. <a href="Simmons–Su_protocols" title="wikilink">Simmons–Su protocols</a>), the approximation might take a long time. In particular:<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<ul>
<li>When the utility functions are accessible only through oracles, the number of queries for achieving an envy of less than ϵ is 

<math display="inline" id="Envy-free:1">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mfrac>
     <mn>1</mn>
     <msup>
      <mi>ϵ</mi>
      <mi>n</mi>
     </msup>
    </mfrac>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ϵ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(\frac{1}{\epsilon^{n}})
  </annotation>
 </semantics>
</math>

.</li>
<li>When the utility functions are given explicitly by polynomial-time algorithms, the envy-free cake-cutting problem has the same complexity as finding a <a href="Brouwer_fixed-point" title="wikilink">Brouwer fixed-point</a>, i.e. <a class="uri" href="PPAD" title="wikilink">PPAD</a>-complete.</li>
</ul>
<h2 id="disconnected-pieces">Disconnected pieces</h2>
<h3 id="procedures-1">Procedures</h3>

<p>For 3 partners, the <a href="Selfridge–Conway_discrete_procedure" title="wikilink">Selfridge–Conway discrete procedure</a> guarantees an envy-free division with at most 5 cuts.</p>

<p>For 4 partners, The <a href="Brams–Taylor–Zwicker_procedure" title="wikilink">Brams–Taylor–Zwicker procedure</a> guarantees an envy-free division with at most 11 cuts.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>For 5 or more partners, the only known exact algorithms are finite but unbounded - there is no fixed bound on the number of cuts required.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> There are three such algorithms:</p>
<ul>
<li>The <a href="Brams–Taylor_protocol" title="wikilink">Brams–Taylor protocol</a>, first published in a 1995 paper and later in a 1996 book.</li>
<li>The <a href="Robertson-Webb_protocol" title="wikilink">Robertson-Webb protocol</a>, first published in a 1997 paper and later in a 1998 book.</li>
<li>The Pikhurko protocol,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> published in 2000.</li>
</ul>

<p>Although the protocols are different, the main idea behind them is similar: Divide the cake to a finite but unbounded number of "crumbs", each of which is so small that its value for all partners is negligible. Then combine the crumbs in a sophisticated way to get the desired division.</p>
<h3 id="approximations-and-partial-solutions">Approximations and partial solutions</h3>

<p>A <a href="Last_diminisher#Approximate-envy-free_version" title="wikilink">reentrant variant of the Last Diminisher protocol</a> finds an additive approximation to an envy-free division in bounded time. Specifically, for every constant 

<math display="inline" id="Envy-free:2">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>ϵ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon>0
  </annotation>
 </semantics>
</math>

, it returns a division in which the value of each partner is at least the largest value minus 

<math display="inline" id="Envy-free:3">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

, in time 

<math display="inline" id="Envy-free:4">
 <semantics>
  <mrow>
   <msup>
    <mi>n</mi>
    <mn>2</mn>
   </msup>
   <mo>/</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{2}/\epsilon
  </annotation>
 </semantics>
</math>

.</p>

<p>If the valuation functions of the agents are piecewise-linear, there is an algorithm which is polynomial in the size of the representation of the valuation functions.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h3 id="hardness-result-1">Hardness result</h3>

<p>Every envy-free procedure for <em>n</em> people requires at least Ω(<em>n</em><sup>2</sup>) queries.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> The proof relies on a careful analysis of the amount of information the algorithm has on each partner.</p>

<p><strong>A.</strong> Assume that the cake is the 1-dimensional interval [0,1], and that the value of the entire cake for each of the partners is normalized 1. In each step, the algorithm asks a certain partner either to <em>evaluate</em> a certain interval contained in [0,1], or to <em>mark</em> an interval with a specified value. In both cases, the algorithm gathers information only about intervals whose end-points were mentioned in the query or in the reply. Let's call these endpoints <em>landmarks</em>. Initially the only landmarks of <em>i</em> are 0 and 1 since the only thing the algorithm knows about partner <em>i</em> is that <em>v</em><sub><em>i</em></sub>([0,1])=1. If the algorithm asks partner <em>i</em> to evaluate the interval [0.2,1], then after the reply the landmarks of <em>i</em> are {0,0.2,1}. The algorithm can calculate <em>v</em><sub><em>i</em></sub>([0,0.2]), but not the value of any interval whose endpoint is different than 0.2. The number of landmarks increases by at most 2 in each query. In particular, the value of the interval [0,0.2] might be concentrated entirely near 0, or entirely near 0.2, or anywhere in between.</p>

<p><strong>B.</strong> An interval between two consecutive landmarks of partner <em>i</em> is called a <em>landmark-interval</em> of partner <em>i</em>, When the algorithm decides to allocate a piece of cake to partner <em>i</em>, it must allocate a piece whose total value for <em>i</em> is at least as large as any landmark-interval of <em>i</em>. The proof is by contradiction: suppose there is a certain landmark-interval <em>J</em> whose value for <em>i</em> is more than the value actually allocated to <em>i</em>. Some other partner, say <em>j</em>, will necessarily receive some part of the landmark-interval <em>J</em>. By paragraph A, it is possible that all the value of interval <em>J</em> is concentrated inside the share allocated to partner <em>j</em>. Thus, <em>i</em> envies <em>j</em> and the division is not envy-free.</p>

<p><strong>C.</strong> Suppose all partners answer all queries <em>as if</em> their value measure is uniform (i.e. the value of an interval is equal to its length). By paragraph B, the algorithm may assign a piece to partner <em>i</em>, only if it is longer than all landmark-intervals of <em>i</em>. At least <em>n</em>/2 partners must receive an interval with a length of at most 2/<em>n</em>; hence all their landmark-intervals must have a length of at most 2/<em>n</em>; hence they must have at least <em>n</em>/2 landmark-intervals; hence they must have at least <em>n</em>/2 landmarks.</p>

<p><strong>D.</strong> Each query answered by partner <em>i</em> involves at most two new endpoints, so it increases the number of landmarks of <em>i</em> by at most 2. Hence, in the case described by paragraph C, the algorithm must ask each of <em>n</em>/2 partners, at least <em>n</em>/4 queries. The total number of queries is thus at least <em>n</em><sup>2</sup>/8 = Ω(<em>n</em><sup>2</sup>).</p>

<p>It is an open question whether a bounded algorithm exists for arbitrary valuation functions. Thus there is a huge gap between the lower bound of Ω(<em>n</em><sup>2</sup>) and the best currently known algorithm which is finite but unbounded.</p>
<h3 id="existence-proofs-and-variants">Existence proofs and variants</h3>

<p>In addition to the general existence proofs implied by the algorithms described above, there are proofs for the existence of envy-free partitions with additional properties:</p>
<ul>
<li>There exists a <a href="perfect_division" title="wikilink">perfect division</a>, which is in particular envy-free.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></li>
<li>There exists an envy-free division which is also <a href="Pareto_efficient" title="wikilink">Pareto efficient</a>; See <a href="Efficient_cake-cutting#PEEF_division_-_general_cakes" title="wikilink">Efficient cake-cutting#PEEF division - general cakes</a>.</li>
</ul>

<p>Both proofs work only for additive and non-atomic value measures, and rely on the ability to give each partner a large number of disconnected pieces.</p>
<h2 id="weighted-envy-free-division">Weighted-envy-free division</h2>

<p>A common generalization of the envy-free criterion is that each of the partners has a different entitlement. I.e., for every partner <em>i</em> there is a weight <em>w<sub>i</sub></em> describing the fraction of the cake that he is entitled to receive (the sum of all <em>w<sub>i</sub></em> is 1). Then a weighted-envy-free division is defined as:</p>
<dl>
<dd>For every agent <em>i</em> with value measure <em>V</em>, and for every other agent <em>k</em>:
<dl>
<dd><dl>
<dd><em>V(X<sub>i</sub>) / V(X<sub>k</sub>) ≥ w<sub>i</sub> / w<sub>k</sub></em>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>

<p>I.e., every partner thinks that his allocation relative to his entitlement is at least as large as any other allocation relative to the other partner's entitlement.</p>

<p>When all weights are the same (and equal to 1/<em>n</em>), this definition reduces to the standard definition of envy-freeness.</p>

<p>When the pieces may be disconnected, a weighted envy-free division can be found constructively using the <a href="Robertson-Webb_protocol" title="wikilink">Robertson-Webb protocol</a>, for any set of weights.</p>

<p>But when the pieces must be connected, only non-constructive existence proofs are reported. A weighted envy-free division is known to exist in the following cases (each case generalizes the previous case):</p>
<ul>
<li>Additive value functions, 1-dimensional cake (interval), and the pieces must be connected intervals.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></li>
<li>Additive value functions, multi-dimensional <a class="uri" href="simplex" title="wikilink">simplex</a> cake, and the pieces must be simplexes.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> The proof uses <a href="Sperner's_theorem" title="wikilink">Sperner's theorem</a>, the <a href="K-K-M_lemma" title="wikilink">K-K-M lemma</a>, <a href="Gale's_covering_lemma" title="wikilink">Gale's covering lemma</a> and <a href="Ky_Fan" title="wikilink">Ky Fan</a>'s lemma on <a href="coincidence_point" title="wikilink">coincidence points</a>.</li>
<li>Non-additive value functions, multi-dimensional <a class="uri" href="simplex" title="wikilink">simplex</a> cake, and the pieces must be <a href="polytope" title="wikilink">polytopes</a>.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></li>
</ul>
<h2 id="envy-free-chore-division">Envy-free chore division</h2>

<p><em>Chore division</em> is a division of a heterogeneous good whose value is negative, such that each partner wants as little as possible. There are algorithms for envy-free chore division for 4 partners<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> and for <em>n</em> partners.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<h2 id="summarizing-table">Summarizing table</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p># agents</p></th>
<th style="text-align: left;">
<p>Connected pieces</p></th>
<th style="text-align: left;">
<p>General pieces</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p><a href="Divide_and_choose" title="wikilink">Divide and choose</a></p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p><a href="Stromquist_three-knives_procedure" title="wikilink">Stromquist three-knives procedure</a></p></td>
<td style="text-align: left;">
<p><a href="Selfridge–Conway_discrete_procedure" title="wikilink">Selfridge–Conway discrete procedure</a> (at most 5 cuts).</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p><a href="Brams–Taylor–Zwicker_moving_knives_procedure" title="wikilink">Brams–Taylor–Zwicker moving knives procedure</a> (at most 11 cuts).</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>5+</p></td>
<td style="text-align: left;">
<p><a href="Simmons–Su_protocols#Cake-cutting" title="wikilink">Simmons' protocol</a><br/>
- An infinite protocol.<br/>
- Can be used to approximate envy-freeness to any ratio.</p></td>
<td style="text-align: left;">
<p><a href="Brams–Taylor_procedure" title="wikilink">Brams and Taylor (1995)</a>;<br/>
<a href="Robertson–Webb_protocol" title="wikilink">Robertson and Webb (1998)</a>.<br/>
- Both algorithms require a finite but unbounded number of cuts.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Hardness</p></td>
<td style="text-align: left;">
<p>All algorithms for <em>n</em> ≥ 3 must be infinite (Stromquist, 2008).</p></td>
<td style="text-align: left;">
<p>All algorithms must use at least Ω(<em>n</em><sup>2</sup>) steps (Procaccia, 2009).</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Variants</p></td>
<td style="text-align: left;">
<p>A weighted envy-free division exists for arbitrary weights (Idzik, 1995),<br/>
even when the cake and pieces are simplexes (Idzik and Ichiishi, 1996),<br/>
and even with non-additive preferences (Dall'Aglio and Maccheroni, 2009).</p></td>
<td style="text-align: left;">
<p>Robertson-Webb can find weighted-envy-free divisions for arbitrary weights.<br/>
 A <a href="perfect_division" title="wikilink">perfect division</a> exists (Dubins&amp;Spanier;, 1961).<br/>
An envy-free and <a href="efficient_cake-cutting" title="wikilink">efficient cake-cutting</a> exists (Weller, 1985).</p></td>
</tr>
</tbody>
</table>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Proportional_division#Comparison_with_Envy-freeness_and_other_criteria" title="wikilink">Proportional division#Comparison with Envy-freeness and other criteria</a></li>
<li><a class="uri" href="Group-envy-free" title="wikilink">Group-envy-free</a></li>
<li><a href="Fair_pie-cutting" title="wikilink">Fair pie-cutting</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.math.hmc.edu/~su/fairdivision/calc/">Fair Division Calculator</a> - an applet for calculating envy-free division for cakes, chores, rooms and rents.</li>
<li><a href="http://math.stackexchange.com/questions/621306/envy-free-matching">Envy-free matching</a></li>
<li></li>
<li></li>
<li><a href="http://www.citeulike.org/user/erelsegal-halevi/tag/envy-free">Other research papers on envy-free division</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Fair_division" title="wikilink">Category:Fair division</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="Stromquist_three-knives_procedure" title="wikilink">Stromquist three-knives procedure</a> requires the three agents to adjust their knives whenever the sword of the referee moves. Since the sword moves continuously, the number of steps required is an uncountable infinity. <a href="Simmons–Su_protocols#Cake_cutting" title="wikilink">Simmons cake-cutting protocol</a> converges to an envy-free division, but the convergence might require an infinite number of steps.<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8">S. J. Brams, M. A. Jones, and C. Klamler, "Better ways to cut a cake," Notices of the AMS, 2005. [Online]. Available: <a class="uri" href="http://www.ams.org/notices/200611/fea-brams.pdf">http://www.ams.org/notices/200611/fea-brams.pdf</a><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
</ol>
</section>
</body>
</html>
