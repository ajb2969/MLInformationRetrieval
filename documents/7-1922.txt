   Mason's gain formula      Mason's gain formula  '''Mason's gain formula''' (MGF) is a method for finding the transfer  function ofÂ aÂ linear signal-flow  graph (SFG).Â Â TheÂ formulaÂ wasÂ derivedÂ by Samuel  Jefferson  Mason , 1 whomÂ itÂ isÂ alsoÂ namedÂ after.Â MGFÂ isÂ anÂ alternateÂ methodÂ toÂ findingÂ theÂ transferÂ functionÂ algebraicallyÂ byÂ labelingÂ eachÂ signal,Â writingÂ downÂ theÂ equationÂ forÂ howÂ thatÂ signalÂ dependsÂ onÂ otherÂ signals,Â andÂ thenÂ solvingÂ theÂ multipleÂ equationsÂ forÂ theÂ outputÂ signalÂ inÂ termsÂ ofÂ theÂ inputÂ signal.Â Â MGFÂ providesÂ aÂ stepÂ byÂ stepÂ methodÂ toÂ obtainÂ theÂ transferÂ functionÂ fromÂ aÂ SFG.Â Â Often,Â MGFÂ canÂ beÂ determinedÂ byÂ inspectionÂ ofÂ theÂ SFG.Â Â TheÂ methodÂ canÂ easilyÂ handleÂ SFGsÂ withÂ manyÂ variablesÂ andÂ loopsÂ includingÂ loopsÂ withÂ innerÂ loops.Â Â MGFÂ comesÂ upÂ oftenÂ inÂ Â theÂ contextÂ of control  systems andÂ digitalÂ filtersÂ becauseÂ controlÂ systemsÂ andÂ digitalÂ filtersÂ areÂ oftenÂ representedÂ byÂ SFGs.  Formula  The gain formula is as follows:      G  =    y  out    y  in    =     âˆ‘   k  =  1   N     G  k    Î”  k      Î”          G     subscript  y  out    subscript  y  in             superscript   subscript     k  1    N      subscript  G  k    subscript  normal-Î”  k     normal-Î”      G=\frac{y_{\text{out}}}{y_{\text{in}}}=\frac{\sum_{k=1}^{N}{G_{k}\Delta_{k}}}{%
 \Delta\ }         Î”  =      1  -   âˆ‘   L  i     +   âˆ‘    L  i    L  j      -   âˆ‘    L  i    L  j    L  k      +  â‹¯  +     (   -  1   )   m    âˆ‘  â‹¯    +  â‹¯       normal-Î”          1     subscript  L  i          subscript  L  i    subscript  L  j           subscript  L  i    subscript  L  j    subscript  L  k      normal-â‹¯     superscript    1   m     normal-â‹¯    normal-â‹¯     \Delta=1-\sum L_{i}+\sum L_{i}L_{j}-\sum L_{i}L_{j}L_{k}+\cdots+(-1)^{m}\sum%
 \cdots+\cdots     where:   Î” = the determinant of the graph.  y in = input-node variable  y out = output-node variable  G = complete gain between y in and y out  N = total number of forward paths between y in and y out  G k = path gain of the k th forward path between y in and y out  L i = loop gain of each closed loop in the system  L i L j = product of the loop gains of any two non-touching loops (no common nodes)  L i L j L k = product of the loop gains of any three pairwise nontouching loops  Î” k = the cofactor value of Î” for the k th forward path, with the loops touching the k th forward path removed. *   definitions 2   Path: a continuous set of branches traversed in the direction that they indicate.  Forward path: A path from an input node to an output node in which no node is touched more than once.  Loop: A path that originates and ends on the same node in which no node is touched more than once.  Path gain: the product of the gains of all the branches in the path.  Loop gain: the product of the gains of all the branches in the loop.   Procedure  To use this technique,   Make a list of all forward paths, and their gains, and label these G k .  Make a list of all the loops and their gains, and label these L i (for i loops). Make a list of all pairs of non-touching loops, and the products of their gains ( L i L j ). Make a list of all pairwise non-touching loops taken three at a time ( L i L j L k ), then four at a time, and so forth, until there are no more.  Compute the determinant Î” and cofactors Î” k .  Apply the formula.   Examples  Circuit containing two-port  (Figure)  lrft|thumb|400px| Signal flow graph of a circuit containing a two port. The forward path from input to output is shown in a different color.   The transfer function from V in to V 2 is desired.  There is only one forward path:  :* V in to V 1 to I 2 to V 2 with gain     G  1   =   -    y  21     R  L           subscript  G  1        subscript  y  21    subscript  R  L       G_{1}=-y_{21}R_{L}\,     There are three loops:  :* V 1 to I 1 to V 1 with gain     L  1   =   -    R   i  n      y  11           subscript  L  1        subscript  R    i  n     subscript  y  11       L_{1}=-R_{in}y_{11}\,     :* V 2 to I 2 to V 2 with gain     L  2   =   -    R  L     y  22           subscript  L  2        subscript  R  L    subscript  y  22       L_{2}=-R_{L}y_{22}\,     :* V 1 to I 2 to V 2 to I 1 to V 1 with gain     L  3   =    y  21    R  L    y  12     R   i  n           subscript  L  3      subscript  y  21    subscript  R  L    subscript  y  12    subscript  R    i  n       L_{3}=y_{21}R_{L}y_{12}R_{in}\,         Î”  =    1  -   (    L  1   +   L  2   +   L  3    )    +   (    L  1    L  2    )        normal-Î”      1     subscript  L  1    subscript  L  2    subscript  L  3        subscript  L  1    subscript  L  2       \Delta=1-(L_{1}+L_{2}+L_{3})+(L_{1}L_{2})\,   note: L 1 and L 2 do not touch each other whereas L 3 touches both of the other loops.       Î”  1   =   1        subscript  normal-Î”  1   1    \Delta_{1}=1\,   note: the forward path touches all the loops so all that is left is 1 .      G  =     G  1    Î”  1    Î”   =     -    y  21    R  L        1  +    R   i  n     y  11    +    R  L    y  22     -    y  21    R  L    y  12    R   i  n      +    R   i  n     y  11    R  L    y  22             G       subscript  G  1    subscript  normal-Î”  1    normal-Î”               subscript  y  21    subscript  R  L           1     subscript  R    i  n     subscript  y  11       subscript  R  L    subscript  y  22        subscript  y  21    subscript  R  L    subscript  y  12    subscript  R    i  n         subscript  R    i  n     subscript  y  11    subscript  R  L    subscript  y  22         G=\frac{G_{1}\Delta_{1}}{\Delta}=\frac{-y_{21}R_{L}}{1+R_{in}y_{11}+R_{L}y_{22%
 }-y_{21}R_{L}y_{12}R_{in}+R_{in}y_{11}R_{L}y_{22}}\,   {{-}}  Digital IIR biquad filter  (Figure)  The signal flow graph (SFG) for a digital infinite impulse response bi-quad filter. This SFG has three forward paths and two loops.   Digital filters are often diagramed as signal flow graphs.   There are two loops       L  1   =   -    a  1     Z   -  1            subscript  L  1        subscript  a  1    superscript  Z    1        L_{1}=-a_{1}Z^{-1}\,          L  2   =   -    a  2     Z   -  2            subscript  L  2        subscript  a  2    superscript  Z    2        L_{2}=-a_{2}Z^{-2}\,            Î”  =   1  -   (    L  1   +   L  2    )        normal-Î”    1     subscript  L  1    subscript  L  2       \Delta=1-(L_{1}+L_{2})\,   Note, the two loops touch so there is no term for their product.   There are three forward paths       G  0   =    b  0         subscript  G  0    subscript  b  0     G_{0}=b_{0}\,          G  1   =    b  1     Z   -  1           subscript  G  1      subscript  b  1    superscript  Z    1       G_{1}=b_{1}Z^{-1}\,          G  2   =    b  2     Z   -  2           subscript  G  2      subscript  b  2    superscript  Z    2       G_{2}=b_{2}Z^{-2}\,         All the forward paths touch all the loops so     Î”  0   =   Î”  1   =   Î”  2   =   1          subscript  normal-Î”  0    subscript  normal-Î”  1         subscript  normal-Î”  2        1     \Delta_{0}=\Delta_{1}=\Delta_{2}=1\,          G  =       G  0    Î”  0    +    G  1    Î”  1    +    G  2    Î”  2     Î”        G         subscript  G  0    subscript  normal-Î”  0       subscript  G  1    subscript  normal-Î”  1       subscript  G  2    subscript  normal-Î”  2     normal-Î”     G=\frac{G_{0}\Delta_{0}+G_{1}\Delta_{1}+G_{2}\Delta_{2}}{\Delta}\,         G  =      b  0   +    b  1    Z   -  1     +    b  2    Z   -  2       1  +    a  1    Z   -  1     +    a  2    Z   -  2            G       subscript  b  0      subscript  b  1    superscript  Z    1        subscript  b  2    superscript  Z    2        1     subscript  a  1    superscript  Z    1        subscript  a  2    superscript  Z    2         G=\frac{b_{0}+b_{1}Z^{-1}+b_{2}Z^{-2}}{1+a_{1}Z^{-1}+a_{2}Z^{-2}}\,   {{-}}  Servo  (Figure)  Angular position servo and signal flow graph. Î¸ C = desired angle command, Î¸ L = actual load angle, K P = position loop gain, V Ï‰C = velocity command, V Ï‰M = motor velocity sense voltage, K V = velocity loop gain, V IC = current command, V IM = current sense voltage, K C = current loop gain, V A = power amplifier output voltage, V M = effective voltage across the inductance, L M = motor inductance, I M = motor current, R M = motor resistance, R S = current sense resistance, K M = motor torque constant (Nm/amp), T = torque, M = moment of inertia of all rotating components Î± = angular acceleration, Ï‰ = angular velocity, Î² = mechanical damping, G M = motor back EMF constant, G T = tachometer conversion gain constant,. There is one forward path (shown in a different color) and six feedback loops. The drive shaft assumed to be stiff enough to not treat as a spring. Constants are shown in black and variables in purple.   The signal flow graph has six loops. They are:  :*     L  0   =   -    Î²   s  M           subscript  L  0       Î²    s  M       L_{0}=-\frac{\beta}{sM}\,     :*     L  1   =     -   (    R  M   +   R  S    )     s   L  M           subscript  L  1          subscript  R  M    subscript  R  S       s   subscript  L  M       L_{1}=\frac{-(R_{M}+R_{S})}{sL_{M}}\,     :*     L  2   =    -    G  M    K  M       s  2    L  M   M         subscript  L  2          subscript  G  M    subscript  K  M        superscript  s  2    subscript  L  M   M      L_{2}=\,\frac{-G_{M}K_{M}}{s^{2}L_{M}M}     :*     L  3   =     -    K  C    R  S      s   L  M           subscript  L  3          subscript  K  C    subscript  R  S       s   subscript  L  M       L_{3}=\frac{-K_{C}R_{S}}{sL_{M}}\,     :*     L  4   =     -    K  V    K  C    K  M    G  T       s  2    L  M   M          subscript  L  4          subscript  K  V    subscript  K  C    subscript  K  M    subscript  G  T        superscript  s  2    subscript  L  M   M      L_{4}=\frac{-K_{V}K_{C}K_{M}G_{T}}{s^{2}L_{M}M}\,     :*     L  5   =     -    K  P    K  V    K  C    K  M       s  3    L  M   M          subscript  L  5          subscript  K  P    subscript  K  V    subscript  K  C    subscript  K  M        superscript  s  3    subscript  L  M   M      L_{5}=\frac{-K_{P}K_{V}K_{C}K_{M}}{s^{3}L_{M}M}\,         Î”  =    1  -   (    L  0   +   L  1   +   L  2   +   L  3   +   L  4   +   L  5    )    +   (     L  0    L  1    +    L  0    L  3     )        normal-Î”      1     subscript  L  0    subscript  L  1    subscript  L  2    subscript  L  3    subscript  L  4    subscript  L  5          subscript  L  0    subscript  L  1       subscript  L  0    subscript  L  3        \Delta=1-(L_{0}+L_{1}+L_{2}+L_{3}+L_{4}+L_{5})+(L_{0}L_{1}+L_{0}L_{3})\,     There is one forward path:  :*     g  0   =     -    K  P    K  V    K  C    K  M       s  3    L  M   M          subscript  g  0          subscript  K  P    subscript  K  V    subscript  K  C    subscript  K  M        superscript  s  3    subscript  L  M   M      g_{0}=\frac{-K_{P}K_{V}K_{C}K_{M}}{s^{3}L_{M}M}\,     The forward path touches all the loops therefore the co-factor     Î”  0   =  1       subscript  normal-Î”  0   1    \Delta_{0}=1     And the gain from input to output is      Î¸  L    Î¸  C    =      g  0    Î”  0    Î”           subscript  Î¸  L    subscript  Î¸  C         subscript  g  0    subscript  normal-Î”  0    normal-Î”     \frac{\theta_{L}}{\theta_{C}}=\frac{g_{0}\Delta_{0}}{\Delta}\,   {{-}}  Equivalent matrix form  Mason's rule can be stated in a simple matrix form. Assume   ğ“   ğ“   \mathbf{T}   is the transient matrix of the graph where     t   n  m    =    [  ğ“  ]    n  m         subscript  t    n  m     subscript   delimited-[]  ğ“     n  m      t_{nm}=\left[\mathbf{T}\right]_{nm}   is the sum transmittance of branches from node m toward node n . Then, the gain from node m to node n of the graph is equal to     u   n  m    =    [  ğ”  ]    n  m         subscript  u    n  m     subscript   delimited-[]  ğ”     n  m      u_{nm}=\left[\mathbf{U}\right]_{nm}   , where      ğ”  =    (   ğˆ  -  ğ“   )    -  1        ğ”   superscript    ğˆ  ğ“     1      \mathbf{U}=\left(\mathbf{I}-\mathbf{T}\right)^{-1}   ,  and   ğˆ   ğˆ   \mathbf{I}   is the identity matrix.  Mason's Rule is also particularly useful for deriving the z-domain transfer function of discrete networks that have inner feedback loops embedded within outer feedback loops (nested loops). If the discrete network can be drawn as a signal flow graph, then the application of Mason's Rule will give that network's z-domain H(z) transfer function.  Complexity and Computational Applications  Mason's Rule can grow factorially, because the enumeration of paths in a directed graph grows thusly. To see this consider the complete directed graph on   n   n   n   vertices, having an edge between every pair of vertices. There is a path form    y   i  n      subscript  y    i  n     y_{in}   to    y   o  u  t      subscript  y    o  u  t     y_{out}   for each of the     (   n  -  2   )   !        n  2     (n-2)!   permutations of the intermediate vertices. Thus Gaussian elimination is more efficient in the general case.  Yet Mason's rule characterizes the transfer functions of interconnected systems in a way which is simultaneously algebraic and combinatorial, allowing for general statements and other computations in algebraic systems theory. While numerous inverses occur during Gaussian eliminiation, Mason's rule naturally collects these into a single quasi-inverse . General form is         p   1  -  q    ,      p    1  q     \frac{p}{1-q},        Where as described above,   q   q   q   is a sum of cycle products, each of which typically falls into an ideal (for example, the strictly causal operators). Fractions of this form form a subring     R    (   1  +   âŸ¨   L  i   âŸ©    )    -  1        R   superscript    1   delimited-âŸ¨âŸ©   subscript  L  i       1      R(1+\langle L_{i}\rangle)^{-1}   of the rational function field . This observation carries over to the noncommutative case, 3 even though Mason's rule itself must then be replaced by Riegle's rule .  See also   Signal-flow graph  Riegle's rule   Notes  References      "  Category:Control theory     â†©  â†©  â†©     