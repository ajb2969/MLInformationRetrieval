   Mason's gain formula      Mason's gain formula  '''Mason's gain formula''' (MGF) is a method for finding the transfer  function of a linear signal-flow  graph (SFG).  The formula was derived by Samuel  Jefferson  Mason , 1 whom it is also named after. MGF is an alternate method to finding the transfer function algebraically by labeling each signal, writing down the equation for how that signal depends on other signals, and then solving the multiple equations for the output signal in terms of the input signal.  MGF provides a step by step method to obtain the transfer function from a SFG.  Often, MGF can be determined by inspection of the SFG.  The method can easily handle SFGs with many variables and loops including loops with inner loops.  MGF comes up often in  the context of control  systems and digital filters because control systems and digital filters are often represented by SFGs.  Formula  The gain formula is as follows:      G  =    y  out    y  in    =     ∑   k  =  1   N     G  k    Δ  k      Δ          G     subscript  y  out    subscript  y  in             superscript   subscript     k  1    N      subscript  G  k    subscript  normal-Δ  k     normal-Δ      G=\frac{y_{\text{out}}}{y_{\text{in}}}=\frac{\sum_{k=1}^{N}{G_{k}\Delta_{k}}}{%
 \Delta\ }         Δ  =      1  -   ∑   L  i     +   ∑    L  i    L  j      -   ∑    L  i    L  j    L  k      +  ⋯  +     (   -  1   )   m    ∑  ⋯    +  ⋯       normal-Δ          1     subscript  L  i          subscript  L  i    subscript  L  j           subscript  L  i    subscript  L  j    subscript  L  k      normal-⋯     superscript    1   m     normal-⋯    normal-⋯     \Delta=1-\sum L_{i}+\sum L_{i}L_{j}-\sum L_{i}L_{j}L_{k}+\cdots+(-1)^{m}\sum%
 \cdots+\cdots     where:   Δ = the determinant of the graph.  y in = input-node variable  y out = output-node variable  G = complete gain between y in and y out  N = total number of forward paths between y in and y out  G k = path gain of the k th forward path between y in and y out  L i = loop gain of each closed loop in the system  L i L j = product of the loop gains of any two non-touching loops (no common nodes)  L i L j L k = product of the loop gains of any three pairwise nontouching loops  Δ k = the cofactor value of Δ for the k th forward path, with the loops touching the k th forward path removed. *   definitions 2   Path: a continuous set of branches traversed in the direction that they indicate.  Forward path: A path from an input node to an output node in which no node is touched more than once.  Loop: A path that originates and ends on the same node in which no node is touched more than once.  Path gain: the product of the gains of all the branches in the path.  Loop gain: the product of the gains of all the branches in the loop.   Procedure  To use this technique,   Make a list of all forward paths, and their gains, and label these G k .  Make a list of all the loops and their gains, and label these L i (for i loops). Make a list of all pairs of non-touching loops, and the products of their gains ( L i L j ). Make a list of all pairwise non-touching loops taken three at a time ( L i L j L k ), then four at a time, and so forth, until there are no more.  Compute the determinant Δ and cofactors Δ k .  Apply the formula.   Examples  Circuit containing two-port  (Figure)  lrft|thumb|400px| Signal flow graph of a circuit containing a two port. The forward path from input to output is shown in a different color.   The transfer function from V in to V 2 is desired.  There is only one forward path:  :* V in to V 1 to I 2 to V 2 with gain     G  1   =   -    y  21     R  L           subscript  G  1        subscript  y  21    subscript  R  L       G_{1}=-y_{21}R_{L}\,     There are three loops:  :* V 1 to I 1 to V 1 with gain     L  1   =   -    R   i  n      y  11           subscript  L  1        subscript  R    i  n     subscript  y  11       L_{1}=-R_{in}y_{11}\,     :* V 2 to I 2 to V 2 with gain     L  2   =   -    R  L     y  22           subscript  L  2        subscript  R  L    subscript  y  22       L_{2}=-R_{L}y_{22}\,     :* V 1 to I 2 to V 2 to I 1 to V 1 with gain     L  3   =    y  21    R  L    y  12     R   i  n           subscript  L  3      subscript  y  21    subscript  R  L    subscript  y  12    subscript  R    i  n       L_{3}=y_{21}R_{L}y_{12}R_{in}\,         Δ  =    1  -   (    L  1   +   L  2   +   L  3    )    +   (    L  1    L  2    )        normal-Δ      1     subscript  L  1    subscript  L  2    subscript  L  3        subscript  L  1    subscript  L  2       \Delta=1-(L_{1}+L_{2}+L_{3})+(L_{1}L_{2})\,   note: L 1 and L 2 do not touch each other whereas L 3 touches both of the other loops.       Δ  1   =   1        subscript  normal-Δ  1   1    \Delta_{1}=1\,   note: the forward path touches all the loops so all that is left is 1 .      G  =     G  1    Δ  1    Δ   =     -    y  21    R  L        1  +    R   i  n     y  11    +    R  L    y  22     -    y  21    R  L    y  12    R   i  n      +    R   i  n     y  11    R  L    y  22             G       subscript  G  1    subscript  normal-Δ  1    normal-Δ               subscript  y  21    subscript  R  L           1     subscript  R    i  n     subscript  y  11       subscript  R  L    subscript  y  22        subscript  y  21    subscript  R  L    subscript  y  12    subscript  R    i  n         subscript  R    i  n     subscript  y  11    subscript  R  L    subscript  y  22         G=\frac{G_{1}\Delta_{1}}{\Delta}=\frac{-y_{21}R_{L}}{1+R_{in}y_{11}+R_{L}y_{22%
 }-y_{21}R_{L}y_{12}R_{in}+R_{in}y_{11}R_{L}y_{22}}\,   {{-}}  Digital IIR biquad filter  (Figure)  The signal flow graph (SFG) for a digital infinite impulse response bi-quad filter. This SFG has three forward paths and two loops.   Digital filters are often diagramed as signal flow graphs.   There are two loops       L  1   =   -    a  1     Z   -  1            subscript  L  1        subscript  a  1    superscript  Z    1        L_{1}=-a_{1}Z^{-1}\,          L  2   =   -    a  2     Z   -  2            subscript  L  2        subscript  a  2    superscript  Z    2        L_{2}=-a_{2}Z^{-2}\,            Δ  =   1  -   (    L  1   +   L  2    )        normal-Δ    1     subscript  L  1    subscript  L  2       \Delta=1-(L_{1}+L_{2})\,   Note, the two loops touch so there is no term for their product.   There are three forward paths       G  0   =    b  0         subscript  G  0    subscript  b  0     G_{0}=b_{0}\,          G  1   =    b  1     Z   -  1           subscript  G  1      subscript  b  1    superscript  Z    1       G_{1}=b_{1}Z^{-1}\,          G  2   =    b  2     Z   -  2           subscript  G  2      subscript  b  2    superscript  Z    2       G_{2}=b_{2}Z^{-2}\,         All the forward paths touch all the loops so     Δ  0   =   Δ  1   =   Δ  2   =   1          subscript  normal-Δ  0    subscript  normal-Δ  1         subscript  normal-Δ  2        1     \Delta_{0}=\Delta_{1}=\Delta_{2}=1\,          G  =       G  0    Δ  0    +    G  1    Δ  1    +    G  2    Δ  2     Δ        G         subscript  G  0    subscript  normal-Δ  0       subscript  G  1    subscript  normal-Δ  1       subscript  G  2    subscript  normal-Δ  2     normal-Δ     G=\frac{G_{0}\Delta_{0}+G_{1}\Delta_{1}+G_{2}\Delta_{2}}{\Delta}\,         G  =      b  0   +    b  1    Z   -  1     +    b  2    Z   -  2       1  +    a  1    Z   -  1     +    a  2    Z   -  2            G       subscript  b  0      subscript  b  1    superscript  Z    1        subscript  b  2    superscript  Z    2        1     subscript  a  1    superscript  Z    1        subscript  a  2    superscript  Z    2         G=\frac{b_{0}+b_{1}Z^{-1}+b_{2}Z^{-2}}{1+a_{1}Z^{-1}+a_{2}Z^{-2}}\,   {{-}}  Servo  (Figure)  Angular position servo and signal flow graph. θ C = desired angle command, θ L = actual load angle, K P = position loop gain, V ωC = velocity command, V ωM = motor velocity sense voltage, K V = velocity loop gain, V IC = current command, V IM = current sense voltage, K C = current loop gain, V A = power amplifier output voltage, V M = effective voltage across the inductance, L M = motor inductance, I M = motor current, R M = motor resistance, R S = current sense resistance, K M = motor torque constant (Nm/amp), T = torque, M = moment of inertia of all rotating components α = angular acceleration, ω = angular velocity, β = mechanical damping, G M = motor back EMF constant, G T = tachometer conversion gain constant,. There is one forward path (shown in a different color) and six feedback loops. The drive shaft assumed to be stiff enough to not treat as a spring. Constants are shown in black and variables in purple.   The signal flow graph has six loops. They are:  :*     L  0   =   -    β   s  M           subscript  L  0       β    s  M       L_{0}=-\frac{\beta}{sM}\,     :*     L  1   =     -   (    R  M   +   R  S    )     s   L  M           subscript  L  1          subscript  R  M    subscript  R  S       s   subscript  L  M       L_{1}=\frac{-(R_{M}+R_{S})}{sL_{M}}\,     :*     L  2   =    -    G  M    K  M       s  2    L  M   M         subscript  L  2          subscript  G  M    subscript  K  M        superscript  s  2    subscript  L  M   M      L_{2}=\,\frac{-G_{M}K_{M}}{s^{2}L_{M}M}     :*     L  3   =     -    K  C    R  S      s   L  M           subscript  L  3          subscript  K  C    subscript  R  S       s   subscript  L  M       L_{3}=\frac{-K_{C}R_{S}}{sL_{M}}\,     :*     L  4   =     -    K  V    K  C    K  M    G  T       s  2    L  M   M          subscript  L  4          subscript  K  V    subscript  K  C    subscript  K  M    subscript  G  T        superscript  s  2    subscript  L  M   M      L_{4}=\frac{-K_{V}K_{C}K_{M}G_{T}}{s^{2}L_{M}M}\,     :*     L  5   =     -    K  P    K  V    K  C    K  M       s  3    L  M   M          subscript  L  5          subscript  K  P    subscript  K  V    subscript  K  C    subscript  K  M        superscript  s  3    subscript  L  M   M      L_{5}=\frac{-K_{P}K_{V}K_{C}K_{M}}{s^{3}L_{M}M}\,         Δ  =    1  -   (    L  0   +   L  1   +   L  2   +   L  3   +   L  4   +   L  5    )    +   (     L  0    L  1    +    L  0    L  3     )        normal-Δ      1     subscript  L  0    subscript  L  1    subscript  L  2    subscript  L  3    subscript  L  4    subscript  L  5          subscript  L  0    subscript  L  1       subscript  L  0    subscript  L  3        \Delta=1-(L_{0}+L_{1}+L_{2}+L_{3}+L_{4}+L_{5})+(L_{0}L_{1}+L_{0}L_{3})\,     There is one forward path:  :*     g  0   =     -    K  P    K  V    K  C    K  M       s  3    L  M   M          subscript  g  0          subscript  K  P    subscript  K  V    subscript  K  C    subscript  K  M        superscript  s  3    subscript  L  M   M      g_{0}=\frac{-K_{P}K_{V}K_{C}K_{M}}{s^{3}L_{M}M}\,     The forward path touches all the loops therefore the co-factor     Δ  0   =  1       subscript  normal-Δ  0   1    \Delta_{0}=1     And the gain from input to output is      θ  L    θ  C    =      g  0    Δ  0    Δ           subscript  θ  L    subscript  θ  C         subscript  g  0    subscript  normal-Δ  0    normal-Δ     \frac{\theta_{L}}{\theta_{C}}=\frac{g_{0}\Delta_{0}}{\Delta}\,   {{-}}  Equivalent matrix form  Mason's rule can be stated in a simple matrix form. Assume   𝐓   𝐓   \mathbf{T}   is the transient matrix of the graph where     t   n  m    =    [  𝐓  ]    n  m         subscript  t    n  m     subscript   delimited-[]  𝐓     n  m      t_{nm}=\left[\mathbf{T}\right]_{nm}   is the sum transmittance of branches from node m toward node n . Then, the gain from node m to node n of the graph is equal to     u   n  m    =    [  𝐔  ]    n  m         subscript  u    n  m     subscript   delimited-[]  𝐔     n  m      u_{nm}=\left[\mathbf{U}\right]_{nm}   , where      𝐔  =    (   𝐈  -  𝐓   )    -  1        𝐔   superscript    𝐈  𝐓     1      \mathbf{U}=\left(\mathbf{I}-\mathbf{T}\right)^{-1}   ,  and   𝐈   𝐈   \mathbf{I}   is the identity matrix.  Mason's Rule is also particularly useful for deriving the z-domain transfer function of discrete networks that have inner feedback loops embedded within outer feedback loops (nested loops). If the discrete network can be drawn as a signal flow graph, then the application of Mason's Rule will give that network's z-domain H(z) transfer function.  Complexity and Computational Applications  Mason's Rule can grow factorially, because the enumeration of paths in a directed graph grows thusly. To see this consider the complete directed graph on   n   n   n   vertices, having an edge between every pair of vertices. There is a path form    y   i  n      subscript  y    i  n     y_{in}   to    y   o  u  t      subscript  y    o  u  t     y_{out}   for each of the     (   n  -  2   )   !        n  2     (n-2)!   permutations of the intermediate vertices. Thus Gaussian elimination is more efficient in the general case.  Yet Mason's rule characterizes the transfer functions of interconnected systems in a way which is simultaneously algebraic and combinatorial, allowing for general statements and other computations in algebraic systems theory. While numerous inverses occur during Gaussian eliminiation, Mason's rule naturally collects these into a single quasi-inverse . General form is         p   1  -  q    ,      p    1  q     \frac{p}{1-q},        Where as described above,   q   q   q   is a sum of cycle products, each of which typically falls into an ideal (for example, the strictly causal operators). Fractions of this form form a subring     R    (   1  +   ⟨   L  i   ⟩    )    -  1        R   superscript    1   delimited-⟨⟩   subscript  L  i       1      R(1+\langle L_{i}\rangle)^{-1}   of the rational function field . This observation carries over to the noncommutative case, 3 even though Mason's rule itself must then be replaced by Riegle's rule .  See also   Signal-flow graph  Riegle's rule   Notes  References      "  Category:Control theory     ↩  ↩  ↩     