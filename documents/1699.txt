   Cyclic code      Cyclic code   In coding theory , a cyclic code is a block code , where the circular shifts of each codeword gives another word that belongs to the code. They are error-correcting codes that have algebraic properties that are convenient for efficient error detection and correction .  Definition  Let   ùíû   ùíû   \mathcal{C}   be a linear code over a finite field     G  F   (  q  )       G  F  q    GF(q)   of block length  n .   ùíû   ùíû   \mathcal{C}   is called a cyclic code if, for every codeword  c =( c 1 ,..., c n ) from C , the word ( c n , c 1 ,..., c n-1 ) in    G  F    (  q  )   n       G  F   superscript  q  n     GF(q)^{n}   obtained by a cyclic right shift of components is again a codeword. Because one cyclic right shift is equal to n ‚àí¬†1 cyclic left shifts, a cyclic code may also be defined via cyclic left shifts. Therefore the linear code   ùíû   ùíû   \mathcal{C}   is cyclic precisely when it is invariant under all cyclic shifts.  Cyclic Codes have some additional structural constraint on the codes. They are based on Galois fields and because of their structural properties they are very useful for error controls. Their structure is strongly related to Galois fields because of which the encoding and decoding algorithms for cyclic codes are computationally efficient.  Algebraic structure  Cyclic codes can be linked to ideals in certain rings. Let    R  =    A   [  x  ]    /   (    x  n   -  1   )        R      A   delimited-[]  x       superscript  x  n   1      R=A[x]/(x^{n}-1)   be a polynomial ring over the finite field    A  =   G  F   (  q  )        A    G  F  q     A=GF(q)   . Identify the elements of the cyclic code C with polynomials in R such that    (   c  0   ,  ‚Ä¶  ,   c   n  -  1    )      subscript  c  0   normal-‚Ä¶   subscript  c    n  1      (c_{0},\ldots,c_{n-1})   maps to the polynomial     c  0   +    c  1   x   +  ‚ãØ  +    c   n  -  1     x   n  -  1          subscript  c  0      subscript  c  1   x   normal-‚ãØ     subscript  c    n  1     superscript  x    n  1       c_{0}+c_{1}x+\cdots+c_{n-1}x^{n-1}   : thus multiplication by x corresponds to a cyclic shift. Then C is an ideal in R , and hence principal , since R is a principal ideal ring . The ideal is generated by the unique monic element in C of minimum degree, the generator polynomial  g . 1 This must be a divisor of     x  n   -  1       superscript  x  n   1    x^{n}-1   . It follows that every cyclic code is a polynomial code . If the generator polynomial g has degree d then the rank of the code C is    n  -  d      n  d    n-d   .  The idempotent of C is a codeword e such that e 2 = e (that is, e is an idempotent element of C ) and e is an identity for the code, that is e  c = c for every codeword c . If n and q are coprime such a word always exists and is unique; 2 it is a generator of the code.  An irreducible code is a cyclic code in which the code, as an ideal is irreducible, i.e. is minimal in R , so that its check polynomial is an irreducible polynomial .  Examples  For example, if A =    ùîΩ  2     subscript  ùîΩ  2    \mathbb{F}_{2}   and n =3, the set of codewords contained in the (1,1,0)-cyclic code is precisely      (   (  0  ,  0  ,  0  )   ,   (  1  ,  1  ,  0  )   ,   (  0  ,  1  ,  1  )   ,   (  1  ,  0  ,  1  )   )      0  0  0    1  1  0    0  1  1    1  0  1     ((0,0,0),(1,1,0),(0,1,1),(1,0,1))\,   .  It corresponds to the ideal in      ùîΩ  2    [  x  ]    /   (    x  3   -  1   )          subscript  ùîΩ  2    delimited-[]  x       superscript  x  3   1     \mathbb{F}_{2}[x]/(x^{3}-1)   generated by    (   1  +  x   )      1  x    (1+x)   .  Note that    (   1  +  x   )      1  x    (1+x)   is an irreducible polynomial in the polynomial ring, and hence the code is an irreducible code.  The idempotent of this code is the polynomial    x  +   x  2       x   superscript  x  2     x+x^{2}   , corresponding to the codeword (1,1,0).  Trivial examples  Trivial examples of cyclic codes are A n itself and the code containing only the zero codeword. These correspond to generators 1 and     x  n   -  1       superscript  x  n   1    x^{n}-1   respectively: these two polynomials must always be factors of     x  n   -  1       superscript  x  n   1    x^{n}-1   .  Over GF (2) the parity bit code, consisting of all words of even weight, corresponds to generator    x  +  1      x  1    x+1   . Again over GF(2) this must always be a factor of     x  n   -  1       superscript  x  n   1    x^{n}-1   .  Quasi-cyclic codes and shortened codes  Before delving into the details of cyclic codes first we will discuss quasi-cyclic and shortened codes which are closely related to the cyclic codes and they all can be converted into each other.  Definition  Quasi-cyclic codes: An     (  n  ,  k  )     n  k    (n,k)    quasi-cyclic code is a linear block code such that, for some    b   b   b    coprime with    n   n   n   , the polynomial       x  b   c   (  x  )       (   mod    x  n   -  1    )      annotated     superscript  x  b   c  x    pmod     superscript  x  n   1      x^{b}c(x)\;\;(\mathop{{\rm mod}}x^{n}-1)    is a codeword polynomial whenever     c   (  x  )       c  x    c(x)    is a codeword polynomial .  Here codeword polynomial is a linear code whose code words are polynomials that are divisible by a polynomial of shorter length called generator polynomial . Note that every codeword polynomial can be expressed in the form     c   (  x  )    =   a   (  x  )   g   (  x  )          c  x     a  x  g  x     c(x)=a(x)g(x)   . For any codeword    (   c  0   ,  .  .  ,   c   n  -  1    )     fragments  normal-(   subscript  c  0   normal-,  normal-.  normal-.  normal-,   subscript  c    n  1    normal-)    (c_{0},..,c_{n-1})   codeword polynomial corresponds to the     ‚àë   i  =  0    n  -  1      c  i   *   x  i        superscript   subscript     i  0      n  1       subscript  c  i    superscript  x  i      \sum_{i=0}^{n-1}c_{i}*x^{i}   .  Definition  Shortened codes: An     [  n  ,  k  ]     n  k    [n,k]   ''linear code is called a proper shortened cyclic code if it can be obtained by deleting ''   b   b   b   '' positions from an''    (   n  +  b   ,   k  +  b   )       n  b     k  b     (n+b,k+b)    cyclic code .  In shortened codes information symbols are deleted to obtain a desired blocklength smaller than the design blocklength. The missing information symbols are usually imagined to be at the beginning of the codeword and are considered to be 0. Therefore,   n   n   n   ‚àí   k   k   k   is fixed, and then   k   k   k   is decreased which eventually decreases   n   n   n   . Note that it is not necessary to delete the starting symbols. Depending on the application sometimes consecutive positions are considered as 0 and are deleted.  All the symbols which are dropped need not be transmitted and at the receiving end can be reinserted. To convert    (  n  ,  k  )     n  k    (n,k)   cyclic code to    (   n  -  b   ,   k  -  b   )       n  b     k  b     (n-b,k-b)   shortened code, set   b   b   b   symbols to zero and drop them from each codeword. Any cyclic code can be converted to quasi-cyclic codes by dropping every   b   b   b   th symbol where   b   b   b   is a factor of   n   n   n   . If the dropped symbols are not check symbols then this cyclic code is also a shortened code.  Cyclic codes for correcting errors  Now, we will begin the discussion of cyclic codes explicitly with error detection and correction . Cyclic codes can be used to correct errors, like Hamming codes as a cyclic codes can be used for correcting single error. Likewise, they are also used to correct double errors and burst errors. All types of error corrections are covered briefly in the further subsections.  The (7,4) Hamming code has a generator polynomial      g   (  x  )    =    x  3   +  x  +  1         g  x      superscript  x  3   x  1     g(x)=x^{3}+x+1   . This polynomial has a zero in Galois extension field     G  F   (  8  )       G  F  8    GF(8)   at the primitive element   Œ±   Œ±   \alpha   , and all codewords satisfy     ùíû   (  Œ±  )    =  0        ùíû  Œ±   0    \mathcal{C}(\alpha)=0   . Cyclic codes can also be used to correct double errors over the field    G  F   (  2  )       G  F  2    GF(2)   . Blocklength will be   n   n   n   equal to     2  m   -  1       superscript  2  m   1    2^{m}-1   and primitive elements   Œ±   Œ±   \alpha   and    Œ±  3     superscript  Œ±  3    \alpha^{3}   as zeros in the    G  F   (   2  m   )       G  F   superscript  2  m     GF(2^{m})   because we are considering the case of two errors here, so each will represent one error.  The received word is a polynomial of degree    n  -  1      n  1    n-1   given as     v   (  x  )    =    a   (  x  )   g   (  x  )    +   e   (  x  )           v  x       a  x  g  x     e  x      v(x)=a(x)g(x)+e(x)     where    e   (  x  )       e  x    e(x)   can have at most two nonzero coefficients corresponding to 2 errors.  We define the Syndrome Polynomial ,    S   (  x  )       S  x    S(x)   as the remainder of polynomial    v   (  x  )       v  x    v(x)   when divided by the generator polynomial    g   (  x  )       g  x    g(x)   i.e.      S   (  x  )       S  x    S(x)   =      v   (  x  )    mod   g   (  x  )     =    (    a   (  x  )   g   (  x  )    +   e   (  x  )     )   mod   g   (  x  )     =    e   (  x  )    mod   g   (  x  )            modulo    v  x     g  x     modulo      a  x  g  x     e  x      g  x          modulo    e  x     g  x       v(x)\mod g(x)=(a(x)g(x)+e(x))\mod g(x)=e(x)\mod g(x)   as     (   a   (  x  )   g   (  x  )    )   mod   g   (  x  )       modulo    a  x  g  x     g  x     (a(x)g(x))\mod g(x)   is zero.  For correcting two errors  Let the field elements    X  1     subscript  X  1    X_{1}   and    X  2     subscript  X  2    X_{2}   be the two error location numbers. If only one error occurs then    X  2     subscript  X  2    X_{2}   is equal to zero and if none occurs both are zero.  Let     S  1   =   v   (  Œ±  )         subscript  S  1     v  Œ±     S_{1}={v}(\alpha)   and     S  3   =   v   (   Œ±  3   )         subscript  S  3     v   superscript  Œ±  3      S_{3}={v}(\alpha^{3})   .  These field elements are called "syndromes". Now because    g   (  x  )       g  x    g(x)   is zero at primitive elements   Œ±   Œ±   \alpha   and    Œ±  3     superscript  Œ±  3    \alpha^{3}   , so we can write     S  1   =   e   (  Œ±  )         subscript  S  1     e  Œ±     S_{1}=e(\alpha)   and     S  3   =   e   (   Œ±  3   )         subscript  S  3     e   superscript  Œ±  3      S_{3}=e(\alpha^{3})   . If say two errors occur, then       S  1   =    Œ±  i   +   Œ±   i  ‚Ä≤          subscript  S  1      superscript  Œ±  i    superscript  Œ±   superscript  i  normal-‚Ä≤       S_{1}=\alpha^{i}+\alpha^{i^{\prime}}   and     S  3   =    Œ±   3  i    +   Œ±   3   i  ‚Ä≤           subscript  S  3      superscript  Œ±    3  i     superscript  Œ±    3   superscript  i  normal-‚Ä≤        S_{3}=\alpha^{3i}+\alpha^{3i^{\prime}}   .  And these two can be considered as two pair of equations in    G  F   (   2  m   )       G  F   superscript  2  m     GF(2^{m})   with two unknowns and hence we can write       S  1   =    X  1   +   X  2         subscript  S  1      subscript  X  1    subscript  X  2      S_{1}=X_{1}+X_{2}   and     S  3   =     (   X  1   )   3   +    (   X  2   )   3         subscript  S  3      superscript   subscript  X  1   3    superscript   subscript  X  2   3      S_{3}=(X_{1})^{3}+(X_{2})^{3}   .  Hence if the two pair of nonlinear equations can be solved cyclic codes can used to correct two errors.  Hamming code  The Hamming(7,4) code may be written as a cyclic code over GF(2) with generator    1  +  x  +   x  3       1  x   superscript  x  3     1+x+x^{3}   . In fact, any binary Hamming code of the form Ham(r, 2) is equivalent to a cyclic code, 3 and any Hamming code of the form Ham(r,q) with r and q-1 relatively prime is also equivalent to a cyclic code. 4 Given a Hamming code of the form Ham(r,2) with    r  ‚â•  3      r  3    r\geq 3   , the set of even codewords forms a cyclic    [    2  r   -  1   ,    2  r   -  r  -  2   ,  4  ]        superscript  2  r   1      superscript  2  r   r  2   4    [2^{r}-1,2^{r}-r-2,4]   -code. 5  Hamming code for correcting single errors  A code whose minimum distance is at least 3, have a check matrix all of whose columns are distinct and non zero. If a check matrix for a binary code has   m   m   m   rows, then each column is an   m   m   m   -bit binary number. There are     2  m   -  1       superscript  2  m   1    2^{m}-1   possible columns. Therefore if a check matrix of a binary code with    d   m  i  n      subscript  d    m  i  n     d_{min}   at least 3 has   m   m   m   rows, then it can only have     2  m   -  1       superscript  2  m   1    2^{m}-1   columns, not more than that. This defines a    (    2  m   -  1   ,    2  m   -  1  -  m   )        superscript  2  m   1      superscript  2  m   1  m     (2^{m}-1,2^{m}-1-m)   code, called Hamming code.  It is easy to define Hamming codes for large alphabets of size   q   q   q   . We need to define one    H   H   H    matrix with linearly independent columns. For any word of size   q   q   q   there will be columns who are multiples of each other. So, to get linear independence all non zero   m   m   m   -tuples with one as a top most non zero element will be chosen as columns. Then two columns will never be linearly dependent because three columns could be linearly dependent with the minimum distance of the code as 3.  So, there are     (    q  m   -  1   )   /   (   q  -  1   )          superscript  q  m   1     q  1     (q^{m}-1)/(q-1)   nonzero columns with one as top most non zero element. Therefore, Hamming code is a    [    (    q  m   -  1   )   /   (   q  -  1   )    ,     (    q  m   -  1   )   /   (   q  -  1   )    -  m   ]          superscript  q  m   1     q  1           superscript  q  m   1     q  1    m     [(q^{m}-1)/(q-1),(q^{m}-1)/(q-1)-m]   code.  Now, for cyclic codes, Let   Œ±   Œ±   \alpha   be primitive element in    G  F   (   q  m   )       G  F   superscript  q  m     GF(q^{m})   , and let    Œ≤  =   Œ±   q  -  1        Œ≤   superscript  Œ±    q  1      \beta=\alpha^{q-1}   . Then     Œ≤    (    q  m   -  1   )   /   (   q  -  1   )     =  1       superscript  Œ≤       superscript  q  m   1     q  1     1    \beta^{(q^{m}-1)/(q-1)}=1   and thus   Œ≤   Œ≤   \beta   is a zero of the polynomial     x    (    q  m   -  1   )   /   (   q  -  1   )     -  1       superscript  x       superscript  q  m   1     q  1     1    x^{(q^{m}-1)/(q-1)}-1   and is a generator polynomial for the cyclic code of block length    n  =    (    q  m   -  1   )   /   (   q  -  1   )        n       superscript  q  m   1     q  1      n=(q^{m}-1)/(q-1)   .  But for    q  =  2      q  2    q=2   ,    Œ±  =  Œ≤      Œ±  Œ≤    \alpha=\beta   . And the received word is a polynomial of degree    n  -  1      n  1    n-1   given as       v   (  x  )    =    a   (  x  )   g   (  x  )    +   e   (  x  )           v  x       a  x  g  x     e  x      v(x)=a(x)g(x)+e(x)     where,     e   (  x  )    =  0        e  x   0    e(x)=0   or    x  i     superscript  x  i    x^{i}   where   i   i   i   represents the error locations.  But we can also use    Œ±  i     superscript  Œ±  i    \alpha^{i}   as an element of    G  F   (   2  m   )       G  F   superscript  2  m     GF(2^{m})   to index error location. Because     g   (  Œ±  )    =  0        g  Œ±   0    g(\alpha)=0   , we have     v   (  Œ±  )    =   Œ±  i         v  Œ±    superscript  Œ±  i     v(\alpha)=\alpha^{i}   and all powers of   Œ±   Œ±   \alpha   from   0   0    to     2  m   -  2       superscript  2  m   2    2^{m}-2   are distinct. Therefore we can easily determine error location   i   i   i   from    Œ±  i     superscript  Œ±  i    \alpha^{i}   unless     v   (  Œ±  )    =  0        v  Œ±   0    v(\alpha)=0   which represents no error. So, hamming code is a single error correcting code over    G  F   (  2  )       G  F  2    GF(2)   with    n  =    2  m   -  1       n     superscript  2  m   1     n=2^{m}-1   and    k  =   n  -  m       k    n  m     k=n-m   .  Cyclic codes for correcting burst errors  From Hamming distance concept, a code with minimum distance     2  t   +  1        2  t   1    2t+1   can correct any   t   t   t   errors. But in many channels error pattern is not very arbitrary, it occurs within very short segment of the message. Such kind of errors are called burst errors . So, for correcting such errors we will get a more efficient code of higher rate because of the less constraints. Cyclic codes are used for correcting burst error. In fact, cyclic codes can also correct cyclic burst errors along with burst errors. Cyclic burst errors are defined as  A cyclic burst of length   t   t   t   is a vector whose nonzero components are among   t   t   t   (cyclically) consecutive components, the first and the last of which are nonzero.  In polynomial form cyclic burst of length   t   t   t   can be described as     e   (  x  )    =     x  i   b   (  x  )    mod   (    x  n   -  1   )          e  x    modulo     superscript  x  i   b  x      superscript  x  n   1      e(x)=x^{i}b(x)\mod(x^{n}-1)   with    b   (  x  )       b  x    b(x)   as a polynomial of degree    t  -  1      t  1    t-1   with nonzero coefficient    b  0     subscript  b  0    b_{0}   . Here    b   (  x  )       b  x    b(x)   defines the pattern and    x  i     superscript  x  i    x^{i}   defines the starting point of error. Length of the pattern is given by deg     b   (  x  )    +  1        b  x   1    b(x)+1   . Syndrome poynomial is unique for each pattern and is given by       s   (  x  )    =    e   (  x  )    mod   g   (  x  )           s  x    modulo    e  x     g  x      s(x)=e(x)\mod g(x)     A linear block code that corrects all burst errors of length   t   t   t   or less must have at least    2  t      2  t    2t   check symbols. Proof: Because any linear code that can correct burst pattern of length   t   t   t   or less cannot have a burst of length    2  t      2  t    2t   or less as a codeword because if it did then a burst of length   t   t   t   could change the codeword to burst pattern of length   t   t   t   , which also could be obtained by making a burst error of length   t   t   t   in all zero codeword. Now, any two vectors that are non zero in the first    2  t      2  t    2t   components must be from different co-sets of an array to avoid their difference being a codeword of bursts of length    2  t      2  t    2t   . Therefore number of such co-sets are equal to number of such vectors which are    q   2  t      superscript  q    2  t     q^{2t}   . Hence at least    q   2  t      superscript  q    2  t     q^{2t}   co-sets and hence at least    2  t      2  t    2t   check symbol.  This property is also known as Rieger bound and it is similar to the singleton bound for random error correcting.  Fire codes as cyclic bounds  In 1959, Philip Fire 6 presented a construction of cyclic codes generated by a product of a binomial and a primitive polynomial. The binomial has the form     x  c   +  1       superscript  x  c   1    x^{c}+1   for some positive odd integer   c   c   c   . 7  Fire code is a cyclic burst error correcting code over    G  F   (  q  )       G  F  q    GF(q)   with the generator polynomial       g   (  x  )    =    (    x    2  t   -  1    -  1   )   p   (  x  )          g  x        superscript  x      2  t   1    1   p  x     g(x)=(x^{2t-1}-1)p(x)     where    p   (  x  )       p  x    p(x)   is a prime polynomial with degree   m   m   m   not smaller than   t   t   t   and    p   (  x  )       p  x    p(x)   does not divide     x    2  t   -  1    -  1       superscript  x      2  t   1    1    x^{2t-1}-1   . Block length of the fire code is the smallest integer   n   n   n   such that    g   (  x  )       g  x    g(x)   divides     x  n   -  1       superscript  x  n   1    x^{n}-1   .  A fire code can correct all burst errors of length t or less if no two bursts    b   (  x  )       b  x    b(x)   and     x  j    b  ‚Ä≤    (  x  )        superscript  x  j    superscript  b  normal-‚Ä≤   x    x^{j}b^{\prime}(x)   appear in the same co-set. This can be proved by contradiction. Suppose there are two distinct nonzero bursts    b   (  x  )       b  x    b(x)   and     x  j    b  ‚Ä≤    (  x  )        superscript  x  j    superscript  b  normal-‚Ä≤   x    x^{j}b^{\prime}(x)   of length   t   t   t   or less and are in the same co-set of the code. So, their difference is a codeword. As the difference is a multiple of    g   (  x  )       g  x    g(x)   it is also a multiple of     x    2  t   -  1    -  1       superscript  x      2  t   1    1    x^{2t-1}-1   . Therefore,       b   (  x  )    =     x  j    b  ‚Ä≤    (  x  )    mod   (    x    2  t   -  1    -  1   )          b  x    modulo     superscript  x  j    superscript  b  normal-‚Ä≤   x      superscript  x      2  t   1    1      b(x)=x^{j}b^{\prime}(x)\mod(x^{2t-1}-1)   .  This shows that   j   j   j   is a multiple of     2  t   -  1        2  t   1    2t-1   , So       b   (  x  )    =    x   l   (    2  t   -  1   )      b  ‚Ä≤    (  x  )          b  x      superscript  x    l      2  t   1      superscript  b  normal-‚Ä≤   x     b(x)=x^{l(2t-1)}b^{\prime}(x)     for some   l   l   l   . Now, as    l   (    2  t   -  1   )       l      2  t   1     l(2t-1)   is less than   t   t   t   and   l   l   l   is less than     q  m   -  1       superscript  q  m   1    q^{m}-1   so     (    x   l   (    2  t   -  1   )     -  1   )   b   (  x  )          superscript  x    l      2  t   1     1   b  x    (x^{l(2t-1)}-1)b(x)   is a codeword. Therefore,        (    x   l   (    2  t   -  1   )     -  1   )   b   (  x  )    =   a   (  x  )    (    x    2  t   -  1    -  1   )   p   (  x  )             superscript  x    l      2  t   1     1   b  x     a  x     superscript  x      2  t   1    1   p  x     (x^{l(2t-1)}-1)b(x)=a(x)(x^{2t-1}-1)p(x)   .  Since    b   (  x  )       b  x    b(x)   degree is less than degree of    p   (  x  )       p  x    p(x)   ,    p   (  x  )       p  x    p(x)   cannot divide    b   (  x  )       b  x    b(x)   . If   l   l   l   is not zero, then    p   (  x  )       p  x    p(x)   also cannot divide     x   l   (    2  t   -  1   )     -  1       superscript  x    l      2  t   1     1    x^{l(2t-1)}-1   as   l   l   l   is less than     q  m   -  1       superscript  q  m   1    q^{m}-1   and by definition of   m   m   m   ,    p   (  x  )       p  x    p(x)   divides     x   l   (    2  t   -  1   )     -  1       superscript  x    l      2  t   1     1    x^{l(2t-1)}-1   for no   l   l   l   smaller than     q  m   -  1       superscript  q  m   1    q^{m}-1   . Therefore   l   l   l   and   j   j   j   equals to zero. That means both that both the bursts are same, contrary to assumption.  Fire codes are the best single burst correcting codes with high rate and they are constructed analytically. They are of very high rate and when   m   m   m   and   t   t   t   are equal, redundancy is least and is equal to     3  t   -  1        3  t   1    3t-1   . By using multiple fire codes longer burst errors can also be corrected.  For error detection cyclic codes are widely used and are called    t  -  1      t  1    t-1    cyclic redundancy codes .  Cyclic codes on Fourier transform  Applications of Fourier transform are widespread in signal processing. But their applications are not limited to the complex fields only; Fourier transforms also exist in the Galois field    G  F   (  q  )       G  F  q    GF(q)   . Cyclic codes using Fourier transform can be described in a setting closer to the signal processing.  Fourier transform over finite fields  Fourier transform over finite fields  The discrete Fourier transform of vector    v  =   v  0   ,   v  1   ,  ‚Ä¶  .  ,   v   n  -  1       fragments  v    subscript  v  0   normal-,   subscript  v  1   normal-,  normal-‚Ä¶  normal-.  normal-,   subscript  v    n  1      v=v_{0},v_{1},....,v_{n-1}   is given by a vector    V  =   V  0   ,   V  1   ,  ‚Ä¶  .  .  ,   V   n  -  1       fragments  V    subscript  V  0   normal-,   subscript  V  1   normal-,  normal-‚Ä¶  normal-.  normal-.  normal-,   subscript  V    n  1      V=V_{0},V_{1},.....,V_{n-1}   where,      V  k     subscript  V  k    V_{k}   =     Œ£   i  =  0    n  -  1     e   -   j  2  œÄ   n   -  1    i  k      v  i        superscript   subscript  normal-Œ£    i  0      n  1     superscript  e      j  2  œÄ   superscript  n    1    i  k      subscript  v  i     \Sigma_{i=0}^{n-1}e^{-j2\pi n^{-1}ik}v_{i}   where,      k  =  0  ,  ‚Ä¶  .  .  ,  n  -  1     fragments  k   0  normal-,  normal-‚Ä¶  normal-.  normal-.  normal-,  n   1    k=0,.....,n-1     where exp(    -    j  2  œÄ   /  n           j  2  œÄ   n     -j2\pi/n   ) is an   n   n   n   th root of unity. Similarly in the finite field   n   n   n   th root of unity is element   œâ   œâ   \omega   of order   n   n   n   . Therefore  If    v  =   (   v  0   ,   v  1   ,  ‚Ä¶  .  ,   v   n  -  1    )      fragments  v    fragments  normal-(   subscript  v  0   normal-,   subscript  v  1   normal-,  normal-‚Ä¶  normal-.  normal-,   subscript  v    n  1    normal-)     v=(v_{0},v_{1},....,v_{n-1})   is a vector over    G  F   (  q  )       G  F  q    GF(q)   , and   œâ   œâ   \omega   be an element of    G  F   (  q  )       G  F  q    GF(q)   of order   n   n   n   , then Fourier transform of the vector   v   v   v   is the vector    V  =   (   V  0   ,   V  1   ,  ‚Ä¶  .  .  ,   V   n  -  1    )      fragments  V    fragments  normal-(   subscript  V  0   normal-,   subscript  V  1   normal-,  normal-‚Ä¶  normal-.  normal-.  normal-,   subscript  V    n  1    normal-)     V=(V_{0},V_{1},.....,V_{n-1})   and components are given by      V  j     subscript  V  j    V_{j}   =     Œ£   i  =  0    n  -  1     œâ   i  j     v  i        superscript   subscript  normal-Œ£    i  0      n  1     superscript  œâ    i  j     subscript  v  i     \Sigma_{i=0}^{n-1}\omega^{ij}v_{i}   where,      k  =  0  ,  ‚Ä¶  .  .  ,  n  -  1     fragments  k   0  normal-,  normal-‚Ä¶  normal-.  normal-.  normal-,  n   1    k=0,.....,n-1     Here   i   i   i   is time index,   j   j   j   is frequency and    V   V   V    is the spectrum . One important difference between Fourier transform in complex field and Galois field is that complex field   œâ   œâ   \omega   exists for every value of   n   n   n   while in Galois field   œâ   œâ   \omega   exists only if   n   n   n   divides    q  -  1      q  1    q-1   . In case of extension fields, there will be a Fourier transform in the extension field    G  F   (   q  m   )       G  F   superscript  q  m     GF(q^{m})   if   n   n   n   divides     q  m   -  1       superscript  q  m   1    q^{m}-1   for some   m   m   m   . In Galois field time domain vector   v   v   v   is over the field    G  F   (  q  )       G  F  q    GF(q)   but the spectrum    V   V   V    may be over the extension field    G  F   (   q  m   )       G  F   superscript  q  m     GF(q^{m})   .  Spectral description of cyclic codes  Any codeword of cyclic code of blocklength   n   n   n   can be represented by a polynomial    c   (  x  )       c  x    c(x)   of degree at most    n  -  1      n  1    n-1   . Its encoder can be written as     c   (  x  )    =   a   (  x  )   g   (  x  )          c  x     a  x  g  x     c(x)=a(x)g(x)   . Therefore in frequency domain encoder can be written as     C  j   =    A  j    G  j         subscript  C  j      subscript  A  j    subscript  G  j      C_{j}=A_{j}G_{j}   . Here codeword spectrum     C  j     subscript  C  j    C_{j}   has a value in    G  F   (   q  m   )       G  F   superscript  q  m     GF(q^{m})   but all the components in the time domain are from    G  F   (  q  )       G  F  q    GF(q)   . As the data spectrum    A  j     subscript  A  j    A_{j}   is arbitrary, the role of    G  j     subscript  G  j    G_{j}   is to specify those   j   j   j   where    C  j     subscript  C  j    C_{j}   will be zero.  Thus, cyclic codes can also be defined as  Given a set of spectral indices,     A  =   (   j  1   ,  ‚Ä¶  .  ,   j   n  -  k    )      fragments  A    fragments  normal-(   subscript  j  1   normal-,  normal-‚Ä¶  normal-.  normal-,   subscript  j    n  k    normal-)     A=(j_{1},....,j_{n-k})   , '' whose elements are called check frequencies, the cyclic code''   C   C   C    is the set of words over     G  F   (  q  )       G  F  q    GF(q)    whose spectrum is zero in the components indexed by      j  1   ,  ‚Ä¶  ,   j   n  -  k        subscript  j  1   normal-‚Ä¶   subscript  j    n  k      j_{1},...,j_{n-k}   . Any such spectrum    C   C   C    will have components of the form      A  j    G  j        subscript  A  j    subscript  G  j     A_{j}G_{j}   .  So, cyclic codes are vectors in the field    G  F   (  q  )       G  F  q    GF(q)   and the spectrum given by its inverse fourier transform is over the field    G  F   (   q  m   )       G  F   superscript  q  m     GF(q^{m})   and are constrained to be zero at certain components. But note that every spectrum in the field    G  F   (   q  m   )       G  F   superscript  q  m     GF(q^{m})   and zero at certain components may not have inverse transforms with components in the field    G  F   (  q  )       G  F  q    GF(q)   . Such spectrum can not be used as cyclic codes.  Following are the few bounds on the spectrum of cyclic codes.  BCH bound  If   n   n   n   be a factor of    (    q  m   -  1   )       superscript  q  m   1    (q^{m}-1)   for some   m   m   m   . The only vector in    G  F    (  q  )   n       G  F   superscript  q  n     GF(q)^{n}   of weight    d  -  1      d  1    d-1   or less that has    d  -  1      d  1    d-1   consecutive components of its spectrum equal to zero is all-zero vector.  Hartmann-Tzeng bound  If   n   n   n   be a factor of    (    q  m   -  1   )       superscript  q  m   1    (q^{m}-1)   for some   m   m   m   , and   b   b   b   an integer that is coprime with   n   n   n   . The only vector   v   v   v   in    G  F    (  q  )   n       G  F   superscript  q  n     GF(q)^{n}   of weight    d  -  1      d  1    d-1   or less whose spectral components    V  j     subscript  V  j    V_{j}   equal zero for    j  =     ‚Ñì  1   +    ‚Ñì  2   b    mod  n       j   modulo     subscript  normal-‚Ñì  1      subscript  normal-‚Ñì  2   b    n     j=\ell_{1}+\ell_{2}b(\mod n)   , where     ‚Ñì  1   =  0  ,  ‚Ä¶  .  ,  d  -  s  -  1     fragments   subscript  normal-‚Ñì  1    0  normal-,  normal-‚Ä¶  normal-.  normal-,  d   s   1    \ell_{1}=0,....,d-s-1   and     ‚Ñì  2   =  0  ,  ‚Ä¶  .  ,  s  -  1     fragments   subscript  normal-‚Ñì  2    0  normal-,  normal-‚Ä¶  normal-.  normal-,  s   1    \ell_{2}=0,....,s-1   , is the all zero vector.  Roos bound  If   n   n   n   be a factor of     q  m   -  1       superscript  q  m   1    q^{m}-1   for some   m   m   m   and     G  C  D   (  n  ,  b  )    =  1        G  C  D   n  b    1    GCD(n,b)=1   . The only vector in    G  F    (  q  )   n       G  F   superscript  q  n     GF(q)^{n}   of weight    d  -  1      d  1    d-1   or less whose spectral components    V  j     subscript  V  j    V_{j}   equal to zero for    j  =     l  1   +    l  2   b    mod  n       j   modulo     subscript  l  1      subscript  l  2   b    n     j=l_{1}+l_{2}b(\mod n)   , where     l  1   =   0  ,  ‚Ä¶  ,   d  -  s  -  2         subscript  l  1    0  normal-‚Ä¶    d  s  2      l_{1}=0,...,d-s-2   and    l  2     subscript  l  2    l_{2}   takes at least    s  +  1      s  1    s+1   values in the range    0  ,  ‚Ä¶  .  ,  d  -  2     fragments  0  normal-,  normal-‚Ä¶  normal-.  normal-,  d   2    0,....,d-2   , is the all-zero vector.  Quadratic residue codes  When the prime   l   l   l   is a quadratic residue modulo the prime   p   p   p   there is a quadratic residue code which is a cyclic code of length   p   p   p   , dimension     (   p  +  1   )   /  2        p  1   2    (p+1)/2   and minimum weight at least    p      p    \sqrt{p}   over    G  F   (  l  )       G  F  l    GF(l)   .  Generalizations  A constacyclic code is a linear code with the property that for some constant Œª if ( c 1 ,c 2 ,..., c n ) is a codeword then so is (Œª c n ,c 1 ,..., c n -1 ). A negacyclic code is a constacyclic code with Œª=-1. 8 A quasi-cyclic code has the property that for some s , any cyclic shift of a codeword by s places is again a codeword. 9 A double circulant code is a quasi-cyclic code of even length with s =2. 10  See also   Cyclic redundancy check  Polynomial code  BCH code  Reed‚ÄìMuller code  Binary Golay code  Ternary Golay code  Eugene Prange   Notes  References        Further reading   Ranjan Bose , Information theory, coding and cryptography , ISBN 0-07-048297-7  Irving S. Reed and Xuemin Chen, Error-Control Coding for Data Networks , Boston: Kluwer Academic Publishers, 1999, ISBN 0-7923-8528-4.  Scott A. Vanstone , Paul C. Van Oorschot , An introduction to error correcting codes with applications , ISBN 0-7923-9017-2   External links   John Gill's (Stanford) class notes ‚Äì Notes #3, October 8, Handout #9 , EE 387.  Jonathan Hall's (MSU) class notes ‚Äì Chapter 8. Cyclic codes - pp. 100 - 123    "  Category:Coding theory  Category:Finite fields     ‚Ü©  ‚Ü©  ‚Ü©  ‚Ü©  ‚Ü©  P. Fire, E, P. (1959). A class of multiple-error-correcting binary codes for non-independent errors. Sylvania Reconnaissance Systems Laboratory, Mountain View, CA, Rept. RSL-E-2, 1959. ‚Ü©  Wei Zhou, Shu Lin, Khaled Abdel-Ghaffar. Burst or random error correction based on Fire and BCH codes. ITA 2014: 1-5 2013. ‚Ü©  ‚Ü©  ‚Ü©      