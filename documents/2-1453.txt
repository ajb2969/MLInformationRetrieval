   Binary logarithm      Binary logarithm   (Figure)  Plot of log 2  n   In mathematics , the binary logarithm ( ) is the logarithm to the base   2   2   2    . It is the inverse function of the power of two function. The binary logarithm of   n   n   n   is the power to which the number   2   2   2   must be raised to obtain the value   n   n   n   . That is:        x  =     log  2   n   ⟺      2  x   =  n    .     formulae-sequence    x     subscript   2   n   normal-⟺       superscript  2  x   n     x=\log_{2}n\quad\Longleftrightarrow\quad 2^{x}=n.   For example, the binary logarithm of   1   1   1   is   0   0    , the binary logarithm of   2   2   2   is   1   1   1   , the binary logarithm of   4   4   4   is   2   2   2   , the binary logarithm of   8   8   8   is   3   3   3   , the binary logarithm of   16   16   16   is   4   4   4   and the binary logarithm of   32   32   32   is   5   5   5   .  The binary logarithm is closely connected to the binary numeral system . Historically, the first application of binary logarithms was in music theory , by Leonhard Euler . Other areas in which the binary logarithm is frequently used include information theory , combinatorics , computer science , bioinformatics , the design of sports tournaments , and photography .  History   Michael Stifel has been credted with publishing the first known table of binary logarithms, in 1544. His book Arthmetica Integra contains several tables that show the integers with their corresponding powers of two . Reversing the rows of these tables allow them to be interpreted as tables of binary logarithms. 1 2  Binary logarithms were considered more explicitly by Leonhard Euler in 1739. Euler established their application to music theory, long before their more significant applications in information theory and computer science became known. As part of his work in this area, Euler published a table of binary logarithms of the integers from 1 to 8, to seven decimal digits of accuracy. 3 4  Notation  In mathematics, the binary logarithm of a number   n   n   n   is written as . However, several other notations for this function have been used or proposed, especially in application areas.  Some authors write the binary logarithm as    l  g  n      l  g  n    lgn   . 5 6  Donald Knuth credits this notation to a suggestion of Edward Reingold , 7 but its use in both information theory and computer science dates to before Reingold was active. 8 9 The binary logarithm has also been written as    l  o  g  n      l  o  g  n    logn   with a prior statement that the default base for the logarithm is   2   2   2   . 10 11 12  Another notation that is sometimes used for the same function (especially in the German language ) is    l  d  n      l  d  n    ldn   , from Latin  logarithmus  duālis . 13 The ISO 31-11 and ISO 80000-2 specifications recommend yet another notation,    l  b  n      l  b  n    lbn   ; in this specification,    l  g  n      l  g  n    lgn   cannot be used for the binary logarithm, as it is instead reserved for . However, the ISO notation has not come into common use.  Applications  Information theory  The number of digits ( bits ) in the binary representation of a positive integer   n   n   n   is the integral part of , i.e. 14       ⌊    log  2   n   ⌋   +   1.           subscript   2   n    1.    \lfloor\log_{2}n\rfloor+1.\,     In information theory, the definition of the amount of self-information and information entropy is often expressed with the binary logarithm, corresponding to making the bit be the fundamental unit of information. However, the natural logarithm and the nat are also used in alternative notations for these definitions. 15  Combinatorics  Although the natural logarithm is more important than the binary logarithm in many areas of pure mathematics such as number theory and mathematical analysis , the binary logarithm has several applications in combinatorics :   Every binary tree with   n   n   n   leaves has height at least , with equality when   n   n   n   is a power of two and the tree is a complete binary tree . 16  Every family of sets with   n   n   n   different sets has at least elements in its union, with equality when the family is a power set . 17  Every partial cube with   n   n   n   vertices has isometric dimension at least , and has at most edges, with equality when the partial cube is a hypercube graph . 18  According to Ramsey's theorem , every   n   n   n   -vertex undirected graph has either a clique or an independent set of size logarithmic in   n   n   n   . The precise size that can be guaranteed is not known, but the best bounds known on its size involve binary logarithms. In particular, all graphs have a clique or independent set of size at least and almost all graphs do not have a clique or independent set of size larger than . 19  From a mathematical analysis of the Gilbert–Shannon–Reeds model of random shuffles, one can show that the number of times one needs to shuffle an   n   n   n   -card deck of cards, using riffle shuffles , to get a distribution on permutations that is close to uniformly random, is approximately . This calculation forms the basis for a recommendation that 52-card decks should be shuffled seven times. 20   Computational complexity  The binary logarithm also frequently appears in the analysis of algorithms , 21 not only because of the frequent use of binary number arithmetic in algorithms, but also because binary logarithms occur in the analysis of algorithms based on two-way branching. 22 If a problem initially has   n   n   n   choices for its solution, and each iteration of the algorithm reduces the number of choices by a factor of two, then the number of iterations needed to select a single choice is again the integral part of . This idea is used in the analysis of several algorithms and data structures . For example, in binary search , the size of the problem to be solved is halved with each iteration, and therefore roughly iterations are needed to obtain a problem of size   1   1   1   , which is solved easily in constant time. Similarly, a perfectly balanced binary search tree containing   n   n   n   elements has height .  However, the running time of an algorithm is usually expressed in big O notation , ignoring constant factors. Since , where   k   k   k   can be any number greater than   1   1   1   , algorithms that run in time can also be said to run in, say, time. The base of the logarithm in expressions such as    O   (   l  o  g  n   )       O    l  o  g  n     O(logn)   or    O   (   n  l  o  g  n   )       O    n  l  o  g  n     O(nlogn)   is therefore not important. 23 In other contexts, though, the base of the logarithm needs to be specified. For example is not the same as because the former is equal to    O   (  n  )       O  n    O(n)   and the latter to .  Algorithms with running time    O   (   n  l  o  g  n   )       O    n  l  o  g  n     O(nlogn)   are sometimes called linearithmic . 24 Some examples of algorithms with running time    O   (   l  o  g  n   )       O    l  o  g  n     O(logn)   or    O   (   n  l  o  g  n   )       O    n  l  o  g  n     O(nlogn)   are:   Average time quicksort and other comparison sort algorithms 25  Searching in balanced binary search trees 26  Exponentiation by squaring 27  Longest increasing subsequence 28   Binary logarithms also occur in the exponents of the time bounds for some divide and conquer algorithms , such as the Karatsuba algorithm for multiplying   n   n   n   -bit numbers in time . 29  Bioinformatics  In the analysis of microarray data in bioinformatics , expression rates of genes are often compared by using the binary logarithm of the ratio of expression rates. By using base   2   2   2   for the logarithm, a doubled expression rate can be described by a log ratio of   1   1   1   , a halved expression rate can be described by a log ratio of    −  1      normal-−  1    −1   , and an unchanged expression rate can be described by a log ratio of zero, for instance. 30 Data points obtained in this way are often visualized as a scatterplot in which one or both of the coordinate axes are binary logarithms of intensity ratios, or in visualizations such as the MA plot and RA plot which rotate and scale these log ratio scatterplots. 31  Music theory  In music theory , the interval or perceptual difference between two tones is determined by the ratio of their frequencies. Intervals coming from rational number ratios with small numerators and denominators are perceived as particularly euphonius. The simplest and most important of these intervals is the octave , a frequency ratio of    2  :  1     normal-:  2  1    2:1   . The number of octaves by which two tones differ is the binary logarithm of their frequency ratio. 32  In order to study tuning systems and other aspects of music theory requiring finer distinctions between tones, it is helpful to have a measure of the size of an interval that is finer than an octave and is additive (as logarithms are) rather than multiplicative (as frequency ratios are). That is, if tones   x   x   x   ,   y   y   y   , and   z   z   z   form a rising sequence of tones, then the measure of the interval from   x   x   x   to   y   y   y   plus the measure of the interval from   y   y   y   to   z   z   z   should equal the measure of the interval from   x   x   x   to   z   z   z   . Such a measure is given by the cent , which divides the octave into   1200   1200   1200   equal intervals (   12   12   12    semitones of   100   100   100   cents each). Mathematically, given tones with frequencies and , the number of cents in the interval from to is 33       |   1200    log  2     f  1    f  2      |   .        1200    subscript   2      subscript  f  1    subscript  f  2        \left|1200\log_{2}\frac{f_{1}}{f_{2}}\right|.   The millioctave is defined in the same way, but with a multiplier of   1000   1000   1000   instead of   1200   1200   1200   .  Sports scheduling  In competitive games and sports involving two players or teams in each game or match, the binary logarithm indicates the number of rounds necessary in a single-elimination tournament in order to determine a winner. For example, a tournament of   4   4   4   players requires rounds to determine the winner, a tournament of   32   32   32   teams requires rounds, etc. In this case, for   n   n   n   players/teams where   n   n   n   is not a power of 2, is rounded up since it will be necessary to have at least one round in which not all remaining competitors play. For example, is approximately   2.585   2.585   2.585   , which rounds up to   3   3   3   , indicating that a tournament of   6   6   6   teams requires   3   3   3   rounds (either two teams will sit out the first round, or one team will sit out the second round). The same number of rounds is also necessary to determine a clear winner in a Swiss-system tournament . 34  Photography  In photography , exposure values are measured in terms of the binary logarithm of the amount of light reaching the film or sensor, in accordance with the Weber–Fechner law describing a logarithmic response of the human visual system to light. A single stop of exposure is one unit on a base-   2   2   2   logarithmic scale. 35 36 More precisely, the exposure value of a photograph is defined as       log  2     N  2   t       subscript   2      superscript  N  2   t     \log_{2}\frac{N^{2}}{t}   where   N   N   N   is the f-number measuring the aperture of the lens during the exposure, and   t   t   t   is the number of seconds of exposure.  Binary logarithms (expressed as stops) are also used in densitometry , to express the dynamic range of light-sensitive materials or digital sensors. 37  Calculation  (Figure)  TI SR-50  scientific calculator (1974). The ln and log keys are in the second row; there is no log 2 key.   Conversion from other bases  An easy way to calculate on calculators that do not have a function is to use the natural logarithm (    l  n      l  n    ln   ) or the common logarithm (    l  o  g      l  o  g    log   or ) functions, which are found on most scientific calculators . The specific change of logarithm base  formulae for this are: 38 39         log  2   n   =    ln  n    ln  2    =     log  10   n     log  10   2     ,          subscript   2   n       n     2             subscript   10   n     subscript   10   2       \log_{2}n=\frac{\ln n}{\ln 2}=\frac{\log_{10}n}{\log_{10}2},   or approximately         log  2   n   ≈   1.442695   ln  n    ≈   3.321928    log  10   n     .          subscript   2   n     1.442695    n           3.321928    subscript   10   n       \log_{2}n\approx 1.442695\ln n\approx 3.321928\log_{10}n.     Integer rounding  The binary logarithm can be made into a function from integers and to integers by rounding it up or down. These two forms of integer binary logarithm are related by this formula:        ⌊    log  2    (  n  )    ⌋   =    ⌈    log  2    (   n  +  1   )    ⌉   -  1    ,    if  n   ≥  1.      formulae-sequence        subscript   2   n          subscript   2     n  1     1        if  n   1.     \lfloor\log_{2}(n)\rfloor=\lceil\log_{2}(n+1)\rceil-1,\text{ if }n\geq 1.    40 The definition can be extended by defining     ⌊    log  2    (  0  )    ⌋   =   -  1           subscript   2   0      1     \lfloor\log_{2}(0)\rfloor=-1   . Extended in this way, this function is related to the number of leading zeros of the 32-bit unsigned binary representation of   x   x   x   ,    n  l  z   (  x  )       n  l  z  x    nlz(x)   .        ⌊    log  2    (  n  )    ⌋   =   31  -   nlz   (  n  )      .          subscript   2   n      31   nlz  n      \lfloor\log_{2}(n)\rfloor=31-\operatorname{nlz}(n).    41  The integer binary logarithm can be interpreted as the zero-based index of the most significant   1   1   1   bit in the input. In this sense it is the complement of the find first set operation, which finds the index of the least significant   1   1   1   bit. Many hardware platforms include support for finding the number of leading zeros, or equivalent operations, which can be used to quickly find the binary logarithm; see find first set for details. The fls and flsl functions in the Linux kernel 42 and in some versions of the libc software library also compute the binary logarithm (rounded up to an integer, plus one).  Recursive approximation  For a general positive real number , the binary logarithm may be computed in two parts: 43   Compute the integer part,    ⌊    log  2   x   ⌋        subscript   2   x     \lfloor\log_{2}x\rfloor   (called the characteristic of the logarithm)  Compute the fractional part (the mantissa of the logarithm)   Computing the integer part is straightforward. For any    x  >  0      x  0    x>0   , there exists a unique integer   n   n   n   such that , or equivalently . Now the integer part of the logarithm is simply   n   n   n   , and the fractional part is . 44 In other words:         log  2   x   =   n  +    log  2   y       where  y   =    2   -  n    x  and  y   ∈   [  1  ,  2  )       formulae-sequence      subscript   2   x     n    subscript   2   y           where  y      superscript  2    n    x  and  y         1  2       \log_{2}x=n+\log_{2}y\quad\text{where }y=2^{-n}x\text{ and }y\in[1,2)     The fractional part of the result is , and can be computed recursively , using only elementary multiplication and division. 45 To compute the fractional part:   Start with a real number   y   y   y   in the half-open interval     1  ,  2  )   )     fragments   fragments  1  normal-,  2  normal-)   normal-)    1,2))   . If    y  =  1      y  1    y=1   , then we are done and the fractional part is zero.  Otherwise, square   y   y   y   repeatedly until the result   z   z   z   lies in the interval     2  ,  4  )   )     fragments   fragments  2  normal-,  4  normal-)   normal-)    2,4))   . Let   m   m   m   be the number of squarings needed. That is, with   m   m   m   chosen such that   m   m   m   is in     2  ,  4  )   )     fragments   fragments  2  normal-,  4  normal-)   normal-)    2,4))   .  Taking the logarithm of both sides and doing some algebra: : \begin{align}   \log_2 z &= 2^m \log_2 y \\ \log_2 y &= \frac{ \log_2 z }{ 2^m } \\ &= \frac{ 1 + \log_2(z/2) }{ 2^m } \\ &= 2^{-m} + 2^{-m}\log_2(z/2) \end{align}   Once again    z  /  2      z  2    z/2   is a real number in the interval     1  ,  2  )   )     fragments   fragments  1  normal-,  2  normal-)   normal-)    1,2))   . Return to step 1, and compute the binary logarithm of    z  /  2      z  2    z/2   using the same method recursively.   The result of this is expressed by the following formulas, in which    m  i     subscript  m  i    m_{i}   is the number of squarings required in the i -th recursion of the algorithm:       log  2   x      subscript   2   x    \displaystyle\log_{2}x     In the special case where the fractional part in step 1 is found to be zero, this is a finite sequence terminating at some point. Otherwise, it is an infinite series which converges according to the ratio test , since each term is strictly less than the previous one (since every ). For practical use, this infinite series must be truncated to reach an approximate result. If the series is truncated after the   i   i   i   th term, then the error in the result is less than .  An alternative algorithm that computes a single bit of the output in each iteration, using a sequence of shift and comparison operations to determine which bit to output, is also possible. 46  Software library support  The log2 function is included in the standard C mathematical functions . The default version of this function takes double precision arguments but variants of it allow the argument to be single-precision or to be a long double . 47  References  External links    Feynman and the Connection Machine   "  Category:Binary arithmetic  Category:Calculus  Category:Logarithms     . ↩  . A copy of the same table with two more entries appears on p. 237, and another copy extended to negative powers appears on p. 249b. ↩  . ↩  . ↩  ↩  . ↩  , [ http://books.google.com/books?id=x9AsAwAAQBAJ&pg; ;=PA11 p. 11]. The same notation was in the 1973 2nd edition of the same book (p. 23) but without the credit to Reingold. ↩  . ↩  . ↩  . ↩  . ↩  ↩  For instance, see . ↩   . ↩  . ↩  Equivalently, a family with   k   k   k   distinct elements has at most distinct sets, with equality when it is a power set. ↩  . ↩  . ↩  . ↩     , [ http://books.google.com/books?id=MTpsAQAAQBAJ&pg; ;=PA186 p. 186]. ↩  Cormen et al., p. 156; Goodrich & Tamassia, p. 238. ↩  Cormen et al., p. 276; Goodrich & Tamassia, p. 159. ↩  Cormen et al., pp. 879–880; Goodrich & Tamassia, p. 464. ↩  . ↩  Cormen et al., p. 844; Goodrich & Tamassia, p. 279. ↩  . ↩  . ↩  . ↩   . ↩  . ↩  . ↩  . ↩   . ↩  ↩   fls , Linux kernel API, kernel.org , retrieved 2010-10-17. ↩  . ↩    . ↩  . ↩     