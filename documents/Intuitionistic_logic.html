<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="614">Intuitionistic logic</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Intuitionistic logic</h1>
<hr>'''Intuitionistic logic''', sometimes more generally called '''constructive logic''', is a system of [[Mathematical logic|symbolic logic]] that dif
<p>fers from <a href="classical_logic" title="wikilink">classical logic</a> by replacing the traditional concept of truth with the concept of <a href="constructive_proof" title="wikilink">constructive provability</a>. For example, in classical logic, <a href="propositional_formula" title="wikilink">propositional formulae</a> are always assigned a <a href="truth_value" title="wikilink">truth value</a> from the two element set of trivial <a href="proposition_(mathematics)" title="wikilink">propositions</a> 

<math display="inline" id="Intuitionistic_logic:0">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mo>⊤</mo>
   <mo>,</mo>
   <mo>⊥</mo>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <csymbol cd="latexml">top</csymbol>
    <csymbol cd="latexml">bottom</csymbol>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\top,\bot\}
  </annotation>
 </semantics>
</math>

 ("true" and "false" respectively) regardless of whether we have direct <a class="uri" href="evidence" title="wikilink">evidence</a> for either case. In contrast, propositional formulae in intuitionistic logic are <em>not</em> assigned any definite truth value at all and instead <em>only</em> considered "true" when we have direct evidence, hence <em>proof</em>. (We can also say, instead of the propositional formula being "true" due to direct evidence, that it is <a href="Inhabited_set" title="wikilink">inhabited</a> by a proof in the <a href="Curry–Howard_correspondence" title="wikilink">Curry–Howard</a> sense.) Operations in intuitionistic logic therefore preserve <a href="Theory_of_justification" title="wikilink">justification</a>, with respect to evidence and provability, rather than truth-valuation.</p>

<p>Unproved statements in Intuitionistic logic are not given an intermediate truth value (as is sometimes mistakenly asserted). One can prove that such statements have no third truth value, a result dating back to <a href="Valery_Glivenko" title="wikilink">Glivenko</a> in 1928.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Instead they remain of unknown truth value, until they are either proved or disproved. Statements are disproved by deducing a contradiction from them.</p>

<p>A consequence of this point of view is that intuitionistic logic has no interpretation as a two-valued logic, nor even as a finite-valued logic, in the familiar sense. Although intuitionistic logic retains the trivial propositions 

<math display="inline" id="Intuitionistic_logic:1">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mo>⊤</mo>
   <mo>,</mo>
   <mo>⊥</mo>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <csymbol cd="latexml">top</csymbol>
    <csymbol cd="latexml">bottom</csymbol>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\top,\bot\}
  </annotation>
 </semantics>
</math>

 from classical logic, each <em>proof</em> of a propositional formula is considered a valid propositional value, thus by <a href="Brouwer-Heyting-Kolmogorov" title="wikilink">Heyting's</a> notion of propositions-as-sets, propositional formulae are (potentially non-finite) sets of their proofs.</p>

<p>From a proof-theoretic perspective, intuitionistic logic is a restriction of classical logic in which the <a href="law_of_excluded_middle" title="wikilink">law of excluded middle</a> and <a href="double_negation_elimination" title="wikilink">double negation elimination</a> are not admitted as axioms. Excluded middle and double negation elimination can still be proved for some propositions on a case by case basis, however, but do not hold universally as they do with classical logic.</p>

<p>Several systems of semantics for intuitionistic logic have been studied. One semantics mirrors classical <a href="Boolean-valued_semantics" title="wikilink">Boolean-valued semantics</a> but uses <a href="Heyting_algebra" title="wikilink">Heyting algebras</a> in place of <a href="Boolean_algebra" title="wikilink">Boolean algebras</a>. Another semantics uses <a href="Kripke_semantics" title="wikilink">Kripke models</a>.</p>

<p>Intuitionistic logic is practically useful because its restrictions produce proofs that have the <a href="existence_property" title="wikilink">existence property</a>, making it also suitable for other forms of <a href="mathematical_constructivism" title="wikilink">mathematical constructivism</a>. Informally, this means that if there is a constructive proof that an object exists, that constructive proof may be used as an algorithm for generating an example of that object.</p>

<p>Formalized intuitionistic logic was originally developed by <a href="Arend_Heyting" title="wikilink">Arend Heyting</a> to provide a formal basis for <a href="Luitzen_Egbertus_Jan_Brouwer" title="wikilink">Brouwer</a>'s programme of <a class="uri" href="intuitionism" title="wikilink">intuitionism</a>.</p>
<h2 id="syntax">Syntax</h2>

<p> The <a class="uri" href="syntax" title="wikilink">syntax</a> of formulas of intuitionistic logic is similar to <a href="propositional_logic" title="wikilink">propositional logic</a> or <a href="first-order_logic" title="wikilink">first-order logic</a>. However, intuitionistic <a href="logical_connective" title="wikilink">connectives</a> are not definable in terms of each other in the same way as in <a href="classical_logic" title="wikilink">classical logic</a>, hence their choice matters. In intuitionistic propositional logic it is customary to use →, ∧, ∨, ⊥ as the basic connectives, treating ¬<em>A</em> as an abbreviation for . In intuitionistic first-order logic both quantifiers ∃, ∀ are needed.</p>

<p>Many <a href="Tautology_(logic)" title="wikilink">tautologies</a> of classical logic can no longer be proved within intuitionistic logic. Examples include not only the <a href="law_of_excluded_middle" title="wikilink">law of excluded middle</a> , but also <a href="Peirce's_law" title="wikilink">Peirce's law</a> , and even <a href="double_negation_elimination" title="wikilink">double negation elimination</a>. In classical logic, both  and also  are theorems. In intuitionistic logic, only the former is a theorem: double negation can be introduced, but it cannot be eliminated. Rejecting  may seem strange to those more familiar with classical logic, but proving this propositional formula in intuitionistic logic would require producing a proof for the truth or falsity of <em>all possible propositional formulae</em>, which is impossible for a variety of reasons.</p>

<p>Because many classically valid tautologies are not theorems of intuitionistic logic, but all theorems of intuitionistic logic are valid classically, intuitionistic logic can be viewed as a weakening of classical logic, albeit one with many useful properties.</p>
<h3 id="sequent-calculus">Sequent calculus</h3>

<p><a href="Gerhard_Gentzen" title="wikilink">Gentzen</a> discovered that a simple restriction of his system LK (his sequent calculus for classical logic) results in a system which is sound and complete with respect to intuitionistic logic. He called this system LJ. In LK any number of formulas is allowed to appear on the conclusion side of a sequent; in contrast LJ allows at most one formula in this position.</p>

<p>Other derivatives of LK are limited to intuitionisitic derivations but still allow multiple conclusions in a sequent. LJ'<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> is one example.</p>
<h3 id="hilbert-style-calculus">Hilbert-style calculus</h3>

<p>Intuitionistic logic can be defined using the following <a href="Hilbert-style_deduction_system" title="wikilink">Hilbert-style calculus</a>. This is similar to <a href="Propositional_calculus#Alternative_calculus" title="wikilink">a way</a> of axiomatizing classical propositional logic.</p>

<p>In propositional logic, the inference rule is <a href="modus_ponens" title="wikilink">modus ponens</a></p>
<ul>
<li>MP: from 

<math display="inline" id="Intuitionistic_logic:2">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Intuitionistic_logic:3">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>→</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>ϕ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\to\psi
  </annotation>
 </semantics>
</math>

 infer 

<math display="inline" id="Intuitionistic_logic:4">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>and the axioms are</p>
<ul>
<li>THEN-1

<math display="block" id="Intuitionistic_logic:5">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>χ</mi>
    <mo>→</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">ϕ</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">χ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\to(\chi\to\phi)
  </annotation>
 </semantics>
</math>

</li>
<li>THEN-2

<math display="block" id="Intuitionistic_logic:6">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>χ</mi>
     <mo>→</mo>
     <mi>ψ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ϕ</mi>
     <mo>→</mo>
     <mi>χ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ϕ</mi>
     <mo>→</mo>
     <mi>ψ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">χ</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">ψ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">ϕ</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">χ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">ϕ</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">ψ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\to(\chi\to\psi))\to((\phi\to\chi)\to(\phi\to\psi))
  </annotation>
 </semantics>
</math>

</li>
<li>AND-1

<math display="block" id="Intuitionistic_logic:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mo>∧</mo>
    <mi>χ</mi>
   </mrow>
   <mo>→</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <and></and>
     <ci>ϕ</ci>
     <ci>χ</ci>
    </apply>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\land\chi\to\phi
  </annotation>
 </semantics>
</math>

</li>
<li>AND-2

<math display="block" id="Intuitionistic_logic:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mo>∧</mo>
    <mi>χ</mi>
   </mrow>
   <mo>→</mo>
   <mi>χ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <and></and>
     <ci>ϕ</ci>
     <ci>χ</ci>
    </apply>
    <ci>χ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\land\chi\to\chi
  </annotation>
 </semantics>
</math>

</li>
<li>AND-3

<math display="block" id="Intuitionistic_logic:9">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>χ</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ϕ</mi>
     <mo>∧</mo>
     <mi>χ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">ϕ</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">χ</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">ϕ</csymbol>
      <and></and>
      <csymbol cd="unknown">χ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\to(\chi\to(\phi\land\chi))
  </annotation>
 </semantics>
</math>

</li>
<li>OR-1

<math display="block" id="Intuitionistic_logic:10">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>→</mo>
   <mrow>
    <mi>ϕ</mi>
    <mo>∨</mo>
    <mi>χ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>ϕ</ci>
    <apply>
     <or></or>
     <ci>ϕ</ci>
     <ci>χ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\to\phi\lor\chi
  </annotation>
 </semantics>
</math>

</li>
<li>OR-2

<math display="block" id="Intuitionistic_logic:11">
 <semantics>
  <mrow>
   <mi>χ</mi>
   <mo>→</mo>
   <mrow>
    <mi>ϕ</mi>
    <mo>∨</mo>
    <mi>χ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>χ</ci>
    <apply>
     <or></or>
     <ci>ϕ</ci>
     <ci>χ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi\to\phi\lor\chi
  </annotation>
 </semantics>
</math>

</li>
<li>OR-3

<math display="block" id="Intuitionistic_logic:12">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>χ</mi>
     <mo>→</mo>
     <mi>ψ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ϕ</mi>
     <mo>∨</mo>
     <mi>χ</mi>
     <mo>→</mo>
     <mi>ψ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">χ</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">ψ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">ϕ</csymbol>
      <or></or>
      <csymbol cd="unknown">χ</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">ψ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\to\psi)\to((\chi\to\psi)\to(\phi\lor\chi\to\psi))
  </annotation>
 </semantics>
</math>

</li>
<li>FALSE

<math display="block" id="Intuitionistic_logic:13">
 <semantics>
  <mrow>
   <mo>⊥</mo>
   <mo>→</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">bottom</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">ϕ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot\to\phi
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>To make this a system of first-order predicate logic, the <a href="generalization_(logic)" title="wikilink">generalization rules</a></p>
<ul>
<li>

<math display="inline" id="Intuitionistic_logic:14">
 <semantics>
  <mo>∀</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">for-all</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall
  </annotation>
 </semantics>
</math>

-GEN: from 

<math display="inline" id="Intuitionistic_logic:15">
 <semantics>
  <mrow>
   <mi>ψ</mi>
   <mo>→</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>ψ</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi\to\phi
  </annotation>
 </semantics>
</math>

 infer 

<math display="inline" id="Intuitionistic_logic:16">
 <semantics>
  <mrow>
   <mi>ψ</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>ϕ</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>ψ</ci>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>ϕ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi\to(\forall x\ \phi)
  </annotation>
 </semantics>
</math>

, if 

<math display="inline" id="Intuitionistic_logic:17">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is not free in 

<math display="inline" id="Intuitionistic_logic:18">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Intuitionistic_logic:19">
 <semantics>
  <mo>∃</mo>
  <annotation-xml encoding="MathML-Content">
   <exists></exists>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists
  </annotation>
 </semantics>
</math>

-GEN: from 

<math display="inline" id="Intuitionistic_logic:20">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>→</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>ϕ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\to\psi
  </annotation>
 </semantics>
</math>

 infer 

<math display="inline" id="Intuitionistic_logic:21">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>ϕ</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>ϕ</ci>
     </apply>
    </apply>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\exists x\ \phi)\to\psi
  </annotation>
 </semantics>
</math>

, if 

<math display="inline" id="Intuitionistic_logic:22">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is not free in 

<math display="inline" id="Intuitionistic_logic:23">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>are added, along with the axioms</p>
<ul>
<li>PRED-1

<math display="block" id="Intuitionistic_logic:24">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>ϕ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall x\ \phi(x))\to\phi(t)
  </annotation>
 </semantics>
</math>

, if the term <em>t</em> is free for substitution for the variable <em>x</em> in 

<math display="inline" id="Intuitionistic_logic:25">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 (i.e., if no occurrence of any variable in <em>t</em> becomes bound in 

<math display="inline" id="Intuitionistic_logic:26">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(t)
  </annotation>
 </semantics>
</math>

)</li>
<li>PRED-2

<math display="block" id="Intuitionistic_logic:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>ϕ</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(t)\to(\exists x\ \phi(x))
  </annotation>
 </semantics>
</math>

, with the same restriction as for PRED-1</li>
</ul>
<h4 id="optional-connectives">Optional connectives</h4>
<h5 id="negation">Negation</h5>

<p>If one wishes to include a connective 

<math display="inline" id="Intuitionistic_logic:28">
 <semantics>
  <mi mathvariant="normal">¬</mi>
  <annotation-xml encoding="MathML-Content">
   <not></not>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lnot
  </annotation>
 </semantics>
</math>

 for negation rather than consider it an abbreviation for 

<math display="inline" id="Intuitionistic_logic:29">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>→</mo>
   <mo>⊥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>ϕ</ci>
    <csymbol cd="latexml">bottom</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\to\bot
  </annotation>
 </semantics>
</math>

, it is enough to add:</p>
<ul>
<li>NOT-1'

<math display="block" id="Intuitionistic_logic:30">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mo>⊥</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi mathvariant="normal">¬</mi>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="latexml">bottom</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <not></not>
    <csymbol cd="unknown">ϕ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\to\bot)\to\lnot\phi
  </annotation>
 </semantics>
</math>

</li>
<li>NOT-2'

<math display="block" id="Intuitionistic_logic:31">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>ϕ</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mo>⊥</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <not></not>
    <csymbol cd="unknown">ϕ</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="latexml">bottom</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lnot\phi\to(\phi\to\bot)
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>There are a number of alternatives available if one wishes to omit the connective 

<math display="inline" id="Intuitionistic_logic:32">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>

 (false). For example, one may replace the three axioms FALSE, NOT-1', and NOT-2' with the two axioms</p>
<ul>
<li>NOT-1

<math display="block" id="Intuitionistic_logic:33">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi>χ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ϕ</mi>
     <mo>→</mo>
     <mi mathvariant="normal">¬</mi>
     <mi>χ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">χ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">ϕ</csymbol>
      <ci>normal-→</ci>
      <not></not>
      <csymbol cd="unknown">χ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <not></not>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\to\chi)\to((\phi\to\lnot\chi)\to\lnot\phi)
  </annotation>
 </semantics>
</math>

</li>
<li>NOT-2

<math display="block" id="Intuitionistic_logic:34">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi>χ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">ϕ</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <not></not>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">χ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\to(\lnot\phi\to\chi)
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>as at <a href="Propositional_calculus#Axioms" title="wikilink">Propositional calculus#Axioms</a>. Alternatives to NOT-1 are 

<math display="inline" id="Intuitionistic_logic:35">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>χ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>χ</mi>
    <mo>→</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <not></not>
     <csymbol cd="unknown">χ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">χ</csymbol>
     <ci>normal-→</ci>
     <not></not>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\to\lnot\chi)\to(\chi\to\lnot\phi)
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Intuitionistic_logic:36">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi mathvariant="normal">¬</mi>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <not></not>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <not></not>
    <csymbol cd="unknown">ϕ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\to\lnot\phi)\to\lnot\phi
  </annotation>
 </semantics>
</math>

.</p>
<h5 id="equivalence">Equivalence</h5>

<p>The connective 

<math display="inline" id="Intuitionistic_logic:37">
 <semantics>
  <mo>↔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftrightarrow
  </annotation>
 </semantics>
</math>

 for equivalence may be treated as an abbreviation, with 

<math display="inline" id="Intuitionistic_logic:38">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>↔</mo>
   <mi>χ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <ci>ϕ</ci>
    <ci>χ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\leftrightarrow\chi
  </annotation>
 </semantics>
</math>

 standing for 

<math display="inline" id="Intuitionistic_logic:39">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi>χ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>χ</mi>
    <mo>→</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">χ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">χ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\to\chi)\land(\chi\to\phi)
  </annotation>
 </semantics>
</math>

. Alternatively, one may add the axioms</p>
<ul>
<li>IFF-1

<math display="block" id="Intuitionistic_logic:40">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>↔</mo>
    <mi>χ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi>χ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-↔</ci>
     <csymbol cd="unknown">χ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">χ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\leftrightarrow\chi)\to(\phi\to\chi)
  </annotation>
 </semantics>
</math>

</li>
<li>IFF-2

<math display="block" id="Intuitionistic_logic:41">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>↔</mo>
    <mi>χ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>χ</mi>
    <mo>→</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-↔</ci>
     <csymbol cd="unknown">χ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">χ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\leftrightarrow\chi)\to(\chi\to\phi)
  </annotation>
 </semantics>
</math>

</li>
<li>IFF-3

<math display="block" id="Intuitionistic_logic:42">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi>χ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>χ</mi>
     <mo>→</mo>
     <mi>ϕ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ϕ</mi>
     <mo>↔</mo>
     <mi>χ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">χ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">χ</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">ϕ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">ϕ</csymbol>
      <ci>normal-↔</ci>
      <csymbol cd="unknown">χ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\to\chi)\to((\chi\to\phi)\to(\phi\leftrightarrow\chi))
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>IFF-1 and IFF-2 can, if desired, be combined into a single axiom 

<math display="inline" id="Intuitionistic_logic:43">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>↔</mo>
    <mi>χ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ϕ</mi>
     <mo>→</mo>
     <mi>χ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>χ</mi>
     <mo>→</mo>
     <mi>ϕ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-↔</ci>
     <csymbol cd="unknown">χ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">ϕ</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">χ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">χ</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">ϕ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\leftrightarrow\chi)\to((\phi\to\chi)\land(\chi\to\phi))
  </annotation>
 </semantics>
</math>

 using conjunction.</p>
<h4 id="relation-to-classical-logic">Relation to classical logic</h4>

<p>The system of classical logic is obtained by adding any one of the following axioms:</p>
<ul>
<li>

<math display="inline" id="Intuitionistic_logic:44">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>∨</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>ϕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>ϕ</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>ϕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\lor\lnot\phi
  </annotation>
 </semantics>
</math>

 (Law of the excluded middle. May also be formulated as 

<math display="inline" id="Intuitionistic_logic:45">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi>χ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">¬</mi>
     <mi>ϕ</mi>
     <mo>→</mo>
     <mi>χ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>χ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">χ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <not></not>
      <csymbol cd="unknown">ϕ</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">χ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">χ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\to\chi)\to((\lnot\phi\to\chi)\to\chi)
  </annotation>
 </semantics>
</math>

.)</li>
<li>

<math display="inline" id="Intuitionistic_logic:46">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi mathvariant="normal">¬</mi>
    <mi>ϕ</mi>
   </mrow>
   <mo>→</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <not></not>
     <not></not>
     <ci>ϕ</ci>
    </apply>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lnot\lnot\phi\to\phi
  </annotation>
 </semantics>
</math>

 (Double negation elimination)</li>
<li>

<math display="inline" id="Intuitionistic_logic:47">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ϕ</mi>
     <mo>→</mo>
     <mi>χ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">ϕ</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">χ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">ϕ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((\phi\to\chi)\to\phi)\to\phi
  </annotation>
 </semantics>
</math>

 (Peirce's law)</li>
</ul>

<p>In general, one may take as the extra axiom any classical tautology that is not valid in the two-element <a href="Kripke_frame" title="wikilink">Kripke frame</a> 

<math display="inline" id="Intuitionistic_logic:48">
 <semantics>
  <mrow>
   <mo>∘</mo>
   <mo>⟶</mo>
   <mo>∘</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <compose></compose>
    <ci>normal-⟶</ci>
    <compose></compose>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \circ{\longrightarrow}\circ
  </annotation>
 </semantics>
</math>

 (in other words, that is not included in <a href="intermediate_logic" title="wikilink">Smetanich's logic</a>).</p>

<p>Another relationship is given by the <a href="Gödel–Gentzen_negative_translation" title="wikilink">Gödel–Gentzen negative translation</a>, which provides an <a class="uri" href="embedding" title="wikilink">embedding</a> of classical first-order logic into intuitionistic logic: a first-order formula is provable in classical logic if and only if its Gödel–Gentzen translation is provable intuitionistically. Therefore intuitionistic logic can instead be seen as a means of extending classical logic with constructive semantics.</p>

<p>In 1932, <a href="Kurt_Gödel" title="wikilink">Kurt Gödel</a> defined a system of Gödel logics intermediate between classical and intuitionistic logic; such logics are known as <a href="intermediate_logic" title="wikilink">intermediate logics</a>.</p>
<h3 id="non-interdefinability-of-operators">Non-interdefinability of operators</h3>

<p>In classical propositional logic, it is possible to take one of <a href="logical_conjunction" title="wikilink">conjunction</a>, <a href="logical_disjunction" title="wikilink">disjunction</a>, or <a href="material_conditional" title="wikilink">implication</a> as primitive, and define the other two in terms of it together with <a href="logical_negation" title="wikilink">negation</a>, such as in <a href="Jan_Łukasiewicz" title="wikilink">Łukasiewicz</a>'s <a href="propositional_logic#Example_1._Simple_axiom_system" title="wikilink">three axioms of propositional logic</a>. It is even possible to define all four in terms of a <a href="sole_sufficient_operator" title="wikilink">sole sufficient operator</a> such as the <a href="Peirce_arrow" title="wikilink">Peirce arrow</a> (NOR) or <a href="Sheffer_stroke" title="wikilink">Sheffer stroke</a> (NAND). Similarly, in classical first-order logic, one of the quantifiers can be defined in terms of the other and negation.</p>

<p>These are fundamentally consequences of the <a href="law_of_bivalence" title="wikilink">law of bivalence</a>, which makes all such connectives merely <a href="Boolean_function" title="wikilink">Boolean functions</a>. The law of bivalence does not hold in intuitionistic logic, only the <a href="law_of_non-contradiction" title="wikilink">law of non-contradiction</a>. As a result none of the basic connectives can be dispensed with, and the above axioms are all necessary. Most of the classical identities are only theorems of intuitionistic logic in one direction, although some are theorems in both directions. They are as follows:</p>

<p>Conjunction versus disjunction:</p>
<ul>
<li>

<math display="inline" id="Intuitionistic_logic:49">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>ϕ</mi>
     <mo>∧</mo>
     <mi>ψ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>ϕ</mi>
      </mrow>
      <mo>∨</mo>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>ψ</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <and></and>
     <ci>ϕ</ci>
     <ci>ψ</ci>
    </apply>
    <apply>
     <not></not>
     <apply>
      <or></or>
      <apply>
       <times></times>
       <not></not>
       <ci>ϕ</ci>
      </apply>
      <apply>
       <times></times>
       <not></not>
       <ci>ψ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\wedge\psi)\to\neg(\neg\phi\vee\neg\psi)
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Intuitionistic_logic:50">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>ϕ</mi>
     <mo>∨</mo>
     <mi>ψ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>ϕ</mi>
      </mrow>
      <mo>∧</mo>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>ψ</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <or></or>
     <ci>ϕ</ci>
     <ci>ψ</ci>
    </apply>
    <apply>
     <not></not>
     <apply>
      <and></and>
      <apply>
       <times></times>
       <not></not>
       <ci>ϕ</ci>
      </apply>
      <apply>
       <times></times>
       <not></not>
       <ci>ψ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\vee\psi)\to\neg(\neg\phi\wedge\neg\psi)
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Intuitionistic_logic:51">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>ϕ</mi>
     </mrow>
     <mo>∨</mo>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>ψ</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ϕ</mi>
      <mo>∧</mo>
      <mi>ψ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <or></or>
     <apply>
      <times></times>
      <not></not>
      <ci>ϕ</ci>
     </apply>
     <apply>
      <times></times>
      <not></not>
      <ci>ψ</ci>
     </apply>
    </apply>
    <apply>
     <not></not>
     <apply>
      <and></and>
      <ci>ϕ</ci>
      <ci>ψ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\neg\phi\vee\neg\psi)\to\neg(\phi\wedge\psi)
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Intuitionistic_logic:52">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>ϕ</mi>
     </mrow>
     <mo>∧</mo>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>ψ</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↔</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ϕ</mi>
      <mo>∨</mo>
      <mi>ψ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <and></and>
     <apply>
      <times></times>
      <not></not>
      <ci>ϕ</ci>
     </apply>
     <apply>
      <times></times>
      <not></not>
      <ci>ψ</ci>
     </apply>
    </apply>
    <apply>
     <not></not>
     <apply>
      <or></or>
      <ci>ϕ</ci>
      <ci>ψ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\neg\phi\wedge\neg\psi)\leftrightarrow\neg(\phi\vee\psi)
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Conjunction versus implication:</p>
<ul>
<li>

<math display="inline" id="Intuitionistic_logic:53">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>ϕ</mi>
     <mo>∧</mo>
     <mi>ψ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ϕ</mi>
      <mo>→</mo>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>ψ</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <and></and>
     <ci>ϕ</ci>
     <ci>ψ</ci>
    </apply>
    <apply>
     <not></not>
     <apply>
      <ci>normal-→</ci>
      <ci>ϕ</ci>
      <apply>
       <times></times>
       <not></not>
       <ci>ψ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\wedge\psi)\to\neg(\phi\to\neg\psi)
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Intuitionistic_logic:54">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>∧</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <not></not>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <and></and>
     <not></not>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\to\psi)\to\neg(\phi\wedge\neg\psi)
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Intuitionistic_logic:55">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>ϕ</mi>
     <mo>∧</mo>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>ψ</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ϕ</mi>
      <mo>→</mo>
      <mi>ψ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <and></and>
     <ci>ϕ</ci>
     <apply>
      <times></times>
      <not></not>
      <ci>ψ</ci>
     </apply>
    </apply>
    <apply>
     <not></not>
     <apply>
      <ci>normal-→</ci>
      <ci>ϕ</ci>
      <ci>ψ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\wedge\neg\psi)\to\neg(\phi\to\psi)
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Intuitionistic_logic:56">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↔</mo>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>∧</mo>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <not></not>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-↔</ci>
    <not></not>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <and></and>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\to\neg\psi)\leftrightarrow\neg(\phi\wedge\psi)
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Disjunction versus implication:</p>
<ul>
<li>

<math display="inline" id="Intuitionistic_logic:57">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>∨</mo>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <or></or>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <not></not>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\vee\psi)\to(\neg\phi\to\psi)
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Intuitionistic_logic:58">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>ϕ</mi>
    <mo>∨</mo>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <not></not>
     <csymbol cd="unknown">ϕ</csymbol>
     <or></or>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\neg\phi\vee\psi)\to(\phi\to\psi)
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Universal versus existential quantification:</p>
<ul>
<li>

<math display="inline" id="Intuitionistic_logic:59">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>x</mi>
       </mpadded>
       <mi mathvariant="normal">¬</mi>
       <mi>ϕ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>ϕ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <not></not>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <ci>x</ci>
       <not></not>
       <ci>ϕ</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall x\ \phi(x))\to\neg(\exists x\ \neg\phi(x))
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Intuitionistic_logic:60">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>x</mi>
       </mpadded>
       <mi mathvariant="normal">¬</mi>
       <mi>ϕ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>ϕ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <not></not>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>x</ci>
       <not></not>
       <ci>ϕ</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\exists x\ \phi(x))\to\neg(\forall x\ \neg\phi(x))
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Intuitionistic_logic:61">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi mathvariant="normal">¬</mi>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>x</mi>
       </mpadded>
       <mi>ϕ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>x</ci>
      <not></not>
      <ci>ϕ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <not></not>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>ϕ</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\exists x\ \neg\phi(x))\to\neg(\forall x\ \phi(x))
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Intuitionistic_logic:62">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi mathvariant="normal">¬</mi>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↔</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>x</mi>
       </mpadded>
       <mi>ϕ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <not></not>
      <ci>ϕ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <not></not>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>ϕ</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall x\ \neg\phi(x))\leftrightarrow\neg(\exists x\ \phi(x))
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>So, for example, "a or b" is a stronger propositional formula than "if not a, then b", whereas these are classically interchangeable. On the other hand, "not (a or b)" is equivalent to "not a, and also not b".</p>

<p>If we include equivalence in the list of connectives, some of the connectives become definable from others:</p>
<ul>
<li>

<math display="inline" id="Intuitionistic_logic:63">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>↔</mo>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ϕ</mi>
     <mo>→</mo>
     <mi>ψ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ψ</mi>
     <mo>→</mo>
     <mi>ϕ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-↔</ci>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-↔</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">ϕ</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">ψ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">ψ</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">ϕ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\leftrightarrow\psi)\leftrightarrow((\phi\to\psi)\land(\psi\to\phi))
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Intuitionistic_logic:64">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ϕ</mi>
     <mo>∨</mo>
     <mi>ψ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>↔</mo>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-↔</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">ϕ</csymbol>
      <or></or>
      <csymbol cd="unknown">ψ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-↔</ci>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\to\psi)\leftrightarrow((\phi\lor\psi)\leftrightarrow\psi)
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Intuitionistic_logic:65">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ϕ</mi>
     <mo>∧</mo>
     <mi>ψ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>↔</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-↔</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">ϕ</csymbol>
      <and></and>
      <csymbol cd="unknown">ψ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-↔</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\to\psi)\leftrightarrow((\phi\land\psi)\leftrightarrow\phi)
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Intuitionistic_logic:66">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>∧</mo>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ϕ</mi>
     <mo>→</mo>
     <mi>ψ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>↔</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <and></and>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-↔</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">ϕ</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">ψ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-↔</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\land\psi)\leftrightarrow((\phi\to\psi)\leftrightarrow\phi)
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Intuitionistic_logic:67">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>∧</mo>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ϕ</mi>
      <mo>∨</mo>
      <mi>ψ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>↔</mo>
     <mi>ψ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>↔</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <and></and>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-↔</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">ϕ</csymbol>
       <or></or>
       <csymbol cd="unknown">ψ</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-↔</ci>
      <csymbol cd="unknown">ψ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-↔</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\land\psi)\leftrightarrow(((\phi\lor\psi)\leftrightarrow\psi)%
\leftrightarrow\phi)
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>In particular, {∨, ↔, ⊥} and {∨, ↔, ¬} are complete bases of intuitionistic connectives.</p>

<p>As shown by Alexander Kuznetsov, either of the following connectives – the first one ternary, the second one quinary – is by itself <a href="functionally_complete" title="wikilink">functionally complete</a>: either one can serve the role of a sole sufficient operator for intuitionistic propositional logic, thus forming an analog of the <a href="Sheffer_stroke" title="wikilink">Sheffer stroke</a> from classical propositional logic:<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<ul>
<li>

<math display="inline" id="Intuitionistic_logic:68">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo>∨</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∨</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>p</mi>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>q</mi>
     <mo>↔</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <or></or>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <not></not>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <or></or>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <not></not>
     <csymbol cd="unknown">p</csymbol>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-↔</ci>
      <csymbol cd="unknown">r</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((p\lor q)\land\neg r)\lor(\neg p\land(q\leftrightarrow r)),
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Intuitionistic_logic:69">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>q</mi>
      <mo>∧</mo>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>r</mi>
      </mrow>
      <mo>∧</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>s</mi>
        <mo>∨</mo>
        <mi>t</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>p</ci>
    <apply>
     <and></and>
     <ci>q</ci>
     <apply>
      <times></times>
      <not></not>
      <ci>r</ci>
     </apply>
     <apply>
      <or></or>
      <ci>s</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\to(q\land\neg r\land(s\lor t)).
  </annotation>
 </semantics>
</math>

</li>
</ul>
<h2 id="semantics">Semantics</h2>

<p>The semantics are rather more complicated than for the classical case. A model theory can be given by <a href="Heyting_algebra" title="wikilink">Heyting algebras</a> or, equivalently, by <a href="Kripke_semantics" title="wikilink">Kripke semantics</a>. Recently, a <a href="Semantic_theory_of_truth" title="wikilink">Tarski-like model theory</a> was proved complete by <a href="Robert_Lee_Constable" title="wikilink">Bob Constable</a>, but with a different notion of completeness than classically.</p>
<h3 id="heyting-algebra-semantics">Heyting algebra semantics</h3>

<p>In classical logic, we often discuss the <a href="truth_value" title="wikilink">truth values</a> that a formula can take. The values are usually chosen as the members of a <a href="Boolean_algebra_(structure)" title="wikilink">Boolean algebra</a>. The meet and join operations in the Boolean algebra are identified with the ∧ and ∨ logical connectives, so that the value of a formula of the form <em>A</em> ∧ <em>B</em> is the meet of the value of <em>A</em> and the value of <em>B</em> in the Boolean algebra. Then we have the useful theorem that a formula is a valid proposition of classical logic if and only if its value is 1 for every <a href="valuation_(logic)" title="wikilink">valuation</a>—that is, for any assignment of values to its variables.</p>

<p>A corresponding theorem is true for intuitionistic logic, but instead of assigning each formula a value from a Boolean algebra, one uses values from a <a href="Heyting_algebra" title="wikilink">Heyting algebra</a>, of which Boolean algebras are a special case. A formula is valid in intuitionistic logic if and only if it receives the value of the top element for any valuation on any Heyting algebra.</p>

<p>It can be shown that to recognize valid formulas, it is sufficient to consider a single Heyting algebra whose elements are the open subsets of the real line <strong>R</strong>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> In this algebra, the ∧ and ∨ operations correspond to set intersection and union, and the value assigned to a formula <em>A</em> → <em>B</em> is int(<em>A</em><sup>C</sup> ∪ <em>B</em>), the <a href="interior_(topology)" title="wikilink">interior</a> of the union of the value of <em>B</em> and the <a href="complement_(set_theory)" title="wikilink">complement</a> of the value of <em>A</em>. The bottom element is the empty set ∅, and the top element is the entire line <strong>R</strong>. The negation ¬<em>A</em> of a formula <em>A</em> is (as usual) defined to be <em>A</em> → ∅. The value of ¬<em>A</em> then reduces to int(<em>A</em><sup>C</sup>), the interior of the complement of the value of <em>A</em>, also known as the <a href="exterior_(topology)" title="wikilink">exterior</a> of <em>A</em>. With these assignments, intuitionistically valid formulas are precisely those that are assigned the value of the entire line.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>For example, the formula ¬(<em>A</em> ∧ ¬<em>A</em>) is valid, because no matter what set <em>X</em> is chosen as the value of the formula <em>A</em>, the value of ¬(<em>A</em> ∧ ¬<em>A</em>) can be shown to be the entire line:</p>
<dl>
<dd>Value(¬(<em>A</em> ∧ ¬<em>A</em>)) =
</dd>
<dd>int((Value(<em>A</em> ∧ ¬<em>A</em>))<sup>C</sup>) =
</dd>
<dd>int((Value(<em>A</em>) ∩ Value(¬<em>A</em>))<sup>C</sup>) =
</dd>
<dd>int((<em>X</em> ∩ int((Value(<em>A</em>))<sup>C</sup>))<sup>C</sup>) =
</dd>
<dd>int((<em>X</em> ∩ int(<em>X</em><sup>C</sup>))<sup>C</sup>)
</dd>
</dl>

<p>A theorem of <a class="uri" href="topology" title="wikilink">topology</a> tells us that int(<em>X</em><sup>C</sup>) is a subset of <em>X</em><sup>C</sup>, so the intersection is empty, leaving:</p>
<dl>
<dd>int(∅<sup>C</sup>) = int(<strong>R</strong>) = <strong>R</strong>
</dd>
</dl>

<p>So the valuation of this formula is true, and indeed the formula is valid.</p>

<p>But the law of the excluded middle, <em>A</em> ∨ ¬<em>A</em>, can be shown to be <em>invalid</em> by letting the value of <em>A</em> be {<em>y</em> : <em>y</em> &gt; 0 }. Then the value of ¬<em>A</em> is the interior of {<em>y</em> : <em>y</em> ≤ 0 }, which is {<em>y</em> : <em>y</em>  0 } and {<em>y</em> : <em>y</em>  Conversely, for every invalid formula, there is an assignment of values to the variables that yields a valuation that differs from the top element.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> No finite Heyting algebra has both these properties.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h3 id="kripke-semantics">Kripke semantics</h3>

<p>Building upon his work on semantics of <a href="modal_logic" title="wikilink">modal logic</a>, <a href="Saul_Kripke" title="wikilink">Saul Kripke</a> created another semantics for intuitionistic logic, known as <strong>Kripke semantics</strong> or <strong>relational semantics</strong>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h3 id="tarski-like-semantics">Tarski-like semantics</h3>

<p>It was discovered that Tarski-like semantics for intuitionistic logic were not possible to prove complete. However, <a href="Robert_Lee_Constable" title="wikilink">Robert Constable</a> has shown that a weaker notion of completeness still holds for intuitionistic logic under a Tarski-like model. In this notion of completeness we are concerned not with all of the statements that are true of every model, but with the statements that are true <em>in the same way</em> in every model. That is, a single proof that the model judges a formula to be true must be valid for every model. In this case, there is not only a proof of completeness, but one that is valid according to intuitionistic logic.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h3 id="relation-to-other-logics">Relation to other logics</h3>

<p>Intuitionistic logic is related by <a href="duality_(mathematics)" title="wikilink">duality</a> to a <a href="paraconsistent_logic" title="wikilink">paraconsistent logic</a> known as <em>Brazilian</em>, <em>anti-intuitionistic</em> or <em>dual-intuitionistic logic</em>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>The subsystem of intuitionistic logic with the FALSE axiom removed is known as <a href="minimal_logic" title="wikilink">minimal logic</a>.</p>
<h4 id="relation-to-many-valued-logic">Relation to many-valued logic</h4>

<p><a href="Kurt_Gödel" title="wikilink">Kurt Gödel</a> in 1932 showed that intuitionistic logic is not a <a href="many-valued_logic" title="wikilink">finitely-many valued logic</a>. (See the section titled <a href="#Heyting_algebra_semantics" title="wikilink">Heyting algebra semantics</a> above for a sort of "infinitely-many valued logic" interpretation of intuitionistic logic.)</p>
<h4 id="relation-to-intermediate-logics">Relation to intermediate logics</h4>

<p>Any finite Heyting algebra which is not equivalent to a Boolean algebra defines (semantically) an <a href="intermediate_logic" title="wikilink">intermediate logic</a>. On the other hand, validity of formulae in pure intuitionistic logic is not tied to any individual Heyting algebra but relates to any and all Heyting algebras at the same time.</p>
<h4 id="relation-to-modal-logic">Relation to modal logic</h4>

<p>Any formula of the intuitionistic propositional logic may be translated into the <a href="modal_logic" title="wikilink">modal logic S4</a> as follows:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Intuitionistic_logic:70">
 <semantics>
  <msup>
   <mo>⊥</mo>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <csymbol cd="latexml">bottom</csymbol>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot^{*}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>=</p></td>
<td style="text-align: left;">
<p>  

<math display="inline" id="Intuitionistic_logic:71">
 <semantics>
  <mo lspace="7.5pt">⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \bot
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Intuitionistic_logic:72">
 <semantics>
  <msup>
   <mi>A</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>A</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{*}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>=</p></td>
<td style="text-align: left;">
<p>  

<math display="inline" id="Intuitionistic_logic:73">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="5pt" width="+5pt">
     <mi mathvariant="normal">□</mi>
    </mpadded>
    <mi>A</mi>
   </mrow>
   <mrow>
    <mtext>if</mtext>
    <mi>A</mi>
    <mtext>is prime (a positive literal)</mtext>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <mtext>if</mtext>
     <ci>A</ci>
     <mtext>is prime (a positive literal)</mtext>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \Box A\qquad\hbox{if }A\hbox{ is prime (a positive literal)}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Intuitionistic_logic:74">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mo>∧</mo>
     <mi>B</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <and></and>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\wedge B)^{*}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>=</p></td>
<td style="text-align: left;">
<p>  

<math display="inline" id="Intuitionistic_logic:75">
 <semantics>
  <mrow>
   <msup>
    <mpadded lspace="5pt" width="+5pt">
     <mi>A</mi>
    </mpadded>
    <mo>*</mo>
   </msup>
   <mo>∧</mo>
   <msup>
    <mi>B</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <times></times>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>B</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ A^{*}\wedge B^{*}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Intuitionistic_logic:76">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mo>∨</mo>
     <mi>B</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <or></or>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\vee B)^{*}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>=</p></td>
<td style="text-align: left;">
<p>  

<math display="inline" id="Intuitionistic_logic:77">
 <semantics>
  <mrow>
   <msup>
    <mpadded lspace="5pt" width="+5pt">
     <mi>A</mi>
    </mpadded>
    <mo>*</mo>
   </msup>
   <mo>∨</mo>
   <msup>
    <mi>B</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <times></times>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>B</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ A^{*}\vee B^{*}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Intuitionistic_logic:78">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\rightarrow B)^{*}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>=</p></td>
<td style="text-align: left;">
<p>  

<math display="inline" id="Intuitionistic_logic:79">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi mathvariant="normal">□</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>A</mi>
     <mo>*</mo>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>B</mi>
     <mo>*</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">□</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <times></times>
     </apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <times></times>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \Box(A^{*}\rightarrow B^{*})
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Intuitionistic_logic:80">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <times></times>
     <not></not>
     <ci>A</ci>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\neg A)^{*}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>=</p></td>
<td style="text-align: left;">
<p>  

<math display="inline" id="Intuitionistic_logic:81">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded lspace="5pt" width="+5pt">
      <mi mathvariant="normal">□</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>A</mi>
         <mo>*</mo>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mtext>since</mtext>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mi>A</mi>
   <mo>→</mo>
   <mo>⊥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <list>
      <apply>
       <times></times>
       <ci>normal-□</ci>
       <apply>
        <not></not>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>A</ci>
         <times></times>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <mtext>since</mtext>
       <not></not>
       <ci>A</ci>
      </apply>
     </list>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <csymbol cd="latexml">bottom</csymbol>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \Box(\neg(A^{*}))\qquad\hbox{since }\neg A:=A\rightarrow\bot
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>and it has been demonstrated<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> that the translated formula is valid in the propositional modal logic S4 if and only if the pre-translated formula is valid in IPC. The above set of formulae are called the <a href="Modal_companion" title="wikilink">Gödel–McKinsey–Tarski translation</a>.</p>

<p>There is also an intuitionistic version of modal logic S4 called Constructive Modal Logic CS4.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h3 id="lambda-calculus">Lambda calculus</h3>

<p>There is an extended <a href="Curry–Howard_isomorphism" title="wikilink">Curry–Howard isomorphism</a> between IPC and <a href="simply-typed_lambda_calculus" title="wikilink">simply-typed lambda calculus</a>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="BHK_interpretation" title="wikilink">BHK interpretation</a></li>
<li><a href="Intuitionistic_Type_Theory" title="wikilink">Intuitionistic Type Theory</a></li>
<li><a href="Intermediate_logics" title="wikilink">Intermediate logics</a></li>
<li><a href="Linear_logic" title="wikilink">Linear logic</a></li>
<li><a href="Constructive_proof" title="wikilink">Constructive proof</a></li>
<li><a href="Curry–Howard_correspondence" title="wikilink">Curry–Howard correspondence</a></li>
<li><a href="Computability_logic" title="wikilink">Computability logic</a></li>
<li><a href="Game_semantics" title="wikilink">Game semantics</a></li>
<li><a href="Smooth_infinitesimal_analysis" title="wikilink">Smooth infinitesimal analysis</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li><a href="Dirk_van_Dalen" title="wikilink">van Dalen, Dirk</a>, 2001, "Intuitionistic Logic", in Goble, Lou, ed., <em>The Blackwell Guide to Philosophical Logic</em>. Blackwell.</li>
<li>Morten H. Sørensen, Paweł Urzyczyn, 2006, <em>Lectures on the Curry-Howard Isomorphism</em> (chapter 2: "Intuitionistic Logic"). Studies in Logic and the Foundations of Mathematics vol. 149, Elsevier.</li>
<li>W. A. Carnielli (with A. B.M. Brunner).<a href="http://dx.doi.org/10.1016/j.jal.2004.07.016">"Anti-intuitionism and paraconsistency"</a>. Journal of Applied Logic Volume 3, Issue 1, March 2005, pages 161-184.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="Stanford_Encyclopedia_of_Philosophy" title="wikilink">Stanford Encyclopedia of Philosophy</a>: "<a href="http://plato.stanford.edu/entries/logic-intuitionistic/">Intuitionistic Logic</a>"—by Joan Moschovakis.</li>
<li><a href="http://www.cs.le.ac.uk/people/nb118/Publications/ESSLLI'05.pdf">Intuitionistic Logic</a> by Nick Bezhanishvili and Dick de Jongh (from the Institute for Logic, Language and Computation at the <a href="University_of_Amsterdam" title="wikilink">University of Amsterdam</a>)</li>
<li><a href="https://www.princeton.edu/~hhalvors/restricted/kripke_intuitionism.pdf">Semantical Analysis of Intuitionistic Logic I</a> by Saul A. Kripke from <em>Harvard University, Cambridge, Mass., USA</em></li>
<li><a href="http://www.phil.uu.nl/~dvdalen/articles/Blackwell(Dalen).pdf">Intuitionistic Logic</a> by <em><a href="Dirk_van_Dalen" title="wikilink">Dirk van Dalen</a></em></li>
<li><a href="http://www.illc.uva.nl/j50/contribs/troelstra/troelstra.pdf">The discovery of E.W. Beth's semantics for intuitionistic logic</a> by A.S. Troelstra and P. van Ulsen</li>
<li><a href="ftp://ftp.cs.toronto.edu/pub/bonner/papers/hypotheticals/naclp89.ps">Expressing Database Queries with Intuitionistic Logic</a> (<em>FTP one-click download</em>) by Anthony J. Bonner. L. Thorne McCarty. Kumar Vadaparty. Rutgers University, Department of Computer Science.</li>
<li><a href="http://teachinglogic.liglab.fr/INT1/index.php">Tableaux'method for intuitionistic logic through S4-translation</a> tests the intuitionistic validity of propositional formulae; provided by the Laboratoire d'Informatique de <a class="uri" href="Grenoble" title="wikilink">Grenoble</a>.</li>
<li><a href="http://www.playmycode.com/play/game/torusglider/validity-tester-for-ipc">Validity tester for IPC</a> (based on <a href="http://www.playmycode.com/play/game/torusglider/mezhirovs-game-for-ipc">Mezhirov's game for IPC</a>) at <em>playmycode.com</em></li>
</ul>

<p><a href="de:Intuitionismus_(Logik_und_Mathematik)" title="wikilink">de:Intuitionismus (Logik und Mathematik)</a>"</p>

<p><a href="Category:Logic_in_computer_science" title="wikilink">Category:Logic in computer science</a> <a href="Category:Non-classical_logic" title="wikilink">Category:Non-classical logic</a> <a href="Category:Constructivism_(mathematics)" title="wikilink">Category:Constructivism (mathematics)</a> <a href="Category:Systems_of_formal_logic" title="wikilink">Category:Systems of formal logic</a> <a class="uri" href="Category:Intuitionism" title="wikilink">Category:Intuitionism</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://plato.stanford.edu/entries/intuitionistic-logic-development/#4.3">Proof that intuitionistic logic has no third truth value, Glivenko 1928</a><a href="#fnref1">↩</a></li>
<li id="fn2">Proof Theory by G. Takeuti, ISBN 0-444-10492-5<a href="#fnref2">↩</a></li>
<li id="fn3">Alexander Chagrov, Michael Zakharyaschev, <em>Modal Logic</em>, vol. 35 of Oxford Logic Guides, Oxford University Press, 1997, pp. 58–59. ISBN 0-19-853779-4.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6">Alfred Tarski, <em>Der Aussagenkalkül und die Topologie</em>, Fundamenta Mathematicae 31 (1938), 103–134. [<a class="uri" href="http://matwbn.icm.edu.pl/tresc.php?wyd=1&amp;tom">http://matwbn.icm.edu.pl/tresc.php?wyd=1&amp;tom;</a>;=31]<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"><a href="http://plato.stanford.edu/entries/logic-intuitionistic/">Intuitionistic Logic</a>. Written by <a href="http://www.math.ucla.edu/~joan/">Joan Moschovakis</a>. Published in Stanford Encyclopedia of Philosophy.<a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12">Lévy, Michel (2011). <a href="http://teachinglogic.liglab.fr/INT1/S4Lint.pdf"><em>Logique modale propositionnelle S4 et logique intuitioniste propositionnelle</em></a>, pp. 4–5.<a href="#fnref12">↩</a></li>
<li id="fn13">Natasha Alechina, Michael Mendler, <a href="Valeria_de_Paiva" title="wikilink">Valeria de Paiva</a>, and Eike Ritter. <a href="http://www.cs.nott.ac.uk/~nza/papers/Alechina++:01a.pdf"><em>Categorical and Kripke Semantics for Constructive S4 Modal Logic</em></a><a href="#fnref13">↩</a></li>
<li id="fn14"></li>
</ol>
</section>
</hr></body>
</html>
