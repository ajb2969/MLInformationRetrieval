<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1376">Lambda calculus definition</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Lambda calculus definition</h1>
<hr/>

<p>Formal definitions of the <a href="Lambda_calculus" title="wikilink">Lambda calculus</a>. Lambda calculus is a programming language based on lambda abstraction and function application. Two definitions of the language are given here.</p>
<ul>
<li>Standard definition</li>
<li>Definition using mathematical formulas.</li>
</ul>
<h2 id="standard-definition">Standard definition</h2>

<p>This formal definition was given by <a href="Alonzo_Church" title="wikilink">Alonzo Church</a>.</p>
<h3 id="definition">Definition</h3>

<p>Lambda expressions are composed of</p>
<ul>
<li>variables v<sub>1</sub>, v<sub>2</sub>, ..., v<sub>n</sub>, ...</li>
<li>the abstraction symbols lambda 'λ' and dot '.'</li>
<li>parentheses ( )</li>
</ul>

<p>The set of lambda expressions, Λ, can be <a href="Recursive_definition" title="wikilink">defined inductively</a>:</p>
<ol>
<li>If x is a variable, then x ∈ Λ</li>
<li>If x is a variable and M ∈ Λ, then (λx.M) ∈ Λ</li>
<li>If M, N ∈ Λ, then (M N) ∈ Λ</li>
</ol>

<p>Instances of rule 2 are known as abstractions and instances of rule 3 are known as applications.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h3 id="notation">Notation</h3>

<p>To keep the notation of lambda expressions uncluttered, the following conventions are usually applied.</p>
<ul>
<li>Outermost parentheses are dropped: M N instead of (M N)</li>
<li>Applications are assumed to be left associative: M N P may be written instead of ((M N) P)<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></li>
<li>The body of an abstraction extends <a href="Regular_expression#Lazy_quantification" title="wikilink">as far right as possible</a>: λx.M N means λx.(M N) and not (λx.M) N</li>
<li>A sequence of abstractions is contracted: λx.λy.λz.N is abbreviated as λxyz.N<ref name="Selinger"></ref></li>
</ul>

<p><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h3 id="free-and-bound-variables">Free and bound variables</h3>

<p>The abstraction operator, λ, is said to bind its variable wherever it occurs in the body of the abstraction. Variables that fall within the scope of an abstraction are said to be <em>bound</em>. All other variables are called <em>free</em>. For example, in the following expression y is a bound variable and x is free: <code>λ''y''.''x'' ''x'' ''y''</code>. Also note that a variable is bound by its "nearest" abstraction. In the following example the single occurrence of x in the expression is bound by the second lambda: <code>λ''x''.''y''  (λ''x''.''z'' ''x'')</code></p>

<p>The set of <em>free variables</em> of a lambda expression, M, is denoted as FV(M) and is defined by recursion on the structure of the terms, as follows:</p>
<ol>
<li>FV(x) = {x}, where x is a variable</li>
<li>FV(λx.M) = FV(M) \ {x}</li>
<li>FV(M N) = FV(M) ∪ FV(N)<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></li>
</ol>

<p>An expression that contains no free variables is said to be <em>closed</em>. Closed lambda expressions are also known as combinators and are equivalent to terms in <a href="combinatory_logic" title="wikilink">combinatory logic</a>.</p>
<h3 id="reduction">Reduction</h3>

<p>The meaning of lambda expressions is defined by how expressions can be reduced.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>There are three kinds of reduction:</p>
<ul>
<li><strong>α-conversion</strong>: changing bound variables (<strong>alpha</strong>);</li>
<li><strong>β-reduction</strong>: applying functions to their arguments (<strong>beta</strong>);</li>
<li><strong>η-conversion</strong>: which captures a notion of extensionality (<strong>eta</strong>).</li>
</ul>

<p>We also speak of the resulting equivalences: two expressions are <em>β-equivalent</em>, if they can be β-converted into the same expression, and α/η-equivalence are defined similarly.</p>

<p>The term <em>redex</em>, short for <em>reducible expression</em>, refers to subterms that can be reduced by one of the reduction rules. For example, <code>(λ''x''.M) N</code> is a beta-redex in expressing the substitution of N for x in M; if <code>''x''</code> is not free in <code>M</code>, <code>λ''x''.M ''x''</code> is an eta-redex. The expression to which a redex reduces is called its reduct; using the previous example, the reducts of these expressions are respectively <code>M[''x'':=N]</code> and <code>M</code>.</p>
<h4 id="α-conversion">α-conversion</h4>

<p>Alpha-conversion, sometimes known as alpha-renaming,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> allows bound variable names to be changed. For example, alpha-conversion of <code>λ''x''.''x''</code> might yield <code>λ''y''.''y''</code>. Terms that differ only by alpha-conversion are called <em>α-equivalent</em>. Frequently in uses of lambda calculus, α-equivalent terms are considered to be equivalent.</p>

<p>The precise rules for alpha-conversion are not completely trivial. First, when alpha-converting an abstraction, the only variable occurrences that are renamed are those that are bound to the same abstraction. For example, an alpha-conversion of <code>λ''x''.λ''x''.''x''</code> could result in <code>λ''y''.λ''x''.''x''</code>, but it could <em>not</em> result in <code>λ''y''.λ''x''.''y''</code>. The latter has a different meaning from the original.</p>

<p>Second, alpha-conversion is not possible if it would result in a variable getting captured by a different abstraction. For example, if we replace <code>''x''</code> with <code>''y''</code> in <code>λ''x''.λ''y''.''x''</code>, we get <code>λ''y''.λ''y''.''y''</code>, which is not at all the same.</p>

<p>In programming languages with static scope, alpha-conversion can be used to make <a href="name_resolution" title="wikilink">name resolution</a> simpler by ensuring that no variable name <a href="Variable_shadowing" title="wikilink">masks</a> a name in a containing <a href="scope_(programming)" title="wikilink">scope</a> (see <a href="Name_resolution#Alpha_renaming_to_make_name_resolution_trivial" title="wikilink">alpha renaming to make name resolution trivial</a>).</p>
<h5 id="substitution">Substitution</h5>

<p>Substitution, written <code>''E''[''V'' := ''R'']</code>, is the process of replacing all free occurrences of the variable <code>''V''</code> in the expression <code>''E''</code> with expression <code>''R''</code>. Substitution on terms of the λ-calculus is defined by recursion on the structure of terms, as follows (note: x and y are only variables while M and N are any λ expression).</p>
<dl>
<dd><code>''x''[''x'' := N]        ≡ N</code>
</dd>
<dd><code>''y''[''x'' := N]        ≡ ''y'', if ''x'' ≠ ''y''</code>
</dd>
<dd><code>(M<sub>1</sub> M<sub>2</sub>)[''x'' := N]  ≡ (M<sub>1</sub>[''x'' := N]) (M<sub>2</sub>[''x'' := N])</code>
</dd>
<dd><code>(λ''x''.M)[''x'' := N]   ≡ λ''x''.M</code>
</dd>
<dd><code>(λ''y''.M)[''x'' := N]   ≡ λ''y''.(M[''x'' := N]), if ''x'' ≠ ''y'', ''provided'' ''y'' ∉ FV(N)</code>
</dd>
</dl>

<p>To substitute into a lambda abstraction, it is sometimes necessary to α-convert the expression. For example, it is not correct for <code>(λ''x''.''y'')[''y'' := ''x'']</code> to result in <code>(λ''x''.''x'')</code>, because the substituted <code>''x''</code> was supposed to be free but ended up being bound. The correct substitution in this case is <code>(λ''z''.''x'')</code>, up to α-equivalence. Notice that substitution is defined uniquely up to α-equivalence.</p>
<h4 id="β-reduction">β-reduction</h4>

<p>Beta-reduction captures the idea of function application. Beta-reduction is defined in terms of substitution: the beta-reduction of <code> ((λ''V''.''E'') ''E′'') </code> is <code>''E''[''V'' := ''E′'']</code>.</p>

<p>For example, assuming some encoding of <code>2, 7, ×</code>, we have the following β-reduction: <code>((λ''n''.''n''×2) 7) </code>→<code> 7×2</code>.</p>
<h4 id="η-conversion">η-conversion</h4>

<p>Eta-conversion expresses the idea of <a class="uri" href="extensionality" title="wikilink">extensionality</a>, which in this context is that two functions are the same <a href="if_and_only_if" title="wikilink">if and only if</a> they give the same result for all arguments. Eta-conversion converts between <code>λ''x''.(''f'' ''x'')</code> and <code>''f''</code> whenever <code>''x''</code> does not appear free in <code>''f''</code>.</p>
<h3 id="normalization">Normalization</h3>

<p>The purpose of beta-reduction is to calculate a value. A value in Lambda Calculus is a function. So beta-reduction continues until the expression looks like a function abstraction.</p>

<p>An lambda expression that cannot be reduced further, by either beta-redex, or eta-redex is in normal form. Note that alpha-conversion may convert functions. All normal forms that can be converted into each other by alpha conversion are defined to be equal. See the main article on <a href="Beta_normal_form" title="wikilink">Beta normal form</a> for details.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Normal Form Type</p></th>
<th style="text-align: left;">
<p>Definition.</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Normal Form</p></td>
<td style="text-align: left;">
<p>No beta or eta reductions are possible.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Head Normal Form</p></td>
<td style="text-align: left;">
<p>In the form of a lambda abstraction whose body is not reducible.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Weak Head Normal Form</p></td>
<td style="text-align: left;">
<p>In the form of a lambda abstraction.</p></td>
</tr>
</tbody>
</table>
<h2 id="evaluation-strategy">Evaluation strategy</h2>

<p>Whether a term is normalising or not, and how much work needs to be done in normalising it if it is, depends to a large extent on the reduction strategy used. The distinction between reduction strategies relates to the distinction in functional programming languages between <a href="eager_evaluation" title="wikilink">eager evaluation</a> and <a href="lazy_evaluation" title="wikilink">lazy evaluation</a>.</p>
<dl>
<dt>Full beta reductions: Any redex can be reduced at any time. This means essentially the lack of any particular reduction strategy—with regard to reducibility, "all bets are off".<br/>
Applicative order: The leftmost, innermost redex is always reduced first. Intuitively this means a function's arguments are always reduced before the function itself. Applicative order always attempts to apply functions to normal forms, even when this is not possible.</dt>
<dd>Most programming languages (including Lisp, ML and imperative languages like C and <a href="Java_programming_language" title="wikilink">Java</a>) are described as "strict", meaning that functions applied to non-normalising arguments are non-normalising. This is done essentially using applicative order, call by value reduction (<a href="#Call_by_value" title="wikilink">see below</a>), but usually called "eager evaluation".
</dd>
<dt>Normal order: The leftmost, outermost redex is always reduced first. That is, whenever possible the arguments are substituted into the body of an abstraction before the arguments are reduced.<br/>
Call by name: As normal order, but no reductions are performed inside abstractions. For example <code>λ''x''.(λ''x''.''x'')''x''</code> is in normal form according to this strategy, although it contains the redex <code>(λ''x''.''x'')''x''</code>.<br/>
Call by value: Only the outermost redexes are reduced: a redex is reduced only when its right hand side has reduced to a value (variable or lambda abstraction).<br/>
Call by need: As normal order, but function applications that would duplicate terms instead name the argument, which is then reduced only "when it is needed". Called in practical contexts "lazy evaluation". In implementations this "name" takes the form of a pointer, with the redex represented by a <a href="thunk_(functional_programming)" title="wikilink">thunk</a>.</dt>
</dl>

<p>Applicative order is not a normalising strategy. The usual counterexample is as follows: define <code>'''Ω''' = ωω</code> where <code>'''ω''' = λ''x''.''xx''</code>. This entire expression contains only one redex, namely the whole expression; its reduct is again <code>'''Ω'''</code>. Since this is the only available reduction, <code>'''Ω'''</code> has no normal form (under any evaluation strategy). Using applicative order, the expression <code>'''KIΩ''' = (λ''x''.λ''y''.''x'') (λ''x''.''x'')'''Ω'''</code> is reduced by first reducing <code>'''Ω'''</code> to normal form (since it is the rightmost redex), but since <code>'''Ω'''</code> has no normal form, applicative order fails to find a normal form for <code>'''KIΩ'''</code>.</p>

<p>In contrast, normal order is so called because it always finds a normalising reduction, if one exists. In the above example, <code>'''KIΩ'''</code> reduces under normal order to <em>I</em>, a normal form. A drawback is that redexes in the arguments may be copied, resulting in duplicated computation (for example, <code>(λ''x''.''xx'') ((λ''x''.''x'')''y'')</code> reduces to <code>((λ''x''.''x'')''y'') ((λ''x''.''x'')''y'')</code> using this strategy; now there are two redexes, so full evaluation needs two more steps, but if the argument had been reduced first, there would now be none).</p>

<p>The positive tradeoff of using applicative order is that it does not cause unnecessary computation, if all arguments are used, because it never substitutes arguments containing redexes and hence never needs to copy them (which would duplicate work). In the above example, in applicative order <code>(λ''x''.''xx'') ((λ''x''.''x'')''y'')</code> reduces first to <code>(λ''x''.''xx'')''y''</code> and then to the normal order <code>''yy''</code>, taking two steps instead of three.</p>

<p>Most <em>purely</em> functional programming languages (notably <a href="Miranda_(programming_language)" title="wikilink">Miranda</a> and its descendents, including Haskell), and the proof languages of <a href="Automated_theorem_prover" title="wikilink">theorem provers</a>, use <em>lazy evaluation</em>, which is essentially the same as call by need. This is like normal order reduction, but call by need manages to avoid the duplication of work inherent in normal order reduction using <em>sharing</em>. In the example given above, <code>(λ''x''.''xx'') ((λ''x''.''x'')''y'')</code> reduces to <code>((λ''x''.''x'')''y'') ((λ''x''.''x'')''y'')</code>, which has two redexes, but in call by need they are represented using the same object rather than copied, so when one is reduced the other is too.</p>
<h2 id="syntax-definition-in-bnf">Syntax definition in BNF</h2>

<p>Lambda Calculus has a simple syntax. A Lambda Calculus program has the syntax of an expression where,</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Name</p></th>
<th style="text-align: left;">
<p>BNF</p></th>
<th style="text-align: left;">
<p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Abstraction</p></td>
<td style="text-align: left;">
<p><expression> ::= λ <variable-list> . <expression></expression></variable-list></expression></p></td>
<td style="text-align: left;">
<p>Anonymous function definition.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Application term</p></td>
<td style="text-align: left;">
<p><expression> ::= <application-term></application-term></expression></p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Application</p></td>
<td style="text-align: left;">
<p><application-term> ::= <application-term> <item></item></application-term></application-term></p></td>
<td style="text-align: left;">
<p>A function call.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Item</p></td>
<td style="text-align: left;">
<p><application-term> ::= <item></item></application-term></p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Variable</p></td>
<td style="text-align: left;">
<p><item> ::= <variable></variable></item></p></td>
<td style="text-align: left;">
<p>E.g. x, y, fact, sum, ...</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Grouping</p></td>
<td style="text-align: left;">
<p><item> ::= ( <expression> )</expression></item></p></td>
<td style="text-align: left;">
<p>Bracketed expression.</p></td>
</tr>
</tbody>
</table>

<p>The variable list is defined as,</p>
<dl>
<dd><variable-list> := <variable> | <variable>, <variable-list>
</variable-list></variable></variable></variable-list></dd>
</dl>

<p>A variable as used by computer scientists has the syntax,</p>
<dl>
<dd><variable> ::= <alpha> <extension>
</extension></alpha></variable></dd>
<dd><extension> ::=
</extension></dd>
<dd><extension> ::= <extension-char> <extension>
</extension></extension-char></extension></dd>
<dd><extension-char> ::= <alpha> | <digit> | _
</digit></alpha></extension-char></dd>
</dl>

<p>Mathematicians will sometimes restrict a variable to be a single alphabetic character. When using this convention the comma is omitted from the variable list.</p>

<p>A lambda abstraction has a lower precedence than an application, so;</p>

<p>

<math display="block" id="Lambda_calculus_definition:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mpadded width="+5pt">
      <mi>y</mi>
     </mpadded>
     <mi>z</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>y</mi>
     </mpadded>
     <mi>z</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.y\ z=\lambda x.(y\ z)
  </annotation>
 </semantics>
</math>

</p>

<p>Applications are left associative;</p>

<p>

<math display="block" id="Lambda_calculus_definition:1">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>y</mi>
    </mpadded>
    <mi>z</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>y</mi>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>y</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\ y\ z=(x\ y)\ z
  </annotation>
 </semantics>
</math>

</p>

<p>An abstraction with multiple parameters is equivalent to multiple abstractions of one parameter.</p>

<p>

<math display="block" id="Lambda_calculus_definition:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>λ</mi>
     <mi>x</mi>
    </mrow>
    <mo>,</mo>
    <mi>y</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>z</mi>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>y</mi>
   </mrow>
   <mo>.</mo>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <list>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
     <ci>y</ci>
    </list>
    <apply>
     <eq></eq>
     <ci>z</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>y</ci>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x,y.z=\lambda x.\lambda y.z
  </annotation>
 </semantics>
</math>

 where,</p>
<ul>
<li>x is a variable</li>
<li>y is a variable list</li>
<li>z is an expression</li>
</ul>
<h2 id="definition-as-mathematical-formulas">Definition as mathematical formulas</h2>

<p>The problem of how variables may be renamed is difficult. This definition avoids the problem by substituting all names with canonical names, which are constructed based on the position of the definition of the name in the expression. The approach is analogous to what a compiler does, but has been adapted to work within the constraints of mathematics.</p>
<h3 id="semantics">Semantics</h3>

<p>The execution of a lambda expression proceeds using the following reductions and transformations,</p>
<ol>
<li>alpha conversion - 

<math display="inline" id="Lambda_calculus_definition:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>alpha</mi>
     <mo>-</mo>
     <mi>con</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo>canonym</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mi>P</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>canonym</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>A</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>P</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <apply>
       <minus></minus>
       <ci>alpha</ci>
       <ci>con</ci>
      </apply>
      <ci>a</ci>
     </apply>
     <apply>
      <ci>canonym</ci>
      <ci>A</ci>
      <ci>P</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>canonym</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>A</ci>
       </apply>
      </apply>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{alpha-con}(a)\to\operatorname{canonym}[A,P]=\operatorname{%
canonym}[a[A],P]
  </annotation>
 </semantics>
</math>


</li>
<li>beta reduction - 

<math display="inline" id="Lambda_calculus_definition:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>beta</mi>
    <mo>-</mo>
    <mi>redex</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>b</mi>
    </mpadded>
    <mi>v</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>b</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>p</mi>
    <mo>:=</mo>
    <mi>v</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>beta</ci>
     <ci>redex</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">b</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{beta-redex}[\lambda p.b\ v]=b[p:=v]
  </annotation>
 </semantics>
</math>

</li>
<li>eta reduction - 

<math display="inline" id="Lambda_calculus_definition:5">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∉</mo>
   <mo>FV</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>eta</mi>
    <mo>-</mo>
    <mi>redex</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <notin></notin>
    <ci>FV</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <apply>
     <minus></minus>
     <ci>eta</ci>
     <ci>redex</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">f</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\not\in\operatorname{FV}(f)\to\operatorname{eta-redex}[\lambda x.(f\ x)]=f
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>where,</p>
<ul>
<li><a href="#Canonym_-_Canonical_Names" title="wikilink">canonym</a> is a renaming of a lambda expression to give the expression standard names, based on the position of the name in the expression.</li>
<li><a href="#Substitution_Operator" title="wikilink">Substitution Operator</a>, 

<math display="inline" id="Lambda_calculus_definition:6">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>p</mi>
    <mo>:=</mo>
    <mi>v</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b[p:=v]
  </annotation>
 </semantics>
</math>

 is the substitution of the name 

<math display="inline" id="Lambda_calculus_definition:7">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 by the lambda expression 

<math display="inline" id="Lambda_calculus_definition:8">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>


 in lambda expression 

<math display="inline" id="Lambda_calculus_definition:9">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

.</li>
<li><a href="#Free_and_Bound_Variable_Sets" title="wikilink">Free Variable Set</a> 

<math display="inline" id="Lambda_calculus_definition:10">
 <semantics>
  <mrow>
   <mo>FV</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>FV</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{FV}(f)
  </annotation>
 </semantics>
</math>

 is the set of variables that do not belong to a lambda abstraction in 

<math display="inline" id="Lambda_calculus_definition:11">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>Execution is performing beta reductions and eta reductions on sub expressions in the canonym of a lambda expression until the result is a lambda function (abstraction) in the <a href="Beta_normal_form" title="wikilink">normal form</a>.</p>

<p>All alpha conversions of a lambda expression are considered to be equivalent.</p>
<h3 id="canonym---canonical-names">Canonym - Canonical Names</h3>

<p>Canonym is a function that takes a lambda expression and renames all names canonically, based on their positions in the expression. This might be implemented as,</p>
<ol>
<li>

<math display="inline" id="Lambda_calculus_definition:12">
 <semantics>
  <mrow>
   <mrow>
    <mo>canonym</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>L</mi>
     <mo>,</mo>
     <mi>Q</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>canonym</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>L</mi>
     <mo>,</mo>
     <mi>O</mi>
     <mo>,</mo>
     <mi>Q</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>canonym</ci>
     <ci>L</ci>
     <ci>Q</ci>
    </apply>
    <apply>
     <ci>canonym</ci>
     <ci>L</ci>
     <ci>O</ci>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{canonym}[L,Q]=\operatorname{canonym}[L,O,Q]
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Lambda_calculus_definition:13">
 <semantics>
  <mrow>
   <mo>canonym</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mi>b</mi>
    <mo>,</mo>
    <mi>M</mi>
    <mo>,</mo>
    <mi>Q</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>λ</mi>
   <mo>name</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mo>canonym</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>b</mi>
    <mo>,</mo>
    <mi>M</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>p</mi>
     <mo>:=</mo>
     <mi>Q</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>,</mo>
    <mi>Q</mi>
    <mo>+</mo>
    <mi>N</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>canonym</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">Q</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <ci>name</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Q</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <ci>canonym</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">M</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="latexml">assign</csymbol>
      <csymbol cd="unknown">Q</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-,</ci>
     <csymbol cd="unknown">Q</csymbol>
     <plus></plus>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{canonym}[\lambda p.b,M,Q]=\lambda\operatorname{name}(Q).%
\operatorname{canonym}[b,M[p:=Q],Q+N]
  </annotation>
 </semantics>
</math>


</li>
<li>

<math display="inline" id="Lambda_calculus_definition:14">
 <semantics>
  <mrow>
   <mrow>
    <mo>canonym</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>X</mi>
      </mpadded>
      <mi>Y</mi>
     </mrow>
     <mo>,</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>Q</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>canonym</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>X</mi>
      <mo>,</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mrow>
       <mi>Q</mi>
       <mo>+</mo>
       <mi>F</mi>
      </mrow>
      <mo rspace="7.5pt" stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mrow>
     <mo>canonym</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>Y</mi>
      <mo>,</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mrow>
       <mi>E</mi>
       <mo>+</mo>
       <mi>S</mi>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>canonym</ci>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
     <ci>x</ci>
     <ci>Q</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>canonym</ci>
      <ci>X</ci>
      <ci>x</ci>
      <apply>
       <plus></plus>
       <ci>Q</ci>
       <ci>F</ci>
      </apply>
     </apply>
     <apply>
      <ci>canonym</ci>
      <ci>Y</ci>
      <ci>x</ci>
      <apply>
       <plus></plus>
       <ci>E</ci>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{canonym}[X\ Y,x,Q]=\operatorname{canonym}[X,x,Q+F]\ %
\operatorname{canonym}[Y,x,E+S]
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Lambda_calculus_definition:15">
 <semantics>
  <mrow>
   <mrow>
    <mo>canonym</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>M</mi>
     <mo>,</mo>
     <mi>Q</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>name</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>M</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>x</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>canonym</ci>
     <ci>x</ci>
     <ci>M</ci>
     <ci>Q</ci>
    </apply>
    <apply>
     <ci>name</ci>
     <apply>
      <times></times>
      <ci>M</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{canonym}[x,M,Q]=\operatorname{name}(M[x])
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>Where, N is the string "N", F is the string "F", S is the string "S", + is concatenation, and "name" converts a string into a name</p>
<h3 id="map-operators">Map Operators</h3>

<p>Map from one value to another if the value is in the map. O is the empty map.</p>
<ol>
<li>

<math display="inline" id="Lambda_calculus_definition:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>x</ci>
     </apply>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O[x]=x
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Lambda_calculus_definition:17">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">M</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M[x:=y][x]=y
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Lambda_calculus_definition:18">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≠</mo>
   <mi>z</mi>
   <mo>→</mo>
   <mi>M</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>z</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>M</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>z</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <neq></neq>
    <csymbol cd="unknown">z</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">M</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">M</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\neq z\to M[x:=y][z]=M[z]
  </annotation>
 </semantics>
</math>


</li>
</ol>
<h3 id="substitution-operator">Substitution Operator</h3>

<p>If L is a lambda expression, x is a name, and y is a lambda expression; 

<math display="inline" id="Lambda_calculus_definition:19">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L[x:=y]
  </annotation>
 </semantics>
</math>

 means substitute x by y in L. The rules are,</p>
<ol>
<li>

<math display="inline" id="Lambda_calculus_definition:20">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>p</mi>
   <mo>.</mo>
   <mi>b</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">b</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda p.b)[x:=y]=\lambda p.b[x:=y]
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Lambda_calculus_definition:21">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>X</mi>
    </mpadded>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>y</mi>
    <mo rspace="7.5pt" stretchy="false">]</mo>
   </mrow>
   <mi>Y</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">X</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">Y</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (X\ Y)[x:=y]=X[x:=y]\ Y[x:=y]
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Lambda_calculus_definition:22">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mi>x</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">z</csymbol>
    <eq></eq>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=x\to(z)[x:=y]=y
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Lambda_calculus_definition:23">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>≠</mo>
   <mi>x</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">z</csymbol>
    <neq></neq>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">z</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z\neq x\to(z)[x:=y]=z
  </annotation>
 </semantics>
</math>


</li>
</ol>

<p>Note that rule 1 must be modified if it is to be used on non canonically renamed lambda expressions. See <a href="#Changes_to_the_substitution_operator" title="wikilink">Changes to the substitution operator</a>.</p>
<h3 id="free-and-bound-variable-sets">Free and Bound Variable Sets</h3>

<p>The set of <em>free variables</em> of a lambda expression, M, is denoted as FV(M). This is the set of variable names that have instances not bound (used) in a lambda abstraction, within the lambda expression. They are the variable names that may be bound to formal parameter variables from outside the lambda expression.</p>

<p>The set of <em>bound variables</em> of a lambda expression, M, is denoted as BV(M). This is the set of variable names that have instances bound (used) in a lambda abstraction, within the lambda expression.</p>

<p>The rules for the two sets are given below.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:24">
 <semantics>
  <mrow>
   <mo>FV</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>FV</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{FV}(M)
  </annotation>
 </semantics>
</math>

 - Free Variable Set</p></th>
<th style="text-align: left;">
<p>Comment</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:25">
 <semantics>
  <mrow>
   <mo>BV</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>BV</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{BV}(M)
  </annotation>
 </semantics>
</math>

 - Bound Variable Set</p></th>
<th style="text-align: left;">
<p>Comment</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:26">
 <semantics>
  <mrow>
   <mrow>
    <mo>FV</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>FV</ci>
     <ci>x</ci>
    </apply>
    <set>
     <ci>x</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{FV}(x)=\{x\}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>where x is a variable</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:27">
 <semantics>
  <mrow>
   <mrow>
    <mo>BV</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>BV</ci>
     <ci>x</ci>
    </apply>
    <list></list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{BV}(x)=\{\}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>where x is a variable</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:28">
 <semantics>
  <mrow>
   <mo>FV</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo>FV</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∩</mo>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>FV</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <ci>FV</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <intersect></intersect>
    <not></not>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{FV}(\lambda x.M)=\operatorname{FV}(M)\cap\neg\{x\}
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p>Free variables of M excluding x</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:29">
 <semantics>
  <mrow>
   <mo>BV</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo>BV</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>BV</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <ci>BV</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <union></union>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{BV}(\lambda x.M)=\operatorname{BV}(M)\cup\{x\}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>Bound variables of M plus x.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:30">
 <semantics>
  <mrow>
   <mrow>
    <mo>FV</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>M</mi>
      </mpadded>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>FV</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∪</mo>
    <mrow>
     <mo>FV</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>N</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>FV</ci>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <union></union>
     <apply>
      <ci>FV</ci>
      <ci>M</ci>
     </apply>
     <apply>
      <ci>FV</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{FV}(M\ N)=\operatorname{FV}(M)\cup\operatorname{FV}(N)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>Combine the free variables from the function and the parameter</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:31">
 <semantics>
  <mrow>
   <mrow>
    <mo>BV</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>M</mi>
      </mpadded>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>BV</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∪</mo>
    <mrow>
     <mo>BV</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>N</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>BV</ci>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <union></union>
     <apply>
      <ci>BV</ci>
      <ci>M</ci>
     </apply>
     <apply>
      <ci>BV</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{BV}(M\ N)=\operatorname{BV}(M)\cup\operatorname{BV}(N)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>Combine the bound variables from the function and the parameter</p></td>
</tr>
</tbody>
</table>

<p>Usage;</p>
<ul>
<li>The Free Variable Set, FV is used above in the <a href="#Definition_of_Semantics" title="wikilink">definition of the eta-reduction</a>.</li>
<li>The Bound Variable Set, BV, is used in the rule for <a href="#Beta_reduction_(capture_avoiding)" title="wikilink">beta-redex</a> of non canonical lambda expression.</li>
</ul>
<h3 id="evaluation-strategy-1">Evaluation strategy</h3>

<p>This mathematical definition is structured so that it represents the result, and not the way it gets calculated. However the result may be different between lazy and eager evaluation. This difference is described in the evaluation formulas.</p>

<p>The definitions given here assume that the first definition that matches the lambda expression will be used. This convention is used to make the definition more readable. Otherwise some if conditions would be required to make the definition precise.</p>

<p>Running or evaluating a lambda expression <em>L</em> is,</p>

<p>

<math display="block" id="Lambda_calculus_definition:32">
 <semantics>
  <mrow>
   <mo>eval</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo>canonym</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>L</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi>Q</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>eval</ci>
    <apply>
     <ci>canonym</ci>
     <ci>L</ci>
    </apply>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{eval}[\operatorname{canonym}[L],Q]
  </annotation>
 </semantics>
</math>

</p>

<p>Where <em>Q</em> is a name prefix possibly an empty string.</p>

<p>where <em>eval</em> is defined by,</p>
<ul>
<li>

<math display="inline" id="Lambda_calculus_definition:33">
 <semantics>
  <mrow>
   <mrow>
    <mo>eval</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>eval</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mo>apply</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mrow>
         <mo>eval</mo>
         <mrow>
          <mo stretchy="false">[</mo>
          <mi>x</mi>
          <mo rspace="7.5pt" stretchy="false">]</mo>
         </mrow>
        </mrow>
        <mrow>
         <mo>strategy</mo>
         <mrow>
          <mo stretchy="false">[</mo>
          <mi>y</mi>
          <mo stretchy="false">]</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>eval</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <ci>eval</ci>
     <apply>
      <ci>apply</ci>
      <apply>
       <times></times>
       <apply>
        <ci>eval</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <ci>strategy</ci>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{eval}[x\ y]=\operatorname{eval}[\operatorname{apply}[%
\operatorname{eval}[x]\ \operatorname{strategy}[y]]]
  </annotation>
 </semantics>
</math>


</li>
<li>

<math display="inline" id="Lambda_calculus_definition:34">
 <semantics>
  <mrow>
   <mo>apply</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mi>y</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>z</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mo>canonym</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>beta</mi>
     <mo>-</mo>
     <mi>redex</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>x</mi>
      <mo>.</mo>
      <mi>y</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mi>z</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>apply</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <ci>canonym</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <minus></minus>
      <ci>beta</ci>
      <ci>redex</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-,</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{apply}[(\lambda x.y)\ z]=\operatorname{canonym}[\operatorname{%
beta-redex}[(\lambda x.y)\ z],x]
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Lambda_calculus_definition:35">
 <semantics>
  <mrow>
   <mrow>
    <mo>apply</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>apply</ci>
     <ci>x</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{apply}[x]=x
  </annotation>
 </semantics>
</math>

 If x does match the above.</li>
<li>

<math display="inline" id="Lambda_calculus_definition:36">
 <semantics>
  <mrow>
   <mo>eval</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mo>eval</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>eta</mi>
     <mo>-</mo>
     <mi>redex</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>eval</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">f</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <ci>eval</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <minus></minus>
      <ci>eta</ci>
      <ci>redex</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">f</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{eval}[\lambda x.(f\ x)]=\operatorname{eval}[\operatorname{eta-%
redex}[\lambda x.(f\ x)]]
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Lambda_calculus_definition:37">
 <semantics>
  <mrow>
   <mrow>
    <mo>eval</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>L</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>eval</ci>
     <ci>L</ci>
    </apply>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{eval}[L]=L
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Lambda_calculus_definition:38">
 <semantics>
  <mrow>
   <mrow>
    <mo>lazy</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>lazy</ci>
     <ci>X</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lazy}[X]=X
  </annotation>
 </semantics>
</math>


</li>
<li>

<math display="inline" id="Lambda_calculus_definition:39">
 <semantics>
  <mrow>
   <mrow>
    <mo>eager</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>eval</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>eager</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <ci>eval</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{eager}[X]=\operatorname{eval}[X]
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Then the evaluation strategy may be chosen as either,</p>
<ul>
<li>

<math display="inline" id="Lambda_calculus_definition:40">
 <semantics>
  <mrow>
   <mo>strategy</mo>
   <mo>=</mo>
   <mo>lazy</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>strategy</ci>
    <ci>lazy</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{strategy}=\operatorname{lazy}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Lambda_calculus_definition:41">
 <semantics>
  <mrow>
   <mo>strategy</mo>
   <mo>=</mo>
   <mo>eager</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>strategy</ci>
    <ci>eager</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{strategy}=\operatorname{eager}
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>The result may be different depending on the strategy used. Eager evaluation will apply all reductions possible, leaving the result in normal form, while lazy evaluation will omit some reductions in parameters, leaving the result in "weak head normal form".</p>
<h4 id="normal-form">Normal form</h4>

<p>All reductions that can be applied have been applied. This is the result obtained from applying eager evaluation.</p>
<ul>
<li>

<math display="inline" id="Lambda_calculus_definition:42">
 <semantics>
  <mrow>
   <mo>normal</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>y</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>z</mi>
   <mo stretchy="false">]</mo>
   <mo>=</mo>
   <mo>false</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">z</csymbol>
    <ci>normal-]</ci>
    <eq></eq>
    <ci>false</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{normal}[\lambda x.y)\ z]=\operatorname{false}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Lambda_calculus_definition:43">
 <semantics>
  <mrow>
   <mo>normal</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mo>false</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">f</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <ci>false</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{normal}[\lambda x.(f\ x)]=\operatorname{false}
  </annotation>
 </semantics>
</math>


</li>
<li>

<math display="inline" id="Lambda_calculus_definition:44">
 <semantics>
  <mrow>
   <mrow>
    <mo>normal</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo>normal</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>x</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mi mathvariant="italic">and</mi>
    </mrow>
    <mrow>
     <mo>normal</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>y</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <ci>normal</ci>
       <ci>x</ci>
      </apply>
      <ci>italic- and</ci>
     </apply>
     <apply>
      <ci>normal</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{normal}[x\ y]=\operatorname{normal}[x]\and\operatorname{normal}[y]
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>In all other cases,</p>
<ul>
<li>

<math display="inline" id="Lambda_calculus_definition:45">
 <semantics>
  <mrow>
   <mrow>
    <mo>normal</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mo>true</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal</ci>
     <ci>x</ci>
    </apply>
    <ci>true</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{normal}[x]=\operatorname{true}
  </annotation>
 </semantics>
</math>

</li>
</ul>
<h4 id="weak-head-normal-form">Weak head normal form</h4>

<p>Reductions to the function (the head) have been applied, but not all reductions to the parameter have been applied. This is the result obtained from applying eager evaluation.</p>
<ul>
<li>

<math display="inline" id="Lambda_calculus_definition:46">
 <semantics>
  <mrow>
   <mo>whnf</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>y</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>z</mi>
   <mo stretchy="false">]</mo>
   <mo>=</mo>
   <mo>false</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>whnf</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">z</csymbol>
    <ci>normal-]</ci>
    <eq></eq>
    <ci>false</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{whnf}[\lambda x.y)\ z]=\operatorname{false}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Lambda_calculus_definition:47">
 <semantics>
  <mrow>
   <mo>whnf</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mo>false</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>whnf</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">f</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <ci>false</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{whnf}[\lambda x.(f\ x)]=\operatorname{false}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Lambda_calculus_definition:48">
 <semantics>
  <mrow>
   <mrow>
    <mo>whnf</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>whnf</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>whnf</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <ci>whnf</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{whnf}[x\ y]=\operatorname{whnf}[x]
  </annotation>
 </semantics>
</math>


</li>
</ul>

<p>In all other cases,</p>
<ul>
<li>

<math display="inline" id="Lambda_calculus_definition:49">
 <semantics>
  <mrow>
   <mrow>
    <mo>whnf</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mo>true</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>whnf</ci>
     <ci>x</ci>
    </apply>
    <ci>true</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{whnf}[x]=\operatorname{true}
  </annotation>
 </semantics>
</math>

</li>
</ul>
<h2 id="derivation-of-standard-from-the-math-definition">Derivation of standard from the math definition</h2>

<p>The standard definition of Lambda Calculus uses some definitions which may be considered as theorems, which can be proved based on the <a href="#Definition_as_mathematical_formulas" title="wikilink">definition as mathematical formulas</a>.</p>

<p>The canonical naming definition deals with the problem of variable identity by constructing a unique name for each variable based on the position of the lambda abstraction for the variable name in the expression.</p>

<p>This definition introduces the rules used in the standard definition and relates explains them in terms of the canonical renaming definition.</p>
<h3 id="free-and-bound-variables-1">Free and bound variables</h3>

<p>The lambda abstraction operator, λ, takes a formal parameter variable and a body expression. When evaluated the formal parameter variable is identified with the value of the actual parameter.</p>

<p>Variables in a lambda expression may either be "bound" or "free". Bound variables are variable names that are already attached to formal parameter variables in the expression.</p>

<p>The formal parameter variable is said to bind the variable name wherever it occurs free in the body. Variable (names) that have already been matched to formal parameter variable are said to be <em>bound</em>. All other variables in the expression are called <em>free</em>.</p>

<p>For example, in the following expression y is a bound variable and x is free

<math display="block" id="Lambda_calculus_definition:50">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>y</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda y.x\ x\ y
  </annotation>
 </semantics>
</math>

. Also note that a variable is bound by its "nearest" lambda abstraction. In the following example the single occurrence of x in the expression is bound by the second lambda

<math display="block" id="Lambda_calculus_definition:51">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mpadded width="+5pt">
    <mi>y</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>z</mi>
    </mpadded>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">y</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">z</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.y\ (\lambda x.z\ x)
  </annotation>
 </semantics>
</math>

</p>
<h3 id="changes-to-the-substitution-operator">Changes to the substitution operator</h3>

<p>In the definition of the <a href="#Substitution_Operator" title="wikilink">Substitution Operator</a> the rule,</p>
<ul>
<li>

<math display="inline" id="Lambda_calculus_definition:52">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>p</mi>
   <mo>.</mo>
   <mi>b</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">b</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda p.b)[x:=y]=\lambda p.b[x:=y]
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>must be replaced with,</p>
<ol>
<li>

<math display="inline" id="Lambda_calculus_definition:53">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">b</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.b)[x:=y]=\lambda x.b
  </annotation>
 </semantics>
</math>


</li>
<li>

<math display="inline" id="Lambda_calculus_definition:54">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>≠</mo>
   <mpadded width="+5pt">
    <mi>x</mi>
   </mpadded>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>z</mi>
    <mo>.</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>z</mi>
   <mo>.</mo>
   <mi>b</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">z</csymbol>
    <neq></neq>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">z</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">b</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z\neq x\ \to(\lambda z.b)[x:=y]=\lambda z.b[x:=y]
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>This is to stop bound variables with the same name being substituted. This would not have occurred in a canonically renamed lambda expression.</p>

<p>For example the previous rules would have wrongly translated,</p>

<p>

<math display="block" id="Lambda_calculus_definition:55">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>y</mi>
    </mpadded>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.x\ z)[x:=y]=(\lambda x.y\ z)
  </annotation>
 </semantics>
</math>

</p>

<p>The new rules block this substitution so that it remains as,</p>

<p>

<math display="block" id="Lambda_calculus_definition:56">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.x\ z)[x:=y]=(\lambda x.x\ z)
  </annotation>
 </semantics>
</math>

</p>
<h3 id="transformation">Transformation</h3>

<p>The meaning of lambda expressions is defined by how expressions can be transformed or reduced.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>There are three kinds of transformation:</p>
<ul>
<li><strong>α-conversion</strong>: changing bound variables (<strong>alpha</strong>);</li>
<li><strong>β-reduction</strong>: applying functions to their arguments (<strong>beta</strong>), calling functions;</li>
<li><strong>η-conversion</strong>: which captures a notion of extensionality (<strong>eta</strong>).</li>
</ul>

<p>We also speak of the resulting equivalences: two expressions are <em>β-equivalent</em>, if they can be β-converted into the same expression, and α/η-equivalence are defined similarly.</p>

<p>The term <em>redex</em>, short for <em>reducible expression</em>, refers to subterms that can be reduced by one of the reduction rules.</p>
<h4 id="alpha-conversion">Alpha Conversion</h4>

<p>Alpha-conversion, sometimes known as alpha-renaming,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> allows bound variable names to be changed. For example, alpha-conversion of 

<math display="inline" id="Lambda_calculus_definition:57">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.x
  </annotation>
 </semantics>
</math>

 might give 

<math display="inline" id="Lambda_calculus_definition:58">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>y</mi>
   </mrow>
   <mo>.</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>y</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda y.y
  </annotation>
 </semantics>
</math>


. Terms that differ only by alpha-conversion are called <em>α-equivalent</em>.</p>

<p>In an alpha conversion, names may be substituted for new names if the new name is not free in the body, as this would lead to the capture of <a href="#Free_and_Bound_Variable_Sets" title="wikilink">free variables</a>.</p>

<p>

<math display="block" id="Lambda_calculus_definition:59">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>∉</mo>
    <mi>F</mi>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi>a</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mi>λ</mi>
    <mi>y</mi>
    <mo>.</mo>
    <mi>b</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo>:=</mo>
     <mi>y</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>alpha</mi>
    <mo>-</mo>
    <mi>con</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <notin></notin>
     <csymbol cd="unknown">F</csymbol>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">b</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="latexml">assign</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <apply>
     <minus></minus>
     <ci>alpha</ci>
     <ci>con</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (y\not\in FV(b)\and a(\lambda x.b)=\lambda y.b[x:=y])\to\operatorname{alpha-%
con}(a)
  </annotation>
 </semantics>
</math>

</p>

<p>Note that the substitution will not recurse into the body of lambda expressions with formal parameter 

<math display="inline" id="Lambda_calculus_definition:60">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 because of the change to the substitution operator described above.</p>

<p>See example;</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Alpha conversion</p></th>
<th style="text-align: left;">
<p>Lambda Expression</p></th>
<th style="text-align: left;">
<p>Canonically named</p></th>
<th style="text-align: left;">
<p>Comment</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:61">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>z</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>y</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>z</mi>
     </mpadded>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>z</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda z.\lambda y.(z\ y)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:62">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mo>P</mo>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mo>PN</mo>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>P</mo>
     <mo>PN</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>normal-P</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>PN</ci>
    </apply>
    <apply>
     <ci>normal-P</ci>
     <ci>PN</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\operatorname{P}.\lambda\operatorname{PN}.(\operatorname{P}%
\operatorname{PN})
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>Original expressions.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>correctly rename y to k, (because k is not used in the body)</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:63">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>z</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>k</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>z</mi>
     </mpadded>
     <mi>k</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <ci>z</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda z.\lambda k.(z\ k)
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:64">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mo>P</mo>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mo>PN</mo>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>P</mo>
     <mo>PN</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>normal-P</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>PN</ci>
    </apply>
    <apply>
     <ci>normal-P</ci>
     <ci>PN</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\operatorname{P}.\lambda\operatorname{PN}.(\operatorname{P}%
\operatorname{PN})
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>No change to canonical renamed expression.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>naively rename y to z, (wrong because z free in 

<math display="inline" id="Lambda_calculus_definition:65">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>y</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>z</mi>
     </mpadded>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>z</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda y.(z\ y)
  </annotation>
 </semantics>
</math>

)</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:66">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>z</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>z</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>z</mi>
     </mpadded>
     <mi>z</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <times></times>
     <ci>z</ci>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda z.\lambda z.(z\ z)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:67">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mo>P</mo>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mo>PN</mo>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\color</mtext>
     </merror>
     <mi>R</mi>
     <mi>e</mi>
     <mi>d</mi>
     <mrow>
      <mo>PN</mo>
      <mo>PN</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>normal-P</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>PN</ci>
    </apply>
    <apply>
     <times></times>
     <mtext>\color</mtext>
     <ci>R</ci>
     <ci>e</ci>
     <ci>d</ci>
     <apply>
      <ci>PN</ci>
      <ci>PN</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\operatorname{P}.\lambda\operatorname{PN}.({\color{Red}\operatorname{PN%
}}\operatorname{PN})
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:68">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>


 is captured.</p></td>
</tr>
</tbody>
</table>
<h4 id="beta-reduction-capture-avoiding">Beta reduction (capture avoiding)</h4>

<p>Beta-reduction captures the idea of function application (also called a function call), and implements the substitution of the actual parameter expression for the formal parameter variable. Beta-reduction is defined in terms of substitution.</p>

<p>If no variable names are <a href="#Free_and_Bound_Variable_Sets" title="wikilink">free</a> in the actual parameter and <a href="#Free_and_Bound_Variable_Sets" title="wikilink">bound</a> in the body, beta reduction may be performed on the lambda abstraction without canonical renaming.</p>

<p>

<math display="block" id="Lambda_calculus_definition:69">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>z</mi>
    <mo>:</mo>
    <mi>z</mi>
    <mo>∉</mo>
    <mi>F</mi>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>z</mi>
    <mo>∉</mo>
    <mi>B</mi>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>beta</mi>
    <mo>-</mo>
    <mi>redex</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>b</mi>
    </mpadded>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>b</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">z</csymbol>
     <notin></notin>
     <csymbol cd="unknown">F</csymbol>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">z</csymbol>
     <notin></notin>
     <csymbol cd="unknown">B</csymbol>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <apply>
     <minus></minus>
     <ci>beta</ci>
     <ci>redex</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">b</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall z:z\not\in FV(y)z\not\in BV(b))\to\operatorname{beta-redex}[\lambda x%
.b\ y]=b[x:=y]
  </annotation>
 </semantics>
</math>

</p>

<p>Alpha renaming may be used on 

<math display="inline" id="Lambda_calculus_definition:70">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 to rename names that are free in 

<math display="inline" id="Lambda_calculus_definition:71">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 but bound in 

<math display="inline" id="Lambda_calculus_definition:72">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

, to meet the pre-condition for this transformation.</p>

<p>See example;</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Beta Reduction</p></th>
<th style="text-align: left;">
<p>Lambda Expression</p></th>
<th style="text-align: left;">
<p>Canonically named</p></th>
<th style="text-align: left;">
<p>Comment</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:73">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>y</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>z</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>z</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>y</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>z</mi>
     </mpadded>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">z</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">z</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.\lambda y.(\lambda z.(\lambda x.z\ x)(\lambda y.z\ y))(x\ y))
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:74">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>λ</mi>
   <mo>P</mo>
   <mo>.</mo>
   <mi>λ</mi>
   <mo>PN</mo>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mo>PNF</mo>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo>PNFNF</mo>
     <mo>.</mo>
     <mo>PNF</mo>
     <mo>PNFNF</mo>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo>PNFNS</mo>
     <mo>.</mo>
     <mo>PNF</mo>
     <mo>PNFNS</mo>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>P</mo>
    <mo>PN</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">λ</csymbol>
    <ci>normal-P</ci>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <ci>PN</ci>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <ci>PNF</ci>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <ci>PNFNF</ci>
      <ci>normal-.</ci>
      <ci>PNF</ci>
      <ci>PNFNF</ci>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <ci>PNFNS</ci>
      <ci>normal-.</ci>
      <ci>PNF</ci>
      <ci>PNFNS</ci>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>normal-P</ci>
     <ci>PN</ci>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda\operatorname{P}.\lambda\operatorname{PN}.(\lambda\operatorname{PNF}.(%
\lambda\operatorname{PNFNF}.\operatorname{PNF}\operatorname{PNFNF})(\lambda%
\operatorname{PNFNS}.\operatorname{PNF}\operatorname{PNFNS}))(\operatorname{P}%
\operatorname{PN}))
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>Original expressions.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Naive beta 1,</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:75">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>y</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>y</mi>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.\lambda y.((\lambda x.(x\ y)x)(\lambda y.(x\ y)y)))
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Canonical</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:76">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>λ</mi>
   <mo>P</mo>
   <mo>.</mo>
   <mi>λ</mi>
   <mo>PN</mo>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo>PNF</mo>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\color</mtext>
      </merror>
      <mi>B</mi>
      <mi>l</mi>
      <mi>u</mi>
      <mi>e</mi>
      <mo>P</mo>
      <mo>PN</mo>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>PNF</mo>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo>PNS</mo>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>P</mo>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\color</mtext>
      </merror>
      <mi>B</mi>
      <mi>l</mi>
      <mi>u</mi>
      <mi>e</mi>
      <mo>PN</mo>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>PNS</mo>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">λ</csymbol>
    <ci>normal-P</ci>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <ci>PN</ci>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <ci>PNF</ci>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <mtext>\color</mtext>
       <csymbol cd="unknown">B</csymbol>
       <csymbol cd="unknown">l</csymbol>
       <csymbol cd="unknown">u</csymbol>
       <csymbol cd="unknown">e</csymbol>
       <ci>normal-P</ci>
       <ci>PN</ci>
       <ci>normal-)</ci>
      </cerror>
      <ci>PNF</ci>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <ci>PNS</ci>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <ci>normal-P</ci>
       <mtext>\color</mtext>
       <csymbol cd="unknown">B</csymbol>
       <csymbol cd="unknown">l</csymbol>
       <csymbol cd="unknown">u</csymbol>
       <csymbol cd="unknown">e</csymbol>
       <ci>PN</ci>
       <ci>normal-)</ci>
      </cerror>
      <ci>PNS</ci>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda\operatorname{P}.\lambda\operatorname{PN}.((\lambda\operatorname{PNF}.%
({\color{Blue}\operatorname{P}}\operatorname{PN})\operatorname{PNF})(\lambda%
\operatorname{PNS}.(\operatorname{P}{\color{Blue}\operatorname{PN}})%
\operatorname{PNS})))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Natural</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:77">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>λ</mi>
   <mo>P</mo>
   <mo>.</mo>
   <mi>λ</mi>
   <mo>PN</mo>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo>PNF</mo>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\color</mtext>
      </merror>
      <mi>R</mi>
      <mi>e</mi>
      <mi>d</mi>
      <mo>PNF</mo>
      <mo>PN</mo>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>PNF</mo>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo>PNS</mo>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>P</mo>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\color</mtext>
      </merror>
      <mi>R</mi>
      <mi>e</mi>
      <mi>d</mi>
      <mo>PNS</mo>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>PNS</mo>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">λ</csymbol>
    <ci>normal-P</ci>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <ci>PN</ci>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <ci>PNF</ci>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <mtext>\color</mtext>
       <csymbol cd="unknown">R</csymbol>
       <csymbol cd="unknown">e</csymbol>
       <csymbol cd="unknown">d</csymbol>
       <ci>PNF</ci>
       <ci>PN</ci>
       <ci>normal-)</ci>
      </cerror>
      <ci>PNF</ci>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <ci>PNS</ci>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <ci>normal-P</ci>
       <mtext>\color</mtext>
       <csymbol cd="unknown">R</csymbol>
       <csymbol cd="unknown">e</csymbol>
       <csymbol cd="unknown">d</csymbol>
       <ci>PNS</ci>
       <ci>normal-)</ci>
      </cerror>
      <ci>PNS</ci>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda\operatorname{P}.\lambda\operatorname{PN}.((\lambda\operatorname{PNF}.%
({\color{Red}\operatorname{PNF}}\operatorname{PN})\operatorname{PNF})(\lambda%
\operatorname{PNS}.(\operatorname{P}{\color{Red}\operatorname{PNS})}%
\operatorname{PNS})))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p>x (P) and y (PN) have been captured in the substitution.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Alpha rename inner, x -&gt; a, y -&gt; b</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:78">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>y</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>z</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>z</mi>
     </mpadded>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>b</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>z</mi>
     </mpadded>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">z</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">z</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.\lambda y.(\lambda z.(\lambda x.z\ a)(\lambda b.z\ b))(x\ y))
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:79">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>λ</mi>
   <mo>P</mo>
   <mo>.</mo>
   <mi>λ</mi>
   <mo>PN</mo>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mo>PNF</mo>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo>PNFNF</mo>
     <mo>.</mo>
     <mo>PNF</mo>
     <mo>PNFNF</mo>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo>PNFNS</mo>
     <mo>.</mo>
     <mo>PNF</mo>
     <mo>PNFNS</mo>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>P</mo>
    <mo>PN</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">λ</csymbol>
    <ci>normal-P</ci>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <ci>PN</ci>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <ci>PNF</ci>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <ci>PNFNF</ci>
      <ci>normal-.</ci>
      <ci>PNF</ci>
      <ci>PNFNF</ci>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <ci>PNFNS</ci>
      <ci>normal-.</ci>
      <ci>PNF</ci>
      <ci>PNFNS</ci>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>normal-P</ci>
     <ci>PN</ci>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda\operatorname{P}.\lambda\operatorname{PN}.(\lambda\operatorname{PNF}.(%
\lambda\operatorname{PNFNF}.\operatorname{PNF}\operatorname{PNFNF})(\lambda%
\operatorname{PNFNS}.\operatorname{PNF}\operatorname{PNFNS}))(\operatorname{P}%
\operatorname{PN}))
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Beta 2,</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:80">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>y</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>a</mi>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>b</mi>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.\lambda y.((\lambda a.(x\ y)a)(\lambda b.(x\ y)b)))
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Canonical</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:81">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>λ</mi>
   <mo>P</mo>
   <mo>.</mo>
   <mi>λ</mi>
   <mo>PN</mo>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo>PNF</mo>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>P</mo>
      <mo>PN</mo>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>PNF</mo>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo>PNS</mo>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>P</mo>
      <mo>PN</mo>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>PNS</mo>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">λ</csymbol>
    <ci>normal-P</ci>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <ci>PN</ci>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <ci>PNF</ci>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <ci>normal-P</ci>
       <ci>PN</ci>
       <ci>normal-)</ci>
      </cerror>
      <ci>PNF</ci>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <ci>PNS</ci>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <ci>normal-P</ci>
       <ci>PN</ci>
       <ci>normal-)</ci>
      </cerror>
      <ci>PNS</ci>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda\operatorname{P}.\lambda\operatorname{PN}.((\lambda\operatorname{PNF}.%
(\operatorname{P}\operatorname{PN})\operatorname{PNF})(\lambda\operatorname{%
PNS}.(\operatorname{P}\operatorname{PN})\operatorname{PNS})))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Natural</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:82">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>λ</mi>
   <mo>P</mo>
   <mo>.</mo>
   <mi>λ</mi>
   <mo>PN</mo>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo>PNF</mo>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>P</mo>
      <mo>PN</mo>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>PNF</mo>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo>PNS</mo>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>P</mo>
      <mo>PN</mo>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>PNS</mo>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">λ</csymbol>
    <ci>normal-P</ci>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <ci>PN</ci>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <ci>PNF</ci>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <ci>normal-P</ci>
       <ci>PN</ci>
       <ci>normal-)</ci>
      </cerror>
      <ci>PNF</ci>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <ci>PNS</ci>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <ci>normal-P</ci>
       <ci>PN</ci>
       <ci>normal-)</ci>
      </cerror>
      <ci>PNS</ci>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda\operatorname{P}.\lambda\operatorname{PN}.((\lambda\operatorname{PNF}.%
(\operatorname{P}\operatorname{PN})\operatorname{PNF})(\lambda\operatorname{%
PNS}.(\operatorname{P}\operatorname{PN})\operatorname{PNS})))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p>x and y not captured.</p></td>
</tr>
</tbody>
</table>
<ol>
<li>

<math display="inline" id="Lambda_calculus_definition:83">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>z</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>y</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>z</mi>
     </mpadded>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>z</mi>
    <mo>:=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">z</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">z</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">z</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((\lambda x.z\ x)(\lambda y.z\ y))[z:=(x\ y)]
  </annotation>
 </semantics>
</math>


</li>
<li>

<math display="inline" id="Lambda_calculus_definition:84">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>a</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>z</mi>
     </mpadded>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>b</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>z</mi>
     </mpadded>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>z</mi>
    <mo>:=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">z</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">z</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">z</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((\lambda a.z\ a)(\lambda b.z\ b))[z:=(x\ y)]
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>In this example,</p>
<ol>
<li>In the beta-redex,
<ol>
<li>The free variables are, 

<math display="inline" id="Lambda_calculus_definition:85">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>V</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <set>
     <ci>x</ci>
     <ci>y</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   FV(x\ y)=\{x,y\}
  </annotation>
 </semantics>
</math>

</li>
<li>The bound variables are, 

<math display="inline" id="Lambda_calculus_definition:86">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>z</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>y</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>z</mi>
     </mpadded>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">B</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">z</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">z</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   BV((\lambda x.z\ x)(\lambda y.z\ y))=\{x,y\}
  </annotation>
 </semantics>
</math>

</li>
</ol></li>
<li>The naive beta-redex changed the meaning of the expression because x and y from the actual parameter became captured when the expressions were substituted in the inner abstractions.</li>
<li>The alpha renaming removed the problem by changing the names of x and y in the inner abstraction so that they are distinct from the names of x and y in the actual parameter.
<ol>
<li>The free variables are, 

<math display="inline" id="Lambda_calculus_definition:87">
 <semantics>
  <mrow>
   <mrow>
    <mo>FV</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>FV</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <set>
     <ci>x</ci>
     <ci>y</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{FV}(x\ y)=\{x,y\}
  </annotation>
 </semantics>
</math>

</li>
<li>The bound variables are, 

<math display="inline" id="Lambda_calculus_definition:88">
 <semantics>
  <mrow>
   <mo>BV</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>a</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>z</mi>
     </mpadded>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>b</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>z</mi>
     </mpadded>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>BV</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">z</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">z</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{BV}((\lambda a.z\ a)(\lambda b.z\ b))=\{a,b\}
  </annotation>
 </semantics>
</math>


</li>
</ol></li>
<li>The beta-redex then proceeded with the intended meaning.</li>
</ol>
<h4 id="eta-reduction">Eta reduction</h4>

<p>Eta-conversion expresses the idea of <a class="uri" href="extensionality" title="wikilink">extensionality</a>, which in this context is that two functions are the same <a href="if_and_only_if" title="wikilink">if and only if</a> they give the same result for all arguments.</p>

<p>Eta reduction may be used without change on lambda expressions that are not canonically renamed.</p>

<p>

<math display="block" id="Lambda_calculus_definition:89">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∉</mo>
   <mo>FV</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>eta</mi>
    <mo>-</mo>
    <mi>redex</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <notin></notin>
    <ci>FV</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <apply>
     <minus></minus>
     <ci>eta</ci>
     <ci>redex</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">f</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\not\in\operatorname{FV}(f)\to\operatorname{eta-redex}[\lambda x.(fx)]=f
  </annotation>
 </semantics>
</math>

</p>

<p>The problem with using an eta-redex when f has free variables is shown in this example,</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Reduction</p></th>
<th style="text-align: left;">
<p>Lambda expression</p></th>
<th style="text-align: left;">
<p>Beta-reduction</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:90">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>y</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>y</mi>
     </mpadded>
     <mi>x</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>x</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">y</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">a</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.(\lambda y.y\ x)\ x)\ a
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:91">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>a</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>a</mi>
    </mpadded>
    <mi>a</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda a.a\ a
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Naive eta-reduction</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:92">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>y</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>y</mi>
    </mpadded>
    <mi>x</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">a</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda y.y\ x)\ a
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_calculus_definition:93">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>a</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>a</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda a.a\ x
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
</tbody>
</table>

<p>This improper use of eta-reduction changes the meaning by leaving 

<math display="inline" id="Lambda_calculus_definition:94">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Lambda_calculus_definition:95">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>y</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>y</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda y.y\ x
  </annotation>
 </semantics>
</math>

 unsubstituted.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Lambda_Calculus" title="wikilink">Lambda Calculus</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Lambda_calculus" title="wikilink">Category:Lambda calculus</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="Ruy_de_Queiroz" title="wikilink">de Queiroz, Ruy J.G.B.</a> "<a href="http://dx.doi.org/10.1111/j.1746-8361.1988.tb00919.x">A Proof-Theoretic Account of Programming and the Role of Reduction Rules.</a>" <em>Dialectica</em> <strong>42</strong>(4), pages 265-282, 1988.<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
</ol>
</section>
</body>
</html>
