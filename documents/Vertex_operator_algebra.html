<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="243">Vertex operator algebra</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Vertex operator algebra</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a <strong>vertex operator algebra</strong> (<strong>VOA</strong>) is an algebraic structure that plays an important role in <a href="conformal_field_theory" title="wikilink">conformal field theory</a> and <a href="string_theory" title="wikilink">string theory</a>. In addition to physical applications, vertex operator algebras have proven useful in purely mathematical contexts such as <a href="monstrous_moonshine" title="wikilink">monstrous moonshine</a> and the <a href="geometric_Langlands_correspondence" title="wikilink">geometric Langlands correspondence</a>.</p>

<p>The related notion of <strong>vertex algebra</strong> was introduced by <a href="Richard_Borcherds" title="wikilink">Richard Borcherds</a> in 1986, motivated by a construction of an infinite-dimensional Lie algebra due to <a href="Igor_Frenkel" title="wikilink">Frenkel</a>. In the course of this construction, one employs a <a href="Fock_space" title="wikilink">Fock space</a> that admits an action of vertex operators attached to lattice vectors. Borcherds formulated the notion of vertex algebra by axiomatizing the relations between the lattice vertex operators, producing an algebraic structure that allows one to construct new Lie algebras by following Frenkel's method.</p>

<p>The notion of vertex operator algebra was introduced as a modification of the notion of vertex algebra, by Frenkel, <a href="James_Lepowsky" title="wikilink">Lepowsky</a>, and <a href="Arne_Meurman" title="wikilink">Meurman</a> in 1988, as part of their project to construct the <a href="moonshine_module" title="wikilink">moonshine module</a>. They observed that many vertex algebras that appear in nature have a useful additional structure (an action of the Virasoro algebra), and satisfy a bounded-below property with respect to an energy operator. Motivated by this observation, they added the Virasoro action and bounded-below property as axioms.</p>

<p>We now have post-hoc motivation for these notions from physics, together with several interpretations of the axioms that were not initially known. Physically, the vertex operators arising from holomorphic field insertions at points (i.e., vertices) in two dimensional conformal field theory admit <a href="operator_product_expansion" title="wikilink">operator product expansions</a> when insertions collide, and these satisfy precisely the relations specified in the definition of vertex operator algebra. Indeed, the axioms of a vertex operator algebra are a formal algebraic interpretation of what physicists call <a href="chiral_algebra" title="wikilink">chiral algebras</a>, or "algebras of chiral symmetries", where these symmetries describe the Ward identities satisfied by a given conformal field theory, including conformal invariance. Other formulations of the vertex algebra axioms include Borcherds's later work on singular commutative rings, algebras over certain operads on curves introduced by Huang, Kriz, and others, and <a class="uri" href="D-module" title="wikilink">D-module</a>-theoretic objects called chiral algebras introduced by <a href="Alexander_Beilinson" title="wikilink">Alexander Beilinson</a> and <a href="Vladimir_Drinfeld" title="wikilink">Vladimir Drinfeld</a>. While related, these chiral algebras are not precisely the same as the objects with the same name that physicists use.</p>

<p>Important basic examples of vertex operator algebras include lattice VOAs (modeling lattice conformal field theories), VOAs given by representations of affine <a href="Kac–Moody_algebra" title="wikilink">Kac–Moody algebras</a> (from the <a href="Wess-Zumino-Witten_model" title="wikilink">WZW model</a>), the Virasoro VOAs (i.e., VOAs corresponding to representations of the <a href="Virasoro_algebra" title="wikilink">Virasoro algebra</a>) and the <a href="moonshine_module" title="wikilink">moonshine module</a> <em>V</em><sup>♮</sup>, which is distinguished by its monster symmetry. More sophisticated examples such as <a href="affine_W-algebras" title="wikilink">affine W-algebras</a> and the <a href="chiral_de_Rham_complex" title="wikilink">chiral de Rham complex</a> on a complex manifold arise in geometric representation theory and <a href="mathematical_physics" title="wikilink">mathematical physics</a>.</p>
<h2 id="formal-definition">Formal definition</h2>
<h3 id="vertex-algebra">Vertex Algebra</h3>

<p>A <strong>vertex algebra</strong> is a collection of data that satisfy certain axioms.</p>
<h4 id="data">Data</h4>
<ul>
<li>a <a href="vector_space" title="wikilink">vector space</a>
<math display="inline" id="Vertex_operator_algebra:0">
<semantics>
<mi>V</mi>
<annotation-xml encoding="MathML-Content">
<ci>V</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   V
  </annotation>
</semantics>
</math>

, called the space of states. The underlying field is typically taken to be the complex numbers, although Borcherds's original formulation allowed for an arbitrary commutative ring.</li>
<li>an identity element 1 ∈ <em>V</em>, sometimes written 

<math display="inline" id="Vertex_operator_algebra:1">
<semantics>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<mn>0</mn>
<mo stretchy="false">⟩</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">ket</csymbol>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |0\rangle
  </annotation>
</semantics>
</math>

 or 

<math display="inline" id="Vertex_operator_algebra:2">
<semantics>
<mi mathvariant="normal">Ω</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Ω</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Ω
  </annotation>
</semantics>
</math>


 to indicate a vacuum state.</li>
<li>an <a class="uri" href="endomorphism" title="wikilink">endomorphism</a>
<math display="inline" id="Vertex_operator_algebra:3">
<semantics>
<mrow>
<mi>T</mi>
<mo>:</mo>
<mrow>
<mi>V</mi>
<mi mathvariant="normal">→</mi>
<mi>V</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<ci>T</ci>
<apply>
<times></times>
<ci>V</ci>
<ci>normal-→</ci>
<ci>V</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   T:V→V
  </annotation>
</semantics>
</math>

, called "translation". (Borcherds's original formulation included a system of divided powers of 

<math display="inline" id="Vertex_operator_algebra:4">
<semantics>
<mi>T</mi>
<annotation-xml encoding="MathML-Content">
<ci>T</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   T
  </annotation>
</semantics>
</math>

, because he did not assume the ground ring was divisible.)</li>
<li>a linear multiplication map 

<math display="inline" id="Vertex_operator_algebra:5">
<semantics>
<mrow>
<mi>Y</mi>
<mo>:</mo>
<mrow>
<mi>V</mi>
<mi mathvariant="normal">⊗</mi>
<mi>V</mi>
<mi mathvariant="normal">→</mi>
<mi>V</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<ci>Y</ci>
<apply>
<times></times>
<ci>V</ci>
<ci>normal-⊗</ci>
<ci>V</ci>
<ci>normal-→</ci>
<ci>V</ci>
<ci>z</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y:V⊗V→V((z))
  </annotation>
</semantics>
</math>

, where 

<math display="inline" id="Vertex_operator_algebra:6">
<semantics>
<mrow>
<mi>V</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>V</ci>
<ci>z</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   V((z))
  </annotation>
</semantics>
</math>

 is the space of all <a href="formal_Laurent_series" title="wikilink">formal Laurent series</a> with coefficients in 

<math display="inline" id="Vertex_operator_algebra:7">
<semantics>
<mi>V</mi>
<annotation-xml encoding="MathML-Content">
<ci>V</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   V
  </annotation>
</semantics>
</math>


. This structure is alternatively presented as an infinite collection of bilinear products <mtpl></mtpl>, or as a left-multiplication map <mtpl></mtpl>, called the state-field correspondence. For each 

<math display="inline" id="Vertex_operator_algebra:8">
<semantics>
<mrow>
<mi>u</mi>
<mi mathvariant="normal">∈</mi>
<mi>V</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>u</ci>
<ci>normal-∈</ci>
<ci>V</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   u∈V
  </annotation>
</semantics>
</math>

, the operator-valued formal distribution 

<math display="inline" id="Vertex_operator_algebra:9">
<semantics>
<mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>Y</ci>
<interval closure="open">
<ci>u</ci>
<ci>z</ci>
</interval>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y(u,z)
  </annotation>
</semantics>
</math>

 is called a vertex operator or a field (inserted at zero), and the coefficient of <mtpl></mtpl> is the operator <mtpl></mtpl>. The standard notation for the multiplication is</li>
</ul>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Vertex_operator_algebra:10">
<semantics>
<mrow>
<mrow>
<mi>u</mi>
<mo>⊗</mo>
<mi>v</mi>
</mrow>
<mo>↦</mo>
<mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>v</mi>
</mrow>
<mo>=</mo>
<mrow>
<msub>
<mo largeop="true" symmetric="true">∑</mo>
<mrow>
<mi>n</mi>
<mo>∈</mo>
<mi>𝐙</mi>
</mrow>
</msub>
<mrow>
<msub>
<mi>u</mi>
<mi>n</mi>
</msub>
<mi>v</mi>
<msup>
<mi>z</mi>
<mrow>
<mrow>
<mo>-</mo>
<mi>n</mi>
</mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<csymbol cd="latexml">maps-to</csymbol>
<apply>
<csymbol cd="latexml">tensor-product</csymbol>
<ci>u</ci>
<ci>v</ci>
</apply>
<apply>
<times></times>
<ci>Y</ci>
<interval closure="open">
<ci>u</ci>
<ci>z</ci>
</interval>
<ci>v</ci>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<in></in>
<ci>n</ci>
<ci>𝐙</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>u</ci>
<ci>n</ci>
</apply>
<ci>v</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<apply>
<minus></minus>
<apply>
<minus></minus>
<ci>n</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   u\otimes v\mapsto Y(u,z)v=\sum_{n\in\mathbf{Z}}u_{n}vz^{-n-1}
  </annotation>
</semantics>
</math>

.
</dd>
</dl>
</dd>
</dl>
<h4 id="axioms">Axioms</h4>

<p>These data are required to satisfy the following axioms:</p>
<ul>
<li><strong>Identity.</strong> For any <mtpl> <em>u</em> {{=}} <em>uz</em><sup>0</sup>}}</mtpl> and <mtpl></mtpl>.</li>
</ul>
<ul>
<li><strong>Translation.</strong>
<math display="inline" id="Vertex_operator_algebra:11">
<semantics>
<mrow>
<mrow>
<mi>T</mi>
<mrow>
<mo stretchy="false">(</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>T</ci>
<cn type="integer">1</cn>
</apply>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   T(1)=0
  </annotation>
</semantics>
</math>

, and for any 

<math display="inline" id="Vertex_operator_algebra:12">
<semantics>
<mrow>
<mi>u</mi>
<mo>,</mo>
<mrow>
<mi>v</mi>
<mi mathvariant="normal">∈</mi>
<mi>V</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<ci>u</ci>
<apply>
<times></times>
<ci>v</ci>
<ci>normal-∈</ci>
<ci>V</ci>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   u,v∈V
  </annotation>
</semantics>
</math>


,</li>
</ul>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Vertex_operator_algebra:13">
<semantics>
<mrow>
<mrow>
<mrow>
<mo stretchy="false">[</mo>
<mi>T</mi>
<mo>,</mo>
<mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
<mi>v</mi>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mi>T</mi>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>v</mi>
</mrow>
<mo>-</mo>
<mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>T</mi>
<mi>v</mi>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mfrac>
<mi>d</mi>
<mrow>
<mi>d</mi>
<mi>z</mi>
</mrow>
</mfrac>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>v</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<interval closure="closed">
<ci>T</ci>
<apply>
<times></times>
<ci>Y</ci>
<interval closure="open">
<ci>u</ci>
<ci>z</ci>
</interval>
</apply>
</interval>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>T</ci>
<ci>Y</ci>
<interval closure="open">
<ci>u</ci>
<ci>z</ci>
</interval>
<ci>v</ci>
</apply>
<apply>
<times></times>
<ci>Y</ci>
<interval closure="open">
<ci>u</ci>
<ci>z</ci>
</interval>
<ci>T</ci>
<ci>v</ci>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<apply>
<divide></divide>
<ci>d</ci>
<apply>
<times></times>
<ci>d</ci>
<ci>z</ci>
</apply>
</apply>
<ci>Y</ci>
<interval closure="open">
<ci>u</ci>
<ci>z</ci>
</interval>
<ci>v</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   [T,Y(u,z)]v=TY(u,z)v-Y(u,z)Tv=\frac{d}{dz}Y(u,z)v
  </annotation>
</semantics>
</math>
</dd>
</dl>
</dd>
</dl>
<ul>
<li><strong>Locality (Jacobi identity, or Borcherds identity).</strong> For any 

<math display="inline" id="Vertex_operator_algebra:14">
<semantics>
<mrow>
<mi>u</mi>
<mo>,</mo>
<mrow>
<mi>v</mi>
<mi mathvariant="normal">∈</mi>
<mi>V</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<ci>u</ci>
<apply>
<times></times>
<ci>v</ci>
<ci>normal-∈</ci>
<ci>V</ci>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   u,v∈V
  </annotation>
</semantics>
</math>

, there exists a positive integer 

<math display="inline" id="Vertex_operator_algebra:15">
<semantics>
<mi>N</mi>
<annotation-xml encoding="MathML-Content">
<ci>N</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   N
  </annotation>
</semantics>
</math>

 such that:</li>
</ul>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Vertex_operator_algebra:16">
<semantics>
<mrow>
<mrow>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>z</mi>
<mo>-</mo>
<mi>x</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>N</mi>
</msup>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>v</mi>
<mo>,</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>z</mi>
<mo>-</mo>
<mi>x</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>N</mi>
</msup>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>v</mi>
<mo>,</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<ci>z</ci>
<ci>x</ci>
</apply>
<ci>N</ci>
</apply>
<ci>Y</ci>
<interval closure="open">
<ci>u</ci>
<ci>z</ci>
</interval>
<ci>Y</ci>
<interval closure="open">
<ci>v</ci>
<ci>x</ci>
</interval>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<ci>z</ci>
<ci>x</ci>
</apply>
<ci>N</ci>
</apply>
<ci>Y</ci>
<interval closure="open">
<ci>v</ci>
<ci>x</ci>
</interval>
<ci>Y</ci>
<interval closure="open">
<ci>u</ci>
<ci>z</ci>
</interval>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (z-x)^{N}Y(u,z)Y(v,x)=(z-x)^{N}Y(v,x)Y(u,z).
  </annotation>
</semantics>
</math>
</dd>
</dl>
</dd>
</dl>
<h5 id="equivalent-formulations-of-locality-axiom">Equivalent Formulations of Locality Axiom</h5>

<p>The Locality axiom has several equivalent formulations in the literature, e.g., Frenkel-Lepowsky-Meurman introduced the Jacobi identity:</p>

<p>
<math display="block" id="Vertex_operator_algebra:17">
<semantics>
<mrow>
<mo>∀</mo>
<mi>u</mi>
<mo>,</mo>
<mi>v</mi>
<mo>,</mo>
<mi>w</mi>
<mo>∈</mo>
<mi>V</mi>
<mo>:</mo>
<msup>
<mi>z</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mi>δ</mi>
<mrow>
<mo>(</mo>
<mfrac>
<mrow>
<mi>y</mi>
<mo>-</mo>
<mi>x</mi>
</mrow>
<mi>z</mi>
</mfrac>
<mo>)</mo>
</mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>v</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>w</mi>
<mo>-</mo>
<msup>
<mi>z</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mi>δ</mi>
<mrow>
<mo>(</mo>
<mfrac>
<mrow>
<mrow>
<mo>-</mo>
<mi>y</mi>
</mrow>
<mo>+</mo>
<mi>x</mi>
</mrow>
<mi>z</mi>
</mfrac>
<mo>)</mo>
</mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>v</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>w</mi>
<mo>=</mo>
<msup>
<mi>y</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mi>δ</mi>
<mrow>
<mo>(</mo>
<mfrac>
<mrow>
<mi>x</mi>
<mo>+</mo>
<mi>z</mi>
</mrow>
<mi>y</mi>
</mfrac>
<mo>)</mo>
</mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>v</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>w</mi>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="latexml">for-all</csymbol>
<csymbol cd="unknown">u</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">v</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">w</csymbol>
<in></in>
<csymbol cd="unknown">V</csymbol>
<ci>normal-:</ci>
<ci>italic-</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<csymbol cd="unknown">δ</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<divide></divide>
<apply>
<minus></minus>
<ci>y</ci>
<ci>x</ci>
</apply>
<ci>z</ci>
</apply>
<ci>normal-)</ci>
</cerror>
<csymbol cd="unknown">Y</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">u</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">x</csymbol>
<ci>normal-)</ci>
</cerror>
<csymbol cd="unknown">Y</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">v</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">y</csymbol>
<ci>normal-)</ci>
</cerror>
<csymbol cd="unknown">w</csymbol>
<minus></minus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<csymbol cd="unknown">δ</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<divide></divide>
<apply>
<plus></plus>
<apply>
<minus></minus>
<ci>y</ci>
</apply>
<ci>x</ci>
</apply>
<ci>z</ci>
</apply>
<ci>normal-)</ci>
</cerror>
<csymbol cd="unknown">Y</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">v</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">y</csymbol>
<ci>normal-)</ci>
</cerror>
<csymbol cd="unknown">Y</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">u</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">x</csymbol>
<ci>normal-)</ci>
</cerror>
<csymbol cd="unknown">w</csymbol>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>y</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<csymbol cd="unknown">δ</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<divide></divide>
<apply>
<plus></plus>
<ci>x</ci>
<ci>z</ci>
</apply>
<ci>y</ci>
</apply>
<ci>normal-)</ci>
</cerror>
<csymbol cd="unknown">Y</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">Y</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">u</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">z</csymbol>
<ci>normal-)</ci>
</cerror>
<csymbol cd="unknown">v</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">y</csymbol>
<ci>normal-)</ci>
</cerror>
<csymbol cd="unknown">w</csymbol>
<ci>normal-,</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \forall u,v,w\in V:\qquad z^{-1}\delta\left(\frac{y-x}{z}\right)Y(u,x)Y(v,y)w-%
z^{-1}\delta\left(\frac{-y+x}{z}\right)Y(v,y)Y(u,x)w=y^{-1}\delta\left(\frac{x%
+z}{y}\right)Y(Y(u,z)v,y)w,
  </annotation>
</semantics>
</math>
</p>

<p>where we define the formal delta series by:</p>

<p>
<math display="block" id="Vertex_operator_algebra:18">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>δ</mi>
<mrow>
<mo>(</mo>
<mfrac>
<mrow>
<mi>y</mi>
<mo>-</mo>
<mi>x</mi>
</mrow>
<mi>z</mi>
</mfrac>
<mo>)</mo>
</mrow>
</mrow>
<mo>:=</mo>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mrow>
<mi>s</mi>
<mo>≥</mo>
<mn>0</mn>
</mrow>
<mo>,</mo>
<mrow>
<mi>r</mi>
<mo>∈</mo>
<mi>𝐙</mi>
</mrow>
</mrow>
</munder>
<mrow>
<mrow>
<mo>(</mo>
<mtable columnspacing="0.4em" rowspacing="0.2ex">
<mtr>
<mtd>
<mi>r</mi>
</mtd>
</mtr>
<mtr>
<mtd>
<mi>s</mi>
</mtd>
</mtr>
</mtable>
<mo>)</mo>
</mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>s</mi>
</msup>
<msup>
<mi>y</mi>
<mrow>
<mi>r</mi>
<mo>-</mo>
<mi>s</mi>
</mrow>
</msup>
<msup>
<mi>x</mi>
<mi>s</mi>
</msup>
<msup>
<mi>z</mi>
<mrow>
<mo>-</mo>
<mi>r</mi>
</mrow>
</msup>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">assign</csymbol>
<apply>
<times></times>
<ci>δ</ci>
<apply>
<divide></divide>
<apply>
<minus></minus>
<ci>y</ci>
<ci>x</ci>
</apply>
<ci>z</ci>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<geq></geq>
<ci>s</ci>
<cn type="integer">0</cn>
</apply>
<apply>
<in></in>
<ci>r</ci>
<ci>𝐙</ci>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="latexml">binomial</csymbol>
<ci>r</ci>
<ci>s</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
<ci>s</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>y</ci>
<apply>
<minus></minus>
<ci>r</ci>
<ci>s</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<ci>s</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<apply>
<minus></minus>
<ci>r</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \delta\left(\frac{y-x}{z}\right):=\sum_{s\geq 0,r\in\mathbf{Z}}{\left({{r}%
\atop{s}}\right)}(-1)^{s}y^{r-s}x^{s}z^{-r}.
  </annotation>
</semantics>
</math>
</p>

<p>Borcherds initially used the following identity: for any vectors <em>u</em>, <em>v</em>, and <em>w</em>, and integers <em>m</em> and <em>n</em> we have</p>

<p>
<math display="block" id="Vertex_operator_algebra:19">
<semantics>
<mrow>
<mrow>
<msub>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>u</mi>
<mi>m</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>v</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>n</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>w</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>i</mi>
<mo>≥</mo>
<mn>0</mn>
</mrow>
</munder>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>i</mi>
</msup>
<mrow>
<mo>(</mo>
<mtable columnspacing="0.4em" rowspacing="0.2ex">
<mtr>
<mtd>
<mi>m</mi>
</mtd>
</mtr>
<mtr>
<mtd>
<mi>i</mi>
</mtd>
</mtr>
</mtable>
<mo>)</mo>
</mrow>
<mrow>
<mo>(</mo>
<mrow>
<mrow>
<msub>
<mi>u</mi>
<mrow>
<mi>m</mi>
<mo>-</mo>
<mi>i</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>v</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mi>i</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>w</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>-</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>m</mi>
</msup>
<msub>
<mi>v</mi>
<mrow>
<mrow>
<mi>m</mi>
<mo>+</mo>
<mi>n</mi>
</mrow>
<mo>-</mo>
<mi>i</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>u</mi>
<mi>i</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>w</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>u</ci>
<ci>m</ci>
</apply>
<ci>v</ci>
</apply>
<ci>n</ci>
</apply>
<ci>w</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<geq></geq>
<ci>i</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="latexml">binomial</csymbol>
<ci>m</ci>
<ci>i</ci>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>u</ci>
<apply>
<minus></minus>
<ci>m</ci>
<ci>i</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>v</ci>
<apply>
<plus></plus>
<ci>n</ci>
<ci>i</ci>
</apply>
</apply>
<ci>w</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
<ci>m</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>v</ci>
<apply>
<minus></minus>
<apply>
<plus></plus>
<ci>m</ci>
<ci>n</ci>
</apply>
<ci>i</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>u</ci>
<ci>i</ci>
</apply>
<ci>w</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (u_{m}(v))_{n}(w)=\sum_{i\geq 0}(-1)^{i}{\left({{m}\atop{i}}\right)}\left(u_{m%
-i}(v_{n+i}(w))-(-1)^{m}v_{m+n-i}(u_{i}(w))\right)
  </annotation>
</semantics>
</math>
</p>

<p>He later gave a more expansive version that is equivalent but easier to use: for any vectors <em>u</em>, <em>v</em>, and <em>w</em>, and integers <em>m</em>, <em>n</em>, and <em>q</em> we have</p>

<p>
<math display="block" id="Vertex_operator_algebra:20">
<semantics>
<mrow>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>i</mi>
<mo>∈</mo>
<mi>𝐙</mi>
</mrow>
</munder>
<mrow>
<msub>
<mrow>
<mo>(</mo>
<mrow>
<msub>
<mi>u</mi>
<mrow>
<mi>q</mi>
<mo>+</mo>
<mi>i</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>v</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
<mrow>
<mrow>
<mi>m</mi>
<mo>+</mo>
<mi>n</mi>
</mrow>
<mo>-</mo>
<mi>i</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>w</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>i</mi>
<mo>∈</mo>
<mi>𝐙</mi>
</mrow>
</munder>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>i</mi>
</msup>
<mrow>
<mo>(</mo>
<mtable columnspacing="0.4em" rowspacing="0.2ex">
<mtr>
<mtd>
<mi>q</mi>
</mtd>
</mtr>
<mtr>
<mtd>
<mi>i</mi>
</mtd>
</mtr>
</mtable>
<mo>)</mo>
</mrow>
<mrow>
<mo>(</mo>
<mrow>
<mrow>
<msub>
<mi>u</mi>
<mrow>
<mrow>
<mi>m</mi>
<mo>+</mo>
<mi>q</mi>
</mrow>
<mo>-</mo>
<mi>i</mi>
</mrow>
</msub>
<mrow>
<mo>(</mo>
<mrow>
<msub>
<mi>v</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mi>i</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>w</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
</mrow>
<mo>-</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>q</mi>
</msup>
<msub>
<mi>v</mi>
<mrow>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mi>q</mi>
</mrow>
<mo>-</mo>
<mi>i</mi>
</mrow>
</msub>
<mrow>
<mo>(</mo>
<mrow>
<msub>
<mi>u</mi>
<mrow>
<mi>m</mi>
<mo>+</mo>
<mi>i</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>w</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<in></in>
<ci>i</ci>
<ci>𝐙</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>u</ci>
<apply>
<plus></plus>
<ci>q</ci>
<ci>i</ci>
</apply>
</apply>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<apply>
<plus></plus>
<ci>m</ci>
<ci>n</ci>
</apply>
<ci>i</ci>
</apply>
</apply>
<ci>w</ci>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<in></in>
<ci>i</ci>
<ci>𝐙</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="latexml">binomial</csymbol>
<ci>q</ci>
<ci>i</ci>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>u</ci>
<apply>
<minus></minus>
<apply>
<plus></plus>
<ci>m</ci>
<ci>q</ci>
</apply>
<ci>i</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>v</ci>
<apply>
<plus></plus>
<ci>n</ci>
<ci>i</ci>
</apply>
</apply>
<ci>w</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
<ci>q</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>v</ci>
<apply>
<minus></minus>
<apply>
<plus></plus>
<ci>n</ci>
<ci>q</ci>
</apply>
<ci>i</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>u</ci>
<apply>
<plus></plus>
<ci>m</ci>
<ci>i</ci>
</apply>
</apply>
<ci>w</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \sum_{i\in\mathbf{Z}}\left(u_{q+i}(v)\right)_{m+n-i}(w)=\sum_{i\in\mathbf{Z}}(%
-1)^{i}{\left({{q}\atop{i}}\right)}\left(u_{m+q-i}\left(v_{n+i}(w)\right)-(-1)%
^{q}v_{n+q-i}\left(u_{m+i}(w)\right)\right)
  </annotation>
</semantics>
</math>
</p>

<p>Finally, there is a formal function version of locality: For any 

<math display="inline" id="Vertex_operator_algebra:21">
<semantics>
<mrow>
<mi>u</mi>
<mo>,</mo>
<mi>v</mi>
<mo>,</mo>
<mrow>
<mi>w</mi>
<mi mathvariant="normal">∈</mi>
<mi>V</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<ci>u</ci>
<ci>v</ci>
<apply>
<times></times>
<ci>w</ci>
<ci>normal-∈</ci>
<ci>V</ci>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   u,v,w∈V
  </annotation>
</semantics>
</math>

, there is an element</p>

<p>
<math display="block" id="Vertex_operator_algebra:22">
<semantics>
<mrow>
<mrow>
<mi>X</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>v</mi>
<mo>,</mo>
<mi>w</mi>
<mo>;</mo>
<mi>z</mi>
<mo>,</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>∈</mo>
<mrow>
<mi>V</mi>
<mrow>
<mo stretchy="false">[</mo>
<mrow>
<mo stretchy="false">[</mo>
<mi>z</mi>
<mo>,</mo>
<mi>x</mi>
<mo stretchy="false">]</mo>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
<mrow>
<mo>[</mo>
<msup>
<mi>z</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mo>,</mo>
<msup>
<mi>x</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mo>,</mo>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>z</mi>
<mo>-</mo>
<mi>x</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mo>]</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<apply>
<times></times>
<ci>X</ci>
<vector>
<ci>u</ci>
<ci>v</ci>
<ci>w</ci>
<ci>z</ci>
<ci>x</ci>
</vector>
</apply>
<apply>
<times></times>
<ci>V</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<interval closure="closed">
<ci>z</ci>
<ci>x</ci>
</interval>
</apply>
<list>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<ci>z</ci>
<ci>x</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</list>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   X(u,v,w;z,x)\in V[[z,x]]\left[z^{-1},x^{-1},(z-x)^{-1}\right]
  </annotation>
</semantics>
</math>
</p>

<p>such that 

<math display="inline" id="Vertex_operator_algebra:23">
<semantics>
<mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>v</mi>
<mo>,</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>w</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>Y</ci>
<interval closure="open">
<ci>u</ci>
<ci>z</ci>
</interval>
<ci>Y</ci>
<interval closure="open">
<ci>v</ci>
<ci>x</ci>
</interval>
<ci>w</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y(u,z)Y(v,x)w
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Vertex_operator_algebra:24">
<semantics>
<mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>v</mi>
<mo>,</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>w</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>Y</ci>
<interval closure="open">
<ci>v</ci>
<ci>x</ci>
</interval>
<ci>Y</ci>
<interval closure="open">
<ci>u</ci>
<ci>z</ci>
</interval>
<ci>w</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y(v,x)Y(u,z)w
  </annotation>
</semantics>
</math>

 are the corresponding expansions of 

<math display="inline" id="Vertex_operator_algebra:25">
<semantics>
<mrow>
<mi>X</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>v</mi>
<mo>,</mo>
<mi>w</mi>
<mo>;</mo>
<mi>z</mi>
<mo>,</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>X</ci>
<vector>
<ci>u</ci>
<ci>v</ci>
<ci>w</ci>
<ci>z</ci>
<ci>x</ci>
</vector>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   X(u,v,w;z,x)
  </annotation>
</semantics>
</math>

 in 

<math display="inline" id="Vertex_operator_algebra:26">
<semantics>
<mrow>
<mi>V</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>V</ci>
<ci>z</ci>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   V((z))((x))
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Vertex_operator_algebra:27">
<semantics>
<mrow>
<mi>V</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>V</ci>
<ci>x</ci>
<ci>z</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   V((x))((z))
  </annotation>
</semantics>
</math>


.</p>
<h3 id="vertex-operator-algebra">Vertex Operator Algebra</h3>

<p>A <strong>vertex operator algebra</strong> is a vertex algebra equipped with a <strong>conformal element</strong>
<math display="inline" id="Vertex_operator_algebra:28">
<semantics>
<mi>ω</mi>
<annotation-xml encoding="MathML-Content">
<ci>ω</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   ω
  </annotation>
</semantics>
</math>

, such that the vertex operator 

<math display="inline" id="Vertex_operator_algebra:29">
<semantics>
<mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>ω</mi>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>Y</ci>
<interval closure="open">
<ci>ω</ci>
<ci>z</ci>
</interval>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y(ω,z)
  </annotation>
</semantics>
</math>

 is the weight two Virasoro field 

<math display="inline" id="Vertex_operator_algebra:30">
<semantics>
<mrow>
<mi>L</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>L</ci>
<ci>z</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L(z)
  </annotation>
</semantics>
</math>

:</p>

<p>
<math display="block" id="Vertex_operator_algebra:31">
<semantics>
<mrow>
<mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>ω</mi>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>n</mi>
<mo>∈</mo>
<mi>𝐙</mi>
</mrow>
</munder>
<mrow>
<msub>
<mi>ω</mi>
<mi>n</mi>
</msub>
<msup>
<mi>z</mi>
<mrow>
<mrow>
<mo>-</mo>
<mi>n</mi>
</mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>L</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>n</mi>
<mo>∈</mo>
<mi>𝐙</mi>
</mrow>
</munder>
<mrow>
<msub>
<mi>L</mi>
<mi>n</mi>
</msub>
<msup>
<mi>z</mi>
<mrow>
<mrow>
<mo>-</mo>
<mi>n</mi>
</mrow>
<mo>-</mo>
<mn>2</mn>
</mrow>
</msup>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<ci>Y</ci>
<interval closure="open">
<ci>ω</ci>
<ci>z</ci>
</interval>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<in></in>
<ci>n</ci>
<ci>𝐙</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ω</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<apply>
<minus></minus>
<apply>
<minus></minus>
<ci>n</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<ci>L</ci>
<ci>z</ci>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<in></in>
<ci>n</ci>
<ci>𝐙</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<apply>
<minus></minus>
<apply>
<minus></minus>
<ci>n</ci>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y(\omega,z)=\sum_{n\in\mathbf{Z}}\omega_{n}{z^{-n-1}}=L(z)=\sum_{n\in\mathbf{Z%
}}L_{n}z^{-n-2}
  </annotation>
</semantics>
</math>
</p>

<p>and satisfies the following properties:</p>
<ul>
<li>[<em>L</em><sub>m</sub>, <em>L</em><sub>n</sub>] = (<em>m</em> − <em>n</em>)<em>L</em><sub>m+n</sub> + (δ<sub>m+n,0</sub>/12) (<em>m</em><sup>3</sup> − <em>m</em>)<em>c</em> Id<sub>V</sub>, where <em>c</em> is a constant called the <strong>central charge</strong>, or <strong>rank</strong> of 

<math display="inline" id="Vertex_operator_algebra:32">
<semantics>
<mi>V</mi>
<annotation-xml encoding="MathML-Content">
<ci>V</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   V
  </annotation>
</semantics>
</math>


. In particular, the coefficients of this vertex operator endow 

<math display="inline" id="Vertex_operator_algebra:33">
<semantics>
<mi>V</mi>
<annotation-xml encoding="MathML-Content">
<ci>V</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   V
  </annotation>
</semantics>
</math>

 with an action of the Virasoro algebra with central charge <em>c</em>.</li>
<li><em>L</em><sub>0</sub> acts semisimply on 

<math display="inline" id="Vertex_operator_algebra:34">
<semantics>
<mi>V</mi>
<annotation-xml encoding="MathML-Content">
<ci>V</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   V
  </annotation>
</semantics>
</math>

 with integer eigenvalues that are bounded below.</li>
<li>Under the grading provided by the eigenvalues of <em>L</em><sub>0</sub>, the multiplication on 

<math display="inline" id="Vertex_operator_algebra:35">
<semantics>
<mi>V</mi>
<annotation-xml encoding="MathML-Content">
<ci>V</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   V
  </annotation>
</semantics>
</math>

 is homogeneous in the sense that if <em>u</em> and <em>v</em> are homogeneous, then <mtpl></mtpl> is homogeneous of degree 

<math display="inline" id="Vertex_operator_algebra:36">
<semantics>
<mrow>
<mrow>
<mi>d</mi>
<mi>e</mi>
<mi>g</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<mi>d</mi>
<mi>e</mi>
<mi>g</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>v</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi mathvariant="normal">−</mi>
<mi>n</mi>
<mi mathvariant="normal">−</mi>
<mn>1</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<plus></plus>
<apply>
<times></times>
<ci>d</ci>
<ci>e</ci>
<ci>g</ci>
<ci>u</ci>
</apply>
<apply>
<times></times>
<ci>d</ci>
<ci>e</ci>
<ci>g</ci>
<ci>v</ci>
<ci>normal-−</ci>
<ci>n</ci>
<ci>normal-−</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   deg(u)+deg(v)−n−1
  </annotation>
</semantics>
</math>

.</li>
<li>The identity 1 has degree 0, and the conformal element 

<math display="inline" id="Vertex_operator_algebra:37">
<semantics>
<mi>ω</mi>
<annotation-xml encoding="MathML-Content">
<ci>ω</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   ω
  </annotation>
</semantics>
</math>


 has degree 2.</li>
<li><em>L</em><sub>−1</sub> = <em>T</em>.</li>
</ul>

<p>A homomorphism of vertex algebras is a map of the underlying vector spaces that respects the additional identity, translation, and multiplication structure. Homomorphisms of vertex operator algebras have "weak" and "strong" forms, depending on whether they respect conformal vectors.</p>
<h2 id="commutative-vertex-algebras">Commutative vertex algebras</h2>

<p>A vertex algebra <em>V</em> is commutative if all vertex operators commute with each other. This is equivalent to the property that all products <em>Y</em>(<em>u</em>,<em>z</em>)<em>v</em> lie in <em>V</em>[[<em>z</em>]]. Given a commutative vertex algebra, the constant terms of multiplication endow the vector space with a commutative ring structure, and <em>T</em> is a derivation. Conversely, any commutative ring <em>V</em> with derivation <em>T</em> has a canonical vertex algebra structure, where we set <em>Y</em>(<em>u</em>,<em>z</em>)<em>v</em> = <em>u</em><sub>–1</sub><em>v</em> <em>z</em><sup>0</sup> = <em>uv</em>. If the derivation <em>T</em> vanishes, we may set ω = 0 to obtain a vertex operator algebra concentrated in degree zero.</p>

<p>Any finite-dimensional vertex algebra is commutative. In particular, even the smallest examples of noncommutative vertex algebras require significant introduction.</p>
<h2 id="basic-properties">Basic properties</h2>

<p>The translation operator <em>T</em> in a vertex algebra induces infinitesimal symmetries on the product structure, and satisfies the following properties:</p>
<ul>
<li><em>Y</em>(<em>u</em>,<em>z</em>)1 = <em>e</em><sup>zT</sup><em>u</em></li>
<li><em>Tu</em> = <em>u</em><sub>–2</sub>1, so <em>T</em> is determined by <em>Y</em>.</li>
<li><em>Y</em>(<em>Tu</em>,<em>z</em>) = <em>d</em>(<em>Y</em>(<em>u</em>,<em>z</em>))/<em>dz</em></li>
<li><em>e</em><sup>xT</sup><em>Y</em>(<em>u</em>,<em>z</em>)<em>e</em><sup>−xT</sup> = <em>Y</em>(<em>e</em><sup>xT</sup><em>u</em>,<em>z</em>) = <em>Y</em>(<em>u</em>,<em>z</em>+<em>x</em>)</li>
<li>(skew-symmetry) <em>Y</em>(<em>u</em>,<em>z</em>)<em>v</em> = <em>e</em><sup>zT</sup><em>Y</em>(<em>v</em>,–<em>z</em>)<em>u</em></li>
</ul>

<p>For a vertex operator algebra, the other Virasoro operators satisfy similar properties:</p>
<ul>
<li><em>x</em><sup>L<sub>0</sub></sup><em>Y</em>(<em>u</em>,<em>z</em>)<em>x</em><sup>−L<sub>0</sub></sup> = <em>Y</em>(<em>x</em><sup>L<sub>0</sub></sup><em>u</em>,<em>xz</em>)</li>
<li><em>e</em><sup>xL<sub>1</sub></sup><em>Y</em>(<em>u</em>,<em>z</em>)<em>e</em><sup>−xL<sub>1</sub></sup> = <em>Y</em>(e<sup>x(1–xz)L<sub>1</sub></sup>(1–<em>xz</em>)<sup>−2L<sub>0</sub></sup><em>u</em>,<em>z</em>(1–<em>xz</em>)<sup>−1</sup>)</li>
<li>(quasi-conformality) 

<math display="inline" id="Vertex_operator_algebra:38">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">[</mo>
<msub>
<mi>L</mi>
<mi>m</mi>
</msub>
<mo>,</mo>
<mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
<mo>=</mo>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">∑</mo>
<mrow>
<mi>k</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mrow>
<mi>m</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msubsup>
<mrow>
<mrow>
<mo>(</mo>
<mstyle scriptlevel="+1">
<mtable columnspacing="0.4em" rowspacing="0.2ex">
<mtr>
<mtd>
<mrow>
<mi>m</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd>
<mi>k</mi>
</mtd>
</mtr>
</mtable>
</mstyle>
<mo>)</mo>
</mrow>
<msup>
<mi>z</mi>
<mi>k</mi>
</msup>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>L</mi>
<mrow>
<mi>m</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
</msub>
<mi>u</mi>
</mrow>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<interval closure="closed">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<ci>m</ci>
</apply>
<apply>
<times></times>
<ci>Y</ci>
<interval closure="open">
<ci>u</ci>
<ci>z</ci>
</interval>
</apply>
</interval>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>k</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<apply>
<plus></plus>
<ci>m</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="latexml">binomial</csymbol>
<apply>
<plus></plus>
<ci>m</ci>
<cn type="integer">1</cn>
</apply>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<ci>k</ci>
</apply>
<ci>Y</ci>
<interval closure="open">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<apply>
<minus></minus>
<ci>m</ci>
<ci>k</ci>
</apply>
</apply>
<ci>u</ci>
</apply>
<ci>z</ci>
</interval>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   [L_{m},Y(u,z)]=\sum_{k=0}^{m+1}{\left({{m+1}\atop{k}}\right)}z^{k}Y(L_{m-k}u,z)
  </annotation>
</semantics>
</math>

 for all <em>m</em>≥–1.</li>
</ul>
<ul>
<li>(Associativity, or Cousin property): For any <em>u</em>, <em>v</em>, <em>w</em> ∈ <em>V</em>, the element</li>
</ul>

<p>
<math display="block" id="Vertex_operator_algebra:39">
<semantics>
<mrow>
<mrow>
<mi>X</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>v</mi>
<mo>,</mo>
<mi>w</mi>
<mo>;</mo>
<mi>z</mi>
<mo>,</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>∈</mo>
<mrow>
<mi>V</mi>
<mrow>
<mo stretchy="false">[</mo>
<mrow>
<mo stretchy="false">[</mo>
<mi>z</mi>
<mo>,</mo>
<mi>x</mi>
<mo stretchy="false">]</mo>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
<mrow>
<mo stretchy="false">[</mo>
<msup>
<mi>z</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mo>,</mo>
<msup>
<mi>x</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mo>,</mo>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>z</mi>
<mo>-</mo>
<mi>x</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<apply>
<times></times>
<ci>X</ci>
<vector>
<ci>u</ci>
<ci>v</ci>
<ci>w</ci>
<ci>z</ci>
<ci>x</ci>
</vector>
</apply>
<apply>
<times></times>
<ci>V</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<interval closure="closed">
<ci>z</ci>
<ci>x</ci>
</interval>
</apply>
<list>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<ci>z</ci>
<ci>x</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</list>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   X(u,v,w;z,x)\in V[[z,x]][z^{-1},x^{-1},(z-x)^{-1}]
  </annotation>
</semantics>
</math>
</p>

<p>given in the definition also expands to <em>Y</em>(<em>Y</em>(<em>u</em>,<em>z</em>–<em>x</em>)<em>v</em>,<em>x</em>)<em>w</em> in <em>V</em>((<em>x</em>))((<em>z</em>–<em>x</em>)).</p>

<p>The associativity property of a vertex algebra follows from the fact that the commutator of <em>Y</em>(<em>u</em>,<em>z</em>) and <em>Y</em>(<em>v</em>,<em>x</em>) is annihilated by a finite power of <em>z</em>–<em>x</em>, i.e., one can expand it as a finite linear combination of derivatives of the formal delta function in (<em>z</em>–<em>x</em>), with coefficients in End(<em>V</em>).</p>

<p>Reconstruction: Let <em>V</em> be a vertex algebra, and let {<em>J</em><sup>a</sup>} be a set of vectors, with corresponding fields <em>J</em><sup>a</sup>(<em>z</em>) ∈ End(<em>V</em>)[[<em>z</em><sup>±1</sup>]]. If <em>V</em> is spanned by monomials in the positive weight coefficients of the fields (i.e., finite products of operators <em>J</em><sup>a</sup><sub>n</sub> applied to 1, where <em>n</em> is negative), then we may write the operator product of such a monomial as a <a href="normally_ordered_product" title="wikilink">normally ordered product</a> of divided power derivatives of fields (here, normal ordering means polar terms on the left are moved to the right). Specifically,</p>

<p>
<math display="block" id="Vertex_operator_algebra:40">
<semantics>
<mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<msubsup>
<mi>J</mi>
<mrow>
<msub>
<mi>n</mi>
<mn>1</mn>
</msub>
<mo>+</mo>
<mn>1</mn>
</mrow>
<msub>
<mi>a</mi>
<mn>1</mn>
</msub>
</msubsup>
<msubsup>
<mi>J</mi>
<mrow>
<msub>
<mi>n</mi>
<mn>2</mn>
</msub>
<mo>+</mo>
<mn>1</mn>
</mrow>
<msub>
<mi>a</mi>
<mn>2</mn>
</msub>
</msubsup>
<mi mathvariant="normal">…</mi>
<msubsup>
<mi>J</mi>
<mrow>
<msub>
<mi>n</mi>
<mi>k</mi>
</msub>
<mo>+</mo>
<mn>1</mn>
</mrow>
<msub>
<mi>a</mi>
<mi>k</mi>
</msub>
</msubsup>
<mn>1</mn>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<mo>:</mo>
<mfrac>
<msup>
<mo>∂</mo>
<msub>
<mi>n</mi>
<mn>1</mn>
</msub>
</msup>
<msubsup>
<mo>∂</mo>
<mi>z</mi>
<msub>
<mi>n</mi>
<mn>1</mn>
</msub>
</msubsup>
</mfrac>
<mfrac>
<mrow>
<msup>
<mi>J</mi>
<msub>
<mi>a</mi>
<mn>1</mn>
</msub>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mrow>
<msub>
<mi>n</mi>
<mn>1</mn>
</msub>
<mo lspace="0pt" rspace="3.5pt">!</mo>
</mrow>
</mfrac>
<mfrac>
<msup>
<mo>∂</mo>
<msub>
<mi>n</mi>
<mn>2</mn>
</msub>
</msup>
<msubsup>
<mo>∂</mo>
<mi>z</mi>
<msub>
<mi>n</mi>
<mn>2</mn>
</msub>
</msubsup>
</mfrac>
<mfrac>
<mrow>
<msup>
<mi>J</mi>
<msub>
<mi>a</mi>
<mn>2</mn>
</msub>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mrow>
<msub>
<mi>n</mi>
<mn>2</mn>
</msub>
<mo lspace="0pt" rspace="3.5pt">!</mo>
</mrow>
</mfrac>
<mi mathvariant="normal">⋯</mi>
<mfrac>
<msup>
<mo>∂</mo>
<msub>
<mi>n</mi>
<mi>k</mi>
</msub>
</msup>
<msubsup>
<mo>∂</mo>
<mi>z</mi>
<msub>
<mi>n</mi>
<mi>k</mi>
</msub>
</msubsup>
</mfrac>
<mfrac>
<mrow>
<msup>
<mi>J</mi>
<msub>
<mi>a</mi>
<mi>k</mi>
</msub>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mrow>
<msub>
<mi>n</mi>
<mi>k</mi>
</msub>
<mo lspace="0pt" rspace="3.5pt">!</mo>
</mrow>
</mfrac>
<mo>:</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">Y</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>J</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>a</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>J</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>a</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<cn type="integer">2</cn>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>J</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>a</ci>
<ci>k</ci>
</apply>
</apply>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<ci>k</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
<cn type="integer">1</cn>
<ci>normal-,</ci>
<csymbol cd="unknown">z</csymbol>
<ci>normal-)</ci>
</cerror>
<eq></eq>
<ci>normal-:</ci>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<partialdiff></partialdiff>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<partialdiff></partialdiff>
<ci>z</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<apply>
<divide></divide>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>J</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>a</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>z</ci>
</apply>
<apply>
<factorial></factorial>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<partialdiff></partialdiff>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<partialdiff></partialdiff>
<ci>z</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<apply>
<divide></divide>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>J</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>a</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>z</ci>
</apply>
<apply>
<factorial></factorial>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<ci>normal-⋯</ci>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<partialdiff></partialdiff>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<ci>k</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<partialdiff></partialdiff>
<ci>z</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
<apply>
<divide></divide>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>J</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>a</ci>
<ci>k</ci>
</apply>
</apply>
<ci>z</ci>
</apply>
<apply>
<factorial></factorial>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
<ci>normal-:</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y(J^{a_{1}}_{n_{1}+1}J^{a_{2}}_{n_{2}+1}...J^{a_{k}}_{n_{k}+1}1,z)=:\frac{%
\partial^{n_{1}}}{\partial_{z}^{n_{1}}}\frac{J^{a_{1}}(z)}{n_{1}!}\frac{%
\partial^{n_{2}}}{\partial_{z}^{n_{2}}}\frac{J^{a_{2}}(z)}{n_{2}!}\cdots\frac{%
\partial^{n_{k}}}{\partial_{z}^{n_{k}}}\frac{J^{a_{k}}(z)}{n_{k}!}:
  </annotation>
</semantics>
</math>
</p>

<p>More generally, if one is given a vector space <em>V</em> with an endomorphism <em>T</em> and vector 1, and one assigns to a set of vectors <em>J</em><sup>a</sup> a set of fields <em>J</em><sup>a</sup>(<em>z</em>) ∈ End(<em>V</em>)<a class="uri" href="''z''&lt;sup&gt;±1&lt;/sup&gt;" title="wikilink">''z''<sup>±1</sup></a> that are mutually local, whose positive weight coefficients generate <em>V</em>, and that satisfy the identity and translation conditions, then the previous formula describes a vertex algebra structure.</p>
<h2 id="example-the-rank-1-free-boson">Example: The rank 1 free boson</h2>

<p>A basic example of a noncommutative vertex algebra is the rank 1 free boson, also called the Heisenberg vertex operator algebra. It is "generated" by a single vector <em>b</em>, in the sense that by applying the coefficients of the field <em>b</em>(<em>z</em>) = <em>Y</em>(<em>b</em>,<em>z</em>) to the vector <em>1</em>, we obtain a spanning set. The underlying vector space is the infinite-variable polynomial ring <strong>C</strong>[<em>x</em><sub>1</sub>,<em>x</em><sub>2</sub>,...], where for positive <em>n</em>, the coefficient <em>b</em><sub>–n</sub> of <em>Y</em>(<em>b</em>,<em>z</em>) acts as multiplication by <em>x</em><sub>n</sub>, and <em>b</em><sub>n</sub> acts as <em>n</em> times the partial derivative in <em>x</em><sub>n</sub>. The action of <em>b</em><sub>0</sub> is multiplication by zero, producing the "momentum zero" Fock representation <em>V</em><sub>0</sub> of the Heisenberg Lie algebra (generated by <em>b</em><sub>n</sub> for integers <em>n</em>, with commutation relations [<em>b</em><sub>n</sub>,<em>b</em><sub>m</sub>]=<em>n</em> δ<sub>n,–m</sub>), i.e., induced by the trivial representation of the subalgebra spanned by <em>b</em><sub>n</sub>, n ≥ 0.</p>

<p>The Fock space <em>V</em><sub>0</sub> can be made into a vertex algebra by following reconstruction:</p>

<p>
<math display="block" id="Vertex_operator_algebra:41">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>x</mi>
<mrow>
<msub>
<mi>n</mi>
<mn>1</mn>
</msub>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<msub>
<mi>x</mi>
<mrow>
<msub>
<mi>n</mi>
<mn>2</mn>
</msub>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<msub>
<mi>x</mi>
<mrow>
<msub>
<mi>n</mi>
<mn>3</mn>
</msub>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mi mathvariant="normal">…</mi>
<msub>
<mi>x</mi>
<mrow>
<msub>
<mi>n</mi>
<mi>k</mi>
</msub>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
</mrow>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>≡</mo>
<mfrac>
<mn>1</mn>
<mrow>
<msub>
<mi>n</mi>
<mn>1</mn>
</msub>
<mo lspace="0pt" rspace="3.5pt">!</mo>
<msub>
<mi>n</mi>
<mn>2</mn>
</msub>
<mo lspace="0pt" rspace="3.5pt">!</mo>
<mo>.</mo>
<mo>.</mo>
<msub>
<mi>n</mi>
<mi>k</mi>
</msub>
<mo lspace="0pt" rspace="3.5pt">!</mo>
</mrow>
</mfrac>
</mrow>
<mo>:</mo>
<mrow>
<mrow>
<msup>
<mo>∂</mo>
<msub>
<mi>n</mi>
<mn>1</mn>
</msub>
</msup>
<mi>b</mi>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<msup>
<mo>∂</mo>
<msub>
<mi>n</mi>
<mn>2</mn>
</msub>
</msup>
<mi>b</mi>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi mathvariant="normal">…</mi>
<mrow>
<msup>
<mo>∂</mo>
<msub>
<mi>n</mi>
<mi>k</mi>
</msub>
</msup>
<mi>b</mi>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>:</mo>
<mi></mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<ci>normal-:</ci>
<apply>
<equivalent></equivalent>
<apply>
<times></times>
<ci>Y</ci>
<interval closure="open">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<cn type="integer">2</cn>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<cn type="integer">3</cn>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<ci>k</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<ci>z</ci>
</interval>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
<factorial></factorial>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<cn type="integer">2</cn>
</apply>
<factorial></factorial>
<ci>normal-.</ci>
<ci>normal-.</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<ci>k</ci>
</apply>
<factorial></factorial>
</cerror>
</apply>
</apply>
<apply>
<times></times>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<partialdiff></partialdiff>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>b</ci>
</apply>
<ci>z</ci>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<partialdiff></partialdiff>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>b</ci>
</apply>
<ci>z</ci>
<ci>normal-…</ci>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<partialdiff></partialdiff>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<ci>k</ci>
</apply>
</apply>
<ci>b</ci>
</apply>
<ci>z</ci>
</apply>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<csymbol cd="latexml">absent</csymbol>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y(x_{n_{1}+1}x_{n_{2}+1}x_{n_{3}+1}...x_{n_{k}+1},z)\equiv\frac{1}{n_{1}!n_{2}%
!..n_{k}!}:\partial^{n_{1}}b(z)\partial^{n_{2}}b(z)...\partial^{n_{k}}b(z):
  </annotation>
</semantics>
</math>
</p>

<p>where :..: denotes normal ordering (i.e. moving all derivatives in <em>x</em> to the right). The vertex operators may also be written as a functional of a multivariable function f as:</p>

<p>
<math display="block" id="Vertex_operator_algebra:42">
<semantics>
<mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">[</mo>
<mi>f</mi>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">]</mo>
</mrow>
<mo>≡</mo>
<mo>:</mo>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mfrac>
<mrow>
<mi>b</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mrow>
<mn>0</mn>
<mo lspace="0pt" rspace="3.5pt">!</mo>
</mrow>
</mfrac>
<mo>,</mo>
<mfrac>
<mrow>
<msup>
<mi>b</mi>
<mo>′</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mrow>
<mn>1</mn>
<mo lspace="0pt" rspace="3.5pt">!</mo>
</mrow>
</mfrac>
<mo>,</mo>
<mfrac>
<mrow>
<msup>
<mi>b</mi>
<mi>′′</mi>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mrow>
<mn>2</mn>
<mo lspace="0pt" rspace="3.5pt">!</mo>
</mrow>
</mfrac>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>:</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">Y</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-[</ci>
<csymbol cd="unknown">f</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">z</csymbol>
<ci>normal-]</ci>
</cerror>
<equivalent></equivalent>
<ci>normal-:</ci>
<csymbol cd="unknown">f</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>b</ci>
<ci>z</ci>
</apply>
<apply>
<factorial></factorial>
<cn type="integer">0</cn>
</apply>
</apply>
<ci>normal-,</ci>
<apply>
<divide></divide>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>b</ci>
<ci>normal-′</ci>
</apply>
<ci>z</ci>
</apply>
<apply>
<factorial></factorial>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>normal-,</ci>
<apply>
<divide></divide>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>b</ci>
<ci>′′</ci>
</apply>
<ci>z</ci>
</apply>
<apply>
<factorial></factorial>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>normal-,</ci>
<ci>normal-…</ci>
<ci>normal-)</ci>
</cerror>
<ci>normal-:</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y[f,z]\equiv:f(\frac{b(z)}{0!},\frac{b^{\prime}(z)}{1!},\frac{b^{\prime\prime}%
(z)}{2!},...):
  </annotation>
</semantics>
</math>
</p>

<p>if we understand that each term in the expansion of f is normal ordered.</p>

<p>The rank <em>n</em> free boson is given by taking an <em>n</em>-fold tensor product of the rank 1 free boson. For any vector <em>b</em> in <em>n</em>-dimensional space, one has a field <em>b</em>(<em>z</em>) whose coefficients are elements of the rank <em>n</em> Heisenberg algebra, whose commutation relations have an extra inner product term: [<em>b</em><sub>n</sub>,<em>c</em><sub>m</sub>]=<em>n</em> (b,c) δ<sub>n,–m</sub>.</p>
<h2 id="example-virasoro-vertex-operator-algebras">Example: Virasoro vertex operator algebras</h2>

<p>Virasoro vertex operator algebras are important for two reasons: First, the conformal element in a vertex operator algebra canonically induces a homomorphism from a Virasoro vertex operator algebra, so they play a universal role in the theory. Second, they are intimately connected to the theory of unitary representations of the Virasoro algebra, and these play a major role in conformal field theory. In particular, the unitary Virasoro minimal models are simple quotients of these vertex algebras, and their tensor products provide a way to combinatorially construct more complicated vertex operator algebras.</p>

<p>The Virasoro vertex operator algebra is defined as an induced representation of the Virasoro algebra: If we choose a central charge <em>c</em>, there is a unique one-dimensional module for the subalgebra <strong>C</strong>[z]∂<sub>z</sub> + <em>K</em> for which <em>K</em> acts by <em>c</em>Id, and <strong>C</strong>[z]∂<sub>z</sub> acts trivially, and the corresponding induced module is spanned by polynomials in <em>L</em><sub>–n</sub> = –z<sup>−n–1</sup>∂<sub>z</sub> as <em>n</em> ranges over integers greater than 1. The module then has partition function</p>

<p>
<math display="block" id="Vertex_operator_algebra:43">
<semantics>
<mrow>
<mrow>
<mi>T</mi>
<msub>
<mi>r</mi>
<mi>V</mi>
</msub>
<msup>
<mi>q</mi>
<msub>
<mi>L</mi>
<mn>0</mn>
</msub>
</msup>
</mrow>
<mo>=</mo>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>n</mi>
<mo>∈</mo>
<mi>𝐑</mi>
</mrow>
</munder>
<mrow>
<mo>dim</mo>
<mrow>
<msub>
<mi>V</mi>
<mi>n</mi>
</msub>
<msup>
<mi>q</mi>
<mi>n</mi>
</msup>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
<mrow>
<mi>n</mi>
<mo>≥</mo>
<mn>2</mn>
</mrow>
</munder>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<msup>
<mi>q</mi>
<mi>n</mi>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<ci>T</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>r</ci>
<ci>V</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>q</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<cn type="integer">0</cn>
</apply>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<in></in>
<ci>n</ci>
<ci>𝐑</ci>
</apply>
</apply>
<apply>
<csymbol cd="latexml">dimension</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>q</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">product</csymbol>
<apply>
<geq></geq>
<ci>n</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>q</ci>
<ci>n</ci>
</apply>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Tr_{V}q^{L_{0}}=\sum_{n\in\mathbf{R}}\dim V_{n}q^{n}=\prod_{n\geq 2}(1-q^{n})^%
{-1}
  </annotation>
</semantics>
</math>

.</p>

<p>This space has a vertex operator algebra structure, where the vertex operators are defined by:</p>

<p>
<math display="block" id="Vertex_operator_algebra:44">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>L</mi>
<mrow>
<mrow>
<mo>-</mo>
<msub>
<mi>n</mi>
<mn>1</mn>
</msub>
</mrow>
<mo>-</mo>
<mn>2</mn>
</mrow>
</msub>
<msub>
<mi>L</mi>
<mrow>
<mrow>
<mo>-</mo>
<msub>
<mi>n</mi>
<mn>2</mn>
</msub>
</mrow>
<mo>-</mo>
<mn>2</mn>
</mrow>
</msub>
<mi mathvariant="normal">…</mi>
<msub>
<mi>L</mi>
<mrow>
<mrow>
<mo>-</mo>
<msub>
<mi>n</mi>
<mi>k</mi>
</msub>
</mrow>
<mo>-</mo>
<mn>2</mn>
</mrow>
</msub>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<mn>0</mn>
<mo stretchy="false">⟩</mo>
</mrow>
</mrow>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>≡</mo>
<mfrac>
<mn>1</mn>
<mrow>
<msub>
<mi>n</mi>
<mn>1</mn>
</msub>
<mo lspace="0pt" rspace="3.5pt">!</mo>
<msub>
<mi>n</mi>
<mn>2</mn>
</msub>
<mo lspace="0pt" rspace="3.5pt">!</mo>
<mo>.</mo>
<mo>.</mo>
<msub>
<mi>n</mi>
<mi>k</mi>
</msub>
<mo lspace="0pt" rspace="3.5pt">!</mo>
</mrow>
</mfrac>
</mrow>
<mo>:</mo>
<mrow>
<mrow>
<msup>
<mo>∂</mo>
<msub>
<mi>n</mi>
<mn>1</mn>
</msub>
</msup>
<mi>L</mi>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<msup>
<mo>∂</mo>
<msub>
<mi>n</mi>
<mn>2</mn>
</msub>
</msup>
<mi>L</mi>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi mathvariant="normal">…</mi>
<mrow>
<msup>
<mo>∂</mo>
<msub>
<mi>n</mi>
<mi>k</mi>
</msub>
</msup>
<mi>L</mi>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>:</mo>
<mi></mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<ci>normal-:</ci>
<apply>
<equivalent></equivalent>
<apply>
<times></times>
<ci>Y</ci>
<interval closure="open">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<apply>
<minus></minus>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<apply>
<minus></minus>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<apply>
<minus></minus>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<ci>k</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<csymbol cd="latexml">ket</csymbol>
<cn type="integer">0</cn>
</apply>
</apply>
<ci>z</ci>
</interval>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
<factorial></factorial>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<cn type="integer">2</cn>
</apply>
<factorial></factorial>
<ci>normal-.</ci>
<ci>normal-.</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<ci>k</ci>
</apply>
<factorial></factorial>
</cerror>
</apply>
</apply>
<apply>
<times></times>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<partialdiff></partialdiff>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>L</ci>
</apply>
<ci>z</ci>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<partialdiff></partialdiff>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>L</ci>
</apply>
<ci>z</ci>
<ci>normal-…</ci>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<partialdiff></partialdiff>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<ci>k</ci>
</apply>
</apply>
<ci>L</ci>
</apply>
<ci>z</ci>
</apply>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<csymbol cd="latexml">absent</csymbol>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y(L_{-n_{1}-2}L_{-n_{2}-2}...L_{-n_{k}-2}|0\rangle,z)\equiv\frac{1}{n_{1}!n_{2%
}!..n_{k}!}:\partial^{n_{1}}L(z)\partial^{n_{2}}L(z)...\partial^{n_{k}}L(z):
  </annotation>
</semantics>
</math>
</p>

<p>and 

<math display="inline" id="Vertex_operator_algebra:45">
<semantics>
<mrow>
<mi>ω</mi>
<mo>=</mo>
<mrow>
<msub>
<mi>L</mi>
<mrow>
<mo>-</mo>
<mn>2</mn>
</mrow>
</msub>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<mn>0</mn>
<mo stretchy="false">⟩</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>ω</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<apply>
<minus></minus>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<csymbol cd="latexml">ket</csymbol>
<cn type="integer">0</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \omega=L_{-2}|0\rangle
  </annotation>
</semantics>
</math>

. The fact that the Virasoro field <em>L(z)</em> is local with respect to itself can be deduced from the formula for its self-commutator:</p>

<p>
<math display="inline" id="Vertex_operator_algebra:46">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">[</mo>
<mrow>
<mi>L</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>,</mo>
<mrow>
<mi>L</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mrow>
<mo>(</mo>
<mrow>
<mfrac>
<mo>∂</mo>
<mrow>
<mo>∂</mo>
<mi>x</mi>
</mrow>
</mfrac>
<mi>L</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
<msup>
<mi>w</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mi>δ</mi>
<mrow>
<mo>(</mo>
<mfrac>
<mi>z</mi>
<mi>x</mi>
</mfrac>
<mo>)</mo>
</mrow>
</mrow>
<mo>-</mo>
<mrow>
<mn>2</mn>
<mi>L</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<msup>
<mi>x</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mfrac>
<mo>∂</mo>
<mrow>
<mo>∂</mo>
<mi>z</mi>
</mrow>
</mfrac>
<mi>δ</mi>
<mrow>
<mo>(</mo>
<mfrac>
<mi>z</mi>
<mi>x</mi>
</mfrac>
<mo>)</mo>
</mrow>
</mrow>
<mo>-</mo>
<mrow>
<mfrac>
<mn>1</mn>
<mn>12</mn>
</mfrac>
<mi>c</mi>
<msup>
<mi>x</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<msup>
<mrow>
<mo>(</mo>
<mfrac>
<mo>∂</mo>
<mrow>
<mo>∂</mo>
<mi>z</mi>
</mrow>
</mfrac>
<mo>)</mo>
</mrow>
<mn>3</mn>
</msup>
<mi>δ</mi>
<mrow>
<mo>(</mo>
<mfrac>
<mi>z</mi>
<mi>x</mi>
</mfrac>
<mo>)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<interval closure="closed">
<apply>
<times></times>
<ci>L</ci>
<ci>z</ci>
</apply>
<apply>
<times></times>
<ci>L</ci>
<ci>x</ci>
</apply>
</interval>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<times></times>
<apply>
<divide></divide>
<partialdiff></partialdiff>
<apply>
<partialdiff></partialdiff>
<ci>x</ci>
</apply>
</apply>
<ci>L</ci>
<ci>x</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>w</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>δ</ci>
<apply>
<divide></divide>
<ci>z</ci>
<ci>x</ci>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>L</ci>
<ci>x</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<divide></divide>
<partialdiff></partialdiff>
<apply>
<partialdiff></partialdiff>
<ci>z</ci>
</apply>
</apply>
<ci>δ</ci>
<apply>
<divide></divide>
<ci>z</ci>
<ci>x</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">12</cn>
</apply>
<ci>c</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<divide></divide>
<partialdiff></partialdiff>
<apply>
<partialdiff></partialdiff>
<ci>z</ci>
</apply>
</apply>
<cn type="integer">3</cn>
</apply>
<ci>δ</ci>
<apply>
<divide></divide>
<ci>z</ci>
<ci>x</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   [L(z),L(x)]=\left(\frac{\partial}{\partial x}L(x)\right)w^{-1}\delta\left(%
\frac{z}{x}\right)-2L(x)x^{-1}\frac{\partial}{\partial z}\delta\left(\frac{z}{%
x}\right)-\frac{1}{12}cx^{-1}\left(\frac{\partial}{\partial z}\right)^{3}%
\delta\left(\frac{z}{x}\right)
  </annotation>
</semantics>
</math>
</p>

<p>where <em>c</em> is central charge.</p>

<p>Given a vertex algebra homomorphism from a Virasoro vertex algebra of central charge <em>c</em> to any other vertex algebra, the vertex operator attached to the image of ω automatically satisfies the Virasoro relations, i.e., the image of ω is a conformal vector. Conversely, any conformal vector in a vertex algebra induces a distinguished vertex algebra homomorphism from some Virasoro vertex operator algebra.</p>

<p>The Virasoro vertex operator algebras are simple, except when <em>c</em> has the form 1–6(<em>p</em>–<em>q</em>)<sup>2</sup>/<em>pq</em> for coprime integers <em>p</em>,<em>q</em> strictly greater than 1 - this follows from Kac's determinant formula. In these exceptional cases, one has a unique maximal ideal, and the corresponding quotient is called a minimal model. When <em>p</em> = <em>q</em>+1, the vertex algebras are unitary representations of Virasoro, and their modules are known as discrete series representations. They play an important role in conformal field theory in part because they are unusually tractable, and for small <em>p</em>, they correspond to well-known statistical-mechanical systems at criticality, e.g., the Ising model, the tri-critical Ising model, the three-state Potts model, etc. By work of Weiqang Wang <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> concerning fusion rules, we have a full description of the tensor categories of unitary minimal models. For example, when <em>c</em>=1/2 (Ising), there three irreducible modules with lowest <em>L</em><sub>0</sub>-weight 0, 1/2, and 1/16, and its fusion ring is <strong>Z</strong>[<em>x</em>,<em>y</em>]/(<em>x</em><sup>2</sup>–1, <em>y</em><sup>2</sup>–<em>x</em>–1, <em>xy</em>–<em>y</em>).</p>
<h2 id="example-wzw-vacuum-modules">Example: WZW vacuum modules</h2>

<p>By replacing the Heisenberg Lie algebra with an untwisted affine Kac–Moody Lie algebra (i.e., the universal central extension of the algebra of polynomial loops on a finite-dimensional simple Lie algebra), one may construct the Vacuum representation in much the same way as the free boson vertex algebra is constructed. Concretely, pulling back the central extension</p>

<p>
<math display="block" id="Vertex_operator_algebra:47">
<semantics>
<mrow>
<mn>0</mn>
<mo>→</mo>
<mi>ℂ</mi>
<mo>→</mo>
<mover accent="true">
<mi>𝔤</mi>
<mo stretchy="false">^</mo>
</mover>
<mo>→</mo>
<mrow>
<mi>𝔤</mi>
<mrow>
<mo stretchy="false">[</mo>
<mi>t</mi>
<mo>,</mo>
<msup>
<mi>t</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<mo>→</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<ci>normal-→</ci>
<cn type="integer">0</cn>
<ci>ℂ</ci>
</apply>
<apply>
<ci>normal-→</ci>
<share href="#.cmml">
</share>
<apply>
<ci>normal-^</ci>
<ci>𝔤</ci>
</apply>
</apply>
<apply>
<ci>normal-→</ci>
<share href="#.cmml">
</share>
<apply>
<times></times>
<ci>𝔤</ci>
<interval closure="closed">
<ci>t</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>t</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</interval>
</apply>
</apply>
<apply>
<ci>normal-→</ci>
<share href="#.cmml">
</share>
<cn type="integer">0</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   0\to\mathbb{C}\to\hat{\mathfrak{g}}\to\mathfrak{g}[t,t^{-1}]\to 0
  </annotation>
</semantics>
</math>
</p>

<p>along the inclusion 

<math display="inline" id="Vertex_operator_algebra:48">
<semantics>
<mrow>
<mrow>
<mi>𝔤</mi>
<mrow>
<mo stretchy="false">[</mo>
<mi>t</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<mo>→</mo>
<mrow>
<mi>𝔤</mi>
<mrow>
<mo stretchy="false">[</mo>
<mi>t</mi>
<mo>,</mo>
<msup>
<mi>t</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<apply>
<times></times>
<ci>𝔤</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>t</ci>
</apply>
</apply>
<apply>
<times></times>
<ci>𝔤</ci>
<interval closure="closed">
<ci>t</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>t</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</interval>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathfrak{g}[t]\to\mathfrak{g}[t,t^{-1}]
  </annotation>
</semantics>
</math>

 yields a split extension, and the vacuum module is induced from the one-dimensional representation of the latter on which a central basis element acts by some chosen constant called the "level". Since central elements can be identified with invariant inner products on the finite type Lie algebra 

<math display="inline" id="Vertex_operator_algebra:49">
<semantics>
<mi>𝔤</mi>
<annotation-xml encoding="MathML-Content">
<ci>𝔤</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathfrak{g}
  </annotation>
</semantics>
</math>

, one typically normalizes the level so that the Killing form has level twice the dual Coxeter number. Equivalently, level one gives the inner product for which the longest root has norm 2. This matches the loop group convention, where levels are discretized by third cohomology of simply connected compact Lie groups.</p>

<p>By choosing a basis <em>J</em><sup>a</sup> of the finite type Lie algebra, one may form a basis of the affine Lie algebra using <em>J</em><sup>a</sup><sub>n</sub> = <em>J</em><sup>a</sup> <em>t</em><sup>n</sup> together with a central element <em>K</em>. By reconstruction, we can describe the vertex operators by normally ordered products of derivatives of the fields</p>

<p>
<math display="block" id="Vertex_operator_algebra:50">
<semantics>
<mrow>
<mrow>
<mrow>
<msup>
<mi>J</mi>
<mi>a</mi>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>n</mi>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</mrow>
<mi mathvariant="normal">∞</mi>
</munderover>
<mrow>
<msubsup>
<mi>J</mi>
<mi>n</mi>
<mi>a</mi>
</msubsup>
<msup>
<mi>z</mi>
<mrow>
<mrow>
<mo>-</mo>
<mi>n</mi>
</mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>n</mi>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</mrow>
<mi mathvariant="normal">∞</mi>
</munderover>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msup>
<mi>J</mi>
<mi>a</mi>
</msup>
<msup>
<mi>t</mi>
<mi>n</mi>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<msup>
<mi>z</mi>
<mrow>
<mrow>
<mo>-</mo>
<mi>n</mi>
</mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>J</ci>
<ci>a</ci>
</apply>
<ci>z</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>n</ci>
<apply>
<minus></minus>
<infinity></infinity>
</apply>
</apply>
</apply>
<infinity></infinity>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>J</ci>
<ci>a</ci>
</apply>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<apply>
<minus></minus>
<apply>
<minus></minus>
<ci>n</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>n</ci>
<apply>
<minus></minus>
<infinity></infinity>
</apply>
</apply>
</apply>
<infinity></infinity>
</apply>
<apply>
<times></times>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>J</ci>
<ci>a</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>t</ci>
<ci>n</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<apply>
<minus></minus>
<apply>
<minus></minus>
<ci>n</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   J^{a}(z)=\sum_{n=-\infty}^{\infty}J^{a}_{n}z^{-n-1}=\sum_{n=-\infty}^{\infty}(%
J^{a}t^{n})z^{-n-1}.
  </annotation>
</semantics>
</math>
</p>

<p>When the level is non-critical, i.e., the inner product is not minus one half of the Killing form, the vacuum representation has a conformal element, given by the Sugawara construction.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> For any choice of dual bases <em>J</em><sup>a</sup>, <em>J</em><sub>a</sub> with respect to the level 1 inner product, the conformal element is</p>

<p>
<math display="block" id="Vertex_operator_algebra:51">
<semantics>
<mrow>
<mi>ω</mi>
<mo>=</mo>
<mrow>
<mfrac>
<mn>1</mn>
<mrow>
<mn>2</mn>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>k</mi>
<mo>+</mo>
<msup>
<mi>h</mi>
<mo>∨</mo>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mi>a</mi>
</munder>
<mrow>
<msub>
<mi>J</mi>
<mrow>
<mi>a</mi>
<mo>,</mo>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</mrow>
</msub>
<msubsup>
<mi>J</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mi>a</mi>
</msubsup>
<mn>1</mn>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>ω</ci>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<times></times>
<cn type="integer">2</cn>
<apply>
<plus></plus>
<ci>k</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<or></or>
</apply>
</apply>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>a</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>J</ci>
<list>
<ci>a</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</list>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>J</ci>
<ci>a</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \omega=\frac{1}{2(k+h^{\vee})}\sum_{a}J_{a,-1}J^{a}_{-1}1
  </annotation>
</semantics>
</math>
</p>

<p>and yields a vertex operator algebra whose central charge is 

<math display="inline" id="Vertex_operator_algebra:52">
<semantics>
<mrow>
<mi>k</mi>
<mo>⋅</mo>
<mrow>
<mo>dim</mo>
<mrow>
<mi>𝔤</mi>
<mo>/</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>k</mi>
<mo>+</mo>
<msup>
<mi>h</mi>
<mo>∨</mo>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-⋅</ci>
<ci>k</ci>
<apply>
<csymbol cd="latexml">dimension</csymbol>
<apply>
<divide></divide>
<ci>𝔤</ci>
<apply>
<plus></plus>
<ci>k</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<or></or>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   k\cdot\dim\mathfrak{g}/(k+h^{\vee})
  </annotation>
</semantics>
</math>


. At critical level, the conformal structure is destroyed, since the denominator is zero, but one may produce operators <em>L</em><sub>n</sub> for <em>n</em> ≥ –1 by taking a limit as <em>k</em> approaches criticality.</p>

<p>This construction can be altered to work for the rank 1 free boson. In fact, the Virasoro vectors form a one-parameter family ω<sub>s</sub> = 1/2 <em>x</em><sub>1</sub><sup>2</sup> + s <em>x</em><sub>2</sub>, endowing the resulting vertex operator algebras with central charge 1−12s<sup>2</sup>. When <em>s</em>=0, we have the following formula for the graded dimension:</p>

<p>
<math display="block" id="Vertex_operator_algebra:53">
<semantics>
<mrow>
<mrow>
<mi>T</mi>
<msub>
<mi>r</mi>
<mi>V</mi>
</msub>
<msup>
<mi>q</mi>
<msub>
<mi>L</mi>
<mn>0</mn>
</msub>
</msup>
</mrow>
<mo>=</mo>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>n</mi>
<mo>∈</mo>
<mi>𝐙</mi>
</mrow>
</munder>
<mrow>
<mo>dim</mo>
<mrow>
<msub>
<mi>V</mi>
<mi>n</mi>
</msub>
<msup>
<mi>q</mi>
<mi>n</mi>
</msup>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
<mrow>
<mi>n</mi>
<mo>≥</mo>
<mn>1</mn>
</mrow>
</munder>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<msup>
<mi>q</mi>
<mi>n</mi>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<ci>T</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>r</ci>
<ci>V</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>q</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<cn type="integer">0</cn>
</apply>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<in></in>
<ci>n</ci>
<ci>𝐙</ci>
</apply>
</apply>
<apply>
<csymbol cd="latexml">dimension</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>q</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">product</csymbol>
<apply>
<geq></geq>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>q</ci>
<ci>n</ci>
</apply>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Tr_{V}q^{L_{0}}=\sum_{n\in\mathbf{Z}}\dim V_{n}q^{n}=\prod_{n\geq 1}(1-q^{n})^%
{-1}
  </annotation>
</semantics>
</math>
</p>

<p>This is known as the generating function for <a href="partition" title="wikilink">partitions</a>, and is also written as <em>q</em><sup>1/24</sup> times the weight −1/2 modular form 1/η. The rank <em>n</em> free boson then has an <em>n</em> parameter family of Virasoro vectors, and when those parameters are zero, the character is <em>q</em><sup>n/24</sup> times the weight −<em>n</em>/2 modular form η<sup>−n</sup>.</p>
<h2 id="modules">Modules</h2>

<p>Much like ordinary rings, vertex algebras admit a notion of module, or representation. Modules play an important role in conformal field theory, where they are often called sectors. A standard assumption in the physics literature is that the full Hilbert space of a conformal field theory decomposes into a sum of tensor products of left-moving and right-moving sectors:</p>

<p>
<math display="block" id="Vertex_operator_algebra:54">
<semantics>
<mrow>
<mi class="ltx_font_mathcaligraphic">ℋ</mi>
<mo>≅</mo>
<mrow>
<munder>
<mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
<mrow>
<mi>i</mi>
<mo>∈</mo>
<mi>I</mi>
</mrow>
</munder>
<mrow>
<msub>
<mi>M</mi>
<mi>i</mi>
</msub>
<mo>⊗</mo>
<mover accent="true">
<msub>
<mi>M</mi>
<mi>i</mi>
</msub>
<mo>¯</mo>
</mover>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<approx></approx>
<ci>ℋ</ci>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">direct-sum</csymbol>
<apply>
<in></in>
<ci>i</ci>
<ci>I</ci>
</apply>
</apply>
<apply>
<csymbol cd="latexml">tensor-product</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>i</ci>
</apply>
<apply>
<ci>normal-¯</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathcal{H}\cong\bigoplus_{i\in I}M_{i}\otimes\overline{M_{i}}
  </annotation>
</semantics>
</math>
</p>

<p>That is, a conformal field theory has a vertex operator algebra of left-moving chiral symmetries, a vertex operator algebra of right-moving chiral symmetries, and the sectors moving in a given direction are modules for the corresponding vertex operator algebra.</p>

<p>Given a vertex algebra <em>V</em> with multiplication <em>Y</em>, a <em>V</em>-module is a vector space <em>M</em> equipped with an action <em>Y</em><sup>M</sup>: <em>V</em> ⊗ <em>M</em> → <em>M</em>((<em>z</em>)), satisfying the following conditions:</p>
<dl>
<dd>(Identity) <em>Y</em><sup>M</sup>(1,z) = Id<sub>M</sub>
</dd>
<dd>(Associativity, or Jacobi identity) For any <em>u</em>, <em>v</em> ∈ <em>V</em>, <em>w</em> ∈ <em>M</em>, there is an element
</dd>
</dl>

<p>
<math display="block" id="Vertex_operator_algebra:55">
<semantics>
<mrow>
<mrow>
<mi>X</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>v</mi>
<mo>,</mo>
<mi>w</mi>
<mo>;</mo>
<mi>z</mi>
<mo>,</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>∈</mo>
<mrow>
<mi>M</mi>
<mrow>
<mo stretchy="false">[</mo>
<mrow>
<mo stretchy="false">[</mo>
<mi>z</mi>
<mo>,</mo>
<mi>x</mi>
<mo stretchy="false">]</mo>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
<mrow>
<mo stretchy="false">[</mo>
<msup>
<mi>z</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mo>,</mo>
<msup>
<mi>x</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mo>,</mo>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>z</mi>
<mo>-</mo>
<mi>x</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<apply>
<times></times>
<ci>X</ci>
<vector>
<ci>u</ci>
<ci>v</ci>
<ci>w</ci>
<ci>z</ci>
<ci>x</ci>
</vector>
</apply>
<apply>
<times></times>
<ci>M</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<interval closure="closed">
<ci>z</ci>
<ci>x</ci>
</interval>
</apply>
<list>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<ci>z</ci>
<ci>x</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</list>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   X(u,v,w;z,x)\in M[[z,x]][z^{-1},x^{-1},(z-x)^{-1}]
  </annotation>
</semantics>
</math>
</p>

<p>such that <em>Y</em><sup>M</sup>(<em>u</em>,<em>z</em>)<em>Y</em><sup>M</sup>(<em>v</em>,<em>x</em>)<em>w</em> and <em>Y</em><sup>M</sup>(<em>Y</em>(<em>u</em>,<em>z</em>–<em>x</em>)<em>v</em>,<em>x</em>)<em>w</em> are the corresponding expansions of 

<math display="inline" id="Vertex_operator_algebra:56">
<semantics>
<mrow>
<mi>X</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>v</mi>
<mo>,</mo>
<mi>w</mi>
<mo>;</mo>
<mi>z</mi>
<mo>,</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>X</ci>
<vector>
<ci>u</ci>
<ci>v</ci>
<ci>w</ci>
<ci>z</ci>
<ci>x</ci>
</vector>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   X(u,v,w;z,x)
  </annotation>
</semantics>
</math>

 in <em>M</em>((<em>z</em>))((<em>x</em>)) and <em>M</em>((<em>x</em>))((<em>z</em>–<em>x</em>)). Equivalently, the following "Jacobi identity" holds:</p>

<p>
<math display="block" id="Vertex_operator_algebra:57">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<msup>
<mi>z</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mi>δ</mi>
<mrow>
<mo>(</mo>
<mfrac>
<mrow>
<mi>y</mi>
<mo>-</mo>
<mi>x</mi>
</mrow>
<mi>z</mi>
</mfrac>
<mo>)</mo>
</mrow>
<msup>
<mi>Y</mi>
<mi>M</mi>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<msup>
<mi>Y</mi>
<mi>M</mi>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>v</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>w</mi>
</mrow>
<mo>-</mo>
<mrow>
<msup>
<mi>z</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mi>δ</mi>
<mrow>
<mo>(</mo>
<mfrac>
<mrow>
<mrow>
<mo>-</mo>
<mi>y</mi>
</mrow>
<mo>+</mo>
<mi>x</mi>
</mrow>
<mi>z</mi>
</mfrac>
<mo>)</mo>
</mrow>
<msup>
<mi>Y</mi>
<mi>M</mi>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>v</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
<msup>
<mi>Y</mi>
<mi>M</mi>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>w</mi>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msup>
<mi>y</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mi>δ</mi>
<mrow>
<mo>(</mo>
<mfrac>
<mrow>
<mi>x</mi>
<mo>+</mo>
<mi>z</mi>
</mrow>
<mi>y</mi>
</mfrac>
<mo>)</mo>
</mrow>
<msup>
<mi>Y</mi>
<mi>M</mi>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>v</mi>
</mrow>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>w</mi>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>δ</ci>
<apply>
<divide></divide>
<apply>
<minus></minus>
<ci>y</ci>
<ci>x</ci>
</apply>
<ci>z</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>Y</ci>
<ci>M</ci>
</apply>
<interval closure="open">
<ci>u</ci>
<ci>x</ci>
</interval>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>Y</ci>
<ci>M</ci>
</apply>
<interval closure="open">
<ci>v</ci>
<ci>y</ci>
</interval>
<ci>w</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>δ</ci>
<apply>
<divide></divide>
<apply>
<plus></plus>
<apply>
<minus></minus>
<ci>y</ci>
</apply>
<ci>x</ci>
</apply>
<ci>z</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>Y</ci>
<ci>M</ci>
</apply>
<interval closure="open">
<ci>v</ci>
<ci>y</ci>
</interval>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>Y</ci>
<ci>M</ci>
</apply>
<interval closure="open">
<ci>u</ci>
<ci>x</ci>
</interval>
<ci>w</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>y</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>δ</ci>
<apply>
<divide></divide>
<apply>
<plus></plus>
<ci>x</ci>
<ci>z</ci>
</apply>
<ci>y</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>Y</ci>
<ci>M</ci>
</apply>
<interval closure="open">
<apply>
<times></times>
<ci>Y</ci>
<interval closure="open">
<ci>u</ci>
<ci>z</ci>
</interval>
<ci>v</ci>
</apply>
<ci>y</ci>
</interval>
<ci>w</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   z^{-1}\delta\left(\frac{y-x}{z}\right)Y^{M}(u,x)Y^{M}(v,y)w-z^{-1}\delta\left(%
\frac{-y+x}{z}\right)Y^{M}(v,y)Y^{M}(u,x)w=y^{-1}\delta\left(\frac{x+z}{y}%
\right)Y^{M}(Y(u,z)v,y)w.
  </annotation>
</semantics>
</math>
</p>

<p>The modules of a vertex algebra form an abelian category. When working with vertex operator algebras, the previous definition is given the name "weak module", and <em>V</em>-modules are required to satisfy the additional condition that <em>L</em><sub>0</sub> acts semisimply with finite-dimensional eigenspaces and eigenvalues bounded below in each coset of <strong>Z</strong>. Work of Huang, Lepowsky, Miyamoto, and Zhang has shown at various levels of generality that modules of a vertex operator algebra admit a fusion tensor product operation, and form a braided tensor category.</p>

<p>When the category of <em>V</em>-modules is semisimple with finitely many irreducible objects, the vertex operator algebra <em>V</em> is called rational. Rational vertex operator algebras satisfying an additional finiteness hypothesis (known as Zhu's <em>C</em><sub>2</sub>-cofiniteness condition) are known to be particularly well-behaved, and are called "regular". For example, Zhu's 1996 modular invariance theorem asserts that the characters of modules of a regular VOA form a vector-valued representation of <em>SL</em><sub>2</sub>(<strong>Z</strong>). In particular, if a VOA is <em>holomorphic</em>, i.e., its representation category is equivalent to that of vector spaces, then its partition function is <em>SL</em><sub>2</sub>(<strong>Z</strong>)-invariant up to a constant. Huang showed that the category of modules of a regular VOA is a <a href="modular_tensor_category" title="wikilink">modular tensor category</a>, and its fusion rules satisfy the <a href="Verlinde_formula" title="wikilink">Verlinde formula</a>.</p>

<p>To connect with our first example, the irreducible modules of the rank 1 free boson are given by Fock spaces <em>V</em><sub>λ</sub> with some fixed momentum λ, i.e., induced representations of the Heisenberg Lie algebra, where the element <em>b</em><sub>0</sub> acts by scalar multiplication by λ. The space can be written as <strong>C</strong>[<em>x</em><sub>1</sub>,<em>x</em><sub>2</sub>,...]<em>v</em><sub>λ</sub>, where <em>v</em><sub>λ</sub> is a distinguished ground-state vector. The module category is not semisimple, since one may induce a representation of the abelian Lie algebra where <em>b</em><sub>0</sub> acts by a nontrivial Jordan block. For the rank <em>n</em> free boson, one has an irreducible module <em>V</em><sub>λ</sub> for each vector λ in complex <em>n</em>-dimensional space. Each vector <em>b</em> ∈ <strong>C</strong><sup>n</sup> yields the operator <em>b</em><sub>0</sub>, and the Fock space <em>V</em><sub>λ</sub> is distinguished by the property that each such <em>b</em><sub>0</sub> acts as scalar multiplication by the inner product (<em>b</em>,λ).</p>

<p>Unlike ordinary rings, vertex algebras admit a notion of twisted module attached to an automorphism. For an automorphism σ of order <em>N</em>, the action has the form <em>V</em> ⊗ <em>M</em> → <em>M</em>((<em>z</em><sup>1/N</sup>)), with the following monodromy condition: if <em>u</em> ∈ <em>V</em> satisfies σ <em>u</em> = exp(2π<em>ik</em>/<em>N</em>)<em>u</em>, then <em>u</em><sub>n</sub> = 0 unless <em>n</em> satisfies <em>n</em>+<em>k</em>/<em>N</em> ∈ <strong>Z</strong> (there is some disagreement about signs among specialists). Geometrically, twisted modules can be attached to branch points on an algebraic curve with a ramified Galois cover. In the conformal field theory literature, twisted modules are called twisted sectors, and are intimately connected with string theory on orbifolds.</p>
<h2 id="vertex-operator-algebra-defined-by-an-even-lattice">Vertex operator algebra defined by an even lattice</h2>

<p>The lattice vertex algebra construction was the original motivation for defining vertex algebras. It is constructed by taking a sum of irreducible modules for the free boson corresponding to lattice vectors, and defining a multiplication operation by specifying intertwining operators between them. That is, if 

<math display="inline" id="Vertex_operator_algebra:58">
<semantics>
<mi mathvariant="normal">Λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Λ
  </annotation>
</semantics>
</math>

 is an even lattice, the lattice vertex algebra <mtpl></mtpl> decomposes into free bosonic modules as:</p>

<p>
<math display="block" id="Vertex_operator_algebra:59">
<semantics>
<mrow>
<msub>
<mi>V</mi>
<mi mathvariant="normal">Λ</mi>
</msub>
<mo>≅</mo>
<mrow>
<munder>
<mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
<mrow>
<mi>λ</mi>
<mo>∈</mo>
<mi mathvariant="normal">Λ</mi>
</mrow>
</munder>
<msub>
<mi>V</mi>
<mi>λ</mi>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<approx></approx>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<ci>normal-Λ</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">direct-sum</csymbol>
<apply>
<in></in>
<ci>λ</ci>
<ci>normal-Λ</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<ci>λ</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   V_{\Lambda}\cong\bigoplus_{\lambda\in\Lambda}V_{\lambda}
  </annotation>
</semantics>
</math>
</p>

<p>Lattice vertex algebras are canonically attached to double covers of <a href="even_integral_lattices" title="wikilink">even integral lattices</a>, rather than the lattices themselves. While each such lattice has a unique lattice vertex algebra up to isomorphism, the vertex algebra construction is not functorial, because lattice automorphisms have an ambiguity in lifting.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>The double covers in question are uniquely determined up to isomorphism by the following rule: elements have the form <mtpl></mtpl> for lattice vectors 

<math display="inline" id="Vertex_operator_algebra:60">
<semantics>
<mrow>
<mi>α</mi>
<mi mathvariant="normal">∈</mi>
<mi mathvariant="normal">Λ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>α</ci>
<ci>normal-∈</ci>
<ci>normal-Λ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   α∈Λ
  </annotation>
</semantics>
</math>

 (i.e., there is a map to 

<math display="inline" id="Vertex_operator_algebra:61">
<semantics>
<mi mathvariant="normal">Λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Λ
  </annotation>
</semantics>
</math>

 sending <mtpl></mtpl> to α that forgets signs), and multiplication satisfies the relations <em>e</em><sub>α</sub><em>e</em><sub>β</sub> = (–1)<sup>(α,β)</sup><em>e</em><sub>β</sub><em>e</em><sub>α</sub>. Another way to describe this is that given an even lattice 

<math display="inline" id="Vertex_operator_algebra:62">
<semantics>
<mi mathvariant="normal">Λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Λ
  </annotation>
</semantics>
</math>


, there is a unique (up to coboundary) normalised <a class="uri" href="cocycle" title="wikilink">cocycle</a>
<math display="inline" id="Vertex_operator_algebra:63">
<semantics>
<mrow>
<mi>ε</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>α</mi>
<mo>,</mo>
<mi>β</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>ε</ci>
<interval closure="open">
<ci>α</ci>
<ci>β</ci>
</interval>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   ε(α,β)
  </annotation>
</semantics>
</math>

 with values 

<math display="inline" id="Vertex_operator_algebra:64">
<semantics>
<mrow>
<mi mathvariant="normal">±</mi>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>normal-±</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   ±1
  </annotation>
</semantics>
</math>

 such that <mtpl> <em>ε</em>(<em>α</em>, <em>β</em>) <em>ε</em>(<em>β</em>, <em>α</em>)}}</mtpl>, where the normalization condition is that ε(α,0) = ε(0,α) = 1 for all 

<math display="inline" id="Vertex_operator_algebra:65">
<semantics>
<mrow>
<mi>α</mi>
<mi mathvariant="normal">∈</mi>
<mi mathvariant="normal">Λ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>α</ci>
<ci>normal-∈</ci>
<ci>normal-Λ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   α∈Λ
  </annotation>
</semantics>
</math>

. This cocycle induces a central extension of 

<math display="inline" id="Vertex_operator_algebra:66">
<semantics>
<mi mathvariant="normal">Λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Λ
  </annotation>
</semantics>
</math>

 by a group of order 2, and we obtain a twisted group ring <mtpl></mtpl> with basis <mtpl></mtpl>, and multiplication rule <mtpl> <em>ε</em>(<em>α</em>, <em>β</em>)<em>e</em><sub><em>α</em>+<em>β</em></sub>}}</mtpl> - the cocycle condition on 

<math display="inline" id="Vertex_operator_algebra:67">
<semantics>
<mi>ε</mi>
<annotation-xml encoding="MathML-Content">
<ci>ε</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   ε
  </annotation>
</semantics>
</math>


 ensures associativity of the ring.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>The vertex operator attached to lowest weight vector <mtpl></mtpl> in the Fock space <mtpl></mtpl> is</p>

<p>
<math display="block" id="Vertex_operator_algebra:68">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>v</mi>
<mi>λ</mi>
</msub>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<msub>
<mi>e</mi>
<mi>λ</mi>
</msub>
</mrow>
<mo>:</mo>
<mrow>
<mrow>
<mi>exp</mi>
<mrow>
<mo largeop="true" symmetric="true">∫</mo>
<mrow>
<mi>λ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>:=</mo>
<mrow>
<msub>
<mi>e</mi>
<mi>λ</mi>
</msub>
<msup>
<mi>z</mi>
<mi>λ</mi>
</msup>
<mrow>
<mi>exp</mi>
<mrow>
<mo>(</mo>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>n</mi>
<mo>&lt;</mo>
<mn>0</mn>
</mrow>
</munder>
<mrow>
<msub>
<mi>λ</mi>
<mi>n</mi>
</msub>
<mfrac>
<msup>
<mi>z</mi>
<mrow>
<mo>-</mo>
<mi>n</mi>
</mrow>
</msup>
<mi>n</mi>
</mfrac>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
</mrow>
<mrow>
<mi>exp</mi>
<mrow>
<mo>(</mo>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>n</mi>
<mo>&gt;</mo>
<mn>0</mn>
</mrow>
</munder>
<mrow>
<msub>
<mi>λ</mi>
<mi>n</mi>
</msub>
<mfrac>
<msup>
<mi>z</mi>
<mrow>
<mo>-</mo>
<mi>n</mi>
</mrow>
</msup>
<mi>n</mi>
</mfrac>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<apply>
<eq></eq>
<apply>
<times></times>
<ci>Y</ci>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>v</ci>
<ci>λ</ci>
</apply>
<ci>z</ci>
</interval>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>e</ci>
<ci>λ</ci>
</apply>
</apply>
<apply>
<csymbol cd="latexml">assign</csymbol>
<apply>
<times></times>
<exp></exp>
<apply>
<int></int>
<apply>
<times></times>
<ci>λ</ci>
<ci>z</ci>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>e</ci>
<ci>λ</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<ci>λ</ci>
</apply>
<apply>
<exp></exp>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<lt></lt>
<ci>n</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>λ</ci>
<ci>n</ci>
</apply>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<apply>
<minus></minus>
<ci>n</ci>
</apply>
</apply>
<ci>n</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<exp></exp>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<gt></gt>
<ci>n</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>λ</ci>
<ci>n</ci>
</apply>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<apply>
<minus></minus>
<ci>n</ci>
</apply>
</apply>
<ci>n</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y(v_{\lambda},z)=e_{\lambda}:\exp\int\lambda(z):=e_{\lambda}z^{\lambda}\exp%
\left(\sum_{n&lt;0}\lambda_{n}\frac{z^{-n}}{n}\right)\exp\left(\sum_{n&gt;0}\lambda_%
{n}\frac{z^{-n}}{n}\right),
  </annotation>
</semantics>
</math>
</p>

<p>where <mtpl></mtpl> is a shorthand for the linear map that takes any element of the α-Fock space <mtpl></mtpl> to the monomial <mtpl></mtpl>. The vertex operators for other elements of the Fock space are then determined by reconstruction.</p>

<p>As in the case of the free boson, one has a choice of conformal vector, given by an element <em>s</em> of the vector space 

<math display="inline" id="Vertex_operator_algebra:69">
<semantics>
<mrow>
<mi mathvariant="normal">Λ</mi>
<mi mathvariant="normal">⊗</mi>
<mi>𝐂</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>normal-Λ</ci>
<ci>normal-⊗</ci>
<ci>𝐂</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Λ⊗\mathbf{C}
  </annotation>
</semantics>
</math>

, but the condition that the extra Fock spaces have integer <em>L</em><sub>0</sub> eigenvalues constrains the choice of <em>s</em>: for an orthonormal basis <mtpl></mtpl>, the vector 1/2 <em>x</em><sub>i,1</sub><sup>2</sup> + <em>s</em><sub>2</sub> must satisfy 

<math display="inline" id="Vertex_operator_algebra:70">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>s</mi>
<mo>,</mo>
<mi>λ</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi mathvariant="normal">∈</mi>
<mi>𝐙</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<interval closure="open">
<ci>s</ci>
<ci>λ</ci>
</interval>
<ci>normal-∈</ci>
<ci>𝐙</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (s,λ)∈\mathbf{Z}
  </annotation>
</semantics>
</math>

 for all λ ∈ Λ, i.e., <em>s</em> lies in the dual lattice.</p>

<p>If the even lattice 

<math display="inline" id="Vertex_operator_algebra:71">
<semantics>
<mi mathvariant="normal">Λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Λ
  </annotation>
</semantics>
</math>

 is generated by its "root vectors" (those satisfying (α,α)=2), and any two root vectors are joined by a chain of root vectors with consecutive inner products non-zero then the vertex operator algebra is the unique simple quotient of the vacuum module of the affine Kac–Moody algebra of the corresponding simply laced simple Lie algebra at level one. This is known as the Frenkel–Kac (or <a href="Igor_Frenkel" title="wikilink">Frenkel</a>–<a href="Victor_Kac" title="wikilink">Kac</a>–<a href="Graeme_Segal" title="wikilink">Segal</a>) construction, and is based on the earlier construction by <a href="Sergio_Fubini" title="wikilink">Sergio Fubini</a> and <a href="Gabriele_Veneziano" title="wikilink">Gabriele Veneziano</a> of the <a href="tachyon" title="wikilink">tachyonic vertex operator</a> in the <a href="dual_resonance_model" title="wikilink">dual resonance model</a>. Among other features, the zero modes of the vertex operators corresponding to root vectors give a construction of the underlying simple Lie algebra, related to a presentation originally due to <a href="Jacques_Tits" title="wikilink">Jacques Tits</a>. In particular, one obtains a construction of all ADE type Lie groups directly from their root lattices. And this is commonly considered the simplest way to construct the 248 dimensional group <em>E</em><sub>8</sub>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="vertex-operator-superalgebras">Vertex operator superalgebras</h2>

<p>By allowing the underlying vector space to be a superspace (i.e., a <strong>Z</strong>/2<strong>Z</strong>-graded vector space 

<math display="inline" id="Vertex_operator_algebra:72">
<semantics>
<mrow>
<mi>V</mi>
<mo>=</mo>
<mrow>
<msub>
<mi>V</mi>
<mo>+</mo>
</msub>
<mo>⊕</mo>
<msub>
<mi>V</mi>
<mo>-</mo>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>V</ci>
<apply>
<csymbol cd="latexml">direct-sum</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<plus></plus>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<minus></minus>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   V=V_{+}\oplus V_{-}
  </annotation>
</semantics>
</math>


) one can define a <em>vertex superalgebra</em> by the same data as a vertex algebra, with 1 in <em>V</em><sub>+</sub> and <em>T</em> an even operator. The axioms are essentially the same, but one must incorporate suitable signs into the locality axiom, or one of the equivalent formulations. That is, if <em>a</em> and <em>b</em> are homogeneous, one compares <em>Y</em>(<em>a</em>,<em>z</em>)<em>Y</em>(<em>b</em>,<em>w</em>) with ε<em>Y</em>(<em>b</em>,<em>w</em>)<em>Y</em>(<em>a</em>,<em>z</em>), where ε is –1 if both <em>a</em> and <em>b</em> are odd and 1 otherwise. If in addition there is a Virasoro element ω in the even part of <em>V</em><sub>2</sub>, and the usual grading restrictions are satisfied, then <em>V</em> is called a <em>vertex operator superalgebra</em>.</p>

<p>One of the simplest examples is the vertex operator superalgebra generated by a single free fermion ψ. As a Virasoro representation, it has central charge 1/2, and decomposes as a direct sum of Ising modules of lowest weight 0 and 1/2. One may also describe it as a spin representation of the Clifford algebra on the quadratic space <em>t</em><sup>1/2</sup><strong>C</strong>[<em>t</em>,<em>t</em><sup>−1</sup>](<em>dt</em>)<sup>1/2</sup> with residue pairing. The vertex operator superalgebra is holomorphic, in the sense that all modules are direct sums of itself, i.e., the module category is equivalent to the category of vector spaces.</p>

<p>The tensor square of the free fermion is called the free charged fermion, and by Boson-Fermion correspondence, it is isomorphic to the lattice vertex superalgebra attached to the odd lattice <strong>Z</strong>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> This correspondence has been used by Date-Jimbo-Kashiwara-Miwa to construct <a class="uri" href="soliton" title="wikilink">soliton</a> solutions to the <a href="KP_hierarchy" title="wikilink">KP hierarchy</a> of nonlinear PDEs.</p>
<h2 id="superconformal-structures">Superconformal structures</h2>

<p>The Virasoro algebra has some supersymmetric extensions that naturally appear in superconformal field theory and superstring theory. The <em>N</em>=1, 2, and 4 superconformal algebras are of particular importance.</p>

<p>Infinitesimal holomorphic superconformal transformations of a supercurve (with one even local coordinate <em>z</em> and <em>N</em> odd local coordinates θ<sub>1</sub>,...,θ<sub>N</sub>) are generated by the coefficients of a super-stress–energy tensor <em>T</em>(z,θ<sub>1</sub>,...,θ<sub>N</sub>).</p>

<p>When <em>N</em>=1, <em>T</em> has odd part given by a Virasoro field <em>L</em>(<em>z</em>), and even part given by a field</p>

<p>
<math display="block" id="Vertex_operator_algebra:73">
<semantics>
<mrow>
<mrow>
<mi>G</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mi>n</mi>
</munder>
<mrow>
<msub>
<mi>G</mi>
<mi>n</mi>
</msub>
<msup>
<mi>z</mi>
<mrow>
<mrow>
<mo>-</mo>
<mi>n</mi>
</mrow>
<mo>-</mo>
<mrow>
<mn>3</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</mrow>
</msup>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>G</ci>
<ci>z</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>n</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>G</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<apply>
<minus></minus>
<apply>
<minus></minus>
<ci>n</ci>
</apply>
<apply>
<divide></divide>
<cn type="integer">3</cn>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   G(z)=\sum_{n}G_{n}z^{-n-3/2}
  </annotation>
</semantics>
</math>
</p>

<p>subject to commutation relations</p>
<ul>
<li>
<math display="inline" id="Vertex_operator_algebra:74">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">[</mo>
<msub>
<mi>G</mi>
<mi>m</mi>
</msub>
<mo>,</mo>
<msub>
<mi>L</mi>
<mi>n</mi>
</msub>
<mo stretchy="false">]</mo>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>m</mi>
<mo>-</mo>
<mrow>
<mi>n</mi>
<mo>/</mo>
<mn>2</mn>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<msub>
<mi>G</mi>
<mrow>
<mi>m</mi>
<mo>+</mo>
<mi>n</mi>
</mrow>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<interval closure="closed">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>G</ci>
<ci>m</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<ci>n</ci>
</apply>
</interval>
<apply>
<times></times>
<apply>
<minus></minus>
<ci>m</ci>
<apply>
<divide></divide>
<ci>n</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>G</ci>
<apply>
<plus></plus>
<ci>m</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   [G_{m},L_{n}]=(m-n/2)G_{m+n}
  </annotation>
</semantics>
</math>
</li>
<li>
<math display="inline" id="Vertex_operator_algebra:75">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">[</mo>
<msub>
<mi>G</mi>
<mi>m</mi>
</msub>
<mo>,</mo>
<msub>
<mi>G</mi>
<mi>n</mi>
</msub>
<mo stretchy="false">]</mo>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>m</mi>
<mo>-</mo>
<mi>n</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<msub>
<mi>L</mi>
<mrow>
<mi>m</mi>
<mo>+</mo>
<mi>n</mi>
</mrow>
</msub>
</mrow>
<mo>+</mo>
<mrow>
<msub>
<mi>δ</mi>
<mrow>
<mi>m</mi>
<mo>,</mo>
<mrow>
<mo>-</mo>
<mi>n</mi>
</mrow>
</mrow>
</msub>
<mfrac>
<mrow>
<mrow>
<mn>4</mn>
<msup>
<mi>m</mi>
<mn>2</mn>
</msup>
</mrow>
<mo>+</mo>
<mn>1</mn>
</mrow>
<mn>12</mn>
</mfrac>
<mi>c</mi>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<interval closure="closed">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>G</ci>
<ci>m</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>G</ci>
<ci>n</ci>
</apply>
</interval>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<minus></minus>
<ci>m</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<apply>
<plus></plus>
<ci>m</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>δ</ci>
<list>
<ci>m</ci>
<apply>
<minus></minus>
<ci>n</ci>
</apply>
</list>
</apply>
<apply>
<divide></divide>
<apply>
<plus></plus>
<apply>
<times></times>
<cn type="integer">4</cn>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>m</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<cn type="integer">1</cn>
</apply>
<cn type="integer">12</cn>
</apply>
<ci>c</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   [G_{m},G_{n}]=(m-n)L_{m+n}+\delta_{m,-n}\frac{4m^{2}+1}{12}c
  </annotation>
</semantics>
</math>
</li>
</ul>

<p>By examining the symmetry of the operator products, one finds that there are two possibilities for the field <em>G</em>: the indices <em>n</em> are either all integers, yielding the Ramond algebra, or all half-integers, yielding the Neveu-Schwarz algebra. These algebras have unitary discrete series representations at central charge</p>

<p>
<math display="block" id="Vertex_operator_algebra:76">
<semantics>
<mrow>
<mrow>
<mover accent="true">
<mi>c</mi>
<mo stretchy="false">^</mo>
</mover>
<mo>=</mo>
<mrow>
<mfrac>
<mn>2</mn>
<mn>3</mn>
</mfrac>
<mi>c</mi>
</mrow>
<mo>=</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mfrac>
<mn>8</mn>
<mrow>
<mi>m</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>m</mi>
<mo>+</mo>
<mn>2</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
</mrow>
</mrow>
<mrow>
<mi>m</mi>
<mo>≥</mo>
<mn>3</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<ci>normal-^</ci>
<ci>c</ci>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">2</cn>
<cn type="integer">3</cn>
</apply>
<ci>c</ci>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<apply>
<divide></divide>
<cn type="integer">8</cn>
<apply>
<times></times>
<ci>m</ci>
<apply>
<plus></plus>
<ci>m</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
<apply>
<geq></geq>
<ci>m</ci>
<cn type="integer">3</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hat{c}=\frac{2}{3}c=1-\frac{8}{m(m+2)}\quad m\geq 3
  </annotation>
</semantics>
</math>
</p>

<p>and unitary representations for all <em>c</em> greater than 3/2, with lowest weight <em>h</em> only constrained by <em>h</em>≥ 0 for Neveu-Schwartz and <em>h</em> ≥ <em>c</em>/24 for Ramond.</p>

<p>An <em>N</em>=1 superconformal vector in a vertex operator algebra <em>V</em> of central charge <em>c</em> is an odd element τ ∈ <em>V</em> of weight 3/2, such that</p>

<p>
<math display="block" id="Vertex_operator_algebra:77">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>τ</mi>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>G</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>m</mi>
<mo>∈</mo>
<mrow>
<mi>ℤ</mi>
<mo>+</mo>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</mrow>
</mrow>
</munder>
<mrow>
<msub>
<mi>G</mi>
<mi>n</mi>
</msub>
<msup>
<mi>z</mi>
<mrow>
<mrow>
<mo>-</mo>
<mi>n</mi>
</mrow>
<mo>-</mo>
<mrow>
<mn>3</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</mrow>
</msup>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<ci>Y</ci>
<interval closure="open">
<ci>τ</ci>
<ci>z</ci>
</interval>
</apply>
<apply>
<times></times>
<ci>G</ci>
<ci>z</ci>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<in></in>
<ci>m</ci>
<apply>
<plus></plus>
<ci>ℤ</ci>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>G</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<apply>
<minus></minus>
<apply>
<minus></minus>
<ci>n</ci>
</apply>
<apply>
<divide></divide>
<cn type="integer">3</cn>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y(\tau,z)=G(z)=\sum_{m\in\mathbb{Z}+1/2}G_{n}z^{-n-3/2},
  </annotation>
</semantics>
</math>
<em>G</em><sub>-1/2</sub>τ = ω, and the coefficients of <em>G</em>(<em>z</em>) yield an action of the <em>N</em>=1 Neveu-Schwarz algebra at central charge <em>c</em>.</p>

<p>For <em>N</em>=2 supersymmetry, one obtains even fields <em>L</em>(<em>z</em>) and <em>J</em>(<em>z</em>), and odd fields <em>G</em><sup>+</sup>(z) and <em>G</em><sup>−</sup>(z). The field <em>J</em>(<em>z</em>) generates an action of the Heisenberg algebras (described by physicists as a <em>U</em>(1) current). There are both Ramond and Neveu-Schwartz <em>N</em>=2 superconformal algebras, depending on whether the indexing on the <em>G</em> fields is integral or half-integral. However, the <em>U</em>(1) current gives rise to a one-parameter family of isomorphic superconformal algebras interpolating between Ramond and Neveu-Schwartz, and this deformation of structure is known as spectral flow. The unitary representations are given by discrete series with central charge <em>c</em> = 3-6/<em>m</em> for integers <em>m</em> at least 3, and a continuum of lowest weights for <em>c</em> &gt; 3.</p>

<p>An <em>N</em>=2 superconformal structure on a vertex operator algebra is a pair of odd elements τ<sup>+</sup>, τ<sup>−</sup> of weight 3/2, and an even element µ of weight 1 such that τ<sup>±</sup> generate <em>G</em><sup>±</sup>(z), and µ generates <em>J</em>(<em>z</em>).</p>

<p>For <em>N</em>=3 and 4, unitary representations only have central charges in a discrete family, with <em>c</em>=3<em>k</em>/2 and 6<em>k</em>, respectively, as <em>k</em> ranges over positive integers.</p>
<h2 id="additional-constructions">Additional constructions</h2>
<ul>
<li>Fixed point subalgebras: Given an action of a symmetry group on a vertex operator algebra, the subalgebra of fixed vectors is also a vertex operator algebra. In 2013, Miyamoto proved that two important finiteness properties, namely Zhu's condition C<sub>2</sub> and regularity, are preserved when taking fixed points under finite solvable group actions.</li>
</ul>
<ul>
<li>Current extensions: Given a vertex operator algebra and some modules of integral conformal weight, one may under favorable circumstances describe a vertex operator algebra structure on the direct sum. Lattice vertex algebras are a standard example of this. Another family of examples are framed VOAs, which start with tensor products of Ising models, and add modules that correspond to suitably even codes.</li>
</ul>
<ul>
<li>Orbifolds: Given a finite cyclic group acting on a holomorphic VOA, it is conjectured that one may construct a second holomorphic VOA by adjoining irreducible twisted modules and taking fixed points under an induced automorphism, as long as those twisted modules have suitable conformal weight. This is known to be true in special cases, e.g., groups of order at most 3 acting on lattice VOAs.</li>
</ul>
<ul>
<li>The coset construction (due to Goddard, Kent, and Olive): Given a vertex operator algebra <em>V</em> of central charge <em>c</em> and a set <em>S</em> of vectors, one may define the commutant <em>C</em>(<em>V</em>,<em>S</em>) to be the subspace of vectors <em>v</em> strictly commute with all fields coming from <em>S</em>, i.e., such that <em>Y</em>(<em>s</em>,<em>z</em>)<em>v</em> ∈ V[[<em>z</em>]] for all <em>s</em> ∈ <em>S</em>. This turns out to be a vertex subalgebra, with <em>Y</em>, <em>T</em>, and identity inherited from <em>V</em>. and if <em>S</em> is a VOA of central charge <em>c</em><sub>S</sub>, the commutant is a VOA of central charge <em>c</em>–<em>c</em><sub>S</sub>. For example, the embedding of <em>SU</em>(2) at level <em>k</em>+1 into the tensor product of two <em>SU</em>(2) algebras at levels <em>k</em> and 1 yields the Virasoro discrete series with <em>p</em>=<em>k</em>+2, <em>q</em>=<em>k</em>+3, and this was used to prove their existence in the 1980s. Again with <em>SU</em>(2), the embedding of level <em>k</em>+2 into the tensor product of level <em>k</em> and level 2 yields the <em>N</em>=1 superconformal discrete series.</li>
</ul>
<ul>
<li>BRST reduction: For any degree 1 vector <em>v</em> satisfying <em>v</em><sub>0</sub><sup>2</sup>=0, the cohomology of this operator has a graded vertex superalgebra structure. More generally, one may use any weight 1 field whose residue has square zero. The usual method is to tensor with fermions, as one then has a canonical differential. An important special case is quantum Drinfeld-Sokolov reduction applied to affine Kac–Moody algebras to obtain affine <em>W</em>-algebras as degree 0 cohomology. These <em>W</em> algebras also admit constructions as vertex subalgebras of free bosons given by kernels of screening operators.</li>
</ul>
<h2 id="additional-examples">Additional Examples</h2>
<ul>
<li>The <a href="monster_vertex_algebra" title="wikilink">monster vertex algebra</a>
<math display="inline" id="Vertex_operator_algebra:78">
<semantics>
<msup>
<mi>V</mi>
<mi mathvariant="normal">♮</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>V</ci>
<ci>normal-♮</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   V^{\natural}
  </annotation>
</semantics>
</math>

 (also called the "moonshine module"), the key to Borcherds's proof of the <a href="Monstrous_moonshine" title="wikilink">Monstrous moonshine</a> conjectures, was constructed by Frenkel, Lepowsky, and Meurman in 1988. It is notable because its partition function is the modular invariant <em>j</em>–744, and its automorphism group is the largest sporadic simple group, known as the <a href="monster_group" title="wikilink">monster group</a>. It is constructed by orbifolding the Leech lattice VOA by the order 2 automorphism induced by reflecting the Leech lattice in the origin. That is, one forms the direct sum of the Leech lattice VOA with the twisted module, and takes the fixed points under an induced involution. Frenkel, Lepowsky, and Meurman conjectured in 1988 that 

<math display="inline" id="Vertex_operator_algebra:79">
<semantics>
<msup>
<mi>V</mi>
<mi mathvariant="normal">♮</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>V</ci>
<ci>normal-♮</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   V^{\natural}
  </annotation>
</semantics>
</math>

 is the unique holomorphic vertex operator algebra with central charge 24, and partition function <em>j</em>–744. This conjecture is still open.</li>
</ul>
<ul>
<li>Chiral de Rham complex: Malikov, Schechtman, and Vaintrob showed that by a method of localization, one may canonically attach a bcβγ (boson-fermion superfield) system to a smooth complex manifold. This complex of sheaves has a distinguished differential, and the global cohomology is a vertex superalgebra. Ben-Zvi, Heluani, and Szczesny showed that a Riemannian metric on the manifold induces an <em>N</em>=1 superconformal structure, which is promoted to an <em>N</em>=2 structure if the metric is Kähler and Ricci-flat, and a hyperKähler structure induces an <em>N</em>=4 structure. Borisov and Libgober showed that one may obtain the two-variable <a href="elliptic_genus" title="wikilink">elliptic genus</a> of a compact complex manifold from the cohomology of Chiral de Rham - if the manifold is Calabi-Yau, then this genus is a weak <a href="Jacobi_form" title="wikilink">Jacobi form</a>.</li>
</ul>
<h2 id="related-algebraic-structures">Related algebraic structures</h2>
<ul>
<li>If one considers only the singular part of the OPE in a vertex algebra, one arrives at the definition of a <a href="Lie_conformal_algebra" title="wikilink">Lie conformal algebra</a>. Since one is often only concerned with the singular part of the OPE, this makes Lie conformal algebras a natural object to study. There is a functor from vertex algebras to Lie conformal algebras that forgets the regular part of OPEs, and it has a left adjoint, called the "universal vertex algebra" functor. Vacuum modules of affine Kac–Moody algebras and Virasoro vertex algebras are universal vertex algebras, and in particular, they can be described very concisely once the background theory is developed.</li>
<li>There are several generalizations of the notion of vertex algebra in the literature. Some mild generalizations involve a weakening of the locality axiom to allow monodromy, e.g., the <em>abelian intertwining algebras</em> of Dong and Lepowsky. One may view these roughly as vertex algebra objects in a braided tensor category of graded vector spaces, in much the same way that a vertex superalgebra is such an object in the category of super vector spaces. More complicated generalizations relate to <em>q</em>-deformations and representations of quantum groups, such as in work of Frenkel–Reshetikhin, Etingof–Kazhdan, and Li.</li>
<li>Beilinson and Drinfeld introduced a sheaf-theoretic notion of <em>chiral algebra</em> that is closely related to the notion of vertex algebra, but is defined without using any visible power series. Given an algebraic curve <em>X</em>, a chiral algebra on <em>X</em> is a <em>D</em><sub>X</sub>-module <em>A</em> equipped with a multiplication operation 

<math display="inline" id="Vertex_operator_algebra:80">
<semantics>
<mrow>
<mrow>
<msub>
<mi>j</mi>
<mo>*</mo>
</msub>
<msup>
<mi>j</mi>
<mo>*</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>A</mi>
<mo>⊠</mo>
<mi>A</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>→</mo>
<mrow>
<msub>
<mi mathvariant="normal">Δ</mi>
<mo>*</mo>
</msub>
<mi>A</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>j</ci>
<times></times>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>j</ci>
<times></times>
</apply>
<apply>
<ci>normal-⊠</ci>
<ci>A</ci>
<ci>A</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>normal-Δ</ci>
<times></times>
</apply>
<ci>A</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   j_{*}j^{*}(A\boxtimes A)\to\Delta_{*}A
  </annotation>
</semantics>
</math>

 on <em>X</em>×<em>X</em> that satisfies an associativity condition. They also introduced an equivalent notion of <em>factorization algebra</em> that is a system of quasicoherent sheaves on all finite products of the curve, together with a compatibility condition involving pullbacks to the complement of various diagonals. Any translation-equivariant chiral algebra on the affine line can be identified with a vertex algebra by taking the fiber at a point, and there is a natural way to attach a chiral algebra on a smooth algebraic curve to any vertex operator algebra.</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Non-associative_algebra" title="wikilink">Category:Non-associative algebra</a> <a href="Category:Lie_algebras" title="wikilink">Category:Lie algebras</a> <a href="Category:Conformal_field_theory" title="wikilink">Category:Conformal field theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><em><a href="http://mathoverflow.net/a/16406/121">1</a></em>, The history of the Sugawara construction is complicated, with several attempts required to get the formula correct.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
