<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="856">Learning with errors</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Learning with errors</h1>
<hr>'''Learning with errors (LWE)''' is a problem in [[machine learning]] that is conjectured to be hard to solve. It is a generalization of the [[parity learning]] problem, introduced<ref name="regev05"></ref> by Oded Regev in 2005. Regev showed, furthermore, that the LWE problem is as hard to solve as several worst-case [[lattice problems]]. The LWE problem has recently<ref name="regev05">Oded Regev, “On lattices, learning with errors, random linear codes, and cryptography,” in Proceedings of the thirt
<p>y-seventh annual ACM symposium on Theory of computing (Baltimore, MD, USA: ACM, 2005), 84-93, <a class="uri" href="http://portal.acm.org/citation.cfm?id=1060590.1060603">http://portal.acm.org/citation.cfm?id=1060590.1060603</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> been used as a <a href="Computational_hardness_assumption" title="wikilink">hardness assumption</a> to create <a href="Public-key_cryptography" title="wikilink">public-key cryptosystems</a>. such as the <a href="ring_learning_with_errors_key_exchange" title="wikilink">ring learning with errors key exchange</a> by Peikert.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>An algorithm is said to solve the LWE problem if, when given access to samples 

<math display="inline" id="Learning_with_errors:0">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Learning_with_errors:1">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msubsup>
    <mi>ℤ</mi>
    <mi>q</mi>
    <mi>n</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℤ</ci>
      <ci>q</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\mathbb{Z}_{q}^{n}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Learning_with_errors:2">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>∈</mo>
   <msub>
    <mi>ℤ</mi>
    <mi>q</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℤ</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in\mathbb{Z}_{q}
  </annotation>
 </semantics>
</math>

, with the assurance, for some fixed <a href="linear_function" title="wikilink">linear function</a> 

<math display="inline" id="Learning_with_errors:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>:</mo>
    <mrow>
     <msubsup>
      <mi>ℤ</mi>
      <mi>q</mi>
      <mi>n</mi>
     </msubsup>
     <mo>→</mo>
     <msub>
      <mi>ℤ</mi>
      <mi>q</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ℤ</ci>
       <ci>q</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℤ</ci>
      <ci>q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\mathbb{Z}_{q}^{n}\rightarrow\mathbb{Z}_{q},
  </annotation>
 </semantics>
</math>


 that 

<math display="inline" id="Learning_with_errors:4">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=f(x)
  </annotation>
 </semantics>
</math>

 with high probability and deviates from it according to some known noise model, the algorithm can recreate 

<math display="inline" id="Learning_with_errors:5">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 or some close approximation of it with high probability.</p>
<h2 id="definition">Definition</h2>

<p>Denote by 

<math display="inline" id="Learning_with_errors:6">
 <semantics>
  <mrow>
   <mi>𝕋</mi>
   <mo>=</mo>
   <mrow>
    <mi>ℝ</mi>
    <mo>/</mo>
    <mi>ℤ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝕋</ci>
    <apply>
     <divide></divide>
     <ci>ℝ</ci>
     <ci>ℤ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{T}=\mathbb{R}/\mathbb{Z}
  </annotation>
 </semantics>
</math>

 the additive group on reals modulo one. Denote by 

<math display="inline" id="Learning_with_errors:7">
 <semantics>
  <msub>
   <mi>A</mi>
   <mrow>
    <mi>𝐬</mi>
    <mo>,</mo>
    <mi>ϕ</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <list>
     <ci>𝐬</ci>
     <ci>ϕ</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{\mathbf{s},\phi}
  </annotation>
 </semantics>
</math>

 the distribution on 

<math display="inline" id="Learning_with_errors:8">
 <semantics>
  <mrow>
   <msubsup>
    <mi>ℤ</mi>
    <mi>q</mi>
    <mi>n</mi>
   </msubsup>
   <mo>×</mo>
   <mi>𝕋</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℤ</ci>
      <ci>q</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <ci>𝕋</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{q}^{n}\times\mathbb{T}
  </annotation>
 </semantics>
</math>


 obtained by choosing a vector 

<math display="inline" id="Learning_with_errors:9">
 <semantics>
  <mrow>
   <mi>𝐚</mi>
   <mo>∈</mo>
   <msubsup>
    <mi>ℤ</mi>
    <mi>q</mi>
    <mi>n</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>𝐚</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℤ</ci>
      <ci>q</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{a}\in\mathbb{Z}_{q}^{n}
  </annotation>
 </semantics>
</math>

 uniformly at random, choosing 

<math display="inline" id="Learning_with_errors:10">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 according to a probability distribution 

<math display="inline" id="Learning_with_errors:11">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 on 

<math display="inline" id="Learning_with_errors:12">
 <semantics>
  <mi>𝕋</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝕋</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{T}
  </annotation>
 </semantics>
</math>

 and outputting 

<math display="inline" id="Learning_with_errors:13">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>𝐚</mi>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>𝐚</mi>
      <mo>,</mo>
      <mi>𝐬</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>/</mo>
     <mi>q</mi>
    </mrow>
    <mo>+</mo>
    <mi>e</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>𝐚</ci>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <list>
       <ci>𝐚</ci>
       <ci>𝐬</ci>
      </list>
      <ci>q</ci>
     </apply>
     <ci>e</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbf{a},\langle\mathbf{a},\mathbf{s}\rangle/q+e)
  </annotation>
 </semantics>
</math>


 for some fixed vector 

<math display="inline" id="Learning_with_errors:14">
 <semantics>
  <mrow>
   <mi>𝐬</mi>
   <mo>∈</mo>
   <msubsup>
    <mi>ℤ</mi>
    <mi>q</mi>
    <mi>n</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>𝐬</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℤ</ci>
      <ci>q</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}\in\mathbb{Z}_{q}^{n}
  </annotation>
 </semantics>
</math>

. Here 

<math display="inline" id="Learning_with_errors:15">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>𝐚</mi>
    <mo>,</mo>
    <mi>𝐬</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>s</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>𝐚</ci>
     <ci>𝐬</ci>
    </list>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\langle\mathbf{a},\mathbf{s}\rangle=\sum_{i=1}^{n}a_{i}s_{i}
  </annotation>
 </semantics>
</math>

 is the standard inner product 

<math display="inline" id="Learning_with_errors:16">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>ℤ</mi>
     <mi>q</mi>
     <mi>n</mi>
    </msubsup>
    <mo>×</mo>
    <msubsup>
     <mi>ℤ</mi>
     <mi>q</mi>
     <mi>n</mi>
    </msubsup>
   </mrow>
   <mo>⟶</mo>
   <msub>
    <mi>ℤ</mi>
    <mi>q</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⟶</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ℤ</ci>
       <ci>q</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ℤ</ci>
       <ci>q</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℤ</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{q}^{n}\times\mathbb{Z}_{q}^{n}\longrightarrow\mathbb{Z}_{q}
  </annotation>
 </semantics>
</math>

, the division is done in the <a href="field_of_reals" title="wikilink">field of reals</a> (or more formally, this "division by 

<math display="inline" id="Learning_with_errors:17">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

" is notation for the group homomorphism 

<math display="inline" id="Learning_with_errors:18">
 <semantics>
  <mrow>
   <msub>
    <mi>ℤ</mi>
    <mi>q</mi>
   </msub>
   <mo>⟶</mo>
   <mi>𝕋</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⟶</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℤ</ci>
     <ci>q</ci>
    </apply>
    <ci>𝕋</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{q}\longrightarrow\mathbb{T}
  </annotation>
 </semantics>
</math>


 mapping 

<math display="inline" id="Learning_with_errors:19">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>∈</mo>
   <msub>
    <mi>ℤ</mi>
    <mi>q</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℤ</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\in\mathbb{Z}_{q}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Learning_with_errors:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>q</mi>
    </mrow>
    <mo>+</mo>
    <mi>ℤ</mi>
   </mrow>
   <mo>∈</mo>
   <mi>𝕋</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>q</ci>
     </apply>
     <ci>ℤ</ci>
    </apply>
    <ci>𝕋</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/q+\mathbb{Z}\in\mathbb{T}
  </annotation>
 </semantics>
</math>

), and the final addition is in 

<math display="inline" id="Learning_with_errors:21">
 <semantics>
  <mi>𝕋</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝕋</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{T}
  </annotation>
 </semantics>
</math>

.</p>

<p>The <strong>learning with errors problem</strong> 

<math display="inline" id="Learning_with_errors:22">
 <semantics>
  <msub>
   <mi>LWE</mi>
   <mrow>
    <mi>q</mi>
    <mo>,</mo>
    <mi>ϕ</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>LWE</ci>
    <list>
     <ci>q</ci>
     <ci>ϕ</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{LWE}_{q,\phi}
  </annotation>
 </semantics>
</math>

 is to find 

<math display="inline" id="Learning_with_errors:23">
 <semantics>
  <mrow>
   <mi>𝐬</mi>
   <mo>∈</mo>
   <msubsup>
    <mi>ℤ</mi>
    <mi>q</mi>
    <mi>n</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>𝐬</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℤ</ci>
      <ci>q</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}\in\mathbb{Z}_{q}^{n}
  </annotation>
 </semantics>
</math>


, given access to polynomially many samples of choice from 

<math display="inline" id="Learning_with_errors:24">
 <semantics>
  <msub>
   <mi>A</mi>
   <mrow>
    <mi>𝐬</mi>
    <mo>,</mo>
    <mi>ϕ</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <list>
     <ci>𝐬</ci>
     <ci>ϕ</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{\mathbf{s},\phi}
  </annotation>
 </semantics>
</math>

.</p>

<p>For every 

<math display="inline" id="Learning_with_errors:25">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>α</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha>0
  </annotation>
 </semantics>
</math>

, denote by 

<math display="inline" id="Learning_with_errors:26">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{\alpha}
  </annotation>
 </semantics>
</math>

 the one-dimensional <a href="Normal_distribution" title="wikilink">Gaussian</a> with density function 

<math display="inline" id="Learning_with_errors:27">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>D</mi>
     <mi>α</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>ρ</mi>
      <mi>α</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>α</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ρ</ci>
       <ci>α</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{\alpha}(x)=\rho_{\alpha}(x)/\alpha
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Learning_with_errors:28">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ρ</mi>
     <mi>α</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>π</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mo stretchy="false">|</mo>
          <mi>x</mi>
          <mo stretchy="false">|</mo>
         </mrow>
         <mo>/</mo>
         <mi>α</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <ci>α</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>π</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <divide></divide>
         <apply>
          <abs></abs>
          <ci>x</ci>
         </apply>
         <ci>α</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{\alpha}(x)=e^{-\pi(|x|/\alpha)^{2}}
  </annotation>
 </semantics>
</math>


, and let 

<math display="inline" id="Learning_with_errors:29">
 <semantics>
  <msub>
   <mi mathvariant="normal">Ψ</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Ψ</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi_{\alpha}
  </annotation>
 </semantics>
</math>

 be the distribution on 

<math display="inline" id="Learning_with_errors:30">
 <semantics>
  <mi>𝕋</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝕋</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{T}
  </annotation>
 </semantics>
</math>

 obtained by considering 

<math display="inline" id="Learning_with_errors:31">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{\alpha}
  </annotation>
 </semantics>
</math>

 modulo one. The version of LWE considered in most of the results would be 

<math display="inline" id="Learning_with_errors:32">
 <semantics>
  <msub>
   <mi>LWE</mi>
   <mrow>
    <mi>q</mi>
    <mo>,</mo>
    <msub>
     <mi mathvariant="normal">Ψ</mi>
     <mi>α</mi>
    </msub>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>LWE</ci>
    <list>
     <ci>q</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Ψ</ci>
      <ci>α</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{LWE}_{q,\Psi_{\alpha}}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="decision-version">Decision version</h2>

<p>The <strong>LWE</strong> problem described above is the <em>search</em> version of the problem. In the <em>decision</em> version (<strong>DLWE</strong>), the goal is to distinguish between noisy inner products and uniformly random samples from 

<math display="inline" id="Learning_with_errors:33">
 <semantics>
  <mrow>
   <msubsup>
    <mi>ℤ</mi>
    <mi>q</mi>
    <mi>n</mi>
   </msubsup>
   <mo>×</mo>
   <mi>𝕋</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℤ</ci>
      <ci>q</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <ci>𝕋</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{q}^{n}\times\mathbb{T}
  </annotation>
 </semantics>
</math>


 (practically, some discretized version of it). Regev<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> showed that the <em>decision</em> and <em>search</em> versions are equivalent when 

<math display="inline" id="Learning_with_errors:34">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 is a prime bounded by some polynomial in 

<math display="inline" id="Learning_with_errors:35">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="solving-decision-assuming-search">Solving decision assuming search</h3>

<p>Intuitively, if we have a procedure for the search problem, the decision version can be solved easily: just feed the input samples for the decision problem to the solver for the search problem. Denote the given samples by 

<math display="inline" id="Learning_with_errors:36">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐚</mi>
      <mi>𝐢</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>𝐛</mi>
      <mi>𝐢</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>⊂</mo>
   <mrow>
    <msubsup>
     <mi>ℤ</mi>
     <mi>q</mi>
     <mi>n</mi>
    </msubsup>
    <mo>×</mo>
    <mi>𝕋</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <set>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐚</ci>
       <ci>𝐢</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐛</ci>
       <ci>𝐢</ci>
      </apply>
     </interval>
    </set>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℤ</ci>
       <ci>n</ci>
      </apply>
      <ci>q</ci>
     </apply>
     <ci>𝕋</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(\mathbf{a_{i}},\mathbf{b_{i}})\}\subset\mathbb{Z}^{n}_{q}\times\mathbb{T}
  </annotation>
 </semantics>
</math>

. If the solver returns a candidate 

<math display="inline" id="Learning_with_errors:37">
 <semantics>
  <mi>𝐬</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐬</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}
  </annotation>
 </semantics>
</math>

, for all 

<math display="inline" id="Learning_with_errors:38">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>


, calculate 

<math display="inline" id="Learning_with_errors:39">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <msub>
      <mi>𝐚</mi>
      <mi>𝐢</mi>
     </msub>
     <mo>,</mo>
     <mi>𝐬</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>-</mo>
    <msub>
     <mi>𝐛</mi>
     <mi>𝐢</mi>
    </msub>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <minus></minus>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐚</ci>
       <ci>𝐢</ci>
      </apply>
      <ci>𝐬</ci>
     </list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐛</ci>
      <ci>𝐢</ci>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\langle\mathbf{a_{i}},\mathbf{s}\rangle-\mathbf{b_{i}}\}
  </annotation>
 </semantics>
</math>

. If the samples are from an LWE distribution, then the results of this calculation will be distributed according 

<math display="inline" id="Learning_with_errors:40">
 <semantics>
  <mi>χ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>χ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi
  </annotation>
 </semantics>
</math>

, but if the samples are uniformly random, these quantities will be distributed uniformly as well.</p>
<h3 id="solving-search-assuming-decision">Solving search assuming decision</h3>

<p>For the other direction, given a solver for the decision problem, the search version can be solved as follows: Recover 

<math display="inline" id="Learning_with_errors:41">
 <semantics>
  <mi>𝐬</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐬</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}
  </annotation>
 </semantics>
</math>

 one coordinate at a time. To obtain the first coordinate, 

<math display="inline" id="Learning_with_errors:42">
 <semantics>
  <msub>
   <mi>𝐬</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐬</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}_{1}
  </annotation>
 </semantics>
</math>

, make a guess 

<math display="inline" id="Learning_with_errors:43">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>∈</mo>
   <msub>
    <mi>Z</mi>
    <mi>q</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>k</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Z</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\in Z_{q}
  </annotation>
 </semantics>
</math>


, and do the following. Choose a number 

<math display="inline" id="Learning_with_errors:44">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>∈</mo>
   <msub>
    <mi>ℤ</mi>
    <mi>q</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>r</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℤ</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\in\mathbb{Z}_{q}
  </annotation>
 </semantics>
</math>

 uniformly at random. Transform the given samples 

<math display="inline" id="Learning_with_errors:45">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐚</mi>
      <mi>𝐢</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>𝐛</mi>
      <mi>𝐢</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>⊂</mo>
   <mrow>
    <msubsup>
     <mi>ℤ</mi>
     <mi>q</mi>
     <mi>n</mi>
    </msubsup>
    <mo>×</mo>
    <mi>𝕋</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <set>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐚</ci>
       <ci>𝐢</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐛</ci>
       <ci>𝐢</ci>
      </apply>
     </interval>
    </set>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℤ</ci>
       <ci>n</ci>
      </apply>
      <ci>q</ci>
     </apply>
     <ci>𝕋</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(\mathbf{a_{i}},\mathbf{b_{i}})\}\subset\mathbb{Z}^{n}_{q}\times\mathbb{T}
  </annotation>
 </semantics>
</math>

 as follows. Calculate 

<math display="inline" id="Learning_with_errors:46">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>𝐚</mi>
      <mi>𝐢</mi>
     </msub>
     <mo>+</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>r</mi>
      <mo>,</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>𝐛</mi>
      <mi>𝐢</mi>
     </msub>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>r</mi>
        <mi>k</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>/</mo>
      <mi>q</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <interval closure="open">
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐚</ci>
       <ci>𝐢</ci>
      </apply>
      <vector>
       <ci>r</ci>
       <cn type="integer">0</cn>
       <ci>normal-…</ci>
       <cn type="integer">0</cn>
      </vector>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐛</ci>
       <ci>𝐢</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>r</ci>
        <ci>k</ci>
       </apply>
       <ci>q</ci>
      </apply>
     </apply>
    </interval>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(\mathbf{a_{i}}+(r,0,\ldots,0),\mathbf{b_{i}}+(rk)/q)\}
  </annotation>
 </semantics>
</math>

. Send the transformed samples to the decision solver.</p>

<p>If the guess 

<math display="inline" id="Learning_with_errors:47">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 was correct, the transformation takes the distribution 

<math display="inline" id="Learning_with_errors:48">
 <semantics>
  <msub>
   <mi>A</mi>
   <mrow>
    <mi>𝐬</mi>
    <mo>,</mo>
    <mi>χ</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <list>
     <ci>𝐬</ci>
     <ci>χ</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{\mathbf{s},\chi}
  </annotation>
 </semantics>
</math>


 to itself, and otherwise, since 

<math display="inline" id="Learning_with_errors:49">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 is prime, it takes it to the uniform distribution. So, given a polynomial-time solver for the decision problem that errs with very small probability, since 

<math display="inline" id="Learning_with_errors:50">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 is bounded by some polynomial in 

<math display="inline" id="Learning_with_errors:51">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, it only takes polynomial time to guess every possible value for 

<math display="inline" id="Learning_with_errors:52">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 and use the solver to see which one is correct.</p>

<p>After obtaining 

<math display="inline" id="Learning_with_errors:53">
 <semantics>
  <msub>
   <mi>𝐬</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐬</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}_{1}
  </annotation>
 </semantics>
</math>


, we follow an analogous procedure for each other coordinate 

<math display="inline" id="Learning_with_errors:54">
 <semantics>
  <msub>
   <mi>𝐬</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐬</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}_{j}
  </annotation>
 </semantics>
</math>

. Namely, we transform our 

<math display="inline" id="Learning_with_errors:55">
 <semantics>
  <msub>
   <mi>𝐛</mi>
   <mi>𝐢</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐛</ci>
    <ci>𝐢</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{b_{i}}
  </annotation>
 </semantics>
</math>

 samples the same way, and transform our 

<math display="inline" id="Learning_with_errors:56">
 <semantics>
  <msub>
   <mi>𝐚</mi>
   <mi>𝐢</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐚</ci>
    <ci>𝐢</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{a_{i}}
  </annotation>
 </semantics>
</math>

 samples by calculating 

<math display="inline" id="Learning_with_errors:57">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐚</mi>
    <mi>𝐢</mi>
   </msub>
   <mo>+</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>r</mi>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐚</ci>
     <ci>𝐢</ci>
    </apply>
    <vector>
     <cn type="integer">0</cn>
     <ci>normal-…</ci>
     <ci>r</ci>
     <ci>normal-…</ci>
     <cn type="integer">0</cn>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{a_{i}}+(0,\ldots,r,\ldots,0)
  </annotation>
 </semantics>
</math>

, where the 

<math display="inline" id="Learning_with_errors:58">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>


 is in the 

<math display="inline" id="Learning_with_errors:59">
 <semantics>
  <msup>
   <mi>j</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>j</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j^{th}
  </annotation>
 </semantics>
</math>

 coordinate.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Peikert<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> showed that this reduction, with a small modification, works for any 

<math display="inline" id="Learning_with_errors:60">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 that is a product of distinct, small (polynomial in 

<math display="inline" id="Learning_with_errors:61">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

) primes. The main idea is if 

<math display="inline" id="Learning_with_errors:62">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>q</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>q</mi>
     <mn>2</mn>
    </msub>
    <mi mathvariant="normal">⋯</mi>
    <msub>
     <mi>q</mi>
     <mi>t</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>q</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q=q_{1}q_{2}\cdots q_{t}
  </annotation>
 </semantics>
</math>

, for each 

<math display="inline" id="Learning_with_errors:63">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi mathvariant="normal">ℓ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>normal-ℓ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{\ell}
  </annotation>
 </semantics>
</math>


, guess and check to see if 

<math display="inline" id="Learning_with_errors:64">
 <semantics>
  <msub>
   <mi>𝐬</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐬</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}_{j}
  </annotation>
 </semantics>
</math>

 is congruent to 

<math display="inline" id="Learning_with_errors:65">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
   <msub>
    <mi>q</mi>
    <mi mathvariant="normal">ℓ</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">modulo</csymbol>
    <cn type="integer">0</cn>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <ci>normal-ℓ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\mod q_{\ell}
  </annotation>
 </semantics>
</math>

, and then use the <a href="Chinese_remainder_theorem" title="wikilink">Chinese remainder theorem</a> to recover 

<math display="inline" id="Learning_with_errors:66">
 <semantics>
  <msub>
   <mi>𝐬</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐬</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}_{j}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="average-case-hardness">Average case hardness</h3>

<p>Regev<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> showed the <a href="Random_self-reducibility" title="wikilink">Random self-reducibility</a> of the <strong>LWE</strong> and <strong>DLWE</strong> problems for arbitrary 

<math display="inline" id="Learning_with_errors:67">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Learning_with_errors:68">
 <semantics>
  <mi>χ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>χ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi
  </annotation>
 </semantics>
</math>


. Given samples 

<math display="inline" id="Learning_with_errors:69">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>𝐚</mi>
     <mi>𝐢</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>𝐛</mi>
     <mi>𝐢</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐚</ci>
      <ci>𝐢</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐛</ci>
      <ci>𝐢</ci>
     </apply>
    </interval>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(\mathbf{a_{i}},\mathbf{b_{i}})\}
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Learning_with_errors:70">
 <semantics>
  <msub>
   <mi>A</mi>
   <mrow>
    <mi>𝐬</mi>
    <mo>,</mo>
    <mi>χ</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <list>
     <ci>𝐬</ci>
     <ci>χ</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{\mathbf{s},\chi}
  </annotation>
 </semantics>
</math>

, it is easy to see that 

<math display="inline" id="Learning_with_errors:71">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐚</mi>
      <mi>𝐢</mi>
     </msub>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>𝐛</mi>
       <mi>𝐢</mi>
      </msub>
      <mo>+</mo>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <msub>
        <mi>𝐚</mi>
        <mi>𝐢</mi>
       </msub>
       <mo>,</mo>
       <mi>𝐭</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mi>q</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <divide></divide>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐚</ci>
       <ci>𝐢</ci>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐛</ci>
        <ci>𝐢</ci>
       </apply>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐚</ci>
         <ci>𝐢</ci>
        </apply>
        <ci>𝐭</ci>
       </list>
      </apply>
     </interval>
     <ci>q</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(\mathbf{a_{i}},\mathbf{b_{i}}+\langle\mathbf{a_{i}},\mathbf{t}\rangle)/q\}
  </annotation>
 </semantics>
</math>

 are samples from 

<math display="inline" id="Learning_with_errors:72">
 <semantics>
  <msub>
   <mi>A</mi>
   <mrow>
    <mrow>
     <mi>𝐬</mi>
     <mo>+</mo>
     <mi>𝐭</mi>
    </mrow>
    <mo>,</mo>
    <mi>χ</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <list>
     <apply>
      <plus></plus>
      <ci>𝐬</ci>
      <ci>𝐭</ci>
     </apply>
     <ci>χ</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{\mathbf{s}+\mathbf{t},\chi}
  </annotation>
 </semantics>
</math>

.</p>

<p>So, suppose there was some set 

<math display="inline" id="Learning_with_errors:73">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒮</mi>
   <mo>⊂</mo>
   <msubsup>
    <mi>ℤ</mi>
    <mi>q</mi>
    <mi>n</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>𝒮</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℤ</ci>
      <ci>q</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}\subset\mathbb{Z}_{q}^{n}
  </annotation>
 </semantics>
</math>


 such that 

<math display="inline" id="Learning_with_errors:74">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi class="ltx_font_mathcaligraphic">𝒮</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <msubsup>
      <mi>ℤ</mi>
      <mi>q</mi>
      <mi>n</mi>
     </msubsup>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>p</mi>
    </mrow>
    <mi>o</mi>
    <mi>l</mi>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <abs></abs>
      <ci>𝒮</ci>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ℤ</ci>
        <ci>q</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>p</ci>
     </apply>
     <ci>o</ci>
     <ci>l</ci>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\mathcal{S}|/|\mathbb{Z}_{q}^{n}|=1/poly(n)
  </annotation>
 </semantics>
</math>

, and for distributions 

<math display="inline" id="Learning_with_errors:75">
 <semantics>
  <msub>
   <mi>A</mi>
   <mrow>
    <msup>
     <mi>𝐬</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <mi>χ</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐬</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>χ</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{\mathbf{s^{\prime}},\chi}
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="Learning_with_errors:76">
 <semantics>
  <mrow>
   <msup>
    <mi>𝐬</mi>
    <mo>′</mo>
   </msup>
   <mo>←</mo>
   <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐬</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>𝒮</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s^{\prime}}\leftarrow\mathcal{S}
  </annotation>
 </semantics>
</math>

, <strong>DLWE</strong> was easy.</p>

<p>Then there would be some distinguisher 

<math display="inline" id="Learning_with_errors:77">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

, who, given samples 

<math display="inline" id="Learning_with_errors:78">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>𝐚</mi>
     <mi>𝐢</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>𝐛</mi>
     <mi>𝐢</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐚</ci>
      <ci>𝐢</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐛</ci>
      <ci>𝐢</ci>
     </apply>
    </interval>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(\mathbf{a_{i}},\mathbf{b_{i}})\}
  </annotation>
 </semantics>
</math>


, could tell whether they were uniformly random or from 

<math display="inline" id="Learning_with_errors:79">
 <semantics>
  <msub>
   <mi>A</mi>
   <mrow>
    <msup>
     <mi>𝐬</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <mi>χ</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐬</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>χ</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{\mathbf{s^{\prime}},\chi}
  </annotation>
 </semantics>
</math>

. If we need to distinguish uniformly random samples from 

<math display="inline" id="Learning_with_errors:80">
 <semantics>
  <msub>
   <mi>A</mi>
   <mrow>
    <mi>𝐬</mi>
    <mo>,</mo>
    <mi>χ</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <list>
     <ci>𝐬</ci>
     <ci>χ</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{\mathbf{s},\chi}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Learning_with_errors:81">
 <semantics>
  <mi>𝐬</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐬</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}
  </annotation>
 </semantics>
</math>

 is chosen uniformly at random from 

<math display="inline" id="Learning_with_errors:82">
 <semantics>
  <msubsup>
   <mi>ℤ</mi>
   <mi>q</mi>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℤ</ci>
     <ci>q</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{q}^{n}
  </annotation>
 </semantics>
</math>

, we could simply try different values 

<math display="inline" id="Learning_with_errors:83">
 <semantics>
  <mi>𝐭</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐭</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{t}
  </annotation>
 </semantics>
</math>


 sampled uniformly at random from 

<math display="inline" id="Learning_with_errors:84">
 <semantics>
  <msubsup>
   <mi>ℤ</mi>
   <mi>q</mi>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℤ</ci>
     <ci>q</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{q}^{n}
  </annotation>
 </semantics>
</math>

, calculate 

<math display="inline" id="Learning_with_errors:85">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐚</mi>
      <mi>𝐢</mi>
     </msub>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>𝐛</mi>
       <mi>𝐢</mi>
      </msub>
      <mo>+</mo>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <msub>
        <mi>𝐚</mi>
        <mi>𝐢</mi>
       </msub>
       <mo>,</mo>
       <mi>𝐭</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mi>q</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <divide></divide>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐚</ci>
       <ci>𝐢</ci>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐛</ci>
        <ci>𝐢</ci>
       </apply>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐚</ci>
         <ci>𝐢</ci>
        </apply>
        <ci>𝐭</ci>
       </list>
      </apply>
     </interval>
     <ci>q</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(\mathbf{a_{i}},\mathbf{b_{i}}+\langle\mathbf{a_{i}},\mathbf{t}\rangle)/q\}
  </annotation>
 </semantics>
</math>

 and feed these samples to 

<math display="inline" id="Learning_with_errors:86">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Learning_with_errors:87">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

 comprises a large fraction of 

<math display="inline" id="Learning_with_errors:88">
 <semantics>
  <msubsup>
   <mi>ℤ</mi>
   <mi>q</mi>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℤ</ci>
     <ci>q</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{q}^{n}
  </annotation>
 </semantics>
</math>


, with high probability, if we choose a polynomial number of values for 

<math display="inline" id="Learning_with_errors:89">
 <semantics>
  <mi>𝐭</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐭</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{t}
  </annotation>
 </semantics>
</math>

, we will find one such that 

<math display="inline" id="Learning_with_errors:90">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐬</mi>
    <mo>+</mo>
    <mi>𝐭</mi>
   </mrow>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <plus></plus>
     <ci>𝐬</ci>
     <ci>𝐭</ci>
    </apply>
    <ci>𝒮</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}+\mathbf{t}\in\mathcal{S}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Learning_with_errors:91">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 will successfully distinguish the samples.</p>

<p>Thus, no such 

<math display="inline" id="Learning_with_errors:92">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

 can exist, meaning <strong>LWE</strong> and <strong>DLWE</strong> are (up to a polynomial factor) as hard in the average case as they are in the worst case.</p>
<h2 id="hardness-results">Hardness results</h2>
<h3 id="regevs-result">Regev's result</h3>

<p>For a n-dimensional lattice 

<math display="inline" id="Learning_with_errors:93">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>


, let <em>smoothing parameter</em> 

<math display="inline" id="Learning_with_errors:94">
 <semantics>
  <mrow>
   <msub>
    <mi>η</mi>
    <mi>ϵ</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>L</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>η</ci>
     <ci>ϵ</ci>
    </apply>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta_{\epsilon}(L)
  </annotation>
 </semantics>
</math>

 denote the smallest 

<math display="inline" id="Learning_with_errors:95">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Learning_with_errors:96">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ρ</mi>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mi>s</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>L</mi>
       <mo>*</mo>
      </msup>
      <mo>∖</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mn>𝟎</mn>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <setdiff></setdiff>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>L</ci>
       <times></times>
      </apply>
      <set>
       <cn type="integer">0</cn>
      </set>
     </apply>
    </apply>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{1/s}(L^{*}\setminus\{\mathbf{0}\})\leq\epsilon
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Learning_with_errors:97">
 <semantics>
  <msup>
   <mi>L</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>L</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{*}
  </annotation>
 </semantics>
</math>

 is the dual of 

<math display="inline" id="Learning_with_errors:98">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Learning_with_errors:99">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ρ</mi>
     <mi>α</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>π</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mo stretchy="false">|</mo>
          <mi>x</mi>
          <mo stretchy="false">|</mo>
         </mrow>
         <mo>/</mo>
         <mi>α</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <ci>α</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>π</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <divide></divide>
         <apply>
          <abs></abs>
          <ci>x</ci>
         </apply>
         <ci>α</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{\alpha}(x)=e^{-\pi(|x|/\alpha)^{2}}
  </annotation>
 </semantics>
</math>

 is extended to sets by summing over function values at each element in the set. Let 

<math display="inline" id="Learning_with_errors:100">
 <semantics>
  <msub>
   <mi>D</mi>
   <mrow>
    <mi>L</mi>
    <mo>,</mo>
    <mi>r</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <list>
     <ci>L</ci>
     <ci>r</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{L,r}
  </annotation>
 </semantics>
</math>

 denote the discrete Gaussian distribution on 

<math display="inline" id="Learning_with_errors:101">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 of width 

<math display="inline" id="Learning_with_errors:102">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 for a lattice 

<math display="inline" id="Learning_with_errors:103">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>


 and real 

<math display="inline" id="Learning_with_errors:104">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>r</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r>0
  </annotation>
 </semantics>
</math>

. The probability of each 

<math display="inline" id="Learning_with_errors:105">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in L
  </annotation>
 </semantics>
</math>

 is proportional to 

<math display="inline" id="Learning_with_errors:106">
 <semantics>
  <mrow>
   <msub>
    <mi>ρ</mi>
    <mi>r</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ρ</ci>
     <ci>r</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{r}(x)
  </annotation>
 </semantics>
</math>

.</p>

<p>The <em>discrete Gaussian sampling problem</em>(DGS) is defined as follows: An instance of 

<math display="inline" id="Learning_with_errors:107">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>G</mi>
   <msub>
    <mi>S</mi>
    <mi>ϕ</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>G</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>ϕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   DGS_{\phi}
  </annotation>
 </semantics>
</math>

 is given by an 

<math display="inline" id="Learning_with_errors:108">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


-dimensional lattice 

<math display="inline" id="Learning_with_errors:109">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 and a number 

<math display="inline" id="Learning_with_errors:110">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>≥</mo>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>L</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>r</ci>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\geq\phi(L)
  </annotation>
 </semantics>
</math>

. The goal is to output a sample from 

<math display="inline" id="Learning_with_errors:111">
 <semantics>
  <msub>
   <mi>D</mi>
   <mrow>
    <mi>L</mi>
    <mo>,</mo>
    <mi>r</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <list>
     <ci>L</ci>
     <ci>r</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{L,r}
  </annotation>
 </semantics>
</math>

. Regev shows that there is a reduction from 

<math display="inline" id="Learning_with_errors:112">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mi>a</mi>
   <mi>p</mi>
   <mi>S</mi>
   <mi>V</mi>
   <msub>
    <mi>P</mi>
    <mrow>
     <mn>100</mn>
     <msqrt>
      <mi>n</mi>
     </msqrt>
     <mi>γ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>a</ci>
    <ci>p</ci>
    <ci>S</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <apply>
      <times></times>
      <cn type="integer">100</cn>
      <apply>
       <root></root>
       <ci>n</ci>
      </apply>
      <ci>γ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GapSVP_{100\sqrt{n}\gamma(n)}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Learning_with_errors:113">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>G</mi>
   <msub>
    <mi>S</mi>
    <mrow>
     <mrow>
      <mrow>
       <msqrt>
        <mi>n</mi>
       </msqrt>
       <mi>γ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>/</mo>
      <mi>λ</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>L</mi>
       <mo>*</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>G</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <root></root>
         <ci>n</ci>
        </apply>
        <ci>γ</ci>
        <ci>n</ci>
       </apply>
       <ci>λ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>L</ci>
       <times></times>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   DGS_{\sqrt{n}\gamma(n)/\lambda(L^{*})}
  </annotation>
 </semantics>
</math>


 for any function 

<math display="inline" id="Learning_with_errors:114">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>γ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma(n)
  </annotation>
 </semantics>
</math>

.</p>

<p>Regev then shows that there exists an efficient quantum algorithm for 

<math display="inline" id="Learning_with_errors:115">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>G</mi>
   <msub>
    <mi>S</mi>
    <mrow>
     <mrow>
      <msqrt>
       <mrow>
        <mn>2</mn>
        <mi>n</mi>
       </mrow>
      </msqrt>
      <msub>
       <mi>η</mi>
       <mi>ϵ</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>L</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>/</mo>
     <mi>α</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>G</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <root></root>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>η</ci>
        <ci>ϵ</ci>
       </apply>
       <ci>L</ci>
      </apply>
      <ci>α</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   DGS_{\sqrt{2n}\eta_{\epsilon}(L)/\alpha}
  </annotation>
 </semantics>
</math>

 given access to an oracle for 

<math display="inline" id="Learning_with_errors:116">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mi>W</mi>
   <msub>
    <mi>E</mi>
    <mrow>
     <mi>q</mi>
     <mo>,</mo>
     <msub>
      <mi mathvariant="normal">Ψ</mi>
      <mi>α</mi>
     </msub>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>W</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <list>
      <ci>q</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Ψ</ci>
       <ci>α</ci>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   LWE_{q,\Psi_{\alpha}}
  </annotation>
 </semantics>
</math>

 for integer 

<math display="inline" id="Learning_with_errors:117">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Learning_with_errors:118">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>α</ci>
    <interval closure="open">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\in(0,1)
  </annotation>
 </semantics>
</math>


 such that 

<math display="inline" id="Learning_with_errors:119">
 <semantics>
  <mrow>
   <mrow>
    <mi>α</mi>
    <mi>q</mi>
   </mrow>
   <mo>></mo>
   <mrow>
    <mn>2</mn>
    <msqrt>
     <mi>n</mi>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>α</ci>
     <ci>q</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <root></root>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha q>2\sqrt{n}
  </annotation>
 </semantics>
</math>

. This implies the hardness for 

<math display="inline" id="Learning_with_errors:120">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mi>W</mi>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>W</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   LWE
  </annotation>
 </semantics>
</math>

. Although the proof of this assertion works for any 

<math display="inline" id="Learning_with_errors:121">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

, for creating a cryptosystem, the 

<math display="inline" id="Learning_with_errors:122">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 has to be polynomial in 

<math display="inline" id="Learning_with_errors:123">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


.</p>
<h3 id="peikerts-result">Peikert's result</h3>

<p>Peikert proves<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> that there is a probabilistic polynomial time reduction from the <a href="Lattice_problems#GapSVP" title="wikilink">

<math display="inline" id="Learning_with_errors:124">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mi>a</mi>
   <mi>p</mi>
   <mi>S</mi>
   <mi>V</mi>
   <msub>
    <mi>P</mi>
    <mrow>
     <mi>ζ</mi>
     <mo>,</mo>
     <mi>γ</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>a</ci>
    <ci>p</ci>
    <ci>S</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <list>
      <ci>ζ</ci>
      <ci>γ</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GapSVP_{\zeta,\gamma}
  </annotation>
 </semantics>
</math>

</a> problem in the worst case to solving 

<math display="inline" id="Learning_with_errors:125">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mi>W</mi>
   <msub>
    <mi>E</mi>
    <mrow>
     <mi>q</mi>
     <mo>,</mo>
     <msub>
      <mi mathvariant="normal">Ψ</mi>
      <mi>α</mi>
     </msub>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>W</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <list>
      <ci>q</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Ψ</ci>
       <ci>α</ci>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   LWE_{q,\Psi_{\alpha}}
  </annotation>
 </semantics>
</math>

 using 

<math display="inline" id="Learning_with_errors:126">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mi>o</mi>
   <mi>l</mi>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>o</ci>
    <ci>l</ci>
    <ci>y</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   poly(n)
  </annotation>
 </semantics>
</math>

 samples for parameters 

<math display="inline" id="Learning_with_errors:127">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>α</ci>
    <interval closure="open">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\in(0,1)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Learning_with_errors:128">
 <semantics>
  <mrow>
   <mrow>
    <mi>γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mi>n</mi>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>α</mi>
      <msqrt>
       <mrow>
        <mi>log</mi>
        <mi>n</mi>
       </mrow>
      </msqrt>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>γ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <apply>
      <times></times>
      <ci>α</ci>
      <apply>
       <root></root>
       <apply>
        <log></log>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma(n)\geq n/(\alpha\sqrt{\log{n}})
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Learning_with_errors:129">
 <semantics>
  <mrow>
   <mrow>
    <mi>ζ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mi>γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>ζ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>γ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \zeta(n)\geq\gamma(n)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Learning_with_errors:130">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>≥</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ζ</mi>
    <mo>/</mo>
    <msqrt>
     <mi>n</mi>
    </msqrt>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>ω</mi>
   <msqrt>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
   </msqrt>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">q</csymbol>
    <geq></geq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ζ</csymbol>
     <divide></divide>
     <apply>
      <root></root>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">ω</csymbol>
    <apply>
     <root></root>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\geq(\zeta/\sqrt{n})\omega\sqrt{\log{n}})
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="use-in-cryptography">Use in Cryptography</h2>

<p>The <strong>LWE</strong> problem serves as a versatile problem used in construction of several<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> cryptosystems. In 2005, Regev<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> showed that the decision version of LWE is hard assuming quantum hardness of the <a href="lattice_problems" title="wikilink">lattice problems</a> 

<math display="inline" id="Learning_with_errors:131">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mi>a</mi>
   <mi>p</mi>
   <mi>S</mi>
   <mi>V</mi>
   <msub>
    <mi>P</mi>
    <mi>γ</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>a</ci>
    <ci>p</ci>
    <ci>S</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>γ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GapSVP_{\gamma}
  </annotation>
 </semantics>
</math>

 (for 

<math display="inline" id="Learning_with_errors:132">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

 as above) and 

<math display="inline" id="Learning_with_errors:133">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>I</mi>
   <mi>V</mi>
   <msub>
    <mi>P</mi>
    <mi>t</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>I</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SIVP_{t}
  </annotation>
 </semantics>
</math>


 with t=Õ(n/

<math display="inline" id="Learning_with_errors:134">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

). In 2009, Peikert<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> proved a similar result assuming only the classical hardness of the related problem <a href="Lattice_problems#GapSVP" title="wikilink">

<math display="inline" id="Learning_with_errors:135">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mi>a</mi>
   <mi>p</mi>
   <mi>S</mi>
   <mi>V</mi>
   <msub>
    <mi>P</mi>
    <mrow>
     <mi>ζ</mi>
     <mo>,</mo>
     <mi>γ</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>a</ci>
    <ci>p</ci>
    <ci>S</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <list>
      <ci>ζ</ci>
      <ci>γ</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GapSVP_{\zeta,\gamma}
  </annotation>
 </semantics>
</math>

</a>. The disadvantage of Peikert's result is that it bases itself on a non-standard version of an easier (when compared to SIVP) problem GapSVP.</p>
<h3 id="public-key-cryptosystem">Public-key cryptosystem</h3>

<p>Regev<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> proposed a <a href="public-key_cryptosystem" title="wikilink">public-key cryptosystem</a> based on the hardness of the <strong>LWE</strong> problem. The cryptosystem as well as the proof of security and correctness are completely classical. The system is characterized by 

<math display="inline" id="Learning_with_errors:136">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>,</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>m</ci>
    <ci>q</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m,q
  </annotation>
 </semantics>
</math>

 and a probability distribution 

<math display="inline" id="Learning_with_errors:137">
 <semantics>
  <mi>χ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>χ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi
  </annotation>
 </semantics>
</math>

 on 

<math display="inline" id="Learning_with_errors:138">
 <semantics>
  <mi>𝕋</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝕋</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{T}
  </annotation>
 </semantics>
</math>


. The setting of the parameters used in proofs of correctness and security is</p>
<ul>
<li>

<math display="inline" id="Learning_with_errors:139">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>≥</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>q</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\geq 2
  </annotation>
 </semantics>
</math>

, a prime number between 

<math display="inline" id="Learning_with_errors:140">
 <semantics>
  <msup>
   <mi>n</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{2}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Learning_with_errors:141">
 <semantics>
  <mrow>
   <mn>2</mn>
   <msup>
    <mi>n</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2n^{2}
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Learning_with_errors:142">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mi>ϵ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>log</mi>
     <mi>q</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <ci>ϵ</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <log></log>
      <ci>q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=(1+\epsilon)(n+1)\log{q}
  </annotation>
 </semantics>
</math>

 for an arbitrary constant 

<math display="inline" id="Learning_with_errors:143">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>


</li>
<li>

<math display="inline" id="Learning_with_errors:144">
 <semantics>
  <mrow>
   <mi>χ</mi>
   <mo>=</mo>
   <msub>
    <mi mathvariant="normal">Ψ</mi>
    <mrow>
     <mi>α</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>χ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Ψ</ci>
     <apply>
      <times></times>
      <ci>α</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi=\Psi_{\alpha(n)}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Learning_with_errors:145">
 <semantics>
  <mrow>
   <mrow>
    <mi>α</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>o</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <msqrt>
        <mi>n</mi>
       </msqrt>
      </mrow>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>α</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>o</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <root></root>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(n)\in o(1/\sqrt{n}\log{n})
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>The cryptosystem is then defined by:</p>
<ul>
<li><em>Private Key</em>: Private key is an 

<math display="inline" id="Learning_with_errors:146">
 <semantics>
  <mrow>
   <mi>𝐬</mi>
   <mo>∈</mo>
   <msubsup>
    <mi>ℤ</mi>
    <mi>q</mi>
    <mi>n</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>𝐬</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℤ</ci>
      <ci>n</ci>
     </apply>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}\in\mathbb{Z}^{n}_{q}
  </annotation>
 </semantics>
</math>

 chosen uniformly at random.</li>
<li><em>Public Key</em>: Choose 

<math display="inline" id="Learning_with_errors:147">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 vectors 

<math display="inline" id="Learning_with_errors:148">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mi>m</mi>
    </msub>
   </mrow>
   <mo>∈</mo>
   <msubsup>
    <mi>ℤ</mi>
    <mi>q</mi>
    <mi>n</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>m</ci>
     </apply>
    </list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℤ</ci>
      <ci>n</ci>
     </apply>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1},\ldots,a_{m}\in\mathbb{Z}^{n}_{q}
  </annotation>
 </semantics>
</math>


 uniformly and independently. Choose error offsets 

<math display="inline" id="Learning_with_errors:149">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>e</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>e</mi>
     <mi>m</mi>
    </msub>
   </mrow>
   <mo>∈</mo>
   <mi>𝕋</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>m</ci>
     </apply>
    </list>
    <ci>𝕋</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{1},\ldots,e_{m}\in\mathbb{T}
  </annotation>
 </semantics>
</math>

 independently according to 

<math display="inline" id="Learning_with_errors:150">
 <semantics>
  <mi>χ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>χ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi
  </annotation>
 </semantics>
</math>

. The public key consists of 

<math display="inline" id="Learning_with_errors:151">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>b</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <mi>𝐬</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>/</mo>
    <mi>q</mi>
    <mo>+</mo>
    <msub>
     <mi>e</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>m</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>i</ci>
      </apply>
      <eq></eq>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-⟨</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-,</ci>
       <csymbol cd="unknown">s</csymbol>
       <ci>normal-⟩</ci>
      </cerror>
      <divide></divide>
      <csymbol cd="unknown">q</csymbol>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>m</ci>
    </apply>
    <apply>
     <eq></eq>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a_{i},b_{i}=\langle a_{i},\mathbf{s}\rangle/q+e_{i})^{m}_{i=1}
  </annotation>
 </semantics>
</math>

</li>
<li><em>Encryption</em>: The encryption of a bit 

<math display="inline" id="Learning_with_errors:152">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\{0,1\}
  </annotation>
 </semantics>
</math>

 is done by choosing a random subset 

<math display="inline" id="Learning_with_errors:153">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>


 of 

<math display="inline" id="Learning_with_errors:154">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>m</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [m]
  </annotation>
 </semantics>
</math>

 and then defining 

<math display="inline" id="Learning_with_errors:155">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mi>n</mi>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>n</ci>
    <ci>c</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Enc(x)
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Learning_with_errors:156">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>∈</mo>
      <mi>S</mi>
     </mrow>
    </msub>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>∈</mo>
       <mi>S</mi>
      </mrow>
     </msub>
     <msub>
      <mi>b</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>i</ci>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>i</ci>
        <ci>S</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\sum_{i\in S}a_{i},x/2+\sum_{i\in S}b_{i})
  </annotation>
 </semantics>
</math>

</li>
<li><em>Decryption</em>: The decryption of 

<math display="inline" id="Learning_with_errors:157">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>a</ci>
    <ci>b</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b)
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Learning_with_errors:158">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>


 if 

<math display="inline" id="Learning_with_errors:159">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>-</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>𝐬</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>/</mo>
    <mi>q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>b</ci>
    <apply>
     <divide></divide>
     <list>
      <ci>a</ci>
      <ci>𝐬</ci>
     </list>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b-\langle a,\mathbf{s}\rangle/q
  </annotation>
 </semantics>
</math>

 is closer to 

<math display="inline" id="Learning_with_errors:160">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 than to 

<math display="inline" id="Learning_with_errors:161">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mn>2</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Learning_with_errors:162">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 otherwise.</li>
</ul>

<p>The proof of correctness follows from choice of parameters and some probability analysis. The proof of security is by reduction to the decision version of <strong>LWE</strong>: an algorithm for distinguishing between encryptions (with above parameters) of 

<math display="inline" id="Learning_with_errors:163">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>


 and 

<math display="inline" id="Learning_with_errors:164">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 can be used to distinguish between 

<math display="inline" id="Learning_with_errors:165">
 <semantics>
  <msub>
   <mi>A</mi>
   <mrow>
    <mi>s</mi>
    <mo>,</mo>
    <mi>χ</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <list>
     <ci>s</ci>
     <ci>χ</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{s,\chi}
  </annotation>
 </semantics>
</math>

 and the uniform distribution over 

<math display="inline" id="Learning_with_errors:166">
 <semantics>
  <mrow>
   <msubsup>
    <mi>ℤ</mi>
    <mi>q</mi>
    <mi>n</mi>
   </msubsup>
   <mo>×</mo>
   <msub>
    <mi>ℤ</mi>
    <mi>q</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℤ</ci>
      <ci>n</ci>
     </apply>
     <ci>q</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℤ</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}^{n}_{q}\times\mathbb{Z}_{q}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="cca-secure-cryptosystem">CCA-secure cryptosystem</h3>

<p>Peikert<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> proposed a system that is secure even against any <a href="chosen-ciphertext_attack" title="wikilink">chosen-ciphertext attack</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Lattice-based_cryptography" title="wikilink">Lattice-based cryptography</a></li>
<li><a href="Ring_learning_with_errors_key_exchange" title="wikilink">Ring Learning with Errors Key Exchange</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Machine_learning" title="wikilink">Category:Machine learning</a> <a class="uri" href="Category:Cryptography" title="wikilink">Category:Cryptography</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Chris Peikert, “Public-key cryptosystems from the worst-case shortest vector problem: extended abstract,” in Proceedings of the 41st annual ACM symposium on Theory of computing (Bethesda, MD, USA: ACM, 2009), 333-342, <a class="uri" href="http://portal.acm.org/citation.cfm?id=1536414.1536461">http://portal.acm.org/citation.cfm?id=1536414.1536461</a>.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10">Chris Peikert and Brent Waters, “Lossy trapdoor functions and their applications,” in Proceedings of the 40th annual ACM symposium on Theory of computing (Victoria, British Columbia, Canada: ACM, 2008), 187-196, <a class="uri" href="http://portal.acm.org/citation.cfm?id=1374406">http://portal.acm.org/citation.cfm?id=1374406</a>.<a href="#fnref10">↩</a></li>
<li id="fn11">Craig Gentry, Chris Peikert, and Vinod Vaikuntanathan, “Trapdoors for hard lattices and new cryptographic constructions,” in Proceedings of the 40th annual ACM symposium on Theory of computing (Victoria, British Columbia, Canada: ACM, 2008), 197-206, <a class="uri" href="http://portal.acm.org/citation.cfm?id=1374407">http://portal.acm.org/citation.cfm?id=1374407</a>.<a href="#fnref11">↩</a></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
</ol>
</section>
</ref></hr></body>
</html>
