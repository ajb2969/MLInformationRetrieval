   Rough set      Rough set   In computer science , a rough set , first described by Polish computer scientist Zdzisław I. Pawlak , is a formal approximation of a crisp set (i.e., conventional set) in terms of a pair of sets which give the lower and the upper approximation of the original set. In the standard version of rough set theory (Pawlak 1991), the lower- and upper-approximation sets are crisp sets, but in other variations, the approximating sets may be fuzzy sets .  Definitions  The following section contains an overview of the basic framework of rough set theory, as originally proposed by Zdzisław I. Pawlak , along with some of the key definitions. More formal properties and boundaries of rough sets can be found in Pawlak (1991) and cited references. The initial and basic theory of rough sets is sometimes referred to as "Pawlak Rough Sets" or "classical rough sets" , as a means to distinguish from more recent extensions and generalizations.  Information system framework  Let    I  =   (  𝕌  ,  𝔸  )       I   𝕌  𝔸     I=(\mathbb{U},\mathbb{A})   be an information system ( attribute-value system ), where   𝕌   𝕌   \mathbb{U}   is a non-empty set of finite objects (the universe) and   𝔸   𝔸   \mathbb{A}   is a non-empty, finite set of attributes such that    a  :   𝕌  →   V  a       normal-:  a   normal-→  𝕌   subscript  V  a      a:\mathbb{U}\rightarrow V_{a}   for every    a  ∈  𝔸      a  𝔸    a\in\mathbb{A}   .    V  a     subscript  V  a    V_{a}   is the set of values that attribute   a   a   a   may take. The information table assigns a value    a   (  x  )       a  x    a(x)   from    V  a     subscript  V  a    V_{a}   to each attribute   a   a   a   and object   x   x   x   in the universe   𝕌   𝕌   \mathbb{U}   .  With any    P  ⊆  𝔸      P  𝔸    P\subseteq\mathbb{A}   there is an associated equivalence relation     IND   (  P  )       IND  P    \mathrm{IND}(P)   :       IND   (  P  )    =   {    (  x  ,  y  )   ∈   𝕌  2    ∣     ∀  a   ∈  P   ,    a   (  x  )    =   a   (  y  )      }         IND  P    conditional-set     x  y    superscript  𝕌  2     formulae-sequence     for-all  a   P       a  x     a  y        \mathrm{IND}(P)=\left\{(x,y)\in\mathbb{U}^{2}\mid\forall a\in P,a(x)=a(y)\right\}     The relation    IND   (  P  )       IND  P    \mathrm{IND}(P)   is called a   P   P   P    -indiscernibility relation . The partition of   𝕌   𝕌   \mathbb{U}   is a family of all equivalence classes of    IND   (  P  )       IND  P    \mathrm{IND}(P)   and is denoted by     𝕌  /  IND    (  P  )         𝕌  IND   P    \mathbb{U}/\mathrm{IND}(P)   (or    𝕌  /  P      𝕌  P    \mathbb{U}/P   ).  If     (  x  ,  y  )   ∈   IND   (  P  )         x  y     IND  P     (x,y)\in\mathrm{IND}(P)   , then   x   x   x   and   y   y   y   are indiscernible (or indistinguishable) by attributes from   P   P   P   .  Example: equivalence-class structure  For example, consider the following information table:        Sample Information System   Object       P  1     subscript  P  1    P_{1}          P  2     subscript  P  2    P_{2}          P  3     subscript  P  3    P_{3}          P  4     subscript  P  4    P_{4}          P  5     subscript  P  5    P_{5}            O  1     subscript  O  1    O_{1}      1   2   0   1   1         O  2     subscript  O  2    O_{2}      1   2   0   1   1         O  3     subscript  O  3    O_{3}      2   0   0   1   0         O  4     subscript  O  4    O_{4}      0   0   1   2   1         O  5     subscript  O  5    O_{5}      2   1   0   2   1         O  6     subscript  O  6    O_{6}      0   0   1   2   2         O  7     subscript  O  7    O_{7}      2   0   0   1   0         O  8     subscript  O  8    O_{8}      0   1   2   2   1         O  9     subscript  O  9    O_{9}      2   1   0   2   2         O  10     subscript  O  10    O_{10}      2   0   0   1   0       When the full set of attributes    P  =   {   P  1   ,   P  2   ,   P  3   ,   P  4   ,   P  5   }       P    subscript  P  1    subscript  P  2    subscript  P  3    subscript  P  4    subscript  P  5      P=\{P_{1},P_{2},P_{3},P_{4},P_{5}\}   is considered, we see that we have the following seven equivalence classes:      {      {   O  1   ,   O  2   }         {   O  3   ,   O  7   ,   O  10   }         {   O  4   }         {   O  5   }         {   O  6   }         {   O  8   }         {   O  9   }          cases    subscript  O  1    subscript  O  2    otherwise    subscript  O  3    subscript  O  7    subscript  O  10    otherwise    subscript  O  4    otherwise    subscript  O  5    otherwise    subscript  O  6    otherwise    subscript  O  8    otherwise    subscript  O  9    otherwise    \begin{cases}\{O_{1},O_{2}\}\\
 \{O_{3},O_{7},O_{10}\}\\
 \{O_{4}\}\\
 \{O_{5}\}\\
 \{O_{6}\}\\
 \{O_{8}\}\\
 \{O_{9}\}\end{cases}     Thus, the two objects within the first equivalence class,    {   O  1   ,   O  2   }      subscript  O  1    subscript  O  2     \{O_{1},O_{2}\}   , cannot be distinguished from each other based on the available attributes, and the three objects within the second equivalence class,    {   O  3   ,   O  7   ,   O  10   }      subscript  O  3    subscript  O  7    subscript  O  10     \{O_{3},O_{7},O_{10}\}   , cannot be distinguished from one another based on the available attributes. The remaining five objects are each discernible from all other objects. The equivalence classes of the   P   P   P   -indiscernibility relation are denoted     [  x  ]   P     subscript   delimited-[]  x   P    [x]_{P}   .  It is apparent that different attribute subset selections will in general lead to different indiscernibility classes. For example, if attribute    P  =   {   P  1   }       P    subscript  P  1      P=\{P_{1}\}   alone is selected, we obtain the following, much coarser, equivalence-class structure:      {      {   O  1   ,   O  2   }         {   O  3   ,   O  5   ,   O  7   ,   O  9   ,   O  10   }         {   O  4   ,   O  6   ,   O  8   }          cases    subscript  O  1    subscript  O  2    otherwise    subscript  O  3    subscript  O  5    subscript  O  7    subscript  O  9    subscript  O  10    otherwise    subscript  O  4    subscript  O  6    subscript  O  8    otherwise    \begin{cases}\{O_{1},O_{2}\}\\
 \{O_{3},O_{5},O_{7},O_{9},O_{10}\}\\
 \{O_{4},O_{6},O_{8}\}\end{cases}     Definition of a rough set  Let    X  ⊆  𝕌      X  𝕌    X\subseteq\mathbb{U}   be a target set that we wish to represent using attribute subset   P   P   P   ; that is, we are told that an arbitrary set of objects   X   X   X   comprises a single class, and we wish to express this class (i.e., this subset) using the equivalence classes induced by attribute subset   P   P   P   . In general,   X   X   X   cannot be expressed exactly, because the set may include and exclude objects which are indistinguishable on the basis of attributes   P   P   P   .  For example, consider the target set    X  =   {   O  1   ,   O  2   ,   O  3   ,   O  4   }       X    subscript  O  1    subscript  O  2    subscript  O  3    subscript  O  4      X=\{O_{1},O_{2},O_{3},O_{4}\}   , and let attribute subset    P  =   {   P  1   ,   P  2   ,   P  3   ,   P  4   ,   P  5   }       P    subscript  P  1    subscript  P  2    subscript  P  3    subscript  P  4    subscript  P  5      P=\{P_{1},P_{2},P_{3},P_{4},P_{5}\}   , the full available set of features. It will be noted that the set   X   X   X   cannot be expressed exactly, because in      [  x  ]   P   ,     subscript   delimited-[]  x   P    [x]_{P},   , objects    {   O  3   ,   O  7   ,   O  10   }      subscript  O  3    subscript  O  7    subscript  O  10     \{O_{3},O_{7},O_{10}\}   are indiscernible. Thus, there is no way to represent any set   X   X   X   which includes     O  3     subscript  O  3    O_{3}   but excludes objects    O  7     subscript  O  7    O_{7}   and    O  10     subscript  O  10    O_{10}   .  However, the target set   X   X   X   can be approximated using only the information contained within   P   P   P   by constructing the   P   P   P   -lower and   P   P   P   -upper approximations of   X   X   X   :        P  ¯   X   =   {  x  ∣     [  x  ]   P   ⊆  X   }          normal-¯  P   X    conditional-set  x     subscript   delimited-[]  x   P   X      {\underline{P}}X=\{x\mid[x]_{P}\subseteq X\}           P  ¯   X   =   {  x  ∣      [  x  ]   P   ∩  X   ≠  ∅   }          normal-¯  P   X    conditional-set  x       subscript   delimited-[]  x   P   X        {\overline{P}}X=\{x\mid[x]_{P}\cap X\neq\emptyset\}     Lower approximation and positive region  The   P   P   P    -lower approximation , or positive region , is the union of all equivalence classes in     [  x  ]   P     subscript   delimited-[]  x   P    [x]_{P}   which are contained by (i.e., are subsets of) the target set – in the example,      P  ¯   X   =    {   O  1   ,   O  2   }   ∪   {   O  4   }           normal-¯  P   X       subscript  O  1    subscript  O  2      subscript  O  4       {\underline{P}}X=\{O_{1},O_{2}\}\cup\{O_{4}\}   , the union of the two equivalence classes in     [  x  ]   P     subscript   delimited-[]  x   P    [x]_{P}   which are contained in the target set. The lower approximation is the complete set of objects in    𝕌  /  P      𝕌  P    \mathbb{U}/P   that can be positively (i.e., unambiguously) classified as belonging to target set   X   X   X   .  Upper approximation and negative region  The   P   P   P    -upper approximation is the union of all equivalence classes in     [  x  ]   P     subscript   delimited-[]  x   P    [x]_{P}   which have non-empty intersection with the target set – in the example,      P  ¯   X   =    {   O  1   ,   O  2   }   ∪   {   O  4   }   ∪   {   O  3   ,   O  7   ,   O  10   }           normal-¯  P   X       subscript  O  1    subscript  O  2      subscript  O  4      subscript  O  3    subscript  O  7    subscript  O  10       {\overline{P}}X=\{O_{1},O_{2}\}\cup\{O_{4}\}\cup\{O_{3},O_{7},O_{10}\}   , the union of the three equivalence classes in     [  x  ]   P     subscript   delimited-[]  x   P    [x]_{P}   that have non-empty intersection with the target set. The upper approximation is the complete set of objects that in    𝕌  /  P      𝕌  P    \mathbb{U}/P   that cannot be positively (i.e., unambiguously) classified as belonging to the complement (    X  ¯     normal-¯  X    \overline{X}   ) of the target set   X   X   X   . In other words, the upper approximation is the complete set of objects that are possibly members of the target set   X   X   X   .  The set    𝕌  -    P  ¯   X       𝕌     normal-¯  P   X     \mathbb{U}-{\overline{P}}X   therefore represents the negative region , containing the set of objects that can be definitely ruled out as members of the target set.  Boundary region  The boundary region , given by set difference      P  ¯   X   -    P  ¯   X          normal-¯  P   X      normal-¯  P   X     {\overline{P}}X-{\underline{P}}X   , consists of those objects that can neither be ruled in nor ruled out as members of the target set   X   X   X   .  In summary, the lower approximation of a target set is a conservative approximation consisting of only those objects which can positively be identified as members of the set. (These objects have no indiscernible "clones" which are excluded by the target set.) The upper approximation is a liberal approximation which includes all objects that might be members of target set. (Some objects in the upper approximation may not be members of the target set.) From the perspective of    𝕌  /  P      𝕌  P    \mathbb{U}/P   , the lower approximation contains objects that are members of the target set with certainty (probability = 1), while the upper approximation contains objects that are members of the target set with non-zero probability (probability > 0).  The rough set  The tuple    ⟨    P  ¯   X   ,    P  ¯   X   ⟩        normal-¯  P   X      normal-¯  P   X     \langle{\underline{P}}X,{\overline{P}}X\rangle   composed of the lower and upper approximation is called a rough set ; thus, a rough set is composed of two crisp sets, one representing a lower boundary of the target set   X   X   X   , and the other representing an upper boundary of the target set   X   X   X   .  The accuracy of the rough-set representation of the set   X   X   X   can be given (Pawlak 1991) by the following:        α  P    (  X  )    =    |    P  ¯   X   |    |    P  ¯   X   |           subscript  α  P   X          normal-¯  P   X         normal-¯  P   X       \alpha_{P}(X)=\frac{\left|{\underline{P}}X\right|}{\left|{\overline{P}}X\right|}     That is, the accuracy of the rough set representation of   X   X   X   ,     α  P    (  X  )        subscript  α  P   X    \alpha_{P}(X)   ,    0  ≤    α  P    (  X  )    ≤  1        0     subscript  α  P   X        1     0\leq\alpha_{P}(X)\leq 1   , is the ratio of the number of objects which can positively be placed in   X   X   X   to the number of objects that can possibly be placed in   X   X   X   – this provides a measure of how closely the rough set is approximating the target set. Clearly, when the upper and lower approximations are equal (i.e., boundary region empty), then      α  P    (  X  )    =  1         subscript  α  P   X   1    \alpha_{P}(X)=1   , and the approximation is perfect; at the other extreme, whenever the lower approximation is empty, the accuracy is zero (regardless of the size of the upper approximation).  Objective analysis  Rough set theory is one of many methods that can be employed to analyse uncertain (including vague) systems, although less common than more traditional methods of probability , statistics , entropy and Dempster–Shafer theory . However a key difference, and a unique strength, of using classical rough set theory is that it provides an objective form of analysis (Pawlak et al. 1995). Unlike other methods, as those given above, classical rough set analysis requires no additional information, external parameters, models, functions, grades or subjective interpretations to determine set membership – instead it only uses the information presented within the given data (Düntsch and Gediga 1995). More recent adaptations of rough set theory, such as dominance-based, decision-theoretic and fuzzy rough sets, have introduced more subjectivity to the analysis.  Definability  In general, the upper and lower approximations are not equal; in such cases, we say that target set   X   X   X   is undefinable or roughly definable on attribute set   P   P   P   . When the upper and lower approximations are equal (i.e., the boundary is empty),      P  ¯   X   =    P  ¯   X          normal-¯  P   X      normal-¯  P   X     {\overline{P}}X={\underline{P}}X   , then the target set   X   X   X   is definable on attribute set   P   P   P   . We can distinguish the following special cases of undefinability:   Set   X   X   X   is internally undefinable if      P  ¯   X   ≠  ∅         normal-¯  P   X      {\underline{P}}X\neq\emptyset   and      P  ¯   X   =  𝕌         normal-¯  P   X   𝕌    {\overline{P}}X=\mathbb{U}   . This means that on attribute set   P   P   P   , there are objects which we can be certain belong to target set   X   X   X   , but there are no objects which we can definitively exclude from set   X   X   X   .    Set   X   X   X   is externally undefinable if      P  ¯   X   =  ∅         normal-¯  P   X      {\underline{P}}X=\emptyset   and      P  ¯   X   ≠  𝕌         normal-¯  P   X   𝕌    {\overline{P}}X\neq\mathbb{U}   . This means that on attribute set   P   P   P   , there are no objects which we can be certain belong to target set   X   X   X   , but there are objects which we can definitively exclude from set   X   X   X   .    Set   X   X   X   is totally undefinable if      P  ¯   X   =  ∅         normal-¯  P   X      {\underline{P}}X=\emptyset   and      P  ¯   X   =  𝕌         normal-¯  P   X   𝕌    {\overline{P}}X=\mathbb{U}   . This means that on attribute set   P   P   P   , there are no objects which we can be certain belong to target set   X   X   X   , and there are no objects which we can definitively exclude from set   X   X   X   . Thus, on attribute set   P   P   P   , we cannot decide whether any object is, or is not, a member of   X   X   X   .   Reduct and core  An interesting question is whether there are attributes in the information system (attribute-value table) which are more important to the knowledge represented in the equivalence class structure than other attributes. Often, we wonder whether there is a subset of attributes which can, by itself, fully characterize the knowledge in the database; such an attribute set is called a reduct .  Formally, a reduct is a subset of attributes    RED  ⊆  P      RED  P    \mathrm{RED}\subseteq P   such that        [  x  ]   RED     subscript   delimited-[]  x   RED    [x]_{\mathrm{RED}}   =     [  x  ]   P     subscript   delimited-[]  x   P    [x]_{P}   , that is, the equivalence classes induced by the reduced attribute set   RED   RED   \mathrm{RED}   are the same as the equivalence class structure induced by the full attribute set   P   P   P   .    the attribute set   RED   RED   \mathrm{RED}   is minimal , in the sense that      [  x  ]    (   RED  -   {  a  }    )    ≠    [  x  ]   P        subscript   delimited-[]  x     RED   a      subscript   delimited-[]  x   P     [x]_{(\mathrm{RED}-\{a\})}\neq[x]_{P}   for any attribute    a  ∈  RED      a  RED    a\in\mathrm{RED}   ; in other words, no attribute can be removed from set   RED   RED   \mathrm{RED}   without changing the equivalence classes     [  x  ]   P     subscript   delimited-[]  x   P    [x]_{P}   .   A reduct can be thought of as a sufficient set of features – sufficient, that is, to represent the category structure. In the example table above, attribute set    {   P  3   ,   P  4   ,   P  5   }      subscript  P  3    subscript  P  4    subscript  P  5     \{P_{3},P_{4},P_{5}\}   is a reduct – the information system projected on just these attributes possesses the same equivalence class structure as that expressed by the full attribute set:      {      {   O  1   ,   O  2   }         {   O  3   ,   O  7   ,   O  10   }         {   O  4   }         {   O  5   }         {   O  6   }         {   O  8   }         {   O  9   }          cases    subscript  O  1    subscript  O  2    otherwise    subscript  O  3    subscript  O  7    subscript  O  10    otherwise    subscript  O  4    otherwise    subscript  O  5    otherwise    subscript  O  6    otherwise    subscript  O  8    otherwise    subscript  O  9    otherwise    \begin{cases}\{O_{1},O_{2}\}\\
 \{O_{3},O_{7},O_{10}\}\\
 \{O_{4}\}\\
 \{O_{5}\}\\
 \{O_{6}\}\\
 \{O_{8}\}\\
 \{O_{9}\}\end{cases}     Attribute set    {   P  3   ,   P  4   ,   P  5   }      subscript  P  3    subscript  P  4    subscript  P  5     \{P_{3},P_{4},P_{5}\}   is a legitimate reduct because eliminating any of these attributes causes a collapse of the equivalence-class structure, with the result that      [  x  ]   RED   ≠    [  x  ]   P        subscript   delimited-[]  x   RED    subscript   delimited-[]  x   P     [x]_{\mathrm{RED}}\neq[x]_{P}   .  The reduct of an information system is not unique : there may be many subsets of attributes which preserve the equivalence-class structure (i.e., the knowledge) expressed in the information system. In the example information system above, another reduct is    {   P  1   ,   P  2   ,   P  5   }      subscript  P  1    subscript  P  2    subscript  P  5     \{P_{1},P_{2},P_{5}\}   , producing the same equivalence-class structure as     [  x  ]   P     subscript   delimited-[]  x   P    [x]_{P}   .  The set of attributes which is common to all reducts is called the core : the core is the set of attributes which is possessed by every legitimate reduct, and therefore consists of attributes which cannot be removed from the information system without causing collapse of the equivalence-class structure. The core may be thought of as the set of necessary attributes – necessary, that is, for the category structure to be represented. In the example, the only such attribute is    {   P  5   }      subscript  P  5     \{P_{5}\}   ; any one of the other attributes can be removed singly without damaging the equivalence-class structure, and hence these are all dispensable . However, removing    {   P  5   }      subscript  P  5     \{P_{5}\}   by itself does change the equivalence-class structure, and thus    {   P  5   }      subscript  P  5     \{P_{5}\}   is the indispensable attribute of this information system, and hence the core.  It is possible for the core to be empty, which means that there is no indispensable attribute: any single attribute in such an information system can be deleted without altering the equivalence-class structure. In such cases, there is no essential or necessary attribute which is required for the class structure to be represented.  Attribute dependency  One of the most important aspects of database analysis or data acquisition is the discovery of attribute dependencies; that is, we wish to discover which variables are strongly related to which other variables. Generally, it is these strong relationships that will warrant further investigation, and that will ultimately be of use in predictive modeling.  In rough set theory, the notion of dependency is defined very simply. Let us take two (disjoint) sets of attributes, set   P   P   P   and set   Q   Q   Q   , and inquire what degree of dependency obtains between them. Each attribute set induces an (indiscernibility) equivalence class structure, the equivalence classes induced by   P   P   P   given by     [  x  ]   P     subscript   delimited-[]  x   P    [x]_{P}   , and the equivalence classes induced by   Q   Q   Q   given by     [  x  ]   Q     subscript   delimited-[]  x   Q    [x]_{Q}   .  Let      [  x  ]   Q   =   {   Q  1   ,   Q  2   ,   Q  3   ,  …  ,   Q  N   }        subscript   delimited-[]  x   Q     subscript  Q  1    subscript  Q  2    subscript  Q  3   normal-…   subscript  Q  N      [x]_{Q}=\{Q_{1},Q_{2},Q_{3},\dots,Q_{N}\}   , where    Q  i     subscript  Q  i    Q_{i}   is a given equivalence class from the equivalence-class structure induced by attribute set   Q   Q   Q   . Then, the dependency of attribute set   Q   Q   Q   on attribute set   P   P   P   ,     γ  P    (  Q  )        subscript  γ  P   Q    \gamma_{P}(Q)   , is given by        γ  P    (  Q  )    =     ∑   i  =  1   N    |    P  ¯    Q  i    |     |  𝕌  |    ≤  1           subscript  γ  P   Q       superscript   subscript     i  1    N        normal-¯  P    subscript  Q  i        𝕌         1     \gamma_{P}(Q)=\frac{\sum_{i=1}^{N}\left|{\underline{P}}Q_{i}\right|}{\left|%
 \mathbb{U}\right|}\leq 1     That is, for each equivalence class    Q  i     subscript  Q  i    Q_{i}   in     [  x  ]   Q     subscript   delimited-[]  x   Q    [x]_{Q}   , we add up the size of its lower approximation by the attributes in   P   P   P   , i.e.,     P  ¯    Q  i        normal-¯  P    subscript  Q  i     {\underline{P}}Q_{i}   . This approximation (as above, for arbitrary set   X   X   X   ) is the number of objects which on attribute set   P   P   P   can be positively identified as belonging to target set    Q  i     subscript  Q  i    Q_{i}   . Added across all equivalence classes in     [  x  ]   Q     subscript   delimited-[]  x   Q    [x]_{Q}   , the numerator above represents the total number of objects which – based on attribute set   P   P   P   – can be positively categorized according to the classification induced by attributes   Q   Q   Q   . The dependency ratio therefore expresses the proportion (within the entire universe) of such classifiable objects. The dependency     γ  P    (  Q  )        subscript  γ  P   Q    \gamma_{P}(Q)   "can be interpreted as a proportion of such objects in the information system for which it suffices to know the values of attributes in   P   P   P   to determine the values of attributes in   Q   Q   Q   ".  Another, intuitive, way to consider dependency is to take the partition induced by Q as the target class C, and consider P as the attribute set we wish to use in order to "re-construct" the target class C. If P can completely reconstruct C, then Q depends totally upon P; if P results in a poor and perhaps a random reconstruction of C, then Q does not depend upon P at all.  Thus, this measure of dependency expresses the degree of functional (i.e., deterministic) dependency of attribute set   Q   Q   Q   on attribute set   P   P   P   ; it is not symmetric. The relationship of this notion of attribute dependency to more traditional information-theoretic (i.e., entropic) notions of attribute dependence has been discussed in a number of sources (e.g., Pawlak, Wong, & Ziarko 1988; Yao & Yao 2002; Wong, Ziarko, & Ye 1986, Quafafou & Boussouf 2000).  Rule extraction  The category representations discussed above are all extensional in nature; that is, a category or complex class is simply the sum of all its members. To represent a category is, then, just to be able to list or identify all the objects belonging to that category. However, extensional category representations have very limited practical use, because they provide no insight for deciding whether novel (never-before-seen) objects are members of the category.  What is generally desired is an intentional description of the category, a representation of the category based on a set of rules that describe the scope of the category. The choice of such rules is not unique, and therein lies the issue of inductive bias . See Version space and Model selection for more about this issue.  There are a few rule-extraction methods. We will start from a rule-extraction procedure based on Ziarko & Shan (1995).  Decision matrices  Let us say that we wish to find the minimal set of consistent rules ( logical implications ) that characterize our sample system. For a set of condition attributes    𝒫  =   {   P  1   ,   P  2   ,   P  3   ,  …  ,   P  n   }       𝒫    subscript  P  1    subscript  P  2    subscript  P  3   normal-…   subscript  P  n      \mathcal{P}=\{P_{1},P_{2},P_{3},\dots,P_{n}\}   and a decision attribute     Q  ,  Q   ∉  𝒫       Q  Q   𝒫    Q,Q\notin\mathcal{P}   , these rules should have the form      P  i  a    P  j  b   …   P  k  c    →   Q  d      normal-→     superscript   subscript  P  i   a    superscript   subscript  P  j   b   normal-…   superscript   subscript  P  k   c     superscript  Q  d     P_{i}^{a}P_{j}^{b}\dots P_{k}^{c}\to Q^{d}   , or, spelled out,       (   P  i   =  a  )   and   (   P  j   =  b  )   and  …  and   (   P  k   =  c  )   →   (  Q  =  d  )      fragments   fragments  normal-(   subscript  P  i    a  normal-)   and   fragments  normal-(   subscript  P  j    b  normal-)   and  normal-…  and   fragments  normal-(   subscript  P  k    c  normal-)   normal-→   fragments  normal-(  Q   d  normal-)     (P_{i}=a)\and(P_{j}=b)\and\dots\and(P_{k}=c)\to(Q=d)     where    {  a  ,  b  ,  c  ,  …  }     a  b  c  normal-…    \{a,b,c,\dots\}   are legitimate values from the domains of their respective attributes. This is a form typical of association rules , and the number of items in   𝕌   𝕌   \mathbb{U}   which match the condition/antecedent is called the support for the rule. The method for extracting such rules given in  is to form a decision matrix corresponding to each individual value   d   d   d   of decision attribute   Q   Q   Q   . Informally, the decision matrix for value   d   d   d   of decision attribute   Q   Q   Q   lists all attribute–value pairs that differ between objects having    Q  =  d      Q  d    Q=d   and    Q  ≠  d      Q  d    Q\neq d   .  This is best explained by example (which also avoids a lot of notation). Consider the table above, and let    P  4     subscript  P  4    P_{4}   be the decision variable (i.e., the variable on the right side of the implications) and let    {   P  1   ,   P  2   ,   P  3   }      subscript  P  1    subscript  P  2    subscript  P  3     \{P_{1},P_{2},P_{3}\}   be the condition variables (on the left side of the implication). We note that the decision variable    P  4     subscript  P  4    P_{4}   takes on two different values, namely    {  1  ,  2  }     1  2    \{1,2\}   . We treat each case separately.  First, we look at the case     P  4   =  1       subscript  P  4   1    P_{4}=1   , and we divide up   𝕌   𝕌   \mathbb{U}   into objects that have     P  4   =  1       subscript  P  4   1    P_{4}=1   and those that have     P  4   ≠  1       subscript  P  4   1    P_{4}\neq 1   . (Note that objects with     P  4   ≠  1       subscript  P  4   1    P_{4}\neq 1   in this case are simply the objects that have     P  4   =  2       subscript  P  4   2    P_{4}=2   , but in general,     P  4   ≠  1       subscript  P  4   1    P_{4}\neq 1   would include all objects having any value for    P  4     subscript  P  4    P_{4}    other than      P  4   =  1       subscript  P  4   1    P_{4}=1   , and there may be several such classes of objects (for example, those having      P  4   =   2  ,  3  ,  4  ,   e  t  c     .       subscript  P  4    2  3  4    e  t  c      P_{4}=2,3,4,etc.   ).) In this case, the objects having     P  4   =  1       subscript  P  4   1    P_{4}=1   are    {   O  1   ,   O  2   ,   O  3   ,   O  7   ,   O  10   }      subscript  O  1    subscript  O  2    subscript  O  3    subscript  O  7    subscript  O  10     \{O_{1},O_{2},O_{3},O_{7},O_{10}\}   while the objects which have     P  4   ≠  1       subscript  P  4   1    P_{4}\neq 1   are    {   O  4   ,   O  5   ,   O  6   ,   O  8   ,   O  9   }      subscript  O  4    subscript  O  5    subscript  O  6    subscript  O  8    subscript  O  9     \{O_{4},O_{5},O_{6},O_{8},O_{9}\}   . The decision matrix for     P  4   =  1       subscript  P  4   1    P_{4}=1   lists all the differences between the objects having     P  4   =  1       subscript  P  4   1    P_{4}=1   and those having     P  4   ≠  1       subscript  P  4   1    P_{4}\neq 1   ; that is, the decision matrix lists all the differences between    {   O  1   ,   O  2   ,   O  3   ,   O  7   ,   O  10   }      subscript  O  1    subscript  O  2    subscript  O  3    subscript  O  7    subscript  O  10     \{O_{1},O_{2},O_{3},O_{7},O_{10}\}   and    {   O  4   ,   O  5   ,   O  6   ,   O  8   ,   O  9   }      subscript  O  4    subscript  O  5    subscript  O  6    subscript  O  8    subscript  O  9     \{O_{4},O_{5},O_{6},O_{8},O_{9}\}   . We put the "positive" objects (     P  4   =  1       subscript  P  4   1    P_{4}=1   ) as the rows, and the "negative" objects     P  4   ≠  1       subscript  P  4   1    P_{4}\neq 1   as the columns.        Decision matrix for     P  4   =  1       subscript  P  4   1    P_{4}=1      Object       O  4     subscript  O  4    O_{4}          O  5     subscript  O  5    O_{5}          O  6     subscript  O  6    O_{6}          O  8     subscript  O  8    O_{8}          O  9     subscript  O  9    O_{9}            O  1     subscript  O  1    O_{1}           P  1  1   ,   P  2  2   ,   P  3  0       superscript   subscript  P  1   1    superscript   subscript  P  2   2    superscript   subscript  P  3   0     P_{1}^{1},P_{2}^{2},P_{3}^{0}           P  1  1   ,   P  2  2       superscript   subscript  P  1   1    superscript   subscript  P  2   2     P_{1}^{1},P_{2}^{2}           P  1  1   ,   P  2  2   ,   P  3  0       superscript   subscript  P  1   1    superscript   subscript  P  2   2    superscript   subscript  P  3   0     P_{1}^{1},P_{2}^{2},P_{3}^{0}           P  1  1   ,   P  2  2   ,   P  3  0       superscript   subscript  P  1   1    superscript   subscript  P  2   2    superscript   subscript  P  3   0     P_{1}^{1},P_{2}^{2},P_{3}^{0}           P  1  1   ,   P  2  2       superscript   subscript  P  1   1    superscript   subscript  P  2   2     P_{1}^{1},P_{2}^{2}            O  2     subscript  O  2    O_{2}           P  1  1   ,   P  2  2   ,   P  3  0       superscript   subscript  P  1   1    superscript   subscript  P  2   2    superscript   subscript  P  3   0     P_{1}^{1},P_{2}^{2},P_{3}^{0}           P  1  1   ,   P  2  2       superscript   subscript  P  1   1    superscript   subscript  P  2   2     P_{1}^{1},P_{2}^{2}           P  1  1   ,   P  2  2   ,   P  3  0       superscript   subscript  P  1   1    superscript   subscript  P  2   2    superscript   subscript  P  3   0     P_{1}^{1},P_{2}^{2},P_{3}^{0}           P  1  1   ,   P  2  2   ,   P  3  0       superscript   subscript  P  1   1    superscript   subscript  P  2   2    superscript   subscript  P  3   0     P_{1}^{1},P_{2}^{2},P_{3}^{0}           P  1  1   ,   P  2  2       superscript   subscript  P  1   1    superscript   subscript  P  2   2     P_{1}^{1},P_{2}^{2}            O  3     subscript  O  3    O_{3}           P  1  2   ,   P  3  0       superscript   subscript  P  1   2    superscript   subscript  P  3   0     P_{1}^{2},P_{3}^{0}          P  2  0     superscript   subscript  P  2   0    P_{2}^{0}           P  1  2   ,   P  3  0       superscript   subscript  P  1   2    superscript   subscript  P  3   0     P_{1}^{2},P_{3}^{0}           P  1  2   ,   P  2  0   ,   P  3  0       superscript   subscript  P  1   2    superscript   subscript  P  2   0    superscript   subscript  P  3   0     P_{1}^{2},P_{2}^{0},P_{3}^{0}          P  2  0     superscript   subscript  P  2   0    P_{2}^{0}            O  7     subscript  O  7    O_{7}           P  1  2   ,   P  3  0       superscript   subscript  P  1   2    superscript   subscript  P  3   0     P_{1}^{2},P_{3}^{0}          P  2  0     superscript   subscript  P  2   0    P_{2}^{0}           P  1  2   ,   P  3  0       superscript   subscript  P  1   2    superscript   subscript  P  3   0     P_{1}^{2},P_{3}^{0}           P  1  2   ,   P  2  0   ,   P  3  0       superscript   subscript  P  1   2    superscript   subscript  P  2   0    superscript   subscript  P  3   0     P_{1}^{2},P_{2}^{0},P_{3}^{0}          P  2  0     superscript   subscript  P  2   0    P_{2}^{0}            O  10     subscript  O  10    O_{10}           P  1  2   ,   P  3  0       superscript   subscript  P  1   2    superscript   subscript  P  3   0     P_{1}^{2},P_{3}^{0}          P  2  0     superscript   subscript  P  2   0    P_{2}^{0}           P  1  2   ,   P  3  0       superscript   subscript  P  1   2    superscript   subscript  P  3   0     P_{1}^{2},P_{3}^{0}           P  1  2   ,   P  2  0   ,   P  3  0       superscript   subscript  P  1   2    superscript   subscript  P  2   0    superscript   subscript  P  3   0     P_{1}^{2},P_{2}^{0},P_{3}^{0}          P  2  0     superscript   subscript  P  2   0    P_{2}^{0}          To read this decision matrix, look, for example, at the intersection of row    O  3     subscript  O  3    O_{3}   and column    O  6     subscript  O  6    O_{6}   , showing     P  1  2   ,   P  3  0       superscript   subscript  P  1   2    superscript   subscript  P  3   0     P_{1}^{2},P_{3}^{0}   in the cell. This means that with regard to decision value     P  4   =  1       subscript  P  4   1    P_{4}=1   , object    O  3     subscript  O  3    O_{3}   differs from object    O  6     subscript  O  6    O_{6}   on attributes    P  1     subscript  P  1    P_{1}   and    P  3     subscript  P  3    P_{3}   , and the particular values on these attributes for the positive object    O  3     subscript  O  3    O_{3}   are     P  1   =  2       subscript  P  1   2    P_{1}=2   and     P  3   =  0       subscript  P  3   0    P_{3}=0   . This tells us that the correct classification of    O  3     subscript  O  3    O_{3}   as belonging to decision class     P  4   =  1       subscript  P  4   1    P_{4}=1   rests on attributes    P  1     subscript  P  1    P_{1}   and    P  3     subscript  P  3    P_{3}   ; although one or the other might be dispensable, we know that at least one of these attributes is in dispensable.  Next, from each decision matrix we form a set of Boolean expressions, one expression for each row of the matrix. The items within each cell are aggregated disjunctively, and the individuals cells are then aggregated conjunctively. Thus, for the above table we have the following five Boolean expressions:      {       (    P  1  1    P  2  2    P  3  0    )   and   (    P  1  1    P  2  2    )   and   (    P  1  1    P  2  2    P  3  0    )   and   (    P  1  1    P  2  2    P  3  0    )   and   (    P  1  1    P  2  2    )           (    P  1  1    P  2  2    P  3  0    )   and   (    P  1  1    P  2  2    )   and   (    P  1  1    P  2  2    P  3  0    )   and   (    P  1  1    P  2  2    P  3  0    )   and   (    P  1  1    P  2  2    )           (    P  1  2    P  3  0    )   and   (   P  2  0   )   and   (    P  1  2    P  3  0    )   and   (    P  1  2    P  2  0    P  3  0    )   and   (   P  2  0   )           (    P  1  2    P  3  0    )   and   (   P  2  0   )   and   (    P  1  2    P  3  0    )   and   (    P  1  2    P  2  0    P  3  0    )   and   (   P  2  0   )           (    P  1  2    P  3  0    )   and   (   P  2  0   )   and   (    P  1  2    P  3  0    )   and   (    P  1  2    P  2  0    P  3  0    )   and   (   P  2  0   )           cases       superscript   subscript  P  1   1    superscript   subscript  P  2   2    superscript   subscript  P  3   0    italic- and     superscript   subscript  P  1   1    superscript   subscript  P  2   2    italic- and     superscript   subscript  P  1   1    superscript   subscript  P  2   2    superscript   subscript  P  3   0    italic- and     superscript   subscript  P  1   1    superscript   subscript  P  2   2    superscript   subscript  P  3   0    italic- and     superscript   subscript  P  1   1    superscript   subscript  P  2   2     otherwise       superscript   subscript  P  1   1    superscript   subscript  P  2   2    superscript   subscript  P  3   0    italic- and     superscript   subscript  P  1   1    superscript   subscript  P  2   2    italic- and     superscript   subscript  P  1   1    superscript   subscript  P  2   2    superscript   subscript  P  3   0    italic- and     superscript   subscript  P  1   1    superscript   subscript  P  2   2    superscript   subscript  P  3   0    italic- and     superscript   subscript  P  1   1    superscript   subscript  P  2   2     otherwise       superscript   subscript  P  1   2    superscript   subscript  P  3   0    italic- and   superscript   subscript  P  2   0   italic- and     superscript   subscript  P  1   2    superscript   subscript  P  3   0    italic- and     superscript   subscript  P  1   2    superscript   subscript  P  2   0    superscript   subscript  P  3   0    italic- and   superscript   subscript  P  2   0    otherwise       superscript   subscript  P  1   2    superscript   subscript  P  3   0    italic- and   superscript   subscript  P  2   0   italic- and     superscript   subscript  P  1   2    superscript   subscript  P  3   0    italic- and     superscript   subscript  P  1   2    superscript   subscript  P  2   0    superscript   subscript  P  3   0    italic- and   superscript   subscript  P  2   0    otherwise       superscript   subscript  P  1   2    superscript   subscript  P  3   0    italic- and   superscript   subscript  P  2   0   italic- and     superscript   subscript  P  1   2    superscript   subscript  P  3   0    italic- and     superscript   subscript  P  1   2    superscript   subscript  P  2   0    superscript   subscript  P  3   0    italic- and   superscript   subscript  P  2   0    otherwise    \begin{cases}(P_{1}^{1}P_{2}^{2}P_{3}^{0})\and(P_{1}^{1}P_{2}^{2})\and(P_{1}^{%
 1}P_{2}^{2}P_{3}^{0})\and(P_{1}^{1}P_{2}^{2}P_{3}^{0})\and(P_{1}^{1}P_{2}^{2})%
 \\
 (P_{1}^{1}P_{2}^{2}P_{3}^{0})\and(P_{1}^{1}P_{2}^{2})\and(P_{1}^{1}P_{2}^{2}P_%
 {3}^{0})\and(P_{1}^{1}P_{2}^{2}P_{3}^{0})\and(P_{1}^{1}P_{2}^{2})\\
 (P_{1}^{2}P_{3}^{0})\and(P_{2}^{0})\and(P_{1}^{2}P_{3}^{0})\and(P_{1}^{2}P_{2}%
 ^{0}P_{3}^{0})\and(P_{2}^{0})\\
 (P_{1}^{2}P_{3}^{0})\and(P_{2}^{0})\and(P_{1}^{2}P_{3}^{0})\and(P_{1}^{2}P_{2}%
 ^{0}P_{3}^{0})\and(P_{2}^{0})\\
 (P_{1}^{2}P_{3}^{0})\and(P_{2}^{0})\and(P_{1}^{2}P_{3}^{0})\and(P_{1}^{2}P_{2}%
 ^{0}P_{3}^{0})\and(P_{2}^{0})\end{cases}     Each statement here is essentially a highly specific (probably too specific) rule governing the membership in class     P  4   =  1       subscript  P  4   1    P_{4}=1   of the corresponding object. For example, the last statement, corresponding to object    O  10     subscript  O  10    O_{10}   , states that all the following must be satisfied:   Either    P  1     subscript  P  1    P_{1}   must have value 2, or    P  3     subscript  P  3    P_{3}   must have value 0, or both.      P  2     subscript  P  2    P_{2}   must have value 0.  Either    P  1     subscript  P  1    P_{1}   must have value 2, or    P  3     subscript  P  3    P_{3}   must have value 0, or both.  Either    P  1     subscript  P  1    P_{1}   must have value 2, or    P  2     subscript  P  2    P_{2}   must have value 0, or    P  3     subscript  P  3    P_{3}   must have value 0, or any combination thereof.      P  2     subscript  P  2    P_{2}   must have value 0.   It is clear that there is a large amount of redundancy here, and the next step is to simplify using traditional Boolean algebra . The statement     (    P  1  1    P  2  2    P  3  0    )   and   (    P  1  1    P  2  2    )   and   (    P  1  1    P  2  2    P  3  0    )   and   (    P  1  1    P  2  2    P  3  0    )   and   (    P  1  1    P  2  2    )          superscript   subscript  P  1   1    superscript   subscript  P  2   2    superscript   subscript  P  3   0    italic- and     superscript   subscript  P  1   1    superscript   subscript  P  2   2    italic- and     superscript   subscript  P  1   1    superscript   subscript  P  2   2    superscript   subscript  P  3   0    italic- and     superscript   subscript  P  1   1    superscript   subscript  P  2   2    superscript   subscript  P  3   0    italic- and     superscript   subscript  P  1   1    superscript   subscript  P  2   2      (P_{1}^{1}P_{2}^{2}P_{3}^{0})\and(P_{1}^{1}P_{2}^{2})\and(P_{1}^{1}P_{2}^{2}P_%
 {3}^{0})\and(P_{1}^{1}P_{2}^{2}P_{3}^{0})\and(P_{1}^{1}P_{2}^{2})   corresponding to objects    {   O  1   ,   O  2   }      subscript  O  1    subscript  O  2     \{O_{1},O_{2}\}   simplifies to     P  1  1    P  2  2        superscript   subscript  P  1   1    superscript   subscript  P  2   2     P_{1}^{1}P_{2}^{2}   , which yields the implication       (   P  1   =  1  )    (   P  2   =  2  )   →   (   P  4   =  1  )      fragments   fragments  normal-(   subscript  P  1    1  normal-)    fragments  normal-(   subscript  P  2    2  normal-)   normal-→   fragments  normal-(   subscript  P  4    1  normal-)     (P_{1}=1)(P_{2}=2)\to(P_{4}=1)     Likewise, the statement     (    P  1  2    P  3  0    )   and   (   P  2  0   )   and   (    P  1  2    P  3  0    )   and   (    P  1  2    P  2  0    P  3  0    )   and   (   P  2  0   )          superscript   subscript  P  1   2    superscript   subscript  P  3   0    italic- and   superscript   subscript  P  2   0   italic- and     superscript   subscript  P  1   2    superscript   subscript  P  3   0    italic- and     superscript   subscript  P  1   2    superscript   subscript  P  2   0    superscript   subscript  P  3   0    italic- and   superscript   subscript  P  2   0     (P_{1}^{2}P_{3}^{0})\and(P_{2}^{0})\and(P_{1}^{2}P_{3}^{0})\and(P_{1}^{2}P_{2}%
 ^{0}P_{3}^{0})\and(P_{2}^{0})   corresponding to objects    {   O  3   ,   O  7   ,   O  10   }      subscript  O  3    subscript  O  7    subscript  O  10     \{O_{3},O_{7},O_{10}\}   simplifies to     P  1  2    P  2  0    P  3  0    P  2  0        superscript   subscript  P  1   2    superscript   subscript  P  2   0    superscript   subscript  P  3   0    superscript   subscript  P  2   0     P_{1}^{2}P_{2}^{0}P_{3}^{0}P_{2}^{0}   . This gives us the implication       (   P  1   =  2  and   P  2   =  0  )    (   P  3   =  0  and   P  2   =  0  )   →   (   P  4   =  1  )      fragments   fragments  normal-(   subscript  P  1    2  and   subscript  P  2    0  normal-)    fragments  normal-(   subscript  P  3    0  and   subscript  P  2    0  normal-)   normal-→   fragments  normal-(   subscript  P  4    1  normal-)     (P_{1}=2\and P_{2}=0)(P_{3}=0\and P_{2}=0)\to(P_{4}=1)     The above implications can also be written as the following rule set:      {       (   P  1   =  1  )   →   (   P  4   =  1  )           (   P  2   =  2  )   →   (   P  4   =  1  )           (   P  1   =  2  )   and   (   P  2   =  0  )   →   (   P  4   =  1  )           (   P  3   =  0  )   and   (   P  2   =  0  )   →   (   P  4   =  1  )           cases   fragments   fragments  normal-(   subscript  P  1    1  normal-)   normal-→   fragments  normal-(   subscript  P  4    1  normal-)    otherwise   fragments   fragments  normal-(   subscript  P  2    2  normal-)   normal-→   fragments  normal-(   subscript  P  4    1  normal-)    otherwise   fragments   fragments  normal-(   subscript  P  1    2  normal-)   and   fragments  normal-(   subscript  P  2    0  normal-)   normal-→   fragments  normal-(   subscript  P  4    1  normal-)    otherwise   fragments   fragments  normal-(   subscript  P  3    0  normal-)   and   fragments  normal-(   subscript  P  2    0  normal-)   normal-→   fragments  normal-(   subscript  P  4    1  normal-)    otherwise    \begin{cases}(P_{1}=1)\to(P_{4}=1)\\
 (P_{2}=2)\to(P_{4}=1)\\
 (P_{1}=2)\and(P_{2}=0)\to(P_{4}=1)\\
 (P_{3}=0)\and(P_{2}=0)\to(P_{4}=1)\end{cases}     It can be noted that each of the first two rules has a support of 1 (i.e., the antecedent matches two objects), while each of the last two rules has a support of 2. To finish writing the rule set for this knowledge system, the same procedure as above (starting with writing a new decision matrix) should be followed for the case of     P  4   =  2       subscript  P  4   2    P_{4}=2   , thus yielding a new set of implications for that decision value (i.e., a set of implications with     P  4   =  2       subscript  P  4   2    P_{4}=2   as the consequent). In general, the procedure will be repeated for each possible value of the decision variable.  LERS rule induction system  The data system LERS (Learning from Examples based on Rough Sets) Grzymala-Busse (1997) may induce rules from inconsistent data, i.e., data with conflicting objects. Two objects are conflicting when they are characterized by the same values of all attributes, but they belong to different concepts (classes). LERS uses rough set theory to compute lower and upper approximations for concepts involved in conflicts with other concepts.  Rules induced from the lower approximation of the concept certainly describe the concept, hence such rules are called certain . On the other hand, rules induced from the upper approximation of the concept describe the concept possibly , so these rules are called possible . For rule induction LERS uses three algorithms: LEM1, LEM2, and IRIM.  The LEM2 algorithm of LERS is frequently used for rule induction and is used not only in LERS but also in other systems, e.g., in RSES (Bazan et al. (2004). LEM2 explores the search space of attribute-value pairs . Its input data set is a lower or upper approximation of a concept, so its input data set is always consistent. In general, LEM2 computes a local covering and then converts it into a rule set. We will quote a few definitions to describe the LEM2 algorithm.  The LEM2 algorithm is based on an idea of an attribute-value pair block. Let   X   X   X   be a nonempty lower or upper approximation of a concept represented by a decision-value pair    (  d  ,  w  )     d  w    (d,w)   . Set   X   X   X    depends on a set   T   T   T   of attribute-value pairs    t  =   (  a  ,  v  )       t   a  v     t=(a,v)   if and only if       ∅  ≠   [  T  ]   =    ⋂   t  ∈  T     [  t  ]    ⊆  X   .          delimited-[]  T          subscript     t  T     delimited-[]  t         X     \emptyset\neq[T]=\bigcap_{t\in T}[t]\subseteq X.     Set   T   T   T   is a minimal complex of   X   X   X   if and only if   X   X   X   depends on   T   T   T   and no proper subset   S   S   S   of   T   T   T   exists such that   X   X   X   depends on   S   S   S   . Let   𝕋   𝕋   \mathbb{T}   be a nonempty collection of nonempty sets of attribute-value pairs. Then   𝕋   𝕋   \mathbb{T}   is a local covering of   X   X   X   if and only if the following three conditions are satisfied:  each member   T   T   T   of   𝕋   𝕋   \mathbb{T}   is a minimal complex of   X   X   X   ,         ⋃   t  ∈  𝕋     [  T  ]    =  X   ,        subscript     t  𝕋     delimited-[]  T    X    \bigcup_{t\in\mathbb{T}}[T]=X,        𝕋   𝕋   \mathbb{T}   is minimal, i.e.,   𝕋   𝕋   \mathbb{T}   has the smallest possible number of members.  For our sample information system, LEM2 will induce the following rules:      {       (   P  1   ,  1  )   →   (   P  4   ,  1  )           (   P  5   ,  0  )   →   (   P  4   ,  1  )           (   P  1   ,  0  )   →   (   P  4   ,  2  )           (   P  2   ,  1  )   →   (   P  4   ,  2  )           cases   normal-→    subscript  P  1   1     subscript  P  4   1    otherwise   normal-→    subscript  P  5   0     subscript  P  4   1    otherwise   normal-→    subscript  P  1   0     subscript  P  4   2    otherwise   normal-→    subscript  P  2   1     subscript  P  4   2    otherwise    \begin{cases}(P_{1},1)\to(P_{4},1)\\
 (P_{5},0)\to(P_{4},1)\\
 (P_{1},0)\to(P_{4},2)\\
 (P_{2},1)\to(P_{4},2)\end{cases}     Other rule-learning methods can be found, e.g., in Pawlak (1991), Stefanowski (1998), Bazan et al. (2004), etc.  Incomplete data  Rough set theory is useful for rule induction from incomplete data sets. Using this approach we can distinguish between three types of missing attribute values: lost values (the values that were recorded but currently are unavailable), attribute-concept values (these missing attribute values may be replaced by any attribute value limited to the same concept), and "do not care" conditions (the original values were irrelevant). A concept ( class ) is a set of all objects classified (or diagnosed) the same way.  Two special data sets with missing attribute values were extensively studied: in the first case, all missing attribute values were lost (Stefanowski and Tsoukias, 2001), in the second case, all missing attribute values were "do not care" conditions (Kryszkiewicz, 1999).  In attribute-concept values interpretation of a missing attribute value, the missing attribute value may be replaced by any value of the attribute domain restricted to the concept to which the object with a missing attribute value belongs (Grzymala-Busse and Grzymala-Busse, 2007). For example, if for a patient the value of an attribute Temperature is missing, this patient is sick with flu, and all remaining patients sick with flu have values high or very-high for Temperature when using the interpretation of the missing attribute value as the attribute-concept value, we will replace the missing attribute value with high and very-high. Additionally, the characteristic relation , (see, e.g., Grzymala-Busse and Grzymala-Busse, 2007) enables to process data sets with all three kind of missing attribute values at the same time: lost, "do not care" conditions, and attribute-concept values.  Applications  Rough set methods can be applied as a component of hybrid solutions in machine learning and data mining . They have been found to be particularly useful for rule induction and feature selection (semantics-preserving dimensionality reduction). Rough set-based data analysis methods have been successfully applied in bioinformatics, economics and finance, medicine, multimedia, web and text mining, signal and image processing, software engineering, robotics, and engineering (e.g. power systems and control engineering). Recently the three regions of rough sets are interpreted as regions of acceptance, rejection and deferment. This leads to three-way decision making approach with the model which can potentially lead to interesting future applications.  History  The idea of rough set was proposed by Pawlak (1981) as a new mathematical tool to deal with vague concepts. Comer, Grzymala-Busse, Iwinski, Nieminen, Novotny, Pawlak, Obtulowicz, and Pomykala have studied algebraic properties of rough sets. Different algebraic semantics have been developed by P. Pagliani, I. Duntsch, M. K. Chakraborty, M. Banerjee and A. Mani; these have been extended to more generalized rough sets by D. Cattaneo and A. Mani, in particular. Rough sets can be used to represent ambiguity , vagueness and general uncertainty .  Extensions and generalizations  Since the development of rough sets, extensions and generalizations have continued to evolve. Initial developments focused on the relationship - both similarities and difference - with fuzzy sets . While some literature contends these concepts are different, other literature considers that rough sets are a generalization of fuzzy sets - as represented through either fuzzy rough sets or rough fuzzy sets. Pawlak (1995) considered that fuzzy and rough sets should be treated as being complimentary to each other, addressing different aspects of uncertainty and vagueness.  Three notable extensions of classical rough sets are:   Dominance-based rough set approach (DRSA) is an extension of rough set theory for multi-criteria decision analysis (MCDA), introduced by Greco, Matarazzo and Słowiński (2001). The main change in this extension of classical rough sets is the substitution of the indiscernibility relation by a dominance relation, which permits the formalism to deal with inconsistencies typical in consideration of criteria and preference-ordered decision classes.    Decision-theoretic rough sets (DTRS) is a probabilistic extension of rough set theory introduced by Yao, Wong, and Lingras (1990). It utilizes a Bayesian decision procedure for minimum risk decision making. Elements are included into the lower and upper approximations based on whether their conditional probability is above thresholds   α   α   \textstyle\alpha   and   β   β   \textstyle\beta   . These upper and lower thresholds determine region inclusion for elements. This model is unique and powerful since the thresholds themselves are calculated from a set of six loss functions representing classification risks.    Game-theoretic rough sets (GTRS) is a game theory-based extension of rough set that was introduced by Herbert and Yao (2011). It utilizes a game-theoretic environment to optimize certain criteria of rough sets based classification or decision making in order to obtain effective region sizes.   Rough membership  Rough sets can be also defined, as a generalisation, by employing a rough membership function instead of objective approximation. The rough membership function expresses a conditional probability that   x   x   x   belongs to   X   X   X   given    \R    \R   \textstyle\R   . This can be interpreted as a degree that   x   x   x   belongs to   X   X   X   in terms of information about   x   x   x   expressed by    \R    \R   \textstyle\R   .  Rough membership primarily differs from the fuzzy membership in that the membership of union and intersection of sets cannot, in general, be computed from their constituent membership as is the case of fuzzy sets. In this, rough membership is a generalization of fuzzy membership. Furthermore, the rough membership function is grounded more in probability than the conventionally held concepts of the fuzzy membership function.  Other generalizations  Several generalizations of rough sets have been introduced, studied and applied to solving problems. Here are some of these generalizations:   rough multisets (Grzymala-Busse, 1987)  fuzzy rough sets extend the rough set concept through the use of fuzzy equivalence classes(Nakamura, 1988)  Alpha rough set theory (α-RST) - a generalization of rough set theory that allows approximation using of fuzzy concepts (Quafafou, 2000)  intuitionistic fuzzy rough sets (Cornelis, De Cock and Kerre, 2003)  generalized rough fuzzy sets (Feng, 2010)  rough intuitionistic fuzzy sets (Thomas and Nair, 2011)  soft rough fuzzy sets and soft fuzzy rough sets (Meng, Zhang and Qin, 2011)  composite rough sets (Zhang, Li and Chen, 2014)   See also   Algebraic semantics  Alternative set theory  Analog computer  Description logic  Fuzzy logic  Fuzzy set theory  Generalized rough set theory  Granular computing  Near sets  Rough fuzzy hybridization  Semantics of rough set theory  Soft computing  Type-2 fuzzy sets and systems  Decision-theoretic rough sets  Variable precision rough set  Version space  Dominance-based rough set approach   References           Pawlak, Zdzisław Rough Sets Research Report PAS 431, Institute of Computer Science, Polish Academy of Sciences (1981)                Burgin M. (1990). Theory of Named Sets as a Foundational Basis for Mathematics, In Structures in mathematical theories: Reports of the San Sebastian international symposium, September 25-29, 1990 (http://www.blogg.org/blog-30140-date-2005-10-26.html)  Burgin, M. (2004). Unified Foundations of Mathematics, Preprint Mathematics LO/0403186, p39. (electronic edition: http://arxiv.org/ftp/math/papers/0403/0403186.pdf )  Burgin, M. (2011), Theory of Named Sets, Mathematics Research Developments, Nova Science Pub Inc, ISBN 978-1-61122-788-8  Cornelis, C., De Cock, M. and Kerre, E. (2003) Intuitionistic fuzzy rough sets: at the crossroads of imperfect knowledge, Expert Systems, 20:5, pp260–270  Düntsch, I. and Gediga, G. (1995) Rough Set Dependency Analysis in Evaluation Studies – An Application in the Study of Repeated Heart Attacks. University of Ulster, Informatics Research Reports No. 10  Feng F. (2010). Generalized Rough Fuzzy Sets Based on Soft Sets, Soft Computing, 14:9, pp 899-911  Grzymala-Busse, J. (1987). Learning from examples based on rough multisets, in Proceedings of the 2nd International Symposium on Methodologies for Intelligent Systems, pp. 325–332. Charlotte, NC, USA,  Meng, D., Zhang, X. and Qin, K. (2011). Soft rough fuzzy sets and soft fuzzy rough sets, Computers & Mathematics with Applications, 62:12, pp4635-4645  Quafafou M. (2000). α-RST: a generalization of rough set theory, Information Sciences, 124:1–4, pp301–316.  Quafafou M. and Boussouf M. (2000). Generalized rough sets based feature selection. Journal Intelligent Data Analysis, 4:1 pp3 - 17  Nakamura, A. (1988) Fuzzy rough sets, ‘Notes on Multiple-valued Logic in Japan’, 9:1, pp1-8  Pawlak, Z., Grzymala-Busse, J., Slowinski, R. Ziarko, W. (1995). Rough Sets. Communications of the ACM, 38:11, pp88-95  Thomas, K. and Nair, L. (2011). Rough intuitionistic fuzzy sets in a lattice, International Mathematical Forum, 6:27, pp1327-1335  Zhang J., Li T., Chen H. (2014). Composite rough sets for dynamic data mining, Information Sciences, 257, pp81-100   Further reading   Gianpiero Cattaneo and Davide Ciucci, "Heyting Wajsberg Algebras as an Abstract Environment Linking Fuzzy and Rough Sets" in J.J. Alpigini et al. (Eds.): RSCTC 2002, LNAI 2475, pp. 77–84, 2002.   External links   The International Rough Set Society  [ http://www.uit.edu.vn/forum/index.php?act=Attach&type; ;=post&id;=19757 Rough set tutorial]  Rough Sets: A Quick Tutorial  Rough Set Exploration System  Rough Sets in Data Warehousing   "  Category:Systems of set theory  Category:Theoretical computer science   