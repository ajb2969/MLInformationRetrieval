   Carry-skip adder      Carry-skip adder   A carry-skip adder (also known as a carry-bypass adder ) is an adder implementation that improves on the delay of a ripple-carry adder with little effort compared to other adders. The improvement of the worst-case delay is achieved by using several carry-skip adders to form a block-carry-skip adder.  Single carry-skip adder  The worst case for a carry-ripple-adder occurs, when the propagate-condition 1 is true for each digit pair    (   a  i   ,   b  i   )      subscript  a  i    subscript  b  i     (a_{i},b_{i})   . Then the carry-in ripples through the   n   n   n   -bit adder and appears as the carry-out after      τ   C  R  A     (  n  )    ≈   n  ⋅   τ   V  A            subscript  τ    C  R  A    n    normal-⋅  n   subscript  τ    V  A       \tau_{CRA}(n)\approx n\cdot\tau_{VA}   .  For each operand input bit pair    (   a  i   ,   b  i   )      subscript  a  i    subscript  b  i     (a_{i},b_{i})   the propagate-conditions     p  i   =    a  i   ⊕   b  i         subscript  p  i    direct-sum   subscript  a  i    subscript  b  i      p_{i}=a_{i}\oplus b_{i}   are determined using an XOR-Gate (see ). When all propagate-conditions are true , then the carry-in bit    c  0     subscript  c  0    c_{0}   determines the carry-out bit.  The n -bit-carry-skip adder consists of a n -bit-carry-ripple-chain, a n -input AND-gate and one multiplexer. Each propagate bit    p  i     subscript  p  i    p_{i}   , that is provided by the carry-ripple-chain is connected to the n -input AND-gate. The resulting bit is used as the select bit of a multiplexer that switches either the last carry-bit    c  n     subscript  c  n    c_{n}   or the carry-in    c  0     subscript  c  0    c_{0}   to the carry-out signal    c   o  u  t      subscript  c    o  u  t     c_{out}   .       s  =    p   n  -  1    ∧   p   n  -  2    ∧  …  ∧   p  1   ∧   p  0    =   p   [  0  :  n  -  1  ]          s     subscript  p    n  1     subscript  p    n  2    normal-…   subscript  p  1    subscript  p  0          subscript  p   fragments  normal-[  0  normal-:  n   1  normal-]       s=p_{n-1}\wedge p_{n-2}\wedge\dots\wedge p_{1}\wedge p_{0}=p_{[0:n-1]}      This greatly reduces the latency of the adder through its critical path, since the carry bit for each block can now "skip" over blocks with a group propagate signal set to logic 1 (as opposed to a long ripple-carry chain, which would require the carry to ripple through each bit in the adder). The number of inputs of the AND-gate is equal to the width of the adder. For a large width, this becomes impractical and leads to additional delays, because the AND-gate has to be built as a tree. A good width is achieved, when the sum-logic has the same depth like the n -input AND-gate and the multiplexer.  (Figure)  4 bit carry-skip adder.   Performance  The critical path of a carry-skip-adder begins at the first full-adder, passes through all adders and ends at the sum-bit    s   n  -  1      subscript  s    n  1     s_{n-1}   . Carry-skip-adders are chained (see block-carry-skip-adders) to reduce the overall critical path, since a single   n   n   n   -bit carry-skip-adder has no real speed benefit compared to a   n   n   n   -bit carry-ripple-adder.        τ   C  S  A     (  n  )    =    τ   C  R  A     (  n  )           subscript  τ    C  S  A    n      subscript  τ    C  R  A    n     \tau_{CSA}(n)=\tau_{CRA}(n)   The skip-logic consists of a   m   m   m   -input AND-gate and one multiplexer.       T   S  K    =     T   A  N  D     (  m  )    +   T   M  U  X          subscript  T    S  K         subscript  T    A  N  D    m    subscript  T    M  U  X       T_{SK}=T_{AND}(m)+T_{MUX}   As the propagate signals are computed in parallel and are early available, the critical path for the skip logic in a carry-skip adder consists only of the delay imposed by the multiplexer (conditional skip).       T   C  S  K    =   T   M  U  X    =   2  D          subscript  T    C  S  K     subscript  T    M  U  X           2  D      T_{CSK}=T_{MUX}=2D   .  Block-carry-skip adders  upright=4.0|thumb|center|16-bit fixed-block-carry-skip adder with a block size of 4 bit. Block-carry-skip adders are composed of a number of carry-skip adders. There are two types of block-carry-skip adders The two operands    A  =   (   a   n  -  1    ,   a   n  -  2    ,  …  ,   a  1   ,   a  0   )       A    subscript  a    n  1     subscript  a    n  2    normal-…   subscript  a  1    subscript  a  0      A=(a_{n-1},a_{n-2},\dots,a_{1},a_{0})   and    B  =   (   b   n  -  1    ,   b   n  -  2    ,  …  ,   b  1   ,   b  0   )       B    subscript  b    n  1     subscript  b    n  2    normal-…   subscript  b  1    subscript  b  0      B=(b_{n-1},b_{n-2},\dots,b_{1},b_{0})   are split in   k   k   k   blocks of    (   m  k   ,   m   k  -  1    ,  …  ,   m  2   ,   m  1   )      subscript  m  k    subscript  m    k  1    normal-…   subscript  m  2    subscript  m  1     (m_{k},m_{k-1},\dots,m_{2},m_{1})   bits.   Why are block-carry-skip-adders used?  Should the block-size be constant or variable?  Fixed block width vs. variable block width   Fixed size block-carry-skip adders  Fixed size block-carry-skip adders split the    n  +  1      n  1    n+1   bit of the input bits into blocks of    m  +  n      m  n    m+n   bit each, resulting in    k  =   n  m       k    n  m     k=\frac{n}{m}   blocks. The critical path consists of the ripple path and the skip element of the first block, the skip paths that are enclosed between the first and the last block, and finally the ripple-path of the last block.        T   F  C  S  A     (  n  )    =     T   C  R   A   [  0  :   c   o  u  t    ]       (  m  )    +   T   C  S  K    +    (   k  -  2   )   ⋅   T   C  S  K     +    T   C  R  A     (  m  )     =    3  D   +    m  ⋅  2   D   +     (   k  -  1   )   ⋅  2   D   +    (   m  +  2   )   2  D    =      (    2  m   +  k   )   ⋅  2   D   +   5  D             subscript  T    F  C  S  A    n        subscript  T    C  R   subscript  A   fragments  normal-[  0  normal-:   subscript  c    o  u  t    normal-]      m    subscript  T    C  S  K     normal-⋅    k  2    subscript  T    C  S  K        subscript  T    C  R  A    m             3  D      normal-⋅  m  2   D      normal-⋅    k  1   2   D       m  2   2  D              normal-⋅      2  m   k   2   D     5  D       T_{FCSA}(n)=T_{CRA_{[0:c_{out}]}}(m)+T_{CSK}+(k-2)\cdot T_{CSK}+T_{CRA}(m)=3D+%
 m\cdot 2D+(k-1)\cdot 2D+(m+2)2D=(2m+k)\cdot 2D+5D   The optimal block size for a given adder width n is derived by equating to 0        d   T   F  C  S  A     (  n  )     d  m    =  0          d   subscript  T    F  C  S  A    n     d  m    0    \frac{dT_{FCSA}(n)}{dm}=0           2  D   ⋅   (   2  -   n  ⋅   1   m  2      )    =  0       normal-⋅    2  D     2   normal-⋅  n    1   superscript  m  2       0    2D\cdot\left(2-n\cdot\frac{1}{m^{2}}\right)=0          ⇒   m   1  ,  2    =   ±    n  2          normal-⇒  absent   subscript  m   1  2          plus-or-minus      n  2        \Rightarrow m_{1,2}=\pm\sqrt{\frac{n}{2}}   Only positive block sizes are realizable       ⇒  m  =    n  2         normal-⇒  absent  m           n  2       \Rightarrow m=\sqrt{\frac{n}{2}}     Variable size block-carry-skip adders  Multilevel carry-skip adders  By using additional skip-blocks in an additional layer, the block-propagate signals    p   [  i  :  i  +  3  ]      subscript  p   fragments  normal-[  i  normal-:  i   3  normal-]     p_{[i:i+3]}   are further summarized and used to perform larger skips:       p   [  i  :  i  +  15  ]    =    p   [  i  :  i  +  3  ]    ∧   p   [  i  +  4  :  i  +  7  ]    ∧   p   [  i  +  8  :  i  +  11  ]    ∧   p   [  i  +  12  :  i  +  15  ]          subscript  p   fragments  normal-[  i  normal-:  i   15  normal-]       subscript  p   fragments  normal-[  i  normal-:  i   3  normal-]     subscript  p   fragments  normal-[  i   4  normal-:  i   7  normal-]     subscript  p   fragments  normal-[  i   8  normal-:  i   11  normal-]     subscript  p   fragments  normal-[  i   12  normal-:  i   15  normal-]       p_{[i:i+15]}=p_{[i:i+3]}\wedge p_{[i+4:i+7]}\wedge p_{[i+8:i+11]}\wedge p_{[i+%
 12:i+15]}     Implementation overview  Breaking this down into more specific terms, in order to build a 4-bit carry-bypass adder, 6 full adders would be needed. The input buses would be a 4-bit A and a 4-bit B , with a carry-in ( CIN ) signal. The output would be a 4-bit bus X and a carry-out signal ( COUT ).  The first two full adders would add the first two bits together. The carry-out signal from the second full adder (    C  1     subscript  C  1    C_{1}   )would drive the select signal for three 2 to 1 multiplexers. The second set of 2 full adders would add the last two bits assuming    C  1     subscript  C  1    C_{1}   is a logical 0. And the final set of full adders would assume that    C  1     subscript  C  1    C_{1}   is a logical 1.  The multiplexers then control which output signal is used for COUT ,    X  2     subscript  X  2    X_{2}   and    X  3     subscript  X  3    X_{3}   .  References    External links   Explanation for critical path of the variable-skip adder   ;  "  Category:Adders (electronics)     ↩     