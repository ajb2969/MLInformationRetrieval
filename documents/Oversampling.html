<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="348">Oversampling</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Oversampling</h1>
<hr/>

<p>In <a href="signal_processing" title="wikilink">signal processing</a>, <strong>oversampling</strong> is the process of <a href="sampling_(signal_processing)" title="wikilink">sampling</a> a signal with a <a href="sampling_frequency" title="wikilink">sampling frequency</a> significantly higher than the <a href="Nyquist_rate" title="wikilink">Nyquist rate</a>. Theoretically a bandwidth-limited signal can be perfectly reconstructed if sampled above the Nyquist rate, which is twice the highest frequency in the signal. Oversampling improves <a href="Resolution_(audio)" title="wikilink">resolution</a>, reduces <a class="uri" href="noise" title="wikilink">noise</a> and helps avoid <a class="uri" href="aliasing" title="wikilink">aliasing</a> and <a href="phase_distortion" title="wikilink">phase distortion</a> by relaxing <a href="anti-aliasing_filter" title="wikilink">anti-aliasing filter</a> performance requirements.</p>

<p>A signal is said to be oversampled by a factor of N if it is sampled at N times the Nyquist rate.</p>
<h2 id="motivation">Motivation</h2>

<p>There are three main reasons for performing oversampling:</p>
<h3 id="anti-aliasing">Anti-aliasing</h3>

<p>Oversampling can make it easier to realize analog <a href="anti-aliasing_filter" title="wikilink">anti-aliasing filters</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Without oversampling, it is very difficult to implement filters with the sharp cutoff necessary to maximize use of the available bandwidth without exceeding the <a href="Nyquist_limit" title="wikilink">Nyquist limit</a>. By increasing the bandwidth of the sampled signal, design constraints for the anti-aliasing filter may be relaxed.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Once sampled, the signal can be <a href="digital_filter" title="wikilink">digitally filtered</a> and <a href="downsampling" title="wikilink">downsampled</a> to the desired sampling frequency. In modern <a href="integrated_circuit" title="wikilink">integrated circuit</a> technology, digital filters are easier to implement than comparable <a href="analog_filter" title="wikilink">analog filters</a>.</p>
<h3 id="resolution">Resolution</h3>

<p>In practice, oversampling is implemented in order to achieve cheaper higher-resolution <a href="Analog-to-digital_converter" title="wikilink">A/D</a> and <a href="Digital-to-analog_converter" title="wikilink">D/A</a> conversion.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> For instance, to implement a 24-bit converter, it is sufficient to use a 20-bit converter that can run at 256 times the target sampling rate. Combining 256 consecutive 20-bit samples can increase the <a href="signal-to-noise_ratio" title="wikilink">signal-to-noise ratio</a> at the voltage level by a factor of 16 (the square root of the number of samples averaged), adding 4 bits to the resolution and producing a single sample with 24-bit resolution.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>When oversampling by a factor of N, the dynamic range increases by log2(N) bits, because there are N times as many possible values for the sum.</p>

<p>However, the SNR increases by sqrt(N), (not by N as in the article). Summing up uncorrelated noise increases its amplitude by sqrt(N), while summing up a coherent signal increases its average by N. As a result, the SNR (or signal/noise) increases by sqrt(N). In the example, that means while with N=256 there is an increase in Dynamic range by 8 bits, and the content of "coherent signal" increases by N, but the noise changes by a factor of sqrt(N)=sqrt(256)=16 in the example (not to be confused with an increase of 16 bits), so the SNR changes by a factor of 16.</p>

<p>The number of samples required to get 

<math display="inline" id="Oversampling:0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 bits of additional data precision is</p>

<p>

<math display="block" id="Oversampling:1">
 <semantics>
  <mrow>
   <mrow>
    <mtext>number of samples</mtext>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mn>2</mn>
       <mi>n</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>=</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <mn>2</mn>
      <mi>n</mi>
     </mrow>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <mtext>number of samples</mtext>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{number of samples}=(2^{n})^{2}=2^{2n}.
  </annotation>
 </semantics>
</math>

</p>

<p>To get the mean sample scaled up to an integer with 

<math display="inline" id="Oversampling:2">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 additional bits, the sum of 

<math display="inline" id="Oversampling:3">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mn>2</mn>
    <mi>n</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{2n}
  </annotation>
 </semantics>
</math>

 samples is divided by 

<math display="inline" id="Oversampling:4">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Oversampling:5">
 <semantics>
  <mrow>
   <mrow>
    <mtext>scaled mean</mtext>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mrow>
        <msup>
         <mn>2</mn>
         <mrow>
          <mn>2</mn>
          <mi>n</mi>
         </mrow>
        </msup>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </munderover>
      <mrow>
       <msup>
        <mn>2</mn>
        <mi>n</mi>
       </msup>
       <mi>d</mi>
       <mi>a</mi>
       <mi>t</mi>
       <msub>
        <mi>a</mi>
        <mi>i</mi>
       </msub>
      </mrow>
     </mrow>
     <msup>
      <mn>2</mn>
      <mrow>
       <mn>2</mn>
       <mi>n</mi>
      </mrow>
     </msup>
    </mfrac>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mrow>
        <msup>
         <mn>2</mn>
         <mrow>
          <mn>2</mn>
          <mi>n</mi>
         </mrow>
        </msup>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </munderover>
      <mrow>
       <mi>d</mi>
       <mi>a</mi>
       <mi>t</mi>
       <msub>
        <mi>a</mi>
        <mi>i</mi>
       </msub>
      </mrow>
     </mrow>
     <msup>
      <mn>2</mn>
      <mi>n</mi>
     </msup>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <mtext>scaled mean</mtext>
     <apply>
      <divide></divide>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <sum></sum>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <cn type="integer">2</cn>
           <apply>
            <times></times>
            <cn type="integer">2</cn>
            <ci>n</ci>
           </apply>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">2</cn>
         <ci>n</ci>
        </apply>
        <ci>d</ci>
        <ci>a</ci>
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <sum></sum>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <cn type="integer">2</cn>
           <apply>
            <times></times>
            <cn type="integer">2</cn>
            <ci>n</ci>
           </apply>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>a</ci>
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{scaled mean}=\frac{\sum\limits^{2^{2n}-1}_{i=0}2^{n}data_{i}}{2^{2n}}=%
\frac{\sum\limits^{2^{2n}-1}_{i=0}data_{i}}{2^{n}}.
  </annotation>
 </semantics>
</math>

</p>

<p>This averaging is only possible if the <a href="signal_(information_theory)" title="wikilink">signal</a> contains equally distributed <a class="uri" href="noise" title="wikilink">noise</a> which is enough to be observed by the A/D converter.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> If not, in the case of a stationary input signal, all 

<math display="inline" id="Oversampling:6">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}
  </annotation>
 </semantics>
</math>

 samples would have the same value and the resulting average would be identical to this value; so in this case, oversampling would have made no improvement. (In similar cases where the A/D converter sees no noise and the input signal is changing over time, oversampling still improves the result, but to an inconsistent/unpredictable extent.) This is an interesting counter-intuitive example where adding some <a href="dither" title="wikilink">dithering</a> noise to the input signal can improve (rather than degrade) the final result because the dither noise allows oversampling to work to improve resolution (or dynamic range). In many practical applications, a small increase in noise is well worth a substantial increase in measurement resolution. In practice, the dithering noise can often be placed outside the frequency range of interest to the measurement, so that this noise can be subsequently filtered out in the digital domain—resulting in a final measurement (in the frequency range of interest) with both higher resolution and lower noise.</p>
<h3 id="noise">Noise</h3>

<p>If multiple samples are taken of the same quantity with <a class="uri" href="uncorrelated" title="wikilink">uncorrelated</a> noise added to each sample, then averaging <em>N</em> samples reduces the <a href="noise_power" title="wikilink">noise power</a> by a factor of 1/<em>N</em>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> If, for example, we oversample by a factor of 4, the <a href="signal-to-noise_ratio" title="wikilink">signal-to-noise ratio</a> in terms of power improves by factor of 4 which corresponds to a factor of 2 improvement in terms of voltage.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>Certain kinds of A/D converters known as <a href="Delta-sigma_modulation" title="wikilink">delta-sigma converters</a> produce disproportionately more <a href="Quantization_(signal_processing)" title="wikilink">quantization</a> noise in the upper portion of their output spectrum. By running these converters at some multiple of the target sampling rate, and <a href="low-pass_filter" title="wikilink">low-pass filtering</a> the oversampled signal down to half the target sampling rate, a final result with <em>less</em> noise (over the entire band of the converter) can be obtained. Delta-sigma converters use a technique called <a href="noise_shaping" title="wikilink">noise shaping</a> to move the quantization noise to the higher frequencies.</p>
<h2 id="example">Example</h2>

<p>Consider a signal with a bandwidth or highest frequency of <em>B</em> = 100 <a href="Hertz" title="wikilink">Hz</a>. The <a href="Nyquist-Shannon_sampling_theorem" title="wikilink">sampling theorem</a> states that sampling frequency would have to be greater than 200 Hz. Sampling at four times that rate requires a sampling frequency of 800 Hz. This gives the anti-aliasing filter a <a href="transition_band" title="wikilink">transition band</a> of 300 Hz ((<em>f</em><sub>s</sub>/2) − <em>B</em> = (800 Hz/2) − 100 Hz = 300 Hz) instead of 0 Hz if the sampling frequency was 200 Hz.</p>

<p>Achieving an anti-aliasing filter with 0 Hz transition band is unrealistic whereas an anti-aliasing filter with a transition band of 300 Hz is not difficult to create.</p>
<h2 id="oversampling-in-reconstruction">Oversampling in reconstruction</h2>

<p>The term oversampling is also used to denote a process used in the reconstruction phase of <a href="digital-to-analog_conversion" title="wikilink">digital-to-analog conversion</a>, in which an intermediate high sampling rate is used between the digital input and the analogue output. Here, samples are interpolated in the digital domain to add additional samples in between, thereby converting the data to a higher sample rate, which is a form of <a class="uri" href="upsampling" title="wikilink">upsampling</a>. When the resulting higher-rate samples are converted to analog, a less complex/expensive analog low pass filter is required to remove the high-frequency content, which will consist of reflected images of the real signal created by the <a href="zero-order_hold" title="wikilink">zero-order hold</a> of the <a href="digital-to-analog_converter" title="wikilink">digital-to-analog converter</a>. Essentially, this is a way to shift some of the complexity of the filtering into the digital domain and achieves the same benefit as oversampling in analog-to-digital conversion.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Upsampling" title="wikilink">Upsampling</a></li>
<li><a class="uri" href="Undersampling" title="wikilink">Undersampling</a></li>
<li><a href="Oversampling_and_undersampling_in_data_analysis" title="wikilink">Oversampling and undersampling in data analysis</a></li>
<li><a href="Oversampled_binary_image_sensor" title="wikilink">Oversampled binary image sensor</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Digital_signal_processing" title="wikilink">Category:Digital signal processing</a> <a href="Category:Information_theory" title="wikilink">Category:Information theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6">See <a href="standard_error_(statistics)" title="wikilink">standard error (statistics)</a><a href="#fnref6">↩</a></li>
<li id="fn7">A system's signal-to-noise ratio cannot necessarily be increased by simple over-sampling, since noise samples are partially correlated (only some portion of the noise due to sampling and analog-to-digital conversion will be uncorrelated).<a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
