<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1285">Derived category</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Derived category</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the <strong>derived category</strong> <em>D</em>(<em>A</em>) of an <a href="abelian_category" title="wikilink">abelian category</a> <em>A</em> is a construction of <a href="homological_algebra" title="wikilink">homological algebra</a> introduced to refine and in a certain sense to simplify the theory of <a href="derived_functor" title="wikilink">derived functors</a> defined on <em>A</em>. The construction proceeds on the basis that the <a href="Object_(category_theory)" title="wikilink">objects</a> of <em>D</em>(<em>A</em>) should be <a href="chain_complex" title="wikilink">chain complexes</a> in <em>A</em>, with two such chain complexes considered <a href="isomorphism" title="wikilink">isomorphic</a> when there is a <a href="Chain_complex#Chain_maps" title="wikilink">chain map</a> that induces an isomorphism on the level of <a href="homology_(mathematics)" title="wikilink">homology</a> of the chain complexes. Derived functors can then be defined for chain complexes, refining the concept of <a href="hyperhomology" title="wikilink">hypercohomology</a>. The definitions lead to a significant simplification of formulas otherwise described (not completely faithfully) by complicated <a href="spectral_sequence" title="wikilink">spectral sequences</a>.</p>

<p>The development of the derived category, by <a href="Alexander_Grothendieck" title="wikilink">Alexander Grothendieck</a> and his student <a href="Jean-Louis_Verdier" title="wikilink">Jean-Louis Verdier</a> shortly after 1960, now appears as one terminal point in the explosive development of homological algebra in the 1950s, a decade in which it had made remarkable strides. The basic theory of Verdier was written down in his dissertation, published finally in 1996 in <a href="#refVerdierAsterisque" title="wikilink">Astérisque</a> (a summary much earlier appeared in <a href="Grothendieck's_Séminaire_de_géométrie_algébrique" title="wikilink">SGA 4½</a>). The axiomatics required an innovation, the concept of <a href="triangulated_category" title="wikilink">triangulated category</a>, and the construction is based on <a href="localization_of_a_category" title="wikilink">localization of a category</a>, a generalization of <a href="localization_of_a_ring" title="wikilink">localization of a ring</a>. The original impulse to develop the "derived" formalism came from the need to find a suitable formulation of Grothendieck's <a href="coherent_duality" title="wikilink">coherent duality</a> theory. Derived categories have since become indispensable also outside of <a href="algebraic_geometry" title="wikilink">algebraic geometry</a>, for example in the formulation of the theory of <a href="D-module" title="wikilink">D-modules</a> and <a href="microlocal_analysis" title="wikilink">microlocal analysis</a>.　Recently the derived categories have also become important in areas nearer to physics, such as <a class="uri" href="D-branes" title="wikilink">D-branes</a> and <a href="mirror_symmetry_(string_theory)" title="wikilink">mirror symmetry</a>.</p>
<h2 id="motivations">Motivations</h2>

<p>In <a href="coherent_sheaf" title="wikilink">coherent sheaf</a> theory, pushing to the limit of what could be done with <a href="Serre_duality" title="wikilink">Serre duality</a> without the assumption of a <a class="uri" href="non-singular" title="wikilink">non-singular</a> <a href="scheme_(mathematics)" title="wikilink">scheme</a>, the need to take a whole complex of sheaves in place of a single <em>dualizing sheaf</em> became apparent. In fact the <a href="Cohen-Macaulay_ring" title="wikilink">Cohen-Macaulay ring</a> condition, a weakening of non-singularity, corresponds to the existence of a single dualizing sheaf; and this is far from the general case. From the top-down intellectual position, always assumed by Grothendieck, this signified a need to reformulate. With it came the idea that the 'real' <a href="tensor_product" title="wikilink">tensor product</a> and <em>Hom</em> functors would be those existing on the derived level; with respect to those, Tor and Ext become more like computational devices.</p>

<p>Despite the level of abstraction, derived categories became accepted over the following decades, especially as a convenient setting for <a href="sheaf_cohomology" title="wikilink">sheaf cohomology</a>. Perhaps the biggest advance was the formulation of the <a href="Riemann-Hilbert_correspondence" title="wikilink">Riemann-Hilbert correspondence</a> in dimensions greater than 1 in derived terms, around 1980. The <a href="Mikio_Sato" title="wikilink">Sato</a> school adopted the language of derived categories, and the subsequent history of <a href="D-module" title="wikilink">D-modules</a> was of a theory expressed in those terms.</p>

<p>A parallel development was the category of <a href="spectrum_(homotopy_theory)" title="wikilink">spectra</a> in <a href="homotopy_theory" title="wikilink">homotopy theory</a>. The homotopy category of spectra and the derived category of a ring are both examples of <a href="triangulated_category" title="wikilink">triangulated categories</a>.</p>
<h2 id="definition">Definition</h2>

<p>Let <em>A</em> be an <a href="abelian_category" title="wikilink">abelian category</a>. (Some basic examples are the category of <a href="module_(mathematics)" title="wikilink">modules</a> over a <a href="ring_(mathematics)" title="wikilink">ring</a>, or the category of <a href="sheaf_(mathematics)" title="wikilink">sheaves</a> of abelian groups on a topological space.) We obtain the derived category <em>D</em>(<em>A</em>) in several steps:</p>
<ul>
<li>The basic object is the category Kom(<em>A</em>) of <a href="chain_complexes" title="wikilink">chain complexes</a></li>
</ul>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\cdots \to X^{-1} \xrightarrow{d^{-1}} X^0 \xrightarrow{d^0} X^1 \xrightarrow{d^1} X^2 \to \cdots</p>

<p>in <em>A</em>. Its objects will be the objects of the derived category but its morphisms will be altered.</p>
<ul>
<li>Pass to the <a href="homotopy_category_of_chain_complexes" title="wikilink">homotopy category of chain complexes</a> <em>K</em>(<em>A</em>) by identifying morphisms which are <a href="chain_homotopy" title="wikilink">chain homotopic</a>.</li>
<li>Pass to the derived category <em>D</em>(<em>A</em>) by <a href="localization_of_a_category" title="wikilink">localizing</a> at the set of <a href="quasi-isomorphism" title="wikilink">quasi-isomorphisms</a>. Morphisms in the derived category may be explicitly described as <em>roofs</em> <em>X</em> ← ''X' ''→ <em>Y</em>, where ''X' ''→ <em>X</em> is a quasi-isomorphism and ''X' ''→ <em>Y</em> is any morphism of chain complexes.</li>
</ul>

<p>The second step may be bypassed since a homotopy equivalence is in particular a quasi-isomorphism. But then the simple <em>roof</em> definition of morphisms must be replaced by a more complicated one using finite strings of morphisms (technically, it is no longer a <em>calculus of fractions</em>). So the one-step construction is more efficient in a way, but more complicated.</p>

<p>From the point of view of <a href="Model_category" title="wikilink">model categories</a>, the derived category <em>D</em>(<em>A</em>) is the true 'homotopy category' of the category of complexes, whereas <em>K</em>(<em>A</em>) might be called the 'naive homotopy category'.</p>
<h2 id="remarks">Remarks</h2>

<p>For certain purposes (see below) one uses <em>bounded-below</em> (<em>X<sup>n</sup></em> = 0 for <em>n n</em> = 0 for <em>n &gt;&gt; 0</em>) or <em>bounded</em> (<em>X<sup>n</sup></em> = 0 for <em>|n| &gt;&gt; 0</em>) complexes instead of unbounded ones. The corresponding derived categories are usually denoted <em>D<sup>+</sup>(A)</em>, <em>D<sup>−</sup>(A)</em> and <em>D<sup>b</sup>(A)</em>, respectively.</p>

<p>If one adopts the classical point of view on categories, that there is a <a href="Set_(mathematics)" title="wikilink">set</a> of morphisms from one object to another (not just a <a href="Class_(set_theory)" title="wikilink">class</a>), then one has to give an additional argument to prove this. If, for example, the abelian category <em>A</em> is small, i.e. has only a set of objects, then this issue will be no problem. Also, if <em>A</em> is a <a href="Grothendieck_category" title="wikilink">Grothendieck abelian category</a>, then the derived category <em>D</em>(<em>A</em>) is equivalent to a full subcategory of the homotopy category <em>K</em>(<em>A</em>), and hence has only a set of morphisms from one object to another.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Grothendieck abelian categories include the category of modules over a ring, the category of sheaves of abelian groups on a topological space, and many other examples.</p>

<p>Composition of morphisms, i.e. roofs, in the derived category is accomplished by finding a third roof on top of the two roofs to be composed. It may be checked that this is possible and gives a well-defined, associative composition.</p>

<p>Since <em>K(A)</em> is a <a href="triangulated_category" title="wikilink">triangulated category</a>, its localization <em>D(A)</em> is also triangulated. For an integer <em>n</em> and a complex <em>X</em>, define<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> the complex <em>X</em>[<em>n</em>] to be <em>X</em> shifted down by <em>n</em>, so that</p>

<p>

<math display="block" id="Derived_category:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>X</mi>
     <msup>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>n</mi>
       <mo stretchy="false">]</mo>
      </mrow>
      <mi>i</mi>
     </msup>
    </mrow>
    <mo>=</mo>
    <msup>
     <mi>X</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mi>i</mi>
     </mrow>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>X</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>n</ci>
      </apply>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X[n]^{i}=X^{n+i},
  </annotation>
 </semantics>
</math>

 with differential</p>

<p>

<math display="block" id="Derived_category:1">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>d</mi>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>n</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>n</mi>
     </msup>
     <msub>
      <mi>d</mi>
      <mi>X</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <apply>
      <times></times>
      <ci>X</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{X[n]}=(-1)^{n}d_{X}.
  </annotation>
 </semantics>
</math>

 By definition, a distinguished triangle in <em>D(A)</em> is a triangle that is isomorphic in <em>D(A)</em> to the triangle <em>X</em> → <em>Y</em> → Cone(<em>f</em>) → <em>X</em>[1] for some map of complexes <em>f</em>: <em>X</em> → <em>Y</em>. Here Cone(<em>f</em>) denotes the <a href="mapping_cone_(homological_algebra)" title="wikilink">mapping cone</a> of <em>f</em>. In particular, for a short exact sequence</p>

<p>

<math display="block" id="Derived_category:2">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mi>X</mi>
   <mo>→</mo>
   <mi>Y</mi>
   <mo>→</mo>
   <mi>Z</mi>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <ci>X</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>Y</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>Z</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\rightarrow X\rightarrow Y\rightarrow Z\rightarrow 0
  </annotation>
 </semantics>
</math>

 in <em>A</em>, the triangle <em>X</em> → <em>Y</em> → <em>Z</em> → <em>X</em>[1] is distinguished in <em>D(A)</em>. Verdier explained that the definition of the shift <em>X</em>[1] is forced by requiring <em>X</em>[1] to be the cone of the morphism <em>X</em> → 0.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>By viewing an object of <em>A</em> as a complex concentrated in degree zero, the derived category <em>D(A)</em> contains <em>A</em> as a <a href="subcategory" title="wikilink">full subcategory</a>. More interestingly, morphisms in the derived category include information about all <a href="Ext_functor" title="wikilink">Ext groups</a>: for any objects <em>X</em> and <em>Y</em> in <em>A</em> and any integer <em>j</em>,</p>

<p>

<math display="block" id="Derived_category:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mtext>Hom</mtext>
      <mrow>
       <mi>D</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi class="ltx_font_mathcaligraphic">𝒜</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo>,</mo>
      <mrow>
       <mi>Y</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>j</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mtext>Ext</mtext>
      <mi class="ltx_font_mathcaligraphic">𝒜</mi>
      <mi>j</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo>,</mo>
      <mi>Y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>Hom</mtext>
      <apply>
       <times></times>
       <ci>D</ci>
       <ci>𝒜</ci>
      </apply>
     </apply>
     <interval closure="open">
      <ci>X</ci>
      <apply>
       <times></times>
       <ci>Y</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>j</ci>
       </apply>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <mtext>Ext</mtext>
       <ci>j</ci>
      </apply>
      <ci>𝒜</ci>
     </apply>
     <interval closure="open">
      <ci>X</ci>
      <ci>Y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Hom}_{D(\mathcal{A})}(X,Y[j])=\text{Ext}^{j}_{\mathcal{A}}(X,Y).
  </annotation>
 </semantics>
</math>

</p>
<h2 id="projective-and-injective-resolutions">Projective and injective resolutions</h2>

<p>One can easily show that a <a href="Homotopy#Homotopy_equivalence" title="wikilink">homotopy equivalence</a> is a <a class="uri" href="quasi-isomorphism" title="wikilink">quasi-isomorphism</a>, so the second step in the above construction may be omitted. The definition is usually given in this way because it reveals the existence of a canonical functor</p>

<p>

<math display="block" id="Derived_category:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi class="ltx_font_mathcaligraphic">𝒜</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi class="ltx_font_mathcaligraphic">𝒜</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>𝒜</ci>
    </apply>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>𝒜</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(\mathcal{A})\rightarrow D(\mathcal{A}).
  </annotation>
 </semantics>
</math>

</p>

<p>In concrete situations, it is very difficult or impossible to handle morphisms in the derived category directly. Therefore one looks for a more manageable category which is equivalent to the derived category. Classically, there are two (dual) approaches to this: projective and <a href="injective_resolution" title="wikilink">injective resolutions</a>. In both cases, the restriction of the above canonical functor to an appropriate subcategory will be an <a href="equivalence_of_categories" title="wikilink">equivalence of categories</a>.</p>

<p>In the following we will describe the role of injective resolutions in the context of the derived category, which is the basis for defining right <a href="derived_functors" title="wikilink">derived functors</a>, which in turn have important applications in <a class="uri" href="cohomology" title="wikilink">cohomology</a> of <a href="sheaf_(mathematics)" title="wikilink">sheaves</a> on <a href="topological_space" title="wikilink">topological spaces</a> or more advanced cohomology theories like <a href="étale_cohomology" title="wikilink">étale cohomology</a> or <a href="group_cohomology" title="wikilink">group cohomology</a>.</p>

<p>In order to apply this technique, one has to assume that the abelian category in question has <em>enough injectives</em>, which means that every object <em>X</em> of the category admits a <a class="uri" href="monomorphism" title="wikilink">monomorphism</a> to an <a href="injective_object" title="wikilink">injective object</a> <em>I</em>. (Neither the map nor the injective object has to be uniquely specified.) For example, every <a href="Grothendieck_category" title="wikilink">Grothendieck abelian category</a> has enough injectives. Embedding <em>X</em> into some injective object <em>I</em><sup>0</sup>, the <a class="uri" href="cokernel" title="wikilink">cokernel</a> of this map into some injective <em>I</em><sup>1</sup> etc., one constructs an <em>injective resolution</em> of <em>X</em>, i.e. an <a href="exact_sequence" title="wikilink">exact</a> (in general infinite) sequence</p>

<p>

<math display="block" id="Derived_category:5">
 <semantics>
  <mrow>
   <mrow>
    <mn>0</mn>
    <mo>→</mo>
    <mi>X</mi>
    <mo>→</mo>
    <msup>
     <mi>I</mi>
     <mn>0</mn>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>I</mi>
     <mn>1</mn>
    </msup>
    <mo>→</mo>
    <mi mathvariant="normal">⋯</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <ci>X</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>I</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>I</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\rightarrow X\rightarrow I^{0}\rightarrow I^{1}\rightarrow\cdots,\,
  </annotation>
 </semantics>
</math>

</p>

<p>where the <em>I</em>* are injective objects. This idea generalizes to give resolutions of bounded-below complexes <em>X</em>, i.e. <em>X<sup>n</sup> = 0</em> for sufficiently small <em>n</em>. As remarked above, injective resolutions are not uniquely defined, but it is a fact that any two resolutions are homotopy equivalent to each other, i.e. isomorphic in the homotopy category. Moreover, morphisms of complexes extend uniquely to a morphism of two given injective resolutions.</p>

<p>This is the point where the homotopy category comes into play again: mapping an object <em>X</em> of <em>A</em> to (any) injective resolution <em>I</em>* of <em>A</em> extends to a <a class="uri" href="functor" title="wikilink">functor</a></p>

<p>

<math display="block" id="Derived_category:6">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>D</mi>
     <mo>+</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi class="ltx_font_mathcaligraphic">𝒜</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>K</mi>
     <mo>+</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>Inj</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi class="ltx_font_mathcaligraphic">𝒜</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>D</ci>
      <plus></plus>
     </apply>
     <ci>𝒜</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>K</ci>
      <plus></plus>
     </apply>
     <apply>
      <times></times>
      <ci>Inj</ci>
      <ci>𝒜</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D^{+}(\mathcal{A})\rightarrow K^{+}(\mathrm{Inj}(\mathcal{A}))
  </annotation>
 </semantics>
</math>

 from the bounded below derived category to the bounded below homotopy category of complexes whose terms are injective objects in <em>A</em>.</p>

<p>It is not difficult to see that this functor is actually inverse to the restriction of the canonical localization functor mentioned in the beginning. In other words, morphisms Hom(<em>X</em>,<em>Y</em>) in the derived category may be computed by resolving both <em>X</em> and <em>Y</em> and computing the morphisms in the homotopy category, which is at least theoretically easier. In fact, it is enough to resolve <em>Y</em>: for any complex <em>X</em> and any bounded below complex <em>Y</em> of injectives,</p>

<p>

<math display="block" id="Derived_category:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>Hom</mi>
      <mrow>
       <mi>D</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo>,</mo>
      <mi>Y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>Hom</mi>
      <mrow>
       <mi>K</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo>,</mo>
      <mi>Y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Hom</ci>
      <apply>
       <times></times>
       <ci>D</ci>
       <ci>A</ci>
      </apply>
     </apply>
     <interval closure="open">
      <ci>X</ci>
      <ci>Y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Hom</ci>
      <apply>
       <times></times>
       <ci>K</ci>
       <ci>A</ci>
      </apply>
     </apply>
     <interval closure="open">
      <ci>X</ci>
      <ci>Y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Hom}_{D(A)}(X,Y)=\mathrm{Hom}_{K(A)}(X,Y).
  </annotation>
 </semantics>
</math>

</p>

<p>Dually, assuming that <em>A</em> has <em>enough <a href="projective_object" title="wikilink">projectives</a></em>, i.e. for every object <em>X</em> there is an <a class="uri" href="epimorphism" title="wikilink">epimorphism</a> from a projective object <em>P</em> to <em>X</em>, one can use projective resolutions instead of injective ones.</p>

<p>In addition to these resolution techniques there are similar ones which apply to special cases, and which elegantly avoid the problem with bounded-above or -below restrictions:  uses so-called <em>K-injective</em> and <em>K-projective</em> resolutions,  and (in a slightly different language)  introduced so called <em>cell-modules</em> and <em>semi-free</em> modules, respectively.</p>

<p>More generally, carefully adapting the definitions, it is possible to define the derived category of an <a href="exact_category" title="wikilink">exact category</a> .</p>
<h2 id="the-relation-to-derived-functors">The relation to derived functors</h2>

<p>The derived category is a natural framework to define and study <a href="derived_functors" title="wikilink">derived functors</a>. In the following, let <em>F</em>: <em>A</em> → <em>B</em> be a functor of abelian categories. There are two dual concepts:</p>
<ul>
<li>right derived functors come from left exact functors and are calculated via injective resolutions</li>
<li>left derived functors come from right exact functors and are calculated via projective resolutions</li>
</ul>

<p>In the following we will describe right derived functors. So, assume that <em>F</em> is left exact. Typical examples are <em>F</em>: <em>A</em> → Ab given by <em>X</em> ↦ Hom(<em>X</em>, <em>A</em>) or <em>X</em> ↦ Hom(<em>A</em>, <em>X</em>) for some fixed object <em>A</em>, or the <a href="global_sections_functor" title="wikilink">global sections functor</a> on <a href="sheaf_(mathematics)" title="wikilink">sheaves</a> or the <a href="direct_image_functor" title="wikilink">direct image functor</a>. Their right derived functors are <a href="Ext_functors" title="wikilink">Ext<sup><em>n</em></sup>(–,<em>A</em>)</a>, Ext<sup><em>n</em></sup>(<em>A</em>,–), <a href="sheaf_cohomology" title="wikilink"><em>H</em><sup><em>n</em></sup>(<em>X</em>, <em>F</em>)</a> or <a href="higher_direct_image_functor" title="wikilink"><em>R</em><sup><em>n</em></sup><em>f</em><sub>∗</sub> (<em>F</em>)</a>, respectively.</p>

<p>The derived category allows us to encapsulate all derived functors <em>R<sup>n</sup>F</em> in one functor, namely the so-called <em>total derived functor</em> <em>RF</em>: <em>D</em><sup>+</sup>(<em>A</em>) → <em>D</em><sup>+</sup>(<em>B</em>). It is the following composition: <em>D</em><sup>+</sup>(<em>A</em>) ≅ <em>K</em><sup>+</sup>(Inj(<em>A</em>)) → <em>K</em><sup>+</sup>(<em>B</em>) → <em>D</em><sup>+</sup>(<em>B</em>), where the first equivalence of categories is described above. The classical derived functors are related to the total one via <em>R<sup>n</sup>F</em>(<em>X</em>) = <em>H<sup>n</sup></em>(<em>RF</em>(<em>X</em>)). One might say that the <em>R<sup>n</sup>F</em> forget the chain complex and keep only the cohomologies, whereas <em>RF</em> does keep track of the complexes.</p>

<p>Derived categories are, in a sense, the "right" place to study these functors. For example, the <a href="Grothendieck_spectral_sequence" title="wikilink">Grothendieck spectral sequence</a> of a composition of two functors</p>

<p>

<math display="block" id="Derived_category:8">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    <mover>
     <mo movablelimits="false">→</mo>
     <mi>F</mi>
    </mover>
    <mi class="ltx_font_mathcaligraphic">ℬ</mi>
    <mover>
     <mo movablelimits="false">→</mo>
     <mi>G</mi>
    </mover>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-→</ci>
      <ci>F</ci>
     </apply>
     <ci>𝒜</ci>
     <ci>ℬ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-→</ci>
      <ci>G</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <ci>𝒞</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}\stackrel{F}{\rightarrow}\mathcal{B}\stackrel{G}{\rightarrow}%
\mathcal{C},\,
  </annotation>
 </semantics>
</math>

</p>

<p>such that <em>F</em> maps <a href="injective_object" title="wikilink">injective objects</a> in <em>A</em> to <em>G</em>-acyclics (i.e. <em>R</em><sup><em>i</em></sup><em>G</em>(<em>F</em>(<em>I</em>)) = 0 for all <em>i</em> &gt; 0 and injective <em>I</em>), is an expression of the following identity of total derived functors</p>
<dl>
<dd><em>R</em>(<em>G</em>∘<em>F</em>) ≅ <em>RG</em>∘<em>RF</em>.
</dd>
</dl>

<p>J.-L. Verdier showed how derived functors associated with an abelian category <em>A</em> can be viewed as <a href="Kan_extension" title="wikilink">Kan extensions</a> along embeddings of <em>A</em> into suitable derived categories [Mac Lane].</p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>Three textbooks that discuss derived categories are:</p>
<ul>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Homological_algebra" title="wikilink">Category:Homological algebra</a> <a href="Category:Category-theoretic_categories" title="wikilink">Category:Category-theoretic categories</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">M. Kashiwara and P. Schapira. <em>Categories and Sheaves.</em> Springer-Verlag (2006). Theorem 14.3.1.<a href="#fnref1">↩</a></li>
<li id="fn2">S. Gelfand and Y. Manin. <em>Methods of Homological Algebra.</em> Springer-Verlag (2003). III.3.2.<a href="#fnref2">↩</a></li>
<li id="fn3">J.-L. Verdier. <em>Astérisque</em> 239. Soc. Math. de France (1996). Appendice to Ch. 1.<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
