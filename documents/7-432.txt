   Algebra of Communicating Processes      Algebra of Communicating Processes  The '''Algebra of Communicating Processes''' (ACP) is an [[Universal algebra|algebraic]] approach to reasoning about [[concurrent systems]]. It is a member of the family of mathematical theories of concurrency known as process algebras or [[process calculi]]. ACP was initially developed by [[Ja n Bergstra]] and Jan Willem Klop in 1982, 1 as part of an effort to investigate the solutions of unguarded recursive equations. More so than the other seminal process calculi ( CCS and CSP ), the development of ACP focused on the algebra of processes, and sought to create an abstract, generalized axiomatic system for processes, 2 and in fact the term process algebra was coined during the research that led to ACP.  Informal description  ACP is fundamentally an algebra, in the sense of universal algebra . This algebra provides a way to describe systems in terms of algebraic process expressions that define compositions of other processes, or of certain primitive elements.  Primitives  ACP uses instantaneous, atomic actions (    a  ,  b  ,  c  ,  …     a  b  c  normal-…    \mathit{a,b,c,...}   ) as its primitives. Some actions have special meaning, such as the action   δ   δ   \delta   , which represents deadlock or stagnation, and the action   τ   τ   \tau   , which represents a silent action (abstracted actions that have no specific identity).  Algebraic operators  Actions can be combined to form processes using a variety of operators. These operators can be roughly categorized as providing a basic process algebra , concurrency , and communication .   Choice and sequencing — the most fundamental of algebraic operators are the alternative operator (   +     +   ), which provides a choice between actions, and the sequencing operator (   ⋅   normal-⋅   \cdot   ), which specifies an ordering on actions. So, for example, the process        (   a  +  b   )   ⋅  c     normal-⋅    a  b   c    (a+b)\cdot c      first chooses to perform either   a   a   \mathit{a}   or   b   b   \mathit{b}   , and then performs action   c   c   \mathit{c}   . How the choice between   a   a   \mathit{a}   and   b   b   \mathit{b}   is made does not matter and is left unspecified. Note that alternative composition is commutative but sequential composition is not (because time flows forward).    Concurrency — to allow the description of concurrency, ACP provides the merge and left-merge operators. The merge operator,    |  |     fragments  normal-|  normal-|    ||   , represents the parallel composition of two processes, the individual actions of which are interleaved. The left-merge operator,    |  ⌊     fragments  normal-|  normal-⌊    |\lfloor   , is an auxiliary operator with similar semantics to the merge, but a commitment to always choose its initial step from the left-hand process. As an example, the process        (  a  ⋅  b  )   |  |   (  c  ⋅  d  )      fragments   fragments  normal-(  a  normal-⋅  b  normal-)   normal-|  normal-|   fragments  normal-(  c  normal-⋅  d  normal-)     (a\cdot b)||(c\cdot d)      may perform the actions    a  ,  b  ,  c  ,  d     a  b  c  d    a,b,c,d   in any of the sequences     a  b  c  d   ,   a  c  b  d   ,   a  c  d  b   ,   c  a  b  d   ,   c  a  d  b   ,   c  d  a  b        a  b  c  d     a  c  b  d     a  c  d  b     c  a  b  d     c  a  d  b     c  d  a  b     abcd,acbd,acdb,cabd,cadb,cdab   . On the other hand, the process        (  a  ⋅  b  )   |   ⌊   (  c  ⋅  d  )       fragments   fragments  normal-(  a  normal-⋅  b  normal-)   normal-|   fragments  normal-⌊   fragments  normal-(  c  normal-⋅  d  normal-)      (a\cdot b)|\lfloor(c\cdot d)      may only perform the sequences     a  b  c  d   ,   a  c  b  d   ,   a  c  d  b        a  b  c  d     a  c  b  d     a  c  d  b     abcd,acbd,acdb   since the left-merge operators ensures that the action   a   a   \mathit{a}   occurs first.    Communication — interaction (or communication) between processes is represented using the binary communications operator,   |   normal-|   |   . For example, the actions    r   (  d  )       r  d    r(d)   and    w   (  d  )       w  d    w(d)   might be interpreted as the reading and writing of a data item    d  ∈  D  =   {  1  ,  2  ,  3  ,  …  }         d  D        1  2  3  normal-…      d\in D=\{1,2,3,\ldots\}   , respectively. Then the process        (   ∑   d  ∈  D    r   (  d  )   ⋅  y  )   |   (  w   (  1  )   ⋅  z  )      fragments   fragments  normal-(   subscript     d  D    r   fragments  normal-(  d  normal-)   normal-⋅  y  normal-)   normal-|   fragments  normal-(  w   fragments  normal-(  1  normal-)   normal-⋅  z  normal-)     \left(\sum_{d\in D}r(d)\cdot y\right)|(w(1)\cdot z)      will communicate the value   1   1   1   from the right component process to the left component process ( i.e. the identifier   d   d   \mathit{d}   is bound to the value   1   1   1   , and free instances of   d   d   \mathit{d}   in the process   y   y   \mathit{y}   take on that value), and then behave as the merge of   y   y   \mathit{y}   and   z   z   \mathit{z}   .    Abstraction — the abstraction operator,    τ  I     subscript  τ  I    \tau_{I}   , provides a way to "hide" certain actions, and treat them as events that are internal to the systems being modelled. Abstracted actions are converted to the silent step action   τ   τ   \tau   . In some cases, these silent steps can also be removed from the process expression as part of the abstraction process. For example,         τ   {  c  }     (    (   a  +  b   )   ⋅  c   )    =    (   a  +  b   )   ⋅  τ          subscript  τ   c     normal-⋅    a  b   c     normal-⋅    a  b   τ     \tau_{\{c\}}((a+b)\cdot c)=(a+b)\cdot\tau      which, in this case, can be reduced to       a  +  b      a  b    a+b      since the event   c   c   \mathit{c}   is no longer observable and has no observable effects.   Formal definition  ACP fundamentally adopts an axiomatic, algebraic approach to the formal definition of its various operators. The axioms presented below comprise the full axiomatic system for ACP    τ   τ   \tau    (ACP with abstraction).  Basic process algebra  Using the alternative and sequential composition operators, ACP defines a basic process algebra which satisfies the axioms 3         x  +  y     =     y  +  x         (   x  +  y   )   +  z     =     x  +   (   y  +  z   )         x  +  x     =     x  ;         (   x  +  y   )   ⋅  z     =      (   x  ⋅  z   )   +   (   y  ⋅  z   )          (   x  ⋅  y   )   ⋅  z     =     x  ⋅   (   y  ⋅  z   )            x  y      y  x         x  y   z      x    y  z        x  x    x     normal-⋅    x  y   z       normal-⋅  x  z    normal-⋅  y  z       normal-⋅   normal-⋅  x  y   z     normal-⋅  x   normal-⋅  y  z       \begin{matrix}x+y&=&y;+x\\
 (x+y)+z&=&x;+(y+z)\\
 x+x&=&x;\\
 (x+y)\cdot z&=&(x\cdot z)+(y\cdot z)\\
 (x\cdot y)\cdot z&=&x;\cdot(y\cdot z)\end{matrix}     Deadlock  Beyond the basic algebra, two additional axioms define the relationships between the alternative and sequencing operators, and the deadlock action,   δ   δ   \delta            δ  +  x     =    x       δ  ⋅  x     =    δ          δ  x    x     normal-⋅  δ  x    δ     \begin{matrix}\delta+x&=&x;\\
 \delta\cdot x&=&\delta\end{matrix}     Concurrency and interaction  The axioms associated with the merge, left-merge, and communication operators are 4         x  |  |  y     =     x  |   ⌊  y  +  y  |   ⌊  x  +  x  |  y          a  ⋅  x  |   ⌊  y      =     a  ⋅   (  x  |  |  y  )         a  |   ⌊  y      =     a  ⋅  y         (  x  +  y  )   |   ⌊  z      =     (  x  |   ⌊  z  )   +   (  y  |   ⌊  z  )          a  ⋅  x  |  b     =      (  a  |  b  )   ⋅  x        a  |  b  ⋅  x     =      (  a  |  b  )   ⋅  x        a  ⋅  x  |  b  ⋅  y     =      (  a  |  b  )   ⋅   (  x  |  |  y  )          (  x  +  y  )   |  z     =     x   |   z  +  y   |   z        x  |   (  y  +  z  )      =     x   |   y  +  x   |   z          fragments  x  normal-|  normal-|  y     fragments  x  normal-|   fragments  normal-⌊  y   y  normal-|   fragments  normal-⌊  x   x  normal-|  y        fragments  a  normal-⋅  x  normal-|   fragments  normal-⌊  y      fragments  a  normal-⋅   fragments  normal-(  x  normal-|  normal-|  y  normal-)       fragments  a  normal-|   fragments  normal-⌊  y      normal-⋅  a  y      fragments   fragments  normal-(  x   y  normal-)   normal-|   fragments  normal-⌊  z      fragments  normal-(  x  normal-|   fragments  normal-⌊  z  normal-)     fragments  normal-(  y  normal-|   fragments  normal-⌊  z  normal-)        fragments  a  normal-⋅  x  normal-|  b     fragments   fragments  normal-(  a  normal-|  b  normal-)   normal-⋅  x      fragments  a  normal-|  b  normal-⋅  x     fragments   fragments  normal-(  a  normal-|  b  normal-)   normal-⋅  x      fragments  a  normal-⋅  x  normal-|  b  normal-⋅  y     fragments   fragments  normal-(  a  normal-|  b  normal-)   normal-⋅   fragments  normal-(  x  normal-|  normal-|  y  normal-)       fragments   fragments  normal-(  x   y  normal-)   normal-|  z      x      z  y    z      fragments  x  normal-|   fragments  normal-(  y   z  normal-)       x      y  x    z      \begin{matrix}x||y&=&x;|\lfloor y+y|\lfloor x+x|y\\
 a\cdot x|\lfloor y&=&a;\cdot(x||y)\\
 a|\lfloor y&=&a;\cdot y\\
 (x+y)|\lfloor z&=&(x|\lfloor z)+(y|\lfloor z)\\
 a\cdot x|b&=&(a|b)\cdot x\\
 a|b\cdot x&=&(a|b)\cdot x\\
 a\cdot x|b\cdot y&=&(a|b)\cdot(x||y)\\
 (x+y)|z&=&x;|z+y|z\\
 x|(y+z)&=&x;|y+x|z\end{matrix}     When the communications operator is applied to actions alone, rather than processes, it is interpreted as a binary function from actions to actions,    |  :  A  ×  A  →  A     fragments  normal-|  normal-:  A   A  normal-→  A    |:A\times A\rightarrow A   . The definition of this function defines the possible interactions between processes — those pairs of actions that do not constitute interactions are mapped to the deadlock action,   δ   δ   \delta   , while permitted interaction pairs are mapped to corresponding single actions representing the occurrence of an interaction. For example, the communications function might specify that      a  |  a  →  c     fragments  a  normal-|  a  normal-→  c    a|a\rightarrow c   which indicates that a successful interaction    a  |  a     fragments  a  normal-|  a    a|a   will be reduced to the action   c   c   c   . ACP also includes an encapsulation operator,    ∂  H     subscript   H    \partial_{H}   for some    H  ⊆  A      H  A    H\subseteq A   , which is used to convert unsuccessful communication attempts (i.e. elements of   H   H   H   that have not been reduced via the communication function) to the deadlock action. The axioms associated with the communications function and encapsulation operator are 5         a  |  b     =     b  |  a         (  a  |  b  )   |  c     =     a  |   (  b  |  c  )         a  |  δ     =    δ        ∂  H    (  a  )      =      a  if  a   ∉  H         ∂  H    (  a  )      =      δ  if  a   ∈  H         ∂  H    (   x  +  y   )      =       ∂  H    (  x  )    +    ∂  H    (  y  )           ∂  H    (   x  ⋅  y   )      =       ∂  H    (  x  )    ⋅    ∂  H    (  y  )            fragments  a  normal-|  b     fragments  b  normal-|  a      fragments   fragments  normal-(  a  normal-|  b  normal-)   normal-|  c     fragments  a  normal-|   fragments  normal-(  b  normal-|  c  normal-)       fragments  a  normal-|  δ    δ      subscript   H   a        a  if  a   H       subscript   H   a        δ  if  a   H       subscript   H     x  y         subscript   H   x     subscript   H   y        subscript   H    normal-⋅  x  y      normal-⋅    subscript   H   x     subscript   H   y       \begin{matrix}a|b&=&b;|a\\
 (a|b)|c&=&a;|(b|c)\\
 a|\delta&=&\delta\\
 \partial_{H}(a)&=&a;\mbox{ if }a\notin H\\
 \partial_{H}(a)&=&\delta\mbox{ if }a\in H\\
 \partial_{H}(x+y)&=&\partial_{H}(x)+\partial_{H}(y)\\
 \partial_{H}(x\cdot y)&=&\partial_{H}(x)\cdot\partial_{H}(y)\\
 \end{matrix}     Abstraction  The axioms associated with the abstraction operator are 6          τ  I    (  τ  )      =    τ        τ  I    (  a  )      =      a  if  a   ∉  I         τ  I    (  a  )      =      τ  if  a   ∈  I         τ  I    (   x  +  y   )      =       τ  I    (  x  )    +    τ  I    (  y  )           τ  I    (   x  ⋅  y   )      =        τ  I    (  x  )    ⋅   τ  I     (  y  )          ∂  H    (  τ  )      =    τ       x  ⋅  τ     =    x       τ  ⋅  x     =      τ  ⋅  x   +  x        a  ⋅   (    τ  ⋅  x   +  y   )      =      a  ⋅   (    τ  ⋅  x   +  y   )    +   a  ⋅  x         τ  ⋅  x  |   ⌊  y      =     τ  ⋅   (  x  |  |  y  )         τ  |   ⌊  x      =     τ  ⋅  x        τ  |  x     =    δ       x  |  τ     =    δ       τ  ⋅  x  |  y     =     x  |  y        x  |  τ  ⋅  y     =     x  |  y            subscript  τ  I   τ    τ       subscript  τ  I   a        a  if  a   I        subscript  τ  I   a        τ  if  a   I        subscript  τ  I     x  y          subscript  τ  I   x      subscript  τ  I   y         subscript  τ  I    normal-⋅  x  y        normal-⋅     subscript  τ  I   x    subscript  τ  I    y       subscript   H   τ    τ     normal-⋅  x  τ    x     normal-⋅  τ  x       normal-⋅  τ  x   x      normal-⋅  a     normal-⋅  τ  x   y        normal-⋅  a     normal-⋅  τ  x   y     normal-⋅  a  x       fragments  τ  normal-⋅  x  normal-|   fragments  normal-⌊  y      fragments  τ  normal-⋅   fragments  normal-(  x  normal-|  normal-|  y  normal-)       fragments  τ  normal-|   fragments  normal-⌊  x      normal-⋅  τ  x      fragments  τ  normal-|  x    δ     fragments  x  normal-|  τ    δ     fragments  τ  normal-⋅  x  normal-|  y     fragments  x  normal-|  y      fragments  x  normal-|  τ  normal-⋅  y     fragments  x  normal-|  y      \begin{matrix}\tau_{I}(\tau)&=&\tau\\
 \tau_{I}(a)&=&a;\mbox{ if }a\notin I\\
 \tau_{I}(a)&=&\tau\mbox{ if }a\in I\\
 \tau_{I}(x+y)&=&\tau_{I}(x)+\tau_{I}(y)\\
 \tau_{I}(x\cdot y)&=&\tau_{I}(x)\cdot\tau_{I}(y)\\
 \partial_{H}(\tau)&=&\tau\\
 x\cdot\tau&=&x;\\
 \tau\cdot x&=&\tau\cdot x+x\\
 a\cdot(\tau\cdot x+y)&=&a;\cdot(\tau\cdot x+y)+a\cdot x\\
 \tau\cdot x|\lfloor y&=&\tau\cdot(x||y)\\
 \tau|\lfloor x&=&\tau\cdot x\\
 \tau|x&=&\delta\\
 x|\tau&=&\delta\\
 \tau\cdot x|y&=&x;|y\\
 x|\tau\cdot y&=&x;|y\end{matrix}     Note that the action a in the above list may take the value δ (but of course, δ cannot belong to the abstraction set I ).  Related formalisms  ACP has served as the basis or inspiration for several other formalisms that can be used to describe and analyze concurrent systems, including:   PSF    μCRL    mCRL2    HyPA — a process algebra for hybrid systems      J.C.M. Baeten, A brief history of process algebra , Rapport CSR 04-02, Vakgroep Informatica, Technische Universiteit Eindhoven, 2004 ↩  Bas Luttik, What is algebraic in process theory , Algebraic Process Calculi: The First Twenty Five Years and Beyond , Bertinoro, Italy, August 1, 2005 ↩  J.A. Bergstra and J.W. Klop, ACP τ : A Universal Axiom System for Process Specification , CWI Quarterly 15, pp. 3-23, 1987 ↩        