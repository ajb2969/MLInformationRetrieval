<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="471">Equation-free modeling</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Equation-free modeling</h1>
<hr>'''Equation-free
<p><code>modeling''' is a method for </code><a href="multiscale_computation" title="wikilink"><code>multiscale</code> <code>computation</code></a><code> and </code><a href="computer-aided_analysis" title="wikilink"><code>computer-aided</code> <code>analysis</code></a><code>. It is designed for a class of complicated systems in which one observes evolution at a macroscopic, coarse scale of interest, while accurate models are only given at a finely detailed, microscopic, level of description. The framework empowers one to perform macroscopic computational tasks (over large space-time scales) using only appropriately initialized microscopic simulation on short time and small length scales. The methodology eliminates the derivation of explicit macroscopic </code><a href="evolution_equation" title="wikilink"><code>evolution</code> <code>equations</code></a><code> when these equations conceptually exist but are not available in closed form; hence the term equation-free.</code><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="introduction">Introduction</h2>

<p>In a wide range of chemical, physical and biological systems, coherent macroscopic behavior emerges from interactions between microscopic entities themselves (molecules, cells, grains, animals in a population, agents) and with their environment. Sometimes, remarkably, a coarse-scale differential equation model (such as the <a href="Navier-Stokes_equations" title="wikilink">Navier-Stokes equations</a> for fluid flow, or a <a href="reaction-diffusion_system" title="wikilink">reaction-diffusion system</a>) can accurately describe macroscopic behavior. Such macroscale modeling makes use of general principles of conservation (atoms, particles, mass, momentum, energy), and closed into a well-posed system through phenomenological <a href="constitutive_equations" title="wikilink">constitutive equations</a> or <a href="equations_of_state" title="wikilink">equations of state</a>. However, one increasingly encounters <a href="complex_systems" title="wikilink">complex systems</a> that only have known microscopic, fine scale, models. In such cases, although we observe the emergence of coarse-scale, macroscopic behavior, modeling it through explicit closure relations may be impossible or impractical. <a href="Non-Newtonian_fluid" title="wikilink">Non-Newtonian fluid</a> flow, <a class="uri" href="chemotaxis" title="wikilink">chemotaxis</a>, <a href="porous_media" title="wikilink">porous media</a> transport, <a class="uri" href="epidemiology" title="wikilink">epidemiology</a>, brain modeling and neuronal systems are some typical examples. Equation-free modeling aims to use such microscale models to predict coarse macroscale emergent phenomena.</p>

<p>Performing coarse-scale computational tasks directly with fine-scale models is often infeasible: direct simulation over the full space-time domain of interest is often computationally prohibitive. Moreover, modeling tasks, such as numerical bifurcation analysis, are often impossible to perform on the fine-scale model directly: a coarse-scale steady state may not imply a steady state for the fine-scale system, since individual molecules or particles do not stop moving when the gas density or pressure become stationary. Equation-free modeling circumvents such problems by using short bursts of appropriately initialized fine-scale simulation.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="the-coarse-time-stepper">The coarse time-stepper</h2>

<p>Dynamic problems invoke the coarse time-stepper. In essence, short bursts of computational experiments with the fine-scale simulator estimate local time derivatives. Given an initial condition for the coarse variables 

<math display="inline" id="Equation-free_modeling:0">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>t</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(t_{k})
  </annotation>
 </semantics>
</math>

 at time 

<math display="inline" id="Equation-free_modeling:1">
 <semantics>
  <msub>
   <mi>t</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{k}
  </annotation>
 </semantics>
</math>

, the coarse time-stepper involves four steps:</p>
<ul>
<li>Lifting, creates microscale initial conditions 

<math display="inline" id="Equation-free_modeling:2">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>t</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>u</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(t_{k})
  </annotation>
 </semantics>
</math>

, consistent with the macrostate 

<math display="inline" id="Equation-free_modeling:3">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>t</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(t_{k})
  </annotation>
 </semantics>
</math>

;</li>
<li>Simulation, uses the microscale simulator to compute the microscale state 

<math display="inline" id="Equation-free_modeling:4">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>u</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(t)
  </annotation>
 </semantics>
</math>

 at over a short interval 

<math display="inline" id="Equation-free_modeling:5">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mi>k</mi>
   </msub>
   <mo>≤</mo>
   <mi>t</mi>
   <mo>≤</mo>
   <mrow>
    <msub>
     <mi>t</mi>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi>δ</mi>
     <mi>t</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>k</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <ci>δ</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{k}\leq t\leq t_{k}+\delta t
  </annotation>
 </semantics>
</math>

;</li>
<li>Restriction, obtains the macrostate 

<math display="inline" id="Equation-free_modeling:6">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>t</mi>
      <mi>k</mi>
     </msub>
     <mo>+</mo>
     <mrow>
      <mi>δ</mi>
      <mi>t</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <ci>δ</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(t_{k}+\delta t)
  </annotation>
 </semantics>
</math>

 from the fine-scale state 

<math display="inline" id="Equation-free_modeling:7">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>u</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(t)
  </annotation>
 </semantics>
</math>

;</li>
<li>the Time-step, extrapolation of macrostate 

<math display="inline" id="Equation-free_modeling:8">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Equation-free_modeling:9">
 <semantics>
  <msub>
   <mi>t</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{k}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Equation-free_modeling:10">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>t</mi>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>t</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{k+1}=t_{k}+\Delta t
  </annotation>
 </semantics>
</math>

 predicts the state a macrotime in the future.</li>
</ul>

<p>Multiple time steps simulates the system into the macro-future. If the microscale model is stochastic, then an ensemble of microscale simulations may be needed to obtain sufficiently good extrapolation in the time step. Such a coarse time-stepper may be used in many algorithms of traditional continuum numerical analysis, such as numerical bifurcation analysis, optimization, control, and even accelerated coarse-scale simulation.</p>

<p>Traditionally, algebraic formulae determine time derivatives of the coarse model. In our approach, the macroscale derivative is estimated by the inner microscale simulator, in effect performing a closure on demand. A reason for the name <em>equation-free</em> is by analogy with matrix-free numerical linear algebra;<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> the name emphasizes that macro-level equations are never constructed explicitly in closed form.</p>
<h3 id="restriction">Restriction</h3>

<p>The restriction operator often follows directly from the specific choice of the macroscale variables. For example, when the microscale model evolves an ensemble of many particles, the restriction typically computes the first few moments of the particle distribution (the density, momentum, and energy).</p>
<h3 id="lifting">Lifting</h3>

<p>The lifting operator is usually much more involved. For example, consider a particle model: we need to define a mapping from a few low order moments of the particle distribution to initial conditions for each particle. The assumption that a relation exists that closes in these low order, coarse, moments, implies that the detailed microscale configurations are functionals of the moments (sometimes referred to as slaving <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a>). We assume this relationship is established/emerges on time scales that are fast compared to the overall system evolution (see <a href="slow_manifold" title="wikilink">slow manifold</a> theory and applications <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a>). Unfortunately, the closure (slaving relations) are algebraically unknown (as otherwise the coarse evolution law would be known).</p>

<p>Initializing the unknown microscale modes randomly introduces a lifting error: we rely on the separation of macro and micro time scales to ensure a quick relaxation to functionals of the coarse macrostates (healing). A preparatory step may be required, possibly involving microscale simulations constrained to keep the macrostates fixed.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> When the system has a unique fixed point for the unknown microscale details conditioned upon the coarse macrostates, a constrained runs algorithm may perform this preparatory step using only the microscale time-stepper.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="an-illustrative-example">An illustrative example</h3>

<p>A toy problem illustrates the basic concepts. For example, consider the <a href="differential_equation" title="wikilink">differential equation</a> system for two variables 

<math display="inline" id="Equation-free_modeling:11">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <times></times>
     <ci>U</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>u</ci>
     <ci>t</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (U(t),u(t))
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Equation-free_modeling:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mrow>
       <mi>d</mi>
       <mi>U</mi>
      </mrow>
      <mrow>
       <mi>d</mi>
       <mi>t</mi>
      </mrow>
     </mfrac>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mrow>
        <mo>-</mo>
        <mi>U</mi>
       </mrow>
       <mo>-</mo>
       <mi>u</mi>
      </mrow>
      <mo>+</mo>
      <mpadded width="+1.7pt">
       <mn>2</mn>
      </mpadded>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mi>d</mi>
       <mi>u</mi>
      </mrow>
      <mrow>
       <mi>d</mi>
       <mi>t</mi>
      </mrow>
     </mfrac>
     <mo>=</mo>
     <mrow>
      <mn>100</mn>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>U</mi>
         <mn>3</mn>
        </msup>
        <mo>-</mo>
        <mi>u</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>U</ci>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <minus></minus>
        <ci>U</ci>
       </apply>
       <ci>u</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>u</ci>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">100</cn>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>U</ci>
        <cn type="integer">3</cn>
       </apply>
       <ci>u</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{dU}{dt}=-U-u+2\,,\quad\frac{du}{dt}=100(U^{3}-u).
  </annotation>
 </semantics>
</math>

 Capital 

<math display="inline" id="Equation-free_modeling:13">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 denotes the presumed macroscale variable, and lowercase 

<math display="inline" id="Equation-free_modeling:14">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 the microscale variable. This classification means that we assume a coarse model of the form 

<math display="inline" id="Equation-free_modeling:15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>d</mi>
      <mi>U</mi>
     </mrow>
     <mo>/</mo>
     <mi>d</mi>
    </mrow>
    <mi>t</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>U</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>U</ci>
      </apply>
      <ci>d</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>U</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   dU/dt=G(U)
  </annotation>
 </semantics>
</math>

 exists, although we do not necessarily know what it is. Arbitrarily define the lifting from any given macrosate 

<math display="inline" id="Equation-free_modeling:16">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Equation-free_modeling:17">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>U</mi>
    <mo>,</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>U</mi>
    <mo>,</mo>
    <mn>0.5</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <ci>U</ci>
     <ci>u</ci>
    </interval>
    <interval closure="open">
     <ci>U</ci>
     <cn type="float">0.5</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (U,u)=(U,0.5)
  </annotation>
 </semantics>
</math>

. A simulation using this lifting and the coarse time-stepper is shown in the figure. </p>

<p>The solution of the differential equation rapidly moves to the <a href="slow_manifold" title="wikilink">slow manifold</a> 

<math display="inline" id="Equation-free_modeling:18">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>≈</mo>
   <msup>
    <mi>U</mi>
    <mn>3</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>u</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>U</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\approx U^{3}
  </annotation>
 </semantics>
</math>

 for any initial data. The coarse time-stepper solution would agree better with the full solution when the 100 factor is increased. The graph shows the lifted solution (blue solid line) 

<math display="inline" id="Equation-free_modeling:19">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>U</mi>
   <mo>,</mo>
   <mi>u</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>U</ci>
    <ci>u</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (U,u)
  </annotation>
 </semantics>
</math>

. At times 

<math display="inline" id="Equation-free_modeling:20">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mi>n</mi>
    <mi>δ</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>δ</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=n\delta t
  </annotation>
 </semantics>
</math>

, the solution is restricted and then lifted again, which here is simply setting 

<math display="inline" id="Equation-free_modeling:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mi>δ</mi>
      <mi>t</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>u</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>δ</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <cn type="float">0.5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(n\delta t)=0.5
  </annotation>
 </semantics>
</math>

. The slow manifold is shown as a red line. The right plot shows the time derivative of the restricted solution as a function of time (blue curve), as well as the time derivative 

<math display="inline" id="Equation-free_modeling:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mi>U</mi>
    </mrow>
    <mo>/</mo>
    <mi>d</mi>
   </mrow>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>U</ci>
     </apply>
     <ci>d</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   dU/dt
  </annotation>
 </semantics>
</math>

 (the coarse time derivative), as observed from a full simulation (red curve).</p>
<h3 id="on-application-to-concrete-multiscale-problems">On application to concrete multiscale problems</h3>

<p>The equation-free approach has been applied to many examples. They examples illustrate the various ways to construct and assemble the algorithmic building blocks. Numerical analysis establishes the accuracy and efficiency of this approach. Additional numerical analysis on other methods of this type has also been done.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>Applying the equation-free paradigm to a real problem requires considerable care, especially defining the lifting and restriction operators, and the appropriate outer solver.</p>
<ul>
<li>The first challenge is to identify the macroscale observables. They need to be complete enough so that the unknown microscale variables can be reliably reconstructed (lifted). Physical arguments often the identify the macroscale observables. Almost always one invokes densities, but there are some surprisingly simple examples where correlation functions are essential macroscale variables.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> If not resorting to physical arguments, then modern data-mining or manifold learning techniques, such as Isomap or diffusion maps, may obtain the macroscale variables from microscale simulation.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></li>
<li>There should be a clear separation between the time-scales of the macroscale observables and the time-scales of the remaining microscale modes quasi-equilibrate given any macrostate.</li>
<li>Knowing the macroscale observables might not be sufficient. One strategy to obtain such information is the baby-bathwater scheme which uses only appropriately initialized simulations.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></li>
</ul>
<h2 id="coarse-bifurcation-analysis">Coarse bifurcation analysis</h2>

<p>The recursive projection method<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> enables the computation of <a href="bifurcation_diagram" title="wikilink">bifurcation diagrams</a> using legacy simulation code. It also empowers the coarse time-stepper to perform equation-free bifurcation computations. Consider the coarse time stepper in its effective form</p>

<p>

<math display="block" id="Equation-free_modeling:23">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mover accent="true">
      <mi>U</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>=</mo>
    <mrow>
     <mover accent="true">
      <mi>S</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mover accent="true">
        <mi>U</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mi>n</mi>
      </msup>
      <mo>,</mo>
      <mi>λ</mi>
      <mo>;</mo>
      <mrow>
       <mi>δ</mi>
       <mi>t</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-→</ci>
      <ci>U</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-→</ci>
      <ci>S</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-→</ci>
        <ci>U</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <ci>λ</ci>
      <apply>
       <times></times>
       <ci>δ</ci>
       <ci>t</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{U}^{n+1}=\vec{S}(\vec{U}^{n},\lambda;\delta t),
  </annotation>
 </semantics>
</math>

 which includes explicit dependence upon one or more parameters 

<math display="inline" id="Equation-free_modeling:24">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

. Bifurcation analysis computes <a href="List_of_types_of_equilibrium" title="wikilink">equilibria</a> or <a href="periodic_orbit" title="wikilink">periodic orbits</a>, their stability and dependence upon parameter 

<math display="inline" id="Equation-free_modeling:25">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

.</p>

<p>Compute a coarse equilibrium as a <a href="fixed_point_(mathematics)" title="wikilink">fixed point</a> of the coarse time stepper</p>

<p>

<math display="block" id="Equation-free_modeling:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>U</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo>-</mo>
     <mrow>
      <mover accent="true">
       <mi>S</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mrow>
       <mo stretchy="false">(</mo>
       <mover accent="true">
        <mi>U</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mo>,</mo>
       <mi>λ</mi>
       <mo>;</mo>
       <mrow>
        <mi>δ</mi>
        <mi>t</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mover accent="true">
     <mn>0</mn>
     <mo stretchy="false">→</mo>
    </mover>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-→</ci>
      <ci>U</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-→</ci>
       <ci>S</ci>
      </apply>
      <vector>
       <apply>
        <ci>normal-→</ci>
        <ci>U</ci>
       </apply>
       <ci>λ</ci>
       <apply>
        <times></times>
        <ci>δ</ci>
        <ci>t</ci>
       </apply>
      </vector>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{U}-\vec{S}(\vec{U},\lambda;\delta t)=\vec{0}.
  </annotation>
 </semantics>
</math>

 In the equation-free context, the recursive projection method is the outer solver of this equation, and the coarse time-stepper enables this method to be performed using fine scale dynamics.</p>

<p>Additionally, for problems where the macroscale has continuous symmetries, one can use a template based approach <a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> to compute coarse <a class="uri" href="self-similar" title="wikilink">self-similar</a> or <a href="travelling_wave" title="wikilink">travelling wave</a> solutions as fixed points of a coarse time-stepper that also encodes appropriate rescaling and/or shifting of space-time and/or solution. For example, self-similar diffusion solutions may be found as the <a href="probability_density_function" title="wikilink">probability density function</a> of detailed <a href="molecular_dynamics" title="wikilink">molecular dynamics</a>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>An alternative to the recursive projection method is to use Newton--Krylov methods.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h2 id="coarse-projective-integration">Coarse projective integration</h2>

<p>The coarse time stepper accelerates simulation over large macroscale times. In the scheme described above, let the large macro-time-step 

<math display="inline" id="Equation-free_modeling:27">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>t</mi>
   </mrow>
   <mo>≫</mo>
   <mrow>
    <mi>δ</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">much-greater-than</csymbol>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>δ</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta t\gg\delta t
  </annotation>
 </semantics>
</math>

, and be on the time scale of the slow coarse dynamics. Let the computed 

<math display="inline" id="Equation-free_modeling:28">
 <semantics>
  <mrow>
   <msup>
    <mi>U</mi>
    <mi>n</mi>
   </msup>
   <mo>≈</mo>
   <mrow>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mi mathvariant="normal">Δ</mi>
      <mi>t</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>U</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>U</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>normal-Δ</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U^{n}\approx U(n\Delta t)
  </annotation>
 </semantics>
</math>

 in terms of the coarse variable, and let the microscale simulation compute 

<math display="inline" id="Equation-free_modeling:29">
 <semantics>
  <mrow>
   <msup>
    <mi>U</mi>
    <mrow>
     <mi>n</mi>
     <mo>,</mo>
     <mi>k</mi>
    </mrow>
   </msup>
   <mo>≈</mo>
   <mrow>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>n</mi>
       <mi mathvariant="normal">Δ</mi>
       <mi>t</mi>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>k</mi>
       <mi>δ</mi>
       <mi>t</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>U</ci>
     <list>
      <ci>n</ci>
      <ci>k</ci>
     </list>
    </apply>
    <apply>
     <times></times>
     <ci>U</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>normal-Δ</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <ci>k</ci>
       <ci>δ</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U^{n,k}\approx U(n\Delta t+k\delta t)
  </annotation>
 </semantics>
</math>

 from a local time simulation with initial condition that the coarse variable 

<math display="inline" id="Equation-free_modeling:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mi mathvariant="normal">Δ</mi>
      <mi>t</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>U</mi>
    <mi>n</mi>
   </msup>
   <mo>=</mo>
   <msup>
    <mi>U</mi>
    <mrow>
     <mi>n</mi>
     <mo>,</mo>
     <mn>0</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>U</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>normal-Δ</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>U</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>U</ci>
      <list>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(n\Delta t)=U^{n}=U^{n,0}
  </annotation>
 </semantics>
</math>

. Then we approximate 

<math display="inline" id="Equation-free_modeling:31">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>t</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U((n+1)\Delta t)
  </annotation>
 </semantics>
</math>

 via extrapolating over a gap by</p>

<p>

<math display="block" id="Equation-free_modeling:32">
 <semantics>
  <mrow>
   <msup>
    <mi>U</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>U</mi>
     <mrow>
      <mi>n</mi>
      <mo>,</mo>
      <mi>k</mi>
     </mrow>
    </msup>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi mathvariant="normal">Δ</mi>
        <mi>t</mi>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>k</mi>
        <mi>δ</mi>
        <mi>t</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mover accent="true">
        <mi>U</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mi>n</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>U</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>U</ci>
      <list>
       <ci>n</ci>
       <ci>k</ci>
      </list>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <ci>k</ci>
        <ci>δ</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <ci>F</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-→</ci>
        <ci>U</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U^{n+1}=U^{n,k}+(\Delta t-k\delta t)F(\vec{U}^{n})
  </annotation>
 </semantics>
</math>

 where, for example, simple linear extrapolation would be</p>

<p>

<math display="block" id="Equation-free_modeling:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mover accent="true">
       <mi>U</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mi>n</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>U</mi>
        <mrow>
         <mi>n</mi>
         <mo>,</mo>
         <mi>k</mi>
        </mrow>
       </msup>
       <mo>-</mo>
       <msup>
        <mi>U</mi>
        <mrow>
         <mi>n</mi>
         <mo>,</mo>
         <mrow>
          <mi>k</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mrow>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>/</mo>
     <mi>δ</mi>
    </mrow>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-→</ci>
       <ci>U</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>U</ci>
        <list>
         <ci>n</ci>
         <ci>k</ci>
        </list>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>U</ci>
        <list>
         <ci>n</ci>
         <apply>
          <minus></minus>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </list>
       </apply>
      </apply>
      <ci>δ</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\vec{U}^{n})=(U^{n,k}-U^{n,k-1})/\delta t
  </annotation>
 </semantics>
</math>

 This scheme is the called coarse projective forward Euler, and is the simplest in the class.</p>

<p>The 

<math display="inline" id="Equation-free_modeling:34">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 steps taken before the extrapolation reflect that we must allow the system to settle onto a quasi-equilibrium (from the microscale point of view), so that we can make a reliable extrapolation of the slow dynamics. Then the size of the projective integration step is limited by stability of the slow modes.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>Higher order versions of coarse projective integration can be formed, analogous to <a class="uri" href="Adams-Bashforth" title="wikilink">Adams-Bashforth</a> or <a class="uri" href="Runge-Kutta" title="wikilink">Runge-Kutta</a>.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> Higher order schemes for systems where the microscale noise is still apparent on the macroscale time step are more problematic.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h2 id="patch-dynamics">Patch dynamics</h2>

<p>The spatial analogue of projective integration is the gap-tooth scheme. The idea of the gap-tooth scheme is to perform simulations of small patches of space, the teeth, separated by unsimulated space, the gaps. By appropriately coupling the small patches of simulations we create a large scale, coarse level, simulation of the spatially extended system. When the microscale simulator is computationally expensive the gap-tooth scheme empowers efficient large scale prediction. Furthermore, it does this without us ever having to identify an algebraic closure for a large scale model. <a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a><a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>

<p>The combination of the gap-tooth scheme with coarse projective integration is called patch dynamics.</p>
<h3 id="coupling-boundary-conditions">Coupling boundary conditions</h3>

<p>The key to the gap-tooth and patch scheme is the coupling of the small patches across unsimulated space. Surprisingly, the generic answer is to simply use classic Lagrange interpolation, whether in one dimension<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> or multiple dimensions.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> This answer is related to the coupling in <a href="holistic_discretization" title="wikilink">holistic discretization</a> and theoretical support provided by the theory of <a href="slow_manifold" title="wikilink">slow manifolds</a>. The interpolation provides value or flux boundary conditions as required by the microscale simulator. High order consistency between the macroscale gap-tooth/patch scheme and the microscale simulation is achieved through high order Lagrange interpolation.</p>

<p>However, commonly the microscale is a noisy particle based or <a href="agent-based_model" title="wikilink">agent-based model</a>. In such cases the relevant macroscale variables are averages such as mass and momentum density. Then one generally has to form averages over a core of each tooth/patch, and apply the coupling condition over a finite action region on the edges of each tooth/patch. The provisional recommendation is to make these regions as big as half the tooth/patch.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> That is, for efficiency one makes the microscale tooth/patch as small as possible, but limited by the need to fit in action and core regions big enough to form accurate enough averages.</p>
<h3 id="lifting-1">Lifting</h3>

<p>Patch dynamics is the combination of the gap-tooth scheme and coarse projective integration. Just as for normal projective integration, at the start of each burst of microscale simulation, one has to create an initial condition for each patch that is consistent with the local macroscale variables, and the macroscale gradients from neighboring interpolated patches. The same techniques suffice.</p>
<h2 id="open-problems-and-future-directions">Open problems and future directions</h2>

<p>Assumptions and choices about the macroscale evolution are crucial in the equation-free scheme. The key assumption is that the variables we choose for the macroscale coupling must effectively close on the chosen macroscale. If the chosen macroscale length is too small then more coarse scale variables may be needed: for example, in fluid dynamics we conventionally close the PDEs for density, momentum and energy; yet in high speed flow especially at lower densities we need to resolve modes of molecular vibration because they have not equilibrated on the time scales of the fluid flow. Qualitatively the same considerations apply to the equation-free approach.</p>

<p>For many systems appropriate coarse variables are more-or-less known by experience. However, in complex situations there is a need to automatically detect the appropriate coarse variables, and then use them in the macroscale evolution. This needs much more research utilizing techniques from data mining and manifold learning. In some problems it could be that as well as densities, the appropriate coarse variables also need to include spatial correlations, as in the so-called Brownian bugs. <a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>

<p>The macroscale may have to be treated as a stochastic system, but then the errors are likely to be much larger and the closures more uncertain.</p>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Algorithms_and_data_structures" title="wikilink">Category:Algorithms and data structures</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">C. T. Kelley. <em>Iterative Methods for linear and nonlinear equations</em>, SIAM, Philadelphia, 1995.<a href="#fnref3">↩</a></li>
<li id="fn4">H. Haken. Slaving principle revisited. <em>Physica D</em>, 97:95--103, 1996.<a href="#fnref4">↩</a></li>
<li id="fn5">A. J. Roberts. Effectively model dynamics, deterministic and stochastic, across multiple space and time scales. In J. G. Hartnett and P. C. Abbott, editors, <em>Frontiers of Fundamental and Computational Physics: 10th International Symposium</em>, volume 1246, pages 75--87. AIP, 2010.<a href="#fnref5">↩</a></li>
<li id="fn6">J. P. Ryckaert, G. Ciccotti, and H. Berendsen. Numerical integration of the Cartesian equation of motion of a system with constraints: molecular dynamics of N-alkanes. <em>J. Comp. Phys.</em>, 23:237, 1977.<a href="#fnref6">↩</a></li>
<li id="fn7">C. W. Gear, T. J. Kaper, I. G. Kevrekidis, and A. Zagaris. Projecting to a Slow Manifold: Singularly Perturbed Systems and Legacy Codes. <em>SIAM Journal on Applied Dynamical Systems</em> 4(3):711--732, 2005.<a href="#fnref7">↩</a></li>
<li id="fn8">W. E and B. Engquist (2003). The heterogeneous multiscale methods <em>Comm. Math. Sciences</em> 1(1):87--132.<a href="#fnref8">↩</a></li>
<li id="fn9">W. R. Young, A. J. Roberts, and G. Stuhne. Reproductive pair correlations and the clustering of organisms. Nature, 412:328--331, 2001.<a href="#fnref9">↩</a></li>
<li id="fn10">R. R. Coifman et al. (2005). Geometric diffusions as a tool for harmonic analysis and structure definition of data: Diffusion maps Proceedings of the National Academy of Sciences 102(21):7426--7431.<a href="#fnref10">↩</a></li>
<li id="fn11">J. Li, P. G. Kevrekidis, C. W. Gear and I. G. Kevrekidis (2003). Deciding the nature of the coarse equation through microscopic simulations: the baby-bathwater scheme <em>SIAM Multiscale Modeling and Simulation</em> 1(3):391--407.<a href="#fnref11">↩</a></li>
<li id="fn12">G.M. Schroff and H.B. Keller (1993). Stabilization of unstable procedures: the recursive projection method <em>SIAM Journal on Numerical Analysis</em> 30: 1099-1120.<a href="#fnref12">↩</a></li>
<li id="fn13">C. Rowley and J. Marsden (2000). Reconstruction equations and the Karhunen-Loeve expansion for systems with symmetry <em>Physica D: Nonlinear Phenomena</em> 142: 1-19.<a href="#fnref13">↩</a></li>
<li id="fn14">L. Chen, P. Debenedetti, C.W. Gear, and I.G. Kevrekidis (2004). From molecular dynamics to coarse self-similar solutions: a simple example using equation-free computation <em>Journal of Non-Newtonian Fluid Mechanics</em> 120: 215-223.<a href="#fnref14">↩</a></li>
<li id="fn15">C.T. Kelley (1995). <em>Iterative Methods for linear and nonlinear equations</em> SIAM, Philadelphia.<a href="#fnref15">↩</a></li>
<li id="fn16">C.W. Gear and I.G. Kevrekidis. Projective methods for stiff differential equations: problems with gaps in their eigenvalue spectrum . <em>SIAM Journal on Scientific Computing</em> 24(4):1091--1106, 2003.<a href="#fnref16">↩</a></li>
<li id="fn17">C.W. Gear; I.G. Kevrekidis and . Theodoropoulos. Coarse integration/bifurcation analysis via microscopic simulators: micro-Galerkin methods <em>Computers and Chemical Engineering</em> 26: 941--963, 2002.<a href="#fnref17">↩</a></li>
<li id="fn18">X. Chen, A. J. Roberts, and I. G. Kevrekidis. Projective integration of expensive multiscale stochastic simulation. In W. McLean and A. J. Roberts, editors, <em>Proceedings of the 15th Biennial Computational Techniques and Applications Conference, CTAC-2010, volume 52 of ANZIAM J.</em>, pages C661--C677, Aug. 2011. <a class="uri" href="http://journal.austms.org.au/ojs/">http://journal.austms.org.au/ojs/</a> index.php/ANZIAMJ/article/view/3764<a href="#fnref18">↩</a></li>
<li id="fn19">Kevrekidis, I.G. et al. (2003). Equation-free, coarse-grained multiscale computation: enabling microscopic simulators to perform system-level tasks <em>Comm. Math. Sciences</em> 1(4): 715-762.<a href="#fnref19">↩</a></li>
<li id="fn20">Samaey, G.; Roose, D. and Kevrekidis, I.G. (2005). The gap-tooth scheme for homogenization problems <em>SIAM Multiscale Modeling and Simulation</em> 4: 278-306.<a href="#fnref20">↩</a></li>
<li id="fn21">Roberts, A.J. and Kevrekidis, I.G. (2007). General tooth boundary conditions for equation free modelling <em>SIAM J. Scientific Computing</em> 29(4): 1495-1510.<a href="#fnref21">↩</a></li>
<li id="fn22"></li>
<li id="fn23">A. J. Roberts, T. MacKenzie, and J. Bunder. A dynamical systems approach to simulating macroscale spatial dynamics in multiple dimensions. <em>J. Engineering Mathematics</em>, 86(1):175–207, 2014.<a href="#fnref23">↩</a></li>
<li id="fn24">J. E. Bunder, A. J. Roberts, and I. Kevrekidis. Better buffers for patches in macroscale simulation of systems with microscale randomness. Technical report, <a href="http://arxiv.org/abs/1312.1415">1</a>, Dec 2013.<a href="#fnref24">↩</a></li>
<li id="fn25">W. R. Young, A. J. Roberts, and G. Stuhne. Reproductive pair correlations and the clustering of organisms. <em>Nature</em>, 412:328--331, 2001.<a href="#fnref25">↩</a></li>
</ol>
</section>
</hr></body>
</html>
