   Literal movement grammar      Literal movement grammar   Literal movement grammars (LMGs) are a grammar formalism introduced by Groenink in 1995 1 intended to characterize certain extraposition phenomena of natural language such as topicalization and cross-serial dependencies. LMGs extend the class of CFGs by adding introducing pattern-matched function-like rewrite semantics, as well as the operations of variable binding and slash deletion.  Description  The basic rewrite operation of an LMG is very similar to that of a CFG, with the addition of "arguments" to the non-terminal symbols. Where a context-free rewrite rule obeys the general schema    S  →  α     normal-→  S  α    S\to\alpha   for some non-terminal   S   S   S   and some string of terminals and/or non-terminals   α   α   \alpha   , an LMG rewrite rule obeys the general schema     X   (   x  1   ,  …  ,   x  n   )    →  α     normal-→    X    subscript  x  1   normal-…   subscript  x  n     α    X(x_{1},...,x_{n})\to\alpha   , where X is a non-terminal with arity n (called a predicate in LMG terminology), and   α   α   \alpha   is a string of "items", as defined below. The arguments    x  i     subscript  x  i    x_{i}   are strings of terminal symbols and/or variable symbols defining an argument pattern. In the case where an argument pattern has multiple adjacent variable symbols, the argument pattern will match any and all partitions of the actual value that unify. Thus, if the predicate is    f   (   x  y   )       f    x  y     f(xy)   and the actual pattern is    f   (   a  b   )       f    a  b     f(ab)   , there are three valid matches     x  =  ϵ   ,    y  =   a  b    ;    x  =  a   ,    y  =  b   ;    x  =   a  b    ,   y  =  ϵ          formulae-sequence    x  ϵ    formulae-sequence    y    a  b     formulae-sequence    x  a    formulae-sequence    y  b    formulae-sequence    x    a  b      y  ϵ         x=\epsilon,\ y=ab;\ x=a,\ y=b;\ x=ab,\ y=\epsilon   . In this way, a single rule is actually a family of alternatives.  An "item" in a literal movement grammar is one of       f   (   x  1   ,  …  ,   x  n   )       f    subscript  x  1   normal-…   subscript  x  n      f(x_{1},\ldots,x_{n})   , a predicate of arity n,      x  :  f   (   x  1   ,  …  ,   x  n   )       x  :  f    subscript  x  1   normal-…   subscript  x  n      x\text{:}f(x_{1},\ldots,x_{n})   , a variable binding x to the string produced by    f   (   x  1   ,  …  ,   x  n   )       f    subscript  x  1   normal-…   subscript  x  n      f(x_{1},...,x_{n})   , or       f   (   x  1   ,  …  ,   x  n   )    /  α        f    subscript  x  1   normal-…   subscript  x  n     α    f(x_{1},\ldots,x_{n})/\alpha   , a slash deletion of    f   (   x  1   ,  …  ,   x  n   )       f    subscript  x  1   normal-…   subscript  x  n      f(x_{1},...,x_{n})   by the string of terminals and/or variables   α   α   \alpha   .   In a rule like     f   (   x  1   ,  …  ,   x  m   )    →    α   y  :  g   (   z  1   ,   …   z  n    )   β      normal-→    f    subscript  x  1   normal-…   subscript  x  m       α  y  :  g    subscript  z  1     normal-…   subscript  z  n     β     f(x_{1},...,x_{m})\to\alpha\ y\text{:}g(z_{1},...z_{n})\ \beta   , the variable y is bound to whatever terminal string the g predicate produces, and in   α   α   \alpha   and   β   β   \beta   , all occurrences of y are replaced by that string, and   α   α   \alpha   and   β   β   \beta   are produced as if terminal string had always been there.  An item    x  /  y      x  y    x/y   , where x is something that produces a terminal string (either a terminal string itself or some predicate), and y is a string of terminals and/or variables, is rewritten as the empty string (   ϵ   ϵ   \epsilon   ) if and only if     g   (   y  1   ,  …  ,   y  n   )    =  z        g    subscript  y  1   normal-…   subscript  y  n     z    g(y_{1},...,y_{n})=z   , and otherwise cannot be rewritten at all.  Example  LMGs can characterize the non-CF language    {    a  n    b  n    c  n    :   n  ≥  1   }     conditional-set     superscript  a  n    superscript  b  n    superscript  c  n      n  1     \{a^{n}b^{n}c^{n}:n\geq 1\}   as follows:       S   (  )    →   x  :  A   (  )   B   (  x  )       normal-→    S      x  :  A   B  x     S()\to x\text{:}A()\ B(x)          A   (  )    →    a   A   (  )       normal-→    A      a  A      A()\to a\ A()          A   (  )    →  ϵ     normal-→    A    ϵ    A()\to\epsilon          B   (   x  y   )    →    a  /   x     b   B   (  y  )   c      normal-→    B    x  y        a  x   b  B  y  c     B(xy)\to a/x\ b\ B(y)c          B   (  ϵ  )    →  ϵ     normal-→    B  ϵ   ϵ    B(\epsilon)\to\epsilon     The derivation for aabbcc , using parentheses also for grouping, is therefore       S   (  )    →   x  :  A   (  )   B   (  x  )    →   x  :   (    a   A   (  )    )   B   (  x  )    →   x  :   (   a   a   A   (  )    )   B   (  x  )    →   x  :  a   a   B   (  x  )    →   a   a   B   (   a  a   )         normal-→    S      x  :  A   B  x     normal-→      x  :    a  A    B  x     normal-→      x  :    a  a  A    B  x     normal-→      x  :  a  a  B  x     normal-→      a  a  B    a  a       S()\to x\text{:}A()\ B(x)\to x\text{:}(a\ A())\ B(x)\to x\text{:}(aa\ A())\ B(%
 x)\to x\text{:}aa\ B(x)\to aa\ B(aa)          →     a   a   a   /   a     b   B   (  a  )   c   →   a  a   b   B   (  a  )   c   →     a  a   b   a   /   a     b   B   (  )   c  c   →   a  a  b   b   B   (  )   c   c    →   a  a  b  b  c  c        normal-→  absent        a  a  a   a   b  B  a  c     normal-→      a  a  b  B  a  c     normal-→          a  a  b  a   a   b  B   c  c     normal-→      a  a  b  b  B   c  c     normal-→      a  a  b  b  c  c      \to aa\ a/a\ b\ B(a)\ c\to aab\ B(a)\ c\to aab\ a/a\ b\ B()\ cc\to aabb\ B()\ %
 cc\ \to aabbcc     Computational Power  Languages generated by LMGs contain the context-free languages as a proper subset, as every CFG is an LMG where all predicates have arity 0 and no production rule contains variable bindings or slash deletions.  References    "  Category:Formal languages  Category:Grammar frameworks     Groenink, Annius V. 1995. Literal Movement Grammars. In Proceedings of the 7th EACL Conference . ↩     