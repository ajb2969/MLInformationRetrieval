   Dynamic logic (modal logic)      Dynamic logic (modal logic)   Dynamic logic is an extension of modal logic originally intended for reasoning about computer programs and later applied to more general complex behaviors arising in linguistics , philosophy , AI , and other fields.  Language  Modal logic is characterized by the modal operators     □  p      normal-□  p    \Box p   (box p) asserting that   p   p   p\,\!   is necessarily the case, and    ◇  p      normal-◇  p    \Diamond p   (diamond p) asserting that   p   p   p\,\!   is possibly the case. Dynamic logic extends this by associating to every action   a   a   a\,\!   the modal operators    [  a  ]     delimited-[]  a    [a]\,\!   and    ⟨  a  ⟩     delimited-⟨⟩  a    \langle a\rangle\,\!   , thereby making it a multimodal logic . The meaning of     [  a  ]   p       delimited-[]  a   p    [a]p\,\!   is that after performing action   a   a   a\,\!   it is necessarily the case that   p   p   p\,\!   holds, that is,   a   a   a\,\!   must bring about   p   p   p\,\!   . The meaning of     ⟨  a  ⟩   p       delimited-⟨⟩  a   p    \langle a\rangle p\,\!   is that after performing   a   a   a\,\!   it is possible that   p   p   p\,\!   holds, that is,   a   a   a\,\!   might bring about   p   p   p\,\!   . These operators are related by      [  a  ]   p   ≡    ¬   ⟨  a  ⟩    ¬  p          delimited-[]  a   p       a    p     [a]p\equiv\neg\langle a\rangle\neg p\,\!   and      ⟨  a  ⟩   p   ≡    ¬   [  a  ]    ¬  p          delimited-⟨⟩  a   p       a    p     \langle a\rangle p\equiv\neg[a]\neg p\,\!   , analogously to the relationship between the universal (   ∀   for-all   \forall\,\!   ) and existential (   ∃     \exists\,\!   ) quantifiers.  Dynamic logic permits compound actions built up from smaller actions. While the basic control operators of any programming language could be used for this purpose, Kleene's regular expression operators are a good match to modal logic. Given actions   a   a   a\,\!   and   b   b   b\,\!   , the compound action    a  ∪  b      a  b    a\cup b\,\!   , choice , also written    a  +  b      a  b    a+b\,\!   or    a  |  b     fragments  a  normal-|  b    a|b\,\!   , is performed by performing one of   a   a   a\,\!   or   b   b   b\,\!   . The compound action    a  ;  b     a  b    a;b\,\!   , sequence , is performed by performing first   a   a   a\,\!   and then   b   b   b\,\!   . The compound action    a  *     fragments  a     a*\,\!   , iteration , is performed by performing   a   a   a\,\!   zero or more times, sequentially. The constant action   0   0   0\,\!   or BLOCK does nothing and does not terminate, whereas the constant action   1   1   1\,\!   or SKIP or NOP , definable as    0  *     fragments  0     0*\,\!   , does nothing but does terminate.  Axioms  These operators can be axiomatized in dynamic logic as follows, taking as already given a suitable axiomatization of modal logic including such axioms for modal operators as the above-mentioned axiom      [  a  ]   p   ≡    ¬   ⟨  a  ⟩    ¬  p          delimited-[]  a   p       a    p     [a]p\equiv\neg\langle a\rangle\neg p\,\!   and the two inference rules modus ponens (     ⊢   p      proves  absent  p    \vdash p\!   and     ⊢   p  →   q       proves  absent   normal-→  p  q     \vdash p\to q\!   implies     ⊢  q     proves  absent  q    \vdash q\,\!   ) and necessitation (     ⊢   p      proves  absent  p    \vdash p\!   implies     ⊢    [  a  ]   p      proves  absent     delimited-[]  a   p     \vdash[a]p\,\!   ).  A1.     [  0  ]   p       delimited-[]  0   p    [0]p\,\!     A2.      [  1  ]   p   ≡  p         delimited-[]  1   p   p    [1]p\equiv p\,\!     A3.      [   a  ∪  b   ]   p   ≡     [  a  ]   p   ∧    [  b  ]   p           delimited-[]    a  b    p        delimited-[]  a   p      delimited-[]  b   p      [a\cup b]p\equiv[a]p\land[b]p\,\!     A4.      [  a  ;  b  ]   p   ≡    [  a  ]    [  b  ]   p          a  b   p      delimited-[]  a    delimited-[]  b   p     [a;b]p\equiv[a][b]p\,\!     A5.     [  a  *  ]   p  ≡  p  ∧   [  a  ]    [  a  *  ]   p     fragments   fragments  normal-[  a   normal-]   p   p    fragments  normal-[  a  normal-]    fragments  normal-[  a   normal-]   p    [a*]p\equiv p\land[a][a*]p\,\!     A6.    p  ∧   [  a  *  ]    (  p  →   [  a  ]   p  )   →   [  a  *  ]   p     fragments  p    fragments  normal-[  a   normal-]    fragments  normal-(  p  normal-→   fragments  normal-[  a  normal-]   p  normal-)   normal-→   fragments  normal-[  a   normal-]   p    p\land[a*](p\to[a]p)\to[a*]p\,\!     Axiom A1 makes the empty promise that when BLOCK terminates,   p   p   p\,\!   will hold, even if   p   p   p\,\!   is the proposition false . (Thus BLOCK abstracts the essence of the action of hell freezing over.) A2 says that [NOP] acts as the identity function on propositions, that is, it transforms   p   p   p\,\!   into itself. A3 says that if doing one of   a   a   a\,\!   or   b   b   b\,\!   must bring about   p   p   p\,\!   , then   a   a   a\,\!   must bring about   p   p   p\,\!   and likewise for   b   b   b\,\!   , and conversely. A4 says that if doing   a   a   a\,\!   and then   b   b   b\,\!   must bring about   p   p   p\,\!   , then   a   a   a\,\!   must bring about a situation in which   b   b   b\,\!   must bring about   p   p   p\,\!   . A5 is the evident result of applying A2, A3 and A4 to the equation    a  *  =  1  ∪  a  ;  a  *     fragments  a    1   a  normal-;  a     a*=1\cup a;a*\,\!   of Kleene algebra . A6 asserts that if   p   p   p\,\!   holds now, and no matter how often we perform   a   a   a\,\!   it remains the case that the truth of   p   p   p\,\!   after that performance entails its truth after one more performance of   a   a   a\,\!   , then   p   p   p\,\!   must remain true no matter how often we perform   a   a   a\,\!   . A6 is recognizable as mathematical induction with the action n := n+1 of incrementing n generalized to arbitrary actions   a   a   a\,\!   .  Derivations  The modal logic axiom      [  a  ]   p   ≡    ¬   ⟨  a  ⟩    ¬  p          delimited-[]  a   p       a    p     [a]p\equiv\neg\langle a\rangle\neg p\,\!   permits the derivation of the following six theorems corresponding to the above:  T1.     ¬   ⟨  0  ⟩    p        0   p    \neg\langle 0\rangle p\,\!     T2.      ⟨  1  ⟩   p   ≡  p         delimited-⟨⟩  1   p   p    \langle 1\rangle p\equiv p\,\!     T3.      ⟨   a  ∪  b   ⟩   p   ≡     ⟨  a  ⟩   p   ∨    ⟨  b  ⟩   p           delimited-⟨⟩    a  b    p        delimited-⟨⟩  a   p      delimited-⟨⟩  b   p      \langle a\cup b\rangle p\equiv\langle a\rangle p\lor\langle b\rangle p\,\!     T4.      ⟨  a  ;  b  ⟩   p   ≡    ⟨  a  ⟩    ⟨  b  ⟩   p          a  b   p      delimited-⟨⟩  a    delimited-⟨⟩  b   p     \langle a;b\rangle p\equiv\langle a\rangle\langle b\rangle p\,\!     T5.     ⟨  a  *  ⟩   p  ≡  p  ∨   ⟨  a  ⟩    ⟨  a  *  ⟩   p     fragments   fragments  normal-⟨  a   normal-⟩   p   p    fragments  normal-⟨  a  normal-⟩    fragments  normal-⟨  a   normal-⟩   p    \langle a*\rangle p\equiv p\lor\langle a\rangle\langle a*\rangle p\,\!     T6.     ⟨  a  *  ⟩   p  →  p  ∨   ⟨  a  *  ⟩    (  ¬  p  ∧   ⟨  a  ⟩   p  )      fragments   fragments  normal-⟨  a   normal-⟩   p  normal-→  p    fragments  normal-⟨  a   normal-⟩    fragments  normal-(   p    fragments  normal-⟨  a  normal-⟩   p  normal-)     \langle a*\rangle p\to p\lor\langle a*\rangle(\neg p\land\langle a\rangle p)\,\!     T1 asserts the impossibility of bringing anything about by performing BLOCK . T2 notes again that NOP changes nothing, bearing in mind that NOP is both deterministic and terminating whence    [  1  ]     delimited-[]  1    [1]\,\!   and    ⟨  1  ⟩     delimited-⟨⟩  1    \langle 1\rangle\,\!   have the same force. T3 says that if the choice of   a   a   a\,\!   or   b   b   b\,\!   could bring about   p   p   p\,\!   , then either   a   a   a\,\!   or   b   b   b\,\!   alone could bring about   p   p   p\,\!   . T4 is just like A4. T5 is explained as for A5. T6 asserts that if it is possible to bring about   p   p   p\,\!   by performing   a   a   a\,\!   sufficiently often, then either   p   p   p\,\!   is true now or it is possible to perform   a   a   a\,\!   repeatedly to bring about a situation where   p   p   p\,\!   is (still) false but one more performance of   a   a   a\,\!   could bring about   p   p   p\,\!   .  Box and diamond are entirely symmetric with regard to which one takes as primitive. An alternative axiomatization would have been to take the theorems T1-T6 as axioms, from which we could then have derived A1-A6 as theorems.  The difference between implication and inference is the same in dynamic logic as in any other logic: whereas the implication    p  →  q     normal-→  p  q    p\to q\,\!   asserts that if   p   p   p\,\!   is true then so is   q   q   q\,\!   , the inference    p  ⊢  q     proves  p  q    p\vdash q\,\!   asserts that if   p   p   p\,\!   is valid then so is   q   q   q\,\!   . However the dynamic nature of dynamic logic moves this distinction out of the realm of abstract axiomatics into the common-sense experience of situations in flux. The inference rule    p  ⊢    [  a  ]   p      proves  p     delimited-[]  a   p     p\vdash[a]p\,\!   , for example, is sound because its premise asserts that   p   p   p\,\!   holds at all times, whence no matter where   a   a   a\,\!   might take us,   p   p   p\,\!   will be true there. The implication    p  →    [  a  ]   p      normal-→  p     delimited-[]  a   p     p\to[a]p\,\!   is not valid, however, because the truth of   p   p   p\,\!   at the present moment is no guarantee of its truth after performing   a   a   a\,\!   . For example,    p  →    [  a  ]   p      normal-→  p     delimited-[]  a   p     p\to[a]p\,\!   will be true in any situation where   p   p   p\,\!   is false, or in any situation where     [  a  ]   p       delimited-[]  a   p    [a]p\,\!   is true, but the assertion     (  x  =  1  )   →   [  x  :=  x  +  1  ]    (  x  =  1  )      fragments   fragments  normal-(  x   1  normal-)   normal-→   fragments  normal-[  x  assign  x   1  normal-]    fragments  normal-(  x   1  normal-)     (x=1)\to[x:=x+1](x=1)\,\!   is false in any situation where   x   x   x\,\!   has value 1, and therefore is not valid.  Derived rules of inference  As for modal logic, the inference rules modus ponens and necessitation suffice also for dynamic logic as the only primitive rules it needs, as noted above. However, as usual in logic, many more rules can be derived from these with the help of the axioms. An example instance of such a derived rule in dynamic logic is that if kicking a broken TV once can't possibly fix it, then repeatedly kicking it can't possibly fix it either. Writing   k   k   k\,\!   for the action of kicking the TV, and   b   b   b\,\!   for the proposition that the TV is broken, dynamic logic expresses this inference as    b  →   [  k  ]   b  ⊢  b  →   [  k  *  ]   b     fragments  b  normal-→   fragments  normal-[  k  normal-]   b  proves  b  normal-→   fragments  normal-[  k   normal-]   b    b\to[k]b\vdash b\to[k*]b\,\!   , having as premise    b  →    [  k  ]   b      normal-→  b     delimited-[]  k   b     b\to[k]b\,\!   and as conclusion    b  →   [  k  *  ]   b     fragments  b  normal-→   fragments  normal-[  k   normal-]   b    b\to[k*]b\,\!   . The meaning of     [  k  ]   b       delimited-[]  k   b    [k]b\,\!   is that it is guaranteed that after kicking the TV, it is broken. Hence the premise    b  →    [  k  ]   b      normal-→  b     delimited-[]  k   b     b\to[k]b\,\!   means that if the TV is broken, then after kicking it once it will still be broken.    k  *     fragments  k     k*\,\!   denotes the action of kicking the TV zero or more times. Hence the conclusion    b  →   [  k  *  ]   b     fragments  b  normal-→   fragments  normal-[  k   normal-]   b    b\to[k*]b\,\!   means that if the TV is broken, then after kicking it zero or more times it will still be broken. For if not, then after the second-to-last kick the TV would be in a state where kicking it once more would fix it, which the premise claims can never happen under any circumstances.  The inference    b  →   [  k  ]   b  ⊢  b  →   [  k  *  ]   b     fragments  b  normal-→   fragments  normal-[  k  normal-]   b  proves  b  normal-→   fragments  normal-[  k   normal-]   b    b\to[k]b\vdash b\to[k*]b\,\!   is sound. However the implication     (  b  →   [  k  ]   b  )   →   (  b  →   [  k  *  ]   b  )      fragments   fragments  normal-(  b  normal-→   fragments  normal-[  k  normal-]   b  normal-)   normal-→   fragments  normal-(  b  normal-→   fragments  normal-[  k   normal-]   b  normal-)     (b\to[k]b)\to(b\to[k*]b)\,\!   is not valid because we can easily find situations in which    b  →    [  k  ]   b      normal-→  b     delimited-[]  k   b     b\to[k]b\,\!   holds but    b  →   [  k  *  ]   b     fragments  b  normal-→   fragments  normal-[  k   normal-]   b    b\to[k*]b\,\!   does not. In any such counterexample situation,   b   b   b\,\!   must hold but     [  k  *  ]   b     fragments   fragments  normal-[  k   normal-]   b    [k*]b\,\!   must be false, while     [  k  ]   b       delimited-[]  k   b    [k]b\,\!   however must be true. But this could happen in any situation where the TV is broken but can be revived with two kicks. The implication fails (is not valid) because it only requires that    b  →    [  k  ]   b      normal-→  b     delimited-[]  k   b     b\to[k]b\,\!   hold now, whereas the inference succeeds (is sound) because it requires that    b  →    [  k  ]   b      normal-→  b     delimited-[]  k   b     b\to[k]b\,\!   hold in all situations, not just the present one.  An example of a valid implication is the proposition     (  x  ≥  3  )   →   [  x  :=  x  +  1  ]    (  x  ≥  4  )      fragments   fragments  normal-(  x   3  normal-)   normal-→   fragments  normal-[  x  assign  x   1  normal-]    fragments  normal-(  x   4  normal-)     (x\geq 3)\to[x:=x+1](x\geq 4)\,\!   . This says that if   x   x   x\,\!   is greater or equal to 3, then after incrementing   x   x   x\,\!   ,   x   x   x\,\!   must be greater or equal to 4. In the case of deterministic actions   a   a   a\,\!   that are guaranteed to terminate, such as    x  :=   x  +  1      assign  x    x  1     x:=x+1\,\!   , must and might have the same force, that is,    [  a  ]     delimited-[]  a    [a]\,\!   and    ⟨  a  ⟩     delimited-⟨⟩  a    \langle a\rangle\,\!   have the same meaning. Hence the above proposition is equivalent to     (  x  ≥  3  )   →   ⟨  x  :=  x  +  1  ⟩    (  x  ≥  4  )      fragments   fragments  normal-(  x   3  normal-)   normal-→   fragments  normal-⟨  x  assign  x   1  normal-⟩    fragments  normal-(  x   4  normal-)     (x\geq 3)\to\langle x:=x+1\rangle(x\geq 4)\,\!   asserting that if   x   x   x\,\!   is greater or equal to 3 then after performing    x  :=   x  +  1      assign  x    x  1     x:=x+1\,\!   ,   x   x   x\,\!   might be greater or equal to 4.  Assignment  The general form of an assignment statement is    x  :=  e     assign  x  e    x:=e\,\!   where   x   x   x\,\!   is a variable and   e   e   e\,\!   is an expression built from constants and variables with whatever operations are provided by the language, such as addition and multiplication. The Hoare axiom for assignment is not given as a single axiom but rather as an axiom schema.  A7.      [  x  :=  e  ]   Φ   (  x  )   ≡  Φ   (  e  )      fragments   fragments  normal-[  x  assign  e  normal-]   Φ   fragments  normal-(  x  normal-)    Φ   fragments  normal-(  e  normal-)     [x:=e]\Phi(x)\equiv\Phi(e)\,\!     This is a schema in the sense that    Φ   (  x  )       normal-Φ  x    \Phi(x)\,\!   can be instantiated with any formula   Φ   normal-Φ   \Phi\,\!   containing zero or more instances of a variable   x   x   x\,\!   . The meaning of    Φ   (  e  )       normal-Φ  e    \Phi(e)\,\!   is   Φ   normal-Φ   \Phi\,\!   with those occurrences of   x   x   x\,\!   that occur free in   Φ   normal-Φ   \Phi\,\!   , i.e. not bound by some quantifier as in    ∀  x     for-all  x    \forall x\,\!   , replaced by   e   e   e\,\!   . For example we may instantiate A7 with     [  x  :=  e  ]    (  x  =   y  2   )   ≡  e  =   y  2      fragments   fragments  normal-[  x  assign  e  normal-]    fragments  normal-(  x    superscript  y  2   normal-)    e    superscript  y  2     [x:=e](x=y^{2})\equiv e=y^{2}\,\!   , or with     [  x  :=  e  ]    (  b  =  c  +  x  )   ≡  b  =  c  +  e     fragments   fragments  normal-[  x  assign  e  normal-]    fragments  normal-(  b   c   x  normal-)    b   c   e    [x:=e](b=c+x)\equiv b=c+e\,\!   . Such an axiom schema allows infinitely many axioms having a common form to be written as a finite expression connoting that form.  The instance     [  x  :=  x  +  1  ]    (  x  ≥  4  )   ≡   (  x  +  1  )   ≥  4     fragments   fragments  normal-[  x  assign  x   1  normal-]    fragments  normal-(  x   4  normal-)     fragments  normal-(  x   1  normal-)    4    [x:=x+1](x\geq 4)\equiv(x+1)\geq 4\,\!   of A7 allows us to calculate mechanically that the example     [  x  :=  x  +  1  ]   x  ≥  4     fragments   fragments  normal-[  x  assign  x   1  normal-]   x   4    [x:=x+1]x\geq 4\,\!   encountered a few paragraphs ago is equivalent to     (   x  +  1   )   ≥  4        x  1   4    (x+1)\geq 4\,\!   , which in turn is equivalent to    x  ≥  3      x  3    x\geq 3\,\!   by elementary algebra .  An example illustrating assignment in combination with   *     *\,\!   is the proposition     ⟨   (  x  :=  x  +  1  )   *  ⟩   x  =  7     fragments   fragments  normal-⟨   fragments  normal-(  x  assign  x   1  normal-)    normal-⟩   x   7    \langle(x:=x+1)*\rangle x=7\,\!   . This asserts that it is possible, by incrementing   x   x   x\,\!   sufficiently often, to make   x   x   x\,\!   equal to 7. This of course is not always true, e.g. if   x   x   x\,\!   is 8 to begin with, or 6.5, whence this proposition is not a theorem of dynamic logic. If   x   x   x\,\!   is of type integer however, then this proposition is true if and only if   x   x   x\,\!   is at most 7 to begin with, that is, it is just a roundabout way of saying    x  ≤  7      x  7    x\leq 7\,\!   .  Mathematical induction can be obtained as the instance of A6 in which the proposition   p   p   p\,\!   is instantiated as    Φ   (  n  )       normal-Φ  n    \Phi(n)\,\!   , the action   a   a   a\,\!   as    n  :=   n  +  1      assign  n    n  1     n:=n+1\,\!   , and   n   n   n\,\!   as   0   0   0\,\!   . The first two of these three instantiations are straightforward, converting A6 to     (  Φ   (  n  )   ∧   [   (  n  :=  n  +  1  )   *  ]    (  Φ   (  n  )   →   [  n  :=  n  +  1  ]   Φ   (  n  )   )   )   →   [   (  n  :=  n  +  1  )   *  ]   Φ   (  n  )      fragments   fragments  normal-(  Φ   fragments  normal-(  n  normal-)     fragments  normal-[   fragments  normal-(  n  assign  n   1  normal-)    normal-]    fragments  normal-(  Φ   fragments  normal-(  n  normal-)   normal-→   fragments  normal-[  n  assign  n   1  normal-]   Φ   fragments  normal-(  n  normal-)   normal-)   normal-)   normal-→   fragments  normal-[   fragments  normal-(  n  assign  n   1  normal-)    normal-]   Φ   fragments  normal-(  n  normal-)     (\Phi(n)\land[(n:=n+1)*](\Phi(n)\to[n:=n+1]\Phi(n)))\to[(n:=n+1)*]\Phi(n)\,\!   . However, the ostensibly simple substitution of   0   0   0\,\!   for   n   n   n\,\!   is not so simple as it brings out the so-called referential opacity of modal logic in the case when a modality can interfere with a substitution.  When we substituted    Φ   (  n  )       normal-Φ  n    \Phi(n)\,\!   for   p   p   p\,\!   , we were thinking of the proposition symbol   p   p   p\,\!   as a rigid designator with respect to the modality    [   n  :=   n  +  1    ]     delimited-[]   assign  n    n  1      [n:=n+1]\,\!   , meaning that it is the same proposition after incrementing   n   n   n\,\!   as before, even though incrementing   n   n   n\,\!   may impact its truth. Likewise, the action   a   a   a\,\!   is still the same action after incrementing   n   n   n\,\!   , even though incrementing   n   n   n\,\!   will result in its executing in a different environment. However,   n   n   n\,\!   itself is not a rigid designator with respect to the modality    [   n  :=   n  +  1    ]     delimited-[]   assign  n    n  1      [n:=n+1]\,\!   ; if it denotes 3 before incrementing   n   n   n\,\!   , it denotes 4 after. So we can't just substitute   0   0   0\,\!   for   n   n   n\,\!   everywhere in A6.  One way of dealing with the opacity of modalities is to eliminate them. To this end, expand     [   (  n  :=  n  +  1  )   *  ]   Φ   (  n  )      fragments   fragments  normal-[   fragments  normal-(  n  assign  n   1  normal-)    normal-]   Φ   fragments  normal-(  n  normal-)     [(n:=n+1)*]\Phi(n)\,\!   as the infinite conjunction     [    (  n  :=  n  +  1  )   0   ]   Φ   (  n  )   ∧   [    (  n  :=  n  +  1  )   1   ]   Φ   (  n  )   ∧   [    (  n  :=  n  +  1  )   2   ]   Φ   (  n  )   ∧  …     fragments   fragments  normal-[   superscript   fragments  normal-(  n  assign  n   1  normal-)   0   normal-]   Φ   fragments  normal-(  n  normal-)     fragments  normal-[   superscript   fragments  normal-(  n  assign  n   1  normal-)   1   normal-]   Φ   fragments  normal-(  n  normal-)     fragments  normal-[   superscript   fragments  normal-(  n  assign  n   1  normal-)   2   normal-]   Φ   fragments  normal-(  n  normal-)    normal-…    [(n:=n+1)^{0}]\Phi(n)\land[(n:=n+1)^{1}]\Phi(n)\land[(n:=n+1)^{2}]\Phi(n)\land%
 \ldots\,\!   , that is, the conjunction over all   i   i   i\,\!   of     [    (  n  :=  n  +  1  )   i   ]   Φ   (  n  )      fragments   fragments  normal-[   superscript   fragments  normal-(  n  assign  n   1  normal-)   i   normal-]   Φ   fragments  normal-(  n  normal-)     [(n:=n+1)^{i}]\Phi(n)\,\!   . Now apply A4 to turn     [    (  n  :=  n  +  1  )   i   ]   Φ   (  n  )      fragments   fragments  normal-[   superscript   fragments  normal-(  n  assign  n   1  normal-)   i   normal-]   Φ   fragments  normal-(  n  normal-)     [(n:=n+1)^{i}]\Phi(n)\,\!   into     [  n  :=  n  +  1  ]    [  n  :=  n  +  1  ]   …  Φ   (  n  )      fragments   fragments  normal-[  n  assign  n   1  normal-]    fragments  normal-[  n  assign  n   1  normal-]   normal-…  Φ   fragments  normal-(  n  normal-)     [n:=n+1][n:=n+1]\ldots\Phi(n)\,\!   , having   i   i   i\,\!   modalities. Then apply Hoare's axiom   i   i   i\,\!   times to this to produce    Φ   (   n  +  i   )       normal-Φ    n  i     \Phi(n+i)\,\!   , then simplify this infinite conjunction to    ∀   i  Φ   (   n  +  i   )       for-all    i  normal-Φ    n  i      \forall i\Phi(n+i)\,\!   . This whole reduction should be applied to both instances of    [   (  n  :=  n  +  1  )   *  ]     fragments  normal-[   fragments  normal-(  n  assign  n   1  normal-)    normal-]    [(n:=n+1)*]\,\!   in A6, yielding     (  Φ   (  n  )   ∧  ∀  i   (  Φ   (  n  +  i  )   →   [  n  :=  n  +  1  ]   Φ   (  n  +  i  )   )   )   →  ∀  i  Φ   (  n  +  i  )      fragments   fragments  normal-(  Φ   fragments  normal-(  n  normal-)    for-all  i   fragments  normal-(  Φ   fragments  normal-(  n   i  normal-)   normal-→   fragments  normal-[  n  assign  n   1  normal-]   Φ   fragments  normal-(  n   i  normal-)   normal-)   normal-)   normal-→  for-all  i  Φ   fragments  normal-(  n   i  normal-)     (\Phi(n)\land\forall i(\Phi(n+i)\to[n:=n+1]\Phi(n+i)))\to\forall i\Phi(n+i)\,\!   . The remaining modality can now be eliminated with one more use of Hoare's axiom to give     (  Φ   (  n  )   ∧  ∀  i   (  Φ   (  n  +  i  )   →  Φ   (  n  +  i  +  1  )   )   )   →  ∀  i  Φ   (  n  +  i  )      fragments   fragments  normal-(  Φ   fragments  normal-(  n  normal-)    for-all  i   fragments  normal-(  Φ   fragments  normal-(  n   i  normal-)   normal-→  Φ   fragments  normal-(  n   i   1  normal-)   normal-)   normal-)   normal-→  for-all  i  Φ   fragments  normal-(  n   i  normal-)     (\Phi(n)\land\forall i(\Phi(n+i)\to\Phi(n+i+1)))\to\forall i\Phi(n+i)\,\!   .  With the opaque modalities now out of the way, we can safely substitute   0   0   0\,\!   for   n   n   n\,\!   in the usual manner of first-order logic to obtain Peano 's celebrated axiom     (  Φ   (  0  )   ∧  ∀  i   (  Φ   (  i  )   →  Φ   (  i  +  1  )   )   )   →  ∀  i  Φ   (  i  )      fragments   fragments  normal-(  Φ   fragments  normal-(  0  normal-)    for-all  i   fragments  normal-(  Φ   fragments  normal-(  i  normal-)   normal-→  Φ   fragments  normal-(  i   1  normal-)   normal-)   normal-)   normal-→  for-all  i  Φ   fragments  normal-(  i  normal-)     (\Phi(0)\land\forall i(\Phi(i)\to\Phi(i+1)))\to\forall i\Phi(i)\,\!   , namely mathematical induction.  One subtlety we glossed over here is that    ∀  i     for-all  i    \forall i\,\!   should be understood as ranging over the natural numbers, where   i   i   i\,\!   is the superscript in the expansion of    a  *     fragments  a     a*\,\!   as the union of    a  i     superscript  a  i    a^{i}\,\!   over all natural numbers   i   i   i\,\!   . The importance of keeping this typing information straight becomes apparent if   n   n   n\,\!   had been of type integer , or even real , for any of which A6 is perfectly valid as an axiom. As a case in point, if   n   n   n\,\!   is a real variable and    Φ   (  n  )       normal-Φ  n    \Phi(n)\,\!   is the predicate   n   n   n\,\!    is a natural number , then axiom A6 after the first two substitutions, that is,     (  Φ   (  n  )   ∧  ∀  i   (  Φ   (  n  +  i  )   →  Φ   (  n  +  i  +  1  )   )   )   →  ∀  i  Φ   (  n  +  i  )      fragments   fragments  normal-(  Φ   fragments  normal-(  n  normal-)    for-all  i   fragments  normal-(  Φ   fragments  normal-(  n   i  normal-)   normal-→  Φ   fragments  normal-(  n   i   1  normal-)   normal-)   normal-)   normal-→  for-all  i  Φ   fragments  normal-(  n   i  normal-)     (\Phi(n)\land\forall i(\Phi(n+i)\to\Phi(n+i+1)))\to\forall i\Phi(n+i)\,\!   , is just as valid, that is, true in every state regardless of the value of   n   n   n\,\!   in that state, as when   n   n   n\,\!   is of type natural number . If in a given state   n   n   n\,\!   is a natural number, then the antecedent of the main implication of A6 holds, but then    n  +  i      n  i    n+i\,\!   is also a natural number so the consequent also holds. If   n   n   n\,\!   is not a natural number, then the antecedent is false and so A6 remains true regardless of the truth of the consequent. We could strengthen A6 to an equivalence    p  ∧   [  a  *  ]    (  p  →   [  a  ]   p  )   ≡   [  a  *  ]   p     fragments  p    fragments  normal-[  a   normal-]    fragments  normal-(  p  normal-→   fragments  normal-[  a  normal-]   p  normal-)     fragments  normal-[  a   normal-]   p    p\land[a*](p\to[a]p)\equiv[a*]p\,\!   without impacting any of this, the other direction being provable from A5, from which we see that if the antecedent of A6 does happen to be false somewhere, then the consequent must be false.  Test  Dynamic logic associates to every proposition   p   p   p\,\!   an action    p  ?      p  normal-?    p?\,\!   called a test. When   p   p   p\,\!   holds, the test    p  ?      p  normal-?    p?\,\!   acts as a NOP , changing nothing while allowing the action to move on. When   p   p   p\,\!   is false,    p  ?      p  normal-?    p?\,\!   acts as BLOCK . Tests can be axiomatized as follows.  A8.       [   p  ?   ]   q   ≡  p  →  q           delimited-[]    p  normal-?    q   p    normal-→    q     [p?]q\equiv p\to q\,\!     The corresponding theorem for    ⟨   p  ?   ⟩     delimited-⟨⟩    p  normal-?     \langle p?\rangle\,\!   is:  T8.       ⟨   p  ?   ⟩   q   ≡   p  ∧  q          delimited-⟨⟩    p  normal-?    q     p  q     \langle p?\rangle q\equiv p\land q\,\!     The construct if p then a else b is realized in dynamic logic as     (   p  ?   ;  a  )   ∪   (   ¬  p  ?   ;  b  )          p  normal-?   a       p  normal-?   b     (p?;a)\cup(\neg p?;b)\,\!   . This action expresses a guarded choice: if   p   p   p\,\!   holds then     p  ?   ;  a       p  normal-?   a    p?;a\,\!   is equivalent to   a   a   a\,\!   , whereas     ¬  p  ?   ;  b        p  normal-?   b    \neg p?;b\,\!   is equivalent to BLOCK, and    a  ∪  0      a  0    a\cup 0\,\!   is equivalent to   a   a   a\,\!   . Hence when   p   p   p\,\!   is true the performer of the action can only take the left branch, and when   p   p   p\,\!   is false the right.  The construct while p do a is realized as     (  p  ?  ;  a  )   *  ;  ¬  p  ?     fragments   fragments  normal-(  p  ?  normal-;  a  normal-)    normal-;   p  ?    (p?;a)*;\neg p?\,\!   . This performs     p  ?   ;  a       p  normal-?   a    p?;a\,\!   zero or more times and then performs    ¬  p  ?       p  normal-?    \neg p?\,\!   . As long as   p   p   p\,\!   remains true, the    ¬  p  ?       p  normal-?    \neg p?\,\!   at the end blocks the performer from terminating the iteration prematurely, but as soon as it becomes false, further iterations of the body   p   p   p\,\!   are blocked and the performer then has no choice but to exit via the test    ¬  p  ?       p  normal-?    \neg p?\,\!   .  Quantification as random assignment  The random-assignment statement    x  :=  ?     assign  x  normal-?    x:=?\,\!   denotes the nondeterministic action of setting   x   x   x\,\!   to an arbitrary value.     [  x  :=  ?  ]   p     fragments   fragments  normal-[  x  assign  ?  normal-]   p    [x:=?]p\,\!   then says that   p   p   p\,\!   holds no matter what you set   x   x   x\,\!   to, while     ⟨  x  :=  ?  ⟩   p     fragments   fragments  normal-⟨  x  assign  ?  normal-⟩   p    \langle x:=?\rangle p\,\!   says that it is possible to set   x   x   x\,\!   to a value that makes   p   p   p\,\!   true.    [   x  :=  ?   ]     delimited-[]   assign  x  normal-?     [x:=?]\,\!   thus has the same meaning as the universal quantifier    ∀  x     for-all  x    \forall x\,\!   , while    ⟨   x  :=  ?   ⟩     delimited-⟨⟩   assign  x  normal-?     \langle x:=?\rangle\,\!   similarly corresponds to the existential quantifier    ∃  x      x    \exists x\,\!   . That is, first-order logic can be understood as the dynamic logic of programs of the form    x  :=  ?     assign  x  normal-?    x:=?\,\!   . 1  Possible-world semantics  Modal logic is most commonly interpreted in terms of possible world semantics or Kripke structures. This semantics carries over naturally to dynamic logic by interpreting worlds as states of a computer in the application to program verification, or states of our environment in applications to linguistics, AI, etc. One role for possible world semantics is to formalize the intuitive notions of truth and validity, which in turn permit the notions of soundness and completeness to be defined for axiom systems. An inference rule is sound when validity of its premises implies validity of its conclusion. An axiom system is sound when all its axioms are valid and its inference rules are sound. An axiom system is complete when every valid formula is derivable as a theorem of that system. These concepts apply to all systems of logic including dynamic logic.  Propositional dynamic logic (PDL)  Ordinary or first-order logic has two types of terms, respectively assertions and data. As can be seen from the examples above, dynamic logic adds a third type of term denoting actions. The dynamic logic assertion     [  x  :=  x  +  1  ]    (  x  ≥  4  )      fragments   fragments  normal-[  x  assign  x   1  normal-]    fragments  normal-(  x   4  normal-)     [x:=x+1](x\geq 4)\,\!   contains all three types   x   x   x\,\!   ,    x  +  1      x  1    x+1\,\!   , and   4   4   4\,\!   are data,    x  :=   x  +  1      assign  x    x  1     x:=x+1\,\!   is an action, and    x  ≥  4      x  4    x\geq 4\,\!   and     [  x  :=  x  +  1  ]    (  x  ≥  4  )      fragments   fragments  normal-[  x  assign  x   1  normal-]    fragments  normal-(  x   4  normal-)     [x:=x+1](x\geq 4)\,\!   are assertions. Propositional logic is derived from first-order logic by omitting data terms and reasons only about abstract propositions, which may be simple propositional variables or atoms or compound propositions built with such logical connectives as and , or , and not .  Propositional dynamic logic, or PDL, was derived from dynamic logic in 1977 by Michael J. Fischer and Richard Ladner. PDL blends the ideas behind propositional logic and dynamic logic by adding actions while omitting data; hence the terms of PDL are actions and propositions. The TV example above is expressed in PDL whereas the next example involving    x  :=   x  +  1      assign  x    x  1     x:=x+1\,\!   is in first-order DL. PDL is to (first-order) dynamic logic as propositional logic is to first-order logic.  Fischer and Ladner showed in their 1977 paper that PDL satisfiability was of computational complexity at most nondeterministic exponential time, and at least deterministic exponential time in the worst case. This gap was closed in 1978 by Vaughan Pratt who showed that PDL was decidable in deterministic exponential time. In 1977, Krister Segerberg proposed a complete axiomatization of PDL, namely any complete axiomatization of modal logic K together with axioms A1-A6 as given above. Completeness proofs for Segerberg's axioms were found by Gabbay (unpublished note), Parikh (1978), Pratt (1979), and Kozen and Parikh (1981).  History  Dynamic logic was developed by Vaughan Pratt in 1974 in notes for a class on program verification as an approach to assigning meaning to Hoare logic by expressing the Hoare formula    p   {  a  }   q      p   a   q    p\{a\}q\,\!   as    p  →    [  a  ]   q      normal-→  p     delimited-[]  a   q     p\to[a]q\,\!   . The approach was later published in 1976 as a logical system in its own right. The system parallels A. Salwicki's system of Algorithmic Logic 2 and Edsger Dijkstra 's notion of weakest-precondition predicate transformer    w  p   (  a  ,  p  )       w  p   a  p     wp(a,p)\,\!   , with     [  a  ]   p       delimited-[]  a   p    [a]p\,\!   corresponding to Dijkstra's    w  l  p   (  a  ,  p  )       w  l  p   a  p     wlp(a,p)\,\!   , weakest liberal precondition. Those logics however made no connection with either modal logic, Kripke semantics, regular expressions, or the calculus of binary relations; dynamic logic therefore can be viewed as a refinement of algorithmic logic and Predicate Transformers that connects them up to the axiomatics and Kripke semantics of modal logic as well as to the calculi of binary relations and regular expressions.  The Concurrency Challenge  Hoare logic, algorithmic logic, weakest preconditions, and dynamic logic are all well suited to discourse and reasoning about sequential behavior. Extending these logics to concurrent behavior however has proved problematic. There are various approaches but all of them lack the elegance of the sequential case. In contrast Amir Pnueli 's 1977 system of temporal logic , another variant of modal logic sharing many common features with dynamic logic, differs from all of the above-mentioned logics by being what Pnueli has characterized as an "endogenous" logic, the others being "exogenous" logics. By this Pnueli meant that temporal logic assertions are interpreted within a universal behavioral framework in which a single global situation changes with the passage of time, whereas the assertions of the other logics are made externally to the multiple actions about which they speak. The advantage of the endogenous approach is that it makes no fundamental assumptions about what causes what as the environment changes with time. Instead a temporal logic formula can talk about two unrelated parts of a system, which because they are unrelated tacitly evolve in parallel. In effect ordinary logical conjunction of temporal assertions is the concurrent composition operator of temporal logic. The simplicity of this approach to concurrency has resulted in temporal logic being the modal logic of choice for reasoning about concurrent systems with its aspects of synchronization, interference, independence, deadlock, livelock, fairness, etc.  These concerns of concurrency would appear to be less central to linguistics, philosophy, and artificial intelligence, the areas in which dynamic logic is most often encountered nowadays.  For a comprehensive treatment of dynamic logic see the book by David Harel et al. cited below.  See also   Temporal logic  Temporal logic in finite-state verification  Temporal logic of actions  Modal μ-calculus   Footnotes  References   Vaughan Pratt , "Semantical Considerations on Floyd-Hoare Logic", Proc. 17th Annual IEEE Symposium on Foundations of Computer Science, 1976, 109-121.  David Harel , Dexter Kozen , and Jerzy Tiuryn , "Dynamic Logic". MIT Press, 2000 (450 pp).  David Harel , "Dynamic Logic", In D. Gabbay and F. Guenthner, editors, Handbook of Philosophical Logic, volume II: Extensions of Classical Logic, chapter 10, pages 497-604. Reidel, Dordrecht, 1984.   External links   Semantical Considerations on Floyd-Hoare Logic (original paper on dynamic logic)   "  Category:Modal logic  Category:Logic in computer science     ↩  ↩     