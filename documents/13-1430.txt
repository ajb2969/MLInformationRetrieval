   Fast Syndrome Based Hash      Fast Syndrome Based Hash   In cryptography , the Fast Syndrome-based hash Functions (FSB) are a family of cryptographic hash functions introduced in 2003 by Daniel Augot, Matthieu Finiasz, and Nicolas Sendrier. 1 Unlike most other cryptographic hash functions in use today, FSB can to a certain extent be proven to be secure. More exactly, it can be proven that breaking FSB is at least as difficult as solving a certain NP-complete problem known as Regular Syndrome Decoding so FSB is provably secure . Though it is not known whether NP-complete problems are solvable in polynomial time , it is often assumed that they are not.  Several versions of FSB have been proposed, the latest of which was submitted to the SHA-3 cryptography competition but was rejected in the first round. Though all versions of FSB claim provable security, some preliminary versions were eventually broken. 2 The design of the latest version of FSB has however taken this attack into account and remains secure to all currently known attacks.  As usual, provable security comes at a cost. FSB is slower than traditional hash functions and uses quite a lot of memory, which makes it impractical on memory constrained environments. Furthermore, the compression function used in FSB needs a large output size to guarantee security. This last problem has been solved in recent versions by simply compressing the output by another compression function called Whirlpool . However, though the authors argue that adding this last compression does not reduce security, it makes a formal security proof impossible. 3  Description of the hash function  We start with a compression function   œï   œï   \phi   with parameters    n  ,  r  ,  w     n  r  w    {n,r,w}   such that    n  >  w      n  w    n>w   and     w   log   (   n  /  w   )     >  r        w      n  w     r    w\log(n/w)>r   . This function will only work on messages with length    s  =   w   log   (   n  /  w   )         s    w      n  w       s=w\log(n/w)   ;   r   r   r   will be the size of the output. Furthermore, we want    n  ,  r  ,  w  ,  s     n  r  w  s    n,r,w,s   and    log   (   n  /  w   )         n  w     \log(n/w)   to be natural numbers, where   log     \log   denote the binary logarithm . The reason for     w  ‚ãÖ   log   (   n  /  w   )     >  r       normal-‚ãÖ  w      n  w     r    w\cdot\log(n/w)>r   is that we want   œï   œï   \phi   to be a compression function, so the input must be larger than the output. We will later use the Merkle-Damg√•rd construction to extend the domain to inputs of arbitrary lengths.  The basis of this function consists of a (randomly chosen) binary    r  √ó  n      r  n    r\times n   matrix   H   H   H   which acts on a message of   n   n   n   bits by matrix multiplication . Here we encode the    w   log   (   n  /  w   )        w      n  w      w\log(n/w)   -bit message as a vector in     (   ùêÖ  2   )   n     superscript   subscript  ùêÖ  2   n    (\mathbf{F}_{2})^{n}   , the   n   n   n   -dimensional vector space over the field of two elements, so the output will be a message of   r   r   r   bits.  For security purposes as well as to get a faster hash speed we want to use only ‚Äúregular words of weight   w   w   w   ‚Äù as input for our matrix.  Definitions   A message is called a word of weight   w   w   w   and length   n   n   n    if it consists of   n   n   n   bits and exactly   w   w   w   of those bits are ones.  A word of weight   w   w   w   and length   n   n   n   is called regular if in every interval    [    (   i  -  1   )   w   ,   i  w   )         i  1   w     i  w     [(i-1)w,iw)   it contains exactly one nonzero entry for all 0 . More intuitively, this means that if we chop up the message in w equal parts, then each part contains exactly one nonzero entry.   The Compression Function  There are exactly     (   n  /  w   )   w     superscript    n  w   w    (n/w)^{w}   different regular words of weight   w   w   w   and length   n   n   n   , so we need exactly     log   (    (   n  /  w   )   w   )    =   w   log   (   n  /  w   )     =  s           superscript    n  w   w      w      n  w          s     \log((n/w)^{w})=w\log(n/w)=s   bits of data to encode these regular words. We fix a bijection from the set of bit strings of length   s   s   s   to the set of regular words of weight   w   w   w   and length   n   n   n   and then the FSB compression function is defined as follows :   input: a message of size   s   s   s     convert to regular word of length   n   n   n   and weight   w   w   w     multiply by the matrix   H   H   H     output: hash of size   r   r   r      This version is usually called Syndrome Based Compression . It is very slow and in practice done in a different and faster way resulting in Fast Syndrome Based Compression . We split   H   H   H   into sub-matrices    H  i     subscript  H  i    H_{i}   of size     r  √ó  n   /  w        r  n   w    r\times n/w   and we fix a bijection from the bit strings of length    w   log   (   n  /  w   )        w      n  w      w\log(n/w)   to the set of sequences of   w   w   w   numbers between 1 and    n  /  w      n  w    n/w   . This is equivalent to a bijection to the set of regular words of length   n   n   n   and weight   w   w   w   , since we can see such a word as a sequence of numbers between 1 and    n  /  w      n  w    n/w   . The compression function looks as follows:   Input: message of size   s   s   s     Convert   s   s   s   to a sequence of   w   w   w   numbers     s  1   ,  ‚Ä¶  ,   s  w       subscript  s  1   normal-‚Ä¶   subscript  s  w     s_{1},\dots,s_{w}   between 1 and    n  /  w      n  w    n/w     Add the corresponding columns of the matrices    H  i     subscript  H  i    H_{i}   to obtain a binary string a length   r   r   r     Output: hash of size   r   r   r      We can now use the Merkle-Damg√•rd construction to generalize the compression function to accept inputs of arbitrary lengths.  Example of the compression  Situation and initialization : Hash a message    s  =  010011      s  010011    s=010011   using    4  √ó  12      4  12    4\times 12   matrix H     H  =   (     1    0    1    1     0    1    0    0     1    0    1    1      0    1    0    0     0    1    1    1     0    1    0    0      0    1    1    1     0    1    0    0     1    0    1    0      1    1    0    0     1    0    1    1     0    0    0    1     )       H    1  0  1  1   missing-subexpression   0  1  0  0   missing-subexpression   1  0  1  1    0  1  0  0   missing-subexpression   0  1  1  1   missing-subexpression   0  1  0  0    0  1  1  1   missing-subexpression   0  1  0  0   missing-subexpression   1  0  1  0    1  1  0  0   missing-subexpression   1  0  1  1   missing-subexpression   0  0  0  1      H=\left(\begin{array}[]{llllcllllcllll}1&0&1&1&&0&1&0&0&&1&0&1&1\\
 0&1&0&0&&0&1&1&1&&0&1&0&0\\
 0&1&1&1&&0&1&0&0&&1&0&1&0\\
 1&1&0&0&&1&0&1&1&&0&0&0&1\end{array}\right)    that is separated into    w  =  3      w  3    w=3   sub-blocks    H  1     subscript  H  1    H_{1}   ,    H  2     subscript  H  2    H_{2}   ,    H  3     subscript  H  3    H_{3}   .  Algorithm :   We split the input   s   s   s   into    w  =  3      w  3    w=3   parts of length      log  2    (   12  /  3   )    =  2        subscript   2     12  3    2    \log_{2}(12/3)=2   and we get     s  1   =  01       subscript  s  1   01    s_{1}=01   ,     s  2   =  00       subscript  s  2   00    s_{2}=00   ,     s  3   =  11       subscript  s  3   11    s_{3}=11   .  We convert each    s  i     subscript  s  i    s_{i}   into an integer and get     s  1   =  1       subscript  s  1   1    s_{1}=1   ,     s  2   =  0       subscript  s  2   0    s_{2}=0   ,     s  3   =  3       subscript  s  3   3    s_{3}=3   .  From the first sub-matrix    H  1     subscript  H  1    H_{1}   , we pick the column 2, from the second sub-matrix    H  2     subscript  H  2    H_{2}   the column 1 and from the third sub-matrix the column 4.  We add the chosen columns and obtain the result    r  =   0111  ‚äï  0001  ‚äï  1001   =  1111        r   direct-sum  0111  0001  1001        1111     r=0111\oplus 0001\oplus 1001=1111   .   Security Proof of FSB  The Merkle-Damg√•rd construction is proven to base its security only on the security of the used compression function. So we only need to show that the compression function   œï   œï   \phi   is secure.  A cryptographic hash function needs to be secure in three different aspects:   Pre-image resistance: Given a Hash h it should be hard to find a message m such that Hash( m )= h  Second pre-image resistance: Given a message m 1 it should be hard to find a message m 2 such that Hash( m 1 ) = Hash( m 2 )  Collision resistance: It should be hard to find two different messages m 1 and m 2 such that Hash( m 1 )=Hash( m 2 )   Note that if an adversary can find a second pre-image, than he can certainly find a collision. This means that if we can prove our system to be collision resistant, it will certainly be second-pre-image resistant.  Usually in cryptography hard means something like ‚Äúalmost certainly beyond the reach of any adversary who must be prevented from breaking the system‚Äù. We will however need a more exact meaning of the word hard. We will take hard to mean ‚ÄúThe runtime of any algorithm that finds a collision or pre-image will depend exponentially on size of the hash value‚Äù. This means that by relatively small additions to the hash size, we can quickly reach high security.  Pre-image resistance and Regular Syndrome Decoding (RSD)  As said before, the security of FSB depends on a problem called Regular Syndrome Decoding (RSD) . Syndrome Decoding is originally a problem from coding theory but its NP-Completeness makes it a nice application for cryptography. Regular Syndrome Decoding is a special case of Syndrome Decoding and is defined as follows:  Definition of RSD: Given   w   w   w   matrices    H  i     subscript  H  i    H_{i}   of dimension    r  √ó   (   n  /  w   )       r    n  w     r\times(n/w)   and a bit string   S   S   S   of length   r   r   r   such that there exists a set of   w   w   w   columns, one in each    H  i     subscript  H  i    H_{i}   , summing to   S   S   S   . Find such a set of columns.  This problem has been proven to be NP-Complete by a reduction from 3-dimensional matching . Again, though it is not known whether there exist polynomial time algorithms for solving NP-Complete problems, none are known and finding one would be a huge discovery.  It is easy to see that finding a pre-image of a given hash   S   S   S   is exactly equivalent to this problem, so the problem of finding pre-images in FSB must also be NP-Complete.  We still need to prove collision resistance. For this we need another NP-Complete variation of RSD: 2-Regular Null Syndrome Decoding .  Collision resistance and 2-Regular Null Syndrome Decoding (2-NRSD)  Definition of 2-NRSD: Given   w   w   w   matrices    H  i     subscript  H  i    H_{i}   of dimension    r  √ó   (   n  /  w   )       r    n  w     r\times(n/w)   and a bit string   S   S   S   of length   r   r   r   such that there exists a set of    w  ‚Ä≤     superscript  w  normal-‚Ä≤    w^{\prime}   columns, two or zero in each    H  i     subscript  H  i    H_{i}   , summing to zero.    (   0  <   w  ‚Ä≤   <   2  w    )        0   superscript  w  normal-‚Ä≤          2  w      (0   . Find such a set of columns.  2-NRSD has also been proven to be NP-Complete by a reduction from 3-dimensional matching .  Just like RSD is in essence equivalent to finding a regular word   w   w   w   such that     H  w   =  S        H  w   S    Hw=S   , 2-NRSD is equivalent to finding a 2-regular word    w  ‚Ä≤     superscript  w  normal-‚Ä≤    w^{\prime}   such that     H   w  ‚Ä≤    =  0        H   superscript  w  normal-‚Ä≤    0    Hw^{\prime}=0   . A 2-regular word of length   n   n   n   and weight   w   w   w   is a bit string of length   n   n   n   such that in every interval    [    (   i  -  1   )   w   ,   i  w   )         i  1   w     i  w     [(i-1)w,iw)   exactly two or zero entries are equal to 1. Note that a 2-regular word is just a sum of two regular words.  Suppose that we have found a collision, so we have Hash( m 1 ) = Hash( m 2 ) with     m  1   ‚â†   m  2        subscript  m  1    subscript  m  2     m_{1}\neq m_{2}   . Then we can find two regular words    w  1     subscript  w  1    w_{1}   and    w  2     subscript  w  2    w_{2}   such that     H   w  1    =   H   w  2          H   subscript  w  1      H   subscript  w  2      Hw_{1}=Hw_{2}   . We then have     H   (    w  1   +   w  2    )    =    H   w  1    +   H   w  2     =   2  H   w  1    =  0          H     subscript  w  1    subscript  w  2         H   subscript  w  1      H   subscript  w  2            2  H   subscript  w  1         0     H(w_{1}+w_{2})=Hw_{1}+Hw_{2}=2Hw_{1}=0   ;    (    w  1   +   w  2    )       subscript  w  1    subscript  w  2     (w_{1}+w_{2})   is a sum of two different regular words and so must be a 2-regular word of which the hash is zero, so we have solved an instance of 2-NRSD. We conclude that finding collisions in FSB is at least as difficult as solving 2-NRSD and so must be NP-Complete.  The latest versions of FSB use the compression function Whirlpool to further compress the hash output. Though this cannot be proven, the authors argue that this last compression does not reduce security. Note that even if one were able to find collisions in Whirlpool, one would still need to find the collisions pre-images in the original FSB compression function to find a collision in FSB.  Examples  Solving RSD, we are in the opposite situation as when hashing. Using the same values as in the previous example, we are given   H   H   H   separated into    w  =  3      w  3    w=3   sub-blocks and a string    r  =  1111      r  1111    r=1111   . We are asked to find in each sub-block exactly one column such that they would all sum to   r   r   r   . The expected answer is thus     s  1   =  1       subscript  s  1   1    s_{1}=1   ,     s  2   =  0       subscript  s  2   0    s_{2}=0   ,     s  3   =  3       subscript  s  3   3    s_{3}=3   . This is known to be hard to compute for large matrices.  In 2-NRSD we want to find in each sub-block not one column, but two or zero such that they would sum up to 0000 (and not to   r   r   r   ). In the example, we might use column (counting from 0) 2 and 3 from    H  1     subscript  H  1    H_{1}   , no column from    H  2     subscript  H  2    H_{2}   column 0 and 2 from    H  3     subscript  H  3    H_{3}   . More solutions are possible, for example might use no columns from    H  3     subscript  H  3    H_{3}   .  Linear cryptanalysis  The provable security of FSB means that finding collisions is NP-complete. But the proof is a reduction to a problem with asymptotically hard worst-case complexity . This offers only limited security assurance as there still can be an algorithm that easily solves the problem for a subset of the problem space. For example, there exists a linearization method that can be used to produce collisions of in a matter of seconds on a desktop PC for early variants of FSB with claimed 2^128 security. It is shown that the hash function offers minimal pre-image or collision resistance when the message space is chosen in a specific way.  Practical security results  The following table shows the complexity of the best known attacks against FSB.      Output size (bits)   Complexity of collision search   Complexity of inversion       160   2 100.3   2 163.6     224   2 135.3   2 229.0     256   2 190.0   2 261.0     384   2 215.5   2 391.5     512   2 285.6   2 527.4     Genesis  FSB is a speed-up version of Syndrom-based hash function (SB). In the case of SB the compression function is very similar to the encoding function of Niederreiter's version of McEliece cryptosystem . Instead of using the parity check matrix of a permuted Goppa code , SB uses a random matrix   H   H   H   . From the security point of view this can only strengthen the system.  Other properties   Both the block size of the hash function and the output size are completely scalable.  The speed can be adjusted by adjusting the number of bitwise operations used by FSB per input bit.  The security can be adjusted by adjusting the output size.  Bad instances exist and one must take care when choosing the matrix   H   H   H   .  The matrix used in the compression function may grow large in certain situations. This might be a limitation when trying to use FSB on memory constrained devices. This problem was solved in the related hash function called Improved FSB, which is still provably secure , but relies on slightly stronger assumptions.   Variants  In 2007, IFSB was published. 4 In 2010, S-FSB was published, which is 30% faster than the original. 5  In 2011, D.J. Bernstein and Tanja Lange published RFSB, which is 10x faster than the original FSB-256. 6 RFSB was shown to run very fast on the Spartan 6 FPGA, reaching throughputs of around 5 Gbit/s. 7  References  External links   FSB website for SHA-3 competition   "  Category:Cryptographic hash functions     ‚Ü©  ‚Ü©  ‚Ü©  https://www.rocq.inria.fr/secret/Matthieu.Finiasz/research/2007/finiasz-gaborit-sendrier-ecrypt-hash-workshop07.pdf ‚Ü©  https://www.informatik.tu-darmstadt.de/fileadmin/user_upload/Group_CASED/Publikationen/2010/S-FSB_An_Improved_Variant_of_the_FSB_Hash_Family.pdf ‚Ü©  http://cr.yp.to/codes/rfsb-20110214.pdf ‚Ü©  https://www.ei.rub.de/media/sh/veroeffentlichungen/2012/12/10/embedded_syndrome-based_hashing.pdf ‚Ü©     