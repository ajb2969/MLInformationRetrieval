   LowerUnits      LowerUnits   In proof compression LowerUnits ( LU ) is an algorithm used to compress propositional logic resolution proofs. The main idea of LowerUnits is to exploit the following fact: 1  Theorem: Let    φ   φ   \varphi    be a potentially redundant  proof , and    η   η   \eta    be the redundant proof | redundant node. If    η   η   \eta    ’s clause is a unit  clause ,  then    φ   φ   \varphi    is redundant.  The algorithm targets exactly the class of global redundancy stemming from multiple resolutions with unit clauses. The algorithm takes its name from the fact that, when this rewriting is done and the resulting proof is displayed as a DAG ( directed acyclic graph ), the unit node   η   η   \eta   appears lower (i.e., closer to the root) than it used to appear in the original proof.  A naive implementation exploiting theorem would require the proof to be traversed and fixed after each unit node is lowered. It is possible, however, to do better by first collecting and removing all the unit nodes in a single traversal, and afterwards fixing the whole proof in a single second traversal. Finally, the collected and fixed unit nodes have to be reinserted at the bottom of the proof.  Care must be taken with cases when a unit node    η  ′     superscript  η  normal-′    \eta^{\prime}   occurs above in the subproof that derives another unit node   η   η   \eta   . In such cases,   η   η   \eta   depends on    η  ′     superscript  η  normal-′    \eta^{\prime}   . Let   ℓ   normal-ℓ   \ell   be the single literal of the unit clause of    η  ′     superscript  η  normal-′    \eta^{\prime}   . Then any occurrence of    ℓ  ¯     normal-¯  normal-ℓ    \overline{\ell}   in the subproof above   η   η   \eta   will not be cancelled by resolution inferences with    η  ′     superscript  η  normal-′    \eta^{\prime}   anymore. Consequently,    ℓ  ¯     normal-¯  normal-ℓ    \overline{\ell}   will be propagated downwards when the proof is fixed and will appear in the clause of   η   η   \eta   . Difficulties with such dependencies can be easily avoided if we reinsert the upper unit node    η  ′     superscript  η  normal-′    \eta^{\prime}   after reinserting the unit node   η   η   \eta   (i.e. after reinsertion,    η  ′     superscript  η  normal-′    \eta^{\prime}   must appear below   η   η   \eta   , to cancel the extra literal    ℓ  ¯     normal-¯  normal-ℓ    \overline{\ell}   from   η   η   \eta   ’s clause). This can be ensured by collecting the unit nodes in a queue during a bottom-up traversal of the proof and reinserting them in the order they were queued.  The algorithm for fixing a proof containing many roots performs a top-down traversal of the proof, recomputing the resolvents and replacing broken nodes (e.g. nodes having deletedNodeMarker as one of their parents) by their surviving parents (e.g. the other parent, in case one parent was deletedNodeMarker).  When unit nodes are collected and removed from a proof of a clause   κ   κ   \kappa   and the proof is fixed, the clause    κ  ′     superscript  κ  normal-′    \kappa^{\prime}   in the root node of the new proof is not equal to   κ   κ   \kappa   anymore, but contains (some of) the duals of the literals of the unit clauses that have been removed from the proof. The reinsertion of unit nodes at the bottom of the proof resolves    κ  ′     superscript  κ  normal-′    \kappa^{\prime}   with the clauses of (some of) the collected unit nodes, in order to obtain a proof of   κ   κ   \kappa   again.  Algorithm  General structure of the algorithm  Input: A proof    ψ   ψ   \psi     Output: A proof     ψ  ′     superscript  ψ  normal-′    \psi^{\prime}    with no global redundancy with unit redundant node  (unitsQueue,     ψ  b     subscript  ψ  b    \psi_{b}    ) ← collectUnits(    ψ   ψ   \psi    );       ψ  f     subscript  ψ  f    \psi_{f}    ← fix(     ψ  b     subscript  ψ  b    \psi_{b}    );  fixedUnitsQueue ← fix(unitsQueue);       ψ  ′     superscript  ψ  normal-′    \psi^{\prime}    ← reinsertUnits(     ψ  f     subscript  ψ  f    \psi_{f}    , fixedUnitsQueue);   return      ψ  ′     superscript  ψ  normal-′    \psi^{\prime}    ;  We collect the unit clauses as follow  Input: A proof    ψ   ψ   \psi     Output: A pair containing a queue of all unit nodes (unitsQueue) that are used more than once in    ψ   ψ   \psi    and a broken proof     ψ  b     subscript  ψ  b    \psi_{b}         ψ  b     subscript  ψ  b    \psi_{b}   ←   ψ   ψ   \psi   ;  traverse     ψ  b     subscript  ψ  b    \psi_{b}    bottom-up and foreach node    η   η   \eta    in     ψ  b     subscript  ψ  b    \psi_{b}     do   if     η   η   \eta    is unit and    η   η   \eta    has more than one child then  add    η   η   \eta    to unitsQueue;  remove    η   η   \eta    from     ψ  b     subscript  ψ  b    \psi_{b}    ;   end  end  return (unitsQueue,     ψ  b     subscript  ψ  b    \psi_{b}    );  Then we reinsert the units  Input: A proof     ψ  f     subscript  ψ  f    \psi_{f}    (with a single root) and a queue    q   q   q    of root nodes  Output: A proof     ψ  ′     superscript  ψ  normal-′    \psi^{\prime}         ψ  ′     superscript  ψ  normal-′    \psi^{\prime}   ←    ψ  f     subscript  ψ  f    \psi_{f}   ;  while      q  ≠  ∅      q     q\neq\emptyset     do      η   η   \eta    ← first element of    q   q   q    ;      q   q   q    ← tail of    q   q   q    ;   if     η   η   \eta    is resolvable with root of     ψ  ′     superscript  ψ  normal-′    \psi^{\prime}     then       ψ  ′     superscript  ψ  normal-′    \psi^{\prime}    ← resolvent of    η   η   \eta    with the root of     ψ  ′     superscript  ψ  normal-′    \psi^{\prime}    ;   end   end  return      ψ  ′     superscript  ψ  normal-′    \psi^{\prime}    ;  Notes  "  Category:Automated theorem proving  Category:Proof theory     Fontaine, Pascal; Merz, Stephan; Woltzenlogel Paleo, Bruno. Compression of Propositional Resolution Proofs via Partial Regularization . 23rd International Conference on Automated Deduction, 2011. ↩     