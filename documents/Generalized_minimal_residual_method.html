<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1327">Generalized minimal residual method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Generalized minimal residual method</h1>
<hr/>

<p>In mathematics, the <strong>generalized minimal residual method</strong> (usually abbreviated <strong>GMRES</strong>) is an <a href="iterative_method" title="wikilink">iterative method</a> for the <a href="numerical_analysis" title="wikilink">numerical</a> solution of a nonsymmetric <a href="system_of_linear_equations" title="wikilink">system of linear equations</a>. The method approximates the solution by the vector in a <a href="Krylov_subspace" title="wikilink">Krylov subspace</a> with minimal <a href="residual_(numerical_analysis)" title="wikilink">residual</a>. The <a href="Arnoldi_iteration" title="wikilink">Arnoldi iteration</a> is used to find this vector.</p>

<p>The GMRES method was developed by <a href="Yousef_Saad" title="wikilink">Yousef Saad</a> and Martin H. Schultz in 1986.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> GMRES is a generalization of the <a class="uri" href="MINRES" title="wikilink">MINRES</a> method developed by Chris Paige and Michael Saunders in 1975. GMRES also is a special case of the <a class="uri" href="DIIS" title="wikilink">DIIS</a> method developed by Peter Pulay in 1980. DIIS is also applicable to non-linear systems.</p>
<h2 id="the-method">The method</h2>

<p>Denote the <a href="Euclidean_norm" title="wikilink">Euclidean norm</a> of any vector <em>v</em> by 

<math display="inline" id="Generalized_minimal_residual_method:0">
 <semantics>
  <mrow>
   <mo>∥</mo>
   <mi>v</mi>
   <mo>∥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">norm</csymbol>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|v\|
  </annotation>
 </semantics>
</math>

. Denote the system of linear equations to be solved by</p>

<p>

<math display="block" id="Generalized_minimal_residual_method:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mi>x</mi>
    </mrow>
    <mo>=</mo>
    <mi>b</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>x</ci>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ax=b.\,
  </annotation>
 </semantics>
</math>

 The matrix <em>A</em> is assumed to be <a href="invertible_matrix" title="wikilink">invertible</a> of size <em>m</em>-by-<em>m</em>. Furthermore, it is assumed that <em>b</em> is normalized, i.e., that ||<em>b</em>|| = 1.</p>

<p>The <em>n</em>th <a href="Krylov_sequence" title="wikilink">Krylov subspace</a> for this problem is</p>

<p>

<math display="block" id="Generalized_minimal_residual_method:2">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>K</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>K</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo rspace="4.2pt">span</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>b</mi>
      <mo>,</mo>
      <mrow>
       <mi>A</mi>
       <mi>b</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <msup>
        <mi>A</mi>
        <mn>2</mn>
       </msup>
       <mi>b</mi>
      </mrow>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mrow>
       <msup>
        <mi>A</mi>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>n</ci>
      </apply>
      <interval closure="open">
       <ci>A</ci>
       <ci>b</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>span</ci>
      <ci>b</ci>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>b</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>b</ci>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{n}=K_{n}(A,b)=\operatorname{span}\,\{b,Ab,A^{2}b,\ldots,A^{n-1}b\}.\,
  </annotation>
 </semantics>
</math>

 GMRES approximates the exact solution of <em>Ax</em> = <em>b</em> by the vector <em>x</em><sub><em>n</em></sub> ∈ <em>K</em><sub><em>n</em></sub> that minimizes the Euclidean norm of the <a href="Residual_(numerical_analysis)" title="wikilink">residual</a> <em>r</em><sub><em>n</em></sub> = <em>Ax</em><sub><em>n</em></sub> − <em>b</em>.</p>

<p>The vectors <em>b</em>, <em>Ab</em>, …, <em>A</em><sup><em>n</em>−1</sup><em>b</em> might be almost <a href="linear_independence" title="wikilink">linearly dependent</a>, so instead of this basis, the <a href="Arnoldi_iteration" title="wikilink">Arnoldi iteration</a> is used to find orthonormal vectors</p>

<p>

<math display="block" id="Generalized_minimal_residual_method:3">
 <semantics>
  <mrow>
   <msub>
    <mi>q</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>q</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mpadded width="+1.7pt">
    <msub>
     <mi>q</mi>
     <mi>n</mi>
    </msub>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{1},q_{2},\ldots,q_{n}\,
  </annotation>
 </semantics>
</math>

 which form a basis for <em>K</em><sub><em>n</em></sub>. Hence, the vector <em>x</em><sub><em>n</em></sub> ∈ <em>K</em><sub><em>n</em></sub> can be written as <em>x</em><sub><em>n</em></sub> = <em>Q</em><sub><em>n</em></sub><em>y</em><sub><em>n</em></sub> with <em>y</em><sub><em>n</em></sub> ∈ <strong>R</strong><sup><em>n</em></sup>, where <em>Q</em><sub><em>n</em></sub> is the <em>m</em>-by-<em>n</em> matrix formed by <em>q</em><sub>1</sub>, …, <em>q</em><sub>n</sub>.</p>

<p>The Arnoldi process also produces an (<em>n</em>+1)-by-<em>n</em> upper <a href="Hessenberg_matrix" title="wikilink">Hessenberg matrix</a> 

<math display="inline" id="Generalized_minimal_residual_method:4">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>H</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-~</ci>
     <ci>H</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{H}_{n}
  </annotation>
 </semantics>
</math>

 with</p>

<p>

<math display="block" id="Generalized_minimal_residual_method:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>A</mi>
     <msub>
      <mi>Q</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msub>
      <mover accent="true">
       <mi>H</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-~</ci>
       <ci>H</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   AQ_{n}=Q_{n+1}\tilde{H}_{n}.\,
  </annotation>
 </semantics>
</math>

 Because columns of 

<math display="inline" id="Generalized_minimal_residual_method:6">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{n}
  </annotation>
 </semantics>
</math>

 are orthogonal, we have</p>

<p>

<math display="block" id="Generalized_minimal_residual_method:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mrow>
       <mi>A</mi>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo>-</mo>
      <mi>b</mi>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mrow>
       <msub>
        <mover accent="true">
         <mi>H</mi>
         <mo stretchy="false">~</mo>
        </mover>
        <mi>n</mi>
       </msub>
       <msub>
        <mi>y</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>β</mi>
       <msub>
        <mi>e</mi>
        <mn>1</mn>
       </msub>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>A</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-~</ci>
         <ci>H</ci>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>β</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|Ax_{n}-b\|=\|\tilde{H}_{n}y_{n}-\beta e_{1}\|,\,
  </annotation>
 </semantics>
</math>

 where</p>

<p>

<math display="block" id="Generalized_minimal_residual_method:8">
 <semantics>
  <mrow>
   <msub>
    <mi>e</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>T</mi>
    </msup>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <vector>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <ci>normal-…</ci>
      <cn type="integer">0</cn>
     </vector>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{1}=(1,0,0,\ldots,0)^{T}\,
  </annotation>
 </semantics>
</math>

 is the first vector in the <a href="standard_basis" title="wikilink">standard basis</a> of <strong>R</strong><sup><em>n</em>+1</sup>, and</p>

<p>

<math display="block" id="Generalized_minimal_residual_method:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>β</mi>
    <mo>=</mo>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi>b</mi>
      <mo>-</mo>
      <mrow>
       <mi>A</mi>
       <msub>
        <mi>x</mi>
        <mn>0</mn>
       </msub>
      </mrow>
     </mrow>
     <mo rspace="4.2pt">∥</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>β</ci>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <minus></minus>
      <ci>b</ci>
      <apply>
       <times></times>
       <ci>A</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta=\|b-Ax_{0}\|\,,
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Generalized_minimal_residual_method:10">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

 being the first trial vector (usually zero). Hence, 

<math display="inline" id="Generalized_minimal_residual_method:11">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}
  </annotation>
 </semantics>
</math>

 can be found by minimizing the Euclidean norm of the residual</p>

<p>

<math display="block" id="Generalized_minimal_residual_method:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>r</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mover accent="true">
        <mi>H</mi>
        <mo stretchy="false">~</mo>
       </mover>
       <mi>n</mi>
      </msub>
      <msub>
       <mi>y</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>β</mi>
      <msub>
       <mi>e</mi>
       <mn>1</mn>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>H</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>β</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{n}=\tilde{H}_{n}y_{n}-\beta e_{1}.
  </annotation>
 </semantics>
</math>

 This is a <a href="linear_least_squares_(mathematics)" title="wikilink">linear least squares</a> problem of size <em>n</em>.</p>

<p>This yields the GMRES method. On the <em>n</em>-th iteration:</p>
<ol>
<li>calculate 

<math display="inline" id="Generalized_minimal_residual_method:13">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{n}
  </annotation>
 </semantics>
</math>

 with the Arnoldi method;</li>
<li>find the 

<math display="inline" id="Generalized_minimal_residual_method:14">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n}
  </annotation>
 </semantics>
</math>

 which minimizes ||<em>r</em><sub><em>n</em></sub>||;</li>
<li>compute 

<math display="inline" id="Generalized_minimal_residual_method:15">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>Q</mi>
     <mi>n</mi>
    </msub>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}=Q_{n}y_{n}
  </annotation>
 </semantics>
</math>

;</li>
<li>repeat if the residual is not yet small enough.</li>
</ol>

<p>At every iteration, a matrix-vector product <em>Aq</em><sub><em>n</em></sub> must be computed. This costs about 2<em>m</em><sup>2</sup> <a href="floating_point" title="wikilink">floating-point operations</a> for general dense matrices of size <em>m</em>, but the cost can decrease to O(<em>m</em>) for <a href="sparse_matrix" title="wikilink">sparse matrices</a>. In addition to the matrix-vector product, O(<em>n</em> <em>m</em>) floating-point operations must be computed at the <em>n</em>th iteration.</p>
<h2 id="convergence">Convergence</h2>

<p>The <em>n</em>th iterate minimizes the residual in the Krylov subspace <em>K</em><sub><em>n</em></sub>. Since every subspace is contained in the next subspace, the residual decreases monotonically. After <em>m</em> iterations, where <em>m</em> is the size of the matrix <em>A</em>, the Krylov space <em>K</em><sub><em>m</em></sub> is the whole of <strong>R</strong><sup><em>m</em></sup> and hence the GMRES method arrives at the exact solution. However, the idea is that after a small number of iterations (relative to <em>m</em>), the vector <em>x</em><sub><em>n</em></sub> is already a good approximation to the exact solution.</p>

<p>This does not happen in general. Indeed, a theorem of Greenbaum, Pták and Strakoš states that for every monotonically decreasing sequence <em>a</em><sub>1</sub>, …, <em>a</em><sub><em>m</em>−1</sub>, <em>a</em><sub><em>m</em></sub> = 0, one can find a matrix <em>A</em> such that the ||<em>r</em><sub><em>n</em></sub>|| = <em>a</em><sub><em>n</em></sub> for all <em>n</em>, where <em>r</em><sub><em>n</em></sub> is the residual defined above. In particular, it is possible to find a matrix for which the residual stays constant for <em>m</em> − 1 iterations, and only drops to zero at the last iteration.</p>

<p>In practice, though, GMRES often performs well. This can be proven in specific situations. If <em>A</em> is <a href="positive-definite_matrix" title="wikilink">positive definite</a>, then</p>

<p>

<math display="block" id="Generalized_minimal_residual_method:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <msub>
      <mi>r</mi>
      <mi>n</mi>
     </msub>
     <mo>∥</mo>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <msup>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mfrac>
         <mrow>
          <msubsup>
           <mi>λ</mi>
           <mi>min</mi>
           <mn>2</mn>
          </msubsup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mrow>
             <mn>1</mn>
             <mo>/</mo>
             <mn>2</mn>
            </mrow>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <msup>
               <mi>A</mi>
               <mi>T</mi>
              </msup>
              <mo>+</mo>
              <mi>A</mi>
             </mrow>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mrow>
          <msub>
           <mi>λ</mi>
           <mi>max</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <msup>
             <mi>A</mi>
             <mi>T</mi>
            </msup>
            <mi>A</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mfrac>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mrow>
       <mi>n</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <mrow>
      <mo>∥</mo>
      <msub>
       <mi>r</mi>
       <mn>0</mn>
      </msub>
      <mo>∥</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>λ</ci>
           <ci>min</ci>
          </apply>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <times></times>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <plus></plus>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>A</ci>
            <ci>T</ci>
           </apply>
           <ci>A</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>λ</ci>
          <ci>max</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>A</ci>
           <ci>T</ci>
          </apply>
          <ci>A</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|r_{n}\|\leq\left(1-\frac{\lambda_{\mathrm{min}}^{2}(1/2(A^{T}+A))}{\lambda_{%
\mathrm{max}}(A^{T}A)}\right)^{n/2}\|r_{0}\|,
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Generalized_minimal_residual_method:17">
 <semantics>
  <mrow>
   <msub>
    <mi>λ</mi>
    <mi>min</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>min</ci>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{\mathrm{min}}(M)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Generalized_minimal_residual_method:18">
 <semantics>
  <mrow>
   <msub>
    <mi>λ</mi>
    <mi>max</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>max</ci>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{\mathrm{max}}(M)
  </annotation>
 </semantics>
</math>

 denote the smallest and largest <a class="uri" href="eigenvalue" title="wikilink">eigenvalue</a> of the matrix 

<math display="inline" id="Generalized_minimal_residual_method:19">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

, respectively.</p>

<p>If <em>A</em> is <a href="symmetric_matrix" title="wikilink">symmetric</a> and positive definite, then we even have</p>

<p>

<math display="block" id="Generalized_minimal_residual_method:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <msub>
      <mi>r</mi>
      <mi>n</mi>
     </msub>
     <mo>∥</mo>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <msup>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mrow>
         <mrow>
          <mn>2</mn>
          <msub>
           <mi>κ</mi>
           <mn>2</mn>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>A</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mrow>
         <mn>2</mn>
         <msub>
          <mi>κ</mi>
          <mn>2</mn>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>A</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mfrac>
       <mo>)</mo>
      </mrow>
      <mrow>
       <mi>n</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <mrow>
      <mo>∥</mo>
      <msub>
       <mi>r</mi>
       <mn>0</mn>
      </msub>
      <mo>∥</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>κ</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>A</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>κ</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>A</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|r_{n}\|\leq\left(\frac{2\kappa_{2}(A)-1}{2\kappa_{2}(A)}\right)^{n/2}\|r_{0}\|.
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Generalized_minimal_residual_method:21">
 <semantics>
  <mrow>
   <msub>
    <mi>κ</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>κ</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa_{2}(A)
  </annotation>
 </semantics>
</math>

 denotes the <a href="condition_number" title="wikilink">condition number</a> of <em>A</em> in the Euclidean norm.</p>

<p>In the general case, where <em>A</em> is not positive definite, we have</p>

<p>

<math display="block" id="Generalized_minimal_residual_method:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <msub>
      <mi>r</mi>
      <mi>n</mi>
     </msub>
     <mo>∥</mo>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <munder>
      <mo movablelimits="false">inf</mo>
      <mrow>
       <mi>p</mi>
       <mo>∈</mo>
       <msub>
        <mi>P</mi>
        <mi>n</mi>
       </msub>
      </mrow>
     </munder>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>∥</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <msub>
      <mi>κ</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>V</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <munder>
       <mo movablelimits="false">inf</mo>
       <mrow>
        <mi>p</mi>
        <mo>∈</mo>
        <msub>
         <mi>P</mi>
         <mi>n</mi>
        </msub>
       </mrow>
      </munder>
      <mrow>
       <munder>
        <mi>max</mi>
        <mrow>
         <mi>λ</mi>
         <mo>∈</mo>
         <mrow>
          <mi>σ</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>A</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </munder>
       <mrow>
        <mrow>
         <mo stretchy="false">|</mo>
         <mrow>
          <mi>p</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>λ</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">|</mo>
        </mrow>
        <mrow>
         <mo>∥</mo>
         <msub>
          <mi>r</mi>
          <mn>0</mn>
         </msub>
         <mo>∥</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">infimum</csymbol>
       <apply>
        <in></in>
        <ci>p</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <times></times>
        <ci>p</ci>
        <ci>A</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>κ</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>V</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">infimum</csymbol>
        <apply>
         <in></in>
         <ci>p</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>P</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <max></max>
         <apply>
          <in></in>
          <ci>λ</ci>
          <apply>
           <times></times>
           <ci>σ</ci>
           <ci>A</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <abs></abs>
          <apply>
           <times></times>
           <ci>p</ci>
           <ci>λ</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="latexml">norm</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>r</ci>
           <cn type="integer">0</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|r_{n}\|\leq\inf_{p\in P_{n}}\|p(A)\|\leq\kappa_{2}(V)\inf_{p\in P_{n}}\max_{%
\lambda\in\sigma(A)}|p(\lambda)|\|r_{0}\|,\,
  </annotation>
 </semantics>
</math>

 where <em>P</em><sub><em>n</em></sub> denotes the set of polynomials of degree at most <em>n</em> with <em>p</em>(0) = 1, <em>V</em> is the matrix appearing in the <a href="spectral_decomposition" title="wikilink">spectral decomposition</a> of <em>A</em>, and σ(<em>A</em>) is the <a href="spectrum_of_a_matrix" title="wikilink">spectrum</a> of <em>A</em>. Roughly speaking, this says that fast convergence occurs when the eigenvalues of <em>A</em> are clustered away from the origin and <em>A</em> is not too far from <a href="normal_matrix" title="wikilink">normality</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>All these inequalities bound only the residuals instead of the actual error, that is, the distance between the current iterate <em>x</em><sub><em>n</em></sub> and the exact solution.</p>
<h2 id="extensions-of-the-method">Extensions of the method</h2>

<p>Like other iterative methods, GMRES is usually combined with a <a class="uri" href="preconditioning" title="wikilink">preconditioning</a> method in order to speed up convergence.</p>

<p>The cost of the iterations grow as O(<em>n</em><sup>2</sup>), where <em>n</em> is the iteration number. Therefore, the method is sometimes restarted after a number, say <em>k</em>, of iterations, with <em>x</em><sub><em>k</em></sub> as initial guess. The resulting method is called GMRES(<em>k</em>) or Restarted GMRES.</p>
<h2 id="comparison-with-other-solvers">Comparison with other solvers</h2>

<p>The Arnoldi iteration reduces to the <a href="Lanczos_iteration" title="wikilink">Lanczos iteration</a> for symmetric matrices. The corresponding <a href="Krylov_subspace" title="wikilink">Krylov subspace</a> method is the minimal residual method (MinRes) of Paige and Saunders. Unlike the unsymmetric case, the MinRes method is given by a three-term <a href="recurrence_relation" title="wikilink">recurrence relation</a>. It can be shown that there is no Krylov subspace method for general matrices, which is given by a short recurrence relation and yet minimizes the norms of the residuals, as GMRES does.</p>

<p>Another class of methods builds on the <a href="unsymmetric_Lanczos_iteration" title="wikilink">unsymmetric Lanczos iteration</a>, in particular the <a href="Biconjugate_gradient_method" title="wikilink">BiCG method</a>. These use a three-term recurrence relation, but they do not attain the minimum residual, and hence the residual does not decrease monotonically for these methods. Convergence is not even guaranteed.</p>

<p>The third class is formed by methods like <a href="Conjugate_gradient_squared_method" title="wikilink">CGS</a> and <a href="Biconjugate_gradient_stabilized_method" title="wikilink">BiCGSTAB</a>. These also work with a three-term recurrence relation (hence, without optimality) and they can even terminate prematurely without achieving convergence. The idea behind these methods is to choose the generating polynomials of the iteration sequence suitably.</p>

<p>None of these three classes is the best for all matrices; there are always examples in which one class outperforms the other. Therefore, multiple solvers are tried in practice to see which one is the best for a given problem.</p>
<h2 id="solving-the-least-squares-problem">Solving the least squares problem</h2>

<p>One part of the GMRES method is to find the vector 

<math display="inline" id="Generalized_minimal_residual_method:23">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n}
  </annotation>
 </semantics>
</math>

 which minimizes</p>

<p>

<math display="block" id="Generalized_minimal_residual_method:24">
 <semantics>
  <mrow>
   <mrow>
    <mo>∥</mo>
    <mrow>
     <mrow>
      <msub>
       <mover accent="true">
        <mi>H</mi>
        <mo stretchy="false">~</mo>
       </mover>
       <mi>n</mi>
      </msub>
      <msub>
       <mi>y</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>β</mi>
      <msub>
       <mi>e</mi>
       <mn>1</mn>
      </msub>
     </mrow>
    </mrow>
    <mo>∥</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">norm</csymbol>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>H</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>β</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\tilde{H}_{n}y_{n}-\beta e_{1}\|.\,
  </annotation>
 </semantics>
</math>

 Note that 

<math display="inline" id="Generalized_minimal_residual_method:25">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>H</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-~</ci>
     <ci>H</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{H}_{n}
  </annotation>
 </semantics>
</math>

 is an (<em>n</em>+1)-by-<em>n</em> matrix, hence it gives an over-constrained linear system of <em>n</em>+1 equations for <em>n</em> unknowns.</p>

<p>The minimum can be computed using a <a href="QR_decomposition" title="wikilink">QR decomposition</a>: find an (<em>n</em>+1)-by-(<em>n</em>+1) <a href="orthogonal_matrix" title="wikilink">orthogonal matrix</a> Ω<sub><em>n</em></sub> and an (<em>n</em>+1)-by-<em>n</em> upper <a href="triangular_matrix" title="wikilink">triangular matrix</a> 

<math display="inline" id="Generalized_minimal_residual_method:26">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>R</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-~</ci>
     <ci>R</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{R}_{n}
  </annotation>
 </semantics>
</math>

 such that</p>

<p>

<math display="block" id="Generalized_minimal_residual_method:27">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi mathvariant="normal">Ω</mi>
      <mi>n</mi>
     </msub>
     <msub>
      <mover accent="true">
       <mi>H</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <msub>
     <mover accent="true">
      <mi>R</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Ω</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-~</ci>
       <ci>H</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>R</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega_{n}\tilde{H}_{n}=\tilde{R}_{n}.
  </annotation>
 </semantics>
</math>

 The triangular matrix has one more row than it has columns, so its bottom row consists of zero. Hence, it can be decomposed as</p>

<p>

<math display="block" id="Generalized_minimal_residual_method:28">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>R</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>R</mi>
         <mi>n</mi>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>R</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>n</ci>
      </apply>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{R}_{n}=\begin{bmatrix}R_{n}\\
0\end{bmatrix},
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Generalized_minimal_residual_method:29">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{n}
  </annotation>
 </semantics>
</math>

 is an <em>n</em>-by-<em>n</em> (thus square) triangular matrix.</p>

<p>The QR decomposition can be updated cheaply from one iteration to the next, because the Hessenberg matrices differ only by a row of zeros and a column:</p>

<p>

<math display="block" id="Generalized_minimal_residual_method:30">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>H</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mover accent="true">
          <mi>H</mi>
          <mo stretchy="false">~</mo>
         </mover>
         <mi>n</mi>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>h</mi>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>h</mi>
         <mrow>
          <mrow>
           <mi>n</mi>
           <mo>+</mo>
           <mn>2</mn>
          </mrow>
          <mo>,</mo>
          <mrow>
           <mi>n</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </mrow>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>H</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>H</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <list>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </list>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{H}_{n+1}=\begin{bmatrix}\tilde{H}_{n}&h_{n+1}\\
0&h_{n+2,n+1}\end{bmatrix},
  </annotation>
 </semantics>
</math>

 where <em>h</em><sub><em>n+1</em></sub> = (<em>h</em><sub>1,<em>n+1</em></sub>, …, <em>h</em><sub><em>n+1,n+1</em></sub>)<sup>T</sup>. This implies that premultiplying the Hessenberg matrix with Ω<sub><em>n</em></sub>, augmented with zeroes and a row with multiplicative identity, yields almost a triangular matrix:</p>

<p>

<math display="block" id="Generalized_minimal_residual_method:31">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi mathvariant="normal">Ω</mi>
         <mi>n</mi>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <msub>
     <mover accent="true">
      <mi>H</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>R</mi>
        <mi>n</mi>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>r</mi>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mi>ρ</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mi>σ</mi>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Ω</ci>
        <ci>n</ci>
       </apply>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </matrixrow>
     </matrix>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-~</ci>
       <ci>H</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <ci>ρ</ci>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <ci>σ</ci>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}\Omega_{n}&0\\
0&1\end{bmatrix}\tilde{H}_{n+1}=\begin{bmatrix}R_{n}&r_{n+1}\\
0&\rho\\
0&\sigma\end{bmatrix}
  </annotation>
 </semantics>
</math>

 This would be triangular if σ is zero. To remedy this, one needs the <a href="Givens_rotation" title="wikilink">Givens rotation</a></p>

<p>

<math display="block" id="Generalized_minimal_residual_method:32">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>I</mi>
        <mi>n</mi>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>c</mi>
        <mi>n</mi>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>s</mi>
        <mi>n</mi>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <msub>
         <mi>s</mi>
         <mi>n</mi>
        </msub>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>c</mi>
        <mi>n</mi>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>n</ci>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>n</ci>
      </apply>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>n</ci>
      </apply>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>n</ci>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{n}=\begin{bmatrix}I_{n}&0&0\\
0&c_{n}&s_{n}\\
0&-s_{n}&c_{n}\end{bmatrix}
  </annotation>
 </semantics>
</math>

 where</p>

<p>

<math display="block" id="Generalized_minimal_residual_method:33">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>n</mi>
     </msub>
     <mo>=</mo>
     <mrow>
      <mfrac>
       <mi>ρ</mi>
       <msqrt>
        <mrow>
         <msup>
          <mi>ρ</mi>
          <mn>2</mn>
         </msup>
         <mo>+</mo>
         <msup>
          <mi>σ</mi>
          <mn>2</mn>
         </msup>
        </mrow>
       </msqrt>
      </mfrac>
      <mtext>and</mtext>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mi>s</mi>
      <mi>n</mi>
     </msub>
     <mo>=</mo>
     <mfrac>
      <mi>σ</mi>
      <msqrt>
       <mrow>
        <msup>
         <mi>ρ</mi>
         <mn>2</mn>
        </msup>
        <mo>+</mo>
        <msup>
         <mi>σ</mi>
         <mn>2</mn>
        </msup>
       </mrow>
      </msqrt>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>n</ci>
     </apply>
     <list>
      <apply>
       <divide></divide>
       <ci>ρ</ci>
       <apply>
        <root></root>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>ρ</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>σ</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <mtext>and</mtext>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <divide></divide>
      <ci>σ</ci>
      <apply>
       <root></root>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ρ</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>σ</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{n}=\frac{\rho}{\sqrt{\rho^{2}+\sigma^{2}}}\quad\mbox{and}\quad s_{n}=\frac{%
\sigma}{\sqrt{\rho^{2}+\sigma^{2}}}.
  </annotation>
 </semantics>
</math>

 With this Givens rotation, we form</p>

<p>

<math display="block" id="Generalized_minimal_residual_method:34">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Ω</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>G</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi mathvariant="normal">Ω</mi>
          <mi>n</mi>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Ω</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <ci>n</ci>
     </apply>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Ω</ci>
        <ci>n</ci>
       </apply>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega_{n+1}=G_{n}\begin{bmatrix}\Omega_{n}&0\\
0&1\end{bmatrix}.
  </annotation>
 </semantics>
</math>

 Indeed,</p>

<p>

<math display="block" id="Generalized_minimal_residual_method:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi mathvariant="normal">Ω</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msub>
      <mover accent="true">
       <mi>H</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>R</mi>
          <mi>n</mi>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>r</mi>
          <mrow>
           <mi>n</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>r</mi>
          <mrow>
           <mrow>
            <mi>n</mi>
            <mo>+</mo>
            <mn>1</mn>
           </mrow>
           <mo>,</mo>
           <mrow>
            <mi>n</mi>
            <mo>+</mo>
            <mn>1</mn>
           </mrow>
          </mrow>
         </msub>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
     <mtext>with</mtext>
    </mrow>
   </mrow>
   <mrow>
    <msub>
     <mi>r</mi>
     <mrow>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </mrow>
    </msub>
    <mo>=</mo>
    <msqrt>
     <mrow>
      <msup>
       <mi>ρ</mi>
       <mn>2</mn>
      </msup>
      <mo>+</mo>
      <msup>
       <mi>σ</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Ω</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>H</ci>
       </apply>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <list>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <list>
          <apply>
           <plus></plus>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <plus></plus>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
         </list>
        </apply>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
      <mtext>with</mtext>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <list>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </list>
     </apply>
     <apply>
      <root></root>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ρ</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>σ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega_{n+1}\tilde{H}_{n+1}=\begin{bmatrix}R_{n}&r_{n+1}\\
0&r_{n+1,n+1}\\
0&0\end{bmatrix}\quad\text{with}\quad r_{n+1,n+1}=\sqrt{\rho^{2}+\sigma^{2}}
  </annotation>
 </semantics>
</math>

 is a triangular matrix.</p>

<p>Given the QR decomposition, the minimization problem is easily solved by noting that</p>

<p>

<math display="block" id="Generalized_minimal_residual_method:36">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mrow>
       <msub>
        <mover accent="true">
         <mi>H</mi>
         <mo stretchy="false">~</mo>
        </mover>
        <mi>n</mi>
       </msub>
       <msub>
        <mi>y</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>β</mi>
       <msub>
        <mi>e</mi>
        <mn>1</mn>
       </msub>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <msub>
       <mi mathvariant="normal">Ω</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <msub>
          <mover accent="true">
           <mi>H</mi>
           <mo stretchy="false">~</mo>
          </mover>
          <mi>n</mi>
         </msub>
         <msub>
          <mi>y</mi>
          <mi>n</mi>
         </msub>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>β</mi>
         <msub>
          <mi>e</mi>
          <mn>1</mn>
         </msub>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mrow>
       <msub>
        <mover accent="true">
         <mi>R</mi>
         <mo stretchy="false">~</mo>
        </mover>
        <mi>n</mi>
       </msub>
       <msub>
        <mi>y</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>β</mi>
       <msub>
        <mi mathvariant="normal">Ω</mi>
        <mi>n</mi>
       </msub>
       <msub>
        <mi>e</mi>
        <mn>1</mn>
       </msub>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-~</ci>
          <ci>H</ci>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>β</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Ω</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <ci>normal-~</ci>
           <ci>H</ci>
          </apply>
          <ci>n</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>β</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>e</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-~</ci>
          <ci>R</ci>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>β</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-Ω</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\tilde{H}_{n}y_{n}-\beta e_{1}\|=\|\Omega_{n}(\tilde{H}_{n}y_{n}-\beta e_{1}%
)\|=\|\tilde{R}_{n}y_{n}-\beta\Omega_{n}e_{1}\|.
  </annotation>
 </semantics>
</math>

 Denoting the vector 

<math display="inline" id="Generalized_minimal_residual_method:37">
 <semantics>
  <mrow>
   <mi>β</mi>
   <msub>
    <mi mathvariant="normal">Ω</mi>
    <mi>n</mi>
   </msub>
   <msub>
    <mi>e</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>β</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Ω</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\Omega_{n}e_{1}
  </annotation>
 </semantics>
</math>

 by</p>

<p>

<math display="block" id="Generalized_minimal_residual_method:38">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>g</mi>
        <mi>n</mi>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>γ</mi>
        <mi>n</mi>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>g</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <ci>n</ci>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>γ</ci>
       <ci>n</ci>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{g}_{n}=\begin{bmatrix}g_{n}\\
\gamma_{n}\end{bmatrix}
  </annotation>
 </semantics>
</math>

 with <em>g</em><sub><em>n</em></sub> ∈ <strong>R</strong><sup><em>n</em></sup> and γ<sub><em>n</em></sub> ∈ <strong>R</strong>, this is</p>

<p>

<math display="block" id="Generalized_minimal_residual_method:39">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mrow>
       <msub>
        <mover accent="true">
         <mi>H</mi>
         <mo stretchy="false">~</mo>
        </mover>
        <mi>n</mi>
       </msub>
       <msub>
        <mi>y</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>β</mi>
       <msub>
        <mi>e</mi>
        <mn>1</mn>
       </msub>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mrow>
       <msub>
        <mover accent="true">
         <mi>R</mi>
         <mo stretchy="false">~</mo>
        </mover>
        <mi>n</mi>
       </msub>
       <msub>
        <mi>y</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>β</mi>
       <msub>
        <mi mathvariant="normal">Ω</mi>
        <mi>n</mi>
       </msub>
       <msub>
        <mi>e</mi>
        <mn>1</mn>
       </msub>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mrow>
       <mrow>
        <mo>[</mo>
        <mtable displaystyle="true">
         <mtr>
          <mtd columnalign="center">
           <msub>
            <mi>R</mi>
            <mi>n</mi>
           </msub>
          </mtd>
         </mtr>
         <mtr>
          <mtd columnalign="center">
           <mn>0</mn>
          </mtd>
         </mtr>
        </mtable>
        <mo>]</mo>
       </mrow>
       <msub>
        <mi>y</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mo>[</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mi>g</mi>
           <mi>n</mi>
          </msub>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mi>γ</mi>
           <mi>n</mi>
          </msub>
         </mtd>
        </mtr>
       </mtable>
       <mo>]</mo>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-~</ci>
          <ci>H</ci>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>β</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-~</ci>
          <ci>R</ci>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>β</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-Ω</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <matrix>
         <matrixrow>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>R</ci>
           <ci>n</ci>
          </apply>
         </matrixrow>
         <matrixrow>
          <cn type="integer">0</cn>
         </matrixrow>
        </matrix>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <matrix>
        <matrixrow>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>g</ci>
          <ci>n</ci>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>γ</ci>
          <ci>n</ci>
         </apply>
        </matrixrow>
       </matrix>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\tilde{H}_{n}y_{n}-\beta e_{1}\|=\|\tilde{R}_{n}y_{n}-\beta\Omega_{n}e_{1}\|%
=\left\|\begin{bmatrix}R_{n}\\
0\end{bmatrix}y_{n}-\begin{bmatrix}g_{n}\\
\gamma_{n}\end{bmatrix}\right\|.
  </annotation>
 </semantics>
</math>

 The vector <em>y</em> that minimizes this expression is given by</p>

<p>

<math display="block" id="Generalized_minimal_residual_method:40">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mi>R</mi>
      <mi>n</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <msub>
      <mi>g</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n}=R_{n}^{-1}g_{n}.
  </annotation>
 </semantics>
</math>

 Again, the vectors 

<math display="inline" id="Generalized_minimal_residual_method:41">
 <semantics>
  <msub>
   <mi>g</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{n}
  </annotation>
 </semantics>
</math>

 are easy to update.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Biconjugate_gradient_method" title="wikilink">Biconjugate gradient method</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li>A. Meister, <em>Numerik linearer Gleichungssysteme</em>, 2nd edition, Vieweg 2005, ISBN 978-3-528-13135-7.</li>
<li>Y. Saad, <em>Iterative Methods for Sparse Linear Systems</em>, 2nd edition, <a href="Society_for_Industrial_and_Applied_Mathematics" title="wikilink">Society for Industrial and Applied Mathematics</a>, 2003. ISBN 978-0-89871-534-7.</li>
<li>Y. Saad and M.H. Schultz, "GMRES: A generalized minimal residual algorithm for solving nonsymmetric linear systems", <em>SIAM J. Sci. Stat. Comput.</em>, <strong>7</strong>:856-869, 1986. .</li>
<li>J. Stoer and R. Bulirsch, <em>Introduction to numerical analysis</em>, 3rd edition, Springer, New York, 2002. ISBN 978-0-387-95452-3.</li>
<li>Lloyd N. Trefethen and David Bau, III, <em>Numerical Linear Algebra</em>, Society for Industrial and Applied Mathematics, 1997. ISBN 978-0-89871-361-9.</li>
<li>[<a class="uri" href="http://www.netlib.org/linalg/html_templates/node29.html#SECTION00734000000000000000|J">http://www.netlib.org/linalg/html_templates/node29.html#SECTION00734000000000000000|J</a>. Dongarra et al. , <em>Templates for the Solution of Linear Systems: Building Blocks for Iterative Methods</em>], 2nd Edition, SIAM, Philadelphia, 1994</li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_linear_algebra" title="wikilink">Category:Numerical linear algebra</a> <a href="Category:Articles_with_example_pseudocode" title="wikilink">Category:Articles with example pseudocode</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Saad and Schultz<a href="#fnref1">↩</a></li>
<li id="fn2">Trefethen &amp; Bau, Thm 35.2<a href="#fnref2">↩</a></li>
<li id="fn3">Stoer and Bulirsch, §8.7.2<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
