   Entanglement-assisted stabilizer formalism      Entanglement-assisted stabilizer formalism   In the theory of quantum communication , the entanglement-assisted stabilizer formalism is a method for protecting quantum information with the help of entanglement shared between a sender and receiver before they transmit quantum data over a quantum communication channel. It extends the standard stabilizer formalism by including shared entanglement (Brun et al. 2006). The advantage of entanglement-assisted stabilizer codes is that the sender can exploit the error-correcting properties of an arbitrary set of Pauli operators . The sender's Pauli operators do not necessarily have to form an Abelian  subgroup of the Pauli group     Œ†  n     superscript  normal-Œ†  n    \Pi^{n}   over   n   n   n    qubits . The sender can make clever use of her shared ebits so that the global stabilizer is Abelian and thus forms a valid quantum error-correcting code .  Definition  We review the construction of an entanglement-assisted code (Brun et al. 2006). Suppose that there is a nonabelian  subgroup     ùíÆ  ‚äÇ   Œ†  n       ùíÆ   superscript  normal-Œ†  n     \mathcal{S}\subset\Pi^{n}   of size     n  -  k   =    2  c   +  s         n  k       2  c   s     n-k=2c+s   . Application of the fundamental theorem of symplectic geometry (Lemma 1 in the first external reference) states that there exists a minimal set of independent generators    {    Z  ¬Ø   1   ,  ‚Ä¶  ,    Z  ¬Ø    s  +  c    ,    X  ¬Ø    s  +  1    ,  ‚Ä¶  ,    X  ¬Ø    s  +  c    }      subscript   normal-¬Ø  Z   1   normal-‚Ä¶   subscript   normal-¬Ø  Z     s  c     subscript   normal-¬Ø  X     s  1    normal-‚Ä¶   subscript   normal-¬Ø  X     s  c      \left\{\bar{Z}_{1},\ldots,\bar{Z}_{s+c},\bar{X}_{s+1},\ldots,\bar{X}_{s+c}\right\}   for   ùíÆ   ùíÆ   \mathcal{S}   with the following commutation relations:        [    Z  ¬Ø   i   ,    Z  ¬Ø   j   ]   =   0   ‚àÄ  i   ,  j    ,        subscript   normal-¬Ø  Z   i    subscript   normal-¬Ø  Z   j     0   for-all  i   j     \left[\bar{Z}_{i},\bar{Z}_{j}\right]=0\ \ \ \ \ \forall i,j,           [    X  ¬Ø   i   ,    X  ¬Ø   j   ]   =   0   ‚àÄ  i   ,  j    ,        subscript   normal-¬Ø  X   i    subscript   normal-¬Ø  X   j     0   for-all  i   j     \left[\bar{X}_{i},\bar{X}_{j}\right]=0\ \ \ \ \ \forall i,j,            [    X  ¬Ø   i   ,    Z  ¬Ø   j   ]   =  0     ‚àÄ  i   ‚â†  j    ,     formulae-sequence      subscript   normal-¬Ø  X   i    subscript   normal-¬Ø  Z   j    0      for-all  i   j     \left[\bar{X}_{i},\bar{Z}_{j}\right]=0\ \ \ \ \ \forall i\neq j,           {    X  ¬Ø   i   ,    Z  ¬Ø   i   }   =   0   ‚àÄ  i     .        subscript   normal-¬Ø  X   i    subscript   normal-¬Ø  Z   i     0   for-all  i      \left\{\bar{X}_{i},\bar{Z}_{i}\right\}=0\ \ \ \ \ \forall i.   The decomposition of   ùíÆ   ùíÆ   \mathcal{S}   into the above minimal generating set determines that the code requires   s   s   s   ancilla qubits and   c   c   c    ebits . The code requires an ebit for every anticommuting pair in the minimal generating set. The simple reason for this requirement is that an ebit is a simultaneous    +  1      1    +1   - eigenstate of the Pauli operators     {   X  X   ,   Z  Z   }       X  X     Z  Z     \left\{XX,ZZ\right\}   . The second qubit in the ebit transforms the anticommuting pair    {  X  ,  Z  }     X  Z    \left\{X,Z\right\}   into a commuting pair    {   X  X   ,   Z  Z   }       X  X     Z  Z     \left\{XX,ZZ\right\}   . The above decomposition also minimizes the number of ebits required for the code---it is an optimal decomposition.  We can partition the nonabelian group    ùíÆ   ùíÆ   \mathcal{S}   into two subgroups : the isotropic subgroup    ùíÆ  I     subscript  ùíÆ  I    \mathcal{S}_{I}   and the entanglement subgroup    ùíÆ  E     subscript  ùíÆ  E    \mathcal{S}_{E}   . The isotropic subgroup    ùíÆ  I     subscript  ùíÆ  I    \mathcal{S}_{I}   is a commuting subgroup of   ùíÆ   ùíÆ   \mathcal{S}   and thus corresponds to ancilla qubits:       ùíÆ  I   =   {    Z  ¬Ø   1   ,  ‚Ä¶  ,    Z  ¬Ø   s   }        subscript  ùíÆ  I     subscript   normal-¬Ø  Z   1   normal-‚Ä¶   subscript   normal-¬Ø  Z   s      \mathcal{S}_{I}=\left\{\bar{Z}_{1},\ldots,\bar{Z}_{s}\right\}   .  The elements of the entanglement subgroup    ùíÆ  E     subscript  ùíÆ  E    \mathcal{S}_{E}   come in anticommuting pairs and thus correspond to ebits :       ùíÆ  E   =   {    Z  ¬Ø    s  +  1    ,  ‚Ä¶  ,    Z  ¬Ø    s  +  c    ,    X  ¬Ø    s  +  1    ,  ‚Ä¶  ,    X  ¬Ø    s  +  c    }        subscript  ùíÆ  E     subscript   normal-¬Ø  Z     s  1    normal-‚Ä¶   subscript   normal-¬Ø  Z     s  c     subscript   normal-¬Ø  X     s  1    normal-‚Ä¶   subscript   normal-¬Ø  X     s  c       \mathcal{S}_{E}=\left\{\bar{Z}_{s+1},\ldots,\bar{Z}_{s+c},\bar{X}_{s+1},\ldots%
 ,\bar{X}_{s+c}\right\}   .  Entanglement-assisted stabilizer code error correction conditions  The two subgroups    ùíÆ  I     subscript  ùíÆ  I    \mathcal{S}_{I}   and    ùíÆ  E     subscript  ùíÆ  E    \mathcal{S}_{E}   play a role in the error-correcting conditions for the entanglement-assisted stabilizer formalism. An entanglement-assisted code corrects errors in a set    ‚Ñ∞  ‚äÇ   Œ†  n       ‚Ñ∞   superscript  normal-Œ†  n     \mathcal{E}\subset\Pi^{n}   if for all      E  1   ,   E  2    ‚àà  ‚Ñ∞        subscript  E  1    subscript  E  2    ‚Ñ∞    E_{1},E_{2}\in\mathcal{E}   ,         E  1  ‚Ä†    E  2    ‚àà    ùíÆ  I   ‚à™   (    Œ†  n   -   ùíµ   (   ‚ü®   ùíÆ  I   ,   ùíÆ  E   ‚ü©   )     )     .         superscript   subscript  E  1   normal-‚Ä†    subscript  E  2       subscript  ùíÆ  I      superscript  normal-Œ†  n     ùíµ    subscript  ùíÆ  I    subscript  ùíÆ  E         E_{1}^{\dagger}E_{2}\in\mathcal{S}_{I}\cup\left(\Pi^{n}-\mathcal{Z}\left(\left%
 \langle\mathcal{S}_{I},\mathcal{S}_{E}\right\rangle\right)\right).     Operation  The operation of an entanglement-assisted code is as follows. The sender performs an encoding unitary on her unprotected qubits, ancilla qubits, and her half of the ebits . The unencoded state is a simultaneous +1- eigenstate of the following Pauli operators :       {   Z  1   ,  ‚Ä¶  ,   Z  s   ,   Z   s  +  1    |   Z  1   ,  ‚Ä¶  ,   Z   s  +  c    |   Z  c   ,   X   s  +  1    |   X  1   ,  ‚Ä¶  ,   X   s  +  c    |   X  c   }   .     fragments   fragments  normal-{   subscript  Z  1   normal-,  normal-‚Ä¶  normal-,   subscript  Z  s   normal-,   subscript  Z    s  1    normal-|   subscript  Z  1   normal-,  normal-‚Ä¶  normal-,   subscript  Z    s  c    normal-|   subscript  Z  c   normal-,   subscript  X    s  1    normal-|   subscript  X  1   normal-,  normal-‚Ä¶  normal-,   subscript  X    s  c    normal-|   subscript  X  c   normal-}   normal-.    \left\{Z_{1},\ldots,Z_{s},Z_{s+1}|Z_{1},\ldots,Z_{s+c}|Z_{c},X_{s+1}|X_{1},%
 \ldots,X_{s+c}|X_{c}\right\}.     The Pauli operators to the right of the vertical bars indicate the receiver's half of the shared ebits . The encoding unitary transforms the unencoded Pauli operators to the following encoded Pauli operators :       {    Z  ¬Ø   1   ,  ‚Ä¶  ,    Z  ¬Ø   s   ,    Z  ¬Ø    s  +  1    |   Z  1   ,  ‚Ä¶  ,    Z  ¬Ø    s  +  c    |   Z  c   ,    X  ¬Ø    s  +  1    |   X  1   ,  ‚Ä¶  ,    X  ¬Ø    s  +  c    |   X  c   }   .     fragments   fragments  normal-{   subscript   normal-¬Ø  Z   1   normal-,  normal-‚Ä¶  normal-,   subscript   normal-¬Ø  Z   s   normal-,   subscript   normal-¬Ø  Z     s  1    normal-|   subscript  Z  1   normal-,  normal-‚Ä¶  normal-,   subscript   normal-¬Ø  Z     s  c    normal-|   subscript  Z  c   normal-,   subscript   normal-¬Ø  X     s  1    normal-|   subscript  X  1   normal-,  normal-‚Ä¶  normal-,   subscript   normal-¬Ø  X     s  c    normal-|   subscript  X  c   normal-}   normal-.    \left\{\bar{Z}_{1},\ldots,\bar{Z}_{s},\bar{Z}_{s+1}|Z_{1},\ldots,\bar{Z}_{s+c}%
 |Z_{c},\bar{X}_{s+1}|X_{1},\ldots,\bar{X}_{s+c}|X_{c}\right\}.   The sender transmits all of her qubits over the noisy quantum channel . The receiver then possesses the transmitted qubits and his half of the ebits . He measures the above encoded operators to diagnose the error. The last step is to correct for the error.  Rate of an entanglement-assisted code  We can interpret the rate of an entanglement-assisted code in three different ways (Wilde and Brun 2007b). Suppose that an entanglement-assisted quantum code encodes   k   k   k   information qubits into   n   n   n   physical qubits with the help of   c   c   c   ebits.   The entanglement-assisted rate assumes that entanglement shared between sender and receiver is free. Bennett et al. make this assumption when deriving the entanglement assisted capacity of a quantum channel for sending quantum information. The entanglement-assisted rate is    k  /  n      k  n    k/n   for a code with the above parameters.    The trade-off rate assumes that entanglement is not free and a rate pair determines performance. The first number in the pair is the number of noiseless qubits generated per channel use, and the second number in the pair is the number of ebits consumed per channel use. The rate pair is    (   k  /  n   ,   c  /  n   )       k  n     c  n     \left(k/n,c/n\right)   for a code with the above parameters. Quantum information theorists have computed asymptotic trade-off curves that bound the rate region in which achievable rate pairs lie. The construction for an entanglement-assisted quantum block code minimizes the number   c   c   c   of ebits given a fixed number   k   k   k   and   n   n   n   of respective information qubits and physical qubits.    The catalytic rate assumes that bits of entanglement are built up at the expense of transmitted qubits. A noiseless quantum channel or the encoded use of noisy quantum channel are two different ways to build up entanglement between a sender and receiver. The catalytic rate of an    [  n  ,  k  ;  c  ]     n  k  c    \left[n,k;c\right]   code is     (   k  -  c   )   /  n        k  c   n    \left(k-c\right)/n   .   Which interpretation is most reasonable depends on the context in which we use the code. In any case, the parameters   n   n   n   ,   k   k   k   , and   c   c   c   ultimately govern performance, regardless of which definition of the rate we use to interpret that performance.  Example of an entanglement-assisted code  We present an example of an entanglement-assisted code that corrects an arbitrary single-qubit error (Brun et al. 2006). Suppose the sender wants to use the quantum error-correcting properties of the following nonabelian subgroup of    Œ†  4     superscript  normal-Œ†  4    \Pi^{4}   :        Z    X    Z    I      Z    Z    I    Z      X    Y    X    I      X    X    I    X        Z  X  Z  I    Z  Z  I  Z    X  Y  X  I    X  X  I  X     \begin{array}[c]{cccc}Z&X&Z&I\\
 Z&Z&I&Z\\
 X&Y&X&I\\
 X&X&I&X\end{array}   The first two generators anticommute. We obtain a modified third generator by multiplying the third generator by the second. We then multiply the last generator by the first, second, and modified third generators. The error-correcting properties of the generators are invariant under these operations. The modified generators are as follows:         g  1     =    Z    X    Z    I       g  2     =    Z    Z    I    Z       g  3     =    Y    X    X    Z       g  4     =    Z    Y    Y    X         subscript  g  1    Z  X  Z  I     subscript  g  2    Z  Z  I  Z     subscript  g  3    Y  X  X  Z     subscript  g  4    Z  Y  Y  X     \begin{array}[c]{cccccc}g_{1}&=&Z&X&Z&I\\
 g_{2}&=&Z&Z&I&Z\\
 g_{3}&=&Y&X&X&Z\\
 g_{4}&=&Z&Y&Y&X\end{array}   The above set of generators have the commutation relations given by the fundamental theorem of symplectic geometry:       {   g  1   ,   g  2   }   =   [   g  1   ,   g  3   ]   =   [   g  1   ,   g  4   ]   =   [   g  2   ,   g  3   ]   =   [   g  2   ,   g  4   ]   =   [   g  3   ,   g  4   ]   =  0.          subscript  g  1    subscript  g  2      subscript  g  1    subscript  g  3           subscript  g  1    subscript  g  4           subscript  g  2    subscript  g  3           subscript  g  2    subscript  g  4           subscript  g  3    subscript  g  4         0.     \left\{g_{1},g_{2}\right\}=\left[g_{1},g_{3}\right]=\left[g_{1},g_{4}\right]=%
 \left[g_{2},g_{3}\right]=\left[g_{2},g_{4}\right]=\left[g_{3},g_{4}\right]=0.   The above set of generators is unitarily equivalent to the following canonical generators:        X    I    I    I      Z    I    I    I      I    Z    I    I      I    I    Z    I        X  I  I  I    Z  I  I  I    I  Z  I  I    I  I  Z  I     \begin{array}[c]{cccc}X&I&I&I\\
 Z&I&I&I\\
 I&Z&I&I\\
 I&I&Z&I\end{array}   We can add one ebit to resolve the anticommutativity of the first two generators and obtain the canonical stabilizer:         X      Z      I      I     |     X    I    I    I      Z    I    I    I      I    Z    I    I      I    I    Z    I        fragments    X    Z    I    I    normal-|    X  I  I  I    Z  I  I  I    I  Z  I  I    I  I  Z  I      \begin{array}[c]{c}X\\
 Z\\
 I\\
 I\end{array}\left|\begin{array}[c]{cccc}X&I&I&I\\
 Z&I&I&I\\
 I&Z&I&I\\
 I&I&Z&I\end{array}\right.   The receiver Bob possesses the qubit on the left and the sender Alice possesses the four qubits on the right. The following state is an eigenstate of the above stabilizer         |   Œ¶  +   ‚ü©    B  A      |  00  ‚ü©   A     |  œà  ‚ü©   A    .       superscript   ket   superscript  normal-Œ¶       B  A     superscript   ket  00   A    superscript   ket  œà   A     \left|\Phi^{+}\right\rangle^{BA}\left|00\right\rangle^{A}\left|\psi\right%
 \rangle^{A}.   where     |  œà  ‚ü©   A     superscript   ket  œà   A    \left|\psi\right\rangle^{A}   is a qubit that the sender wants to encode. The encoding unitary then rotates the canonical stabilizer to the following set of globally commuting generators:         X      Z      I      I     |     Z    X    Z    I      Z    Z    I    Z      Y    X    X    Z      Z    Y    Y    X        fragments    X    Z    I    I    normal-|    Z  X  Z  I    Z  Z  I  Z    Y  X  X  Z    Z  Y  Y  X      \begin{array}[c]{c}X\\
 Z\\
 I\\
 I\end{array}\left|\begin{array}[c]{cccc}Z&X&Z&I\\
 Z&Z&I&Z\\
 Y&X&X&Z\\
 Z&Y&Y&X\end{array}\right.   The receiver measures the above generators upon receipt of all qubits to detect and correct errors.  Encoding algorithm  We continue with the previous example. We detail an algorithm for determining an encoding circuit and the optimal number of ebits for the entanglement-assisted code---this algorithm first appeared in the appendix of (Wilde and Brun 2007a) and later in the appendix of (Shaw et al. 2008). The operators in the above example have the following representation as a binary matrix (See the stabilizer code article):      H  =   [     1    0    1    0      1    1    0    1      0    1    0    0      0    0    0    0     |     0    1    0    0      0    0    0    0      1    1    1    0      1    1    0    1     ]   .     fragments  H    fragments  normal-[    1  0  1  0    1  1  0  1    0  1  0  0    0  0  0  0    normal-|    0  1  0  0    0  0  0  0    1  1  1  0    1  1  0  1    normal-]   normal-.    H=\left[\left.\begin{array}[c]{cccc}1&0&1&0\\
 1&1&0&1\\
 0&1&0&0\\
 0&0&0&0\end{array}\right|\begin{array}[c]{cccc}0&1&0&0\\
 0&0&0&0\\
 1&1&1&0\\
 1&1&0&1\end{array}\right].   Call the matrix to the left of the vertical bar the "   Z   Z   Z   matrix" and the matrix to the right of the vertical bar the "   X   X   X   matrix."  The algorithm consists of row and column operations on the above matrix. Row operations do not affect the error-correcting properties of the code but are crucial for arriving at the optimal decomposition from the fundamental theorem of symplectic geometry. The operations available for manipulating columns of the above matrix are Clifford operations. Clifford operations preserve the Pauli group    Œ†  n     superscript  normal-Œ†  n    \Pi^{n}   under conjugation. The CNOT gate, the Hadamard gate, and the Phase gate generate the Clifford group. A CNOT gate from qubit   i   i   i   to qubit   j   j   j   adds column   i   i   i   to column   j   j   j   in the   X   X   X   matrix and adds column   j   j   j   to column   i   i   i   in the   Z   Z   Z   matrix. A Hadamard gate on qubit   i   i   i   swaps column   i   i   i   in the   Z   Z   Z   matrix with column   i   i   i   in the   X   X   X   matrix and vice versa. A phase gate on qubit   i   i   i   adds column   i   i   i   in the   X   X   X   matrix to column   i   i   i   in the   Z   Z   Z   matrix. Three CNOT gates implement a qubit swap operation. The effect of a swap on qubits   i   i   i   and   j   j   j   is to swap columns   i   i   i   and   j   j   j   in both the   X   X   X   and   Z   Z   Z   matrix.  The algorithm begins by computing the symplectic product between the first row and all other rows. We emphasize that the symplectic product here is the standard symplectic product. Leave the matrix as it is if the first row is not symplectically orthogonal to the second row or if the first row is symplectically orthogonal to all other rows. Otherwise, swap the second row with the first available row that is not symplectically orthogonal to the first row. In our example, the first row is not symplectically orthogonal to the second so we leave all rows as they are.  Arrange the first row so that the top left entry in the   X   X   X   matrix is one. A CNOT, swap, Hadamard, or combinations of these operations can achieve this result. We can have this result in our example by swapping qubits one and two. The matrix becomes       [     0    1    1    0      1    1    0    1      1    0    0    0      0    0    0    0     |     1    0    0    0      0    0    0    0      1    1    1    0      1    1    0    1     ]   .     fragments   fragments  normal-[    0  1  1  0    1  1  0  1    1  0  0  0    0  0  0  0    normal-|    1  0  0  0    0  0  0  0    1  1  1  0    1  1  0  1    normal-]   normal-.    \left[\left.\begin{array}[c]{cccc}0&1&1&0\\
 1&1&0&1\\
 1&0&0&0\\
 0&0&0&0\end{array}\right|\begin{array}[c]{cccc}1&0&0&0\\
 0&0&0&0\\
 1&1&1&0\\
 1&1&0&1\end{array}\right].   Perform CNOTs to clear the entries in the   X   X   X   matrix in the top row to the right of the leftmost entry. These entries are already zero in this example so we need not do anything. Proceed to the clear the entries in the first row of the   Z   Z   Z   matrix. Perform a phase gate to clear the leftmost entry in the first row of the   Z   Z   Z   matrix if it is equal to one. It is equal to zero in this case so we need not do anything. We then use Hadamards and CNOTs to clear the other entries in the first row of the   Z   Z   Z   matrix.  We perform the above operations for our example. Perform a Hadamard on qubits two and three. The matrix becomes       [     0    0    0    0      1    0    0    1      1    1    1    0      0    1    0    0     |     1    1    1    0      0    1    0    0      1    0    0    0      1    0    0    1     ]   .     fragments   fragments  normal-[    0  0  0  0    1  0  0  1    1  1  1  0    0  1  0  0    normal-|    1  1  1  0    0  1  0  0    1  0  0  0    1  0  0  1    normal-]   normal-.    \left[\left.\begin{array}[c]{cccc}0&0&0&0\\
 1&0&0&1\\
 1&1&1&0\\
 0&1&0&0\end{array}\right|\begin{array}[c]{cccc}1&1&1&0\\
 0&1&0&0\\
 1&0&0&0\\
 1&0&0&1\end{array}\right].   Perform a CNOT from qubit one to qubit two and from qubit one to qubit three. The matrix becomes       [     0    0    0    0      1    0    0    1      1    1    1    0      1    1    0    0     |     1    0    0    0      0    1    0    0      1    1    1    0      1    1    1    1     ]   .     fragments   fragments  normal-[    0  0  0  0    1  0  0  1    1  1  1  0    1  1  0  0    normal-|    1  0  0  0    0  1  0  0    1  1  1  0    1  1  1  1    normal-]   normal-.    \left[\left.\begin{array}[c]{cccc}0&0&0&0\\
 1&0&0&1\\
 1&1&1&0\\
 1&1&0&0\end{array}\right|\begin{array}[c]{cccc}1&0&0&0\\
 0&1&0&0\\
 1&1&1&0\\
 1&1&1&1\end{array}\right].   The first row is complete. We now proceed to clear the entries in the second row. Perform a Hadamard on qubits one and four. The matrix becomes       [     1    0    0    0      0    0    0    0      1    1    1    0      1    1    0    1     |     0    0    0    0      1    1    0    1      1    1    1    0      1    1    1    0     ]   .     fragments   fragments  normal-[    1  0  0  0    0  0  0  0    1  1  1  0    1  1  0  1    normal-|    0  0  0  0    1  1  0  1    1  1  1  0    1  1  1  0    normal-]   normal-.    \left[\left.\begin{array}[c]{cccc}1&0&0&0\\
 0&0&0&0\\
 1&1&1&0\\
 1&1&0&1\end{array}\right|\begin{array}[c]{cccc}0&0&0&0\\
 1&1&0&1\\
 1&1&1&0\\
 1&1&1&0\end{array}\right].   Perform a CNOT from qubit one to qubit two and from qubit one to qubit four. The matrix becomes       [     1    0    0    0      0    0    0    0      0    1    1    0      1    1    0    1     |     0    0    0    0      1    0    0    0      1    0    1    1      1    0    1    1     ]   .     fragments   fragments  normal-[    1  0  0  0    0  0  0  0    0  1  1  0    1  1  0  1    normal-|    0  0  0  0    1  0  0  0    1  0  1  1    1  0  1  1    normal-]   normal-.    \left[\left.\begin{array}[c]{cccc}1&0&0&0\\
 0&0&0&0\\
 0&1&1&0\\
 1&1&0&1\end{array}\right|\begin{array}[c]{cccc}0&0&0&0\\
 1&0&0&0\\
 1&0&1&1\\
 1&0&1&1\end{array}\right].   The first two rows are now complete. They need one ebit to compensate for their anticommutativity or their nonorthogonality with respect to the symplectic product.  Now we perform a "Gram-Schmidt orthogonalization" with respect to the symplectic product. Add row one to any other row that has one as the leftmost entry in its   Z   Z   Z   matrix. Add row two to any other row that has one as the leftmost entry in its   X   X   X   matrix. For our example, we add row one to row four and we add row two to rows three and four. The matrix becomes       [     1    0    0    0      0    0    0    0      0    1    1    0      0    1    0    1     |     0    0    0    0      1    0    0    0      0    0    1    1      0    0    1    1     ]   .     fragments   fragments  normal-[    1  0  0  0    0  0  0  0    0  1  1  0    0  1  0  1    normal-|    0  0  0  0    1  0  0  0    0  0  1  1    0  0  1  1    normal-]   normal-.    \left[\left.\begin{array}[c]{cccc}1&0&0&0\\
 0&0&0&0\\
 0&1&1&0\\
 0&1&0&1\end{array}\right|\begin{array}[c]{cccc}0&0&0&0\\
 1&0&0&0\\
 0&0&1&1\\
 0&0&1&1\end{array}\right].   The first two rows are now symplectically orthogonal to all other rows per the fundamental theorem of symplectic geometry. We proceed with the same algorithm on the next two rows. The next two rows are symplectically orthogonal to each other so we can deal with them individually. Perform a Hadamard on qubit two. The matrix becomes       [     1    0    0    0      0    0    0    0      0    0    1    0      0    0    0    1     |     0    0    0    0      1    0    0    0      0    1    1    1      0    1    1    1     ]   .     fragments   fragments  normal-[    1  0  0  0    0  0  0  0    0  0  1  0    0  0  0  1    normal-|    0  0  0  0    1  0  0  0    0  1  1  1    0  1  1  1    normal-]   normal-.    \left[\left.\begin{array}[c]{cccc}1&0&0&0\\
 0&0&0&0\\
 0&0&1&0\\
 0&0&0&1\end{array}\right|\begin{array}[c]{cccc}0&0&0&0\\
 1&0&0&0\\
 0&1&1&1\\
 0&1&1&1\end{array}\right].   Perform a CNOT from qubit two to qubit three and from qubit two to qubit four. The matrix becomes       [     1    0    0    0      0    0    0    0      0    1    1    0      0    1    0    1     |     0    0    0    0      1    0    0    0      0    1    0    0      0    1    0    0     ]   .     fragments   fragments  normal-[    1  0  0  0    0  0  0  0    0  1  1  0    0  1  0  1    normal-|    0  0  0  0    1  0  0  0    0  1  0  0    0  1  0  0    normal-]   normal-.    \left[\left.\begin{array}[c]{cccc}1&0&0&0\\
 0&0&0&0\\
 0&1&1&0\\
 0&1&0&1\end{array}\right|\begin{array}[c]{cccc}0&0&0&0\\
 1&0&0&0\\
 0&1&0&0\\
 0&1&0&0\end{array}\right].   Perform a phase gate on qubit two:       [     1    0    0    0      0    0    0    0      0    0    1    0      0    0    0    1     |     0    0    0    0      1    0    0    0      0    1    0    0      0    1    0    0     ]   .     fragments   fragments  normal-[    1  0  0  0    0  0  0  0    0  0  1  0    0  0  0  1    normal-|    0  0  0  0    1  0  0  0    0  1  0  0    0  1  0  0    normal-]   normal-.    \left[\left.\begin{array}[c]{cccc}1&0&0&0\\
 0&0&0&0\\
 0&0&1&0\\
 0&0&0&1\end{array}\right|\begin{array}[c]{cccc}0&0&0&0\\
 1&0&0&0\\
 0&1&0&0\\
 0&1&0&0\end{array}\right].   Perform a Hadamard on qubit three followed by a CNOT from qubit two to qubit three:       [     1    0    0    0      0    0    0    0      0    0    0    0      0    0    0    1     |     0    0    0    0      1    0    0    0      0    1    0    0      0    1    1    0     ]   .     fragments   fragments  normal-[    1  0  0  0    0  0  0  0    0  0  0  0    0  0  0  1    normal-|    0  0  0  0    1  0  0  0    0  1  0  0    0  1  1  0    normal-]   normal-.    \left[\left.\begin{array}[c]{cccc}1&0&0&0\\
 0&0&0&0\\
 0&0&0&0\\
 0&0&0&1\end{array}\right|\begin{array}[c]{cccc}0&0&0&0\\
 1&0&0&0\\
 0&1&0&0\\
 0&1&1&0\end{array}\right].   Add row three to row four and perform a Hadamard on qubit two:       [     1    0    0    0      0    0    0    0      0    1    0    0      0    0    0    1     |     0    0    0    0      1    0    0    0      0    0    0    0      0    0    1    0     ]   .     fragments   fragments  normal-[    1  0  0  0    0  0  0  0    0  1  0  0    0  0  0  1    normal-|    0  0  0  0    1  0  0  0    0  0  0  0    0  0  1  0    normal-]   normal-.    \left[\left.\begin{array}[c]{cccc}1&0&0&0\\
 0&0&0&0\\
 0&1&0&0\\
 0&0&0&1\end{array}\right|\begin{array}[c]{cccc}0&0&0&0\\
 1&0&0&0\\
 0&0&0&0\\
 0&0&1&0\end{array}\right].   Perform a Hadamard on qubit four followed by a CNOT from qubit three to qubit four. End by performing a Hadamard on qubit three:       [     1    0    0    0      0    0    0    0      0    1    0    0      0    0    1    0     |     0    0    0    0      1    0    0    0      0    0    0    0      0    0    0    0     ]   .     fragments   fragments  normal-[    1  0  0  0    0  0  0  0    0  1  0  0    0  0  1  0    normal-|    0  0  0  0    1  0  0  0    0  0  0  0    0  0  0  0    normal-]   normal-.    \left[\left.\begin{array}[c]{cccc}1&0&0&0\\
 0&0&0&0\\
 0&1&0&0\\
 0&0&1&0\end{array}\right|\begin{array}[c]{cccc}0&0&0&0\\
 1&0&0&0\\
 0&0&0&0\\
 0&0&0&0\end{array}\right].   The above matrix now corresponds to the canonical Pauli operators. Adding one half of an ebit to the receiver's side gives the canonical stabilizer whose simultaneous +1-eigenstate is the above state. The above operations in reverse order take the canonical stabilizer to the encoded stabilizer.  References   Todd A. Brun, Igor Devetak, and Min-Hsiu Hsieh. Correcting Quantum Errors with Entanglement. Science 314, 436 (2006). Available at http://arxiv.org/abs/quant-ph/0610092  Min-Hsiu Hsieh. Entanglement-assisted Coding Theory. Ph.D. Dissertation, University of Southern California, August 2008. Available at http://arxiv.org/abs/0807.2080  Mark M. Wilde. Quantum Coding with Entanglement. Ph.D. Dissertation, University of Southern California, August 2008. Available at http://arxiv.org/abs/0806.4214  Min-Hsiu Hsieh, Igor Devetak, Todd A. Brun. General entanglement-assisted quantum error-correcting codes. Phys. Rev. A 76, 062313 (2007). Available at http://arxiv.org/abs/0708.2142  Isaac Kremsky, Min-Hsiu Hsieh, Todd A. Brun. Classical Enhancement of Quantum Error-Correcting Codes. Phys. Rev. A 78, 012341 (2008). Available at http://arxiv.org/abs/0802.2414  Mark M. Wilde and Todd A. Brun. Optimal Entanglement Formulas for Entanglement-Assisted Quantum Coding. Phys. Rev. A 77, 064302 (2008). Available at http://arxiv.org/abs/0804.1404  Mark M. Wilde and Todd A. Brun. (2007a) Convolutional Entanglement Distillation. Available at http://arxiv.org/abs/0708.3699  Mark M. Wilde and Todd A. Brun. (2007b) Entanglement-assisted quantum convolutional coding. Available at http://arxiv.org/abs/0712.2223  Mark M. Wilde and Todd A. Brun. Quantum Convolutional Coding with Shared Entanglement: General Structure. Available at http://arxiv.org/abs/0807.3803  Bilal Shaw, Mark M. Wilde, Ognyan Oreshkov, Isaac Kremsky, and Daniel A. Lidar. Encoding One Logical Qubit Into Six Physical Qubits. Physical Review A 78, 012337 (2008). Available at http://arxiv.org/abs/0803.1495   "  Category:Linear algebra   