<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1161">Very smooth hash</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Very smooth hash</h1>
<hr/>

<p>In <a class="uri" href="cryptography" title="wikilink">cryptography</a>, <strong>Very Smooth Hash (VSH)</strong> is a  secure <a href="cryptographic_hash_function" title="wikilink">cryptographic hash function</a> invented in 2005 by Scott Contini, Arjen Lenstra and Ron Steinfeld. <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <a href="Provably_secure_cryptographic_hash_function" title="wikilink">Provably secure</a> means that finding collisions is as difficult as some known hard mathematical problem. Unlike other  secure <a href="Collision_resistance" title="wikilink">collision-resistant</a> hashes, VSH is efficient and usable in practice. <a href="Big_O_notation" title="wikilink">Asymptotically</a>, it only requires a single multiplication per log(<em>n</em>) message-bits and uses RSA-type arithmetic. Therefore, VSH can be useful in embedded environments where code space is limited.</p>

<p>Two major variants of VSH were proposed. For one finding a <a href="Collision_resistance" title="wikilink">collision</a> is  as difficult as finding a nontrivial modular square root of a very smooth number modulo <em>n</em>. The other one uses a prime modulus <em>p</em> (with no <a href="Trapdoor_function" title="wikilink">trapdoor</a>), and its security proof relies on the hardness of finding discrete logarithms of very smooth numbers modulo <em>p</em>. Both versions have similar efficiency.</p>

<p>VSH is not suitable as a substitute for a <a href="random_oracle" title="wikilink">random oracle</a>, but can be used to build a  secure randomized trapdoor hash function. This function can replace the <a href="trapdoor_function" title="wikilink">trapdoor function</a> used in the <a href="Cramer–Shoup_cryptosystem" title="wikilink">Cramer-Shoup signature scheme</a>, maintaining its provable security while speeding up verification time by about 50%.</p>
<h2 id="vsn-and-vssr">VSN and VSSR</h2>

<p>All cryptographic hash functions that are now widely used are not based on hard mathematical problems. Those few functions that are constructed on hard mathematical problems are called <a href="Provably_secure_cryptographic_hash_function" title="wikilink">provably secure</a>. <a href="Collision_resistance" title="wikilink">Finding collisions</a> is then known to be as hard as solving the hard mathematical problem. For the basic version of Very Smooth Hash function, this hard problem is to find modular square roots (VSSR) of certain special numbers (VSN).<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> This is assumed to be as hard as <a href="Integer_factorization" title="wikilink">factoring integers</a>.</p>

<p>For a fixed constant <em>c</em> and <em>n</em> an integer <em>m</em> is a <strong>Very Smooth Number (VSN)</strong> if the largest prime factor of <em>m</em> is at most (log <em>n</em>)<sup><em>c</em></sup>.</p>

<p>An integer <em>b</em> is a <strong>Very Smooth Quadratic Residue</strong> modulo <em>n</em> if the largest prime in <em>b</em>’s factorization is at most (log <em>n</em>)<sup><em>c</em></sup> and there exists an integer <em>x</em> such that 

<math display="inline" id="Very_smooth_hash:0">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>≡</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>b</ci>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\equiv x^{2}\mod n
  </annotation>
 </semantics>
</math>

. The integer <em>x</em> is said to be a <a href="Quadratic_residue" title="wikilink">Modular Square Root</a> of <em>b</em>.</p>

<p>We are interested only in non-trivial square roots, those where <em>x</em><sup>2</sup> ≥ <em>n</em>. If <em>x</em><sup>2</sup> k\le(\log n)^c. Let 

<math display="inline" id="Very_smooth_hash:1">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mn>2</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>p</mi>
      <mn>2</mn>
     </msub>
     <mo>=</mo>
     <mn>3</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>p</mi>
      <mn>3</mn>
     </msub>
     <mo>=</mo>
     <mrow>
      <mn>5</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">3</cn>
      </apply>
      <list>
       <cn type="integer">5</cn>
       <ci>normal-…</ci>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1}=2,p_{2}=3,p_{3}=5,\dots
  </annotation>
 </semantics>
</math>

 be the sequence of primes. VSSR is the following problem: Given <em>n</em>, find 

<math display="inline" id="Very_smooth_hash:2">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msubsup>
    <mi>ℤ</mi>
    <mi>n</mi>
    <mo>*</mo>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℤ</ci>
      <times></times>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\mathbb{Z}^{*}_{n}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Very_smooth_hash:3">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
   <mo>≡</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∏</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>k</mi>
    </msubsup>
    <msubsup>
     <mi>p</mi>
     <mi>i</mi>
     <msub>
      <mi>e</mi>
      <mi>i</mi>
     </msub>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle x^{2}\equiv\prod_{i=0}^{k}p_{i}^{e_{i}}
  </annotation>
 </semantics>
</math>

 and at least one of <em>e</em><sub>0</sub>,...,<em>e</em><sub><em>k</em></sub> is odd.</p>

<p>The <strong>VSSR assumption</strong> is that there is no <a href="PP_(complexity)" title="wikilink">probabilistic polynomial</a> (in 

<math display="inline" id="Very_smooth_hash:4">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log n
  </annotation>
 </semantics>
</math>

) time algorithm which solves VSSR with <a href="Negligible_function" title="wikilink">non-negligible</a> probability. This is considered a useless assumption for practice because it does not tell for what size of moduli VSSR is computationally hard. Instead <strong>The computational VSSR assumption</strong> is used. It says that solving VSSR is assumed to be as hard as <a href="Integer_factorization" title="wikilink">factoring</a> a hard to factor 

<math display="inline" id="Very_smooth_hash:5">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 bit modulus, where 

<math display="inline" id="Very_smooth_hash:6">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 is somewhat smaller than the size of 

<math display="inline" id="Very_smooth_hash:7">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="examples-of-vsn-and-vssr">Examples of VSN and VSSR</h3>

<p>Let the parameters be fixed as follows

<math display="block" id="Very_smooth_hash:8">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mn>5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>c</ci>
    <cn type="integer">5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=5
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Very_smooth_hash:9">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>31</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">31</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=31
  </annotation>
 </semantics>
</math>

.</p>

<p>Then 

<math display="inline" id="Very_smooth_hash:10">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mn>35</mn>
   <mo>=</mo>
   <mrow>
    <mn>5</mn>
    <mo>⋅</mo>
    <mn>7</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">35</cn>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-⋅</ci>
      <cn type="integer">5</cn>
      <cn type="integer">7</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{1}=35=5\cdot 7
  </annotation>
 </semantics>
</math>

 is a Very Smooth Number with respect to these parameters because 

<math display="inline" id="Very_smooth_hash:11">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>log</mi>
       <mn>31</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>5</mn>
    </msup>
   </mpadded>
   <mpadded width="+3.3pt">
    <mover accent="true">
     <mo>=</mo>
     <mo>˙</mo>
    </mover>
   </mpadded>
   <mn>7.37</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <log></log>
      <cn type="integer">31</cn>
     </apply>
     <cn type="integer">5</cn>
    </apply>
    <apply>
     <ci>normal-˙</ci>
     <eq></eq>
    </apply>
    <cn type="float">7.37</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\log 31)^{5}~{}\dot{=}~{}7.37
  </annotation>
 </semantics>
</math>

 is greater than all 

<math display="inline" id="Very_smooth_hash:12">
 <semantics>
  <msub>
   <mi>m</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{1}
  </annotation>
 </semantics>
</math>

's prime factors. On the other hand 

<math display="inline" id="Very_smooth_hash:13">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mn>55</mn>
   <mo>=</mo>
   <mrow>
    <mn>5</mn>
    <mo>⋅</mo>
    <mn>11</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">55</cn>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-⋅</ci>
      <cn type="integer">5</cn>
      <cn type="integer">11</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{2}=55=5\cdot 11
  </annotation>
 </semantics>
</math>

 is not a VSN under 

<math display="inline" id="Very_smooth_hash:14">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mn>5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>c</ci>
    <cn type="integer">5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=5
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Very_smooth_hash:15">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>31</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">31</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=31
  </annotation>
 </semantics>
</math>

.</p>

<p>The integer 

<math display="inline" id="Very_smooth_hash:16">
 <semantics>
  <mrow>
   <msub>
    <mi>b</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mn>9</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">9</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{1}=9
  </annotation>
 </semantics>
</math>

 is Very Smooth Quadratic Residue modulo 

<math display="inline" id="Very_smooth_hash:17">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 because it is Very Smooth Number (under 

<math display="inline" id="Very_smooth_hash:18">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>,</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>c</ci>
    <ci>n</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c,n
  </annotation>
 </semantics>
</math>

) and we have 

<math display="inline" id="Very_smooth_hash:19">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}=3
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Very_smooth_hash:20">
 <semantics>
  <mrow>
   <msubsup>
    <mi>x</mi>
    <mn>1</mn>
    <mn>2</mn>
   </msubsup>
   <mo>=</mo>
   <msub>
    <mi>b</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}^{2}=b_{1}
  </annotation>
 </semantics>
</math>

 (mod 

<math display="inline" id="Very_smooth_hash:21">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

). This is a trivial modular square root, because 

<math display="inline" id="Very_smooth_hash:22">
 <semantics>
  <mrow>
   <msup>
    <mn>3</mn>
    <mn>2</mn>
   </msup>
   <mo>≱</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-greater-than-or-equals</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">3</cn>
     <cn type="integer">2</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3^{2}\not\geq n
  </annotation>
 </semantics>
</math>

 and so the modulus is not involved when squaring.</p>

<p>The integer 

<math display="inline" id="Very_smooth_hash:23">
 <semantics>
  <mrow>
   <msub>
    <mi>b</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mn>15</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">15</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{2}=15
  </annotation>
 </semantics>
</math>

 is also Very Smooth Quadratic Residue modulo 

<math display="inline" id="Very_smooth_hash:24">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

. All prime factors are smaller than 7.37 and the Modular Square Root is 

<math display="inline" id="Very_smooth_hash:25">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mn>20</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">20</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}=20
  </annotation>
 </semantics>
</math>

 since 

<math display="inline" id="Very_smooth_hash:26">
 <semantics>
  <mrow>
   <msup>
    <mn>20</mn>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mn>400</mn>
   <mo>≡</mo>
   <mn>15</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">20</cn>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">400</cn>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <cn type="integer">15</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   20^{2}=400\equiv 15
  </annotation>
 </semantics>
</math>

 (mod 

<math display="inline" id="Very_smooth_hash:27">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

). This is thus a non-trivial root. The VSSR problem is to find 

<math display="inline" id="Very_smooth_hash:28">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}
  </annotation>
 </semantics>
</math>

 given 

<math display="inline" id="Very_smooth_hash:29">
 <semantics>
  <msub>
   <mi>b</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>b</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{2}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Very_smooth_hash:30">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

. And we suppose that this is computationally as hard as factoring 

<math display="inline" id="Very_smooth_hash:31">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="vsh-algorithm-basic-versions">VSH Algorithm, basic versions</h2>

<p>Let 

<math display="inline" id="Very_smooth_hash:32">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 be a large RSA composite and let 

<math display="inline" id="Very_smooth_hash:33">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mn>2</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>p</mi>
     <mn>2</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mn>3</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">2</cn>
     </apply>
     <list>
      <cn type="integer">3</cn>
      <ci>normal-…</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1}=2,p_{2}=3,\ldots
  </annotation>
 </semantics>
</math>

 the sequence of primes. Let 

<math display="inline" id="Very_smooth_hash:34">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, the block length, be the largest integer such that 

<math display="inline" id="Very_smooth_hash:35">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∏</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>k</mi>
    </msubsup>
    <msub>
     <mi>p</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo><</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\prod_{i=1}^{k}p_{i}<n
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Very_smooth_hash:36">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 be an 

<math display="inline" id="Very_smooth_hash:37">
 <semantics>
  <mi mathvariant="normal">ℓ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-ℓ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

-bit message to be hashed consisting of bits 

<math display="inline" id="Very_smooth_hash:38">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>m</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>m</mi>
    <mi mathvariant="normal">ℓ</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>normal-ℓ</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (m_{1},\ldots,m_{\ell})
  </annotation>
 </semantics>
</math>

 and assume that 

<math display="inline" id="Very_smooth_hash:39">
 <semantics>
  <mrow>
   <mi mathvariant="normal">ℓ</mi>
   <mo><</mo>
   <msup>
    <mn>2</mn>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>normal-ℓ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell<2^{k}
  </annotation>
 </semantics>
</math>

. To compute the hash of 

<math display="inline" id="Very_smooth_hash:40">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

:</p>
<ol>
<li><em>x</em><sub>0</sub> = 1</li>
<li>Let 

<math display="inline" id="Very_smooth_hash:41">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

, the smallest integer greater or equal to 

<math display="inline" id="Very_smooth_hash:42">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mo>/</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>l</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l/k
  </annotation>
 </semantics>
</math>

, be the number of blocks. Let 

<math display="inline" id="Very_smooth_hash:43">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{i}=0
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Very_smooth_hash:44">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mo><</mo>
   <mi>i</mi>
   <mo>≤</mo>
   <mrow>
    <mi>L</mi>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <ci>l</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l<i\leq Lk
  </annotation>
 </semantics>
</math>

 (padding)</li>
<li>Let 

<math display="inline" id="Very_smooth_hash:45">
 <semantics>
  <mrow>
   <mi mathvariant="normal">ℓ</mi>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>k</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>l</mi>
      <mi>i</mi>
     </msub>
     <msup>
      <mn>2</mn>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-ℓ</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\ell=\sum_{i=1}^{k}l_{i}2^{i-1}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Very_smooth_hash:46">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">ℓ</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-ℓ</ci>
     <ci>i</ci>
    </apply>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell_{i}\in\{0,1\}
  </annotation>
 </semantics>
</math>

 be the binary representation of the message length 

<math display="inline" id="Very_smooth_hash:47">
 <semantics>
  <mi mathvariant="normal">ℓ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-ℓ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

 and define 

<math display="inline" id="Very_smooth_hash:48">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mrow>
     <mrow>
      <mi>L</mi>
      <mi>k</mi>
     </mrow>
     <mo>+</mo>
     <mi>i</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi mathvariant="normal">ℓ</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>L</ci>
       <ci>k</ci>
      </apply>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-ℓ</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{Lk+i}=\ell_{i}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Very_smooth_hash:49">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>i</mi>
   <mo>≤</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq i\leq k
  </annotation>
 </semantics>
</math>

.</li>
<li>for <em>j</em> = 0, 1,..., <em>L</em> in succession compute 

<math display="inline" id="Very_smooth_hash:50">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>j</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msubsup>
      <mi>x</mi>
      <mi>j</mi>
      <mn>2</mn>
     </msubsup>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∏</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>k</mi>
      </msubsup>
      <msubsup>
       <mi>p</mi>
       <mi>i</mi>
       <msub>
        <mi>m</mi>
        <mrow>
         <mrow>
          <mi>j</mi>
          <mi>k</mi>
         </mrow>
         <mo>+</mo>
         <mi>i</mi>
        </mrow>
       </msub>
      </msubsup>
     </mrow>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>j</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <csymbol cd="latexml">product</csymbol>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <apply>
          <plus></plus>
          <apply>
           <times></times>
           <ci>j</ci>
           <ci>k</ci>
          </apply>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j+1}=x_{j}^{2}\prod_{i=1}^{k}p_{i}^{m_{jk+i}}\mod n
  </annotation>
 </semantics>
</math>

</li>
<li>return <em>x</em><sub><em>L</em> + 1</sub>.</li>
</ol>

<p>The function in step 4 is called the compression function.</p>
<h2 id="properties-of-vsh">Properties of VSH</h2>
<ul>
<li>The message length does not need to be known in advance.</li>
<li>A most important theorem states that finding a collision in VSH is as hard as solving VSSR. Thus VSH is (strongly) <a href="collision_resistant" title="wikilink">collision resistant</a> which also implies second preimage resistance. VSH has not been proven to be pre-image resistant.</li>
<li>A curious feature of VSH is that the compression function is not collision-resistant. Nonetheless, the hash function VSH is collision-resistant based on the VSSR assumption. An altered version of VSH, called <strong>VSH*</strong>, has the compression function collision resistant and furthermore is about 5 times quicker when hashing short messages.</li>
<li>Since the output length of VSH is the length of a secure RSA modulus, VSH seems quite suitable in practice for constructing 'hash-then-sign' RSA signatures for arbitrarily long messages. However, such a signature must be designed carefully to ensure its security. The naive approach could be easily broken under <a href="Ciphertext_indistinguishability" title="wikilink">CPA (chosen plaintext attack)</a>.</li>
<li><a href="Analysis_of_algorithms" title="wikilink">Efficiency</a>: The cost of each iteration is less than the cost of 3 modular multiplications. The basic version of VSH altogether requires single multiplication per 

<math display="inline" id="Very_smooth_hash:51">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mi>n</mi>
      <mo>/</mo>
      <mrow>
       <mi>log</mi>
       <mrow>
        <mi>log</mi>
        <mi>n</mi>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <apply>
     <log></log>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <apply>
       <log></log>
       <apply>
        <log></log>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(\log n/\log\log n)
  </annotation>
 </semantics>
</math>

 message-bits.</li>
</ul>
<h2 id="variants-of-vsh">Variants of VSH</h2>

<p>Several improvements, speedups and more efficient variants of VSH have been proposed.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> None of them changes the underlying concept of the function. These improvements are called:</p>
<ul>
<li>Cubing VSH (instead of squaring).</li>
<li>VSH with increased number of small primes.</li>
<li>VSH with precomputed products of primes.</li>
<li>Fast VSH.</li>
<li>Fast VSH with increased block length.</li>
</ul>
<h2 id="vsdl-and-vsh-dl-variant">VSDL and VSH-DL variant</h2>

<p>The <strong>VSH-DL</strong> is a discrete logarithm variant of VSH that has no <a href="Trapdoor_function" title="wikilink">trapdoor</a>, its security depends on the difficulty of finding discrete logarithm modulo a prime <em>p</em>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p><strong>Very Smooth Number Discrete Logarithm (VSDL)</strong> is a problem where given a very smooth number, we want to find its <a href="discrete_logarithm" title="wikilink">discrete logarithm</a> modulo some number <em>n</em>.</p>

<p>Similarly as in previous section, by 

<math display="inline" id="Very_smooth_hash:52">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}
  </annotation>
 </semantics>
</math>

 we denote the 

<math display="inline" id="Very_smooth_hash:53">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th prime. Let furthermore 

<math display="inline" id="Very_smooth_hash:54">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 be a fixed constant and 

<math display="inline" id="Very_smooth_hash:55">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Very_smooth_hash:56">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 be primes with 

<math display="inline" id="Very_smooth_hash:57">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>q</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>q</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p=2q+1
  </annotation>
 </semantics>
</math>

 and let 

<math display="inline" id="Very_smooth_hash:58">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>≤</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>log</mi>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>k</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <log></log>
      <ci>p</ci>
     </apply>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\leq(\log p)^{c}
  </annotation>
 </semantics>
</math>

. CSDL is the following problem: given 

<math display="inline" id="Very_smooth_hash:59">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, find integers 

<math display="inline" id="Very_smooth_hash:60">
 <semantics>
  <mrow>
   <msub>
    <mi>e</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>e</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{1},...,e_{k}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Very_smooth_hash:61">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <msub>
     <mi>e</mi>
     <mn>1</mn>
    </msub>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∏</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>2</mn>
      </mrow>
      <mi>k</mi>
     </msubsup>
     <msubsup>
      <mi>p</mi>
      <mi>i</mi>
      <msub>
       <mi>e</mi>
       <mi>i</mi>
      </msub>
     </msubsup>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{e_{1}}\equiv\prod_{i=2}^{k}p_{i}^{e_{i}}\mod p
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Very_smooth_hash:62">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>e</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo><</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |e_{i}|<q
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Very_smooth_hash:63">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>k</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,...,k
  </annotation>
 </semantics>
</math>

 and at least one of 

<math display="inline" id="Very_smooth_hash:64">
 <semantics>
  <mrow>
   <msub>
    <mi>e</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>e</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{1},...,e_{k}
  </annotation>
 </semantics>
</math>

 non-zero.</p>

<p>The <strong>VSDL assumption</strong> is that there is no <a href="PP_(complexity)" title="wikilink">probabilistic polynomial</a> (in 

<math display="inline" id="Very_smooth_hash:65">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log p
  </annotation>
 </semantics>
</math>

) time algorithm which solves VSDL with <a href="Negligible_function" title="wikilink">non-negligible</a> probability. There is a strong connection between the hardness of VSDL and the hardness of computing discrete logarithm modulo 

<math display="inline" id="Very_smooth_hash:66">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, which is reminiscent of, but somewhat weaker than, the connection between VSSR and integer factorization.</p>
<h2 id="security-of-vsh">Security of VSH</h2>

<p>Strong <a href="collision_resistance" title="wikilink">collision resistance</a> is the only property proven for VSH. This does not imply preimage-resistance or other important hash function properties and the authors state that “VSH should not be used to model <a href="random_oracle" title="wikilink">random oracles</a>,” and cannot be substituted into constructions that depend upon them (<a href="RSA_(algorithm)" title="wikilink">RSA signatures</a>, some <a href="Message_authentication_code" title="wikilink">MACs</a>).<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> VSH should not be considered a general-purpose hash function as usually understood in security engineering.</p>
<h3 id="multiplicative-property">Multiplicative property</h3>

<p>VSH is multiplicative: Let <em>x</em>, <em>y</em>, and <em>z</em> be three bit strings of equal length, where <em>z</em> consists only of zero bits and the strings satisfy <em>x AND y = z</em>. It is easy to see that <em>H(z)H(x OR y) ≡ H(x)H(y) (mod n)</em>. As a result VSH succumbs to a classical time-memory trade-off attack that applies to multiplicative and additive hashes.</p>

<p>This fact can be used to construct a preimage attack against VSH of 

<math display="inline" id="Very_smooth_hash:67">
 <semantics>
  <mi mathvariant="normal">ℓ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-ℓ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

 bits which has 

<math display="inline" id="Very_smooth_hash:68">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi mathvariant="normal">ℓ</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <divide></divide>
     <ci>normal-ℓ</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{\ell/2}
  </annotation>
 </semantics>
</math>

 complexity rather than 

<math display="inline" id="Very_smooth_hash:69">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi mathvariant="normal">ℓ</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>normal-ℓ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{\ell}
  </annotation>
 </semantics>
</math>

 as expected.</p>
<h3 id="attack-against-truncated-version">Attack against truncated version</h3>

<p>VSH produces a very long hash (typically 1024 bits). There are no indications that a truncated VSH hash offers security that is commensurate with the hash length.</p>

<p>There exists a Partial Collision Attacks on VSH truncated to least significant <em>l</em> bits. <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>The complexity of this attack against is:</p>
<ul>
<li>Pre-computing the table offline

<math display="block" id="Very_smooth_hash:70">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi mathvariant="normal">ℓ</mi>
    <mo>/</mo>
    <mn>3</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <divide></divide>
     <ci>normal-ℓ</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{\ell/3}
  </annotation>
 </semantics>
</math>

 time and space.</li>
<li>Finding collisions

<math display="block" id="Very_smooth_hash:71">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi mathvariant="normal">ℓ</mi>
    <mo>/</mo>
    <mn>3</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <divide></divide>
     <ci>normal-ℓ</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{\ell/3}
  </annotation>
 </semantics>
</math>

 iterations.</li>
<li>Total cost: roughly 

<math display="inline" id="Very_smooth_hash:72">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi mathvariant="normal">ℓ</mi>
    <mo>/</mo>
    <mn>3</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <divide></divide>
     <ci>normal-ℓ</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{\ell/3}
  </annotation>
 </semantics>
</math>

, rather than 

<math display="inline" id="Very_smooth_hash:73">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi mathvariant="normal">ℓ</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <divide></divide>
     <ci>normal-ℓ</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{\ell/2}
  </annotation>
 </semantics>
</math>

 as expected from a hash function with good pseudorandomness properties.</li>
</ul>

<p>This probably rules out the applicability of VSH in digital signature schemes which produce signatures shorter than the VSH hash result, such as Elliptic Curve signature schemes.</p>
<h2 id="references">References</h2>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Cryptographic_hash_functions" title="wikilink">Cryptographic hash functions</a></li>
<li><a href="Provably_secure_cryptographic_hash_function" title="wikilink">Provably secure cryptographic hash function</a></li>
</ul>

<p>"</p>

<p><a href="Category:Cryptographic_hash_functions" title="wikilink">Category:Cryptographic hash functions</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
