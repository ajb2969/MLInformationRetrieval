   Simply typed lambda calculus      Simply typed lambda calculus   The simply typed lambda calculus (    λ  →     superscript  λ  normal-→    \lambda^{\to}   ), a form of type theory , is a typed interpretation of the lambda calculus with only one type constructor    →   normal-→   \to   that builds function types . It is the canonical and simplest example of a typed lambda calculus. The simply typed lambda calculus was originally introduced by Alonzo Church in 1940 as an attempt to avoid paradoxical uses of the untyped lambda calculus , and it exhibits many desirable and interesting properties.  The term simple type is also used to refer to extensions of the simply typed lambda calculus such as products , coproducts or natural numbers ( System T ) or even full recursion (like PCF ). In contrast, systems which introduce polymorphic types (like System F ) or dependent types (like the Logical Framework ) are not considered simply typed . The former are still considered simple because the Church encodings of such structures can be done using only   →   normal-→   \to   and suitable type variables, while polymorphism and dependency cannot.  Syntax  In this article, we use   σ   σ   \sigma   and   τ   τ   \tau   to range over types. Informally, the function type     σ  →  τ     normal-→  σ  τ    \sigma\to\tau   refers to the type of functions that, given an input of type   σ   σ   \sigma   , produce an output of type   τ   τ   \tau   . By convention,   →   normal-→   \to   associates to the right: we read    σ  →  τ  →  ρ       normal-→  σ  τ    normal-→    ρ     \sigma\to\tau\to\rho   as    σ  →   (  τ  →  ρ  )      fragments  σ  normal-→   fragments  normal-(  τ  normal-→  ρ  normal-)     \sigma\to(\tau\to\rho)   .  To define the types, we begin by fixing a set of base types ,   B   B   B   . These are sometimes called atomic types or type constants . With this fixed, the syntax of types is:      τ  :  :=  τ  →  τ  ∣  T  where  T  ∈  B     fragments  τ  normal-:  assign  τ  normal-→  τ  normal-∣  T   where   T   B    \tau::=\tau\to\tau\mid T\quad\mathrm{where}\quad T\in B   .  For example, if    B  =   {  a  ,  b  }       B   a  b     B=\{a,b\}   , then   a   a   a   ,   b   b   b   ,    a  →  a     normal-→  a  a    a\to a   ,    a  →  b     normal-→  a  b    a\to b   , and    a  →  b  →  a       normal-→  a  b    normal-→    a     a\to b\to a   are all valid types (among others).  We also fix a set of term constants for the base types. For example, we might assume a base type nat , and the term constants could be the natural numbers. In the original presentation, Church used only two base types   o   o   o   for "the type of propositions" and   ι   ι   \iota   for "the type of individuals". The type   o   o   o   has no term constants, whereas   ι   ι   \iota   has one term constant. Frequently the calculus with only one base type, usually   o   o   o   , is considered.  The syntax of the simply typed lambda calculus is essentially that of the lambda calculus itself. We write    :   x  ,  τ      normal-:  x  τ    x\mathbin{:}\tau   to denote that the variable   x   x   x   is of type   τ   τ   \tau   . The term syntax is then:      e  :  :=  x  ∣  λ  x  :  τ  .  e  ∣   e   e  ∣  c     fragments  e  normal-:  assign  x  normal-∣  λ  x  normal-:  τ  normal-.  e  normal-∣  e  e  normal-∣  c    e::=x\mid\lambda x\mathbin{:}\tau.e\mid e\,e\mid c     where   c   c   c   is a term constant.  That is, variable reference , abstractions , application , and constant . A variable reference   x   x   x   is bound if it is inside of an abstraction binding   x   x   x   . A term is closed if there are no unbound variables.  Compare this to the syntax of untyped lambda calculus:      e  :  :=  x  ∣  λ  x  .  e  ∣   e   e     fragments  e  normal-:  assign  x  normal-∣  λ  x  normal-.  e  normal-∣  e  e    e::=x\mid\lambda x.e\mid e\,e     We see that in typed lambda calculus every function ( abstraction ) must specify the type of its argument.  Typing rules  To define the set of well typed lambda terms of a given type, we will define a typing relation between terms and types. First, we introduce typing contexts or typing environments     Γ  ,  Δ  ,  …     normal-Γ  normal-Δ  normal-…    \Gamma,\Delta,\dots   , which are sets of typing assumptions. A typing assumption has the form    :   x  ,  σ      normal-:  x  σ    x\mathbin{:}\sigma   , meaning   x   x   x   has type   σ   σ   \sigma   .  The typing relation     Γ  ⊢   :   e  ,  σ       proves  normal-Γ   normal-:  e  σ     \Gamma\vdash e\mathbin{:}\sigma   indicates that   e   e   e   is a term of type   σ   σ   \sigma   in context   Γ   normal-Γ   \Gamma   . In this case   e   e   e   is said to be well-typed (having type   σ   σ   \sigma   ). Instances of the typing relation are called typing judgements . The validity of a typing judgement is shown by providing a typing derivation , constructed using typing rules (wherein the premises above the line allow us to derive the conclusion below the line). Simply-typed lambda calculus uses these rules:            :   x  ,  σ    ∈  Γ    Γ  ⊢   :   x  ,  σ            normal-:  x  σ   normal-Γ    proves  normal-Γ   normal-:  x  σ      {\frac{x\mathbin{:}\sigma\in\Gamma}{\Gamma\vdash x\mathbin{:}\sigma}}   (1)        c  is a constant of type  T    Γ  ⊢   :   c  ,  T           c  is a constant of type  T    proves  normal-Γ   normal-:  c  T      {\frac{c\text{ is a constant of type }T}{\Gamma\vdash c\mathbin{:}T}}   (2)           Γ  ,   :   x  ,  σ     ⊢   :   e  ,  τ      Γ  ⊢   (  λ  x  :  σ  .  e  )   :   (  σ  →  τ  )         proves   normal-Γ   normal-:  x  σ     normal-:  e  τ     fragments  Γ  proves   fragments  normal-(  λ  x  normal-:  σ  normal-.  e  normal-)   normal-:   fragments  normal-(  σ  normal-→  τ  normal-)      {\frac{\Gamma,x\mathbin{:}\sigma\vdash e\mathbin{:}\tau}{\Gamma\vdash(\lambda x%
 \mathbin{:}\sigma.~{}e)\mathbin{:}(\sigma\to\tau)}}   (3)        Γ  ⊢    :    e  1   ,  σ    →   τ  Γ    ⊢   :    e  2   ,  σ      Γ  ⊢   :      e  1     e  2    ,  τ            proves  normal-Γ   normal-→   normal-:   subscript  e  1   σ    τ  normal-Γ      proves     normal-:   subscript  e  2   σ      proves  normal-Γ   normal-:     subscript  e  1    subscript  e  2    τ      {\frac{\Gamma\vdash e_{1}\mathbin{:}\sigma\to\tau\quad\Gamma\vdash e_{2}%
 \mathbin{:}\sigma}{\Gamma\vdash e_{1}~{}e_{2}\mathbin{:}\tau}}   (4)     In other words,   If   x   x   x   has type   σ   σ   \sigma   in the context, we know that   x   x   x   has type   σ   σ   \sigma   .  Term constants have the appropriate base types.  If, in a certain context with   x   x   x   having type   σ   σ   \sigma   ,   e   e   e   has type   τ   τ   \tau   , then, in the same context without   x   x   x   ,     :    λ  x   ,  σ    .  e     formulae-sequence   normal-:    λ  x   σ   e    \lambda x\mathbin{:}\sigma.~{}e   has type    σ  →  τ     normal-→  σ  τ    \sigma\to\tau   .  If, in a certain context,    e  1     subscript  e  1    e_{1}   has type    σ  →  τ     normal-→  σ  τ    \sigma\to\tau   , and    e  2     subscript  e  2    e_{2}   has type   σ   σ   \sigma   , then      e  1     e  2        subscript  e  1    subscript  e  2     e_{1}~{}e_{2}   has type   τ   τ   \tau   .   Examples of closed terms, i.e. terms typable in the empty context, are:   For every type   τ   τ   \tau   , a term     :    λ  x   ,  τ    .    :   x  ,  τ    →  τ      formulae-sequence   normal-:    λ  x   τ    normal-→   normal-:  x  τ   τ     \lambda x\mathbin{:}\tau.x\mathbin{:}\tau\to\tau   (identity function/I-combinator),  For types    σ  ,  τ     σ  τ    \sigma,\tau   , a term     :    λ  x   ,  σ    .   :    λ  y   ,  τ    .    :   x  ,  σ    →  τ  →  σ      formulae-sequence   normal-:    λ  x   σ    normal-:    λ  y   τ      normal-→   normal-:  x  σ   τ    normal-→    σ      \lambda x\mathbin{:}\sigma.\lambda y\mathbin{:}\tau.x\mathbin{:}\sigma\to\tau\to\sigma   (the K-combinator), and  For types    τ  ,   τ  ′   ,   τ  ′′      τ   superscript  τ  normal-′    superscript  τ  ′′     \tau,\tau^{\prime},\tau^{\prime\prime}   , a term    λ  x  :  τ  →   τ  ′   →   τ  ′′   .  λ  y  :  τ  →   τ  ′   .  λ  z  :  τ  .  x  z   (  y  z  )   :   (  τ  →   τ  ′   →   τ  ′′   )   →   (  τ  →   τ  ′   )   →  τ  →   τ  ′′      fragments  λ  x  normal-:  τ  normal-→   superscript  τ  normal-′   normal-→   superscript  τ  ′′   normal-.  λ  y  normal-:  τ  normal-→   superscript  τ  normal-′   normal-.  λ  z  normal-:  τ  normal-.  x  z   fragments  normal-(  y  z  normal-)   normal-:   fragments  normal-(  τ  normal-→   superscript  τ  normal-′   normal-→   superscript  τ  ′′   normal-)   normal-→   fragments  normal-(  τ  normal-→   superscript  τ  normal-′   normal-)   normal-→  τ  normal-→   superscript  τ  ′′     \lambda x\mathbin{:}\tau\to\tau^{\prime}\to\tau^{\prime\prime}.\lambda y%
 \mathbin{:}\tau\to\tau^{\prime}.\lambda z\mathbin{:}\tau.xz(yz):(\tau\to\tau^{%
 \prime}\to\tau^{\prime\prime})\to(\tau\to\tau^{\prime})\to\tau\to\tau^{\prime\prime}   (the S-combinator).   These are the typed lambda calculus representations of the basic combinators of combinatory logic .  Each type   τ   τ   \tau   is assigned an order, a number    o   (  τ  )       o  τ    o(\tau)   . For base types,     o   (  T  )    =  0        o  T   0    o(T)=0   ; for function types,    o   (  σ  →  τ  )   =  max   (  o   (  σ  )   +  1  ,  o   (  τ  )   )      fragments  o   fragments  normal-(  σ  normal-→  τ  normal-)    max   fragments  normal-(  o   fragments  normal-(  σ  normal-)    1  normal-,  o   fragments  normal-(  τ  normal-)   normal-)     o(\sigma\to\tau)=\mbox{max}(o(\sigma)+1,o(\tau))   . That is, the order of a type measures the depth of the most left-nested arrow. Hence:      o   (  ι  →  ι  →  ι  )   =  1     fragments  o   fragments  normal-(  ι  normal-→  ι  normal-→  ι  normal-)    1    o(\iota\to\iota\to\iota)=1         o   (   (  ι  →  ι  )   →  ι  )   =  2     fragments  o   fragments  normal-(   fragments  normal-(  ι  normal-→  ι  normal-)   normal-→  ι  normal-)    2    o((\iota\to\iota)\to\iota)=2     Semantics  Intrinsic vs. extrinsic interpretations  Broadly speaking, there are two different ways of assigning meaning to the simply typed lambda calculus, as to typed languages more generally, sometimes called intrinsic vs. extrinsic , or Church -style vs. Curry -style . 1 An intrinsic/Church-style semantics only assigns meaning to well-typed terms, or more precisely, assigns meaning directly to typing derivations. This has the effect that terms differing only by type annotations can nonetheless be assigned different meanings. For example, the identity term     :    λ  x   ,  𝚒𝚗𝚝    .  x     formulae-sequence   normal-:    λ  x   𝚒𝚗𝚝   x    \lambda x\mathbin{:}\mathtt{int}.~{}x   on integers and the identity term     :    λ  x   ,  𝚋𝚘𝚘𝚕    .  x     formulae-sequence   normal-:    λ  x   𝚋𝚘𝚘𝚕   x    \lambda x\mathbin{:}\mathtt{bool}.~{}x   on booleans may mean different things. (The classic intended interpretations are the identity function on integers and the identity function on boolean values.) In contrast, an extrinsic/Curry-style semantics assigns meaning to terms regardless of typing, as they would be interpreted in an untyped language. In this view,     :    λ  x   ,  𝚒𝚗𝚝    .  x     formulae-sequence   normal-:    λ  x   𝚒𝚗𝚝   x    \lambda x\mathbin{:}\mathtt{int}.~{}x   and     :    λ  x   ,  𝚋𝚘𝚘𝚕    .  x     formulae-sequence   normal-:    λ  x   𝚋𝚘𝚘𝚕   x    \lambda x\mathbin{:}\mathtt{bool}.~{}x   mean the same thing ( i.e. , the same thing as     λ  x   .  x     formulae-sequence    λ  x   x    \lambda x.~{}x   ).  The distinction between intrinsic and extrinsic semantics is sometimes associated with the presence or absence of annotations on lambda abstractions, but strictly speaking this usage is imprecise. It is possible to define a Curry-style semantics on annotated terms simply by ignoring the types ( i.e. , through type erasure ), as it is possible to give a Church-style semantics on unannotated terms when the types can be deduced from context ( i.e. , through type inference ). The essential difference between intrinsic and extrinsic approaches is just whether the typing rules are viewed as defining the language, or as a formalism for verifying properties of a more primitive underlying language. Most of the different semantic interpretations discussed below can be seen through either a Church or Curry perspective.  Equational theory  The simply typed lambda calculus has the same equational theory of βη-equivalence as untyped lambda calculus , but subject to type restrictions. The equation for beta reduction       (  λ  x  :  σ  .  t  )   u   =  β   t   [  x  :=  u  ]      fragments   fragments  normal-(  λ  x  normal-:  σ  normal-.  t  normal-)   u   subscript   β   t   fragments  normal-[  x  assign  u  normal-]     (\lambda x\mathbin{:}\sigma.~{}t)\,u=_{\beta}t[x:=u]   holds in context   Γ   normal-Γ   \Gamma   whenever     Γ  ,   :   x  ,  σ     ⊢   :   t  ,  τ       proves   normal-Γ   normal-:  x  σ     normal-:  t  τ     \Gamma,x\mathbin{:}\sigma\vdash t\mathbin{:}\tau   and    Γ  ⊢   :   u  ,  σ       proves  normal-Γ   normal-:  u  σ     \Gamma\vdash u\mathbin{:}\sigma   , while the equation for eta reduction       :    λ  x   ,  σ    .     t   x    =  η   t      formulae-sequence   normal-:    λ  x   σ     subscript   η     t  x   t     \lambda x\mathbin{:}\sigma.~{}t\,x=_{\eta}t   holds whenever    Γ  ⊢   t   :   σ  →  τ        proves  normal-Γ  t    normal-:     normal-→  σ  τ      \Gamma\vdash t\!:\sigma\to\tau   and   x   x   x   does not appear free in   t   t   t   .  Operational semantics  Likewise, the operational semantics of simply typed lambda calculus can be fixed as for the untyped lambda calculus, using call by name , call by value , or other evaluation strategies . As for any typed language, type safety is a fundamental property of all of these evaluation strategies. Additionally, the strong normalization property described below implies that any evaluation strategy will terminate on all simply typed terms.  Categorical semantics  The simply typed lambda calculus (with    β  η      β  η    \beta\eta   -equivalence) is the internal language of Cartesian closed categories (CCCs), as was first observed by Lambek . Given any specific CCC, the basic types of the corresponding lambda calculus are just the objects , and the terms are the morphisms . Conversely, every simply typed lambda calculus gives a CCC whose objects are the types, and morphisms are equivalence classes of terms.  To make the correspondence clear, a type constructor for the Cartesian product is typically added to the above. To preserve the categoricity of the Cartesian product , one adds type rules for pairing , projection , and a unit term . Given two terms    :   s  ,  σ      normal-:  s  σ    s\mathbin{:}\sigma   and    :   t  ,  τ      normal-:  t  τ    t\mathbin{:}\tau   , the term    (  s  ,  t  )     s  t    (s,t)   has type    σ  ×  τ      σ  τ    \sigma\times\tau   . Likewise, if one has a term     :   u  ,   τ  1     ×   τ  2        normal-:  u   subscript  τ  1     subscript  τ  2     u\mathbin{:}\tau_{1}\times\tau_{2}   , then there are terms    :     π  1    (  u  )    ,   τ  1       normal-:     subscript  π  1   u    subscript  τ  1     \pi_{1}(u)\mathbin{:}\tau_{1}   and    :     π  2    (  u  )    ,   τ  2       normal-:     subscript  π  2   u    subscript  τ  2     \pi_{2}(u)\mathbin{:}\tau_{2}   where the    π  i     subscript  π  i    \pi_{i}   correspond to the projections of the Cartesian product. The unit term , of type 1, is written as    (  )      ()   and vocalized as 'nil', is the final object . The equational theory is extended likewise, so that one has        π  1    (   :   s  ,  σ    ,   :   t  ,  τ    )    =   :   s  ,  σ           subscript  π  1     normal-:  s  σ    normal-:  t  τ      normal-:  s  σ     \pi_{1}(s\mathbin{:}\sigma,t\mathbin{:}\tau)=s\mathbin{:}\sigma           π  2    (   :   s  ,  σ    ,   :   t  ,  τ    )    =   :   t  ,  τ           subscript  π  2     normal-:  s  σ    normal-:  t  τ      normal-:  t  τ     \pi_{2}(s\mathbin{:}\sigma,t\mathbin{:}\tau)=t\mathbin{:}\tau          (    π  1    (    :   u  ,  σ    ×  τ   )    ,    π  2    (    :   u  ,  σ    ×  τ   )    )   =    :   u  ,  σ    ×  τ           subscript  π  1      normal-:  u  σ   τ       subscript  π  2      normal-:  u  σ   τ        normal-:  u  σ   τ     (\pi_{1}(u\mathbin{:}\sigma\times\tau),\pi_{2}(u\mathbin{:}\sigma\times\tau))=%
 u\mathbin{:}\sigma\times\tau          :   t  ,  1    =   (  )        normal-:  t  1      t\mathbin{:}1=()   This last is read as " if t has type 1, then it reduces to nil ".  The above can then be turned into a category by taking the types as the objects . The morphisms     σ  →  τ     normal-→  σ  τ    \sigma\to\tau   are equivalence classes of pairs    (   :   x  ,  σ    ,   :   t  ,  τ    )      normal-:  x  σ    normal-:  t  τ     (x\mathbin{:}\sigma,t\mathbin{:}\tau)   where x is a variable (of type   σ   σ   \sigma   ) and t is a term (of type   τ   τ   \tau   ), having no free variables in it, except for (optionally) x . Closure is obtained from currying and application , as usual.  More precisely, there exist functors between the category of Cartesian closed categories, and the category of simply-typed lambda theories.  It is common to extend this case to closed symmetric monoidal categories by using a linear type system . The reason for this is that the CCC is a special case of the closed symmetric monoidal category, which is typically taken to be the category of sets . This is fine for laying the foundations of set theory , but the more general topos seems to provide a superior foundation.  Proof-theoretic semantics  The simply typed lambda calculus is closely related to the implicational fragment of propositional intuitionistic logic , i.e., minimal logic , via the Curry–Howard isomorphism : terms correspond precisely to proofs in natural deduction , and inhabited types are exactly the tautologies of minimal logic.  Alternative syntaxes  The presentation given above is not the only way of defining the syntax of the simply typed lambda calculus. One alternative is to remove type annotations entirely (so that the syntax is identical to the untyped lambda calculus), while ensuring that terms are well-typed via Hindley-Milner type inference . The inference algorithm is terminating, sound, and complete: whenever a term is typable, the algorithm computes its type. More precisely, it computes the term's principal type , since often an unannotated term (such as     λ  x   .  x     formulae-sequence    λ  x   x    \lambda x.~{}x   ) may have more than one type (    𝚒𝚗𝚝  →  𝚒𝚗𝚝     normal-→  𝚒𝚗𝚝  𝚒𝚗𝚝    \mathtt{int}\to\mathtt{int}   ,    𝚋𝚘𝚘𝚕  →  𝚋𝚘𝚘𝚕     normal-→  𝚋𝚘𝚘𝚕  𝚋𝚘𝚘𝚕    \mathtt{bool}\to\mathtt{bool}   , etc., which are all instances of the principal type    α  →  α     normal-→  α  α    \alpha\to\alpha   ).  Another alternative presentation of simply typed lambda calculus is based on bidirectional type checking , which requires more type annotations than Hindley-Milner inference but is easier to describe. The type system is divided into two judgments, representing both checking and synthesis , written    Γ  ⊢   e  ⇐  τ      proves  normal-Γ   normal-⇐  e  τ     \Gamma\vdash e\Leftarrow\tau   and    Γ  ⊢   e  ⇒  τ      proves  normal-Γ   normal-⇒  e  τ     \Gamma\vdash e\Rightarrow\tau   respectively. Operationally, the three components   Γ   normal-Γ   \Gamma   ,   e   e   e   , and   τ   τ   \tau   are all inputs to the checking judgment    Γ  ⊢   e  ⇐  τ      proves  normal-Γ   normal-⇐  e  τ     \Gamma\vdash e\Leftarrow\tau   , whereas the synthesis judgment    Γ  ⊢   e  ⇒  τ      proves  normal-Γ   normal-⇒  e  τ     \Gamma\vdash e\Rightarrow\tau   only takes   Γ   normal-Γ   \Gamma   and   e   e   e   as inputs, producing the type   τ   τ   \tau   as output. These judgments are derived via the following rules:            :   x  ,  σ    ∈  Γ    Γ  ⊢   x  ⇒  σ           normal-:  x  σ   normal-Γ    proves  normal-Γ   normal-⇒  x  σ      {\frac{x\mathbin{:}\sigma\in\Gamma}{\Gamma\vdash x\Rightarrow\sigma}}   [1]        c  is a constant of type  T    Γ  ⊢   c  ⇒  T          c  is a constant of type  T    proves  normal-Γ   normal-⇒  c  T      {\frac{c\text{ is a constant of type }T}{\Gamma\vdash c\Rightarrow T}}   [2]           Γ  ,   :   x  ,  σ     ⊢   e  ⇐  τ     Γ  ⊢  λ  x  .  e  ⇐  σ  →  τ        proves   normal-Γ   normal-:  x  σ     normal-⇐  e  τ     fragments  Γ  proves  λ  x  normal-.  e  normal-⇐  σ  normal-→  τ     {\frac{\Gamma,x\mathbin{:}\sigma\vdash e\Leftarrow\tau}{\Gamma\vdash\lambda x.%
 ~{}e\Leftarrow\sigma\to\tau}}   [3]        Γ  ⊢   e  1   ⇒  σ  →  τ  Γ  ⊢   e  2   ⇐  σ    Γ  ⊢      e  1     e  2    ⇒  τ         fragments  Γ  proves   subscript  e  1   normal-⇒  σ  normal-→  τ   Γ  proves   subscript  e  2   normal-⇐  σ    proves  normal-Γ   normal-⇒     subscript  e  1    subscript  e  2    τ      {\frac{\Gamma\vdash e_{1}\Rightarrow\sigma\to\tau\quad\Gamma\vdash e_{2}%
 \Leftarrow\sigma}{\Gamma\vdash e_{1}~{}e_{2}\Rightarrow\tau}}   [4]          Γ  ⊢   e  ⇒  τ     Γ  ⊢   e  ⇐  τ         proves  normal-Γ   normal-⇒  e  τ     proves  normal-Γ   normal-⇐  e  τ      {\frac{\Gamma\vdash e\Rightarrow\tau}{\Gamma\vdash e\Leftarrow\tau}}   [5]        Γ  ⊢   e  ⇐  τ     Γ  ⊢    (   :   e  ,  τ    )   ⇒  τ         proves  normal-Γ   normal-⇐  e  τ     proves  normal-Γ   normal-⇒   normal-:  e  τ   τ      {\frac{\Gamma\vdash e\Leftarrow\tau}{\Gamma\vdash(e\mathbin{:}\tau)\Rightarrow%
 \tau}}   [6]     Observe that rules [1]–[4] are nearly identical to rules (1)–(4) above, except for the careful choice of checking or synthesis judgments. These choices can be explained like so:   If    :   x  ,  σ      normal-:  x  σ    x\mathbin{:}\sigma   is in the context, we can synthesize type   σ   σ   \sigma   for   x   x   x   .  The types of term constants are fixed and can be synthesized.  To check that     λ  x   .  e     formulae-sequence    λ  x   e    \lambda x.~{}e   has type    σ  →  τ     normal-→  σ  τ    \sigma\to\tau   in some context, we extend the context with    :   x  ,  σ      normal-:  x  σ    x\mathbin{:}\sigma   and check that   e   e   e   has type   τ   τ   \tau   .  If    e  1     subscript  e  1    e_{1}   synthesizes type    σ  →  τ     normal-→  σ  τ    \sigma\to\tau   (in some context), and    e  2     subscript  e  2    e_{2}   checks against type   σ   σ   \sigma   (in the same context), then      e  1     e  2        subscript  e  1    subscript  e  2     e_{1}~{}e_{2}   synthesizes type   τ   τ   \tau   .   Observe that the rules for synthesis are read top-to-bottom, whereas the rules for checking are read bottom-to-top. Note in particular that we do not need any annotation on the lambda abstraction in rule [3], because the type of the bound variable can be deduced from the type at which we check the function. Finally, we explain rules [5] and [6] as follows:   To check that   e   e   e   has type   τ   τ   \tau   , it suffices to synthesize type   τ   τ   \tau   .  If   e   e   e   checks against type   τ   τ   \tau   , then the explicitly annotated term    (   :   e  ,  τ    )     normal-:  e  τ    (e\mathbin{:}\tau)   synthesizes   τ   τ   \tau   .   Because of these last two rules coercing between synthesis and checking, it is easy to see that any well-typed but unannotated term can be checked in the bidirectional system, so long as we insert "enough" type annotations. And in fact, annotations are needed only at β-redexes.  General observations  Given the standard semantics, the simply typed lambda calculus is strongly normalizing : that is, well-typed terms always reduce to a value, i.e., a   λ   λ   \lambda   abstraction. This is because recursion is not allowed by the typing rules: it is impossible to find types for fixed-point combinators and the looping term    Ω  =   (  λ  x  .   x   x  )    (  λ  x  .   x   x  )      fragments  Ω    fragments  normal-(  λ  x  normal-.  x  x  normal-)    fragments  normal-(  λ  x  normal-.  x  x  normal-)     \Omega=(\lambda x.~{}x~{}x)(\lambda x.~{}x~{}x)   . Recursion can be added to the language by either having a special operator    𝚏𝚒𝚡  α     subscript  𝚏𝚒𝚡  α    \mathtt{fix}_{\alpha}   of type     (  α  →  α  )   →  α     fragments   fragments  normal-(  α  normal-→  α  normal-)   normal-→  α    (\alpha\to\alpha)\to\alpha   or adding general recursive types , though both eliminate strong normalization.  Since it is strongly normalising, it is decidable whether or not a simply typed lambda calculus program halts: in fact, it always halts. We can therefore conclude that the language is not  Turing complete .  Important results   Tait showed in 1967 that   β   β   \beta   -reduction is strongly normalizing . As a corollary    β  η      β  η    \beta\eta   -equivalence is decidable . Statman showed in 1977 that the normalisation problem is not elementary recursive . A purely semantic normalisation proof (see normalisation by evaluation ) was given by Berger and Schwichtenberg in 1991.  The unification problem for    β  η      β  η    \beta\eta   -equivalence is undecidable. Huet showed in 1973 that 3rd order unification is undecidable and this was improved upon by Baxter in 1978 then by Goldfarb in 1981 by showing that 2nd order unification is already undecidable. Whether higher order matching (unification where only one term contains existential variables) is decidable is still open. [2006: Colin Stirling, Edinburgh, has published a proof-sketch in which he claims that the problem is decidable; however, the complete version of the proof is still unpublished]  We can encode natural numbers by terms of the type     (  o  →  o  )   →   (  o  →  o  )      fragments   fragments  normal-(  o  normal-→  o  normal-)   normal-→   fragments  normal-(  o  normal-→  o  normal-)     (o\to o)\to(o\to o)   ( Church numerals ). Schwichtenberg showed in 1976 that in    λ  →     superscript  λ  normal-→    \lambda^{\to}   exactly the extended polynomials are representable as functions over Church numerals; these are roughly the polynomials closed up under a conditional operator.  A full model of    λ  →     superscript  λ  normal-→    \lambda^{\to}   is given by interpreting base types as sets and function types by the set-theoretic function space . Friedman showed in 1975 that this interpretation is complete for    β  η      β  η    \beta\eta   -equivalence, if the base types are interpreted by infinite sets. Statman showed in 1983 that    β  η      β  η    \beta\eta   -equivalence is the maximal equivalence which is typically ambiguous , i.e. closed under type substitutions ( Statman's Typical Ambiguity Theorem ). A corollary of this is that the finite model property holds, i.e. finite sets are sufficient to distinguish terms which are not identified by    β  η      β  η    \beta\eta   -equivalence.  Plotkin introduced logical relations in 1973 to characterize the elements of a model which are definable by lambda terms. In 1993 Jung and Tiuryn showed that a general form of logical relation (Kripke logical relations with varying arity) exactly characterizes lambda definability. Plotkin and Statman conjectured that it is decidable whether a given element of a model generated from finite sets is definable by a lambda term ( Plotkin-Statman-conjecture ). The conjecture was shown to be false by Loader in 1993.   Notes  See also   Article Church's Type Theory in the Stanford Encyclopedia of Philosophy.  Hindley-Milner type inference algorithm   References   A. Church: A Formulation of the Simple Theory of Types, JSL 5, 1940  W.W.Tait : Intensional Interpretations of Functionals of Finite Type I, JSL 32(2), 1967  G.D. Plotkin: Lambda-definability and logical relations, Technical report, 1973  G.P. Huet: The Undecidability of Unification in Third Order Logic Information and Control 22(3): 257-267 (1973)  H. Friedman: Equality between functionals. LogicColl. '73, pages 22-37, LNM 453, 1975.  H. Schwichtenberg: Functions definable in the simply-typed lambda calculus, Arch. Math Logik 17 (1976) 113-114.  R. Statman: The Typed lambda-Calculus Is not Elementary Recursive FOCS 1977: 90-94  W. D. Goldfarb: The undecidability of the 2nd order unification problem, TCS (1981), no. 13, 225- 230.  R. Statman.   λ   λ   \lambda   -definable functionals and    β  η      β  η    \beta\eta   conversion. Arch. Math. Logik, 23:21–26, 1983.  J. Lambek: Cartesian Closed Categories and Typed Lambda-calculi. Combinators and Functional Programming Languages 1985: 136-175  U. Berger, H. Schwichtenberg: An Inverse of the Evaluation Functional for Typed lambda-calculus LICS 1991: 203-211  Jung, A.,Tiuryn, J.:A New Characterization of Lambda Definability, TLCA 1993  R. Loader: The Undecidability of λ-definability , appeared in the Church Festschrift, 2001  H. Barendregt, Lambda Calculi with Types , Handbook of Logic in Computer Science, Volume II, Oxford University Press, 1993. ISBN 0-19-853761-1.  L. Baxter: The undecidability of the third order dyadic unification problem, Information and Control 38(2), 170-178 (1978)   External links     "  Category:Lambda calculus  Category:Theory of computation     ↩     