<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1457">Dependency network</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Dependency network</h1>
<hr>The '''dependency network''' approach provides a new system level analysis of the activity and topology of directed [[Graph (mathematics)|networks]]. The approach extracts causal topological relations between the network's nodes (when the network structure is analyzed), and provides an important step towards inference of [[causal]] activity relations between the network nodes (when analyzing the network activity). This methodology has originally been introduced for the study of financial data,<ref name="PLoS1_2010">Dror Y. Kenett, Michele Tumminello, Asaf Madi, Gitit Gur-Gershgoren, Rosario N. Mantegna, and Eshel Ben-Jacob (2010), Dominating clasp of the financial sector revealed by partial correlation analysis of the stock market, [http://dx.crossref.org/10.1371%2Fjournal.pone.0015032PLoS ONE 5(12), e15032]</ref><ref name="ICF_subbmited">Dror Y. Kenett, Yoash Shapira, Gitit Gu
<p>r-Gershgoren, and Eshel Ben-Jacob (submitted), Index Cohesive Force analysis of the U.S. stock market, Proceedings of the 2011 International Conference on Econophysics, Kavala, Greece it has been extended and applied to other systems, such as the <a href="immune_system" title="wikilink">immune system</a>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and <a href="semantic_networks" title="wikilink">semantic networks</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>In the case of network activity, the analysis is based on <a href="partial_correlation" title="wikilink">partial correlations</a>,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> which are becoming ever more widely used to investigate <a href="complex_systems" title="wikilink">complex systems</a>. In simple words, the partial (or residual) <a class="uri" href="correlation" title="wikilink">correlation</a> is a measure of the effect (or contribution) of a given node, say <em>j</em>, on the correlations between another pair of nodes, say <em>i</em> and <em>k</em>. Using this concept, the dependency of one node on another node, is calculated for the entire network. This results in a directed weighted adjacency matrix, of a fully connected network. Once the adjacency matrix has been constructed, different algorithms can be used to construct the network, such as a threshold network, <a href="Minimal_spanning_tree" title="wikilink">Minimal Spanning Tree (MST)</a>, Planar Maximally Filtered Graph (PMFG), and others.</p>
<figure><b>(Figure)</b>
<figcaption>Dependency Network of financial data, for 300 of the S&amp;P500; stocks, traded between 2001-2003. Stocks are grouped by economic sectors, and the arrow points in the direction of influence. The hub of the network, the most influencing sector, is the Financial sector. Reproduction from Kenett et al., PLoS ONE 5(12), e15032 (2010)</figcaption>
</figure>
<h2 id="importance">Importance</h2>

<p>The partial correlation based Dependency Networks is a revolutionary new class of correlation based networks, which is capable of uncovering hidden relationships between the nodes of the network.</p>

<p>This original methodology was first presented at the end of 2010, published in the highly cited <a href="PLoS_ONE" title="wikilink">PLoS ONE</a> journal.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> This research, headed by <a href="http://tamar.tau.ac.il/~dror/">Dror Y. Kenett</a> and his Ph.D. supervisor <a href="Eshel_Ben-Jacob" title="wikilink">Prof. Eshel Ben-Jacob</a>, collaborated with Dr. Michele Tumminello and Prof. <a href="http://ocs.unipa.it/mantegna.html">Rosario Mantegna</a>. They quantitatively uncovered hidden information about the underlying structure of the <a href="New_York_Stock_Exchange" title="wikilink">U.S. stock market</a>, information that was not present in the standard <a class="uri" href="correlation" title="wikilink">correlation</a> networks. One of the main results of this work is that for the investigated time period (2001–2003), the structure of the network is dominated by companies belonging to the <a href="financial_sector" title="wikilink">financial sector</a>, which are the <a href="wikt:hub" title="wikilink">hubs</a> in the dependency network. Thus, they were able for the first time to quantitatively show the dependency relationships between the different <a href="economic_sectors" title="wikilink">economic sectors</a>. Following this work, the dependency network methodology has been applied to the study of the <a href="immune_system" title="wikilink">immune system</a>,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> and <a href="semantic_networks" title="wikilink">semantic networks</a>.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> As such, this methodology is applicable to any <a href="complex_system" title="wikilink">complex system</a>.</p>

<p> </p>
<h2 id="overview">Overview</h2>

<p>To be more specific, the partial correlations of the pair, given <em>j</em> is the correlations between them after proper subtraction of the correlations between <em>i</em> and <em>j</em> and between <em>k</em> and <em>j</em>. Defined this way, the difference between the correlations and the partial correlations provides a measure of the influence of node <em>j</em> on the <a class="uri" href="correlation" title="wikilink">correlation</a>. Therefore, we define the influence of node <em>j</em> on node <em>i</em>, or the dependency of node <em>i</em> on node <em>j- D(i,j)</em>, to be the sum of the influence of node <em>j</em> on the correlations of node <em>i</em> with all other nodes.</p>

<p>In the case of network topology, the analysis is based on the effect of node deletion on the shortest paths between the <a href="network_nodes" title="wikilink">network nodes</a>. More specifically, we define the influence of node <em>j</em> on each pair of nodes <em>(i,k)</em> to be the inverse of the topological distance between these nodes in the presence of <em>j</em> minus the inverse distance between them in the absence of node <em>j</em>. Then we define the influence of node <em>j</em> on node <em>i</em>, or the dependency of node <em>i</em> on node'' j - D(i,j)'', to be the sum of the influence of node <em>j</em> on the distances between node <em>i</em> with all other nodes <em>k</em>.</p>
<h2 id="the-activity-dependency-networks">The activity dependency networks</h2>
<h3 id="the-node-node-correlations">The node-node correlations</h3>

<p>The node=node correlations can be calculated by <a href="Pearson_product-moment_correlation_coefficient" title="wikilink">Pearson’s formula</a>:</p>

<p>

<math display="inline" id="Dependency_network:0">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mrow>
     <mi>X</mi>
     <mo>,</mo>
     <mi>Y</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mo>⟨</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <msub>
          <mi>X</mi>
          <mi>i</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <msub>
         <mi>μ</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <msub>
          <mi>X</mi>
          <mi>j</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <msub>
         <mi>μ</mi>
         <mi>j</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⟩</mo>
    </mrow>
    <mrow>
     <msub>
      <mi>σ</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>σ</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <list>
      <ci>X</ci>
      <ci>Y</ci>
     </list>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <ci>i</ci>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>μ</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <ci>j</ci>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>μ</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{X,Y}=\frac{\left\langle(X_{i}(n)-\mu_{i})(X_{j}(n)-\mu_{j})\right\rangle}{%
\sigma_{i}\sigma_{j}}
  </annotation>
 </semantics>
</math>

</p>

<p>Where 

<math display="inline" id="Dependency_network:1">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>i</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}(n)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependency_network:2">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mi>j</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>j</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{j}(n)
  </annotation>
 </semantics>
</math>

 are the activity of nodes <em>i</em> and <em>j</em> of subject n, <em>μ</em> stands for average, and sigma the STD of the dynamics profiles of nodes'' i'' and <em>j</em>. Note that the node-node correlations (or for simplicity the node correlations) for all pairs of nodes define a symmetric correlation matrix whose 

<math display="inline" id="Dependency_network:3">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>i</mi>
   <mo>,</mo>
   <mi>j</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>i</ci>
    <ci>j</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i,j)
  </annotation>
 </semantics>
</math>

 element is the correlation between nodes <em>i</em> and <em>j</em>.</p>
<h3 id="partial-correlations">Partial correlations</h3>

<p>Next we use the resulting node correlations to compute the partial correlations. The first order partial correlation coefficient is a statistical measure indicating how a third variable affects the correlation between two other variables. The partial correlation between nodes i and k with respect to a third node 

<math display="inline" id="Dependency_network:4">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>-</mo>
   <mi>P</mi>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">|</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">j</csymbol>
    <minus></minus>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">k</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j-PC(i,k|j)
  </annotation>
 </semantics>
</math>

 is defined as:</p>

<p>

<math display="inline" id="Dependency_network:5">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">|</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mi>C</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo>,</mo>
       <mi>k</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>C</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo>,</mo>
       <mi>j</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>C</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>k</mi>
       <mo>,</mo>
       <mi>j</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <msqrt>
     <mrow>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <msup>
          <mi>C</mi>
          <mn>2</mn>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>i</mi>
          <mo>,</mo>
          <mi>j</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <msup>
          <mi>C</mi>
          <mn>2</mn>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>k</mi>
          <mo>,</mo>
          <mi>j</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </msqrt>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">k</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>C</ci>
       <interval closure="open">
        <ci>i</ci>
        <ci>k</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>C</ci>
       <interval closure="open">
        <ci>i</ci>
        <ci>j</ci>
       </interval>
       <ci>C</ci>
       <interval closure="open">
        <ci>k</ci>
        <ci>j</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <root></root>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>C</ci>
           <cn type="integer">2</cn>
          </apply>
          <interval closure="open">
           <ci>i</ci>
           <ci>j</ci>
          </interval>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>C</ci>
           <cn type="integer">2</cn>
          </apply>
          <interval closure="open">
           <ci>k</ci>
           <ci>j</ci>
          </interval>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   PC(i,k|j)=\frac{C(i,k)-C(i,j)C(k,j)}{\sqrt{[1-C^{2}(i,j)][1-C^{2}(k,j)]}}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Dependency_network:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>C</ci>
     <interval closure="open">
      <ci>i</ci>
      <ci>j</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>C</ci>
     <interval closure="open">
      <ci>i</ci>
      <ci>k</ci>
     </interval>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(i,j),C(i,k)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependency_network:7">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>j</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <interval closure="open">
     <ci>j</ci>
     <ci>k</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(j,k)
  </annotation>
 </semantics>
</math>

 are the node correlations defined above.</p>
<h3 id="the-correlation-influence-and-correlation-dependency">The correlation influence and correlation dependency</h3>

<p>The relative effect of the correlations 

<math display="inline" id="Dependency_network:8">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <interval closure="open">
     <ci>i</ci>
     <ci>j</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(i,j)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependency_network:9">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>j</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <interval closure="open">
     <ci>j</ci>
     <ci>k</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(j,k)
  </annotation>
 </semantics>
</math>

 of node <em>j</em> on the correlation <em>C(i,k)</em> is given by: 

<math display="inline" id="Dependency_network:10">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">|</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≡</mo>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>-</mo>
   <mi>P</mi>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">|</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">d</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">k</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <equivalent></equivalent>
    <csymbol cd="unknown">C</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">k</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <minus></minus>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">k</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(i,k|j)\equiv C(i,k)-PC(i,k|j)
  </annotation>
 </semantics>
</math>

 This avoids the trivial case were node <em>j</em> appears to strongly effect the correlation 

<math display="inline" id="Dependency_network:11">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <interval closure="open">
     <ci>i</ci>
     <ci>k</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(i,k)
  </annotation>
 </semantics>
</math>

 , mainly because 

<math display="inline" id="Dependency_network:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>C</ci>
     <interval closure="open">
      <ci>i</ci>
      <ci>j</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>C</ci>
     <interval closure="open">
      <ci>i</ci>
      <ci>k</ci>
     </interval>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(i,j),C(i,k)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependency_network:13">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>j</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <interval closure="open">
     <ci>j</ci>
     <ci>k</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(j,k)
  </annotation>
 </semantics>
</math>

 have small values. We note that this quantity can be viewed either as the correlation dependency of <em>C(i,k)</em> on node <em>j</em>, (the term used here) or as the correlation influence of node <em>j</em> on the correlation <em>C(i,k)</em>.</p>
<h3 id="node-activity-dependencies">Node activity dependencies</h3>

<p>Next, we define the total influence of node <em>j</em> on node <em>i</em>, or the dependency <em>D(i,j)</em> of node <em>i</em> on node <em>j</em> to be: 

<math display="inline" id="Dependency_network:14">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mfrac>
   <msubsup>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>k</mi>
     <mo>≠</mo>
     <mi>j</mi>
    </mrow>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">|</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <neq></neq>
       <ci>k</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <csymbol cd="unknown">d</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">k</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(i,j)=\frac{1}{N-1}\sum_{k\neq j}^{N-1}d(i,k|j)
  </annotation>
 </semantics>
</math>

</p>

<p>As defined,<em>D(i,j)</em> is a measure of the average influence of node <em>j</em> on the correlations <em>C(i,k)</em> over all nodes <em>k</em> not equal to <em>j</em>. The node activity dependencies define a dependency matrix <em>D</em> whose <em>(i,j)</em> element is the dependency of node <em>i</em> on node <em>j</em>. It is important to note that while the correlation matrix C is a symmetric matrix, the dependency matrix D is nonsymmetrical – 

<math display="inline" id="Dependency_network:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>j</mi>
     <mo>,</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <ci>D</ci>
     <interval closure="open">
      <ci>i</ci>
      <ci>j</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>D</ci>
     <interval closure="open">
      <ci>j</ci>
      <ci>i</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(i,j)\neq D(j,i)
  </annotation>
 </semantics>
</math>

 since the influence of node <em>j</em> on node <em>i</em> is not equal to the influence of node <em>i</em> on node <em>j</em>. For this reason, some of the methods used in the analyses of the correlation matrix (e.g. the PCA) have to be replaced or are less efficient. Yet there are other methods, as the ones used here, that can properly account for the non-symmetric nature of the dependency matrix.</p>
<h2 id="the-structure-dependency-networks">The structure dependency networks</h2>

<p>The path influence and distance dependency: The relative effect of node <em>j</em> on the directed path 

<math display="inline" id="Dependency_network:16">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>→</mo>
    <mi>k</mi>
    <mo stretchy="false">|</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">k</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   DP(i\rightarrow k|j)
  </annotation>
 </semantics>
</math>

 - the shortest topological path with each segment corresponds to a distance 1, between nodes <em>i</em> and <em>k</em> is given: 

<math display="inline" id="Dependency_network:17">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>→</mo>
    <mi>k</mi>
    <mo stretchy="false">|</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≡</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>t</mi>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo>→</mo>
      <mi>k</mi>
      <mo stretchy="false">|</mo>
      <msup>
       <mi>j</mi>
       <mo>+</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>-</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>t</mi>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo>→</mo>
      <mi>k</mi>
      <mo stretchy="false">|</mo>
      <msup>
       <mi>j</mi>
       <mo>-</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">k</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <equivalent></equivalent>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">t</csymbol>
      <csymbol cd="unknown">d</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">i</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">k</csymbol>
       <ci>normal-|</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>j</ci>
        <plus></plus>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
    <minus></minus>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">t</csymbol>
      <csymbol cd="unknown">d</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">i</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">k</csymbol>
       <ci>normal-|</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>j</ci>
        <minus></minus>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   DP(i\rightarrow k|j)\equiv\frac{1}{td(i\rightarrow k|j^{+})}-\frac{1}{td(i%
\rightarrow k|j^{-})}
  </annotation>
 </semantics>
</math>

 Where 

<math display="inline" id="Dependency_network:18">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>→</mo>
    <mi>k</mi>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>j</mi>
     <mo>+</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <csymbol cd="unknown">d</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">k</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>j</ci>
      <plus></plus>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   td(i\rightarrow k|j^{+})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependency_network:19">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>→</mo>
    <mi>k</mi>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>j</mi>
     <mo>-</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <csymbol cd="unknown">d</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">k</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>j</ci>
      <minus></minus>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   td(i\rightarrow k|j^{-})
  </annotation>
 </semantics>
</math>

 are the shortest directed topological path from node <em>i</em> to node <em>k</em> in the presence and the absence of node <em>j</em> respectively.</p>
<h3 id="node-structural-dependencies">Node structural dependencies</h3>

<p>Next, we define the total influence of node <em>j</em> on node <em>i</em>, or the dependency <em>D(i,j)</em> of node <em>i</em> on node <em>j</em> to be:</p>

<p>

<math display="inline" id="Dependency_network:20">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mfrac>
   <msubsup>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>k</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
   <mi>D</mi>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>→</mo>
    <mi>k</mi>
    <mo stretchy="false">|</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <csymbol cd="unknown">D</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">k</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(i,j)=\frac{1}{N-1}\sum_{k=1}^{N-1}DP(i\rightarrow k|j)
  </annotation>
 </semantics>
</math>

</p>

<p>As defined, <em>D(i,j)</em> is a measure of the average influence of node <em>j</em> on the directed paths from node <em>i</em> to all other nodes <em>k</em>. The node structural dependencies define a dependency matrix <em>D</em> whose <em>(i,j)</em> element is the dependency of node <em>i</em> on node <em>j</em>, or the influence of node <em>j</em> on node <em>i</em>. It is important to note that the dependency matrix D is nonsymmetrical – 

<math display="inline" id="Dependency_network:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>j</mi>
     <mo>,</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <ci>D</ci>
     <interval closure="open">
      <ci>i</ci>
      <ci>j</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>D</ci>
     <interval closure="open">
      <ci>j</ci>
      <ci>i</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(i,j)\neq D(j,i)
  </annotation>
 </semantics>
</math>

 since the influence of node <em>j</em> on node <em>i</em> is not equal to the influence of node <em>i</em> on node <em>j</em>.</p>
<h2 id="visualization-of-the-dependency-network">Visualization of the Dependency Network</h2>

<p>The Dependency matrix is the weighted adjacency matrix, representing the fully connected network. Different algorithms can be applied to filter the fully connected network to obtain the most meaningful information, such as using a threshold approach,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> or different pruning algorithms. A widely used method to construct informative sub-graph of a complete network is the Minimum Spanning Tree (MST).<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> Another informative sub-graph, which retains more information (in comparison to the MST) is the Planar Maximally Filtered Graph (PMFG)<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> which is used here. Both methods are based on hierarchical clustering and the resulting sub-graphs include all the <em>N</em> nodes in the network whose edges represent the most relevant association correlations. The MST sub-graph contains 

<math display="inline" id="Dependency_network:22">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>N</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>N</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (N-1)
  </annotation>
 </semantics>
</math>

edges with no loops while the PMFG sub-graph contains 

<math display="inline" id="Dependency_network:23">
 <semantics>
  <mrow>
   <mn>3</mn>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>2</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">3</cn>
    <apply>
     <minus></minus>
     <ci>N</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3(N-2)
  </annotation>
 </semantics>
</math>

 edges.</p>
<h2 id="references">References</h2>

<p>External links</p>
<ul>
<li><a href="http://www.star.tau.ac.il/~eshel">Eshel Ben-Jacob homepage</a></li>
<li><a href="http://www.tamar.tau.ac.il/~dror">Dror Y. Kenett homepage</a></li>
<li><a href="http://www.ocs.unipa.it">Observatory of Complex Systems</a></li>
<li><a href="http://www.unifr.ch/econophysics/">Econophysics forum</a></li>
<li><a href="http://www.plosone.org">PLoS ONE</a></li>
<li><a href="http://www.futurict.org.il">FuturICT Israel</a></li>
</ul>

<p>"</p>

<p><a href="Category:Network_analysis" title="wikilink">Category:Network analysis</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Asaf Madi, Dror Y. Kenett, Sharron Bransburg-Zabary, Yifat Merbl, Francisco J. Quintana, Stefano Boccaletti, Alfred I. Tauber, Irun R. Cohen, and Eshel Ben-Jacob (2011), Analyses of antigen dependency networks unveil immune system reorganization between birth and adulthood, <a href="http://chaos.aip.org/resource/1/chaoeh/v21/i1/p016109_s1?isAuthorized=no">Chaos 21, 016109</a><a href="#fnref1">↩</a></li>
<li id="fn2">Yoed N. Kenett, Dror Y. Kenett, Eshel Ben-Jacob and Miriam Fuast (2011), Charting the Hebrew semantic lexicon: Using association correlations, semantic cliques and dependency networks for global and local system analysis, <a href="http://dx.crossref.org/10.1371%2Fjournal.pone.0023912">PLoS ONE 6(8): e23912</a><a href="#fnref2">↩</a></li>
<li id="fn3">Kunihiro Baba, Ritel Shibata, Masaaki Sibuya (2004), Partial correlation and conditional correlation as measures of conditional independence, <a href="http://onlinelibrary.wiley.com/doi/10.1111/j.1467-842X.2004.00360.x/abstract">Aust New Zealand J Stat 46(4): 657–774</a><a href="#fnref3">↩</a></li>
<li id="fn4">Yoash Shapira, Dror Y. Kenett, and Eshel Ben-Jacob (2009), The Index Cohesive Effect on Stock Market Correlations, <a href="http://star.tau.ac.il/~eshel/listall.htmlEuropean">Journal of Physics B. vol. 72, no. 4, pp. 657-669</a><a href="#fnref4">↩</a></li>
<li id="fn5">7) Dror Y. Kenett, Yoash Shapira, Asaf Madi, Sharron Bransburg-Zabary, Gitit Gur-Gershgoren, and Eshel Ben-Jacob (2011), Index cohesive force analysis reveals that the US market became prone to systemic collapses since 2002, <a href="http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.0019378">PLoS ONE 6(4): e19378</a><a href="#fnref5">↩</a></li>
<li id="fn6">Dror Y. Kenett, Matthias Raddant, Thomas Lux, and Eshel Ben-Jacob (submitted), Evolvement of uniformity and volatility in the stressed global market, PNAS<a href="#fnref6">↩</a></li>
<li id="fn7">Eran Stark, Rotem Drori and <a href="Moshe_Abeles" title="wikilink">Moshe Abeles</a> (2006), Partial Cross-Correlation Analysis Resolves Ambiguity in the Encoding of Multiple Movement Features, <a href="http://jn.physiology.org/content/95/3/1966.full.pdf">J Neurophysiol 95: 1966–1975</a><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12">Rosario N. Mantegna, Hierarchical structure in Financial markets, <a href="http://epjb.edpsciences.org/articles/epjb/abs/1999/17/b9199/b9199.html">Eur. Phys. J. B 11 (1), 193-197 (1999)</a><a href="#fnref12">↩</a></li>
<li id="fn13">Rosario N. Mantegna, Computer Physics Communications 121-122, 153-156 (1999)<a href="#fnref13">↩</a></li>
<li id="fn14">Guillermo J. Ortega, Rafael G. Sola and Jesus Pastor, Complex network analysis of Human ECoG data, <a href="http://www.neurorgs.com/inv/Publi/Pdf/sdarticle.pdf">Neuroscience Letters 447 (2-3), 129-133 (2008)</a><a href="#fnref14">↩</a></li>
<li id="fn15">Michele Tumminello, Claudia Coronnello, Fabrizio Lillo, Salvatore Miccichè and Rrosario N. Mantegna, Spanning trees and bootstrap reliability estimations in correlation based networks <a href="http://arxiv.org/abs/physics/0605116">1</a><a href="#fnref15">↩</a></li>
<li id="fn16">Douglas B. West, An Introduction to Graph Theory, edited by Prentice-Hall, Englewood Cliffs, NJ, 2001<a href="#fnref16">↩</a></li>
<li id="fn17">Michele Tumminello, Tomaso Aste, Tiziana Di Matteo and Rosario N. Mantegna, A tool for filtering information in complex systems, PNAS 102 (30), 10421-10426 (2005)<a href="#fnref17">↩</a></li>
</ol>
</section>
</ref></hr></body>
</html>
