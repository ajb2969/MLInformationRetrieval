<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1786">Linear network coding</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Linear network coding</h1>
<hr/>

<p><strong>Linear network coding</strong> is a technique which can be used to improve a network's throughput, efficiency and <a class="uri" href="scalability" title="wikilink">scalability</a>, as well as resilience to attacks and eavesdropping. Instead of simply relaying the <a href="Packet_(information_technology)" title="wikilink">packets</a> of information they receive, the <a href="Node_(networking)" title="wikilink">nodes</a> of a network take <em>several</em> packets and combine them together for transmission. This can be used to attain the maximum possible <a class="uri" href="information" title="wikilink">information</a> <a href="flow_network" title="wikilink">flow</a> in a <a href="Network_theory" title="wikilink">network</a>.</p>

<p>It has been proven that <a href="linear_code" title="wikilink">linear coding</a> is enough to achieve the upper bound in multicast problems with one or more sources.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> However linear coding is not sufficient in general (e.g. multisource, multisink with arbitrary demands), even for more general versions of linearity such as <a href="convolutional_coding" title="wikilink">convolutional coding</a> and <a href="filter-bank_coding" title="wikilink">filter-bank coding</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Finding optimal coding solutions for general network problems with arbitrary demands remains an open problem.</p>
<h2 id="encoding-and-decoding">Encoding and decoding</h2>

<p>In a linear network coding problem, a group of nodes 

<math display="inline" id="Linear_network_coding:0">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 are involved in moving the data from 

<math display="inline" id="Linear_network_coding:1">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 source nodes to 

<math display="inline" id="Linear_network_coding:2">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 sink nodes. Each node generates new packets which are linear combinations of earlier received packets, multiplying them by <a href="coefficient" title="wikilink">coefficients</a> chosen from a <a href="Galois_field" title="wikilink">finite field</a>, typically of size 

<math display="inline" id="Linear_network_coding:3">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mn>2</mn>
     <mi>s</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>F</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GF(2^{s})
  </annotation>
 </semantics>
</math>

.</p>

<p>Each node, 

<math display="inline" id="Linear_network_coding:4">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{k}
  </annotation>
 </semantics>
</math>

 with <a href="Indegree#Indegree_and_outdegree" title="wikilink">indegree</a>, 

<math display="inline" id="Linear_network_coding:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <mi>n</mi>
    <mi>D</mi>
    <mi>e</mi>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>p</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>I</ci>
     <ci>n</ci>
     <ci>D</ci>
     <ci>e</ci>
     <ci>g</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   InDeg(p_{k})=S
  </annotation>
 </semantics>
</math>

, generates a message 

<math display="inline" id="Linear_network_coding:6">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{k}
  </annotation>
 </semantics>
</math>

 from the linear combination of received messages 

<math display="inline" id="Linear_network_coding:7">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>M</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>S</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <ci>i</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{M_{i}\}_{i=1}^{S}
  </annotation>
 </semantics>
</math>

 by the relation:</p>

<p>

<math display="block" id="Linear_network_coding:8">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>S</mi>
    </munderover>
    <mrow>
     <msubsup>
      <mi>g</mi>
      <mi>k</mi>
      <mi>i</mi>
     </msubsup>
     <mo>⋅</mo>
     <msub>
      <mi>M</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>S</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>k</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{k}=\sum_{i=1}^{S}g_{k}^{i}\cdot M_{i}
  </annotation>
 </semantics>
</math>

 where the values 

<math display="inline" id="Linear_network_coding:9">
 <semantics>
  <msubsup>
   <mi>g</mi>
   <mi>k</mi>
   <mi>i</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <ci>k</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{k}^{i}
  </annotation>
 </semantics>
</math>

 are the coefficients selected from 

<math display="inline" id="Linear_network_coding:10">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mn>2</mn>
     <mi>s</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>F</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GF(2^{s})
  </annotation>
 </semantics>
</math>

. Note that, since operations are computed in a finite field, the generated message is of the same length as the original messages. Each node forwards the computed value 

<math display="inline" id="Linear_network_coding:11">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{k}
  </annotation>
 </semantics>
</math>

 along with the coefficients, 

<math display="inline" id="Linear_network_coding:12">
 <semantics>
  <msubsup>
   <mi>g</mi>
   <mi>k</mi>
   <mi>i</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <ci>k</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{k}^{i}
  </annotation>
 </semantics>
</math>

, used in the 

<math display="inline" id="Linear_network_coding:13">
 <semantics>
  <msup>
   <mi>k</mi>
   <mtext>th</mtext>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <mtext>th</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{\text{th}}
  </annotation>
 </semantics>
</math>

 level, 

<math display="inline" id="Linear_network_coding:14">
 <semantics>
  <msubsup>
   <mi>g</mi>
   <mi>k</mi>
   <mi>i</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <ci>k</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{k}^{i}
  </annotation>
 </semantics>
</math>

.</p>

<p>Sink nodes receive these network coded messages, and collect them in a matrix. The original messages can be recovered by performing <a href="Gaussian_elimination" title="wikilink">Gaussian elimination</a> on the matrix.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> In reduced row echelon form, decoded packets correspond to the rows of the form 

<math display="inline" id="Linear_network_coding:15">
 <semantics>
  <mrow>
   <msub>
    <mi>e</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0...010...0</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <cn type="float">0...010...0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{i}=[0...010...0]
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="a-brief-history">A brief history</h2>

<p>A network is represented by a <a href="directed_graph" title="wikilink">directed graph</a> 

<math display="inline" id="Linear_network_coding:16">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒢</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo>,</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒢</ci>
    <vector>
     <ci>V</ci>
     <ci>E</ci>
     <ci>C</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{G}=(V,E,C)
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Linear_network_coding:17">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 is the set of nodes or vertices, 

<math display="inline" id="Linear_network_coding:18">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 is the set of directed links (or edges), and 

<math display="inline" id="Linear_network_coding:19">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 gives the capacity of each link of 

<math display="inline" id="Linear_network_coding:20">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Linear_network_coding:21">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <interval closure="open">
     <ci>s</ci>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(s,t)
  </annotation>
 </semantics>
</math>

 be the maximum possible throughput from node 

<math display="inline" id="Linear_network_coding:22">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 to node 

<math display="inline" id="Linear_network_coding:23">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

. By the <a href="max-flow_min-cut_theorem" title="wikilink">max-flow min-cut theorem</a>, 

<math display="inline" id="Linear_network_coding:24">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <interval closure="open">
     <ci>s</ci>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(s,t)
  </annotation>
 </semantics>
</math>

 is upper bounded by the minimum capacity of all <a href="Cut_(graph_theory)" title="wikilink">cuts</a>, which is the sum of the capacities of the edges on a cut, between these two nodes.</p>

<p><a href="Karl_Menger" title="wikilink">Karl Menger</a> proved that there is always a set of edge-disjoint paths achieving the upper bound in a <a class="uri" href="unicast" title="wikilink">unicast</a> scenario, known as the <a href="max-flow_min-cut_theorem" title="wikilink">max-flow min-cut theorem</a>. Later, the <a href="Ford–Fulkerson_algorithm" title="wikilink">Ford–Fulkerson algorithm</a> was proposed to find such paths in polynomial time. Then, Edmonds proved in the paper "Edge-Disjoint Branchings" the upper bound in the broadcast scenario is also achievable, and proposed a polynomial time algorithm.</p>

<p>However, the situation in the <a class="uri" href="multicast" title="wikilink">multicast</a> scenario is more complicated, and in fact, such an upper bound can't be reached using traditional <a class="uri" href="routing" title="wikilink">routing</a> ideas. Ahlswede, et al. proved that it can be achieved if additional computing tasks (incoming packets are combined into one or several outgoing packets) can be done in the intermediate nodes.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="the-butterfly-network-example">The butterfly network example</h2>

<p> The butterfly network <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> is often used to illustrate how linear network coding can outperform <a class="uri" href="routing" title="wikilink">routing</a>. Two source nodes (at the top of the picture) have information A and B that must be transmitted to the two destination nodes (at the bottom), which each want to know both A and B. Each edge can carry only a single value (we can think of an edge transmitting a bit in each time slot).</p>

<p>If only routing were allowed, then the central link would be only able to carry A or B, but not both. Suppose we send A through the center; then the left destination would receive A twice and not know B at all. Sending B poses a similar problem for the right destination. We say that routing is insufficient because no routing scheme can transmit both A and B simultaneously to both destinations.</p>

<p>Using a simple code, as shown, A and B can be transmitted to both destinations simultaneously by sending the sum of the symbols through the center – in other words, we encode A and B using the formula "A+B". The left destination receives A and A + B, and can calculate B by subtracting the two values. Similarly, the right destination will receive B and A + B, and will also be able to determine both A and B.</p>

<p>A similar concept has been used to encode stereophonic sound, where there is a "left" signal and a "right" signal. The two analog signals are "added" together, and the "sum" is subsequently used to recover the original signals.</p>
<h2 id="random-network-coding">Random network coding</h2>

<p>Random network coding <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> is a simple yet powerful encoding scheme, which in broadcast transmission schemes allows close to optimal throughput using a decentralized algorithm. Nodes transmit random linear combinations of the packets they receive, with coefficients chosen from a Galois field. If the field size is sufficiently large, the probability that the receiver(s) will obtain linearly independent combinations (and therefore obtain innovative information) approaches 1. It should however be noted that, although random network coding has excellent throughput performance, if a receiver obtains an insufficient number of packets, it is extremely unlikely that they can recover any of the original packets. This can be addressed by sending additional random linear combinations until the receiver obtains the appropriate number of packets.</p>
<h3 id="open-issues">Open issues</h3>

<p>Based on previous studies, there are three important open issues in RNC:</p>
<ol>
<li>High decoding computational complexity due to using the Gauss-Jordan elimination method</li>
<li>High transmission overhead due to attaching large coefficients vectors to encoded blocks</li>
<li>Linear dependency among coefficients vectors which can reduce the number of innovative encoded blocks</li>
</ol>

<p>Recently, Behrang Barekatain et al. addressed these open issues. Therefore, RNC can be more useful for computer networks, especially wireless communications.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="wireless-network-coding">Wireless Network Coding</h2>

<p>The broadcast nature of wireless (coupled with network topology) determines the nature of <a href="Interference_(communication)" title="wikilink">interference</a>. Simultaneous transmissions in a wireless network typically result in all of the packets being lost (i.e., collision, see <a href="Multiple_Access_with_Collision_Avoidance_for_Wireless" title="wikilink">Multiple Access with Collision Avoidance for Wireless</a>). A wireless network therefore requires a scheduler (as part of the <a href="Media_access_control" title="wikilink">MAC</a> functionality) to minimize such interference. Hence any gains from network coding are strongly impacted by the underlying scheduler and will deviate from the gains seen in wired networks. Further, wireless links are typically half-duplex due to hardware constraints; i.e., a node can not simultaneously transmit and receive due to the lack of sufficient isolation between the two paths.</p>

<p>Although, originally network coding was proposed to be used at Network layer (see <a href="OSI_model" title="wikilink">OSI model</a>), in wireless networks, network coding has been widely used in either MAC layer or <a href="Physical_layer" title="wikilink">PHY</a> layer.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> It has been shown that in both cases, network coding can increase the end-to-end throughput.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="applications">Applications</h2>

<p>Network coding is seen to be useful in the following areas:</p>
<ul>
<li>Alternative to <a href="forward_error_correction" title="wikilink">forward error correction</a> and <a href="Automatic_repeat_request" title="wikilink">ARQ</a> in traditional and wireless networks with packet loss. e.g.: <a href="Coded_TCP" title="wikilink">Coded TCP</a>,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> <a href="Multi-user_ARQ" title="wikilink">Multi-user ARQ</a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></li>
<li>Robust and resilient to network attacks like snooping, eavesdropping, replay or data corruption attacks.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></li>
<li>Digital file distribution and P2P file sharing. e.g.: <a href="Avalanche_filesystem" title="wikilink">Avalanche</a> from Microsoft</li>
<li>Distributed storage.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></li>
<li>Throughput increase in wireless mesh networks. e.g. : <a href="COPE_(network_coding)" title="wikilink">COPE</a>,<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> <a href="CORE_(network_coding)" title="wikilink">CORE</a>,<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> <a href="Coding-aware_routing" title="wikilink">Coding-aware routing</a>,<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> <a class="uri" href="B.A.T.M.A.N." title="wikilink">B.A.T.M.A.N.</a></li>
<li>Bidirectional low energy transmission in wireless sensor networks.</li>
<li>Many-to-many broadcast network capacity augmentations.</li>
<li>Buffer and Delay reduction in spatial sensor networks: <a href="Spatial_buffer_multiplexing" title="wikilink">Spatial buffer multiplexing</a> <a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></li>
<li>Reduce the number of packet retransmission for a single-hop wireless multicast transmission, and hence improve network bandwidth.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></li>
<li>Distributed file sharing <a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Secret_sharing_protocol" title="wikilink">Secret sharing protocol</a></li>
<li><a href="Homomorphic_signatures_for_network_coding" title="wikilink">Homomorphic signatures for network coding</a></li>
<li><a href="Triangular_network_coding" title="wikilink">Triangular network coding</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Fragouli, C.; Le Boudec, J. &amp; Widmer, J. "Network coding: An instant primer" in <em>Computer Communication Review</em>, 2006.</li>
</ul>

<p>Ali Farzamnia, Sharifah K. Syed-Yusof, Norsheila Fisa "Multicasting Multiple Description Coding Using p-Cycle Network Coding", KSII Transactions on Internet and Information Systems, Vol 7, No 12, 2013.</p>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.ifp.uiuc.edu/~koetter/NWC/index.html">Network Coding Homepage</a></li>
<li><a href="https://wiki.lnt.ei.tum.de/doku.php?id=network_coding:bibliography_for_network_coding">A network coding bibliography</a></li>
<li>An Overview of Network Coding in Broadcast Wireless Communication:<a href="http://www.techntechie.com/the-overview-of-network-coding-in-broadcast-wireless-communication.html">1</a></li>
<li>Raymond W. Yeung, Information Theory and Network Coding, Springer 2008, <a class="uri" href="http://iest2.ie.cuhk.edu.hk/~whyeung/book2/">http://iest2.ie.cuhk.edu.hk/~whyeung/book2/</a></li>
<li>Raymond W. Yeung et al., Network Coding Theory, now Publishers, 2005, <a class="uri" href="http://iest2.ie.cuhk.edu.hk/~whyeung/netcode/monograph.html">http://iest2.ie.cuhk.edu.hk/~whyeung/netcode/monograph.html</a></li>
<li>Christina Fragouli et al., Network Coding: An Instant Primer, ACM SIGCOMM 2006, <a class="uri" href="http://infoscience.epfl.ch/getfile.py?mode=best&amp;recid">http://infoscience.epfl.ch/getfile.py?mode=best&amp;recid;</a>;=58339.</li>
<li>Avalanche Filesystem, <a class="uri" href="http://research.microsoft.com/en-us/projects/avalanche/default.aspx">http://research.microsoft.com/en-us/projects/avalanche/default.aspx</a></li>
<li>Random Network Coding, <a class="uri" href="http://www.mit.edu/~medard/coding1.htm">http://www.mit.edu/~medard/coding1.htm</a></li>
<li>Digital Fountain Codes, <a class="uri" href="http://www.icsi.berkeley.edu/~luby/">http://www.icsi.berkeley.edu/~luby/</a></li>
<li>Coding-Aware Routing, <a class="uri" href="http://arena.cse.sc.edu/papers/rocx.secon06.pdf">http://arena.cse.sc.edu/papers/rocx.secon06.pdf</a></li>
<li>MIT offers a course: <a href="http://web.mit.edu/professional/short-programs/courses/network_coding.html">Introduction to Network Coding</a></li>
<li><a href="http://www.networkworld.com/news/2007/121007-network-coding.html">Network coding: Networking's next revolution?</a></li>
<li>Coding-aware protocol design for wireless networks: <a class="uri" href="http://scholarcommons.sc.edu/etd/230/">http://scholarcommons.sc.edu/etd/230/</a></li>
</ul>

<p>"</p>

<p><a href="Category:Coding_theory" title="wikilink">Category:Coding theory</a> <a href="Category:Information_theory" title="wikilink">Category:Information theory</a> <a href="Category:Finite_fields" title="wikilink">Category:Finite fields</a> <a href="Category:Network_performance" title="wikilink">Category:Network performance</a> <a href="Category:Wireless_sensor_network" title="wikilink">Category:Wireless sensor network</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">S. Li, R. Yeung, and N. Cai, "Linear Network Coding"(<a href="http://pdos.lcs.mit.edu/decouto/papers/li03.pdf">PDF</a>), in IEEE Transactions on Information Theory, Vol 49, No. 2, pp. 371–381, 2003<a href="#fnref1">↩</a></li>
<li id="fn2">R. Dougherty, <a href="Chris_Freiling" title="wikilink">C. Freiling</a>, and K. Zeger, "Insufficiency of Linear Coding in Network Information Flow" (<a href="http://code.ucsd.edu/~zeger/publications/journals/DoFrZe05-IT-Insufficiency/DoFrZe05-IT-Insufficiency.pdf">PDF</a>), in IEEE Transactions on Information Theory, Vol. 51, No. 8, pp. 2745-2759, August 2005 ( <a href="http://code.ucsd.edu/~zeger/publications/journals/DoFrZe05-IT-Insufficiency/DoFrZe05-IT-Insufficiency-erratum.pdf">erratum</a>)<a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6">T. Ho, R. Koetter, M. Medard, D. R. Karger and M. Effros, <a href="http://www.its.caltech.edu/~tho/i1.pdf">"The Benefits of Coding over Routing in a Randomized Setting"</a> in 2003 IEEE International Symposium on Information Theory. <a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8">M.H.Firooz, Z. Chen, S. Roy and H. Liu, (<a href="http://arxiv.org/pdf/1210.1326.pdf">Wireless Network Coding via Modiﬁed 802.11 MAC/PHY: Design and Implementation on SDR</a>) in IEEE Journal on Selected Areas in Communications, 2013.<a href="#fnref8">↩</a></li>
<li id="fn9"><a href="http://nms.csail.mit.edu/~sachin/papers/copesc.pdf">XORs in The Air: Practical Wireless Network Coding</a><a href="#fnref9">↩</a></li>
<li id="fn10"><a class="uri" href="http://arxiv.org/abs/1212.2291">http://arxiv.org/abs/1212.2291</a><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="http://www.ericsson.com/technology/research_papers/wireless_access/doc/Multi-User%20ARQ.pdf">http://www.ericsson.com/technology/research_papers/wireless_access/doc/Multi-User%20ARQ.pdf</a><a href="#fnref11">↩</a></li>
<li id="fn12"><a class="uri" href="http://securenetworkcoding.wikidot.com/">http://securenetworkcoding.wikidot.com/</a><a href="#fnref12">↩</a></li>
<li id="fn13"><a class="uri" href="http://home.eng.iastate.edu/~yuzhen/publications/ZhenYu_INFOCOM_2008.pdf">http://home.eng.iastate.edu/~yuzhen/publications/ZhenYu_INFOCOM_2008.pdf</a><a href="#fnref13">↩</a></li>
<li id="fn14"><a class="uri" href="http://netcod.org/papers/11AcedanskiDMK-final.pdf">http://netcod.org/papers/11AcedanskiDMK-final.pdf</a><a href="#fnref14">↩</a></li>
<li id="fn15"><a class="uri" href="http://arxiv.org/pdf/cs/0702015.pdf">http://arxiv.org/pdf/cs/0702015.pdf</a><a href="#fnref15">↩</a></li>
<li id="fn16"><a class="uri" href="http://people.csail.mit.edu/rahul/papers/cope-ton2008.pdf">http://people.csail.mit.edu/rahul/papers/cope-ton2008.pdf</a><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a class="uri" href="http://arena.cse.sc.edu/papers/rocx.secon06.pdf">http://arena.cse.sc.edu/papers/rocx.secon06.pdf</a><a href="#fnref18">↩</a></li>
<li id="fn19"><a class="uri" href="http://www.cs.wisc.edu/~shravan/infocom-07-2.pdf">http://www.cs.wisc.edu/~shravan/infocom-07-2.pdf</a><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4146919">Welcome to IEEE Xplore 2.0: Looking at Large Networks: Coding vs. Queueing</a><a href="#fnref20">↩</a></li>
<li id="fn21"><a class="uri" href="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=4549741">http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=4549741</a><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="http://arxiv.org/pdf/1203.5395.pdf">Data dissemination in wireless networks with network coding</a><a href="#fnref22">↩</a></li>
</ol>
</section>
</body>
</html>
