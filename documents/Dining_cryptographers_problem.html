<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="538">Dining cryptographers problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Dining cryptographers problem</h1>
<hr/>

<p>In cryptography, the <strong>dining cryptographers problem</strong> studies how to perform a <a href="secure_multi-party_computation" title="wikilink">secure multi-party computation</a> of the boolean-OR function. <a href="David_Chaum" title="wikilink">David Chaum</a> first proposed this problem in 1988, and used it as an illustrative example to show it was possible to send anonymous messages with unconditional sender and recipient untraceability.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Anonymous communication networks based on this problem are often referred to as <strong>DC-nets</strong>.</p>

<p>Despite the word <em>dining</em>, the dining cryptographers problem is unrelated to the <a href="dining_philosophers_problem" title="wikilink">dining philosophers problem</a>.</p>
<h2 id="description">Description</h2>

<p>Three cryptographers gather around a table for dinner. The waiter informs them that the meal has been paid for by someone, who could be one of the cryptographers or the <a href="National_Security_Agency" title="wikilink">National Security Agency</a> (NSA). The cryptographers respect each other's right to make an anonymous payment, but want to find out whether the NSA paid. So they decide to execute a two-stage protocol.</p>

<p>In the first stage, every two cryptographers establish a shared one-bit secret, say by tossing a coin behind a menu so that only two cryptographers see the outcome in turn for each two cryptographers. Suppose, after the coin tossing, cryptographer A and B share a secret bit 

<math display="inline" id="Dining_cryptographers_problem:0">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle 1
  </annotation>
 </semantics>
</math>

, A and C share 

<math display="inline" id="Dining_cryptographers_problem:1">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle 0
  </annotation>
 </semantics>
</math>

, and B and C share 

<math display="inline" id="Dining_cryptographers_problem:2">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle 1
  </annotation>
 </semantics>
</math>

.</p>

<p>In the second stage, each cryptographer publicly announces a bit, which is</p>
<ul>
<li>if they didn't pay for the meal, the <a href="Exclusive_OR" title="wikilink">Exclusive OR</a> (XOR) of the two shared bits they hold with their two neighbours</li>
<li>if they did pay for the meal, the opposite of that XOR.</li>
</ul>

<p>Suppose none of the cryptographers paid, then A would announce 

<math display="inline" id="Dining_cryptographers_problem:3">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+1.7pt">
     <mn>1</mn>
    </mpadded>
    <mo>⊕</mo>
    <mpadded width="+2.8pt">
     <mn>0</mn>
    </mpadded>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <cn type="integer">1</cn>
     <cn type="float">0</cn>
    </apply>
    <cn type="float">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle 1\,\oplus\,0\;=\;1
  </annotation>
 </semantics>
</math>

, B would announce 

<math display="inline" id="Dining_cryptographers_problem:4">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+1.7pt">
     <mn>1</mn>
    </mpadded>
    <mo>⊕</mo>
    <mpadded width="+2.8pt">
     <mn>1</mn>
    </mpadded>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <cn type="integer">1</cn>
     <cn type="float">1</cn>
    </apply>
    <cn type="float">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle 1\,\oplus\,1\;=\;0
  </annotation>
 </semantics>
</math>

, and C would announce 

<math display="inline" id="Dining_cryptographers_problem:5">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+1.7pt">
     <mn>0</mn>
    </mpadded>
    <mo>⊕</mo>
    <mpadded width="+2.8pt">
     <mn>1</mn>
    </mpadded>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <cn type="integer">0</cn>
     <cn type="float">1</cn>
    </apply>
    <cn type="float">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle 0\,\oplus\,1\;=\;1
  </annotation>
 </semantics>
</math>

. On the other hand, if A paid, he would announce 

<math display="inline" id="Dining_cryptographers_problem:6">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mn>1</mn>
      </mpadded>
      <mo>⊕</mo>
      <mn>0</mn>
     </mrow>
     <mo rspace="5.3pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <not></not>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <cn type="integer">1</cn>
      <cn type="float">0</cn>
     </apply>
    </apply>
    <cn type="float">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\lnot{(1\,\oplus\,0)}\;=\;0
  </annotation>
 </semantics>
</math>

.</p>

<p>After the second stage is the truth revealing. One simply performs XOR of all the announced bits. If the result is 0, then it implies that none of the cryptographers paid (so NSA must have paid). Otherwise, it would imply one of the cryptographers paid, but their identity remains unknown to the other cryptographers.</p>

<p>David Chaum coined the term <em>dining cryptographers network</em>, or DC-net, for this protocol.</p>
<h2 id="limitations">Limitations</h2>

<p>The DC-net protocol is simple and elegant. It has several limitations, however, some solutions to which have been explored in follow-up research (see the References section below).</p>
<dl>
<dt>Collision : If two cryptographers paid for the dinner, their messages will cancel each other out, and the final XOR result will be 

<math display="inline" id="Dining_cryptographers_problem:7">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle 0
  </annotation>
 </semantics>
</math>

. This is called a collision, and allows only one participant to transmit at a time using this protocol. In a more general case, a collision happens as long as any even number of participants send messages.</dt>
</dl>
<dl>
<dt>Disruption : Any malicious cryptographer who does not want the group to communicate successfully can jam the protocol so that the final XOR result is useless, simply by sending random bits instead of the correct result of the XOR. This problem occurs because the original protocol was designed without using any <a href="public_key" title="wikilink">public key</a> technology, and lacks reliable mechanisms to check whether participants honestly follow the protocol.</dt>
</dl>
<dl>
<dt>Complexity : The protocol requires pairwise shared secret keys between the participants, which may be problematic if there are many participants. Also, though the DC-net protocol is "unconditionally secure", it actually depends on the assumption that "unconditionally secure" channels already exist between pairs of the participants, which is not easy to achieve in practice.</dt>
</dl>

<p>A related <a href="anonymous_veto_network" title="wikilink">anonymous veto network</a> algorithm computes the logical OR of several users' inputs, rather than a logical XOR as in DC-nets, which may be useful in applications to which a logical OR combining operation is naturally suited.</p>
<h2 id="generalizations">Generalizations</h2>

<p>DC-nets are readily generalized to allow for transmissions of more than one bit per round, for groups larger than three participants, and for arbitrary "alphabets" other than the binary digits 0 and 1, as described below.</p>
<h3 id="transmissions-of-longer-messages">Transmissions of longer messages</h3>

<p>To enable an anonymous sender to transmit more than one bit of information per DC-nets round, the group of cryptographers can simply repeat the protocol as many times as desired to create a desired number of bits worth of transmission bandwidth. These repetitions need not be performed serially. In practical DC-net systems, it is typical for pairs of participants to agree up-front on a single shared "master" secret, using <a href="Diffie–Hellman_key_exchange" title="wikilink">Diffie–Hellman key exchange</a> for example. Each participant then locally feeds this shared master secret into a <a href="pseudorandom_number_generator" title="wikilink">pseudorandom number generator</a>, in order to produce as many shared "coin flips" as desired to allow an anonymous sender to transmit multiple bits of information.</p>
<h3 id="larger-group-sizes">Larger group sizes</h3>

<p>The protocol can be generalized to a group of 

<math display="inline" id="Dining_cryptographers_problem:8">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle n
  </annotation>
 </semantics>
</math>

 participants, each with a shared secret key in common with each other participant. In each round of the protocol, if a participant wants to transmit an untraceable message to the group, they invert their publicly announced bit. The participants can be visualized as a <a href="Complete_graph" title="wikilink">fully connected graph</a> with the vertices representing the participants and the edges representing their shared secret keys.</p>
<h3 id="sparse-secret-sharing-graphs">Sparse secret sharing graphs</h3>

<p>The protocol may be run with less than fully connected secret sharing graphs, which can improve the performance and scalability of practical DC-net implementations, at the potential risk of reducing anonymity if colluding participants can split the secret sharing graph into separate connected components. For example, an intuitively appealing but less secure generalization to 

<math display="inline" id="Dining_cryptographers_problem:9">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>></mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>n</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle n>3
  </annotation>
 </semantics>
</math>

 participants using a <a href="ring_topology" title="wikilink">ring topology</a>, where each cryptographer sitting around a table shares a secret <em>only</em> with the cryptographer to their immediate left and right, and <em>not</em> with every other cryptographer. Such a topology is appealing because each cryptographer needs to coordinate two coin flips per round, rather than 

<math display="inline" id="Dining_cryptographers_problem:10">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle n
  </annotation>
 </semantics>
</math>

. However, if Adam and Charlie are actually NSA agents sitting immediately to the left and right of Bob, an innocent victim, and if Adam and Charlie secretly collude to reveal their secrets to each other, then they can determine with certainty whether or not Bob was the sender of a 1 bit in a DC-net run, regardless of how many participants there are in total. This is because the colluding participants Adam and Charlie effectively "split" the secret sharing graph into two separate disconnected components, one containing only Bob, the other containing all other honest participants.</p>

<p>Another compromise secret sharing DC-net topology, employed in the <a href="http://dedis.cs.yale.edu/2010/anon/">Dissent</a> system for scalability,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> may be described as a <em>client/server</em> or <em>user/trustee</em> topology. In this variant, we assume there are two types of participants playing different roles: a potentially large number ''n ''of users who desire anonymity, and a much smaller number 

<math display="inline" id="Dining_cryptographers_problem:11">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle m
  </annotation>
 </semantics>
</math>

 of <em>trustees</em> whose role is to help the users obtain that anonymity. In this topology, each of the 

<math display="inline" id="Dining_cryptographers_problem:12">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle n
  </annotation>
 </semantics>
</math>

 users shares a secret with each of the 

<math display="inline" id="Dining_cryptographers_problem:13">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle m
  </annotation>
 </semantics>
</math>

 trustees - but users share no secrets directly with other users, and trustees share no secrets directly with other trustees - resulting in an 

<math display="inline" id="Dining_cryptographers_problem:14">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle n\times m
  </annotation>
 </semantics>
</math>

 secret sharing matrix. If the number of trustees 

<math display="inline" id="Dining_cryptographers_problem:15">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle m
  </annotation>
 </semantics>
</math>

 is small, then each user needs to manage only a few shared secrets, improving efficiency for users in the same way the ring topology does. However, as long as <em>at least one trustee</em> behaves honestly and does not leak his or her secrets or collude with other participants, then that honest trustee forms a "hub" connecting all honest users into a single fully connected component, regardless of which or how many other users and/or trustees might be dishonestly colluding. Users need not know or guess which trustee is honest; their security depends only on the <em>existence</em> of at least one honest, non-colluding trustee.</p>
<h3 id="alternate-alphabets-and-combining-operators">Alternate alphabets and combining operators</h3>

<p>Though the simple DC-nets protocol uses <a href="Bit" title="wikilink">binary digits</a> as its transmission alphabet, and uses the XOR operator to combine cipher texts, the basic protocol generalizes to any alphabet and combining operator suitable for <a href="one-time_pad" title="wikilink">one-time pad</a> encryption. This flexibility arises naturally from the fact that the secrets shared between the many pairs of participants are, in effect, merely one-time pads combined together symmetrically within a single DC-net round.</p>

<p>One useful alternate choice of DC-nets alphabet and combining operator is to use a <a href="finite_group" title="wikilink">finite group</a> suitable for public-key cryptography as the alphabet - such as a <a href="Schnorr_group" title="wikilink">Schnorr group</a> or <a href="elliptic_curve" title="wikilink">elliptic curve</a> - and to use the associated group operator as the DC-net combining operator. Such a choice of alphabet and operator makes it possible for clients to use <a href="zero-knowledge_proof" title="wikilink">zero-knowledge proof</a> techniques to prove correctness properties about the DC-net ciphertexts that they produce - such as that the participant is not "jamming" the transmission channel - without compromising the anonymity offered by the DC-net. This technique was first suggested by Golle and Juels,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> further developed by Franck,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> and later implemented in <a href="http://dedis.cs.yale.edu/2010/anon/papers/verdict-abs">Verdict</a>, a cryptographically verifiable implementation of the <a href="http://dedis.cs.yale.edu/2010/anon/">Dissent</a> system.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="handling-or-avoiding-collisions">Handling or avoiding collisions</h2>

<p>The measure originally suggested by David Chaum to avoid collisions is to retransmit the message once a collision is detected, but the paper does not explain exactly how to arrange the retransmission.</p>

<p><a href="http://dedis.cs.yale.edu/2010/anon/">Dissent</a> avoids the possibility of unintentional collisions by using a verifiable shuffle to establish a DC-nets transmission schedule, such that each participant knows exactly which bits in the schedule correspond to his own transmission slot, but does not know who owns other transmission slots.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="countering-disruption-attacks">Countering disruption attacks</h2>

<p><a href="http://www.cs.cornell.edu/people/egs/herbivore/documentation.html">Herbivore</a> divides a large anonymity network into smaller DC-net groups, enabling participants to evade disruption attempts by leaving a disrupted group and joining another group, until the participant finds a group free of disruptors.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> This evasion approach introduces the risk that an adversary who owns many nodes could <em>selectively</em> disrupt only groups the adversary has not <em>completely</em> compromised, thereby "herding" participants toward groups that may be functional precisely because they are completely compromised.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p><a href="http://dedis.cs.yale.edu/2010/anon/">Dissent</a> implements several schemes to counter disruption. The original protocol<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> used a verifiable <a href="shuffling" title="wikilink">cryptographic shuffle</a> to form a DC-net transmission schedule and distribute "transmission assignments", allowing the correctness of subsequent DC-nets ciphertexts to be verified with a simple <a href="cryptographic_hash_function" title="wikilink">cryptographic hash</a> check. This technique required a fresh verifiable before every DC-nets round, however, leading to high latencies. A later, more efficient scheme allows a series of DC-net rounds to proceed without intervening shuffles in the absence of disruption, but in response to a disruption event uses a shuffle to distribute anonymous <em>accusations</em> enabling a disruption victim to expose and prove the identity of the perpetrator.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Finally, more recent versions support fully verifiable DC-nets - at substantial cost in computation efficiency due to the use of <a href="public-key_cryptography" title="wikilink">public-key cryptography</a> in the DC-net - as well as a <em>hybrid</em> mode that uses efficient XOR-based DC-nets in the normal case and verifiable DC-nets only upon disruption, to distribute accusations more quickly than is feasible using verifiable shuffles.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a class="uri" href="Category:Cryptography" title="wikilink">Category:Cryptography</a> <a href="Category:Mathematical_problems" title="wikilink">Category:Mathematical problems</a> <a href="Category:Zero-knowledge_protocols" title="wikilink">Category:Zero-knowledge protocols</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
</ol>
</section>
</body>
</html>
