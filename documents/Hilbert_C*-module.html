<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="86">Hilbert C*-module</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Hilbert C*-module</h1><hr/>

<p><strong>Hilbert C*-modules</strong> are <a href="mathematical_object" title="wikilink">mathematical objects</a> which generalise the notion of a <a href="Hilbert_space" title="wikilink">Hilbert space</a> (which itself is a generalisation of <a href="Euclidean_space" title="wikilink">Euclidean space</a>), in that they endow a <a href="vector_space" title="wikilink">linear space</a> with an "<a href="inner_product" title="wikilink">inner product</a>" which takes values in a <a class="uri" href="C*-algebra" title="wikilink">C*-algebra</a>. Hilbert C*-modules were first introduced in the work of <a href="Irving_Kaplansky" title="wikilink">Irving Kaplansky</a> in <a href="1953_in_science" title="wikilink">1953</a>, which developed the theory for <a class="uri" href="commutative" title="wikilink">commutative</a>, <a href="unital_algebra" title="wikilink">unital algebras</a> (though Kaplansky observed that the assumption of a unit element was not "vital").<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> In the 1970s the theory was extended to non-commutative C*-algebras independently by William Lindall Paschke<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and <a href="Marc_Rieffel" title="wikilink">Marc Rieffel</a>, the latter in a paper which used Hilbert C*-modules to construct a theory of <a href="induced_representation" title="wikilink">induced representations</a> of C*-algebras.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Hilbert C*-modules are crucial to Kasparov's formulation of <a class="uri" href="KK-theory" title="wikilink">KK-theory</a>,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> and provide the right framework to extend the notion of <a href="Morita_equivalence" title="wikilink">Morita equivalence</a> to <a class="uri" href="C*-algebras" title="wikilink">C*-algebras</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> They can be viewed as the generalization of <a href="vector_bundles" title="wikilink">vector bundles</a> to noncommutative <a class="uri" href="C*-algebras" title="wikilink">C*-algebras</a> and as such play an important role in <a href="noncommutative_geometry" title="wikilink">noncommutative geometry</a>, notably in <a href="C*-algebraic_quantum_group_theory" title="wikilink">C*-algebraic quantum group theory</a>,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> and <a class="uri" href="groupoid" title="wikilink">groupoid</a> <a class="uri" href="C*-algebras" title="wikilink">C*-algebras</a>.</p>
<h2 id="definitions">Definitions</h2>
<h3 id="inner-product-a-modules">Inner-product <em>A</em>-modules</h3>

<p>Let <em>A</em> be a C*-algebra (not assumed to be commutative or unital), its <a href="Involution_(mathematics)" title="wikilink">involution</a> denoted by *. An <strong>inner-product <em>A</em>-module</strong> (or <strong>pre-Hilbert <em>A</em>-module</strong>) is a <a href="complex_number" title="wikilink">complex</a> linear space <em>E</em> which is equipped with a compatible right <a href="Module_(mathematics)" title="wikilink"><em>A</em>-module</a> structure, together with a map</p>

<p>

<math display="block" id="Hilbert_C*-module:0">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mo>⋅</mo>
    <mo>,</mo>
    <mo>⋅</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>E</mi>
     <mo>×</mo>
     <mi>E</mi>
    </mrow>
    <mo>→</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <list>
     <ci>normal-⋅</ci>
     <ci>normal-⋅</ci>
    </list>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>E</ci>
     </apply>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\cdot,\cdot\rangle:E\times E\rightarrow A
  </annotation>
 </semantics>
</math>

 which satisfies the following properties:</p>
<ul>
<li>For all <em>x</em>, <em>y</em>, <em>z</em> in <em>E</em>, and α, β in <strong>C</strong>:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Hilbert_C*-module:1">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mi>α</mi>
      <mi>y</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>β</mi>
      <mi>z</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>α</mi>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>β</mi>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>z</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>α</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <times></times>
       <ci>β</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </list>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>α</ci>
      <list>
       <ci>x</ci>
       <ci>y</ci>
      </list>
     </apply>
     <apply>
      <times></times>
      <ci>β</ci>
      <list>
       <ci>x</ci>
       <ci>z</ci>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x,\alpha y+\beta z\rangle=\alpha\langle x,y\rangle+\beta\langle x,z\rangle
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>(<em>i.e.</em> the inner product is linear in its second argument).
</dd>
</dl>
<ul>
<li>For all <em>x</em>, <em>y</em> in <em>E</em>, and <em>a</em> in <em>A</em>:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Hilbert_C*-module:2">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mrow>
     <mi>y</mi>
     <mi>a</mi>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>a</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>a</ci>
     </apply>
    </list>
    <apply>
     <times></times>
     <list>
      <ci>x</ci>
      <ci>y</ci>
     </list>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x,ya\rangle=\langle x,y\rangle a
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li>For all <em>x</em>, <em>y</em> in <em>E</em>:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Hilbert_C*-module:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>x</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>*</mo>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>x</ci>
     <ci>y</ci>
    </list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <list>
      <ci>y</ci>
      <ci>x</ci>
     </list>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x,y\rangle=\langle y,x\rangle^{*},
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>from which it follows that the inner product is <a href="conjugate_linear" title="wikilink">conjugate linear</a> in its first argument (<em>i.e.</em> it is a <a href="sesquilinear_form" title="wikilink">sesquilinear form</a>).
</dd>
</dl>
<ul>
<li>For all <em>x</em> in <em>E</em>:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Hilbert_C*-module:4">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <list>
     <ci>x</ci>
     <ci>x</ci>
    </list>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x,x\rangle\geq 0
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>and
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Hilbert_C*-module:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>x</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mi>x</mi>
    <mo>=</mo>
    <mn>0.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <apply>
     <eq></eq>
     <list>
      <ci>x</ci>
      <ci>x</ci>
     </list>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <eq></eq>
     <ci>x</ci>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x,x\rangle=0\iff x=0.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>(An element of a C*-algebra <em>A</em> is said to be <em>positive</em> if it is <a class="uri" href="self-adjoint" title="wikilink">self-adjoint</a> with non-negative <a href="Spectrum_(functional_analysis)" title="wikilink">spectrum</a>.)<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a>
</dd>
</dl>
<h3 id="hilbert-a-modules">Hilbert <em>A</em>-modules</h3>

<p>An analogue to the <a href="Cauchy-Schwarz_inequality" title="wikilink">Cauchy-Schwarz inequality</a> holds for an inner-product <em>A</em>-module <em>E</em>:<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>

<math display="block" id="Hilbert_C*-module:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>x</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>x</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <list>
      <ci>x</ci>
      <ci>y</ci>
     </list>
     <list>
      <ci>y</ci>
      <ci>x</ci>
     </list>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <list>
       <ci>x</ci>
       <ci>x</ci>
      </list>
     </apply>
     <list>
      <ci>y</ci>
      <ci>y</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x,y\rangle\langle y,x\rangle\leq\|\langle x,x\rangle\|\langle y,y\rangle
  </annotation>
 </semantics>
</math>

</p>

<p>for <em>x</em>, <em>y</em> in <em>E</em>.</p>

<p>On the pre-Hilbert module <em>E</em>, define a norm by</p>

<p>

<math display="block" id="Hilbert_C*-module:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mi>x</mi>
     <mo>∥</mo>
    </mrow>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>x</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <list>
       <ci>x</ci>
       <ci>x</ci>
      </list>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|x\|=\|\langle x,x\rangle\|^{\frac{1}{2}}.
  </annotation>
 </semantics>
</math>

</p>

<p>The norm-completion of <em>E</em>, still denoted by <em>E</em>, is said to be a <strong>Hilbert <em>A</em>-module</strong> or a <strong>Hilbert C*-module over the C*-algebra <em>A</em></strong>. The Cauchy-Schwarz inequality implies the inner product is jointly continuous in norm and can therefore be extended to the completion.</p>

<p>The action of <em>A</em> on <em>E</em> is continuous: for all <em>x</em> in <em>E</em></p>

<p>

<math display="block" id="Hilbert_C*-module:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mi>λ</mi>
    </msub>
    <mo>→</mo>
    <mi>a</mi>
    <mo>⇒</mo>
    <mrow>
     <mi>x</mi>
     <msub>
      <mi>a</mi>
      <mi>λ</mi>
     </msub>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>x</mi>
     <mi>a</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>λ</ci>
     </apply>
     <ci>a</ci>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>λ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{\lambda}\rightarrow a\Rightarrow xa_{\lambda}\rightarrow xa.
  </annotation>
 </semantics>
</math>

</p>

<p>Similarly, if {<em>e<sub>λ</sub></em>} is an <a href="Approximate_identity" title="wikilink">approximate unit</a> for <em>A</em> (a <a href="Net_(mathematics)" title="wikilink">net</a> of self-adjoint elements of <em>A</em> for which <em>ae</em><sub>λ</sub> and <em>e</em><sub>λ</sub><em>a</em> tend to <em>a</em> for each <em>a</em> in <em>A</em>), then for <em>x</em> in <em>E</em></p>

<p>

<math display="block" id="Hilbert_C*-module:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <msub>
     <mi>e</mi>
     <mi>λ</mi>
    </msub>
   </mrow>
   <mo>→</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>λ</ci>
     </apply>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   xe_{\lambda}\rightarrow x
  </annotation>
 </semantics>
</math>

</p>

<p>whence it follows that <em>EA</em> is <a href="Dense_set" title="wikilink">dense</a> in <em>E</em>, and <em>x</em>1 = <em>x</em> when <em>A</em> is unital.</p>

<p>Let</p>

<p>

<math display="block" id="Hilbert_C*-module:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>E</mi>
     <mo>,</mo>
     <mi>E</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>span</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mo stretchy="false">|</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mrow>
       <mi>y</mi>
       <mo>∈</mo>
       <mi>E</mi>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>E</ci>
     <ci>E</ci>
    </list>
    <apply>
     <ci>span</ci>
     <list>
      <ci>x</ci>
      <ci>y</ci>
     </list>
     <ci>x</ci>
     <apply>
      <in></in>
      <ci>y</ci>
      <ci>E</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle E,E\rangle=\operatorname{span}\{\langle x,y\rangle|x,y\in E\},
  </annotation>
 </semantics>
</math>

</p>

<p>then the <a href="Closure_(topology)" title="wikilink">closure</a> of  is a two-sided ideal in <em>A</em>. Two-sided ideals are C*-subalgebras and therefore possess approximate units. One can verify that <em>E</em> is dense in <em>E</em>. In the case when  is dense in <em>A</em>, <em>E</em> is said to be <strong>full</strong>. This does not generally hold.</p>
<h2 id="examples">Examples</h2>
<h3 id="hilbert-spaces">Hilbert spaces</h3>

<p>A complex Hilbert space <em>H</em> is a Hilbert <strong>C</strong>-module under its inner product, the complex numbers being a C*-algebra with an involution given by <a href="complex_conjugation" title="wikilink">complex conjugation</a>.</p>
<h3 id="vector-bundles">Vector bundles</h3>

<p>If <em>X</em> is a <a href="locally_compact_Hausdorff_space" title="wikilink">locally compact Hausdorff space</a> and <em>E</em> a <a href="vector_bundle" title="wikilink">vector bundle</a> over <em>X</em> with a <a href="Riemannian_metric" title="wikilink">Riemannian metric</a> <em>g</em>, then the space of continuous sections of <em>E</em> is a Hilbert <em>C(X)</em>-module. The inner product is given by</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Hilbert_C*-module:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>f</mi>
      <mo>,</mo>
      <mi>h</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>:=</mo>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>h</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <list>
      <ci>f</ci>
      <ci>h</ci>
     </list>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>x</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle f,h\rangle(x):=g(f(x),h(x)).
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>The converse holds as well: Every countably generated Hilbert C*-module over a commutative C*-algebra <em>A = C(X)</em> is isomorphic to the space of sections vanishing at infinity of a continuous field of Hilbert spaces over <em>X</em>.</p>
<h3 id="c-algebras">C*-algebras</h3>

<p>Any C*-algebra <em>A</em> is a Hilbert <em>A</em>-module under the inner product  = <em>a</em>*<em>b</em>. By the C*-identity, the Hilbert module norm coincides with C*-norm on <em>A</em>.</p>

<p>The (algebraic) <a href="direct_sum_of_modules" title="wikilink">direct sum</a> of <em>n</em> copies of <em>A</em></p>

<p>

<math display="block" id="Hilbert_C*-module:12">
 <semantics>
  <mrow>
   <msup>
    <mi>A</mi>
    <mi>n</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo>⊕</mo>
     <mn>1</mn>
     <mi>n</mi>
    </msubsup>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">direct-sum</csymbol>
       <cn type="integer">1</cn>
      </apply>
      <ci>n</ci>
     </apply>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{n}=\oplus_{1}^{n}A
  </annotation>
 </semantics>
</math>

</p>

<p>can be made into a Hilbert <em>A</em>-module by defining</p>

<p>

<math display="block" id="Hilbert_C*-module:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>a</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>b</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <msubsup>
       <mi>a</mi>
       <mi>i</mi>
       <mo>*</mo>
      </msubsup>
      <msub>
       <mi>b</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>i</ci>
     </apply>
    </list>
    <apply>
     <sum></sum>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle(a_{i}),(b_{i})\rangle=\sum a_{i}^{*}b_{i}.
  </annotation>
 </semantics>
</math>

</p>

<p>One may also consider the following elements in the countable direct product of <em>A</em></p>

<p>

<math display="block" id="Hilbert_C*-module:14">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi class="ltx_font_mathcaligraphic">ℋ</mi>
     <mi>A</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>a</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <msubsup>
        <mi>a</mi>
        <mi>i</mi>
        <mo>*</mo>
       </msubsup>
       <msub>
        <mi>a</mi>
        <mi>i</mi>
       </msub>
       <mtext>converges in</mtext>
       <mi>A</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℋ</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <sum></sum>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>i</ci>
        </apply>
        <times></times>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <mtext>converges in</mtext>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}_{A}=\{(a_{i})|\sum a_{i}^{*}a_{i}\text{ converges in }A\}.
  </annotation>
 </semantics>
</math>

</p>

<p>Given an inner product analogous to that on <em>A<sup>n</sup></em>, the resulting Hilbert <em>A</em>-module is called the <strong>standard Hilbert module</strong>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Operator_algebra" title="wikilink">Operator algebra</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://www.imn.htwk-leipzig.de/~mfrank/hilmod.html">Hilbert C*-Modules Home Page</a>, a literature list</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:C*-algebras" title="wikilink">Category:C*-algebras</a> <a href="Category:Operator_theory" title="wikilink">Category:Operator theory</a> <a href="Category:Theoretical_physics" title="wikilink">Category:Theoretical physics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9">In the case when <em>A</em> is non-unital, the spectrum of an element is calculated in the C*-algebra generated by adjoining a unit to <em>A</em>.<a href="#fnref9">↩</a></li>
<li id="fn10">This result in fact holds for semi-inner-product <em>A</em>-modules, which may have non-zero elements <em>x</em> such that  = 0, as the proof does not rely on the <a class="uri" href="nondegeneracy" title="wikilink">nondegeneracy</a> property.<a href="#fnref10">↩</a></li>
</ol>
</section>
</body>
</html>
