<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="663">Centrality</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Centrality</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Examples of A) <a href="Betweenness_centrality" title="wikilink">Betweenness centrality</a>, B) <a href="Closeness_centrality" title="wikilink">Closeness centrality</a>, C) <a href="Eigenvector_centrality" title="wikilink">Eigenvector centrality</a>, D) <a href="Degree_centrality" title="wikilink">Degree centrality</a>, E) <a href="Harmonic_centrality" title="wikilink">Harmonic centrality</a> and F) <a href="Katz_centrality" title="wikilink">Katz centrality</a> of the same graph.</figcaption>
</figure>

<p>In <a href="graph_theory" title="wikilink">graph theory</a> and <a href="network_theory" title="wikilink">network analysis</a>, indicators of <strong>centrality</strong> identify the most important <a href="vertex_(graph_theory)" title="wikilink">vertices</a> within a graph. Applications include identifying the most influential person(s) in a <a href="social_network" title="wikilink">social network</a>, key infrastructure nodes in the <a class="uri" href="Internet" title="wikilink">Internet</a> or <a href="urban_network" title="wikilink">urban networks</a>, and <a href="super-spreader" title="wikilink">super-spreaders</a> of disease. Centrality concepts were first developed in <a href="social_network_analysis" title="wikilink">social network analysis</a>, and many of the terms used to measure centrality reflect their <a href="sociology" title="wikilink">sociological</a> origin.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> They should not be confused with <a href="Node_influence_metric" title="wikilink">node influence metrics</a>, which seek to quantify the influence of every node in the network.</p>
<h2 id="definition-and-characterization-of-centrality-indices">Definition and characterization of centrality indices</h2>

<p>Centrality indices are answers to the question "What characterizes an important vertex?" The answer is given in terms of a real-valued function on the vertices of a graph, where the values produced are expected to provide a ranking which identifies the most important nodes.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>The word "importance" has a wide number of meanings, leading to many different definitions of centrality. Two categorization schemes have been proposed. "Importance" can be conceived in relation to a type of flow or transfer across the network. This allows centralities to be classified by the type of flow they consider important.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> "Importance" can alternately be conceived as involvement in the cohesiveness of the network. This allows centralities to be classified based on how they measure cohesiveness.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Both of these approaches divide centralities in distinct categories. A further conclusion is that a centrality which is appropriate for one category will often "get it wrong" when applied to a different category.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>When centralities are categorized by their approach to cohesiveness, it becomes apparent that the majority of centralities inhabit one category. The count of the number of walks starting from a given vertex differs only in how walks are defined and counted. Restricting consideration to this group allows for a soft characterization which places centralities on a spectrum from walks of length one (<a href="Centrality#Degree_centrality" title="wikilink">degree</a> centrality) to infinite walks (<a href="Centrality#Eigenvector_centrality" title="wikilink">eigenvalue</a> centrality).<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> The observation that many centralities share this familial relationships perhaps explains the high rank correlations between these indices.</p>
<h3 id="characterization-by-network-flows">Characterization by network flows</h3>

<p>A network can be considered a description of the paths along which something flows. This allows a characterization based on the type of flow and the type of path encoded by the centrality. A flow can be based on transfers, where each undivisible item goes from one node to another, like a package delivery which goes from the delivery site to the client's house. A second case is the serial duplication, where this is a replication of the item which goes to the next node, so both the source and the target have it. An example is the propagation of information through gossip, with the information being propagated in a private way and with both the source and the target nodes being informed at the end of the process. The last case is the parallel duplication, with the item being duplicated to several links at the same time, like a radio broadcast which provides the same information to many listeners at once.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>Likewise, the type of path can be constrained to: Geodesics (shortest paths), <a href="Walk_(graph_theory)#Walks" title="wikilink">paths</a> (no vertex is visited more than once), <a href="Walk_(graph_theory)#Walks" title="wikilink">trails</a> (vertices can be visited multiple times, no edge is traversed more than once), or <a href="Walk_(graph_theory)#Walks" title="wikilink">walks</a> (vertices and edges can be visited/traversed multiple times).<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h3 id="characterization-by-walk-structure">Characterization by walk structure</h3>

<p>An alternate classification can be derived from how the centrality is constructed. This again splits into two classes. Centralities are either <em>Radial</em> or <em>Medial.</em> Radial centralities count walks which start/end from the given vertex. The <a href="Centrality#Degree_centrality" title="wikilink">degree</a> and <a href="Centrality#Eigenvector_centrality" title="wikilink">eigenvalue</a> centralities are examples of radial centralities, counting the number of walks of length one or length infinity. Medial centralities count walks which pass through the given vertex. The canonical example is Freedman's <a href="Centrality#Betweenness_centrality" title="wikilink">betweenness</a> centrality, the number of shortest paths which pass through the given vertex.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>Likewise, the counting can capture either the <em>volume</em> or the <em>length</em> of walks. Volume is the total number of walks of the given type. The three examples from the previous paragraph fall into this category. Length captures the distance from the given vertex to the remaining vertices in the graph. Freedman's <a href="Centrality#Closeness_centrality" title="wikilink">closeness</a> centrality, the total geodesic distance from a given vertex to all other vertices, is the best known example.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Note that this classification is independent of the type of walk counted (i.e. walk, trail, path, geodesic).</p>

<p>Borgatti and Everett propose that this typology provides insight into how best to compare centrality measures. Centralities placed in the same box in this 2×2 classification are similar enough to make plausible alternatives; one can reasonably compare which is better for a given application. Measures from different boxes, however, are categorically distinct. Any evaluation of relative fitness can only occur within the context of predetermining which category is more applicable, rendering the comparison moot.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h3 id="radial-volume-centralities-exist-on-a-spectrum">Radial-volume centralities exist on a spectrum</h3>

<p>The characterization by walk structure shows that almost all centralities in wide use are radial-volume measures. These encode the belief that a vertex's centrality is a function of the centrality of the vertices it is associated with. Centralities distinguish themselves on how association is defined.</p>

<p>Bonacich showed that if association is defined in terms of <a href="Walk_(graph_theory)#Walks" title="wikilink">walks</a>, then a family of centralities can be defined based on the length of walk considered.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> The <a href="Centrality#Degree_centrality" title="wikilink">degree</a> counts walks of length one, the <a href="Centrality#Eigenvector_centrality" title="wikilink">eigenvalue</a> centrality counts walks of length infinity. Alternate definitions of association are also reasonable. The <a href="alpha_centrality" title="wikilink">alpha centrality</a> allows vertices to have an external source of influence. Estrada's subgraph centrality proposes only counting closed paths (triangles, squares, ...).</p>

<p>The heart of such measures is the observation that powers of the graph's adjacency matrix gives the number of walks of length given by that power. Similarly, the matrix exponential is also closely related to the number of walks of a given length. An initial transformation of the adjacency matrix allows differing definition of the type of walk counted. Under either approach, the centrality of a vertex can be expressed as an infinite sum, either</p>

<p>

<math display="block" id="Centrality:0">
 <semantics>
  <mrow>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>k</mi>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </munderover>
   <mrow>
    <msup>
     <mi>β</mi>
     <mi>k</mi>
    </msup>
    <msubsup>
     <mi>A</mi>
     <mi>R</mi>
     <mi>k</mi>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>k</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>β</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>R</ci>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{k=0}^{\infty}\beta^{k}A_{R}^{k}
  </annotation>
 </semantics>
</math>

</p>

<p>for matrix powers or</p>

<p>

<math display="block" id="Centrality:1">
 <semantics>
  <mrow>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>k</mi>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </munderover>
   <mfrac>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>β</mi>
       <msub>
        <mi>A</mi>
        <mi>R</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>k</mi>
    </msup>
    <mrow>
     <mi>k</mi>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>k</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <ci>β</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>R</ci>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <factorial></factorial>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{k=0}^{\infty}\frac{(\beta A_{R})^{k}}{k!}
  </annotation>
 </semantics>
</math>

</p>

<p>for matrix exponentials, where</p>
<ul>
<li>

<math display="inline" id="Centrality:2">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is walk length,</li>
<li>

<math display="inline" id="Centrality:3">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>R</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{R}
  </annotation>
 </semantics>
</math>

 is the transformed adjacency matrix, and</li>
<li>

<math display="inline" id="Centrality:4">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 is a discount parameter which ensures convergence of the sum.</li>
</ul>

<p>Bonacich's family of measures does not transform the adjacency matrix. The <a href="alpha_centrality" title="wikilink">alpha centrality</a> replaces the adjacency matrix with its resolvent. The subgraph centrality replaces the adjacency matrix with its trace. A startling conclusion is that regardless of the initial transformation of the adjacency matrix, all such approaches have common limiting behavior. As 

<math display="inline" id="Centrality:5">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 approaches zero, the indices converge to the <a href="Centrality#Degree_centrality" title="wikilink">degree</a> centrality. As 

<math display="inline" id="Centrality:6">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 approaches its maximal value, the indices converge to the <a href="Centrality#Eigenvector_centrality" title="wikilink">eigenvalue</a> centrality.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h2 id="important-limitations">Important limitations</h2>

<p>Centrality indices have two important limitations, one obvious and the other subtle. The obvious limitation is that a centrality which is optimal for one application is often sub-optimal for a different application. Indeed, if this were not so, we would not need so many different centralities.</p>

<p>The more subtle limitation is the commonly held fallacy that vertex centrality indicates the relative importance of vertices. Centrality indices are explicitly designed to produce a ranking which allows indication of the most important vertices. <a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> This they do well, under the limitation just noted. The error is two-fold. Firstly, a ranking only orders vertices by importance, it does not quantify the difference in importance between different levels of the ranking. This may be slightly mitigated by applying <a href="Centrality#Freeman_Centralization" title="wikilink">Freeman centralization</a> to the centrality measure in question, which provide some insight to the importance of nodes depending on the differences of their centralization scores. This approach, however, is seldom seen in practice. Secondly, the features which (correctly) identify the most important vertices in a given network/application do not necessarily generalize to the remaining vertices. For the majority of other network nodes the rankings may be meaningless. This explains why, for example, only the first few results of a Google image search appear in a reasonable order.</p>

<p>While the failure of centrality indices to generalize to the rest of the network may at first seem counter-intuitive, it follows directly from the above definitions. Complex networks have heterogeneous topology. To the extent that the optimal measure depends on the network structure of the most important vertices, a measure which is optimal for such vertices is sub-optimal for the remainder of the network. <a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h2 id="degree-centrality">Degree centrality</h2>

<p>Historically first and conceptually simplest is <strong>degree centrality</strong>, which is defined as the number of links incident upon a node (i.e., the number of ties that a node has). The degree can be interpreted in terms of the immediate risk of a node for catching whatever is flowing through the network (such as a virus, or some information). In the case of a directed network (where ties have direction), we usually define two separate measures of degree centrality, namely <a class="uri" href="indegree" title="wikilink">indegree</a> and <a class="uri" href="outdegree" title="wikilink">outdegree</a>. Accordingly, indegree is a count of the number of ties directed to the node and outdegree is the number of ties that the node directs to others. When ties are associated to some positive aspects such as friendship or collaboration, indegree is often interpreted as a form of popularity, and outdegree as gregariousness.</p>

<p>The degree centrality of a vertex 

<math display="inline" id="Centrality:7">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

, for a given graph 

<math display="inline" id="Centrality:8">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>:=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G:=(V,E)
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Centrality:9">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>V</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |V|
  </annotation>
 </semantics>
</math>

 vertices and 

<math display="inline" id="Centrality:10">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>E</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |E|
  </annotation>
 </semantics>
</math>

 edges, is defined as</p>

<p>

<math display="block" id="Centrality:11">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>C</mi>
     <mi>D</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>deg</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>D</ci>
     </apply>
     <ci>v</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">degree</csymbol>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{D}(v)=\deg(v)
  </annotation>
 </semantics>
</math>

</p>

<p>Calculating degree centrality for all the nodes in a graph takes <a href="big_theta" title="wikilink">

<math display="inline" id="Centrality:12">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>V</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(V^{2})
  </annotation>
 </semantics>
</math>

</a> in a <a href="dense_matrix" title="wikilink">dense</a> <a href="adjacency_matrix" title="wikilink">adjacency matrix</a> representation of the graph, and for edges takes 

<math display="inline" id="Centrality:13">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(E)
  </annotation>
 </semantics>
</math>

 in a <a href="sparse_matrix" title="wikilink">sparse matrix</a> representation.</p>

<p>The definition of centrality on the node level can be extended to the whole graph, in which case we are speaking of <em>graph centralization</em>.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> Let 

<math display="inline" id="Centrality:14">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>*</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">v</csymbol>
    <times></times>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v*
  </annotation>
 </semantics>
</math>

 be the node with highest degree centrality in 

<math display="inline" id="Centrality:15">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Centrality:16">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>:=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>X</ci>
    <interval closure="open">
     <ci>Y</ci>
     <ci>Z</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X:=(Y,Z)
  </annotation>
 </semantics>
</math>

 be the 

<math display="inline" id="Centrality:17">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>Y</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |Y|
  </annotation>
 </semantics>
</math>

 node connected graph that maximizes the following quantity (with 

<math display="inline" id="Centrality:18">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>*</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <times></times>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y*
  </annotation>
 </semantics>
</math>

 being the node with highest degree centrality in 

<math display="inline" id="Centrality:19">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

):</p>

<p>

<math display="block" id="Centrality:20">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>j</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>Y</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </munderover>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>C</mi>
     <mi>D</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>*</mo>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>-</mo>
    <msub>
     <mi>C</mi>
     <mi>D</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>y</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">H</csymbol>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <sum></sum>
      <apply>
       <abs></abs>
       <ci>Y</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <ci>j</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>D</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <times></times>
      <ci>normal-)</ci>
     </cerror>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>D</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>j</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=\sum^{|Y|}_{j=1}[C_{D}(y*)-C_{D}(y_{j})]
  </annotation>
 </semantics>
</math>

</p>

<p>Correspondingly, the degree centralization of the graph 

<math display="inline" id="Centrality:21">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is as follows:</p>

<p>

<math display="block" id="Centrality:22">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>C</mi>
     <mi>D</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mstyle displaystyle="true">
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>V</mi>
        <mo stretchy="false">|</mo>
       </mrow>
      </munderover>
     </mstyle>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>C</mi>
       <mi>D</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo>*</mo>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>-</mo>
      <msub>
       <mi>C</mi>
       <mi>D</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>v</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mi>H</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>D</ci>
     </apply>
     <ci>G</ci>
    </apply>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <sum></sum>
        <apply>
         <abs></abs>
         <ci>V</ci>
        </apply>
       </apply>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>D</ci>
       </apply>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">v</csymbol>
        <times></times>
        <ci>normal-)</ci>
       </cerror>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>D</ci>
       </apply>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <ci>i</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-]</ci>
      </cerror>
     </cerror>
     <ci>H</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{D}(G)=\frac{\displaystyle{\sum^{|V|}_{i=1}{[C_{D}(v*)-C_{D}(v_{i})]}}}{H}
  </annotation>
 </semantics>
</math>

</p>

<p>The value of 

<math display="inline" id="Centrality:23">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 is maximized when the graph 

<math display="inline" id="Centrality:24">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 contains one central node to which all other nodes are connected (a <a href="star_graph" title="wikilink">star graph</a>), and in this case 

<math display="inline" id="Centrality:25">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=(n-1)(n-2)
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="closeness-centrality">Closeness centrality</h2>

<p>In connected <a href="graph_(mathematics)" title="wikilink">graphs</a> there is a natural distance metric between all pairs of nodes, defined by the length of their <a href="shortest_path_problem" title="wikilink">shortest paths</a>. The <strong>farness</strong> of a node <em>x</em> is defined as the sum of its distances from all other nodes, and its closeness was defined by Bavelas as the <a href="Multiplicative_inverse" title="wikilink">reciprocal</a> of the farness,<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a><a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> that is:</p>

<p>

<math display="block" id="Centrality:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mi>y</mi>
      </msub>
      <mrow>
       <mi>d</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo>,</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>y</ci>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <interval closure="open">
        <ci>y</ci>
        <ci>x</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(x)=\frac{1}{\sum_{y}d(y,x)}.
  </annotation>
 </semantics>
</math>

</p>

<p>Thus, the more central a node is the lower its total distance from all other nodes. Note that taking distances <em>from</em> or <em>to</em> all other nodes is irrelevant in undirected graphs, whereas in directed graphs distances <em>to</em> a node are considered a more meaningful measure of centrality, as in general (e.g., in, the web) a node has little control over its incoming links.</p>

<p>When a graph is not <a href="Strongly_connected_component" title="wikilink">strongly connected</a>, a widespread idea is that of using the sum of reciprocal of distances, instead of the reciprocal of the sum of distances, with the convention 

<math display="inline" id="Centrality:27">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <infinity></infinity>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/\infty=0
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Centrality:28">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>H</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>y</mi>
       <mo>≠</mo>
       <mi>x</mi>
      </mrow>
     </munder>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mi>d</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo>,</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <neq></neq>
       <ci>y</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>d</ci>
       <interval closure="open">
        <ci>y</ci>
        <ci>x</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(x)=\sum_{y\neq x}\frac{1}{d(y,x)}.
  </annotation>
 </semantics>
</math>

</p>

<p>This idea was explicitly stated for undirected graphs under the name <strong>harmonic centrality</strong> by Rochat (2009)<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> and proposed once again later by Opsahl (2010).<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> It was later studied in full generality for directed networks by Boldi and Vigna (2014).<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>

<p>Note that harmonic centrality is a most natural modification of Bavelas's definition of closeness following the general principle proposed by <a href="Massimo_Marchiori" title="wikilink">Marchiori</a> and <a href="Vito_Latora" title="wikilink">Latora</a> (2000)<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> that in graphs with infinite distances the harmonic mean behaves better than the arithmetic mean. Indeed, Bavelas's closeness can be described as the denormalized reciprocal of the <strong><a href="arithmetic_mean" title="wikilink">arithmetic mean</a></strong> of distances, whereas harmonic centrality is the denormalized reciprocal of the <strong><a href="harmonic_mean" title="wikilink">harmonic mean</a></strong> of distances.</p>

<p>Dangalchev (2006),<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> in a work on network vulnerability proposes for undirected graphs a different definition:</p>

<p>

<math display="block" id="Centrality:29">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>y</mi>
       <mo>≠</mo>
       <mi>x</mi>
      </mrow>
     </munder>
     <mfrac>
      <mn>1</mn>
      <msup>
       <mn>2</mn>
       <mrow>
        <mi>d</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>y</mi>
         <mo>,</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </msup>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <neq></neq>
       <ci>y</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <times></times>
        <ci>d</ci>
        <interval closure="open">
         <ci>y</ci>
         <ci>x</ci>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(x)=\sum_{y\neq x}\frac{1}{2^{d(y,x)}}.
  </annotation>
 </semantics>
</math>

</p>

<p>Note that the original definition<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> uses 

<math display="inline" id="Centrality:30">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(x,y)
  </annotation>
 </semantics>
</math>

.</p>

<p>The <em>information centrality</em> of Stephenson and Zelen (1989) is another closeness measure, which computes the <a href="harmonic_mean" title="wikilink">harmonic mean</a> of the resistance distances towards a vertex <em>x</em>, which is smaller if <em>x</em> has many paths of small resistance connecting it to other vertices.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p>

<p>In the classic definition of the closeness centrality, the spread of information is modeled by the use of shortest paths. This model might not be the most realistic for all types of communication scenarios. Thus, related definitions have been discussed to measure closeness, like the <a href="random_walk_closeness_centrality" title="wikilink">random walk closeness centrality</a> introduced by Noh and Rieger (2004). It measures the speed with which randomly walking messages reach a vertex from elsewhere in the graph—a sort of random-walk version of closeness centrality.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> <a href="Hierarchical_closeness" title="wikilink">Hierarchical closeness</a> of Tran and Kwon (2014)<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> is an extended closeness centrality to deal still in another way with the limitation of closeness in graphs that are not strongly connected. The hierarchical closeness explicitly includes information about the range of other nodes that can be affected by the given node.</p>
<h2 id="betweenness-centrality">Betweenness centrality</h2>
<figure><b>(Figure)</b>
<figcaption>Hue (from red = 0 to blue = max) shows the node betweenness.</figcaption>
</figure>

<p><strong>Betweenness</strong> is a centrality measure of a <a href="vertex_(graph_theory)" title="wikilink">vertex</a> within a <a href="graph_(mathematics)" title="wikilink">graph</a> (there is also <a href="edge_(graph_theory)" title="wikilink">edge</a> betweenness, which is not discussed here). Betweenness centrality quantifies the number of times a node acts as a bridge along the shortest path between two other nodes. It was introduced as a measure for quantifying the control of a human on the communication between other humans in a social network by <a href="Linton_Freeman" title="wikilink">Linton Freeman</a><a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> In his conception, vertices that have a high probability to occur on a randomly chosen <a href="shortest_path_problem" title="wikilink">shortest path</a> between two randomly chosen vertices have a high betweenness.</p>

<p>The betweenness of a vertex 

<math display="inline" id="Centrality:31">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 in a graph 

<math display="inline" id="Centrality:32">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>:=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G:=(V,E)
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Centrality:33">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 vertices is computed as follows:</p>
<ol>
<li>For each pair of vertices (<em>s</em>,<em>t</em>), compute the <a href="Shortest_path_problem" title="wikilink">shortest paths</a> between them.</li>
<li>For each pair of vertices (<em>s</em>,<em>t</em>), determine the fraction of shortest paths that pass through the vertex in question (here, vertex <em>v</em>).</li>
<li>Sum this fraction over all pairs of vertices (<em>s</em>,<em>t</em>).</li>
</ol>

<p>More compactly the betweenness can be represented as:<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></p>

<p>

<math display="block" id="Centrality:34">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>C</mi>
     <mi>B</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>s</mi>
      <mo>≠</mo>
      <mi>v</mi>
      <mo>≠</mo>
      <mi>t</mi>
      <mo>∈</mo>
      <mi>V</mi>
     </mrow>
    </munder>
    <mfrac>
     <mrow>
      <msub>
       <mi>σ</mi>
       <mrow>
        <mi>s</mi>
        <mi>t</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <msub>
      <mi>σ</mi>
      <mrow>
       <mi>s</mi>
       <mi>t</mi>
      </mrow>
     </msub>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>B</ci>
     </apply>
     <ci>v</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <and></and>
       <apply>
        <neq></neq>
        <ci>s</ci>
        <ci>v</ci>
       </apply>
       <apply>
        <neq></neq>
        <share href="#.cmml">
        </share>
        <ci>t</ci>
       </apply>
       <apply>
        <in></in>
        <share href="#.cmml">
        </share>
        <ci>V</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <apply>
         <times></times>
         <ci>s</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <ci>v</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <apply>
        <times></times>
        <ci>s</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{B}(v)=\sum_{s\neq v\neq t\in V}\frac{\sigma_{st}(v)}{\sigma_{st}}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Centrality:35">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mrow>
    <mi>s</mi>
    <mi>t</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{st}
  </annotation>
 </semantics>
</math>

 is total number of shortest paths from node 

<math display="inline" id="Centrality:36">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 to node 

<math display="inline" id="Centrality:37">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Centrality:38">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mrow>
     <mi>s</mi>
     <mi>t</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{st}(v)
  </annotation>
 </semantics>
</math>

 is the number of those paths that pass through 

<math display="inline" id="Centrality:39">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

. The betweenness may be normalised by dividing through the number of pairs of vertices not including <em>v</em>, which for <a href="Digraph_(mathematics)" title="wikilink">directed graphs</a> is 

<math display="inline" id="Centrality:40">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>2</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n-1)(n-2)
  </annotation>
 </semantics>
</math>

 and for undirected graphs is 

<math display="inline" id="Centrality:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n-1)(n-2)/2
  </annotation>
 </semantics>
</math>

. For example, in an undirected <a href="Star_(graph_theory)" title="wikilink">star graph</a>, the center vertex (which is contained in every possible shortest path) would have a betweenness of 

<math display="inline" id="Centrality:42">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n-1)(n-2)/2
  </annotation>
 </semantics>
</math>

 (1, if normalised) while the leaves (which are contained in no shortest paths) would have a betweenness of 0.</p>

<p>From a calculation aspect, both betweenness and closeness centralities of all vertices in a graph involve calculating the shortest paths between all pairs of vertices on a graph, which requires <a href="big_theta" title="wikilink">

<math display="inline" id="Centrality:43">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>V</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(V^{3})
  </annotation>
 </semantics>
</math>

</a> time with the <a href="Floyd–Warshall_algorithm" title="wikilink">Floyd–Warshall algorithm</a>. However, on sparse graphs, <a href="Johnson's_algorithm" title="wikilink">Johnson's algorithm</a> may be more efficient, taking <a href="Big_O_notation" title="wikilink">

<math display="inline" id="Centrality:44">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>V</mi>
       <mn>2</mn>
      </msup>
      <mrow>
       <mi>log</mi>
       <mi>V</mi>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>V</mi>
      <mi>E</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>V</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <log></log>
       <ci>V</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>E</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(V^{2}\log V+VE)
  </annotation>
 </semantics>
</math>

</a> time. In the case of unweighted graphs the calculations can be done with Brandes' algorithm<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> which takes <a href="Big_O_notation" title="wikilink">

<math display="inline" id="Centrality:45">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>V</mi>
     <mi>E</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(VE)
  </annotation>
 </semantics>
</math>

</a> time. Normally, these algorithms assume that graphs are undirected and connected with the allowance of loops and multiple edges. When specifically dealing with network graphs, often graphs are without loops or multiple edges to maintain simple relationships (where edges represent connections between two people or vertices). In this case, using Brandes' algorithm will divide final centrality scores by 2 to account for each shortest path being counted twice.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></p>
<h2 id="eigenvector-centrality">Eigenvector centrality</h2>

<p><strong>Eigenvector centrality</strong> is a measure of the influence of a <a href="node_(networking)" title="wikilink">node</a> in a <a href="network_(mathematics)" title="wikilink">network</a>. It assigns relative scores to all nodes in the network based on the concept that connections to high-scoring nodes contribute more to the score of the node in question than equal connections to low-scoring nodes. <a class="uri" href="Google" title="wikilink">Google</a>'s <a class="uri" href="PageRank" title="wikilink">PageRank</a> is a variant of the eigenvector centrality measure.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> Another closely related centrality measure is <a href="Katz_centrality" title="wikilink">Katz centrality</a>.</p>
<h3 id="using-the-adjacency-matrix-to-find-eigenvector-centrality">Using the adjacency matrix to find eigenvector centrality</h3>

<p>For a given graph 

<math display="inline" id="Centrality:46">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>:=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G:=(V,E)
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Centrality:47">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>V</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |V|
  </annotation>
 </semantics>
</math>

 number of vertices let 

<math display="inline" id="Centrality:48">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>v</mi>
      <mo>,</mo>
      <mi>t</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <list>
      <ci>v</ci>
      <ci>t</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=(a_{v,t})
  </annotation>
 </semantics>
</math>

 be the <a href="adjacency_matrix" title="wikilink">adjacency matrix</a>, i.e. 

<math display="inline" id="Centrality:49">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>v</mi>
     <mo>,</mo>
     <mi>t</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <list>
      <ci>v</ci>
      <ci>t</ci>
     </list>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{v,t}=1
  </annotation>
 </semantics>
</math>

 if vertex 

<math display="inline" id="Centrality:50">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 is linked to vertex 

<math display="inline" id="Centrality:51">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Centrality:52">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>v</mi>
     <mo>,</mo>
     <mi>t</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <list>
      <ci>v</ci>
      <ci>t</ci>
     </list>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{v,t}=0
  </annotation>
 </semantics>
</math>

 otherwise. The centrality score of vertex 

<math display="inline" id="Centrality:53">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 can be defined as:</p>

<p>

<math display="block" id="Centrality:54">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>v</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>λ</mi>
    </mfrac>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>t</mi>
       <mo>∈</mo>
       <mrow>
        <mi>M</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>v</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </munder>
     <msub>
      <mi>x</mi>
      <mi>t</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>λ</mi>
    </mfrac>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>t</mi>
       <mo>∈</mo>
       <mi>G</mi>
      </mrow>
     </munder>
     <mrow>
      <msub>
       <mi>a</mi>
       <mrow>
        <mi>v</mi>
        <mo>,</mo>
        <mi>t</mi>
       </mrow>
      </msub>
      <msub>
       <mi>x</mi>
       <mi>t</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>v</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>λ</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <in></in>
         <ci>t</ci>
         <apply>
          <times></times>
          <ci>M</ci>
          <ci>v</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>λ</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <in></in>
         <ci>t</ci>
         <ci>G</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <list>
          <ci>v</ci>
          <ci>t</ci>
         </list>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{v}=\frac{1}{\lambda}\sum_{t\in M(v)}x_{t}=\frac{1}{\lambda}\sum_{t\in G}a_{%
v,t}x_{t}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Centrality:55">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M(v)
  </annotation>
 </semantics>
</math>

 is a set of the neighbors of 

<math display="inline" id="Centrality:56">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Centrality:57">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 is a constant. With a small rearrangement this can be rewritten in vector notation as the <a class="uri" href="eigenvector" title="wikilink">eigenvector</a> equation</p>

<p>

<math display="block" id="Centrality:58">
 <semantics>
  <mrow>
   <mi>𝐀𝐱</mi>
   <mo>=</mo>
   <mrow>
    <mi>λ</mi>
    <mi>𝐱</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐀𝐱</ci>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>𝐱</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Ax}={\lambda}\mathbf{x}
  </annotation>
 </semantics>
</math>

</p>

<p>In general, there will be many different <a href="eigenvalue" title="wikilink">eigenvalues</a> 

<math display="inline" id="Centrality:59">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 for which an eigenvector solution exists. However, the additional requirement that all the entries in the eigenvector be positive implies (by the <a href="Perron–Frobenius_theorem" title="wikilink">Perron–Frobenius theorem</a>) that only the greatest eigenvalue results in the desired centrality measure.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> The 

<math display="inline" id="Centrality:60">
 <semantics>
  <msup>
   <mi>v</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>v</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v^{th}
  </annotation>
 </semantics>
</math>

 component of the related eigenvector then gives the centrality score of the vertex 

<math display="inline" id="Centrality:61">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 in the network. <a href="Power_iteration" title="wikilink">Power iteration</a> is one of many <a href="eigenvalue_algorithm" title="wikilink">eigenvalue algorithms</a> that may be used to find this dominant eigenvector.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> Furthermore, this can be generalized so that the entries in <em>A</em> can be real numbers representing connection strengths, as in a <a href="stochastic_matrix" title="wikilink">stochastic matrix</a>.</p>
<h2 id="katz-centrality-and-pagerank">Katz centrality and PageRank</h2>

<p><a href="Katz_centrality" title="wikilink">Katz centrality</a><a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> is a generalization of degree centrality. Degree centrality measures the number of direct neighbors, and Katz centrality measures the number of all nodes that can be connected through a path, while the contributions of distant nodes are penalized. Mathematically, it is defined as 

<math display="inline" id="Centrality:62">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\infin</mtext>
     </merror>
    </msubsup>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </msubsup>
     <mrow>
      <msup>
       <mi>α</mi>
       <mi>k</mi>
      </msup>
      <msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>A</mi>
         <mi>k</mi>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mi>j</mi>
        <mi>i</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <mtext>\infin</mtext>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>α</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>A</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <times></times>
         <ci>j</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}=\sum_{k=1}^{\infin}\sum_{j=1}^{N}\alpha^{k}(A^{k})_{ji}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Centrality:63">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is an attenuation factor in 

<math display="inline" id="Centrality:64">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (0,1)
  </annotation>
 </semantics>
</math>

.</p>

<p>Katz centrality can be viewed as a variant of eigenvector centrality. Another form of Katz centrality is 

<math display="inline" id="Centrality:65">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>α</mi>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>N</mi>
      </msubsup>
      <mrow>
       <msub>
        <mi>a</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>x</mi>
          <mi>j</mi>
         </msub>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>α</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>j</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}=\alpha\sum_{j=1}^{N}a_{ij}(x_{j}+1).
  </annotation>
 </semantics>
</math>

 Compared to the expression of eigenvector centrality, 

<math display="inline" id="Centrality:66">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}
  </annotation>
 </semantics>
</math>

 is replaced by 

<math display="inline" id="Centrality:67">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>j</mi>
   </msub>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>j</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}+1
  </annotation>
 </semantics>
</math>

.</p>

<p>It is shown that<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> the principal eigenvector (associated with the largest eigenvalue of 

<math display="inline" id="Centrality:68">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, the adjacency matrix) is the limit of Katz centrality as 

<math display="inline" id="Centrality:69">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 approaches 

<math display="inline" id="Centrality:70">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mi>λ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/\lambda
  </annotation>
 </semantics>
</math>

 from below.</p>

<p><a class="uri" href="PageRank" title="wikilink">PageRank</a> satisfies the following equation 

<math display="inline" id="Centrality:71">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>α</mi>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∑</mo>
        <mi>j</mi>
       </msub>
       <mrow>
        <msub>
         <mi>a</mi>
         <mrow>
          <mi>j</mi>
          <mi>i</mi>
         </mrow>
        </msub>
        <mfrac>
         <msub>
          <mi>x</mi>
          <mi>j</mi>
         </msub>
         <mrow>
          <mi>L</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>j</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mfrac>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mfrac>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>α</mi>
      </mrow>
      <mi>N</mi>
     </mfrac>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>α</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>j</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <apply>
          <times></times>
          <ci>j</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>j</ci>
         </apply>
         <apply>
          <times></times>
          <ci>L</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>α</ci>
      </apply>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}=\alpha\sum_{j}a_{ji}\frac{x_{j}}{L(j)}+\frac{1-\alpha}{N},
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Centrality:72">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>j</mi>
    </msub>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(j)=\sum_{j}a_{ij}
  </annotation>
 </semantics>
</math>

 is the number of neighbors of node 

<math display="inline" id="Centrality:73">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 (or number of outbound links in a directed graph). Compared to eigenvector centrality and Katz centrality, one major difference is the scaling factor 

<math display="inline" id="Centrality:74">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(j)
  </annotation>
 </semantics>
</math>

. Another difference between PageRank and eigenvector centrality is that the PageRank vector is a left hand eigenvector (note the factor 

<math display="inline" id="Centrality:75">
 <semantics>
  <msub>
   <mi>a</mi>
   <mrow>
    <mi>j</mi>
    <mi>i</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <apply>
     <times></times>
     <ci>j</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{ji}
  </annotation>
 </semantics>
</math>

 has indices reversed).<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a></p>
<h2 id="percolation-centrality">Percolation centrality</h2>

<p>A slew of centrality measures exist to determine the ‘importance’ of a single node in a complex network. However, these measures quantify the importance of a node in purely topological terms, and the value of the node does not depend on the ‘state’ of the node in any way. It remains constant regardless of network dynamics. This is true even for the weighted betweenness measures. However, a node may very well be centrally located in terms of betweenness centrality or another centrality measure, but may not be ‘centrally’ located in the context of a network in which there is percolation. Percolation of a ‘contagion’ occurs in complex networks in a number of scenarios. For example, viral or bacterial infection can spread over social networks of people, known as contact networks. The spread of disease can also be considered at a higher level of abstraction, by contemplating a network of towns or population centres, connected by road, rail or air links. Computer viruses can spread over computer networks. Rumours or news about business offers and deals can also spread via social networks of people. In all of these scenarios, a ‘contagion’ spreads over the links of a complex network, altering the ‘states’ of the nodes as it spreads, either recoverably or otherwise. For example, in an epidemiological scenario, individuals go from ‘susceptible’ to ‘infected’ state as the infection spreads. The states the individual nodes can take in the above examples could be binary (such as received/not received a piece of news), discrete (susceptible/infected/recovered), or even continuous (such as the proportion of infected people in a town), as the contagion spreads. The common feature in all these scenarios is that the spread of contagion results in the change of node states in networks. Percolation centrality (PC) was proposed with this in mind, which specifically measures the importance of nodes in terms of aiding the percolation through the network. This measure was proposed by Piraveenan et al.<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a></p>

<p>The Percolation Centrality is defined for a given node, at a given time, as the proportion of ‘percolated paths’ that go through that node. A ‘percolated path’ is a shortest path between a pair of nodes, where the source node is percolated (e.g., infected). The target node can be percolated or non-percolated, or in a partially percolated state.</p>

<p>

<math display="block" id="Centrality:76">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <msup>
     <mi>C</mi>
     <mi>t</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
    </mfrac>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>s</mi>
       <mo>≠</mo>
       <mi>v</mi>
       <mo>≠</mo>
       <mi>r</mi>
      </mrow>
     </munder>
     <mrow>
      <mfrac>
       <mrow>
        <msub>
         <mi>σ</mi>
         <mrow>
          <mi>s</mi>
          <mi>r</mi>
         </mrow>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>v</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <msub>
        <mi>σ</mi>
        <mrow>
         <mi>s</mi>
         <mi>r</mi>
        </mrow>
       </msub>
      </mfrac>
      <mfrac>
       <mmultiscripts>
        <mi>x</mi>
        <none></none>
        <mi>t</mi>
        <mi>s</mi>
        <none></none>
       </mmultiscripts>
       <mrow>
        <mrow>
         <mo largeop="true" symmetric="true">∑</mo>
         <mrow>
          <mo stretchy="false">[</mo>
          <mmultiscripts>
           <mi>x</mi>
           <none></none>
           <mi>t</mi>
           <mi>i</mi>
           <none></none>
          </mmultiscripts>
          <mo stretchy="false">]</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mmultiscripts>
         <mi>x</mi>
         <none></none>
         <mi>t</mi>
         <mi>v</mi>
         <none></none>
        </mmultiscripts>
       </mrow>
      </mfrac>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>C</ci>
      <ci>t</ci>
     </apply>
     <ci>v</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <and></and>
        <apply>
         <neq></neq>
         <ci>s</ci>
         <ci>v</ci>
        </apply>
        <apply>
         <neq></neq>
         <share href="#.cmml">
         </share>
         <ci>r</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>σ</ci>
          <apply>
           <times></times>
           <ci>s</ci>
           <ci>r</ci>
          </apply>
         </apply>
         <ci>v</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>σ</ci>
         <apply>
          <times></times>
          <ci>s</ci>
          <ci>r</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <ci>t</ci>
         </apply>
         <ci>s</ci>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <sum></sum>
          <apply>
           <csymbol cd="latexml">delimited-[]</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>x</ci>
             <ci>t</ci>
            </apply>
            <ci>i</ci>
           </apply>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>x</ci>
           <ci>t</ci>
          </apply>
          <ci>v</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   PC^{t}(v)=\frac{1}{N-2}\sum_{s\neq v\neq r}\frac{\sigma_{sr}(v)}{\sigma_{sr}}%
\frac{{x^{t}}_{s}}{{\sum{[{x^{t}}_{i}}]}-{x^{t}}_{v}}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Centrality:77">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mrow>
    <mi>s</mi>
    <mi>r</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{sr}
  </annotation>
 </semantics>
</math>

 is total number of shortest paths from node 

<math display="inline" id="Centrality:78">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 to node 

<math display="inline" id="Centrality:79">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Centrality:80">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mrow>
     <mi>s</mi>
     <mi>r</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>r</ci>
     </apply>
    </apply>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{sr}(v)
  </annotation>
 </semantics>
</math>

 is the number of those paths that pass through 

<math display="inline" id="Centrality:81">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

. The percolation state of the node 

<math display="inline" id="Centrality:82">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 at time 

<math display="inline" id="Centrality:83">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 is denoted by 

<math display="inline" id="Centrality:84">
 <semantics>
  <mmultiscripts>
   <mi>x</mi>
   <none></none>
   <mi>t</mi>
   <mi>i</mi>
   <none></none>
  </mmultiscripts>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>t</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x^{t}}_{i}
  </annotation>
 </semantics>
</math>

 and two special cases are when 

<math display="inline" id="Centrality:85">
 <semantics>
  <mrow>
   <mmultiscripts>
    <mi>x</mi>
    <none></none>
    <mi>t</mi>
    <mi>i</mi>
    <none></none>
   </mmultiscripts>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x^{t}}_{i}=0
  </annotation>
 </semantics>
</math>

 which indicates a non-percolated state at time 

<math display="inline" id="Centrality:86">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 whereas when 

<math display="inline" id="Centrality:87">
 <semantics>
  <mrow>
   <mmultiscripts>
    <mi>x</mi>
    <none></none>
    <mi>t</mi>
    <mi>i</mi>
    <none></none>
   </mmultiscripts>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x^{t}}_{i}=1
  </annotation>
 </semantics>
</math>

 which indicates a fully percolated state at time 

<math display="inline" id="Centrality:88">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

. The values in between indicate partially percolated states ( e.g., in a network of townships, this would be the percentage of people infected in that town).</p>

<p>The attached weights to the percolation paths depend on the percolation levels assigned to the source nodes, based on the premise that the higher the percolation level of a source node is, the more important are the paths that originate from that node. Nodes which lie on shortest paths originating from highly percolated nodes are therefore potentially more important to the percolation. The definition of PC may also be extended to include target node weights as well. Percolation centrality calculations run in <a href="Big_O_notation" title="wikilink">

<math display="inline" id="Centrality:89">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mi>M</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(NM)
  </annotation>
 </semantics>
</math>

</a> time with an efficient implementation adopted from Brandes' fast algorithm and if the calculation needs to consider target nodes weights, the worst case time is <a href="Big_O_notation" title="wikilink">

<math display="inline" id="Centrality:90">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>N</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>N</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(N^{3})
  </annotation>
 </semantics>
</math>

</a>.</p>
<h2 id="cross-clique-centrality">Cross-clique centrality</h2>

<p><strong>Cross-clique</strong> centrality of a single node, in a complex graph determines the connectivity of a node to different <a href="clique_(graph_theory)" title="wikilink">cliques</a>. A node with high cross-clique connectivity facilitates the propagation of information or disease in a graph. Cliques are subgraphs in which every node is connected to every other node in the clique. The cross-clique connectivity of a node 

<math display="inline" id="Centrality:91">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 for a given graph 

<math display="inline" id="Centrality:92">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>:=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G:=(V,E)
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Centrality:93">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>V</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |V|
  </annotation>
 </semantics>
</math>

 vertices and 

<math display="inline" id="Centrality:94">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>E</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |E|
  </annotation>
 </semantics>
</math>

 edges, is defined as 

<math display="inline" id="Centrality:95">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(v)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Centrality:96">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(v)
  </annotation>
 </semantics>
</math>

 is the number of cliques to which vertex 

<math display="inline" id="Centrality:97">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 belongs. This measure was used in <a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> but was first proposed by Everett and Borgatti in 1998 where they called it clique-overlap centrality.</p>
<h2 id="freeman-centralization">Freeman Centralization</h2>

<p>The <em>centralization</em> of any network is a measure of how central its most central node is in relation to how central all the other nodes are.<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> Centralization measures then (a) calculate the sum in differences in centrality between the most central node in a network and all other nodes; and (b) divide this quantity by the theoretically largest such sum of differences in any network of the same size.<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a> Thus, every centrality measure can have its own centralization measure. Defined formally, if 

<math display="inline" id="Centrality:98">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>x</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>p</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{x}(p_{i})
  </annotation>
 </semantics>
</math>

 is any centrality measure of point 

<math display="inline" id="Centrality:99">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, if 

<math display="inline" id="Centrality:100">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>x</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>p</mi>
     <mo>*</mo>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{x}(p_{*})
  </annotation>
 </semantics>
</math>

 is the largest such measure in the network, and if 

<math display="inline" id="Centrality:101">
 <semantics>
  <mrow>
   <mrow>
    <mi>max</mi>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>C</mi>
       <mi>x</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>p</mi>
        <mo>*</mo>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mrow>
    <msub>
     <mi>C</mi>
     <mi>x</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>p</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <max></max>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <times></times>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max\sum_{i=1}^{N}C_{x}(p_{*})-C_{x}(p_{i})
  </annotation>
 </semantics>
</math>

 is the largest sum of differences in point centrality 

<math display="inline" id="Centrality:102">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{x}
  </annotation>
 </semantics>
</math>

 for any graph with the same number of nodes, then the centralization of the network is:<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a> 

<math display="inline" id="Centrality:103">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>x</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mstyle displaystyle="false">
       <msubsup>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>N</mi>
       </msubsup>
      </mstyle>
      <mrow>
       <msub>
        <mi>C</mi>
        <mi>x</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>p</mi>
         <mo>*</mo>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>C</mi>
       <mi>x</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>p</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mi>max</mi>
      <mrow>
       <mstyle displaystyle="false">
        <msubsup>
         <mo largeop="true" symmetric="true">∑</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>N</mi>
        </msubsup>
       </mstyle>
       <mrow>
        <msub>
         <mi>C</mi>
         <mi>x</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>p</mi>
          <mo>*</mo>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>C</mi>
       <mi>x</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>p</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>N</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <ci>x</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <times></times>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <max></max>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>N</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>C</ci>
          <ci>x</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <times></times>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{x}=\frac{\sum_{i=1}^{N}C_{x}(p_{*})-C_{x}(p_{i})}{\max\sum_{i=1}^{N}C_{x}(p%
_{*})-C_{x}(p_{i})}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="extensions">Extensions</h2>

<p>Empirical and theoretical research have extended the concept of centrality in the context of static networks to dynamic centrality<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a> in the context of time-dependent and temporal networks.<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a><a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a><a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a></p>

<p>For generalizations to weighted networks, see Opsahl et al. (2010).<a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a></p>

<p>The concept of centrality was extended to a group level as well. For example, <strong>Group Betweenness</strong> centrality shows the proportion of geodesics connecting pairs of non-group members that pass through the group.<a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a><a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Alpha_centrality" title="wikilink">Alpha centrality</a></li>
<li><a href="distance_(graph_theory)" title="wikilink">Distance in graphs</a></li>
</ul>
<h2 id="notes-and-references">Notes and references</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Koschützki, D.; Lehmann, K. A.; Peeters, L.; Richter, S.; Tenfelde-Podehl, D. and Zlotowski, O. (2005) Centrality Indices. In Brandes, U. and Erlebach, T. (Eds.) <em>Network Analysis: Methodological Foundations</em>, pp. 16–61, LNCS 3418, Springer-Verlag.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a class="uri" href="https://networkx.lanl.gov/trac/attachment/ticket/119/page_rank.py">https://networkx.lanl.gov/trac/attachment/ticket/119/page_rank.py</a></li>
<li><a class="uri" href="http://www.faculty.ucr.edu/~hanneman/nettext/C10_Centrality.html">http://www.faculty.ucr.edu/~hanneman/nettext/C10_Centrality.html</a></li>
<li><a class="uri" href="http://socnetv.sourceforge.net/docs/analysis.html#CC">http://socnetv.sourceforge.net/docs/analysis.html#CC</a></li>
</ul>

<p>"</p>

<p><a href="Category:Graph_theory" title="wikilink">Category:Graph theory</a> <a href="Category:Graph_algorithms" title="wikilink">Category:Graph algorithms</a> <a href="Category:Algebraic_graph_theory" title="wikilink">Category:Algebraic graph theory</a> <a class="uri" href="Category:Networks" title="wikilink">Category:Networks</a> <a href="Category:Network_analysis" title="wikilink">Category:Network analysis</a> <a href="Category:Network_theory" title="wikilink">Category:Network theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Newman, M.E.J. 2010. <em>Networks: An Introduction.</em> Oxford, UK: Oxford University Press.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19">Freeman, Linton C. "Centrality in social networks conceptual clarification." Social networks 1.3 (1979): 215–239.<a href="#fnref19">↩</a></li>
<li id="fn20">Alex Bavelas. Communication patterns in task-oriented groups. <em>J. Acoust. Soc. Am</em>, <strong>22</strong>(6):725–730, 1950.<a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30">Tran, T.-D. and Kwon, Y.-K. Hierarchical closeness efficiently predicts disease genes in a directed signaling network, Computational biology and chemistry.<a href="#fnref30">↩</a></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33"></li>
<li id="fn34"></li>
<li id="fn35"><a class="uri" href="http://www.ams.org/samplings/feature-column/fcarc-pagerank">http://www.ams.org/samplings/feature-column/fcarc-pagerank</a><a href="#fnref35">↩</a></li>
<li id="fn36"><a href="#fnref36">↩</a></li>
<li id="fn37"></li>
<li id="fn38">Katz, L. 1953. A New Status Index Derived from Sociometric Index. Psychometrika, 39–43.<a href="#fnref38">↩</a></li>
<li id="fn39"><a href="#fnref39">↩</a></li>
<li id="fn40"><a href="http://scenic.princeton.edu/network20q/lectures/Q3_notes.pdf">How does Google rank webpages?</a> 20Q: About Networked Life<a href="#fnref40">↩</a></li>
<li id="fn41"><a href="#fnref41">↩</a></li>
<li id="fn42"><a href="#fnref42">↩</a></li>
<li id="fn43"><a href="#fnref43">↩</a></li>
<li id="fn44"></li>
<li id="fn45"></li>
<li id="fn46"><a href="#fnref46">↩</a></li>
<li id="fn47"><a href="#fnref47">↩</a></li>
<li id="fn48">Gross, T. and Sayama, H. (Eds.). 2009. <em>Adaptive Networks: Theory, Models and Applications.</em> Springer.<a href="#fnref48">↩</a></li>
<li id="fn49">Holme, P. and Saramäki, J. 2013. <em>Temporal Networks.</em> Springer.<a href="#fnref49">↩</a></li>
<li id="fn50"><a href="#fnref50">↩</a></li>
<li id="fn51">Everett, M. G. and Borgatti, S. P. (2005). Extending centrality. In P. J. Carrington, J. Scott and S. Wasserman (Eds.), <em>Models and methods in social network analysis</em> (pp. 57–76). New York: Cambridge University Press.<a href="#fnref51">↩</a></li>
<li id="fn52">Puzis, R., Yagil, D., Elovici, Y., Braha, D. (2009).<a href="http://necsi.edu/affiliates/braha/Internet_Research_Anonimity.pdf">Collaborative attack on Internet users’ anonymity</a>, <em>Internet Research</em> <strong>19</strong>(1)<a href="#fnref52">↩</a></li>
</ol>
</section>
</body>
</html>
