<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="643">List of first-order theories</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>List of first-order theories</h1>
<hr/>

<p>In <a href="mathematical_logic" title="wikilink">mathematical logic</a>, a <a href="first-order_logic" title="wikilink">first-order theory</a> is given by a set of axioms in some language. This entry lists some of the more common examples used in <a href="model_theory" title="wikilink">model theory</a> and some of their properties.</p>
<h2 id="preliminaries">Preliminaries</h2>

<p>For every natural mathematical structure there is a <a href="Signature_(logic)" title="wikilink">signature</a> σ listing the constants, functions, and relations of the theory together with their valences, so that the object is naturally a <a href="model_theory" title="wikilink">σ-structure</a>. Given a signature σ there is a unique first-order language <em>L</em><sub>σ</sub> that can be used to capture the first-order expressible facts about the σ-structure.</p>

<p>There are two common ways to specify theories:</p>
<ol>
<li>List or describe a set of sentences in the language <em>L</em><sub>σ</sub>, called the <strong>axioms</strong> of the theory.</li>
<li>Give a set of σ-structures, and define a theory to be the set of sentences in <em>L</em><sub>σ</sub> holding in all these models. For example, the "theory of finite fields" consists of all sentences in the language of fields that are true in all finite fields.</li>
</ol>

<p>An L<sub>σ</sub> theory may:</p>
<ul>
<li>be consistent: no proof of contradiction exists;</li>
<li>be satisfiable: there exists a σ-structure for which the sentences of the theory are all true (by the <a href="completeness_theorem" title="wikilink">completeness theorem</a>, satisfiability is equivalent to consistency);</li>
<li>be complete: for any statement, either it or its negation is provable;</li>
<li>have <a href="quantifier_elimination" title="wikilink">quantifier elimination</a>;</li>
<li><a href="elimination_of_imaginaries" title="wikilink">eliminate imaginaries</a>;</li>
<li>be <a href="finitely_axiomatizable" title="wikilink">finitely axiomatizable</a>;</li>
<li>be <a href="Decidability_(logic)" title="wikilink">decidable</a>: There is an algorithm to decide which statements are provable;</li>
<li>be recursively axiomatizable;</li>
<li>be <a href="Model_complete" title="wikilink">Model complete</a> or sub-model complete;</li>
<li>be <a href="Morley's_categoricity_theorem" title="wikilink">κ-categorical</a>: All models of cardinality κ are isomorphic;</li>
<li>be <a href="stable_theory" title="wikilink">Stable</a> or unstable.</li>
<li>be <a class="uri" href="ω-stable" title="wikilink">ω-stable</a> (same as <a href="totally_transcendental" title="wikilink">totally transcendental</a> for countable theories).</li>
<li>be <a class="uri" href="superstable" title="wikilink">superstable</a></li>
<li>have an <a href="atomic_model_(mathematical_logic)" title="wikilink">atomic model</a></li>
<li>have a <a href="prime_model" title="wikilink">prime model</a></li>
<li>have a <a href="saturated_model" title="wikilink">saturated model</a></li>
</ul>
<h2 id="pure-identity-theories">Pure identity theories</h2>

<p>The signature of the pure identity theory is empty, with no functions, constants, or relations.</p>

<p><strong>Pure identity theory</strong> has no (non-logical) axioms. It is decidable.</p>

<p>One of the few interesting properties that can be stated in the language of pure identity theory is that of being infinite. This is given by an infinite set of axioms stating there are at least 2 elements, there are at least 3 elements, and so on:</p>
<ul>
<li>∃<em>x</em><sub>1</sub> ∃<em>x</em><sub>2</sub> ¬<em>x</em><sub>1</sub> = <em>x</em><sub>2</sub>,    ∃<em>x</em><sub>1</sub> ∃<em>x</em><sub>2</sub> ∃<em>x</em><sub>3</sub> ¬<em>x</em><sub>1</sub> = <em>x</em><sub>2</sub> ∧ ¬<em>x</em><sub>1</sub> = <em>x</em><sub>3</sub> ∧ ¬<em>x</em><sub>2</sub> = <em>x</em><sub>3</sub>,...</li>
</ul>

<p>These axioms define the <strong>theory of an infinite set</strong>.</p>

<p>The opposite property of being finite cannot be stated in first-order logic for any theory that has arbitrarily large finite models: in fact any such theory has infinite models by the <a href="compactness_theorem" title="wikilink">compactness theorem</a>. In general if a property can be stated by a finite number of sentences of first-order logic then the opposite property can also be stated in first-order logic, but if a property needs an infinite number of sentences then its opposite property cannot be stated in first-order logic.</p>

<p>Any statement of pure identity theory is equivalent to either σ(<em>N</em>) or to ¬σ(<em>N</em>) for some finite subset <em>N</em> of the non-negative integers, where σ(<em>N</em>) is the statement that the number of elements is in <em>N</em>. It is even possible to describe all possible theories in this language as follows. Any theory is either the theory of all sets of cardinality in <em>N</em> for some <em>finite</em> subset <em>N</em> of the non-negative integers, or the theory of all sets whose cardinality is not in <em>N</em>, for some <em>finite or infinite</em> subset <em>N</em> of the non-negative integers. (There are no theories whose models are exactly sets of cardinality <em>N</em> if <em>N</em> is an infinite subset of the integers.) The complete theories are the theories of sets of cardinality <em>n</em> for some finite <em>n</em>, and the theory of infinite sets.</p>

<p>One special case of this is the <strong>inconsistent theory</strong> defined by the axiom ∃<em>x</em> ¬<em>x</em> = <em>x</em>. It is a perfectly good theory with many good properties: it is complete, decidable, finitely axiomatizable, and so on. The only problem is that it has no models at all.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> By Gödel's completeness theorem, it is the only theory (for any given language) with no models.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="unary-relations">Unary relations</h2>

<p>A set of unary relations <em>P</em><sub><em>i</em></sub> for <em>i</em> in some set <em>I</em> is called <strong>independent</strong> if for every two disjoint finite subsets <em>A</em> and <em>B</em> of <em>I</em> there is some element <em>x</em> such that <em>P</em><sub><em>i</em></sub>(<em>x</em>) is true for <em>i</em> in <em>A</em> and false for <em>i</em> in <em>B</em>. Independence can be expressed by a set of first-order statements.</p>

<p>The <strong>theory of a countable number of independent unary relations</strong> is complete, but has no <a href="atomic_model_(mathematical_logic)" title="wikilink">atomic models</a>. It is also an example of a theory that is <a class="uri" href="superstable" title="wikilink">superstable</a> but not <a href="totally_transcendental" title="wikilink">totally transcendental</a>.</p>
<h2 id="equivalence-relations">Equivalence relations</h2>

<p>The signature of <a href="equivalence_relation" title="wikilink">equivalence relations</a> has one binary infix relation symbol ~, no constants, and no functions. Equivalence relations satisfy the axioms:</p>
<ul>
<li><strong><a href="Reflexive_relation" title="wikilink">Reflexivity</a></strong> ∀<em>x</em> <em>x</em>~<em>x</em>;</li>
<li><strong><a href="Symmetric_relation" title="wikilink">Symmetry</a></strong> ∀<em>x</em> ∀<em>y</em> <em>x</em>~<em>y</em> → <em>y</em>~<em>x</em>;</li>
<li><strong><a href="Transitive_relation" title="wikilink">Transitivity</a></strong>: ∀<em>x</em> ∀<em>y</em> ∀<em>z</em> (<em>x</em>~<em>y</em> ∧ <em>y</em>~<em>z</em>) → <em>x</em>~<em>z</em>.</li>
</ul>

<p>Some first order properties of equivalence relations are:</p>
<ul>
<li>~ has an infinite number of <a href="equivalence_classes" title="wikilink">equivalence classes</a>;</li>
<li>~ has exactly <em>n</em> equivalence classes (for any fixed positive integer <em>n</em>);</li>
<li>All equivalence classes are infinite;</li>
<li>All equivalence classes have size exactly <em>n</em> (for any fixed positive integer <em>n</em>).</li>
</ul>

<p>The theory of an equivalence relation with exactly 2 infinite <a href="equivalence_class" title="wikilink">equivalence classes</a> is an easy example of a theory which is ω-categorical but not categorical for any larger <a href="cardinal_number" title="wikilink">cardinal</a>.</p>

<p>The equivalence relation ~ should not be confused with the <a href="identity_(philosophy)" title="wikilink">identity</a> symbol '=': if <em>x</em>=<em>y</em> then <em>x</em>~<em>y</em>, but the converse is not necessarily true. Theories of equivalence relations are not all that difficult or interesting, but often give easy examples or counterexamples for various statements.</p>

<p>The following constructions are sometimes used to produce examples of theories with certain <a href="spectrum_of_a_theory" title="wikilink">spectra</a>; in fact by applying them to a small number of explicit theories <em>T</em> one gets examples of complete countable theories with all possible uncountable spectra. If <em>T</em> is a theory in some language, we define a new theory 2<sup><em>T</em></sup> by adding a new binary relation to the language, and adding axioms stating that it is an equivalence relation, such that there are an infinite number of equivalence classes all of which are <a href="model_theory" title="wikilink">models</a> of <em>T</em>. It is possible to iterate this construction <a href="transfinite_induction" title="wikilink">transfinitely</a>: given an <a href="ordinal_number" title="wikilink">ordinal</a> α, define a new theory by adding an equivalence relation <em>E<sub>β</sub></em> for each β&lt;α, together with axioms stating that whenever β&lt;γ then each <em>E<sub>γ</sub></em> equivalence class is the union of infinitely many <em>E<sub>β</sub></em> equivalence classes, and each <em>E<sub>0</sub></em> equivalence class is a model of <em>T</em>. Informally, one can visualize models of this theory as infinitely branching trees of height α with models of <em>T</em> attached to all leaves.</p>
<h2 id="orders">Orders</h2>

<p>The signature of orders has no constants or functions, and one binary relation symbols ≤. (It is of course possible to use ≥,  instead as the basic relation, with the obvious minor changes to the axioms.) We define <em>x</em> ≥ <em>y</em>, <em>x</em> <em>y</em> as abbreviations for <em>y</em> ≤ <em>x</em>, <em>x</em> ≤ <em>y</em> ∧¬<em>y</em> ≤ <em>x</em>, <em>y</em>  \forall a \forall b \; a \vee b = b \vee a  || || 

<math display="inline" id="List_of_first-order_theories:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo>∀</mo>
       <mrow>
        <mpadded width="+2.8pt">
         <mi>b</mi>
        </mpadded>
        <mi>a</mi>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>∧</mo>
    <mi>b</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>b</mi>
    <mo>∧</mo>
    <mi>a</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>a</ci>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <times></times>
         <ci>b</ci>
         <ci>a</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>b</ci>
    </apply>
    <apply>
     <and></and>
     <ci>b</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall a\forall b\;a\wedge b=b\wedge a
  </annotation>
 </semantics>
</math>

 |- | <strong><a href="associativity" title="wikilink">Associative</a> laws:</strong> || | 

<math display="inline" id="List_of_first-order_theories:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo>∀</mo>
       <mrow>
        <mi>b</mi>
        <mrow>
         <mo>∀</mo>
         <mrow>
          <mpadded width="+2.8pt">
           <mi>c</mi>
          </mpadded>
          <mi>a</mi>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>∨</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mo>∨</mo>
      <mi>c</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mo>∨</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∨</mo>
    <mi>c</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <or></or>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>a</ci>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <times></times>
         <ci>b</ci>
         <apply>
          <csymbol cd="latexml">for-all</csymbol>
          <apply>
           <times></times>
           <ci>c</ci>
           <ci>a</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <or></or>
      <ci>b</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <or></or>
     <apply>
      <or></or>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall a\forall b\forall c\;a\vee(b\vee c)=(a\vee b)\vee c
  </annotation>
 </semantics>
</math>

 || || 

<math display="inline" id="List_of_first-order_theories:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo>∀</mo>
       <mrow>
        <mi>b</mi>
        <mrow>
         <mo>∀</mo>
         <mrow>
          <mpadded width="+2.8pt">
           <mi>c</mi>
          </mpadded>
          <mi>a</mi>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mo>∧</mo>
      <mi>c</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mo>∧</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mi>c</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>a</ci>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <times></times>
         <ci>b</ci>
         <apply>
          <csymbol cd="latexml">for-all</csymbol>
          <apply>
           <times></times>
           <ci>c</ci>
           <ci>a</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <and></and>
      <ci>b</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <and></and>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall a\forall b\forall c\;a\wedge(b\wedge c)=(a\wedge b)\wedge c
  </annotation>
 </semantics>
</math>

 |- | <strong><a href="Absorption_law" title="wikilink">Absorption laws</a>:</strong> || | 

<math display="inline" id="List_of_first-order_theories:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo>∀</mo>
       <mrow>
        <mpadded width="+2.8pt">
         <mi>b</mi>
        </mpadded>
        <mi>a</mi>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>∨</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mo>∧</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <or></or>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>a</ci>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <times></times>
         <ci>b</ci>
         <ci>a</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <and></and>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall a\forall b\;a\vee(a\wedge b)=a
  </annotation>
 </semantics>
</math>

 || || 

<math display="inline" id="List_of_first-order_theories:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo>∀</mo>
       <mrow>
        <mpadded width="+2.8pt">
         <mi>b</mi>
        </mpadded>
        <mi>a</mi>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mo>∨</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>a</ci>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <times></times>
         <ci>b</ci>
         <ci>a</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <or></or>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall a\forall b\;a\wedge(a\vee b)=a
  </annotation>
 </semantics>
</math>


 |}</p>

<p>For one relation ≤ the axioms are:</p>
<ul>
<li>Axioms stating ≤ is a partial order, as above.</li>
<li>

<math display="inline" id="List_of_first-order_theories:5">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mi>a</mi>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <mi>b</mi>
       <merror class="ltx_ERROR undefined undefined">
        <mtext>\exist</mtext>
       </merror>
       <mpadded width="+2.8pt">
        <mi>c</mi>
       </mpadded>
       <mi>c</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>a</mi>
    <mo>∧</mo>
    <mi>c</mi>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>b</mi>
    <mo>∧</mo>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <mpadded width="+2.8pt">
       <mi>d</mi>
      </mpadded>
      <mi>d</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>a</mi>
    <mo>∧</mo>
    <mi>d</mi>
   </mrow>
   <mo>≤</mo>
   <mi>b</mi>
   <mo>→</mo>
   <mi>d</mi>
   <mo>≤</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>a</ci>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <times></times>
         <ci>b</ci>
         <mtext>\exist</mtext>
         <ci>c</ci>
         <ci>c</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <and></and>
      <ci>a</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <and></and>
      <ci>b</ci>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>d</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <and></and>
      <ci>a</ci>
      <ci>d</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>b</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>d</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall a\forall b\exist c\;c\leq a\wedge c\leq b\wedge\forall d\;d\leq a%
\wedge d\leq b\rightarrow d\leq c
  </annotation>
 </semantics>
</math>

 (existence of c=a∧b)</li>
<li>

<math display="inline" id="List_of_first-order_theories:6">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mi>a</mi>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <mi>b</mi>
       <merror class="ltx_ERROR undefined undefined">
        <mtext>\exist</mtext>
       </merror>
       <mpadded width="+2.8pt">
        <mi>c</mi>
       </mpadded>
       <mi>a</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>c</mi>
    <mo>∧</mo>
    <mi>b</mi>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>c</mi>
    <mo>∧</mo>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <mpadded width="+2.8pt">
       <mi>d</mi>
      </mpadded>
      <mi>a</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>d</mi>
    <mo>∧</mo>
    <mi>b</mi>
   </mrow>
   <mo>≤</mo>
   <mi>d</mi>
   <mo>→</mo>
   <mi>c</mi>
   <mo>≤</mo>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>a</ci>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <times></times>
         <ci>b</ci>
         <mtext>\exist</mtext>
         <ci>c</ci>
         <ci>a</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <and></and>
      <ci>c</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <and></and>
      <ci>c</ci>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>a</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <and></and>
      <ci>d</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>d</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>c</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall a\forall b\exist c\;a\leq c\wedge b\leq c\wedge\forall d\;a\leq d%
\wedge b\leq d\rightarrow c\leq d
  </annotation>
 </semantics>
</math>

 (existence of c=a∨b)</li>
</ul>

<p>First order properties include:</p>
<ul>
<li>

<math display="inline" id="List_of_first-order_theories:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo>∀</mo>
       <mrow>
        <mi>y</mi>
        <mrow>
         <mo>∀</mo>
         <mrow>
          <mpadded width="+2.8pt">
           <mi>z</mi>
          </mpadded>
          <mi>x</mi>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>∨</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>y</mi>
      <mo>∧</mo>
      <mi>z</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>∨</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>∨</mo>
      <mi>z</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <or></or>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>x</ci>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <times></times>
         <ci>y</ci>
         <apply>
          <csymbol cd="latexml">for-all</csymbol>
          <apply>
           <times></times>
           <ci>z</ci>
           <ci>x</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <and></and>
      <ci>y</ci>
      <ci>z</ci>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <or></or>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <or></or>
      <ci>x</ci>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\forall y\forall z\;x\vee(y\wedge z)=(x\vee y)\wedge(x\vee z)
  </annotation>
 </semantics>
</math>

 (<a href="distributive_lattice" title="wikilink">distributive lattices</a>)</li>
<li>

<math display="inline" id="List_of_first-order_theories:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo>∀</mo>
       <mrow>
        <mi>y</mi>
        <mrow>
         <mo>∀</mo>
         <mrow>
          <mpadded width="+2.8pt">
           <mi>z</mi>
          </mpadded>
          <mi>x</mi>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>∨</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>y</mi>
      <mo>∧</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>∨</mo>
        <mi>z</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>∨</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>∨</mo>
      <mi>z</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <or></or>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>x</ci>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <times></times>
         <ci>y</ci>
         <apply>
          <csymbol cd="latexml">for-all</csymbol>
          <apply>
           <times></times>
           <ci>z</ci>
           <ci>x</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <and></and>
      <ci>y</ci>
      <apply>
       <or></or>
       <ci>x</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <or></or>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <or></or>
      <ci>x</ci>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\forall y\forall z\;x\vee(y\wedge(x\vee z))=(x\vee y)\wedge(x\vee z)
  </annotation>
 </semantics>
</math>

 (<a href="modular_lattice" title="wikilink">modular lattices</a>)</li>
</ul>

<p><a href="Heyting_algebra" title="wikilink">Heyting algebras</a> can be defined as lattices with certain extra first-order properties.</p>

<p><a href="Complete_lattice" title="wikilink">Completeness</a> is not a first order property of lattices.</p>
<h2 id="graphs">Graphs</h2>

<p>The signature of graphs has no constants or functions, and one binary relation symbol <em>R</em>, where <em>R</em>(<em>x</em>,<em>y</em>) is read as "there is an edge from <em>x</em> to <em>y</em>".</p>

<p>The axioms for the <strong>theory of graphs</strong> are</p>
<ul>
<li><strong>Symmetric</strong>: ∀<em>x</em> ∀<em>y</em> <em>R</em>(<em>x</em>,<em>y</em>)→ <em>R</em>(<em>y</em>,<em>x</em>)</li>
<li><strong>Anti-reflexive</strong>: ∀<em>x</em> ¬<em>R</em>(<em>x</em>,<em>x</em>) ("no loops")</li>
</ul>

<p>The <em>theory of random graphs</em> has the following extra axioms for each positive integer <em>n</em>:</p>
<ul>
<li>For any two disjoint finite sets of size <em>n</em>, there is a point joined to all points of the first set and to no points of the second set. (For each fixed <em>n</em>, it is easy to write this statement in the language of graphs.)</li>
</ul>

<p>The theory of random graphs is ω categorical, complete, and decidable, and its countable model is called the <a href="Rado_graph" title="wikilink">Rado graph</a>. A statement in the language of graphs is true in this theory if and only if the probability that an <em>n</em>-vertex <a href="random_graph" title="wikilink">random graph</a> models the statement tends to 1 in the limit as <em>n</em> goes to infinity.</p>
<h2 id="boolean-algebras">Boolean algebras</h2>

<p>There are several different signatures and conventions used for <strong><a href="Boolean_algebras" title="wikilink">Boolean algebras</a></strong>:</p>
<ol>
<li>The signature has 2 constants, 0 and 1, and two binary functions ∧ and ∨ ("and" and "or"), and one unary function ¬ ("not"). This is a little confusing as the functions use the same symbols as the <a href="propositional_function" title="wikilink">propositional functions</a> of first-order logic.</li>
<li>In <a href="set_theory" title="wikilink">set theory</a>, a common convention is that the language has 2 constants, 0 and 1, and two binary functions · and +, and one unary function −. The three functions have the same interpretation as the functions in the first convention. Unfortunately, this convention clashes badly with the next convention:</li>
<li>In algebra, the usual convention is that the language has 2 constants, 0 and 1, and two binary functions · and +. The function · has the same meaning as ∧, but <em>a</em>+<em>b</em> means <em>a</em>∨<em>b</em>∧¬(<em>a</em>∧<em>b</em>). The reason for this is that the axioms for a Boolean algebra are then just the axioms for a ring with 1 plus ∀<em>x</em> <em>x</em><sup>2</sup> = <em>x</em>. Unfortunately this clashes with the standard convention in set theory given above.</li>
</ol>

<p>The axioms are:</p>
<ul>
<li>The axioms for a distributive lattice (see above)</li>
<li>∀a <em>a</em>∧¬<em>a</em> = 0, ∀a <em>a</em>∨¬<em>a</em> = 1 (properties of negation)</li>
<li>Some authors add the extra axiom ¬0=1, to exclude the trivial algebra with one element.</li>
</ul>

<p>Tarski proved that the theory of Boolean algebras is decidable.</p>

<p>We write <em>x</em> ≤ <em>y</em> as an abbreviation for <em>x</em> ∧ <em>y</em> = <em>x</em>, and atom(<em>x</em>) as an abbreviation for ¬<em>x</em> = 0 ∧ ∀<em>y</em> <em>y</em>≤<em>x</em> → <em>y</em> = 0 ∨ <em>y</em> = <em>x</em>, read as "<em>x</em> is an atom", in other words a non-zero element with nothing between it and 0. Here are some first-order properties of Boolean algebras:</p>
<ul>
<li><strong>Atomic</strong>: ∀<em>x</em> <em>x</em>=0 ∨ ∃<em>y</em> <em>y</em>≤<em>x</em> ∧ atom(<em>y</em>)</li>
<li><strong>Atomless</strong>: ∀<em>x</em> ¬atom(<em>x</em>)</li>
</ul>

<p>The theory of <strong>atomless Boolean algebras</strong> is ω-categorical and complete.</p>

<p>For any Boolean algebra <em>B</em>, there are several invariants defined as follows.</p>
<ul>
<li>the ideal <em>I</em>(<em>B</em>) consists of elements that are the sum of an atomic and an atomless element (an element with no atoms below it).</li>
<li>The quotient algebras <em>B</em><sup><em>i</em></sup> of <em>B</em> are defined inductively by <em>B</em><sup>0</sup>=<em>B</em>, <em>B</em><sup><em>k</em>+1</sup> = <em>B</em><sup><em>k</em></sup>/<em>I</em>(<em>B</em><sup><em>k</em></sup>).</li>
<li>The invariant <em>m</em>(<em>B</em>) is the smallest integer such that <em>B</em><sup><em>m</em>+1</sup> is trivial, or ∞ if no such integer exists.</li>
<li>If <em>m</em>(<em>B</em>) is finite, the invariant <em>n</em>(<em>B</em>) is the number of atoms of <em>B</em><sup><em>m</em>(<em>B</em>)</sup> if this number is finite, or ∞ if this number is infinite.</li>
<li>The invariant <em>l</em>(<em>B</em>) is 0 if <em>B</em><sup><em>m</em>(<em>B</em>)</sup> is atomic or if <em>m</em>(<em>B</em>) is ∞, and 1 otherwise.</li>
</ul>

<p>Then two Boolean algebras are elementarily equivalent if and only if their invariants <em>l</em>, <em>m</em>, and <em>n</em> are the same. In other words, the values of these invariants classify the possible completions of the theory of Boolean algebras. So the possible complete theories are:</p>
<ul>
<li>The trivial algebra (if this is allowed; sometimes 0≠1 is included as an axiom.)</li>
<li>The theory with <em>m</em>=∞</li>
<li>The theories with <em>m</em> a natural number, <em>n</em> a natural number or ∞, and <em>l</em> = 0 or 1 (with <em>l</em> = 0 if <em>n</em>=0).</li>
</ul>
<h2 id="groups">Groups</h2>

<p>The signature of group theory has one constant 1 (the identity), one function of arity 1 (the inverse) whose value on <em>t</em> is denoted by <em>t</em><sup>−1</sup>, and one function of arity 2, which is usually omitted from terms. For any integer <em>n</em>. <em>t</em><sup><em>n</em></sup> is an abbreviation for the obvious term for the <em>n</em>th power of <em>t</em>.</p>

<p><strong><a href="Group_(mathematics)" title="wikilink">Groups</a></strong> are defined by the axioms</p>
<ul>
<li><em>Identity</em>: ∀<em>x</em> 1<em>x</em> = <em>x</em> ∧ <em>x</em>1 = <em>x</em></li>
<li><em>Inverse</em>: ∀<em>x</em> <em>x</em><sup>−1</sup><em>x</em> = <em>1</em> ∧ <em>xx</em><sup>−1</sup> = <em>1</em></li>
<li><em>Associative</em>: ∀<em>x</em>∀<em>y</em>∀<em>z</em> (<em>xy</em>)<em>z</em> = <em>x</em>(<em>yz</em>)</li>
</ul>

<p>Some properties of groups that can be defined in the first-order language of groups are:</p>
<ul>
<li><strong>Abelian</strong> ∀<em>x</em> ∀<em>y</em> <em>xy</em> = <em>yx</em>.</li>
<li><strong>Torsion free</strong> ∀<em>x</em> <em>x</em><sup>2</sup> = 1→<em>x</em> = 1, ∀<em>x</em> <em>x</em><sup>3</sup> = 1 → <em>x</em> = 1, ∀<em>x</em> <em>x</em><sup>4</sup> = 1 → <em>x</em> = 1, ...</li>
<li><strong>Divisible</strong> ∀<em>x</em> ∃<em>y</em> <em>y</em><sup>2</sup> = <em>x</em>, ∀<em>x</em> ∃<em>y</em> <em>y</em><sup>3</sup> = <em>x</em>, ∀<em>x</em> ∃<em>y</em> <em>y</em><sup>4</sup> = <em>x</em>, ...</li>
<li><strong>Infinite</strong> (as in identity theory)</li>
<li><strong>Exponent</strong> <em>n</em> (for any fixed positive integer <em>n</em>) ∀<em>x</em> <em>x</em><sup><em>n</em></sup> = 1</li>
<li><a href="Nilpotent_group" title="wikilink">Nilpotent</a> of class <em>n</em> (for any fixed positive integer <em>n</em>)</li>
<li><a href="solvable_group" title="wikilink">Solvable</a> of class <em>n</em> (for any fixed positive integer <em>n</em>)</li>
</ul>

<p>The theory of <strong>Abelian groups</strong> is decidable. The theory of <strong>Infinite divisible torsion-free abelian groups</strong> is complete, as is the theory of <strong>Infinite abelian groups of exponent p</strong> (for <em>p</em> prime).</p>

<p>The theory of <strong>finite groups</strong> is the set of first-order statements in the language of groups that are true in all finite groups (there are plenty of infinite models of this theory). It is not completely trivial to find any such statement that is not true for all groups: one example is "given two elements of order 2, either they are conjugate or there is a non-trivial element commuting with both of them".</p>

<p>The properties of being finite, or free, or simple, or torsion are not first-order. More precisely, the first-order theory of all groups with one of these properties has models that do not have this property.</p>
<h2 id="rings-and-fields">Rings and fields</h2>

<p>The signature of (unital) rings has 2 constants 0 and 1, two binary functions + and ×, and, optionally, one unary inverse functions − <sup>−1</sup>.</p>

<p><strong><a href="ring_(mathematics)" title="wikilink">Rings</a></strong> Axioms: Addition makes the ring into an abelian group, multiplication is associative and has an identity 1, and multiplication is left and right distributive.</p>

<p><strong><a href="Commutative_ring" title="wikilink">Commutative rings</a></strong> The axioms for rings plus ∀<em>x</em> ∀<em>y</em> <em>xy</em>=<em>yx</em>.</p>

<p><strong><a href="Field_(mathematics)" title="wikilink">Fields</a></strong> The axioms for commutative rings plus ∀<em>x</em> ¬ <em>x</em>=0 → ∃<em>y</em> <em>xy</em>=1 and ¬ 1=0. Many of the examples given here have only universal, or <em>algebraic</em> axioms. The class of structures satisfying such a theory has the property of being closed under substructure. For example, a subset of a group closed under the group actions of multiplication and inverse is again a group. Since the signature of fields does not usually include multiplicative and additive inverse, the axioms for inverses are not universal, and therefore a substructure of a field closed under addition and multiplication is not always a field. This can be remedied by adding unary inverse functions to the language.</p>

<p>For any positive integer <em>n</em> the property that all equations of degree <em>n</em> have a root can be expressed by a single first-order sentence:</p>
<ul>
<li>∀ <em>a</em><sub>1</sub> ∀ <em>a</em><sub>2</sub>... ∀ <em>a</em><sub><em>n</em></sub> ∃<em>x</em> (...((<em>x</em>+<em>a</em><sub>1</sub>)<em>x</em> +<em>a</em><sub>2</sub>)<em>x</em>+...)<em>x</em>+<em>a</em><sub><em>n</em></sub> = 0</li>
</ul>

<p><strong><a href="Perfect_field" title="wikilink">Perfect fields</a></strong> The axioms for fields, plus axioms for each prime number <em>p</em> stating that if p 1 = 0 (i.e. the field has <a href="field_characteristic" title="wikilink">characteristic</a> <em>p</em>), then every field element has a <em>p</em>th root.</p>

<p><strong>Algebraically closed fields of characteristic <em>p</em></strong> The axioms for fields, plus for every positive <em>n</em> the axiom that all polynomials of degree <em>n</em> have a root, plus axioms fixing the characteristic. The classical examples of complete theories. <a class="uri" href="Categorical" title="wikilink">Categorical</a> in all uncountable cardinals. The theory <em>ACF</em><sub>p</sub> has a <em>universal domain property</em>, in the sense that every structure <em>N</em> satisfying the universal axioms of <em>ACF</em><sub>p</sub> is a substructure of a sufficiently large algebraically closed field 

<math display="inline" id="List_of_first-order_theories:9">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>⊧</mo>
   <mrow>
    <mi>A</mi>
    <mi>C</mi>
    <msub>
     <mi>F</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">models</csymbol>
    <ci>M</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>C</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\models ACF_{0}
  </annotation>
 </semantics>
</math>


, and additionally any two such embeddings <em>N</em> → <em>M</em> induce an <a class="uri" href="automorphism" title="wikilink">automorphism</a> of <em>M</em>.</p>

<p><strong><a href="Finite_field" title="wikilink">Finite fields</a></strong>. The theory of finite fields is the set of all first-order statements that are true in all finite fields. Significant examples of such statements can, for example, be given by applying the <a href="Chevalley–Warning_theorem" title="wikilink">Chevalley–Warning theorem</a>, over the <a href="prime_field" title="wikilink">prime fields</a>. The name is a little misleading as the theory has plenty of infinite models. Ax proved that the theory is decidable.</p>

<p><strong><a href="Formally_real_field" title="wikilink">Formally real fields</a></strong> These are fields with the axiom</p>
<ul>
<li>For every positive <em>n</em>, the axiom ∀ <em>a</em><sub>1</sub> ∀ <em>a</em><sub>2</sub>... ∀ <em>a</em><sub><em>n</em></sub> <em>a</em><sub>1</sub><em>a</em><sub>1</sub>+<em>a</em><sub>2</sub><em>a</em><sub>2</sub>+ ...+<em>a</em><sub><em>n</em></sub><em>a</em><sub><em>n</em></sub>=0 → <em>a</em><sub><em>1</em></sub>=0∨<em>a</em><sub><em>2</em></sub>=0∨ ... ∨<em>a</em><sub><em>n</em></sub>=0 (0 is not a non-trivial sum of squares).</li>
</ul>

<p><strong><a href="Real_closed_field" title="wikilink">Real closed fields</a></strong> Axioms:</p>
<ul>
<li>∀<em>x</em> ∃<em>y</em> <em>x</em>=<em>yy</em> ∨ <em>x</em>+<em>yy</em>=0.</li>
<li>For every odd positive <em>n</em>, the axiom stating that every polynomial of degree <em>n</em> has a root.</li>
<li>For every positive <em>n</em>, the axiom ∀ <em>a</em><sub>1</sub> ∀ <em>a</em><sub>2</sub>... ∀ <em>a</em><sub><em>n</em></sub> <em>a</em><sub>1</sub><em>a</em><sub>1</sub>+<em>a</em><sub>2</sub><em>a</em><sub>2</sub>+ ...+<em>a</em><sub><em>n</em></sub><em>a</em><sub><em>n</em></sub>=0 → <em>a</em><sub><em>1</em></sub>=0∨<em>a</em><sub><em>2</em></sub>=0∨ ... ∨<em>a</em><sub><em>n</em></sub>=0 (0 is not a non-trivial sum of squares).</li>
</ul>

<p>The theory of real closed fields is effective and complete and therefore decidable (the <a href="Tarski-Seidenberg_theorem" title="wikilink">Tarski-Seidenberg theorem</a>). The addition of further function symbols (e.g., the exponential function, the sine function) <a href="Decidability_of_first-order_theories_of_the_real_numbers" title="wikilink">may change decidability</a>.</p>

<p>''' <em>p</em>-adic fields''':  showed that the theory of <em>p</em>-adic fields is decidable and gave a set of axioms for it.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="geometry">Geometry</h2>

<p>Axioms for various systems of geometry usually use a typed language, with the different types corresponding to different geometric objects such as points, lines, circles, planes, and so on. The signature will often consist of binary incidence relations between objects of different types; for example, the relation that a point lies on a line. The signature may have more complicated relations; for example ordered geometry might have a ternary "betweenness" relation for 3 points, which says whether one lies between two others, or a "congruence" relation between 2 pairs of points.</p>

<p>Some examples of axiomatized systems of geometry include <a href="ordered_geometry" title="wikilink">ordered geometry</a>, <a href="absolute_geometry" title="wikilink">absolute geometry</a>, <a href="affine_geometry" title="wikilink">affine geometry</a>, <a href="Euclidean_geometry" title="wikilink">Euclidean geometry</a>, <a href="projective_geometry" title="wikilink">projective geometry</a>, and <a href="hyperbolic_geometry" title="wikilink">hyperbolic geometry</a>. For each of these geometries there are many different and inequivalent systems of axioms for various dimensions. Some of these axiom systems include "completeness" axioms that are not first order.</p>

<p>As a typical example, the axioms for projective geometry use 2 types, points and lines, and a binary incidence relation between points and lines. If point and line variables are indicated by small and capital letter, and <em>a</em> incident to <em>A</em> is written as <em>aA</em>, then one set of axioms is</p>
<ul>
<li>

<math display="inline" id="List_of_first-order_theories:10">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mi>a</mi>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <mpadded width="+2.8pt">
        <mi>b</mi>
       </mpadded>
       <mi mathvariant="normal">¬</mi>
       <mi>a</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>b</mi>
   <mo>→</mo>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mpadded width="+2.8pt">
      <mi>C</mi>
     </mpadded>
     <mi>a</mi>
     <mi>C</mi>
     <mi mathvariant="italic">and</mi>
     <mi>b</mi>
     <mi>C</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>a</ci>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <times></times>
         <ci>b</ci>
         <not></not>
         <ci>a</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>b</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <ci>C</ci>
       <ci>a</ci>
       <ci>C</ci>
       <ci>italic- and</ci>
       <ci>b</ci>
       <ci>C</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall a\forall b\;\lnot a=b\rightarrow\exists C\;aC\and bC
  </annotation>
 </semantics>
</math>

 (There is a line through any 2 distinct points <em>a</em>,<em>b</em> ...)</li>
<li>

<math display="inline" id="List_of_first-order_theories:11">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mi>a</mi>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <mi>b</mi>
       <mrow>
        <mo>∀</mo>
        <mrow>
         <mi>C</mi>
         <mrow>
          <mo>∀</mo>
          <mrow>
           <mpadded width="+2.8pt">
            <mi>D</mi>
           </mpadded>
           <mi mathvariant="normal">¬</mi>
           <mi>a</mi>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>b</mi>
    <mi mathvariant="italic">and</mi>
    <mi>a</mi>
    <mi>C</mi>
    <mi mathvariant="italic">and</mi>
    <mi>b</mi>
    <mi>C</mi>
    <mi mathvariant="italic">and</mi>
    <mi>a</mi>
    <mi>D</mi>
    <mi mathvariant="italic">and</mi>
    <mi>b</mi>
    <mi>D</mi>
   </mrow>
   <mo>→</mo>
   <mi>C</mi>
   <mo>=</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>a</ci>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <times></times>
         <ci>b</ci>
         <apply>
          <csymbol cd="latexml">for-all</csymbol>
          <apply>
           <times></times>
           <ci>C</ci>
           <apply>
            <csymbol cd="latexml">for-all</csymbol>
            <apply>
             <times></times>
             <ci>D</ci>
             <not></not>
             <ci>a</ci>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>b</ci>
      <ci>italic- and</ci>
      <ci>a</ci>
      <ci>C</ci>
      <ci>italic- and</ci>
      <ci>b</ci>
      <ci>C</ci>
      <ci>italic- and</ci>
      <ci>a</ci>
      <ci>D</ci>
      <ci>italic- and</ci>
      <ci>b</ci>
      <ci>D</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>C</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall a\forall b\forall C\forall D\;\lnot a=b\and aC\and bC\and aD\and bD%
\rightarrow C=D
  </annotation>
 </semantics>
</math>

 (... which is unique)</li>
<li>

<math display="inline" id="List_of_first-order_theories:12">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mi>a</mi>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <mi>b</mi>
       <mrow>
        <mo>∀</mo>
        <mrow>
         <mi>c</mi>
         <mrow>
          <mo>∀</mo>
          <mrow>
           <mi>d</mi>
           <mrow>
            <mo>∀</mo>
            <mrow>
             <mi>e</mi>
             <mrow>
              <mo>∀</mo>
              <mrow>
               <mi>G</mi>
               <mrow>
                <mo>∀</mo>
                <mrow>
                 <mpadded width="+2.8pt">
                  <mi>H</mi>
                 </mpadded>
                 <mi>a</mi>
                 <mi>H</mi>
                 <mi mathvariant="italic">and</mi>
                 <mi>b</mi>
                 <mi>H</mi>
                 <mi mathvariant="italic">and</mi>
                 <mi>e</mi>
                 <mi>H</mi>
                 <mi mathvariant="italic">and</mi>
                 <mi>c</mi>
                 <mi>G</mi>
                 <mi mathvariant="italic">and</mi>
                 <mi>d</mi>
                 <mi>G</mi>
                 <mi mathvariant="italic">and</mi>
                 <mi>e</mi>
                 <mi>G</mi>
                </mrow>
               </mrow>
              </mrow>
             </mrow>
            </mrow>
           </mrow>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <mi>I</mi>
       <mrow>
        <mo>∃</mo>
        <mrow>
         <mpadded width="+2.8pt">
          <mi>J</mi>
         </mpadded>
         <mi>a</mi>
         <mi>I</mi>
         <mi mathvariant="italic">and</mi>
         <mi>c</mi>
         <mi>I</mi>
         <mi mathvariant="italic">and</mi>
         <mi>f</mi>
         <mi>I</mi>
         <mi mathvariant="italic">and</mi>
         <mi>b</mi>
         <mi>J</mi>
         <mi mathvariant="italic">and</mi>
         <mi>d</mi>
         <mi>J</mi>
         <mi mathvariant="italic">and</mi>
         <mi>f</mi>
         <mi>J</mi>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>a</ci>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <times></times>
        <ci>b</ci>
        <apply>
         <csymbol cd="latexml">for-all</csymbol>
         <apply>
          <times></times>
          <ci>c</ci>
          <apply>
           <csymbol cd="latexml">for-all</csymbol>
           <apply>
            <times></times>
            <ci>d</ci>
            <apply>
             <csymbol cd="latexml">for-all</csymbol>
             <apply>
              <times></times>
              <ci>e</ci>
              <apply>
               <csymbol cd="latexml">for-all</csymbol>
               <apply>
                <times></times>
                <ci>G</ci>
                <apply>
                 <csymbol cd="latexml">for-all</csymbol>
                 <apply>
                  <times></times>
                  <ci>H</ci>
                  <ci>a</ci>
                  <ci>H</ci>
                  <ci>italic- and</ci>
                  <ci>b</ci>
                  <ci>H</ci>
                  <ci>italic- and</ci>
                  <ci>e</ci>
                  <ci>H</ci>
                  <ci>italic- and</ci>
                  <ci>c</ci>
                  <ci>G</ci>
                  <ci>italic- and</ci>
                  <ci>d</ci>
                  <ci>G</ci>
                  <ci>italic- and</ci>
                  <ci>e</ci>
                  <ci>G</ci>
                 </apply>
                </apply>
               </apply>
              </apply>
             </apply>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <exists></exists>
       <apply>
        <times></times>
        <ci>I</ci>
        <apply>
         <exists></exists>
         <apply>
          <times></times>
          <ci>J</ci>
          <ci>a</ci>
          <ci>I</ci>
          <ci>italic- and</ci>
          <ci>c</ci>
          <ci>I</ci>
          <ci>italic- and</ci>
          <ci>f</ci>
          <ci>I</ci>
          <ci>italic- and</ci>
          <ci>b</ci>
          <ci>J</ci>
          <ci>italic- and</ci>
          <ci>d</ci>
          <ci>J</ci>
          <ci>italic- and</ci>
          <ci>f</ci>
          <ci>J</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall a\forall b\forall c\forall d\forall e\forall G\forall H\;aH\and bH\and
eH%
\and cG\and dG\and eG\rightarrow\exists f\exists I\exists J\;aI\and cI\and fI%
\and bJ\and dJ\and fJ
  </annotation>
 </semantics>
</math>

 (Veblen's axiom: if <em>ab</em> and <em>cd</em> lie on intersecting lines, then so do <em>ac</em> and <em>bd</em>.)</li>
<li>

<math display="inline" id="List_of_first-order_theories:13">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mi>A</mi>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <mi>b</mi>
       <mrow>
        <mo>∃</mo>
        <mrow>
         <mi>c</mi>
         <mrow>
          <mo>∃</mo>
          <mrow>
           <mpadded width="+2.8pt">
            <mi>d</mi>
           </mpadded>
           <mi>b</mi>
           <mi>A</mi>
           <mi mathvariant="italic">and</mi>
           <mi>c</mi>
           <mi>A</mi>
           <mi mathvariant="italic">and</mi>
           <mi>d</mi>
           <mi>A</mi>
           <mi mathvariant="italic">and</mi>
           <mi mathvariant="normal">¬</mi>
           <mi>b</mi>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>c</mi>
    <mi mathvariant="italic">and</mi>
    <mi mathvariant="normal">¬</mi>
    <mi>b</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>d</mi>
    <mi mathvariant="italic">and</mi>
    <mi mathvariant="normal">¬</mi>
    <mi>c</mi>
   </mrow>
   <mo>=</mo>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>A</ci>
       <apply>
        <exists></exists>
        <apply>
         <times></times>
         <ci>b</ci>
         <apply>
          <exists></exists>
          <apply>
           <times></times>
           <ci>c</ci>
           <apply>
            <exists></exists>
            <apply>
             <times></times>
             <ci>d</ci>
             <ci>b</ci>
             <ci>A</ci>
             <ci>italic- and</ci>
             <ci>c</ci>
             <ci>A</ci>
             <ci>italic- and</ci>
             <ci>d</ci>
             <ci>A</ci>
             <ci>italic- and</ci>
             <not></not>
             <ci>b</ci>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>italic- and</ci>
      <not></not>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>italic- and</ci>
      <not></not>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall A\exists b\exists c\exists d\;bA\and cA\and dA\and\lnot b=c\and\lnot b%
=d\and\lnot c=d
  </annotation>
 </semantics>
</math>

 (Every line has at least 3 points)</li>
</ul>

<p>Euclid did not state all the axioms for Euclidean geometry explicitly, and the first complete list was given by Hilbert in <a href="Hilbert's_axioms" title="wikilink">Hilbert's axioms</a>. This is not a first order axiomatization as one of Hilbert's axioms is a second order completeness axiom. <a href="Tarski's_axioms" title="wikilink">Tarski's axioms</a> are a first order axiomatization of Euclidean geometry. Tarski showed this axiom system is complete and decidable by relating it to the complete and decidable theory of real closed fields.</p>
<h2 id="differential-algebra">Differential algebra</h2>
<ul>
<li>The theory DF of <a href="differential_field" title="wikilink">differential fields</a>.</li>
</ul>

<p>The signature is that of fields (0, 1, +, −, ×) together with a unary function ∂, the derivation. The axioms are those for fields together with</p>

<p>

<math display="block" id="List_of_first-order_theories:14">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mi>u</mi>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <mpadded width="+1.7pt">
        <mi>v</mi>
       </mpadded>
       <mrow>
        <mo>∂</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>u</mi>
          <mi>v</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>u</mi>
     </mpadded>
     <mrow>
      <mo>∂</mo>
      <mi>v</mi>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>v</mi>
     </mpadded>
     <mrow>
      <mo>∂</mo>
      <mi>u</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>u</ci>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <times></times>
        <ci>v</ci>
        <apply>
         <partialdiff></partialdiff>
         <apply>
          <times></times>
          <ci>u</ci>
          <ci>v</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>u</ci>
      <apply>
       <partialdiff></partialdiff>
       <ci>v</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>v</ci>
      <apply>
       <partialdiff></partialdiff>
       <ci>u</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall u\forall v\,\partial(uv)=u\,\partial v+v\,\partial u
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="List_of_first-order_theories:15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <mi>u</mi>
      <mrow>
       <mo>∀</mo>
       <mrow>
        <mpadded width="+1.7pt">
         <mi>v</mi>
        </mpadded>
        <mrow>
         <mo>∂</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>u</mi>
           <mo>+</mo>
           <mi>v</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>∂</mo>
      <mi>u</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mo>∂</mo>
      <mpadded width="+5pt">
       <mi>v</mi>
      </mpadded>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>u</ci>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <times></times>
        <ci>v</ci>
        <apply>
         <partialdiff></partialdiff>
         <apply>
          <plus></plus>
          <ci>u</ci>
          <ci>v</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <partialdiff></partialdiff>
      <ci>u</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <ci>v</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall u\forall v\,\partial(u+v)=\partial u+\partial v\ .
  </annotation>
 </semantics>
</math>

 For this theory one can add the condition that the characteristic is <em>p</em>, a prime or zero, to get the theory DF<sub><em>p</em></sub> of '''differential fields of characteristic <em>p</em> '''(and similarly with the other theories below).</p>

<p>If <em>K</em> is a differential field then the <strong>field of constants</strong> 

<math display="inline" id="List_of_first-order_theories:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>u</mi>
      <mo>∈</mo>
      <mi>K</mi>
     </mrow>
     <mo>:</mo>
     <mrow>
      <mrow>
       <mo>∂</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>u</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>u</ci>
      <ci>K</ci>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <partialdiff></partialdiff>
       <ci>u</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=\{u\in K:\partial(u)=0\}.
  </annotation>
 </semantics>
</math>

 The theory of <strong>differentially perfect fields</strong> is the theory of differential fields together with the condition that the field of constants is perfect; in other words, for each prime <em>p</em> it has the axiom:</p>

<p>

<math display="block" id="List_of_first-order_theories:17">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>u</mi>
     </mpadded>
     <mrow>
      <mo>∂</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mi mathvariant="italic">and</mi>
    <mi>p</mi>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
   <mo>→</mo>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>v</mi>
     </mpadded>
     <msup>
      <mi>v</mi>
      <mi>p</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>u</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>u</ci>
       <apply>
        <partialdiff></partialdiff>
        <ci>u</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">0</cn>
      <ci>italic- and</ci>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <ci>v</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>v</ci>
        <ci>p</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall u\,\partial(u)=0\and p1=0\rightarrow\exists v\,v^{p}=u
  </annotation>
 </semantics>
</math>

 (There is little point in demanding that the whole field should be a <a href="perfect_field" title="wikilink">perfect field</a>, because in non-zero characteristic this implies the differential is 0.) For technical reasons to do with <a href="quantifier_elimination" title="wikilink">quantifier elimination</a>, it is sometimes more convenient to force the constant field to be perfect by adding a new symbol <em>r</em> to the signature with the axioms</p>

<p>

<math display="block" id="List_of_first-order_theories:18">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>u</mi>
     </mpadded>
     <mrow>
      <mo>∂</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mi mathvariant="italic">and</mi>
    <mi>p</mi>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
   <mo>→</mo>
   <mrow>
    <mi>r</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>p</mi>
    </msup>
   </mrow>
   <mo>=</mo>
   <mi>u</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>u</ci>
       <apply>
        <partialdiff></partialdiff>
        <ci>u</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">0</cn>
      <ci>italic- and</ci>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>r</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>u</ci>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall u\,\partial(u)=0\and p1=0\rightarrow r(u)^{p}=u
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="List_of_first-order_theories:19">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>u</mi>
     </mpadded>
     <mi mathvariant="normal">¬</mi>
     <mrow>
      <mo>∂</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
   <mo>→</mo>
   <mrow>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>u</ci>
       <not></not>
       <apply>
        <partialdiff></partialdiff>
        <ci>u</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>u</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall u\,\lnot\partial(u)=0\rightarrow r(u)=0.
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>The theory of <strong><a href="differentially_closed_field" title="wikilink">differentially closed fields</a></strong> (DCF) is the theory of differentially perfect fields with axioms saying that if <em>f</em> and <em>g</em> are <a href="differential_polynomial" title="wikilink">differential polynomials</a> and the <a class="uri" href="separant" title="wikilink">separant</a> of <em>f</em> is nonzero and <em>g</em>≠0 and <em>f</em> has order greater than that of <em>g</em>, then there is some <em>x</em> in the field with <em>f</em>(<em>x</em>)=0 and <em>g</em>(<em>x</em>)≠0.</li>
</ul>
<h2 id="addition">Addition</h2>

<p>The <strong>theory of the natural numbers with a successor function</strong> has signature consisting of a constant 0 and a unary function <em>S</em> ("successor": <em>S</em>(<em>x</em>) is interpreted as <em>x</em>+1), and has axioms:</p>
<ol>
<li>∀x ¬ Sx = 0</li>
<li>∀x∀y Sx = Sy → x = y</li>
<li>Let <em>P</em>(<em>x</em>) be a <a href="first-order_logic" title="wikilink">first-order formula</a> with a single free variable <em>x</em>. Then the following formula is an axiom:</li>
</ol>
<dl>
<dd>(<em>P</em>(0) ∧ ∀<em>x</em>(<em>P</em>(<em>x</em>)→<em>P</em>(<em>Sx</em>))) → ∀<em>y</em> <em>P</em>(<em>y</em>).
</dd>
</dl>

<p>The last axiom (induction) can be replaced by the axioms</p>
<ul>
<li>For each integer <em>n</em>&gt;0, the axiom ∀x SSS...Sx ≠ x (with <em>n</em> copies of <em>S</em>)</li>
<li>∀x ¬ x = 0 → ∃y Sy = x</li>
</ul>

<p>The theory of the natural numbers with a successor function is complete and decidable, and is κ-categorical for uncountable κ but not for countable κ.</p>

<p><strong><a href="Presburger_arithmetic" title="wikilink">Presburger arithmetic</a></strong> is the theory of the natural numbers under addition, with signature consisting of a constant 0, a unary function <em>S</em>, and a binary function +. It is complete and decidable. The axioms are</p>
<ol>
<li>∀x ¬ Sx = 0</li>
<li>∀x∀y Sx = Sy → x = y</li>
<li>∀x x + 0 = x</li>
<li>∀x∀y x + Sy = S(x + y)</li>
<li>Let <em>P</em>(<em>x</em>) be a <a href="first-order_logic" title="wikilink">first-order formula</a> with a single free variable <em>x</em>. Then the following formula is an axiom:</li>
</ol>
<dl>
<dd>(<em>P</em>(0) ∧ ∀<em>x</em>(<em>P</em>(<em>x</em>)→<em>P</em>(<em>Sx</em>))) → ∀<em>y</em> <em>P</em>(<em>y</em>).
</dd>
</dl>
<h2 id="arithmetic">Arithmetic</h2>

<p>Many of the first order theories described above can be extended to complete recursively enumerable consistent theories. This is no longer true for most of the following theories; they can usually encode both multiplication and addition of natural numbers, and this gives them enough power to encode themselves, which implies that <a href="Gödel's_incompleteness_theorem" title="wikilink">Gödel's incompleteness theorem</a> applies and the theories can no longer be both complete and recursively enumerable (unless they are inconsistent).</p>

<p>The signature of a theory of arithmetic has:</p>
<ul>
<li>The constant 0;</li>
<li>The <a href="unary_function" title="wikilink">unary function</a>, the <a href="successor_function" title="wikilink">successor function</a>, here denoted by prefix <em>S</em>, or by prefix σ or postfix ′ elsewhere;</li>
<li>Two <a href="binary_function" title="wikilink">binary functions</a>, denoted by infix + and ×, called "addition" and "multiplication."</li>
</ul>

<p>Some authors take the signature to contain a constant 1 instead of the function <em>S</em>, then define <em>S</em> in the obvious way as <em>St</em> = 1 + <em>t</em>.</p>

<p><strong><a href="Robinson_arithmetic" title="wikilink">Robinson arithmetic</a></strong> (also called <strong>Q</strong>). Axioms (1) and (2) govern the distinguished element 0. (3) assures that <em>S</em> is an <a href="Injective_function" title="wikilink">injection</a>. Axioms (4) and (5) are the standard recursive definition of addition; (6) and (7) do the same for multiplication. Robinson arithmetic can be thought of as Peano arithmetic without induction. <strong>Q</strong> is a weak theory for which <a href="Gödel's_incompleteness_theorems" title="wikilink">Gödel's incompleteness theorem</a> holds. Axioms:</p>
<ol>
<li>∀<em>x</em> ¬ S<em>x</em> = 0</li>
<li>∀<em>x</em> ¬ <em>x</em> = 0 → ∃<em>y</em> S<em>y</em> = <em>x</em></li>
<li>∀<em>x</em>∀<em>y</em> S<em>x</em> = S<em>y</em> → <em>x</em> = <em>y</em></li>
<li>∀<em>x</em> <em>x</em> + 0 = <em>x</em></li>
<li>∀<em>x</em>∀<em>y</em> <em>x</em> + S<em>y</em> = S(<em>x</em> + <em>y</em>)</li>
<li>∀<em>x</em> <em>x</em> × 0 = 0</li>
<li>∀<em>x</em>∀<em>y</em> <em>x</em> × S<em>y</em> = (<em>x</em> × <em>y</em>) + <em>x</em>.</li>
</ol>

<p><strong>IΣ<sub>n</sub></strong> is first order Peano arithmetic with induction restricted to <a href="Arithmetical_hierarchy" title="wikilink">Σ<sub>n</sub> formulas</a> (for <em>n</em> = 0, 1, 2, ...). The theory IΣ<sub>0</sub> is often denoted by IΔ<sub>0</sub>. This is a series of more and more powerful fragments of Peano arithmetic. The case <em>n</em> = 1 has about the same strength as <strong><a href="primitive_recursive_arithmetic" title="wikilink">primitive recursive arithmetic</a></strong> (PRA). <strong><a href="Exponential_function_arithmetic" title="wikilink">Exponential function arithmetic</a></strong> (EFA) is IΣ<sub>0</sub> with an axiom stating that <em>x</em><sup><em>y</em></sup> exists for all <em>x</em> and <em>y</em> (with the usual properties).</p>

<p><strong>First order <a href="Peano_arithmetic" title="wikilink">Peano arithmetic</a></strong>, <strong>PA</strong>. The "standard" theory of arithmetic. The axioms are the axioms of <a href="Robinson_arithmetic" title="wikilink">Robinson arithmetic</a> above, together with the axiom scheme of induction:</p>
<ul>
<li>

<math display="inline" id="List_of_first-order_theories:20">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">ϕ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">ϕ</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">S</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">ϕ</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(0)\wedge(\forall x\phi(x)\rightarrow\phi(Sx))\rightarrow(\forall x\phi(x))
  </annotation>
 </semantics>
</math>

 for any formula φ in the language of <strong>PA</strong>. φ may contain free variables other than <em>x</em>.</li>
</ul>

<p><a href="Kurt_Gödel" title="wikilink">Kurt Gödel</a>'s 1931 paper proved that <strong>PA</strong> is incomplete, and has no consistent recursively enumerable completions.</p>

<p><strong>Complete arithmetic</strong> (also known as <strong>true arithmetic</strong>) is the theory of the standard model of arithmetic, the natural numbers <strong>N</strong>. It is complete but does not have a recursively enumerable set of axioms.</p>

<p>For the <strong>real numbers</strong>, the situation is slightly different: The case that includes just addition and multiplication cannot encode the integers, and hence <a href="Gödel's_incompleteness_theorem" title="wikilink">Gödel's incompleteness theorem</a> <a href="Tarski–Seidenberg_theorem" title="wikilink">does not apply</a>. <a href="Decidability_of_first-order_theories_of_the_real_numbers" title="wikilink">Complications</a> arise when adding further function symbols (e.g., exponentiation).</p>
<h2 id="second-order-arithmetic">Second order arithmetic</h2>

<p><strong><a href="Second-order_arithmetic" title="wikilink">Second-order arithmetic</a></strong> can refer to a first order theory (in spite of the name) with two types of variables, thought of as varying over integers and subsets of the integers. (There is also a theory of arithmetic in second order logic that is called second order arithmetic. It has only one model, unlike the corresponding theory in first order logic, which is incomplete.) The signature will typically be the signature 0, <em>S</em>, +, × of arithmetic, together with a membership relation ∈ between integers and subsets (though there are numerous minor variations). The axioms are those of <a href="Robinson_arithmetic" title="wikilink">Robinson arithmetic</a>, together with axiom schemes of <a href="Mathematical_induction" title="wikilink">induction</a> and <a href="Axiom_schema_of_specification" title="wikilink">comprehension</a>.</p>

<p>There are many different subtheories of second order arithmetic that differ in which formulas are allowed in the induction and comprehension schemes. In order of increasing strength, five of the most common systems are</p>
<ul>
<li>

<math display="inline" id="List_of_first-order_theories:21">
 <semantics>
  <msub>
   <mi>𝖱𝖢𝖠</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝖱𝖢𝖠</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathsf{RCA}_{0}
  </annotation>
 </semantics>
</math>

, Recursive Comprehension</li>
<li>

<math display="inline" id="List_of_first-order_theories:22">
 <semantics>
  <msub>
   <mi>𝖶𝖪𝖫</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝖶𝖪𝖫</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathsf{WKL}_{0}
  </annotation>
 </semantics>
</math>

, Weak König's lemma</li>
<li>

<math display="inline" id="List_of_first-order_theories:23">
 <semantics>
  <msub>
   <mi>𝖠𝖢𝖠</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝖠𝖢𝖠</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathsf{ACA}_{0}
  </annotation>
 </semantics>
</math>

, Arithmetical comprehension</li>
<li>

<math display="inline" id="List_of_first-order_theories:24">
 <semantics>
  <msub>
   <mi>𝖠𝖳𝖱</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝖠𝖳𝖱</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathsf{ATR}_{0}
  </annotation>
 </semantics>
</math>


, Arithmetical Transfinite Recursion</li>
<li>

<math display="inline" id="List_of_first-order_theories:25">
 <semantics>
  <mrow>
   <msubsup>
    <mi mathvariant="normal">Π</mi>
    <mn>1</mn>
    <mn>1</mn>
   </msubsup>
   <mtext>-</mtext>
   <msub>
    <mi>𝖢𝖠</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Π</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <mtext>-</mtext>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝖢𝖠</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi^{1}_{1}\mbox{-}\mathsf{CA}_{0}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="List_of_first-order_theories:26">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Π</mi>
   <mn>1</mn>
   <mn>1</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Π</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi^{1}_{1}
  </annotation>
 </semantics>
</math>

 comprehension</li>
</ul>

<p>These are defined in detail in the articles on <a href="second_order_arithmetic" title="wikilink">second order arithmetic</a> and <a href="reverse_mathematics" title="wikilink">reverse mathematics</a>.</p>
<h2 id="set-theories">Set theories</h2>

<p>The usual signature of set theory has one binary relation ∈, no constants, and no functions. Some of the theories below are "class theories" which have two sorts of object, sets and classes. There are three common ways of handling this in first-order logic:</p>
<ol>
<li>Use first-order logic with two types.</li>
<li>Use ordinary first-order logic, but add a new unary predicate "Set", where "Set(<em>t</em>)" means informally "<em>t</em> is a set".</li>
<li>Use ordinary first-order logic, and instead of adding a new predicate to the language, treat "Set(<em>t</em>)" as an abbreviation for "∃<em>y</em> <em>t</em>∈<em>y</em>"</li>
</ol>

<p>Some first order set theories include:</p>
<ul>
<li>Weak theories lacking <a href="powerset" title="wikilink">powersets</a>:
<ul>
<li><a href="General_set_theory" title="wikilink">S'</a> (Tarski, Mostowski, and Robinson, 1953); (finitely axiomatizable)</li>
<li><a href="General_set_theory" title="wikilink">General set theory</a>;</li>
<li><a href="Kripke-Platek_set_theory" title="wikilink">Kripke-Platek set theory</a>; KP;</li>
</ul></li>
<li><a href="Mac_Lane_set_theory" title="wikilink">Mac Lane set theory</a> and <a href="elementary_topos_theory" title="wikilink">elementary topos theory</a></li>
<li><a href="Zermelo_set_theory" title="wikilink">Zermelo set theory</a>; Z</li>
<li><a href="Ackermann_set_theory" title="wikilink">Ackermann set theory</a>;</li>
<li><a href="Zermelo-Fraenkel_set_theory" title="wikilink">Zermelo-Fraenkel set theory</a>; ZF, ZFC;</li>
<li><a href="Von_Neumann-Bernays-Gödel_set_theory" title="wikilink">Von Neumann-Bernays-Gödel set theory</a>; NBG; (finitely axiomatizable)</li>
<li><a href="Morse–Kelley_set_theory" title="wikilink">Morse–Kelley set theory</a>; MK;</li>
<li><a href="Tarski–Grothendieck_set_theory" title="wikilink">Tarski–Grothendieck set theory</a>; TG;</li>
<li><a href="New_Foundations" title="wikilink">New Foundations</a>; (finitely axiomatizable)</li>
<li><a href="Scott-Potter_set_theory" title="wikilink">Scott-Potter set theory</a></li>
<li><a href="Positive_set_theory" title="wikilink">Positive set theory</a></li>
</ul>

<p>Some extra first order axioms that can be added to one of these (usually ZF) include:</p>
<ul>
<li><a href="axiom_of_choice" title="wikilink">axiom of choice</a>, <a href="axiom_of_dependent_choice" title="wikilink">axiom of dependent choice</a></li>
<li><a href="Generalized_continuum_hypothesis" title="wikilink">Generalized continuum hypothesis</a></li>
<li><a href="Martin's_axiom" title="wikilink">Martin's axiom</a> (usually together with the negation of the continuum hypothesis), <a href="Martin's_maximum" title="wikilink">Martin's maximum</a></li>
<li><a href="diamondsuit" title="wikilink">◊</a> and <a href="clubsuit" title="wikilink">♣</a></li>
<li><a href="Axiom_of_constructibility" title="wikilink">Axiom of constructibility</a> (V=L)</li>
<li><a href="proper_forcing_axiom" title="wikilink">proper forcing axiom</a></li>
<li><a href="analytic_determinacy" title="wikilink">analytic determinacy</a>, <a href="projective_determinacy" title="wikilink">projective determinacy</a>, <a href="Axiom_of_determinacy" title="wikilink">Axiom of determinacy</a></li>
<li>Many <a href="list_of_large_cardinal_properties" title="wikilink">large cardinal axioms</a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="List_of_mathematical_theories" title="wikilink">List of mathematical theories</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="additional-reading">Additional reading</h2>
<ul>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Model_theory" title="wikilink">First-order theories, List of</a> <a href="Category:Mathematical_logic" title="wikilink">First-order theories, List of</a> <a href="Category:Mathematics-related_lists" title="wikilink">First-order theories</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">.<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
