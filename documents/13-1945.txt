   Test Template Framework      Test Template Framework   The Test Template Framework ( TTF ) is a model-based testing (MBT) framework proposed by Phil Stocks and David Carrington in  for the purpose of software testing . Although the TTF was meant to be notation-independent, the original presentation was made using the Z formal notation . It is one of the few MBT frameworks approaching unit testing .  Introduction  The TTF is a specific proposal of model-based testing (MBT). It considers models to be Z specifications . Each operation within the specification is analyzed to derive or generate abstract test cases . This analysis consists of the following steps:   Define the input space (IS) of each operation.  Derive the valid input space (VIS) from the IS of each operation.  Apply one or more testing tactics , 1 starting from each VIS , to build a testing tree for each operation. Testing trees are populated with nodes called test classes .  Prune each of the resulting testing trees .  Find one or more abstract test cases from each leaf in each testing tree .   One of the main advantages of the TTF is that all of these concepts are expressed in the same notation of the specification, i.e. the Z notation . Hence, the engineer has to know only one notation to perform the analysis down to the generation of abstract test cases .  Important concepts  In this section the main concepts defined by the TTF are described.  Input space  Let    O  p      O  p    Op   be a Z operation. Let     x  1   …   x  n        subscript  x  1   normal-…   subscript  x  n     x_{1}\dots x_{n}   be all the input and (non-primed) state variables referenced in    O  p      O  p    Op   , and     T  1   …   T  n        subscript  T  1   normal-…   subscript  T  n     T_{1}\dots T_{n}   their corresponding types. The Input Space (IS) of    O  p      O  p    Op   , written    I   S   O  p        I   subscript  S    O  p      IS_{Op}   , is the Z schema box defined by    [    x  1   :    T  1   …   x  n    :   T  n    ]     delimited-[]     normal-:   subscript  x  1      subscript  T  1   normal-…   subscript  x  n      normal-:     subscript  T  n       [x_{1}:T_{1}\dots x_{n}:T_{n}]   .  Valid input space  Let    O  p      O  p    Op   be a Z operation. Let    pre  O  p      pre  O  p    \text{pre }Op   be the precondition of    O  p      O  p    Op   . The Valid Input Space (VIS) of    O  p      O  p    Op   , written    V  I   S   O  p        V  I   subscript  S    O  p      VIS_{Op}   , is the Z schema box defined by    [  I   S   O  p    |  pre  O  p  ]     fragments  normal-[  I   subscript  S    O  p    normal-|  pre  O  p  normal-]    [IS_{Op}|\text{pre }Op]   .  Test class  Let    O  p      O  p    Op   be a Z operation and let   P   P   P   be any predicate depending on one or more of the variables defined in    V  I   S   O  p        V  I   subscript  S    O  p      VIS_{Op}   . Then, the Z schema box    [  V  I   S   O  p    |  P  ]     fragments  normal-[  V  I   subscript  S    O  p    normal-|  P  normal-]    [VIS_{Op}|P]   is a test class of    O  p      O  p    Op   . Note that this schema is equivalent to    [  I   S   O  p    |  pre  O  p  ∧  P  ]     fragments  normal-[  I   subscript  S    O  p    normal-|  pre  O  p   P  normal-]    [IS_{Op}|\text{pre }Op\land P]   . This observation can be generalized by saying that if    C   O  p      subscript  C    O  p     C_{Op}   is a test class of    O  p      O  p    Op   , then the Z schema box defined by    [   C   O  p    |  P  ]     fragments  normal-[   subscript  C    O  p    normal-|  P  normal-]    [C_{Op}|P]   is also a test class of    O  p      O  p    Op   . According to this definition the VIS is also a test class.  If    C   O  p      subscript  C    O  p     C_{Op}   is a test class of    O  p      O  p    Op   , then the predicate   P   P   P   in     C   O  p   ′   =  =   [   C   O  p    |  P  ]      fragments   subscript   superscript  C  normal-′     O  p       fragments  normal-[   subscript  C    O  p    normal-|  P  normal-]     C^{\prime}_{Op}==[C_{Op}|P]   is said to be the characteristic predicate of    C   O  p   ′     subscript   superscript  C  normal-′     O  p     C^{\prime}_{Op}   or    C   O  p   ′     subscript   superscript  C  normal-′     O  p     C^{\prime}_{Op}   is characterized by   P   P   P   .  Test classes are also called test objectives , test templates  and test specifications.  Testing tactic  In the context of the TTF a testing tactic 2 is a means to partition any test class of any operation. However, some of the testing tactics used in practice actually do not always generate a partition of some test classes.  Some testing tactics originally proposed for the TTF are the following:   Disjunctive Normal Form (DNF). By applying this tactic the operation is written in Disjunctive Normal Form and the test class is divided in as many test classes as terms are in the resulting operation's predicate. The predicate added to each new test class is the precondition of one of the terms in the operation's predicate.    Standard Partitions (SP). This tactic uses a predefined partition of some mathematical operator . For example, the following is a good partition for expressions of the form    S  ♠  T      S  normal-♠  T    S\spadesuit T   where   ♠   normal-♠   \spadesuit   is one of   ∪     \cup   ,   ∩     \cap   and   ∖     \setminus   (see Set theory ).            S  =  ∅   ,   T  =  ∅        S  ≠  ∅   ,    T  ≠  ∅   ,   S  ⊂  T           S  =  ∅   ,   T  ≠  ∅        S  ≠  ∅   ,    T  ≠  ∅   ,   T  ⊂  S           S  ≠  ∅   ,   T  =  ∅        S  ≠  ∅   ,    T  ≠  ∅   ,   T  =  S           S  ≠  ∅   ,    T  ≠  ∅   ,    S  ∩  T   =  ∅         S  ≠  ∅   ,    T  ≠  ∅   ,     S  ∩  T   ≠   ∅  ,   ¬   (   S  ⊆  T   )    ,   ¬   (   T  ⊆  S   )      ,   S  ≠  T             formulae-sequence    S      T      formulae-sequence    S     formulae-sequence    T      S  T        formulae-sequence    S      T      formulae-sequence    S     formulae-sequence    T      T  S        formulae-sequence    S      T      formulae-sequence    S     formulae-sequence    T      T  S        formulae-sequence    S     formulae-sequence    T        S  T        formulae-sequence    S     formulae-sequence    T     formulae-sequence      S  T         S  T        T  S        S  T         \begin{array}[]{l|l}S=\emptyset,T=\emptyset&S\neq\emptyset,T\neq\emptyset,S%
 \subset T\\
 \hline S=\emptyset,T\neq\emptyset&S\neq\emptyset,T\neq\emptyset,T\subset S\\
 \hline S\neq\emptyset,T=\emptyset&S\neq\emptyset,T\neq\emptyset,T=S\\
 \hline S\neq\emptyset,T\neq\emptyset,S\cap T=\emptyset&S\neq\emptyset,T\neq%
 \emptyset,S\cap T\neq\emptyset,\lnot(S\subseteq T),\lnot(T\subseteq S),S\neq T%
 \end{array}       As can be noticed, standard partitions might change according to how much testing the engineer wants to perform.    Sub-domain Propagation (SDP). This tactic is applied to expressions containing:    Two or more mathematical operators for which there are already defined standard partitions, or  Mathematical operators which are defined in terms of other mathematical operators.    In any of these cases, the standard partitions of the operators appearing in the expression or in the definition of a complex one, are combined to produce a partition for the expression. If the tactic is applied to the second case, then the resulting partition can be considered as the standard partition for that operator. Stocks and Carrington in  illustrate this situation with    R  ⊕  G  =   (  dom  G  ⋪  R  )   ∪  G     fragments  R  direct-sum  G    fragments  normal-(  dom  G  not-subgroup-of  R  normal-)    G    R\oplus G=(\text{dom }G\ntriangleleft R)\cup G   , where   ⋪   not-subgroup-of   \ntriangleleft   means domain anti-restriction , by giving standard partitions for   ⋪   not-subgroup-of   \ntriangleleft   and   ∪     \cup   and propagating them to calculate a partition for   ⊕   direct-sum   \oplus   .    Specification Mutation (SM). The first step of this tactic consists in generating a mutant of the Z operation. A mutant of a Z operation is similar in concept to a mutant of a program , i.e. it is a modified version of the operation. The modification is introduced by the engineer with the intention of uncovering an error in the implementation. The mutant should be the specification that the engineer guesses the programmer has implemented. Then, the engineer has to calculate the subset of the VIS that yields different results in both specifications. The predicate of this set is used to derive a new test class.   Some other testing tactics that may also be used are the following:   In Set Extension (ISE). It applies to predicates of the form     e  x  p  r   ∈   {   e  x  p   r  1    ,  …  ,   e  x  p   r  n    }         e  x  p  r      e  x  p   subscript  r  1    normal-…    e  x  p   subscript  r  n       expr\in\{expr_{1},\dots,expr_{n}\}   . In this case, it generates   n   n   n   test classes such that a predicate of the form     e  x  p  r   =   e  x  p   r  i          e  x  p  r     e  x  p   subscript  r  i      expr=expr_{i}   is added to each of them.    Mandatory Test Set (MTS). This tactic associates a set of constant values to a VIS' variable and generates as many test classes as elements are in the set. Each test class is characterized by a predicate of the form     v  a  r   =   v  a  l         v  a  r     v  a  l     var=val   where    v  a  r      v  a  r    var   is the name of the variable and    v  a  l      v  a  l    val   is one of the values of the set.    Numeric Ranges (NR). This tactic applies only to VIS' variables of type   ℤ   ℤ   \mathbb{Z}   (or its "subtype"   ℕ   ℕ   \mathbb{N}   ). It consists in associating a range to a variable and deriving test classes by comparing the variable with the limits of the range in some ways. More formally, let   n   n   n   be a variable of type   ℤ   ℤ   \mathbb{Z}   and let    [  i  ,  j  ]     i  j    [i,j]   be the associated range. Then, the tactic generates the test classes characterized by the following predicates    n  >  j      n  j    n>j   ,    C  O  L  O  U  R  :  :=  r  e  d  |  b  l  u  e  |  g  r  e  e  n     fragments  C  O  L  O  U  R  normal-:  assign  r  e  d  normal-|  b  l  u  e  normal-|  g  r  e  e  n    COLOUR::=red|blue|green   ,   c   c   c   .    Free Type (FT). This tactic generates as many test classes as elements a free (enumerated) type has. In other words, if a model defines type    C  O  L  O  U  R      C  O  L  O  U  R    COLOUR   and some operation uses   c   c   c   of type    r  e  d      r  e  d    red   , then by applying this tactic each test class will by divided into three new test classes: one in which   c   c   c   equals    b  l  u  e      b  l  u  e    blue   , the other in which   c   c   c   equals    g  r  e  e  n      g  r  e  e  n    green   , and the third where     e  x  p  r   ⊂   {   e  x  p   r  1    ,  …  ,   e  x  p   r  n    }         e  x  p  r      e  x  p   subscript  r  1    normal-…    e  x  p   subscript  r  n       expr\subset\{expr_{1},\dots,expr_{n}\}   equals     2  n   -  1       superscript  2  n   1    2^{n}-1   .    Proper Subset of Set Extension (PSSE). This tactic uses the same concept of ISE but applied to set inclusions. PSSE helps to test operations including predicates like     e  x  p  r   =   A  i         e  x  p  r    subscript  A  i     expr=A_{i}   . When PSSE is applied it generates    i  ∈   [  1  ,    2  n   -  1   ]       i   1     superscript  2  n   1      i\in[1,2^{n}-1]   test classes where a predicate of the form     A  i   ∈    ℙ   {   e  x  p   r  1    ,  …  ,   e  x  p   r  n    }    ∖   {   {   e  x  p   r  1    ,  …  ,   e  x  p   r  n    }   }         subscript  A  i       ℙ     e  x  p   subscript  r  1    normal-…    e  x  p   subscript  r  n          e  x  p   subscript  r  1    normal-…    e  x  p   subscript  r  n         A_{i}\in\mathbb{P}\{expr_{1},\dots,expr_{n}\}\setminus\{\{expr_{1},\dots,expr_%
 {n}\}\}   with    {   e  x  p   r  1    ,  …  ,   e  x  p   r  n    }       e  x  p   subscript  r  1    normal-…    e  x  p   subscript  r  n      \{expr_{1},\dots,expr_{n}\}   and    ℙ   {   e  x  p   r  1    ,  …  ,   e  x  p   r  n    }       ℙ     e  x  p   subscript  r  1    normal-…    e  x  p   subscript  r  n       \mathbb{P}\{expr_{1},\dots,expr_{n}\}   , is added to each class.    e  x  p  r      e  x  p  r    expr   is excluded from    {   e  x  p   r  1    ,  …  ,   e  x  p   r  n    }       e  x  p   subscript  r  1    normal-…    e  x  p   subscript  r  n      \{expr_{1},\dots,expr_{n}\}   because     e  x  p  r   ⊆   {   e  x  p   r  1    ,  …  ,   e  x  p   r  n    }         e  x  p  r      e  x  p   subscript  r  1    normal-…    e  x  p   subscript  r  n       expr\subseteq\{expr_{1},\dots,expr_{n}\}   is a proper subset of    2  n     superscript  2  n    2^{n}   .    Subset of Set Extension (SSE). It is identical to PSSE but it applies to predicates of the form    {   e  x  p   r  1    ,  …  ,   e  x  p   r  n    }       e  x  p   subscript  r  1    normal-…    e  x  p   subscript  r  n      \{expr_{1},\dots,expr_{n}\}   in which case it generates       V  I  S      =  =   [  I  S  |  P  ]         T  C   L   T  1   1       =  =   [  V  I  S  |   P   T  1   1   ]         …       T  C   L   T  1   n       =  =   [  V  I  S  |   P   T  1   n   ]         T  C   L   T  2   1       =  =   [  T  C   L   T  1   i   |   P   T  2   1   ]         …       T  C   L   T  2   m       =  =   [  T  C   L   T  1   i   |   P   T  2   m   ]         …       T  C   L   T  3   1       =  =   [  T  C   L   T  2   j   |   P   T  3   1   ]         …       T  C   L   T  3   k       =  =   [  T  C   L   T  2   j   |   P   T  3   k   ]         …       …       …          V  I  S    fragments     fragments  normal-[  I  S  normal-|  P  normal-]        T  C   superscript   subscript  L   subscript  T  1    1     fragments     fragments  normal-[  V  I  S  normal-|   superscript   subscript  P   subscript  T  1    1   normal-]       missing-subexpression   normal-…      T  C   superscript   subscript  L   subscript  T  1    n     fragments     fragments  normal-[  V  I  S  normal-|   superscript   subscript  P   subscript  T  1    n   normal-]        T  C   superscript   subscript  L   subscript  T  2    1     fragments     fragments  normal-[  T  C   superscript   subscript  L   subscript  T  1    i   normal-|   superscript   subscript  P   subscript  T  2    1   normal-]       missing-subexpression   normal-…      T  C   superscript   subscript  L   subscript  T  2    m     fragments     fragments  normal-[  T  C   superscript   subscript  L   subscript  T  1    i   normal-|   superscript   subscript  P   subscript  T  2    m   normal-]       missing-subexpression   normal-…      T  C   superscript   subscript  L   subscript  T  3    1     fragments     fragments  normal-[  T  C   superscript   subscript  L   subscript  T  2    j   normal-|   superscript   subscript  P   subscript  T  3    1   normal-]       missing-subexpression   normal-…      T  C   superscript   subscript  L   subscript  T  3    k     fragments     fragments  normal-[  T  C   superscript   subscript  L   subscript  T  2    j   normal-|   superscript   subscript  P   subscript  T  3    k   normal-]       missing-subexpression   normal-…     missing-subexpression   normal-…     missing-subexpression   normal-…     \begin{aligned}\displaystyle VIS&\displaystyle==[IS|P]\\
 \displaystyle TCL_{T_{1}}^{1}&\displaystyle==[VIS|P_{T_{1}}^{1}]\\
 &\displaystyle\dots\\
 \displaystyle TCL_{T_{1}}^{n}&\displaystyle==[VIS|P_{T_{1}}^{n}]\\
 \displaystyle TCL_{T_{2}}^{1}&\displaystyle==[TCL_{T_{1}}^{i}|P_{T_{2}}^{1}]\\
 &\displaystyle\dots\\
 \displaystyle TCL_{T_{2}}^{m}&\displaystyle==[TCL_{T_{1}}^{i}|P_{T_{2}}^{m}]\\
 &\displaystyle\dots\\
 \displaystyle TCL_{T_{3}}^{1}&\displaystyle==[TCL_{T_{2}}^{j}|P_{T_{3}}^{1}]\\
 &\displaystyle\dots\\
 \displaystyle TCL_{T_{3}}^{k}&\displaystyle==[TCL_{T_{2}}^{j}|P_{T_{3}}^{k}]\\
 &\displaystyle\dots\\
 &\displaystyle\dots\\
 &\displaystyle\dots\end{aligned}   by considering also    O  p      O  p    Op   .   Testing tree&  The application of a testing tactic to the VIS generates some test classes. If some of these test classes are further partitioned by applying one or more testing tactics, a new set of test classes is obtained. This process can continue by applying testing tactics to the test classes generated so far. Evidently, the result of this process can be drawn as a tree with the VIS as the root node, the test classes generated by the first testing tactic as its children, and so on. Furthermore, Stocks and Carrington in  propose to use the Z notation to build the tree, as follows.      V  I   S   O  p        V  I   subscript  S    O  p      VIS_{Op}     Pruning testing trees  In general a test class' predicate is a conjunction of two or more predicates. It is likely, then, that some test classes are empty because their predicates are contradictions. These test classes must be pruned from the testing tree because they represent impossible combinations of input values, i.e. no abstract test case can be derived out of them.  Abstract test case  An abstract test case is an element belonging to a test class . The TTF prescribes that abstract test cases should be derived only from the leaves of the testing tree . Abstract test cases can also be written as Z schema boxes. Let    O  p      O  p    Op   be some operation, let     x  1   :    T  1   …   x  n    :   T  n        normal-:   subscript  x  1      subscript  T  1   normal-…   subscript  x  n      normal-:     subscript  T  n      x_{1}:T_{1}\dots x_{n}:T_{n}   be the VIS of    V  I   S   O  p        V  I   subscript  S    O  p      VIS_{Op}   , let    C   O  p      subscript  C    O  p     C_{Op}   be all the variables declared in    O  p      O  p    Op   , let     P  1   …   P  m        subscript  P  1   normal-…   subscript  P  m     P_{1}\dots P_{m}   be a (leaf) test class of the testing tree associated to    C   O  p      subscript  C    O  p     C_{Op}   , let    V  I   S   O  p        V  I   subscript  S    O  p      VIS_{Op}   be the characteristic predicates of each test class from     v  1   :    T  1   …   v  n    :   T  n        normal-:   subscript  v  1      subscript  T  1   normal-…   subscript  v  n      normal-:     subscript  T  n      v_{1}:T_{1}\dots v_{n}:T_{n}   up to   n   n   n   (by following the edges from child to parent ), and let     P  1   ∧  …  ∧   P  m        subscript  P  1   normal-…   subscript  P  m     P_{1}\land\dots\land P_{m}   be    C   O  p      subscript  C    O  p     C_{Op}   constant values satisfying    [   C   O  p    |   x  1   =   v  1   ∧  …  ∧   x  n   =   v  n   ]     fragments  normal-[   subscript  C    O  p    normal-|   subscript  x  1     subscript  v  1    normal-…    subscript  x  n     subscript  v  n   normal-]    [C_{Op}|x_{1}=v_{1}\land\dots\land x_{n}=v_{n}]   . Then, an abstract test case of $C_{Op}$ is the Z schema box defined by $[C_{Op} | x_{1} = v_{1} \land \dots \land x_{n} = v_{n}]$ .  See also   Model-based testing  Fastest   References    .   .   .   Notes  "  Category:1996 introductions  Category:Software testing  Category:Z notation     Stocks and Carrington use the term testing strategies in . ↩      