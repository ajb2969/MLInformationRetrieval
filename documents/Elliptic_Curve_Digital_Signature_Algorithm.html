<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="975">Elliptic Curve Digital Signature Algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Elliptic Curve Digital Signature Algorithm</h1>
<hr/>

<p>In <a class="uri" href="cryptography" title="wikilink">cryptography</a>, the <strong>Elliptic Curve Digital Signature Algorithm</strong> (<strong>ECDSA</strong>) offers a variant of the <a href="Digital_Signature_Algorithm" title="wikilink">Digital Signature Algorithm</a> (DSA) which uses <a href="elliptic_curve_cryptography" title="wikilink">elliptic curve cryptography</a>.</p>
<h2 id="key-and-signature-size-comparison-to-dsa">Key and signature-size comparison to DSA</h2>

<p>As with elliptic-curve cryptography in general, the bit <a href="Key_size" title="wikilink">size</a> of the <a href="public_key" title="wikilink">public key</a> believed to be needed for ECDSA is about twice the size of the security level, in bits. For example, at a security level of 80 bits (meaning an attacker requires the equivalent of about 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:0">
 <semantics>
  <msup>
   <mn>2</mn>
   <mn>80</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <cn type="integer">80</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{80}
  </annotation>
 </semantics>
</math>

 operations to find the private key) the size of a DSA public key is at least 1024 bits, whereas the size of an ECDSA public key would be 160 bits. On the other hand, the signature size is the same for both DSA and ECDSA

<math display="block" id="Elliptic_Curve_Digital_Signature_Algorithm:1">
 <semantics>
  <mrow>
   <mn>4</mn>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">4</cn>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4t
  </annotation>
 </semantics>
</math>

 bits, where 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:2">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 is the security level measured in bits, that is, about 320 bits for a security level of 80 bits.</p>
<h2 id="signature-generation-algorithm">Signature generation algorithm</h2>

<p>Suppose <a href="Alice_and_Bob" title="wikilink">Alice</a> wants to send a signed message to <a href="Alice_and_Bob" title="wikilink">Bob</a>. Initially, they must agree on the curve parameters 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:3">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mtext>CURVE</mtext>
   <mo>,</mo>
   <mi>G</mi>
   <mo>,</mo>
   <mi>n</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <mtext>CURVE</mtext>
    <ci>G</ci>
    <ci>n</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\textrm{CURVE},G,n)
  </annotation>
 </semantics>
</math>

. In addition to the field and equation of the curve, we need 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:4">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, a base point of prime order on the curve; 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:5">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is the multiplicative order of the point 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:6">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Parameter</p></th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>CURVE</p></td>
<td style="text-align: left;">
<p>the elliptic curve field and equation used</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>G</em></p></td>
<td style="text-align: left;">
<p>elliptic curve base point, a generator of the elliptic curve with large prime order <em>n</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>n</em></p></td>
<td style="text-align: left;">
<p>integer order of <em>G</em>, means that 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mo>×</mo>
    <mi>G</mi>
   </mrow>
   <mo>=</mo>
   <mi>O</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>G</ci>
    </apply>
    <ci>O</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times G=O
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>Alice creates a key pair, consisting of a private key integer 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:8">
 <semantics>
  <msub>
   <mi>d</mi>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{A}
  </annotation>
 </semantics>
</math>

, randomly selected in the interval 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:9">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <cn type="integer">1</cn>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [1,n-1]
  </annotation>
 </semantics>
</math>

; and a public key curve point 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:10">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mi>A</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>d</mi>
     <mi>A</mi>
    </msub>
    <mo>×</mo>
    <mi>G</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>A</ci>
     </apply>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{A}=d_{A}\times G
  </annotation>
 </semantics>
</math>

. We use 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:11">
 <semantics>
  <mo>×</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \times
  </annotation>
 </semantics>
</math>

 to denote <a href="Elliptic_curve_point_multiplication" title="wikilink">elliptic curve point multiplication by a scalar</a>.</p>

<p>For Alice to sign a message 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:12">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

, she follows these steps:</p>
<ol>
<li>Calculate 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:13">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>=</mo>
   <mrow>
    <mtext>HASH</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>e</ci>
    <apply>
     <times></times>
     <mtext>HASH</mtext>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e=\textrm{HASH}(m)
  </annotation>
 </semantics>
</math>

, where HASH is a <a href="cryptographic_hash_function" title="wikilink">cryptographic hash function</a>, such as <a class="uri" href="SHA-2" title="wikilink">SHA-2</a>.</li>
<li>Let 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:14">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 be the 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:15">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{n}
  </annotation>
 </semantics>
</math>

 leftmost bits of 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:16">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:17">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{n}
  </annotation>
 </semantics>
</math>

 is the bit length of the group order 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:18">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

.</li>
<li>Select a <strong>cryptographically secure random</strong> integer 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:19">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:20">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <cn type="integer">1</cn>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [1,n-1]
  </annotation>
 </semantics>
</math>

.</li>
<li>Calculate the curve point 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:21">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mo>×</mo>
    <mi>G</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1},y_{1})=k\times G
  </annotation>
 </semantics>
</math>

.</li>
<li>Calculate 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:22">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
    </mpadded>
    <mo lspace="2.5pt" rspace="4.2pt">mod</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>r</ci>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=x_{1}\,\bmod\,n
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:23">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>r</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=0
  </annotation>
 </semantics>
</math>

, go back to step 3.</li>
<li>Calculate 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:24">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>k</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>z</mi>
       <mo>+</mo>
       <mrow>
        <mi>r</mi>
        <msub>
         <mi>d</mi>
         <mi>A</mi>
        </msub>
       </mrow>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo lspace="2.5pt" rspace="4.2pt">mod</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>k</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <ci>z</ci>
       <apply>
        <times></times>
        <ci>r</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>d</ci>
         <ci>A</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=k^{-1}(z+rd_{A})\,\bmod\,n
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:25">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=0
  </annotation>
 </semantics>
</math>

, go back to step 3.</li>
<li>The signature is the pair 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:26">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>r</mi>
   <mo>,</mo>
   <mi>s</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>r</ci>
    <ci>s</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (r,s)
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>When computing 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:27">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

, the string 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:28">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 resulting from 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:29">
 <semantics>
  <mrow>
   <mtext>HASH</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>HASH</mtext>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textrm{HASH}(m)
  </annotation>
 </semantics>
</math>

 shall be converted to an integer. Note that 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:30">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 can be <em>greater</em> than 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:31">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 but not <em>longer</em>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>As the standard notes, it is crucial to select different 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:32">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 for different signatures, otherwise the equation in step 6 can be solved for 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:33">
 <semantics>
  <msub>
   <mi>d</mi>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{A}
  </annotation>
 </semantics>
</math>

, the private key: Given two signatures 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:34">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>r</mi>
   <mo>,</mo>
   <mi>s</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>r</ci>
    <ci>s</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (r,s)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:35">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>r</mi>
   <mo>,</mo>
   <msup>
    <mi>s</mi>
    <mo>′</mo>
   </msup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>r</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (r,s^{\prime})
  </annotation>
 </semantics>
</math>

, employing the same unknown 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:36">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 for different known messages 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:37">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:38">
 <semantics>
  <msup>
   <mi>m</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>m</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m^{\prime}
  </annotation>
 </semantics>
</math>

, an attacker can calculate 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:39">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:40">
 <semantics>
  <msup>
   <mi>z</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>z</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{\prime}
  </annotation>
 </semantics>
</math>

, and since 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mo>-</mo>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>k</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>z</mi>
      <mo>-</mo>
      <msup>
       <mi>z</mi>
       <mo>′</mo>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>s</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>k</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>z</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s-s^{\prime}=k^{-1}(z-z^{\prime})
  </annotation>
 </semantics>
</math>

 (all operations in this paragraph are done modulo 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:42">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

) the attacker can find 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:43">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>z</mi>
     <mo>-</mo>
     <msup>
      <mi>z</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <mrow>
     <mi>s</mi>
     <mo>-</mo>
     <msup>
      <mi>s</mi>
      <mo>′</mo>
     </msup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <ci>z</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>s</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=\frac{z-z^{\prime}}{s-s^{\prime}}
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:44">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>k</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>z</mi>
      <mo>+</mo>
      <mrow>
       <mi>r</mi>
       <msub>
        <mi>d</mi>
        <mi>A</mi>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>k</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <ci>z</ci>
      <apply>
       <times></times>
       <ci>r</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>d</ci>
        <ci>A</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=k^{-1}(z+rd_{A})
  </annotation>
 </semantics>
</math>

, the attacker can now calculate the private key 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:45">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mi>A</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mi>s</mi>
      <mi>k</mi>
     </mrow>
     <mo>-</mo>
     <mi>z</mi>
    </mrow>
    <mi>r</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>k</ci>
      </apply>
      <ci>z</ci>
     </apply>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{A}=\frac{sk-z}{r}
  </annotation>
 </semantics>
</math>

. This implementation failure was used, for example, to extract the signing key used in the <a href="PlayStation_3" title="wikilink">PlayStation 3</a> gaming-console.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Another way ECDSA signature may leak private keys is when 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:46">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is generated by faulty <a href="random_number_generator" title="wikilink">random number generator</a>. Such failure of RNG caused users of Android Bitcoin Wallet to lose their funds in August 2013.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> To ensure that 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:47">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is unique for each message one may bypass RNG completely and generate deterministic signatures by deriving 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:48">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 from both the message and the private key.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="signature-verification-algorithm">Signature verification algorithm</h2>

<p>For Bob to authenticate Alice's signature, he must have a copy of her public-key curve point 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:49">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{A}
  </annotation>
 </semantics>
</math>

. Bob can verify 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:50">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{A}
  </annotation>
 </semantics>
</math>

 is a valid curve point as follows:</p>
<ol>
<li>Check that 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:51">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{A}
  </annotation>
 </semantics>
</math>

 is not equal to the identity element 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:52">
 <semantics>
  <mi>O</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>O</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O
  </annotation>
 </semantics>
</math>

, and its coordinates are otherwise valid</li>
<li>Check that 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:53">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{A}
  </annotation>
 </semantics>
</math>

 lies on the curve</li>
<li>Check that 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:54">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mo>×</mo>
    <msub>
     <mi>Q</mi>
     <mi>A</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>O</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>A</ci>
     </apply>
    </apply>
    <ci>O</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times Q_{A}=O
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>After that, Bob follows these steps:</p>
<ol>
<li>Verify that 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:55">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:56">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 are integers in 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:57">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <cn type="integer">1</cn>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [1,n-1]
  </annotation>
 </semantics>
</math>

. If not, the signature is invalid.</li>
<li>Calculate 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:58">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>=</mo>
   <mrow>
    <mtext>HASH</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>e</ci>
    <apply>
     <times></times>
     <mtext>HASH</mtext>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e=\textrm{HASH}(m)
  </annotation>
 </semantics>
</math>

, where HASH is the same function used in the signature generation.</li>
<li>Let 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:59">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 be the 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:60">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{n}
  </annotation>
 </semantics>
</math>

 leftmost bits of 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:61">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

.</li>
<li>Calculate 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:62">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <msup>
      <mi>s</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mpadded>
    <mo lspace="2.5pt" rspace="4.2pt">mod</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>w</ci>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w=s^{-1}\,\bmod\,n
  </annotation>
 </semantics>
</math>

.</li>
<li>Calculate 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:63">
 <semantics>
  <mrow>
   <msub>
    <mi>u</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>z</mi>
     <mpadded width="+1.7pt">
      <mi>w</mi>
     </mpadded>
    </mrow>
    <mo lspace="2.5pt" rspace="4.2pt">mod</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <times></times>
      <ci>z</ci>
      <ci>w</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{1}=zw\,\bmod\,n
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:64">
 <semantics>
  <mrow>
   <msub>
    <mi>u</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>r</mi>
     <mpadded width="+1.7pt">
      <mi>w</mi>
     </mpadded>
    </mrow>
    <mo lspace="2.5pt" rspace="4.2pt">mod</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>w</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{2}=rw\,\bmod\,n
  </annotation>
 </semantics>
</math>

.</li>
<li>Calculate the curve point 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:65">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>u</mi>
      <mn>1</mn>
     </msub>
     <mo>×</mo>
     <mi>G</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>u</mi>
      <mn>2</mn>
     </msub>
     <mo>×</mo>
     <msub>
      <mi>Q</mi>
      <mi>A</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>G</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1},y_{1})=u_{1}\times G+u_{2}\times Q_{A}
  </annotation>
 </semantics>
</math>

.</li>
<li>The signature is valid if 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:66">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>≡</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>r</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\equiv x_{1}\;\;(\mathop{{\rm mod}}n)
  </annotation>
 </semantics>
</math>

, invalid otherwise.</li>
</ol>

<p>Note that using <a href="Straus's_algorithm" title="wikilink">Straus's algorithm</a> (also known as Shamir's trick), a sum of two scalar multiplications 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:67">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>u</mi>
     <mn>1</mn>
    </msub>
    <mo>×</mo>
    <mi>G</mi>
   </mrow>
   <mo>+</mo>
   <mrow>
    <msub>
     <mi>u</mi>
     <mn>2</mn>
    </msub>
    <mo>×</mo>
    <msub>
     <mi>Q</mi>
     <mi>A</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>G</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{1}\times G+u_{2}\times Q_{A}
  </annotation>
 </semantics>
</math>

 can be calculated faster than two scalar multiplications done independently.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="correctness-of-the-algorithm">Correctness of the algorithm</h2>

<p>It is not immediately obvious why verification even functions correctly. To see why, denote as 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:68">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 the curve point computed in step 6 of verification,</p>

<p>

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:69">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>u</mi>
      <mn>1</mn>
     </msub>
     <mo>×</mo>
     <mi>G</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>u</mi>
      <mn>2</mn>
     </msub>
     <mo>×</mo>
     <msub>
      <mi>Q</mi>
      <mi>A</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>G</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=u_{1}\times G+u_{2}\times Q_{A}
  </annotation>
 </semantics>
</math>

</p>

<p>From the definition of the public key as 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:70">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mi>A</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>d</mi>
     <mi>A</mi>
    </msub>
    <mo>×</mo>
    <mi>G</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>A</ci>
     </apply>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{A}=d_{A}\times G
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:71">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>u</mi>
      <mn>1</mn>
     </msub>
     <mo>×</mo>
     <mi>G</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>u</mi>
       <mn>2</mn>
      </msub>
      <msub>
       <mi>d</mi>
       <mi>A</mi>
      </msub>
     </mrow>
     <mo>×</mo>
     <mi>G</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>G</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>d</ci>
        <ci>A</ci>
       </apply>
      </apply>
      <ci>G</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=u_{1}\times G+u_{2}d_{A}\times G
  </annotation>
 </semantics>
</math>

</p>

<p>Because elliptic curve scalar multiplication distributes over addition,</p>

<p>

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:72">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>u</mi>
       <mn>1</mn>
      </msub>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>u</mi>
        <mn>2</mn>
       </msub>
       <msub>
        <mi>d</mi>
        <mi>A</mi>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>×</mo>
    <mi>G</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>d</ci>
        <ci>A</ci>
       </apply>
      </apply>
     </apply>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=(u_{1}+u_{2}d_{A})\times G
  </annotation>
 </semantics>
</math>

</p>

<p>Expanding the definition of 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:73">
 <semantics>
  <msub>
   <mi>u</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:74">
 <semantics>
  <msub>
   <mi>u</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{2}
  </annotation>
 </semantics>
</math>

 from verification step 4,</p>

<p>

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:75">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>z</mi>
       <msup>
        <mi>s</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>r</mi>
       <msub>
        <mi>d</mi>
        <mi>A</mi>
       </msub>
       <msup>
        <mi>s</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>×</mo>
    <mi>G</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>z</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>r</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>d</ci>
        <ci>A</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=(zs^{-1}+rd_{A}s^{-1})\times G
  </annotation>
 </semantics>
</math>

</p>

<p>Collecting the common term 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:76">
 <semantics>
  <msup>
   <mi>s</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>s</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{-1}
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:77">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>z</mi>
       <mo>+</mo>
       <mrow>
        <mi>r</mi>
        <msub>
         <mi>d</mi>
         <mi>A</mi>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>s</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>×</mo>
    <mi>G</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <ci>z</ci>
       <apply>
        <times></times>
        <ci>r</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>d</ci>
         <ci>A</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=(z+rd_{A})s^{-1}\times G
  </annotation>
 </semantics>
</math>

</p>

<p>Expanding the definition of 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:78">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 from signature step 6,</p>

<p>

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:79">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>z</mi>
       <mo>+</mo>
       <mrow>
        <mi>r</mi>
        <msub>
         <mi>d</mi>
         <mi>A</mi>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>z</mi>
        <mo>+</mo>
        <mrow>
         <mi>r</mi>
         <msub>
          <mi>d</mi>
          <mi>A</mi>
         </msub>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>k</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>×</mo>
    <mi>G</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <ci>z</ci>
       <apply>
        <times></times>
        <ci>r</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>d</ci>
         <ci>A</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <ci>z</ci>
        <apply>
         <times></times>
         <ci>r</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>d</ci>
          <ci>A</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>k</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=(z+rd_{A})(z+rd_{A})^{-1}(k^{-1})^{-1}\times G
  </annotation>
 </semantics>
</math>

</p>

<p>Since the inverse of an inverse is the original element, and the product of an element's inverse and the element is the identity, we are left with</p>

<p>

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:80">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mo>×</mo>
    <mi>G</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=k\times G
  </annotation>
 </semantics>
</math>

</p>

<p>From the definition of 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:81">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

, this is verification step 6.</p>

<p>This shows only that a correctly signed message will verify correctly; many other properties are required for a secure signature algorithm.</p>
<h2 id="security">Security</h2>

<p>In December 2010, a group calling itself <em>fail0verflow</em> announced recovery of the ECDSA private key used by <a class="uri" href="Sony" title="wikilink">Sony</a> to sign software for the <a href="PlayStation_3" title="wikilink">PlayStation 3</a> game console. However, this attack only worked because Sony did not properly implement the algorithm, because 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:82">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 was static instead of random. As pointed out in the <a href="#Signature_generation_algorithm" title="wikilink">Signature generation algorithm</a> Section above, this makes 

<math display="inline" id="Elliptic_Curve_Digital_Signature_Algorithm:83">
 <semantics>
  <msub>
   <mi>d</mi>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{A}
  </annotation>
 </semantics>
</math>

 solvable and the entire algorithm useless.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>On March 29, 2011, two researchers published an <a href="International_Association_for_Cryptologic_Research" title="wikilink">IACR</a> paper<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> demonstrating that it is possible to retrieve a TLS private key of a server using <a class="uri" href="OpenSSL" title="wikilink">OpenSSL</a> that authenticates with Elliptic Curves DSA over a binary <a href="Field_(mathematics)" title="wikilink">field</a> via a <a href="timing_attack" title="wikilink">timing attack</a>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> The vulnerability was fixed in OpenSSL 1.0.0e.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>In August 2013, it was revealed that bugs in some implementations of the <a href="Java_(programming_language)" title="wikilink">Java</a> class <a href="http://docs.oracle.com/javase/7/docs/api/java/security/SecureRandom.html">SecureRandom</a> sometimes generated collisions in the k value. As discussed above, this allowed solution of the private key, in turn allowing stealing <a href="bitcoin" title="wikilink">bitcoins</a> from the containing wallet on <a href="Android_(operating_system)" title="wikilink">Android</a> app implementations, which use Java and rely on ECDSA to authenticate transactions.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>This issue can be prevented by deterministic generation of <em>k</em>, as described by RFC 6979.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Elliptic_curve_cryptography" title="wikilink">Elliptic curve cryptography</a></li>
<li><a class="uri" href="EdDSA" title="wikilink">EdDSA</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>Accredited Standards Committee <a href="http://www.x9.org">X9</a>, <em>American National Standard X9.62-2005, Public Key Cryptography for the Financial Services Industry, The Elliptic Curve Digital Signature Algorithm (ECDSA)</em>, November 16, 2005.</li>
<li>Certicom Research, <a href="http://www.secg.org/download/aid-780/sec1-v2.pdf"><em>Standards for efficient cryptography, SEC 1: Elliptic Curve Cryptography</em></a>, Version 2.0, May 21, 2009.</li>
<li>López, J. and Dahab, R. <a href="http://citeseer.ist.psu.edu/333066.html"><em>An Overview of Elliptic Curve Cryptography</em></a>, Technical Report IC-00-10, State University of Campinas, 2000.</li>
<li>Daniel J. Bernstein, <a href="http://cr.yp.to/papers/pippenger.pdf">Pippenger's exponentiation algorithm</a>, 2002.</li>
<li>Daniel R. L. Brown, <em>Generic Groups, Collision Resistance, and ECDSA</em>, Designs, Codes and Cryptography, <strong>35</strong>, 119–152, 2005. <a href="http://eprint.iacr.org/2002/026">ePrint version</a></li>
<li>Ian F. Blake, Gadiel Seroussi, and Nigel P. Smart, editors, <em>Advances in Elliptic Curve Cryptography</em>, London Mathematical Society Lecture Note Series 317, Cambridge University Press, 2005.</li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf">Digital Signature Standard; includes info on ECDSA</a></li>
</ul>

<p>"</p>

<p><a href="Category:Digital_signature_schemes" title="wikilink">Category:Digital signature schemes</a> <a href="Category:Elliptic_curve_cryptography" title="wikilink">Category:Elliptic curve cryptography</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf">NIST FIPS 186-4, July 2013, pp. 19 and 26</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://events.ccc.de/congress/2010/Fahrplan/attachments/1780_27c3_console_hacking_2010.pdf">Console Hacking 2010 - PS3 Epic Fail</a>, page 123–128<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="https://www.kb.cert.org/vuls/id/536044">Vulnerability Note VU#536044 - OpenSSL leaks ECDSA private key through a remote timing attack</a><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
</ol>
</section>
</body>
</html>
