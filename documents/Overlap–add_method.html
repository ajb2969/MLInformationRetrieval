<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1614">Overlap–add method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Overlap–add method</h1>
<hr/>

<p>In <a href="signal_processing" title="wikilink">signal processing</a>, the <strong>overlap–add method (OA, OLA)</strong> is an efficient way to evaluate the discrete <a class="uri" href="convolution" title="wikilink">convolution</a> of a very long signal 

<math display="inline" id="Overlap–add_method:0">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[n]
  </annotation>
 </semantics>
</math>

 with a <a href="finite_impulse_response" title="wikilink">finite impulse response</a> (FIR) filter 

<math display="inline" id="Overlap–add_method:1">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h[n]
  </annotation>
 </semantics>
</math>

<strong>:</strong></p>

<p>

<math display="inline" id="Overlap–add_method:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>n</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo>*</mo>
      <mi>h</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo rspace="7.5pt" stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mpadded width="+5pt">
     <mover>
      <mo movablelimits="false">=</mo>
      <mi>def</mi>
     </mover>
    </mpadded>
    <mrow>
     <mstyle displaystyle="true">
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>m</mi>
        <mo>=</mo>
        <mrow>
         <mo>-</mo>
         <mi mathvariant="normal">∞</mi>
        </mrow>
       </mrow>
       <mi mathvariant="normal">∞</mi>
      </munderover>
     </mstyle>
     <mrow>
      <mrow>
       <mrow>
        <mi>h</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mi>m</mi>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
       <mo>⋅</mo>
       <mi>x</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mi>m</mi>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mstyle displaystyle="true">
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>m</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>M</mi>
      </munderover>
     </mstyle>
     <mrow>
      <mrow>
       <mrow>
        <mi>h</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mi>m</mi>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
       <mo>⋅</mo>
       <mi>x</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mi>m</mi>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>y</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <ci>x</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>n</ci>
        </apply>
       </apply>
       <ci>h</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <eq></eq>
      <ci>def</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>m</ci>
         <apply>
          <minus></minus>
          <infinity></infinity>
         </apply>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <times></times>
         <ci>h</ci>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <ci>m</ci>
         </apply>
        </apply>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <ci>m</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>m</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>M</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <times></times>
         <ci>h</ci>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <ci>m</ci>
         </apply>
        </apply>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <ci>m</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle y[n]=x[n]*h[n]\ \stackrel{\mathrm{def}}{=}\ \sum_{m=-\infty}^{%
\infty}h[m]\cdot x[n-m]=\sum_{m=1}^{M}h[m]\cdot x[n-m],
  </annotation>
 </semantics>
</math>


</p>

<p>where <em>h</em>[<em>m</em>] = 0 for <em>m</em> outside the region [1, <em>M</em>].</p>

<p>The concept is to divide the problem into multiple convolutions of <em>h</em>[<em>n</em>] with short segments of 

<math display="inline" id="Overlap–add_method:3">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[n]
  </annotation>
 </semantics>
</math>

<strong>:</strong></p>

<p>

<math display="block" id="Overlap–add_method:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo rspace="7.5pt" stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mover>
    <mo movablelimits="false">=</mo>
    <mi>def</mi>
   </mover>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>x</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mrow>
           <mi>k</mi>
           <mi>L</mi>
          </mrow>
         </mrow>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mi>n</mi>
        <mo>=</mo>
        <mrow>
         <mn>1</mn>
         <mo>,</mo>
         <mn>2</mn>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo>,</mo>
         <mi>L</mi>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mtext>otherwise</mtext>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <ci>def</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <apply>
         <times></times>
         <ci>k</ci>
         <ci>L</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <ci>n</ci>
      <list>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
       <ci>normal-…</ci>
       <ci>L</ci>
      </list>
     </apply>
     <cn type="integer">0</cn>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}[n]\ \stackrel{\mathrm{def}}{=}\begin{cases}x[n+kL]&n=1,2,\ldots,L\\
0&\textrm{otherwise},\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>L</em> is an arbitrary segment length. Then<strong>:</strong></p>

<p>

<math display="block" id="Overlap–add_method:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>k</mi>
     </munder>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>k</mi>
      </msub>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mrow>
         <mi>k</mi>
         <mi>L</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <apply>
         <times></times>
         <ci>k</ci>
         <ci>L</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[n]=\sum_{k}x_{k}[n-kL],\,
  </annotation>
 </semantics>
</math>

</p>

<p>and <em>y</em>[<em>n</em>] can be written as a sum of short convolutions<strong>:</strong></p>

<p>

<math display="inline" id="Overlap–add_method:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mstyle displaystyle="true">
        <munder>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mi>k</mi>
        </munder>
       </mstyle>
       <mrow>
        <msub>
         <mi>x</mi>
         <mi>k</mi>
        </msub>
        <mrow>
         <mo stretchy="false">[</mo>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mrow>
           <mi>k</mi>
           <mi>L</mi>
          </mrow>
         </mrow>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mo>*</mo>
     <mi>h</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>k</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <apply>
           <times></times>
           <ci>k</ci>
           <ci>L</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>h</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle y[n]=\left(\sum_{k}x_{k}[n-kL]\right)*h[n]
  </annotation>
 </semantics>
</math>


</p>

<p>where  

<math display="inline" id="Overlap–add_method:7">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo rspace="7.5pt" stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mpadded width="+5pt">
    <mover>
     <mo movablelimits="false">=</mo>
     <mi>def</mi>
    </mover>
   </mpadded>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>k</mi>
      </msub>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>n</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>*</mo>
     <mi>h</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo rspace="4.2pt" stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <ci>def</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>n</ci>
       </apply>
      </apply>
      <ci>h</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}[n]\ \stackrel{\mathrm{def}}{=}\ x_{k}[n]*h[n]\,
  </annotation>
 </semantics>
</math>

  is zero outside the region [1, <em>L</em> + <em>M</em> − 1].  And for any parameter  

<math display="inline" id="Overlap–add_method:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>N</mi>
    <mo>≥</mo>
    <mrow>
     <mrow>
      <mi>L</mi>
      <mo>+</mo>
      <mi>M</mi>
     </mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>N</ci>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <ci>L</ci>
      <ci>M</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\geq L+M-1,\,
  </annotation>
 </semantics>
</math>

  it is equivalent to the 

<math display="inline" id="Overlap–add_method:9">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>N</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\,
  </annotation>
 </semantics>
</math>

-point <a href="circular_convolution" title="wikilink">circular convolution</a> of 

<math display="inline" id="Overlap–add_method:10">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo rspace="4.2pt" stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}[n]\,
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Overlap–add_method:11">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo rspace="4.2pt" stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h[n]\,
  </annotation>
 </semantics>
</math>


  in the region [1, <em>N</em>].</p>

<p>The advantage is that the <a href="circular_convolution" title="wikilink">circular convolution</a> can be computed very efficiently as follows, according to the <a href="Discrete_Fourier_transform#Circular_convolution_theorem_and_cross-correlation_theorem" title="wikilink">circular convolution theorem</a><strong>:</strong></p>

<p>where FFT and IFFT refer to the <a href="fast_Fourier_transform" title="wikilink">fast Fourier transform</a> and inverse fast Fourier transform, respectively, evaluated over 

<math display="inline" id="Overlap–add_method:12">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 discrete points.</p>
<h2 id="the-algorithm">The algorithm</h2>
<figure><b>(Figure)</b>
<figcaption>Figure 1: the overlap–add method</figcaption>
</figure>

<p>Fig. 1 sketches the idea of the overlap–add method. The signal 

<math display="inline" id="Overlap–add_method:13">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[n]
  </annotation>
 </semantics>
</math>

 is first partitioned into non-overlapping sequences, then the <a href="discrete_Fourier_transform" title="wikilink">discrete Fourier transforms</a> of the sequences 

<math display="inline" id="Overlap–add_method:14">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}[n]
  </annotation>
 </semantics>
</math>

 are evaluated by multiplying the FFT of 

<math display="inline" id="Overlap–add_method:15">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}[n]
  </annotation>
 </semantics>
</math>

 with the FFT of 

<math display="inline" id="Overlap–add_method:16">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h[n]
  </annotation>
 </semantics>
</math>


. After recovering of 

<math display="inline" id="Overlap–add_method:17">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}[n]
  </annotation>
 </semantics>
</math>

 by inverse FFT, the resulting output signal is reconstructed by overlapping and adding the 

<math display="inline" id="Overlap–add_method:18">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}[n]
  </annotation>
 </semantics>
</math>

 as shown in the figure. The overlap arises from the fact that a linear convolution is always longer than the original sequences. In the early days of development of the fast Fourier transform, 

<math display="inline" id="Overlap–add_method:19">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 was often chosen to be a power of 2 for efficiency, but further development has revealed efficient transforms for larger prime factorizations of L, reducing computational sensitivity to this parameter. A <a class="uri" href="pseudocode" title="wikilink">pseudocode</a> of the algorithm is the following:</p>

<p><code>   </code><strong><code>Algorithm</code> <code>1</code></strong><code> (</code><em><code>OA</code> <code>for</code> <code>linear</code> <code>convolution</code></em><code>)</code><br/>
<code>   Evaluate the best value of N and L (L&gt;0, N = M+L-1 nearest to power of 2).</code><br/>
<code>   Nx = length(x);</code><br/>
<code>   H = FFT(h,N)       </code><span style="color:green;"><code>(</code><em><code>zero-padded</code> <code>FFT</code></em><code>)</code></span><br/>
<code>   i = 1</code><br/>
<code>   y = zeros(1, M+Nx-1)</code><br/>
<code>   </code><strong><code>while</code></strong><code> i </code><code>(</code><em><code>Nx:</code> <code>the</code> <code>last</code> <code>index</code> <code>of</code> <code>x[n]</code></em><code>)</code><br/>
<code>       il = min(i+L-1,Nx)</code><br/>
<code>       yt = IFFT( FFT(x(i:il),N) * H, N)</code><br/>
<code>       k  = min(i+N-1,M+Nx-1)</code><br/>
<code>       y(i:k) = y(i:k) + yt(1:k-i+1)    </code><span style="color:green;"><code>(</code><em><code>add</code> <code>the</code> <code>overlapped</code> <code>output</code> <code>blocks</code></em><code>)</code></span><br/>
<code>       i = i+L</code><br/>
<code>   </code><strong><code>end</code></strong></p>
<h2 id="circular-convolution-with-the-overlapadd-method">Circular convolution with the overlap–add method</h2>

<p>When sequence <em>x</em>[<em>n</em>] is periodic, and <em>N</em><sub><em>x</em></sub> is the period, then <em>y</em>[<em>n</em>] is also periodic, with the same period.  To compute one period of y[n], Algorithm 1 can first be used to convolve <em>h</em>[<em>n</em>] with just one period of <em>x</em>[<em>n</em>].  In the region <em>M</em> ≤ <em>n</em> ≤ <em>N</em><sub><em>x</em></sub>,  the resultant <em>y</em>[<em>n</em>] sequence is correct.  And if the next <em>M</em> − 1 values are added to the first <em>M</em> − 1 values, then the region 1 ≤ <em>n</em> ≤ <em>N</em><sub><em>x</em></sub> will represent the desired convolution. The modified pseudocode is<strong>:</strong></p>

<p><code>   </code><strong><code>Algorithm</code> <code>2</code></strong><code> (</code><em><code>OA</code> <code>for</code> <code>circular</code> <code>convolution</code></em><code>)</code><br/>
<code>   Evaluate Algorithm 1</code><br/>
<code>   y(1:M-1) = y(1:M-1) + y(Nx+1:Nx+M-1)</code><br/>
<code>   y = y(1:Nx)</code><br/>
<code>   </code><strong><code>end</code></strong></p>
<h2 id="cost-of-the-overlap-add-method">Cost of the overlap-add method</h2>

<p>The cost of the convolution can be associated to the number of complex multiplications involved in the operation. The major computational effort is due to the FFT operation, which for a radix-2 algorithm applied to a signal of length 

<math display="inline" id="Overlap–add_method:20">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 roughly calls for 

<math display="inline" id="Overlap–add_method:21">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mi>N</mi>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>2</mn>
     </msub>
     <mi>N</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>N</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <cn type="integer">2</cn>
      </apply>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=\frac{N}{2}\log_{2}N
  </annotation>
 </semantics>
</math>


 complex multiplications. It turns out that the number of complex multiplications of the overlap-add method are:</p>

<p>

<math display="block" id="Overlap–add_method:22">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mrow>
     <mi>O</mi>
     <mi>A</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>⌈</mo>
     <mfrac>
      <msub>
       <mi>N</mi>
       <mi>x</mi>
      </msub>
      <mrow>
       <mrow>
        <mi>N</mi>
        <mo>-</mo>
        <mi>M</mi>
       </mrow>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </mfrac>
     <mo>⌉</mo>
    </mrow>
    <mi>N</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>log</mi>
        <mn>2</mn>
       </msub>
       <mi>N</mi>
      </mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo rspace="4.2pt">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ceiling></ceiling>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>N</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <minus></minus>
         <ci>N</ci>
         <ci>M</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>N</ci>
     <apply>
      <plus></plus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <cn type="integer">2</cn>
       </apply>
       <ci>N</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{OA}=\left\lceil\frac{N_{x}}{N-M+1}\right\rceil N\left(\log_{2}N+1\right)\,
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Overlap–add_method:23">
 <semantics>
  <msub>
   <mi>C</mi>
   <mrow>
    <mi>O</mi>
    <mi>A</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <apply>
     <times></times>
     <ci>O</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{OA}
  </annotation>
 </semantics>
</math>

 accounts for the FFT+filter multiplication+IFFT operation.</p>

<p>The additional cost of the 

<math display="inline" id="Overlap–add_method:24">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>L</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{L}
  </annotation>
 </semantics>
</math>

 sections involved in the circular version of the overlap–add method is usually very small and can be neglected for the sake of simplicity. The best value of 

<math display="inline" id="Overlap–add_method:25">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 can be found by numerical search of the minimum of 

<math display="inline" id="Overlap–add_method:26">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>C</mi>
     <mrow>
      <mi>O</mi>
      <mi>A</mi>
     </mrow>
    </msub>
    <mrow>
     <mo>(</mo>
     <mi>N</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>C</mi>
     <mrow>
      <mi>O</mi>
      <mi>A</mi>
     </mrow>
    </msub>
    <mrow>
     <mo>(</mo>
     <msup>
      <mn>2</mn>
      <mi>m</mi>
     </msup>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <apply>
       <times></times>
       <ci>O</ci>
       <ci>A</ci>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <apply>
       <times></times>
       <ci>O</ci>
       <ci>A</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{OA}\left(N\right)=C_{OA}\left(2^{m}\right)
  </annotation>
 </semantics>
</math>

 by spanning the integer 

<math display="inline" id="Overlap–add_method:27">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 in the range 

<math display="inline" id="Overlap–add_method:28">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo>(</mo>
     <mi>M</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>m</mi>
   <mo>≤</mo>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo>(</mo>
     <msub>
      <mi>N</mi>
      <mi>x</mi>
     </msub>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <cn type="integer">2</cn>
      </apply>
      <ci>M</ci>
     </apply>
     <ci>m</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log_{2}\left(M\right)\leq m\leq\log_{2}\left(N_{x}\right)
  </annotation>
 </semantics>
</math>

. Being 

<math display="inline" id="Overlap–add_method:29">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 a power of two, the FFTs of the overlap–add method are computed efficiently. Once evaluated the value of 

<math display="inline" id="Overlap–add_method:30">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 it turns out that the optimal partitioning of 

<math display="inline" id="Overlap–add_method:31">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[n]
  </annotation>
 </semantics>
</math>

 has 

<math display="inline" id="Overlap–add_method:32">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mi>M</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <ci>M</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=N-M+1
  </annotation>
 </semantics>
</math>

. For comparison, the cost of the standard circular convolution of 

<math display="inline" id="Overlap–add_method:33">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[n]
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Overlap–add_method:34">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h[n]
  </annotation>
 </semantics>
</math>

 is:</p>

<p>

<math display="block" id="Overlap–add_method:35">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>S</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>N</mi>
     <mi>x</mi>
    </msub>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>log</mi>
        <mn>2</mn>
       </msub>
       <msub>
        <mi>N</mi>
        <mi>x</mi>
       </msub>
      </mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo rspace="4.2pt">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>N</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{S}=N_{x}\left(\log_{2}N_{x}+1\right)\,
  </annotation>
 </semantics>
</math>

</p>

<p>Hence the cost of the overlap–add method scales almost as 

<math display="inline" id="Overlap–add_method:36">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo>(</mo>
    <mrow>
     <msub>
      <mi>N</mi>
      <mi>x</mi>
     </msub>
     <mrow>
      <msub>
       <mi>log</mi>
       <mn>2</mn>
      </msub>
      <mi>N</mi>
     </mrow>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <cn type="integer">2</cn>
      </apply>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(N_{x}\log_{2}N\right)
  </annotation>
 </semantics>
</math>

 while the cost of the standard circular convolution method is almost 

<math display="inline" id="Overlap–add_method:37">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo>(</mo>
    <mrow>
     <msub>
      <mi>N</mi>
      <mi>x</mi>
     </msub>
     <mrow>
      <msub>
       <mi>log</mi>
       <mn>2</mn>
      </msub>
      <msub>
       <mi>N</mi>
       <mi>x</mi>
      </msub>
     </mrow>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(N_{x}\log_{2}N_{x}\right)
  </annotation>
 </semantics>
</math>

. However such functions accounts only for the cost of the complex multiplications, regardless of the other operations involved in the algorithm. A direct measure of the computational time required by the algorithms is of much interest. Fig. 2 shows the ratio of the measured time to evaluate a standard circular convolution using   with the time elapsed by the same convolution using the overlap–add method in the form of Alg 2, vs. the sequence and the filter length. Both algorithms have been implemented under <a class="uri" href="Matlab" title="wikilink">Matlab</a>. The bold line represent the boundary of the region where the overlap–add method is faster (ratio&gt;1) than the standard circular convolution. Note that the overlap–add method in the tested cases can be three times faster than the standard method.</p>
<figure><b>(Figure)</b>
<figcaption>Figure 2: Ratio between the time required by   and the time required by the overlap–add Alg. 2 to evaluate a complex circular convolution, vs the sequence length 

<math display="inline" id="Overlap–add_method:38">
 <semantics>
  <msub>
   <mi>N</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{x}
  </annotation>
 </semantics>
</math>

 and the filter length 

<math display="inline" id="Overlap–add_method:39">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

.</figcaption>
</figure>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Overlap–save_method" title="wikilink">Overlap–save method</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>

<p>"</p>

<p><a href="Category:Signal_processing" title="wikilink">Category:Signal processing</a> <a class="uri" href="Category:Transforms" title="wikilink">Category:Transforms</a> <a href="Category:Fourier_analysis" title="wikilink">Category:Fourier analysis</a> <a href="Category:Numerical_analysis" title="wikilink">Category:Numerical analysis</a></p>
</body>
</html>
