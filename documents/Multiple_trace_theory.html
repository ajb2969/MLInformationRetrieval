<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="318">Multiple trace theory</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Multiple trace theory</h1>
<hr>'''Multiple Trace Theory (MTT)''' is a [[memory consolidation]] model advanced as an alternative model to strength theory. It posits that each time some information is presented to a person, it is neurally encoded in a unique memory trace composed of a combination of its attributes.<ref name="Semon">{{cite book|last=Semon|first=RW|title=Mnemonic psychology|year=1923|publisher=George Allen &amp; Unwin|location=London}}</ref> Further support for this theory came in the 1960s from empirical findings that people could remember specific attributes about an object without remembering the object itself.<ref name="Underwood">{
<p>{cite journal|last=Underwood|first=BJ|title=Some correlates of item repetition in free-recall learning|journal=Journal of Verbal Learning and Verbal Behavior|year=1969|volume=8|pages=83‚Äì94|doi=10.1016/s0022-5371(69)80015-0}} The mode in which the information is presented and subsequently encoded can be flexibly incorporated into the model. This memory trace is unique from all others resembling it due to differences in some aspects of the item's attributes, and all memory traces incorporated since birth are combined into a multiple-trace representation in the brain.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> In memory research, a mathematical formulation of this theory can successfully explain empirical phenomena observed in <a href="Recognition_memory" title="wikilink">recognition</a> and <a href="Recall_(memory)" title="wikilink">recall</a> tasks.</p>
<h2 id="attributes">Attributes</h2>

<p>The attributes an item possesses form its trace and can fall into many categories. When an item is committed to memory, information from each of these attributional categories is encoded into the item's trace. There may be a kind of semantic categorization at play, whereby an individual trace is incorporated into overarching concepts of an object. For example, when a person sees a pigeon, a trace is added to the ‚Äúpigeon‚Äù cluster of traces within his or her mind. This new ‚Äúpigeon‚Äù trace, while distinguishable and divisible from other instances of pigeons that the person may have seen within his or her life, serves to support the more general and overarching concept of a pigeon.</p>
<h3 id="physical">Physical</h3>

<p>Physical attributes of an item encode information about physical properties of a presented item. For a word, this could include color, font, spelling, and size, while for a picture, the equivalent aspects could be shapes and colors of objects. It has been shown experimentally that people who are unable to recall an individual word can sometimes recall the first or last letter or even rhyming words,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> all aspects encoded in the physical orthography of a word's trace. Even when an item is not presented visually, when encoded, it may have some physical aspects based on a visual representation of the item.</p>
<h3 id="contextual">Contextual</h3>

<p>Contextual attributes are a broad class of attributes that define the internal and external features that are simultaneous with presentation of the item. Internal context is a sense of the internal network that a trace evokes.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> This may range from aspects of an individual's mood to other semantic associations the presentation of the word evokes. On the other hand, external context encodes information about the spatial and temporal aspects as information is being presented. This may reflect time of day or weather, for example. Interestingly, spatial attributes can refer both to physical environment and imagined environment. The <a href="method_of_loci" title="wikilink">method of loci</a>, a mnemonic strategy incorporating an imagined spatial position, assigns relative spatial positions to different items memorized and then "walking through" these assigned positions to remember the items.</p>
<h3 id="modal">Modal</h3>

<p>Modality attributes possess information as to the method by which an item was presented. The most frequent types of modalities in an experimental setting are auditory and visual. It should be noted, however, that any sensory modality may be utilized practically.</p>
<h3 id="classifying">Classifying</h3>

<p>These attributes refer to the categorization of items presented. Items that fit into the same categories will have the same class attributes. For example, if the item ‚Äútouchdown‚Äù were presented, it would evoke the overarching concept of ‚Äúfootball‚Äù or perhaps, more generally, ‚Äúsports‚Äù, and it would likely share class attributes with "endzone" and other elements that fit into the same concept. A single item may fit into different concepts at the time it is presented depending on other attributes of the item, like context. For example, the word "star" might fall into the class of astronomy after visiting a space museum or a class with words like "celebrity" or "famous" after seeing a movie.</p>
<h2 id="mathematical-formulation">Mathematical Formulation</h2>

<p>The mathematical formulation of traces allows for a model of memory as an ever-growing matrix that is continuously receiving and incorporating information in the form of a vectors of attributes. Multiple trace theory states that every item ever encoded, from birth to death, will exist in this matrix as multiple traces. This is done by giving every possible attribute some numerical value to classify it as it is encoded, so each encoded memory will have a unique set of numerical attributes.</p>
<h3 id="matrix-definition-of-traces">Matrix Definition of Traces</h3>

<p>By assigning numerical values to all possible attributes, it is convenient to construct a <a href="column_vector" title="wikilink">column vector</a> representation of each encoded item. This vector representation can also be fed into computational models of the brain like <a href="neural_networks" title="wikilink">neural networks</a>, which take as inputs vectorial "memories" and simulate their biological encoding through neurons.</p>

<p>Formally, one can denote an encoded memory by numerical assignments to all of its possible attributes. If two items are perceived to have the same color or experienced in the same context, the numbers denoting their color and contextual attributes, respectively, will be relatively close. Suppose we encode a total of <em>L</em> attributes anytime we see an object. Then, when a memory is encoded, it can be written as <strong>m<sub>1</sub></strong> with <em>L</em> total numerical entries in a column vector:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Multiple_trace_theory:0">
 <semantics>
  <mrow>
   <msub>
    <mi>ùê¶</mi>
    <mn>ùüè</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msub>
         <mi>m</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msub>
         <mi>m</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msub>
         <mi>m</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>3</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">‚ãÆ</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msub>
         <mi>m</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>L</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ùê¶</ci>
     <cn type="integer">1</cn>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">3</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <ci>normal-‚ãÆ</ci>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>L</ci>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{m_{1}}=\begin{bmatrix}m_{1}(1)\\
m_{1}(2)\\
m_{1}(3)\\
\vdots\\
m_{1}(L)\end{bmatrix}
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
</dd>
</dl>

<p>A subset of the <em>L</em> attributes will be devoted to contextual attributes, a subset to physical attributes, and so on. One underlying assumption of multiple trace theory is that, when we construct multiple memories, we organize the attributes in the same order. Thus, we can similarly define vectors <strong>m<sub>2</sub></strong>, <strong>m<sub>3</sub></strong>, ..., <strong>m<sub>n</sub></strong> to account for <em>n</em> total encoded memories. Multiple trace theory states that these memories come together in our brain to form a memory matrix from the simple concatenation of the individual memories:</p>
<dl>
<dd><dl>
<dd><math>\mathbf{M} = \begin{bmatrix} \mathbf{m_1} &amp; \mathbf{m_2} &amp; \mathbf{m_3} &amp; \cdots &amp; \mathbf{m_n} \end{bmatrix}
</math></dd>
</dl>
</dd>
</dl>

<p>= \begin{bmatrix} m_{1}(1) &amp; m_{2}(1) &amp; m_{3}(1) &amp; \cdots &amp; m_{n}(1) \\ m_{1}(2) &amp; m_{2}(2) &amp; m_{3}(2) &amp; \cdots &amp; m_{n}(2) \\ \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots \\m_{1}(L) &amp; m_{2}(L) &amp; m_{3}(L) &amp; \cdots &amp; m_{n}(L)\end{bmatrix} .</p>

<p>For <em>L</em> total attributes and <em>n</em> total memories, <strong>M</strong> will have <em>L</em> rows and <em>n</em> columns. Note that, although the <em>n</em> traces are combined into a large memory matrix, each trace is individually accessible as a column in this matrix.</p>

<p>In this formulation, the <em>n</em> different memories are made to be more or less independent of each other. However, items presented in some setting together will become tangentially associated by the similarity of their context vectors. If multiple items are made associated with each other and intentionally encoded in that manner, say an item <strong>a</strong> and an item <strong>b</strong>, then the memory for these two can be constructed, with each having <em>k</em> attributes as follows:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Multiple_trace_theory:1">
 <semantics>
  <mrow>
   <msub>
    <mi>ùê¶</mi>
    <mi>ùêöùêõ</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>a</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>a</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">‚ãÆ</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>a</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>k</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>b</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>b</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">‚ãÆ</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>b</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>k</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mi>ùêö</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi>ùêõ</mi>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùê¶</ci>
      <ci>ùêöùêõ</ci>
     </apply>
     <matrix>
      <matrixrow>
       <apply>
        <times></times>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <ci>normal-‚ãÆ</ci>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>k</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <ci>b</ci>
        <cn type="integer">2</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <ci>normal-‚ãÆ</ci>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <matrix>
      <matrixrow>
       <ci>ùêö</ci>
      </matrixrow>
      <matrixrow>
       <ci>ùêõ</ci>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{m_{ab}}=\begin{bmatrix}a(1)\\
a(2)\\
\vdots\\
a(k)\\
b(1)\\
b(2)\\
\vdots\\
b(k)\end{bmatrix}=\begin{bmatrix}\mathbf{a}\\
\mathbf{b}\end{bmatrix}
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
</dd>
</dl>
<h3 id="context-as-a-stochastic-vector">Context as a Stochastic Vector</h3>

<p>When items are learned one after another, it is tempting to say that they are learned in the same temporal context. However, in reality, there are subtle variations in context. Hence, contextual attributes are often considered to be changing over time as modeled by a <a href="stochastic_process" title="wikilink">stochastic process</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Considering a vector of only <em>r</em> total context attributes <strong>t<sub>i</sub></strong> that represents the context of memory <strong>m<sub>i</sub></strong>, the context of the next-encoded memory is given by <strong>t<sub>i+1</sub></strong>:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Multiple_trace_theory:2">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ùê≠</mi>
     <mrow>
      <mi>ùê¢</mi>
      <mo>+</mo>
      <mn>ùüè</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ùê£</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>ùê≠</mi>
      <mi>ùê¢</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ùê£</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>œµ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ùê£</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùê≠</ci>
      <apply>
       <plus></plus>
       <ci>ùê¢</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>ùê£</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ùê≠</ci>
       <ci>ùê¢</ci>
      </apply>
      <ci>ùê£</ci>
     </apply>
     <apply>
      <times></times>
      <ci>œµ</ci>
      <ci>ùê£</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{t_{i+1}(j)}=\mathbf{t_{i}(j)+\epsilon(j)}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>so,</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Multiple_trace_theory:3">
 <semantics>
  <mrow>
   <msub>
    <mi>ùê≠</mi>
    <mrow>
     <mi>ùê¢</mi>
     <mo>+</mo>
     <mn>ùüè</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mrow>
         <msub>
          <mi>t</mi>
          <mi>i</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>1</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>œµ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>1</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mrow>
         <msub>
          <mi>t</mi>
          <mi>i</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>2</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>œµ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>2</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">‚ãÆ</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mrow>
         <msub>
          <mi>t</mi>
          <mi>i</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>r</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>œµ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>r</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ùê≠</ci>
     <apply>
      <plus></plus>
      <ci>ùê¢</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <ci>i</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <times></times>
        <ci>œµ</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <ci>i</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <ci>œµ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <ci>normal-‚ãÆ</ci>
     </matrixrow>
     <matrixrow>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <ci>i</ci>
        </apply>
        <ci>r</ci>
       </apply>
       <apply>
        <times></times>
        <ci>œµ</ci>
        <ci>r</ci>
       </apply>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{t_{i+1}}=\begin{bmatrix}t_{i}(1)+\epsilon(1)\\
t_{i}(2)+\epsilon(2)\\
\vdots\\
t_{i}(r)+\epsilon(r)\end{bmatrix}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Here, <strong>Œµ(j)</strong> is a random number sampled from a <a href="Gaussian_distribution" title="wikilink">Gaussian distribution</a>.</p>
<h3 id="summed-similarity">Summed Similarity</h3>

<p>As explained in the subsequent section, the hallmark of multiple trace theory is an ability to compare some probe item to the pre-existing matrix of encoded memories. This simulates the memory search process, whereby we can determine whether we have ever seen the probe before as in recognition tasks or whether the probe gives rise to another previously encoded memory as in cued recall.</p>

<p>First, the probe <strong>p</strong> is encoded as an attribute vector. Continuing with the preceding example of the memory matrix <strong>M</strong>, the probe will have <em>L</em> entries:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Multiple_trace_theory:4">
 <semantics>
  <mrow>
   <mi>ùê©</mi>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">‚ãÆ</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>L</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ùê©</ci>
    <matrix>
     <matrixrow>
      <apply>
       <times></times>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>p</ci>
       <cn type="integer">2</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <ci>normal-‚ãÆ</ci>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>L</ci>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{p}=\begin{bmatrix}p(1)\\
p(2)\\
\vdots\\
p(L)\end{bmatrix}
  </annotation>
 </semantics>
</math>


.
</dd>
</dl>
</dd>
</dl>

<p>This <strong>p</strong> is then compared one by one to all pre-existing memories (trace) in <strong>M</strong> by determining the <a href="Euclidean_distance" title="wikilink">Euclidean distance</a> between <strong>p</strong> and each <strong>m<sub>i</sub></strong>:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Multiple_trace_theory:5">
 <semantics>
  <mrow>
   <mrow>
    <mo>‚à•</mo>
    <mrow>
     <mi>ùê©</mi>
     <mo>-</mo>
     <msub>
      <mi>ùê¶</mi>
      <mi>ùê¢</mi>
     </msub>
    </mrow>
    <mo>‚à•</mo>
   </mrow>
   <mo>=</mo>
   <msqrt>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>L</mi>
     </msubsup>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>p</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>j</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <msub>
          <mi>m</mi>
          <mi>i</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>j</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <minus></minus>
      <ci>ùê©</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ùê¶</ci>
       <ci>ùê¢</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <root></root>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>L</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>j</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <ci>i</ci>
         </apply>
         <ci>j</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\|\mathbf{p-m_{i}}\right\|=\sqrt{\sum_{j=1}^{L}(p(j)-m_{i}(j))^{2}}
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
</dd>
</dl>

<p>Due to the stochastic nature of context, it is almost never the case in multiple trace theory that a probe item exactly matches an encoded memory. Still, high similarity between <strong>p</strong> and <strong>m<sub>i</sub></strong> is indicated by a small Euclidean distance. Hence, another operation must be performed on the distance that leads to very low similarity for great distance and very high similarity for small distance. A linear operation does not eliminate low-similarity items harshly enough. Intuitively, an exponential decay model seems most suitable:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Multiple_trace_theory:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mi>i</mi>
    <mi>m</mi>
    <mi>i</mi>
    <mi>l</mi>
    <mi>a</mi>
    <mi>r</mi>
    <mi>i</mi>
    <mi>t</mi>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ùê©</mi>
     <mo>,</mo>
     <msub>
      <mi>ùê¶</mi>
      <mi>ùê¢</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>œÑ</mi>
      <mrow>
       <mo>‚à•</mo>
       <mrow>
        <mi>ùê©</mi>
        <mo>-</mo>
        <msub>
         <mi>ùê¶</mi>
         <mi>ùê¢</mi>
        </msub>
       </mrow>
       <mo>‚à•</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>i</ci>
     <ci>m</ci>
     <ci>i</ci>
     <ci>l</ci>
     <ci>a</ci>
     <ci>r</ci>
     <ci>i</ci>
     <ci>t</ci>
     <ci>y</ci>
     <interval closure="open">
      <ci>ùê©</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ùê¶</ci>
       <ci>ùê¢</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>œÑ</ci>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <apply>
         <minus></minus>
         <ci>ùê©</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ùê¶</ci>
          <ci>ùê¢</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   similarity(\mathbf{p,m_{i}})=e^{-\tau\left\|\mathbf{p-m_{i}}\right\|}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where <strong>œÑ</strong> is a decay parameter that can be experimentally assigned. We can go on to then define similarity to the entire memory matrix by a summed similarity <strong>SS(p,M)</strong> between the probe <strong>p</strong> and the memory matrix <strong>M</strong>:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Multiple_trace_theory:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>ùêíùêí</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ùê©</mi>
     <mo>,</mo>
     <mi>ùêå</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">‚àë</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>œÑ</mi>
       <mrow>
        <mo>‚à•</mo>
        <mrow>
         <mi>ùê©</mi>
         <mo>-</mo>
         <msub>
          <mi>ùê¶</mi>
          <mi>ùê¢</mi>
         </msub>
        </mrow>
        <mo>‚à•</mo>
       </mrow>
      </mrow>
     </mrow>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">‚àë</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>œÑ</mi>
       <msqrt>
        <mrow>
         <mstyle displaystyle="false">
          <msubsup>
           <mo largeop="true" symmetric="true">‚àë</mo>
           <mrow>
            <mi>j</mi>
            <mo>=</mo>
            <mn>1</mn>
           </mrow>
           <mi>L</mi>
          </msubsup>
         </mstyle>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mrow>
             <mi>p</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>j</mi>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
            <mo>-</mo>
            <mrow>
             <msub>
              <mi>m</mi>
              <mi>i</mi>
             </msub>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>j</mi>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mn>2</mn>
         </msup>
        </mrow>
       </msqrt>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>ùêíùêí</ci>
      <interval closure="open">
       <ci>ùê©</ci>
       <ci>ùêå</ci>
      </interval>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>œÑ</ci>
         <apply>
          <csymbol cd="latexml">norm</csymbol>
          <apply>
           <minus></minus>
           <ci>ùê©</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>ùê¶</ci>
            <ci>ùê¢</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>œÑ</ci>
         <apply>
          <root></root>
          <apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <sum></sum>
             <apply>
              <eq></eq>
              <ci>j</ci>
              <cn type="integer">1</cn>
             </apply>
            </apply>
            <ci>L</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <minus></minus>
             <apply>
              <times></times>
              <ci>p</ci>
              <ci>j</ci>
             </apply>
             <apply>
              <times></times>
              <apply>
               <csymbol cd="ambiguous">subscript</csymbol>
               <ci>m</ci>
               <ci>i</ci>
              </apply>
              <ci>j</ci>
             </apply>
            </apply>
            <cn type="integer">2</cn>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{SS(p,M)}=\sum_{i=1}^{n}e^{-\tau\left\|\mathbf{p-m_{i}}\right\|}=\sum_{%
i=1}^{n}e^{-\tau\sqrt{\sum_{j=1}^{L}(p(j)-m_{i}(j))^{2}}}
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
</dd>
</dl>

<p>If the probe item is very similar to even one of the encoded memories, <strong>SS</strong> receives a large boost. For example, given <strong>m<sub>1</sub></strong> as a probe item, we will get a near 0 distance (not exactly due to context) for i=1, which will add nearly the maximal boost possible to <strong>SS</strong>. To differentiate from background similarity (there will always be some low similarity to context or a few attributes for example), <strong>SS</strong> is often compared to some arbitrary criterion. If it is higher than the criterion, then the probe is considered among those encoded. The criterion can be varied based on the nature of the task and the desire to prevent <a href="false_alarms" title="wikilink">false alarms</a>. Thus, multiple trace theory predicts that, given some cue, the brain can compare that cue to a criterion to answer questions like "has this cue been experienced before?" (recognition) or "what memory does this cue elicit?" (cued recall), which are applications of summed similarity described below.</p>
<h2 id="applications-to-memory-phenomena">Applications to Memory Phenomena</h2>
<h3 id="recognition">Recognition</h3>

<p>Multiple trace theory fits well into the conceptual framework for <a href="recognition_memory" title="wikilink">recognition</a>. Recognition requires an individual to determine whether or not they have seen an item before. For example, facial recognition is determining whether one has seen a face before. When asked this for a successfully encoded item (something that has indeed been seen before), recognition should occur with high probability. In the mathematical framework of this theory, we can model recognition of an individual probe item <strong>p</strong> by summed similarity with a criterion. We translate the test item into an attribute vector as done for the encoded memories and compared to every trace ever encountered. If summed similarity passes the criterion, we say we have seen the item before. Summed similarity is expected to be very low if the item has never been seen but relatively higher if it has due to the similarity of the probe's attributes to some memory of the memory matrix.</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Multiple_trace_theory:8">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mi>e</mi>
    <mi>c</mi>
    <mi>o</mi>
    <mi>g</mi>
    <mi>n</mi>
    <mi>i</mi>
    <mi>z</mi>
    <mi>i</mi>
    <mi>n</mi>
    <mpadded width="+3.3pt">
     <mi>g</mi>
    </mpadded>
    <mi>p</mi>
    <mo rspace="5.8pt" stretchy="false">)</mo>
   </mrow>
   <mo rspace="5.8pt">=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ùêíùêí</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ùê©</mi>
     <mo>,</mo>
     <mi>ùêå</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>></mo>
    <mi>c</mi>
    <mi>r</mi>
    <mi>i</mi>
    <mi>t</mi>
    <mi>e</mi>
    <mi>r</mi>
    <mi>i</mi>
    <mi>o</mi>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">r</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <csymbol cd="unknown">c</csymbol>
     <csymbol cd="unknown">o</csymbol>
     <csymbol cd="unknown">g</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <csymbol cd="unknown">i</csymbol>
     <csymbol cd="unknown">z</csymbol>
     <csymbol cd="unknown">i</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <csymbol cd="unknown">g</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">SS</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">M</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <gt></gt>
     <csymbol cd="unknown">c</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <csymbol cd="unknown">i</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <csymbol cd="unknown">i</csymbol>
     <csymbol cd="unknown">o</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(recognizing~{}p)~{}=~{}P(\mathbf{SS(p,M)}>criterion)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>This can be applied both to individual item recognition and associative recognition for two or more items together.</p>
<h3 id="cued-recall">Cued Recall</h3>

<p>The theory can also account for <a href="cued_recall" title="wikilink">cued recall</a>. Here, some cue is given that is meant to elicit an item out of memory. For example, a factual question like "Who was the first President of the United States?" is a cue to elicit the answer of "George Washington". In the <strong>"ab"</strong> framework described above, we can take all attributes present in a cue and list consider these the <strong>a</strong> item in an encoded association as we try to recall the <strong>b</strong> portion of the <strong>m<sub>ab</sub></strong> memory. In this example, attributes like "first", "President", and "United States" will be combined to form the <strong>a</strong> vector, which will have already been formulated into the <strong>m<sub>ab</sub></strong> memory whose <strong>b</strong> values encode "George Washington". Given <strong>a</strong>, there are two popular models for how we can successfully recall <strong>b</strong>:</p>

<p>1) We can go through and determine similarity (not summed similarity, see above for distinction) to every item in memory for the <strong>a</strong> attributes, then pick whichever memory has the highest similarity for the <strong>a</strong>. Whatever <strong>b</strong>-type attributes we are linked to gives what we recall. The <strong>m<sub>ab</sub></strong> memory gives best chance of recall since its <strong>a</strong> elements will have high similarity to the cue <strong>a</strong>. Still, since recall does not always occur, we can say that the similarity must pass a criterion for recall to occur at all. This is similar to how the IBM machine <a href="Watson_(computer)" title="wikilink">Watson</a> operates. Here, the similarity compares only the <strong>a</strong>-type attributes of <strong>a</strong> to m<sub>ab</sub>.</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Multiple_trace_theory:9">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mi>e</mi>
    <mi>c</mi>
    <mi>a</mi>
    <mi>l</mi>
    <mi>l</mi>
    <mi>i</mi>
    <mi>n</mi>
    <mpadded width="+3.3pt">
     <mi>g</mi>
    </mpadded>
    <msub>
     <mi>m</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </msub>
    <mo rspace="5.8pt" stretchy="false">)</mo>
   </mrow>
   <mo rspace="5.8pt">=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mi>i</mi>
    <mi>m</mi>
    <mi>i</mi>
    <mi>l</mi>
    <mi>a</mi>
    <mi>r</mi>
    <mi>i</mi>
    <mi>t</mi>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <msub>
      <mi>m</mi>
      <mrow>
       <mi>a</mi>
       <mi>b</mi>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>></mo>
    <mi>c</mi>
    <mi>r</mi>
    <mi>i</mi>
    <mi>t</mi>
    <mi>e</mi>
    <mi>r</mi>
    <mi>i</mi>
    <mi>o</mi>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">r</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <csymbol cd="unknown">c</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">l</csymbol>
     <csymbol cd="unknown">l</csymbol>
     <csymbol cd="unknown">i</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <csymbol cd="unknown">g</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <csymbol cd="unknown">i</csymbol>
     <csymbol cd="unknown">m</csymbol>
     <csymbol cd="unknown">i</csymbol>
     <csymbol cd="unknown">l</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <csymbol cd="unknown">i</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <gt></gt>
     <csymbol cd="unknown">c</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <csymbol cd="unknown">i</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <csymbol cd="unknown">i</csymbol>
     <csymbol cd="unknown">o</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(recalling~{}m_{ab})~{}=~{}P(similarity(a,m_{ab})>criterion)
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
</dl>

<p>2) We can use a probabilistic choice rule to determine probability of recalling an item as proportional to its similarity. This is akin to throwing a dart at a dartboard with bigger areas represented by larger similarities to the cue item. Mathematically speaking, given the cue <strong>a</strong>, the probability of recalling the desired memory <strong>m<sub>ab</sub></strong> is:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Multiple_trace_theory:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>r</mi>
      <mi>e</mi>
      <mi>c</mi>
      <mi>a</mi>
      <mi>l</mi>
      <mi>l</mi>
      <mi>i</mi>
      <mi>n</mi>
      <mpadded width="+3.3pt">
       <mi>g</mi>
      </mpadded>
      <msub>
       <mi>m</mi>
       <mrow>
        <mi>a</mi>
        <mi>b</mi>
       </mrow>
      </msub>
     </mrow>
     <mo rspace="5.8pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="5.8pt">=</mo>
   <mfrac>
    <mrow>
     <mi>s</mi>
     <mi>i</mi>
     <mi>m</mi>
     <mi>i</mi>
     <mi>l</mi>
     <mi>a</mi>
     <mi>r</mi>
     <mi>i</mi>
     <mi>t</mi>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <msub>
       <mi>m</mi>
       <mrow>
        <mi>a</mi>
        <mi>b</mi>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mi>S</mi>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo>,</mo>
       <mi>M</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>e</mi>
      <mi>r</mi>
      <mi>r</mi>
      <mi>o</mi>
      <mi>r</mi>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>e</ci>
      <ci>c</ci>
      <ci>a</ci>
      <ci>l</ci>
      <ci>l</ci>
      <ci>i</ci>
      <ci>n</ci>
      <ci>g</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>i</ci>
      <ci>m</ci>
      <ci>i</ci>
      <ci>l</ci>
      <ci>a</ci>
      <ci>r</ci>
      <ci>i</ci>
      <ci>t</ci>
      <ci>y</ci>
      <interval closure="open">
       <ci>a</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <apply>
         <times></times>
         <ci>a</ci>
         <ci>b</ci>
        </apply>
       </apply>
      </interval>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>S</ci>
       <ci>S</ci>
       <interval closure="open">
        <ci>a</ci>
        <ci>M</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>e</ci>
       <ci>r</ci>
       <ci>r</ci>
       <ci>o</ci>
       <ci>r</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(recalling~{}m_{ab})~{}=~{}\frac{similarity(a,m_{ab})}{SS(a,M)+error}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>In computing both similarity and summed similarity, we only consider relations among <strong>a</strong>-type attributes. We add the <strong>error</strong> term because without it, the probability of recalling any memory in <strong>M</strong> will be 1, but there are certainly times when recall does not occur at all.</p>
<h3 id="other-common-results-explained">Other Common Results Explained</h3>

<p>Phenomena in memory associated with repetition, word frequency, recency, forgetting, and contiguity, among others, can be easily explained in the realm of multiple trace theory. Memory is known to improve with repeated exposure to items. For example, hearing a word several times in a list will improve recognition and recall of that word later on. This is because repeated exposure simply adds the memory into the ever-growing memory matrix, so summed similarity for this memory will be larger and thus more likely to pass the criterion.</p>

<p>In recognition, very common words are harder to recognize as part of a memorized list, when tested, than rare words. This is known as the word frequency effect and can be explained by multiple trace theory as well. For common words, summed similarity will be relatively high, whether the word was seen in the list or not, because it is likely that the word has been encountered and encoded in the memory matrix several times throughout life. Thus, the brain typically selects a higher criterion in determining whether common words are part of a list, making them harder to successfully select. However, rarer words are typically encountered less throughout life and so their presence in the memory matrix is limited. Hence, low overall summed similarity will lead to a more lax criterion. If the word was present in the list, high context similarity at time of test and other attribute similarity will lead to enough boost in summed similarity to excel past criterion and thus recognize the rare word successfully.</p>

<p>Recency in the <a href="serial_position_effect#Recency" title="wikilink">serial position effect</a> can be explained because more recent memories encoded will share a temporal context most similar to the present context, as the stochastic nature of time will not have had as pronounced an effect. Thus, context similarity will be high for recently encoded items, so overall similarity will be relatively higher for these items as well. The stochastic contextual drift is also thought to account for forgetting because the context in which a memory was encoded is lost over time, so summed similarity for an item only presented in that context will decrease over time.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Finally, empirical data have shown a <a href="contiguity#Psychology" title="wikilink">contiguity effect</a>, whereby items that are presented together temporally, even though they may not be encoded as a single memory as in the <strong>"ab"</strong> paradigm described above, are more likely to be remembered together. This can be considered a result of low contextual drift between items remembered together, so the contextual similarity between two items presented together is high.</p>
<h2 id="shortcomings-of-multiple-trace-theory">Shortcomings of Multiple Trace Theory</h2>

<p>One of the biggest shortcomings of multiple trace theory is the requirement of some item with which to compare the memory matrix when determining successful encoding. As mentioned above, this works quite well in recognition and cued recall, but there is a glaring inability to incorporate <a href="free_recall" title="wikilink">free recall</a> into the model. Free recall requires an individual to freely remember some list of items. Although the very act of asking to recall may act as a cue that can then elicit cued recall techniques, it is unlikely that the cue is unique enough to reach a summed similarity criterion or to otherwise achieve a high probability of recall.</p>

<p>Another major issue lies in translating the model to biological relevance. It is hard to imagine that the brain has unlimited capacity to keep track of such a large matrix of memories and continue expanding it with every item with which it has ever been presented. Furthermore, searching through this matrix is an exhaustive process that would not be relevant on biological time scales.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a class="uri" href="Category:Memory" title="wikilink">Category:Memory</a> <a class="uri" href="Category:Neuroscience" title="wikilink">Category:Neuroscience</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">‚Ü©</a></li>
<li id="fn2"><a href="#fnref2">‚Ü©</a></li>
<li id="fn3"><a href="#fnref3">‚Ü©</a></li>
<li id="fn4"><a href="#fnref4">‚Ü©</a></li>
<li id="fn5"><a href="#fnref5">‚Ü©</a></li>
<li id="fn6"><a href="#fnref6">‚Ü©</a></li>
<li id="fn7"><a href="#fnref7">‚Ü©</a></li>
</ol>
</section>
</ref></hr></body>
</html>
