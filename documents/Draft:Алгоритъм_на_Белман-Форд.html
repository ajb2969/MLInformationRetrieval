<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1740">Draft:Алгоритъм на Белман-Форд</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Draft:Алгоритъм на Белман-Форд</h1>
<hr/>

<p><strong>Алгоритъмът на Белман-Форд</strong> е <a class="uri" href="алгоритъм" title="wikilink">алгоритъм</a>, който пресмята най - късите пътища от един връх към всички останали върхове в един граф. По - бавен е от <a href="алгоритъма_на_Дейкстра" title="wikilink">алгоритъма на Дейкстра</a>, но много по - гъвкав, когато се обхождат графи, на които ръбовете им са отрицателни числа. Алгоритъмът е именуван на двама от създателите си, Ричард Белман и Лестър Форд Младши, които публикуват алгоритъма през 1958 и 1956, съответно; обаче, Едуард Ф. Мур също публикува същия алгоритъм през 1957 и поради тази причина понякога се среща като <strong>Алгоритъм на Белман-Форд-Мур</strong>.</p>

<p>Този алгоритъм е полезен за намирането на отрицателни стойности в обхождането на различни графи. Ако един граф съдържа в себе си "отрицателен цикъл" (т.е. цикъл, на който сумата на върховете има отрицателна стойност), който може да се срещне още от самото начало, после няма намерен по - <em>евтин</em> път: всеки път може да се нарече евтин при още едно обхождане на отрицателните цикли. В такъв случай алгоритъмът на Белман-Форд може да намери отрицателните цикли и да каже за тяхното наличие.</p>
<h2 id="algorithm">Algorithm</h2>
<figure><b>(Figure)</b>
<figcaption> В този примерен граф, допускаме, че A е началния връх и ребрата са в най-неблагоприятна поредност, отдясно наляво, изискващ пълни |V|−1 или 4 итерации, за да се пресметне разстоянието. Обратно, ако ребрата са в най-благоприятна поредност, отляво надясно, алогритъма клони към една итерация.</figcaption>
</figure>

<p>Също както <a href="Алгоритъм_на_Дейкстра" title="wikilink">Алгоритъм на Дейкстра</a>, Белман-Форд е базиран на принципа на <a href="Relaxation_(iterative_method)" title="wikilink">relaxation</a>, в който приблизителното правилно разстояние постепенно се заменя от по-точни стойности, докато се достигне до оптимално решение. И в двата алгоритъма, приблизителното разстояние до всеки връх е винаги надценено спрямо действителното разстояние и се заменя минимума на неговата стара стойност с дължината на новото намерено разстояние. Обаче, <a href="Алгоритъм_на_Дейкстра" title="wikilink">Алгоритъм на Дейкстра</a> избира върхът с най-минимално тегло, който още не е бил обработен и извършва релакционния процес на всички ребра, излизащи от него. В противоположност, Алгоритъмът на Белман-Форд просто релаксира <em>всички</em> ребра, и прави това 

<math display="inline" id="Draft:Алгоритъм_на_Белман-Форд:0">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">|</mo>
<mi>V</mi>
<mo stretchy="false">|</mo>
</mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<apply>
<abs></abs>
<ci>V</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |V|-1
  </annotation>
</semantics>
</math>

 пъти, където 

<math display="inline" id="Draft:Алгоритъм_на_Белман-Форд:1">
<semantics>
<mrow>
<mo stretchy="false">|</mo>
<mi>V</mi>
<mo stretchy="false">|</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<abs></abs>
<ci>V</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |V|
  </annotation>
</semantics>
</math>

 е броят на върховете в графа. Във всяко от тези повторения, броят на върховете с точно пресметнати разстояния расте, от което следва че всички върхове ще имат точни разстояния. Този метод позволява на Алгоритъма на Белман-Форд да бъде приложен на по-широк клас от входни данни, отклокото <a href="Алгоритъм_на_Дейкстра" title="wikilink">Алгоритъм на Дейкстра</a>. Белман-Форд протича 

<math display="inline" id="Draft:Алгоритъм_на_Белман-Форд:2">
<semantics>
<mrow>
<mi>O</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mo stretchy="false">|</mo>
<mi>V</mi>
<mo stretchy="false">|</mo>
</mrow>
<mo>⋅</mo>
<mrow>
<mo stretchy="false">|</mo>
<mi>E</mi>
<mo stretchy="false">|</mo>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>O</ci>
<apply>
<ci>normal-⋅</ci>
<apply>
<abs></abs>
<ci>V</ci>
</apply>
<apply>
<abs></abs>
<ci>E</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   O(|V|\cdot|E|)
  </annotation>
</semantics>
</math>

 пъти, където 

<math display="inline" id="Draft:Алгоритъм_на_Белман-Форд:3">
<semantics>
<mrow>
<mo stretchy="false">|</mo>
<mi>V</mi>
<mo stretchy="false">|</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<abs></abs>
<ci>V</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |V|
  </annotation>
</semantics>
</math>

 и 

<math display="inline" id="Draft:Алгоритъм_на_Белман-Форд:4">
<semantics>
<mrow>
<mo stretchy="false">|</mo>
<mi>E</mi>
<mo stretchy="false">|</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<abs></abs>
<ci>E</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |E|
  </annotation>
</semantics>
</math>

 са броят на върховете и ребрата респективно.</p>

<p><strong><code>function</code></strong><code> BellmanFord(</code><em><code>list</code></em><code> vertices, </code><em><code>list</code></em><code> edges, </code><em><code>vertex</code></em><code> source)</code><br/>
<code>   ::distance[],predecessor[]</code><br/>
<br/>
<code>   </code><em><code>//</code> <code>This</code> <code>implementation</code> <code>takes</code> <code>in</code> <code>a</code> <code>graph,</code> <code>represented</code> <code>as</code></em><br/>
<code>   </code><em><code>//</code> <code>lists</code> <code>of</code> <code>vertices</code> <code>and</code> <code>edges,</code> <code>and</code> <code>fills</code> <code>two</code> <code>arrays</code></em><br/>
<code>   </code><em><code>//</code> <code>(distance</code> <code>and</code> <code>predecessor)</code> <code>with</code> <code>shortest-path</code></em><br/>
<code>   </code><em><code>//</code> <code>(less</code> <code>cost/distance/metric)</code> <code>information</code></em><br/>
<br/>
<code>   </code><em><code>//</code> <code>Step</code> <code>1:</code> <code>initialize</code> <code>graph</code></em><br/>
<code>   </code><strong><code>for</code> <code>each</code></strong><code> vertex v </code><strong><code>in</code></strong><code> vertices:</code><br/>
<code>       </code><strong><code>if</code></strong><code> v </code><strong><code>is</code></strong><code> source </code><strong><code>then</code></strong><code> distance[v] := 0</code><br/>
<code>       </code><strong><code>else</code></strong><code> distance[v] := </code><strong><code>inf</code></strong><br/>
<code>       predecessor[v] := </code><strong><code>null</code></strong><br/>
<br/>
<code>   </code><em><code>//</code> <code>Step</code> <code>2:</code> <code>relax</code> <code>edges</code> <code>repeatedly</code></em><br/>
<code>   </code><br/>
<code>   </code><strong><code>for</code></strong><code> i </code><strong><code>from</code></strong><code> 1 </code><strong><code>to</code></strong><code> size(vertices)-1:</code><br/>
<code>       </code><strong><code>for</code> <code>each</code></strong><code> edge (u, v) </code><strong><code>with</code></strong><code> weight w </code><strong><code>in</code></strong><code> edges:</code><br/>
<code>           </code><strong><code>if</code></strong><code> distance[u] + w </code><code>i</code><code>, за която ребрата са сканирани алгоритъмът намира всички най-къси пътища в най-дългите </code>
<math display="inline" id="Draft:Алгоритъм_на_Белман-Форд:5">
<semantics>
<mi>i</mi>
<annotation-xml encoding="MathML-Content">
<ci>i</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   i
  </annotation>
</semantics>
</math>
<code> ребра. Докато най-дългият възможен път без цикъл може да бъде </code>
<math display="inline" id="Draft:Алгоритъм_на_Белман-Форд:6">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">|</mo>
<mi>V</mi>
<mo stretchy="false">|</mo>
</mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<apply>
<abs></abs>
<ci>V</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |V|-1
  </annotation>
</semantics>
</math>
<code> ребра, ребрата трябва да бъдат сканирани </code>
<math display="inline" id="Draft:Алгоритъм_на_Белман-Форд:7">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">|</mo>
<mi>V</mi>
<mo stretchy="false">|</mo>
</mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<apply>
<abs></abs>
<ci>V</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |V|-1
  </annotation>
</semantics>
</math>
<code> пъти за да е сигурно, че е намерен най-късия път за всички върхове. Последното сканиране на всички върхове се изпълнява и ако някое разстояние се обнови, тогава път с дължина </code>
<math display="inline" id="Draft:Алгоритъм_на_Белман-Форд:8">
<semantics>
<mrow>
<mo stretchy="false">|</mo>
<mi>V</mi>
<mo stretchy="false">|</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<abs></abs>
<ci>V</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |V|
  </annotation>
</semantics>
</math>
<code> ребра е намерен. Това може да се случи само ако съществува един отрицателен цикъл в графа.</code></p>
<h2 id="доказателство-за-коректност">Доказателство за коректност</h2>

<p>Правилността на алгоритъма може да се докаже чрез <a href="математическа_индукция" title="wikilink">математическа индукция</a>. Твърдението доказано чрез индукцията е:</p>

<p><strong>Лема</strong>. След <em>i</em> повторения на <em>for</em> цикъл:</p>
<ul>
<li>Ако разстоянието(<em>u</em>) не е безкрайност, то е равно на някой от пътищата между връх <em>s</em> и връх <em>u</em>;</li>
<li>Ако има път от връх <em>s</em> до връх <em>u</em> с не повече от <em>i</em> ребра, то тогава разстоянието(u) е не по-голямо от дължината на най-късия път от връх <em>s</em> до връх <em>u</em> с не повече от <em>i</em> ребра.</li>
</ul>

<p><strong>Доказателство</strong>. Основният случай на индукция се разглежда за <code>i=0</code> и момента преди <em>for</em> цикъла да е изпълнен за първи път.Тогава за началния връх <code>source.distance = 0</code>, което е вярно. За другите върхове <em>u</em>, <code>u.distance = '''infinity'''</code>, което също е вярно,защото няма път от началния връх до връх <em>u</em> с 0 ребра.</p>

<p>За индуктивния случай първо се доказва първата част.Разглежда се момента, когато разстоянието на върха се обнови чрез <code>v.distance := u.distance + uv.weight</code>. Чрез индуктивно предположение, <code>u.distance</code>е дължината на път от <em>началния връх</em> до връх <em>u</em>. Тогава <code>u.distance + uv.weight</code> е дължината на пътя от <em>s</em> до <em>v</em>, който минава през <em>u</em> и отива в <em>v</em>.</p>

<p>За втората част се разглежда най-късият път от <em>началния връх</em> до <em>u</em> с не повече от <em>i</em> ребра. Нека последният връх преди връх <em>u</em> от този път да бъде <em>v</em>. Тогава частта от пътя от <em>s</em> до <em>v</em> е най-късият път между <em>s</em> и <em>v</em> с не повече от <em>i-1</em> ребра. Чрез индуктивно предположение, <code>v.distance</code> след <em>i</em>−1 итерации е най-голямата дължина на този път. Следователно, <code>uv.weight + v.distance</code> е най-голямата дължина на пътя от <em>s</em> до <em>u</em>. На <em>i<sup>тата</sup></em> итерация, <code>u.distance</code> се сравнява с <code>uv.weight + v.distance</code>и ако стойността му е по-малка му се присвоява тази на <code>uv.weight + v.distance</code>.Затова след <em>i</em> итерации, <code>u.distance</code> e не по-голямо от най-краткия път от <em>s</em> до <em>u</em> който минава през не повече от <em>i</em> ребра.</p>

<p>Ако няма цикли с отрицателни тегла всеки най-кратък път преминава през всеки връх поне по веднъж, поради тази причина в стъпка 3 не могат да се направят оптимизации. Обратното, нека предположим, че подобрения не могат да бъдат направени. Тогава за всеки цикъл с върхове <em>v</em>[0], ..., <em>v</em>[<em>k</em>−1],</p>

<p><code>v[i].distance &lt;= v[(i-1) mod k].distance + v[(i-1) mod k]v[i].weight</code></p>

<p>Сумирайки през цикъла, условията за разстоянията <em>v</em>[<em>i</em>] и <em>v</em>[<em>i</em>−1 (mod <em>k</em>)] анулират</p>

<p><code>0 &lt;= sum from 1 to k of v[i-1 (mod k)]v[i].weight</code></p>

<p>т.е. всеки цикъл има положителни тегла.</p>
<h2 id="намиране-на-отрицателни-цикли">Намиране на отрицателни цикли</h2>

<p>Когато алгоритъмът се използва за да намери най-кратките пътища, наличието на отрицателни цикли е проблем, попречва на алгоритъма да намери правилен отговор. Тъй като той прекратява изпълнението си при намиране на отрицателен цикъл, Белман-Форд алгоритъмът може да бъде използван за приложения в които това е търсената цел - например в техники за анулиране на цикъл при анализи на мрежови поток.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="приложения-в-маршрутизация">Приложения в маршрутизация</h2>

<p>Разпространен вариант на алгоритъма на Белман-Форд се използва в дистанционно векторни протоколи за маршрутизация, например Маршрутизиращият Информационен Протокол (<a href="Routing_Information_Protocol" title="wikilink">RIP</a>). Алгоритъмът се разпределя, тъй като включва редица възли (рутери) в <a href="Автономна_система" title="wikilink">автономна система</a>, колекция от IP мрежи, обикновено собственост на един доставчик на интернет услуги (ISP). Той се състой от следните стъпки:</p>
<ol>
<li>Всеки възел изчислява разстоянията между себе си и всички други възли в автономната система и съхранява тази информация във вид на таблица.</li>
<li>Всеки възел изпраща своята таблица до всички съседни възли.</li>
<li>Когато един възел получава таблица от своите съседни възли, изчислява най-кратките маршрути до всички други възли и актуализира своята собствена таблица за да отрази промените.</li>
</ol>

<p>Основните недостатъци на Белман-Форд алгоритъма в тази настройка, са както следва:</p>
<ul>
<li>Той не мащабира добре.</li>
<li>Промените в <a href="Мрежови_топологии" title="wikilink">мрежовата топология</a> не са отразени бързо, тъй като актуализациите са разделени възел по възел.</li>
<li>Count to infinit if link or node failures render a node unreachable from some set of other nodes, those nodes may spend forever gradually increasing their estimates of the distance to it, and in the meantime there may be routing loops.</li>
</ul>
<h2 id="подобрения">Подобрения</h2>

<p>Алгоритъмът на Белман-Форд може да бъде подобрен на практика (въпреки че не в най-лошия случай) както виждаме в случай, че ако една итерация от основният цикъл на алгоритъма завърши без да са направени никакви промени, то тогава алгоритъмът може незабавно да бъде прекратен, като последващите итерации няма да направят никакви промени. При това условие с преждевременно прекратяване, основният цикъл в някои случаи може да използва много по-малко итерации от колкото |<em>V</em>| − 1, въпреки, че в най-лошият случай на алгоритъма, остава непроменен.</p>

<p>е описал още две подобрения на Белман-Форд алгоритъма за графика без негативни цикли; отново, докато на практика правят алгоритъма по-бърз, те не променят неговото O(|V|*|E|) в най-лошия случай обвързан с времето. Неговото първо подобрение намалява броя на стъпките за релаксация, които трябва да се извършат в рамките на всяка итерация на алгоритъма. If a vertex <em>v</em> has a distance value that has not changed since the last time the edges out of <em>v</em> were relaxed, then there is no need to relax the edges out of <em>v</em> a second time. In this way, as the number of vertices with correct distance values grows, the number whose outgoing edges need to be relaxed in each iteration shrinks, leading to a constant-factor savings in time for <a href="dense_graph" title="wikilink">dense graphs</a>.</p>

<p>Второто подобрение на Yen първо присвоява някакъв произволен линеен ред на всички върхове и след това разделя множеството от всички ръбове на две подгрупи. Първата група, <em>E<sub>f</sub></em>, съдържа всички ръбове (<em>v<sub>i</sub></em>, <em>v<sub>j</sub></em>) така, че <em>i</em> b<em>, съдържа ръбове (</em>v<sub>i</sub>'', <em>v<sub>j</sub></em>) така, че <em>i</em> &gt; <em>j</em>. Всеки връх се посещава в ред <em>v<sub>1</sub></em>, <em>v<sub>2</sub></em>, ..., <em>v</em><sub>|<em>V</em>|</sub>, релаксирайки всеки изходящ ръб от този връх в <em>E<sub>b</sub></em>.Всяка итерация от основният цикъл на алгоритъма, след първата, добавя най-малко два ръба към множеството от ръбове, чиито релаксирани разстояния намират най-кратките разстояния на пътищата: един от <em>E<sub>f</sub></em> и един от <em>E<sub>b</sub></em>. Тази модификация намалява броя на итерациите, в най-лошия случай, на основният цикъл на алгоритъма от |<em>V</em>| − 1 до |<em>V</em>|/2.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Друго подобрение, от , замества произволният линеен ред използван във второто подобрение на Yen, с произволна пермутация. Поради тази промянa, става много малка вероятността, най-лошият случай от подобрението на Yen (в който ръбовете, на най-краткият път, стриктно се редуват между двете подгрупи <em>E<sub>f</sub></em> and <em>E<sub>b</sub></em>) да се случи. С произволно разместена върхова подредба, <a href="Математическо_очакване" title="wikilink">очакваният</a> брой итерации, необходими в основният цикъл, е най-много |<em>V</em>|/3.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h3 id="original-sources">Original sources</h3>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h3 id="secondary-sources">Secondary sources</h3>
<ul>
<li></li>
<li>

<p>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Section 24.1: The Bellman–Ford algorithm, pp. 588–592. Problem 24-1, pp. 614–615. Third Edition. MIT Press, 2009. ISBN 978-0-262-53305-8. Section 24.1: The Bellman–Ford algorithm, pp. 651–655.</p></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="https://github.com/xtaci/algorithms/blob/master/include/bellman_ford.h">C++ code example</a></li>
<li><a href="http://code.google.com/p/annas/">Open Source Java Graph package with Bellman-Ford Algorithms</a></li>
</ul>

<p><a href=":Category:Graph_algorithms" title="wikilink">:Category:Graph algorithms</a> <a href=":Category:Polynomial-time_problems" title="wikilink">:Category:Polynomial-time problems</a> <a href=":Category:Articles_with_example_C_code" title="wikilink">:Category:Articles with example C code</a> <a href=":Category:Articles_with_example_pseudocode" title="wikilink">:Category:Articles with example pseudocode</a> <a href=":Category:Dynamic_programming" title="wikilink">:Category:Dynamic programming</a>"</p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2">Cormen et al., 2nd ed., Problem 24-1, pp. 614–615.<a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4">See Sedgewick's <a href="http://algs4.cs.princeton.edu/44sp/">web exercises</a> for <em>Algorithms</em>, 4th ed., exercises 5 and 11 (retrieved 2013-01-30).<a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
