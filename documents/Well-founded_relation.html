<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="20">Well-founded relation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Well-founded relation</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a <a href="binary_relation" title="wikilink">binary relation</a>, <em>R</em>, is <strong>well-founded</strong> (or <strong>wellfounded</strong>) on a <a href="Class_(set_theory)" title="wikilink">class</a> <em>X</em> if and only if every non-<a href="Empty_set" title="wikilink">empty</a> <a class="uri" href="subset" title="wikilink">subset</a> <em>S⊆X</em> has a <a href="minimal_element" title="wikilink">minimal element</a>; that is, some <a href="Element_(mathematics)" title="wikilink">element</a> <em>m</em> of any <em>S</em> is not related by <em>sRm</em> (for instance, "<em>m</em> is not smaller than") for the rest of the <em>s ∈ S</em>.</p>

<p>

<math display="block" id="Well-founded_relation:0">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>S</mi>
   <mo>⊆</mo>
   <mpadded width="+5pt">
    <mi>X</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>≠</mo>
    <mi mathvariant="normal">∅</mi>
    <mo>→</mo>
    <mo>∃</mo>
    <mi>m</mi>
    <mo>∈</mo>
    <mpadded width="+5.6pt">
     <mi>S</mi>
    </mpadded>
    <mo>∀</mo>
    <mi>s</mi>
    <mo>∈</mo>
    <mpadded width="+4.5pt">
     <mi>S</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo>,</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∉</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <subset></subset>
    <csymbol cd="unknown">X</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <neq></neq>
     <emptyset></emptyset>
     <ci>normal-→</ci>
     <exists></exists>
     <csymbol cd="unknown">m</csymbol>
     <in></in>
     <csymbol cd="unknown">S</csymbol>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">s</csymbol>
     <in></in>
     <csymbol cd="unknown">S</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">m</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <notin></notin>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall S\subseteq X\ (S\neq\varnothing\to\exists m\in S\;\;\forall s\in S\;\,%
(s,m)\notin R)
  </annotation>
 </semantics>
</math>

 (Some authors include an extra condition that <em>R</em> is <a href="Binary_relation#Relations_over_a_set" title="wikilink">set-like</a>, i.e., that the elements less than any given element form a set.)</p>

<p>Equivalently, assuming some <a href="axiom_of_choice" title="wikilink">choice</a>, a relation is well-founded if and only if it contains no countable <a href="infinite_descending_chain" title="wikilink">infinite descending chains</a>: that is, there is no infinite sequence <em>x</em><sub>0</sub>, <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ... of elements of <em>X</em> such that <em>x</em><sub><em>n</em>+1</sub> <em>R</em> <em>x</em><sub>n</sub> for every natural number <em>n</em>.</p>

<p>In <a href="order_theory" title="wikilink">order theory</a>, a <a href="partial_order" title="wikilink">partial order</a> is called well-founded if the corresponding <a href="strict_order" title="wikilink">strict order</a> is a well-founded relation. If the order is a <a href="total_order" title="wikilink">total order</a> then it is called a <a class="uri" href="well-order" title="wikilink">well-order</a>.</p>

<p>In <a href="set_theory" title="wikilink">set theory</a>, a set <em>x</em> is called a <strong>well-founded set</strong> if the <a href="element_(mathematics)" title="wikilink">set membership</a> relation is well-founded on the <a href="transitive_set" title="wikilink">transitive closure</a> of <em>x</em>. The <a href="axiom_of_regularity" title="wikilink">axiom of regularity</a>, which is one of the axioms of <a href="Zermelo–Fraenkel_set_theory" title="wikilink">Zermelo–Fraenkel set theory</a>, asserts that all sets are well-founded.</p>

<p>A relation <em>R</em> is <strong>converse well-founded</strong>, <strong>upwards well-founded</strong> or <strong>Noetherian</strong> on <em>X</em>, if the <a href="converse_relation" title="wikilink">converse relation</a> <em>R</em><sup>−1</sup> is well-founded on <em>X</em>. In this case <em>R</em> is also said to satisfy the <a href="ascending_chain_condition" title="wikilink">ascending chain condition</a>. In the context of <a class="uri" href="rewriting" title="wikilink">rewriting</a> systems, a Noetherian relation is also called <strong>terminating</strong>.</p>
<h2 id="induction-and-recursion">Induction and recursion</h2>

<p>An important reason that well-founded relations are interesting is because a version of <a href="transfinite_induction" title="wikilink">transfinite induction</a> can be used on them: if (<em>X</em>, <em>R</em>) is a well-founded relation, <em>P</em>(<em>x</em>) is some property of elements of <em>X</em>, and we want to show that</p>
<dl>
<dd><em>P</em>(<em>x</em>) holds for all elements <em>x</em> of <em>X</em>,
</dd>
</dl>

<p>it suffices to show that:</p>
<dl>
<dd>If <em>x</em> is an element of <em>X</em> and <em>P</em>(<em>y</em>) is true for all <em>y</em> such that <em>y R x</em>, then <em>P</em>(<em>x</em>) must also be true.
</dd>
</dl>

<p>That is,</p>

<p>

<math display="block" id="Well-founded_relation:1">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mo>∈</mo>
   <mpadded width="+1.7pt">
    <mi>X</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>∀</mo>
     <mi>y</mi>
     <mo>∈</mo>
     <mpadded width="+1.7pt">
      <mi>X</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+1.7pt">
       <mi>y</mi>
      </mpadded>
      <mpadded width="+1.7pt">
       <mi>R</mi>
      </mpadded>
      <mi>x</mi>
      <mo>→</mo>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>→</mo>
   <mo>∀</mo>
   <mi>x</mi>
   <mo>∈</mo>
   <mpadded width="+1.7pt">
    <mi>X</mi>
   </mpadded>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <in></in>
    <csymbol cd="unknown">X</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <in></in>
      <csymbol cd="unknown">X</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">y</csymbol>
       <csymbol cd="unknown">R</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">P</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">y</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <in></in>
    <csymbol cd="unknown">X</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\in X\,[(\forall y\in X\,(y\,R\,x\to P(y)))\to P(x)]\to\forall x\in X%
\,P(x).
  </annotation>
 </semantics>
</math>

 Well-founded induction is sometimes called Noetherian induction,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> after <a href="Emmy_Noether" title="wikilink">Emmy Noether</a>.</p>

<p>On par with induction, well-founded relations also support construction of objects by <a href="transfinite_recursion" title="wikilink">transfinite recursion</a>. Let (<em>X</em>, <em>R</em>) be a <a href="binary_relation#Relations_over_a_set" title="wikilink">set-like</a> well-founded relation and <em>F</em> a function that assigns an object <em>F</em>(<em>x</em>, <em>g</em>) to each pair of an element <em>x ∈ X</em> and a function <em>g</em> on the <a href="initial_segment" title="wikilink">initial segment</a> {<em>y</em>: <em>y</em> <em>R</em> <em>x</em>} of <em>X</em>. Then there is a unique function <em>G</em> such that for every <em>x ∈ X</em>,</p>

<p>

<math display="block" id="Well-founded_relation:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <msub>
      <mrow>
       <mi>G</mi>
       <mo fence="true">|</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">{</mo>
       <mi>y</mi>
       <mo>:</mo>
       <mrow>
        <mpadded width="+1.7pt">
         <mi>y</mi>
        </mpadded>
        <mpadded width="+1.7pt">
         <mi>R</mi>
        </mpadded>
        <mi>x</mi>
       </mrow>
       <mo stretchy="false">}</mo>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>F</ci>
     <interval closure="open">
      <ci>x</ci>
      <apply>
       <csymbol cd="latexml">evaluated-at</csymbol>
       <ci>G</ci>
       <apply>
        <csymbol cd="latexml">conditional-set</csymbol>
        <ci>y</ci>
        <apply>
         <times></times>
         <ci>y</ci>
         <ci>R</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(x)=F(x,G|_{\{y:y\,R\,x\}})
  </annotation>
 </semantics>
</math>

 That is, if we want to construct a function <em>G</em> on <em>X</em>, we may define <em>G</em>(<em>x</em>) using the values of <em>G</em>(<em>y</em>) for <em>y R x</em>.</p>

<p>As an example, consider the well-founded relation (<strong>N</strong>, <em>S</em>), where <strong>N</strong> is the set of all <a href="natural_numbers" title="wikilink">natural numbers</a>, and <em>S</em> is the graph of the successor function <em>x</em> → <em>x</em> + 1. Then induction on <em>S</em> is the usual <a href="mathematical_induction" title="wikilink">mathematical induction</a>, and recursion on <em>S</em> gives <a href="primitive_recursive_functions" title="wikilink">primitive recursion</a>. If we consider the order relation (<strong>N</strong>, 1, <em>n</em><sub>2</sub>) 1, <em>m</em><sub>2</sub>) if and only if <em>n</em><sub>1</sub> 1 and <em>n</em><sub>2</sub> 2.</p>
<ul>
<li>the set of all <a href="regular_expression" title="wikilink">regular expressions</a> over a fixed alphabet, with the order defined by <em>s</em> &lt; <em>t</em> if and only if <em>s</em> is a proper subexpression of <em>t</em>.</li>
<li>any class whose elements are sets, with the relation 

<math display="inline" id="Well-founded_relation:3">
 <semantics>
  <mo>∈</mo>
  <annotation-xml encoding="MathML-Content">
   <in></in>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in
  </annotation>
 </semantics>
</math>

 ("is an element of"). This is the <a href="axiom_of_regularity" title="wikilink">axiom of regularity</a>.</li>
<li>the nodes of any finite <a href="directed_acyclic_graph" title="wikilink">directed acyclic graph</a>, with the relation <em>R</em> defined such that <em>a R b</em> if and only if there is an edge from <em>a</em> to <em>b</em>.</li>
</ul>

<p>Examples of relations that are not well-founded include:</p>
<ul>
<li>the negative integers {-1, -2, -3, …}, with the usual order, since any unbounded subset has no least element.</li>
<li>The set of strings over a finite alphabet with more than one element, under the usual (<a href="lexicographic_ordering" title="wikilink">lexicographic</a>) order, since the sequence "B" &gt; "AB" &gt; "AAB" &gt; "AAAB" &gt; … is an infinite descending chain. This relation fails to be well-founded even though the entire set has a minimum element, namely the empty string.</li>
<li>the <a href="rational_number" title="wikilink">rational numbers</a> (or <a href="real_numbers" title="wikilink">reals</a>) under the standard ordering, since, for example, the set of positive rationals (or reals) lacks a minimum.</li>
</ul>
<h2 id="other-properties">Other properties</h2>

<p>If (<em>X</em>, 1 \geq 1 \geq 1 \geq \cdots. To avoid these trivial descending sequences, when working with a reflexive relation <em>R</em> it is common to use (perhaps implicitly) the alternate relation <em>R′</em> defined such that <em>a</em> <em>R′</em> <em>b</em> if and only if <em>a</em> <em>R</em> <em>b</em> and <em>a</em> ≠ <em>b</em>. In the context of the natural numbers, this means that the relation </p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Bourbaki, N. (1972) <em>Elements of mathematics. Commutative algebra</em>, Addison-Wesley.<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
