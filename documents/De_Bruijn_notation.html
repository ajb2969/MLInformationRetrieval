<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="995">De Bruijn notation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>De Bruijn notation</h1>
<hr/>

<p>In <a href="mathematical_logic" title="wikilink">mathematical logic</a>, the <strong>De Bruijn notation</strong> is a <a href="syntax_(logic)" title="wikilink">syntax</a> for terms in the <a href="λ_calculus" title="wikilink">λ calculus</a> invented by the <a href="Netherlands" title="wikilink">Dutch</a> <a class="uri" href="mathematician" title="wikilink">mathematician</a> <a href="Nicolaas_Govert_de_Bruijn" title="wikilink">Nicolaas Govert de Bruijn</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> It can be seen as a reversal of the usual syntax for the λ calculus where the <a href="argument_(computer_science)" title="wikilink">argument</a> in an application is placed next to its corresponding binder in the <a href="function_(mathematics)" title="wikilink">function</a> instead of after the latter's body.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>Terms (

<math display="inline" id="De_Bruijn_notation:0">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>,</mo>
   <mi>N</mi>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>M</ci>
    <ci>N</ci>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M,N,\ldots
  </annotation>
 </semantics>
</math>

) in the De Bruijn notation are either variables (

<math display="inline" id="De_Bruijn_notation:1">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

), or have one of two <em>wagon</em> prefixes. The <em>abstractor wagon</em>, written 

<math display="inline" id="De_Bruijn_notation:2">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>v</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [v]
  </annotation>
 </semantics>
</math>

, corresponds to the usual λ-binder of the <a href="λ_calculus" title="wikilink">λ calculus</a>, and the <em>applicator wagon</em>, written 

<math display="inline" id="De_Bruijn_notation:3">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>M</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M)
  </annotation>
 </semantics>
</math>

, corresponds to the argument in an application in the λ calculus.</p>

<p>

<math display="block" id="De_Bruijn_notation:4">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>,</mo>
   <mi>N</mi>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>:</mo>
   <mo rspace="7.5pt">:=</mo>
   <mpadded width="+5pt">
    <mi>v</mi>
   </mpadded>
   <mo rspace="7.5pt" stretchy="false">|</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>v</mi>
    <mo rspace="5.3pt" stretchy="false">]</mo>
   </mrow>
   <mpadded width="+5pt">
    <mi>M</mi>
   </mpadded>
   <mo rspace="7.5pt" stretchy="false">|</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo rspace="5.3pt" stretchy="false">)</mo>
   </mrow>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">M</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">N</csymbol>
    <ci>normal-,</ci>
    <ci>normal-…</ci>
    <ci>normal-:</ci>
    <csymbol cd="latexml">assign</csymbol>
    <csymbol cd="unknown">v</csymbol>
    <ci>normal-|</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">M</csymbol>
    <ci>normal-|</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">N</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M,N,...::=\ v\ |\ [v]\;M\ |\ (M)\;N
  </annotation>
 </semantics>
</math>

</p>

<p>Terms in the traditional syntax can be converted to the De Bruijn notation by defining an inductive function 

<math display="inline" id="De_Bruijn_notation:5">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℐ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℐ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{I}
  </annotation>
 </semantics>
</math>

 for which:</p>
<blockquote>

<p>

<math display="inline" id="De_Bruijn_notation:6">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mi class="ltx_font_mathcaligraphic">ℐ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi></mi>
      <mo>=</mo>
      <mi>v</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mi class="ltx_font_mathcaligraphic">ℐ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>λ</mi>
       <mi>v</mi>
       <mo rspace="7.5pt">.</mo>
       <mi>M</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi></mi>
      <mo>=</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>v</mi>
        <mo rspace="5.3pt" stretchy="false">]</mo>
       </mrow>
       <mi class="ltx_font_mathcaligraphic">ℐ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>M</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mi class="ltx_font_mathcaligraphic">ℐ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+2.8pt">
         <mi>M</mi>
        </mpadded>
        <mi>N</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi></mi>
       <mo>=</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi class="ltx_font_mathcaligraphic">ℐ</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>N</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi class="ltx_font_mathcaligraphic">ℐ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>M</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>.</mo>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <times></times>
      <ci>ℐ</ci>
      <ci>v</ci>
     </apply>
     <apply>
      <eq></eq>
      <csymbol cd="latexml">absent</csymbol>
      <ci>v</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">I</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">v</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">M</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <apply>
      <eq></eq>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>v</ci>
       </apply>
       <ci>ℐ</ci>
       <ci>M</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <ci>ℐ</ci>
      <apply>
       <times></times>
       <ci>M</ci>
       <ci>N</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <ci>ℐ</ci>
        <ci>N</ci>
       </apply>
       <ci>ℐ</ci>
       <ci>M</ci>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{aligned}\displaystyle\mathcal{I}(v)&\displaystyle=v\\
\displaystyle\mathcal{I}(\lambda v.\ M)&\displaystyle=[v]\;\mathcal{I}(M)\\
\displaystyle\mathcal{I}(M\;N)&\displaystyle=(\mathcal{I}(N))\mathcal{I}(M).%
\end{aligned}
  </annotation>
 </semantics>
</math>

</p>
</blockquote>

<p>All operations on λ-terms commute with respect to the 

<math display="inline" id="De_Bruijn_notation:7">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℐ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℐ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{I}
  </annotation>
 </semantics>
</math>

 translation. For example, the usual β-reduction,</p>

<p>

<math display="block" id="De_Bruijn_notation:8">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>v</mi>
    <mo rspace="7.5pt">.</mo>
    <mi>M</mi>
    <mo rspace="5.3pt" stretchy="false">)</mo>
   </mrow>
   <mi>N</mi>
   <msub>
    <mo>⟶</mo>
    <mi>β</mi>
   </msub>
   <mi>M</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>v</mi>
    <mo>:=</mo>
    <mi>N</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">N</csymbol>
    <ci></ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-⟶</ci>
     <ci>β</ci>
    </apply>
    <ci></ci>
    <csymbol cd="unknown">M</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">v</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda v.\ M)\;N\ \ \longrightarrow_{\beta}\ \ M[v:=N]
  </annotation>
 </semantics>
</math>

 in the De Bruijn notation is, predictably,</p>

<p>

<math display="block" id="De_Bruijn_notation:9">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo rspace="5.3pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>v</mi>
    <mo rspace="5.3pt" stretchy="false">]</mo>
   </mrow>
   <mi>M</mi>
   <msub>
    <mo>⟶</mo>
    <mi>β</mi>
   </msub>
   <mi>M</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>v</mi>
    <mo>:=</mo>
    <mi>N</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">M</csymbol>
    <ci></ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-⟶</ci>
     <ci>β</ci>
    </apply>
    <ci></ci>
    <csymbol cd="unknown">M</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">v</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (N)\;[v]\;M\ \ \longrightarrow_{\beta}\ \ M[v:=N].
  </annotation>
 </semantics>
</math>

</p>

<p>A feature of this notation is that abstractor and applicator wagons of β-redexes are paired like parentheses. For example, consider the stages in the β-reduction of the term 

<math display="inline" id="De_Bruijn_notation:10">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo rspace="5.3pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo rspace="5.3pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>u</mi>
    <mo rspace="5.3pt" stretchy="false">]</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo rspace="5.3pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>v</mi>
    <mo rspace="5.3pt" stretchy="false">]</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>w</mi>
    <mo rspace="5.3pt" stretchy="false">]</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Q</mi>
    <mo rspace="5.3pt" stretchy="false">)</mo>
   </mrow>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <ci>N</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>u</ci>
    </apply>
    <ci>P</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>v</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>w</ci>
    </apply>
    <ci>Q</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M)\;(N)\;[u]\;(P)\;[v]\;[w]\;(Q)\;z
  </annotation>
 </semantics>
</math>

, where the redexes are underlined:<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<blockquote>

<p>

<math display="inline" id="De_Bruijn_notation:11">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>M</mi>
       <mo rspace="5.3pt" stretchy="false">)</mo>
      </mrow>
      <mpadded width="+2.8pt">
       <munder accentunder="true">
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>N</mi>
          <mo rspace="5.3pt" stretchy="false">)</mo>
         </mrow>
         <mrow>
          <mo stretchy="false">[</mo>
          <mi>u</mi>
          <mo stretchy="false">]</mo>
         </mrow>
        </mrow>
        <mo>¯</mo>
       </munder>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>P</mi>
       <mo rspace="5.3pt" stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>v</mi>
       <mo rspace="5.3pt" stretchy="false">]</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>w</mi>
       <mo rspace="5.3pt" stretchy="false">]</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Q</mi>
       <mo rspace="5.3pt" stretchy="false">)</mo>
      </mrow>
      <mi>z</mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mpadded width="+5pt">
       <msub>
        <mo lspace="7.5pt">⟶</mo>
        <mi>β</mi>
       </msub>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>M</mi>
       <mo rspace="5.3pt" stretchy="false">)</mo>
      </mrow>
      <mpadded width="+2.8pt">
       <munder accentunder="true">
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>P</mi>
          <mrow>
           <mo stretchy="false">[</mo>
           <mi>u</mi>
           <mo>:=</mo>
           <mi>N</mi>
           <mo stretchy="false">]</mo>
          </mrow>
          <mo rspace="5.3pt" stretchy="false">)</mo>
         </mrow>
         <mrow>
          <mo stretchy="false">[</mo>
          <mi>v</mi>
          <mo stretchy="false">]</mo>
         </mrow>
        </mrow>
        <mo>¯</mo>
       </munder>
      </mpadded>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>w</mi>
       <mo rspace="5.3pt" stretchy="false">]</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Q</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>u</mi>
        <mo>:=</mo>
        <mi>N</mi>
        <mo stretchy="false">]</mo>
       </mrow>
       <mo rspace="5.3pt" stretchy="false">)</mo>
      </mrow>
      <mi>z</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mpadded width="+5pt">
       <msub>
        <mo lspace="7.5pt">⟶</mo>
        <mi>β</mi>
       </msub>
      </mpadded>
      <mpadded width="+2.8pt">
       <munder accentunder="true">
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>M</mi>
          <mo rspace="5.3pt" stretchy="false">)</mo>
         </mrow>
         <mrow>
          <mo stretchy="false">[</mo>
          <mi>w</mi>
          <mo stretchy="false">]</mo>
         </mrow>
        </mrow>
        <mo>¯</mo>
       </munder>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Q</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>u</mi>
        <mo>:=</mo>
        <mi>N</mi>
        <mo>,</mo>
        <mi>v</mi>
        <mo>:=</mo>
        <mi>P</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mi>u</mi>
         <mo>:=</mo>
         <mi>N</mi>
         <mo stretchy="false">]</mo>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
       <mo rspace="5.3pt" stretchy="false">)</mo>
      </mrow>
      <mi>z</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mpadded width="+5pt">
       <msub>
        <mo lspace="7.5pt">⟶</mo>
        <mi>β</mi>
       </msub>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Q</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>u</mi>
        <mo>:=</mo>
        <mi>N</mi>
        <mo>,</mo>
        <mi>v</mi>
        <mo>:=</mo>
        <mi>P</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mi>u</mi>
         <mo>:=</mo>
         <mi>N</mi>
         <mo stretchy="false">]</mo>
        </mrow>
        <mo>,</mo>
        <mi>w</mi>
        <mo>:=</mo>
        <mi>M</mi>
        <mo stretchy="false">]</mo>
       </mrow>
       <mo rspace="5.3pt" stretchy="false">)</mo>
      </mrow>
      <mi>z</mi>
      <mo>.</mo>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <times></times>
      <ci>M</ci>
      <apply>
       <ci>normal-¯</ci>
       <apply>
        <times></times>
        <ci>N</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>u</ci>
        </apply>
       </apply>
      </apply>
      <ci>P</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>v</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>w</ci>
      </apply>
      <ci>Q</ci>
      <ci>z</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-⟶</ci>
       <ci>β</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">M</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <apply>
       <ci>normal-¯</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">P</csymbol>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <ci>normal-[</ci>
          <csymbol cd="unknown">u</csymbol>
          <csymbol cd="latexml">assign</csymbol>
          <csymbol cd="unknown">N</csymbol>
          <ci>normal-]</ci>
         </cerror>
         <ci>normal-)</ci>
        </cerror>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-[</ci>
         <csymbol cd="unknown">v</csymbol>
         <ci>normal-]</ci>
        </cerror>
       </cerror>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">w</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">Q</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-[</ci>
        <csymbol cd="unknown">u</csymbol>
        <csymbol cd="latexml">assign</csymbol>
        <csymbol cd="unknown">N</csymbol>
        <ci>normal-]</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">z</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-⟶</ci>
       <ci>β</ci>
      </apply>
      <apply>
       <ci>normal-¯</ci>
       <apply>
        <times></times>
        <ci>M</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>w</ci>
        </apply>
       </apply>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">Q</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-[</ci>
        <csymbol cd="unknown">u</csymbol>
        <csymbol cd="latexml">assign</csymbol>
        <csymbol cd="unknown">N</csymbol>
        <ci>normal-,</ci>
        <csymbol cd="unknown">v</csymbol>
        <csymbol cd="latexml">assign</csymbol>
        <csymbol cd="unknown">P</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-[</ci>
         <csymbol cd="unknown">u</csymbol>
         <csymbol cd="latexml">assign</csymbol>
         <csymbol cd="unknown">N</csymbol>
         <ci>normal-]</ci>
        </cerror>
        <ci>normal-]</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">z</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-⟶</ci>
       <ci>β</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">Q</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-[</ci>
        <csymbol cd="unknown">u</csymbol>
        <csymbol cd="latexml">assign</csymbol>
        <csymbol cd="unknown">N</csymbol>
        <ci>normal-,</ci>
        <csymbol cd="unknown">v</csymbol>
        <csymbol cd="latexml">assign</csymbol>
        <csymbol cd="unknown">P</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-[</ci>
         <csymbol cd="unknown">u</csymbol>
         <csymbol cd="latexml">assign</csymbol>
         <csymbol cd="unknown">N</csymbol>
         <ci>normal-]</ci>
        </cerror>
        <ci>normal-,</ci>
        <csymbol cd="unknown">w</csymbol>
        <csymbol cd="latexml">assign</csymbol>
        <csymbol cd="unknown">M</csymbol>
        <ci>normal-]</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-.</ci>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{aligned}\displaystyle(M)\;\underline{(N)\;[u]}\;(P)\;[v]\;[w]\;(Q)\;z&%
\displaystyle{\ \longrightarrow_{\beta}\ }(M)\;\underline{(P[u:=N])\;[v]}\;[w]%
\;(Q[u:=N])\;z\\
&\displaystyle{\ \longrightarrow_{\beta}\ }\underline{(M)\;[w]}\;(Q[u:=N,v:=P[%
u:=N]])\;z\\
&\displaystyle{\ \longrightarrow_{\beta}\ }(Q[u:=N,v:=P[u:=N],w:=M])\;z.\end{aligned}
  </annotation>
 </semantics>
</math>

</p>
</blockquote>

<p>Thus, if one views the applicator as an open paren ('<code>(</code>') and the abstractor as a close bracket ('<code>]</code>'), then the pattern in the above term is '<code>((](]]</code>'. De Bruijn called an applicator and its corresponding abstractor in this interpretation <em>partners</em>, and wagons without partners <em>bachelors</em>. A sequence of wagons, which he called a <em>segment</em>, is <em>well balanced</em> if all its wagons are partnered.</p>
<h2 id="advantages-of-the-de-bruijn-notation">Advantages of the De Bruijn notation</h2>

<p>In a well balanced segment, the partnered wagons may be moved around arbitrarily and, as long as parity is not destroyed, the meaning of the term stays the same. For example, in the above example, the applicator 

<math display="inline" id="De_Bruijn_notation:12">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>M</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M)
  </annotation>
 </semantics>
</math>

 can be brought to its abstractor 

<math display="inline" id="De_Bruijn_notation:13">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>w</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [w]
  </annotation>
 </semantics>
</math>

, or the abstractor to the applicator. In fact, <em>all</em> <a href="commutative_conversion" title="wikilink">commutatives</a> and <a href="permutative_conversion" title="wikilink">permutative conversions</a> on lambda terms may be described simply in terms of parity-preserving reorderings of partnered wagons. One thus obtains a <em>generalised conversion</em> primitive for λ-terms in the De Bruijn notation.</p>

<p>Several properties of λ-terms that are difficult to state and prove using the traditional notation are easily expressed in the De Bruijn notation. For example, in a <a href="type_theory" title="wikilink">type-theoretic</a> setting, one can easily compute the canonical class of types for a term in a typing context, and restate the <a href="type_checking" title="wikilink">type checking</a> problem to one of verifying that the checked type is a member of this class.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> De Bruijn notation has also been shown to be useful in calculi for <a href="explicit_substitution" title="wikilink">explicit substitution</a> in <a href="pure_type_system" title="wikilink">pure type systems</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Mathematical_notation" title="wikilink">Mathematical notation</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Lambda_calculus" title="wikilink">Category:Lambda calculus</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"> The example is from page 384.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">.<a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
