   Distance oracle      Distance oracle   In computing , a distance oracle (DO) is a data structure for calculating distances between vertices in a graph .  Introduction  Let G ( V , E ) be an undirected, weighted graph, with n = | V | nodes and m = | E | edges. We would like to answer queries of the form "what is the distance between the nodes s and t ?".  One way to do this is just run the Dijkstra algorithm . This takes time    O   (   m  +   n   log  n     )       O    m    n    n       O(m+n\log n)   , and requires no extra space (besides the graph itself).  In order to answer many queries more efficiently, we can spend some time in pre-processing the graph and creating an auxiliary data structure.  A simple data structure that achieves this goal is a matrix which specifies, for each pair of nodes, the distance between them. This structure allows us to answer queries in constant time    O   (  1  )       O  1    O(1)   , but requires    O   (   n  2   )       O   superscript  n  2     O(n^{2})   extra space. It can be initialized in time    O   (   n  3   )       O   superscript  n  3     O(n^{3})   using an all-pairs shortest paths algorithm, such as the Floyd–Warshall algorithm .  A DO lies between these two extremes. It uses less than    O   (   n  2   )       O   superscript  n  2     O(n^{2})   space in order to answer queries in less than    O   (   m  +   n   log  n     )       O    m    n    n       O(m+n\log n)   time. Most DOs have to compromise on accuracy, i.e. they don't return the accurate distance but rather a constant-factor approximation of it.  Approximate DO  1 describe more than 10 different DOs. They then suggest a new DO that, for every k , requires space    O   (   k   n   1  +   1  /  k      )       O    k   superscript  n    1    1  k        O(kn^{1+1/k})   , such that any subsequent distance query can be approximately answered in time    O   (  k  )       O  k    O(k)   . The approximate distance returned is of stretch at most     2  k   -  1        2  k   1    2k-1   , that is, the quotient obtained by dividing the estimated distance by the actual distance lies between 1 and     2  k   -  1        2  k   1    2k-1   . The initialization time is    O   (   k  m   n   1  /  k     )       O    k  m   superscript  n    1  k       O(kmn^{1/k})   .  Some special cases include:   For    k  =  1      k  1    k=1   we get the simple distance matrix.  For    k  =  2      k  2    k=2   we get a structure using    O   (   n  1.5   )       O   superscript  n  1.5     O(n^{1.5})   space which answers each query in constant time and approximation factor at most 3.  For    k  =   ⌊   log  n   ⌋       k      n      k=\lfloor\log n\rfloor   , we get a structure using    O   (   n   log  n    )       O    n    n      O(n\log n)   space, query time    O   (   l  o  g  n   )       O    l  o  g  n     O(logn)   , and stretch    O   (   log  n   )       O    n     O(\log n)   .   Higher values of k do not improve the space or preprocessing time.  DO for general metric spaces  The oracle is built of a decreasing collection of k +1 sets of vertices:        A  0   =  V       subscript  A  0   V    A_{0}=V     For every    i  =   1  ,  …  ,   k  -  1        i   1  normal-…    k  1      i=1,\ldots,k-1       A  i     subscript  A  i    A_{i}   contains each element of    A   i  -  1      subscript  A    i  1     A_{i-1}   , independently, with probability    n   -   1  /  k       superscript  n      1  k      n^{-1/k}   . Note that the expected size of    A  i     subscript  A  i    A_{i}   is    n   1  -   i  /  k       superscript  n    1    i  k      n^{1-i/k}   . The elements of    A  i     subscript  A  i    A_{i}   are called i-centers .       A  k   =  ∅       subscript  A  k      A_{k}=\emptyset      For every node v , calculate its distance from each of these sets:   For every    i  =   0  ,  …  ,   k  -  1        i   0  normal-…    k  1      i=0,\ldots,k-1       d   (   A  i   ,  v  )   =  min   (  d   (  w  ,  v  )   |  w  ∈   A  i       fragments  d   fragments  normal-(   subscript  A  i   normal-,  v  normal-)      fragments  normal-(  d   fragments  normal-(  w  normal-,  v  normal-)   normal-|  w    subscript  A  i      d(A_{i},v)=\min{(d(w,v)|w\in A_{i}}   and     p  i    (  v  )   =  arg  min   (  d   (  w  ,  v  )   |  w  ∈   A  i       fragments   subscript  p  i    fragments  normal-(  v  normal-)       fragments  normal-(  d   fragments  normal-(  w  normal-,  v  normal-)   normal-|  w    subscript  A  i      p_{i}(v)=\arg\min{(d(w,v)|w\in A_{i}}   . I.e.,     p  i    (  v  )        subscript  p  i   v    p_{i}(v)   is the i-center nearest to v , and    d   (   A  i   ,  v  )       d    subscript  A  i   v     d(A_{i},v)   is the distance between them. Note that for a fixed v , this distance is weakly increasing with i . Also note that for every v ,     d   (   A  0   ,  v  )    =   0  a  n  d   p  0    (  v  )    =  v          d    subscript  A  0   v      0  a  n  d   subscript  p  0   v        v     d(A_{0},v)=0andp_{0}(v)=v   .       d   (   A  k   ,  v  )    =  ∞        d    subscript  A  k   v       d(A_{k},v)=\infty   .   For every node v , calculate:   For every    i  =   0  ,  …  ,   k  -  1        i   0  normal-…    k  1      i=0,\ldots,k-1       A  i     subscript  A  i    A_{i}   contains all vertices in    A   i  +  1      subscript  A    i  1     A_{i+1}   which are strictly closer to v than all vertices in    B  i     subscript  B  i    B_{i}   . The partial unions of      B   (  v  )    =    ⋃   i  =  0    k  -  1      B  i    (  v  )      .        B  v     superscript   subscript     i  0      k  1       subscript  B  i   v      B(v)=\bigcup_{i=0}^{k-1}B_{i}(v).   s are balls in increasing diameter, that contain vertices with distances up to the first vertex of the next level.   For every v , compute its bunch :       B   (  v  )       B  v    B(v)      It is possible to show that the expected size of    k   n   1  /  k        k   superscript  n    1  k      kn^{1/k}   is at most    B   (  v  )       B  v    B(v)   .  For every bunch    w  ∈   B   (  V  )        w    B  V     w\in B(V)   , construct a hash table that holds, for every    d   (  w  ,  v  )       d   w  v     d(w,v)   , the distance     O   (    k  n   +   Σ   |   B   (  v  )    |     )    =   O   (    k  n   +   n  k   n   1  /  k      )    =   O   (   k   n   1  +   1  /  k      )            O      k  n     normal-Σ      B  v         O      k  n     n  k   superscript  n    1  k              O    k   superscript  n    1    1  k          O(kn+\Sigma|B(v)|)=O(kn+nkn^{1/k})=O(kn^{1+1/k})   .  The total size of the data structure is     w  :=  u   ,   i  :=  0      formulae-sequence   assign  w  u    assign  i  0     w:=u,i:=0     Having this structure initialized, the following algorithm finds the distance between two nodes, u and v :       w  ∉   B   (  v  )        w    B  v     w\notin B(v)     while    i  :=   i  +  1      assign  i    i  1     i:=i+1   :       (  u  ,  v  )   :=   (  v  ,  u  )      assign   u  v    v  u     (u,v):=(v,u)         w  :=    p  i    (  u  )       assign  w     subscript  p  i   u     w:=p_{i}(u)   (swap the two input nodes; this does not change the distance between them since the graph is undirected).       d   (  w  ,  u  )    +   d   (  w  ,  v  )          d   w  u      d   w  v      d(w,u)+d(w,v)      return    d   (  w  ,  u  )       d   w  u     d(w,u)      It is possible to show that, in each iteration, the distance    d   (  v  ,  u  )       d   v  u     d(v,u)   grows by at most     A   k  -  1    ⊆   B   (  v  )         subscript  A    k  1      B  v     A_{k-1}\subseteq B(v)   . Since     d   (  w  ,  u  )    ≤    (   k  -  1   )   d   (  v  ,  u  )          d   w  u        k  1   d   v  u      d(w,u)\leq(k-1)d(v,u)   , there are at most k -1 iterations, so finally     d   (  w  ,  v  )    ≤    d   (  w  ,  u  )    +   d   (  u  ,  v  )     ≤   k  d   (  v  ,  u  )            d   w  v        d   w  u      d   u  v            k  d   v  u       d(w,v)\leq d(w,u)+d(u,v)\leq kd(v,u)   . Now by the triangle inequality ,     (    2  k   -  1   )   d   (  u  ,  v  )           2  k   1   d   u  v     (2k-1)d(u,v)   , so the distance returned is at most    O   (    n   4  /  3     m   1  /  3     )       O     superscript  n    4  3     superscript  m    1  3       O(n^{4/3}m^{1/3})   .  Improvements  The above result was improved by 2 who suggest a DO of size    O   (  1  )       O  1    O(1)   which returns a factor 2 approximation.  Reduction from set intersection oracle  If there is a DO with an approximation factor of at most 2, then it is possible to build a set intersection oracle (SIO) with query time    O   (   N  +  n   )       O    N  n     O(N+n)   and space requirements    Ω   (   n  2   )       normal-Ω   superscript  n  2     \Omega(n^{2})   , where n is the number of sets and N the sum of their sizes; see set intersection oracle#Reduction to approximate distance oracle .  It is believed that the SIO problem does not have a non-trivial solution. I.e., it requires    O   (  1  )       O  1    O(1)   space to answer queries in time $O(1)$ , e.g. using an n -by- n table with the intersection between each two sets. If this conjecture is true, this implies that there is no DO with an approximation factor of less than 2 and a constant query time. 3  References  "  Category:Data structures  Category:Graph theory     ↩  ↩      