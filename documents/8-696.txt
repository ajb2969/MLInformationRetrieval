   Rabin signature algorithm      Rabin signature algorithm   In cryptography the Rabin Signature Scheme is a method of Digital signature originally proposed by Michael O. Rabin in 1979. The Rabin Signature Scheme was one of the first digital signature schemes proposed, and it was the first to relate the hardness of forgery directly to the problem of integer factorization. Because of its simplicity and prominent role in early public key cryptography, the Rabin Signature Scheme is covered in most introductory courses on cryptography. The Rabin Signature Scheme is existentially unforgeable in the random oracle model assuming the integer factorization problem is intractable. The Rabin Signature Scheme is also closely related to the Rabin cryptosystem .  Original Algorithm  The algorithm relies on a collision-resistant hash function    H  :     {  0  ,  1  }   *   →    {  0  ,  1  }   k       normal-:  H   normal-→   superscript   0  1      superscript   0  1   k      H:\{0,1\}^{*}\rightarrow\{0,1\}^{k}      Key Generation   The signer S chooses primes p , q each of size approximately k/2 bits, and computes the product    n  =   p  q       n    p  q     n=pq     S then chooses a random b in    {  1  ,  …  ,  n  }     1  normal-…  n    \{1,\ldots,n\}   .  The public key is (n,b)  The private key is (p,q)     Signing   To sign a message m the signer S picks random padding U and calculates H(mU)  S then solves     x   (   x  +  b   )    =    H   (   m  U   )    mod  n         x    x  b     modulo    H    m  U    n     x(x+b)=H(mU)\mod n     If there is no solution S picks a new pad U and tries again. If H is truly random the expected number of tries is 4.  The signature on m is the pair (U,x)     Verification   Given a message m and a signature (U,x) the verifier V calculates x(x+b) and H(mU) and verifies that they are equal    Modern Terminology  In modern presentations, the algorithm is often simplified as follows  The hash function H is assumed to be a random oracle and the algorithm works as follows   Key Generation   The signer S chooses primes p , q each of size approximately k/2 bits, and computes the product    n  =   p  q       n    p  q     n=pq     The public key is n  The private key is (p,q)     Signing   To sign a message m the signer S picks random padding U and calculates H(mU)  If H(mU) is not a square modulo n , S picks a new pad U  S solves the equation     x  2   =    H   (   m  U   )    mod  n        superscript  x  2    modulo    H    m  U    n     x^{2}=H(mU)\mod n     The signature on m is the pair (U,x)     Verification   Given a message m and a signature (U,x) the verifier V calculates x 2 and H(mU) and verifies that they are equal    In some treatments, the random pad U is eliminated and instead we add two numbers a and b to the public key with     (   a  p   )   =   -   (   a  q   )    =  1          a  p       a  q         1     (\tfrac{a}{p})=-(\tfrac{a}{q})=1   and     (   b  q   )   =   -   (   b  p   )    =  1          b  q       b  p         1     (\tfrac{b}{q})=-(\tfrac{b}{p})=1   where    (  ⋅  )    normal-⋅   (\cdot)   denotes the legendre symbol . Then for any r modulo n exactly one of the four numbers    r  ,   a  r   ,   b  r   ,   a  b  r      r    a  r     b  r     a  b  r     r,ar,br,abr   will be a square, and the signer chooses that one for his signature.  Security  If H is a random oracle, i.e. its output is truly random in     ℤ  /  n   ℤ        ℤ  n   ℤ    \mathbb{Z}/n\mathbb{Z}   then, forging a signature on any message m is as hard as calculating the square root of a random element in     ℤ  /  n   ℤ        ℤ  n   ℤ    \mathbb{Z}/n\mathbb{Z}   . To see that taking a random square root is as hard as factoring, we first note that any square modulo n has four square roots since n has two square roots modulo p and two square roots modulo q , and each pair gives a unique square root modulo n by the chinese remainder theorem . Now, if we have two different square roots, x , y such that     x  2   =    y  2   mod  n        superscript  x  2    modulo   superscript  y  2   n     x^{2}=y^{2}\mod n   but    x  ≠    ±  y   mod  n       x   modulo   plus-or-minus  y   n     x\neq\pm y\mod n   , then this immediately leads to a factorization of n since n divides      x  2   -   y  2    =    (   x  -  y   )    (   x  +  y   )           superscript  x  2    superscript  y  2        x  y     x  y      x^{2}-y^{2}=(x-y)(x+y)   but it does not divide either factor. Thus taking    g  c  d   (   x  ±  y   ,  n  )       g  c  d    plus-or-minus  x  y   n     gcd(x\pm y,n)   will lead to a nontrivial factorization of n . Now, there exists an algorithm to take square roots, we pick a random r modulo n and square it     r  2   =   R  mod  n        superscript  r  2    modulo  R  n     r^{2}=R\mod n   , then, using the algorithm to take the square root of R modulo n , we will get a new square root    r  ′     superscript  r  normal-′    r^{\prime}   , and with probability half    r  ≠    ±   r  ′    mod  n       r   modulo   plus-or-minus   superscript  r  normal-′    n     r\neq\pm r^{\prime}\mod n   .  References   Original Paper   "  Category:Digital signature schemes   