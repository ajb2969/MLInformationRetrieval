<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1437">Nearest-neighbor chain algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Nearest-neighbor chain algorithm</h1>
<hr/>

<p>In the theory of <a href="cluster_analysis" title="wikilink">cluster analysis</a>, the <strong>nearest-neighbor chain algorithm</strong> is a method that can be used to perform several types of agglomerative <a href="hierarchical_clustering" title="wikilink">hierarchical clustering</a>, using an amount of memory that is linear in the number of points to be clustered and an amount of time linear in the number of distinct distances between pairs of points.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The main idea of the algorithm is to find pairs of clusters to merge by following paths in the <a href="nearest_neighbor_graph" title="wikilink">nearest neighbor graph</a> of the clusters until the paths terminate in pairs of mutual nearest neighbors. The algorithm was developed and implemented in 1982 by J. P. Benzécri<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and J. Juan,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> based on earlier methods that constructed hierarchical clusterings using mutual nearest neighbor pairs without taking advantage of nearest neighbor chains.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="background">Background</h2>

<p>The input to a clustering problem consists of a set of points. A <em>cluster</em> is any proper subset of the points, and a hierarchical clustering is a <a href="maximal_element" title="wikilink">maximal</a> family of clusters with the property that any two clusters in the family are either nested or <a href="disjoint_set" title="wikilink">disjoint</a>. Alternatively, a hierarchical clustering may be represented as a <a href="binary_tree" title="wikilink">binary tree</a> with the points at its leaves; the clusters of the clustering are the sets of points in subtrees descending from each node of the tree.</p>

<p>In agglomerative clustering methods, the input also includes a distance function defined on the points, or a numerical measure of their dissimilarity that is symmetric (insensitive to the ordering within each pair of points) but (unlike a distance) may not satisfy the triangle inequality. Depending on the method, this dissimilarity function can be extended in several different ways to pairs of clusters; for instance, in the <a href="single-linkage_clustering" title="wikilink">single-linkage clustering</a> method, the distance between two clusters is defined to be the minimum distance between any two points from each cluster. Given this distance between clusters, a hierarchical clustering may be defined by a <a href="greedy_algorithm" title="wikilink">greedy algorithm</a> that initially places each point in its own single-point cluster and then repeatedly merges the <a href="closest_pair" title="wikilink">closest pair</a> of clusters.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>However, known methods for repeatedly finding the closest pair of clusters in a dynamic set of clusters either require superlinear space to maintain a <a href="data_structure" title="wikilink">data structure</a> that can find closest pairs quickly, or they take greater than linear time to find each closest pair.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> The nearest-neighbor chain algorithm uses a smaller amount of time and space than the greedy algorithm by merging pairs of clusters in a different order. However, for many types of clustering problem, it can be guaranteed to come up with the same hierarchical clustering as the greedy algorithm despite the different merge order.</p>
<h2 id="the-algorithm">The algorithm</h2>

<p> Intuitively, the nearest neighbor chain algorithm repeatedly follows a chain of clusters 

<math display="inline" id="Nearest-neighbor_chain_algorithm:0">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi mathvariant="normal">→</mi>
   <mi>B</mi>
   <mi mathvariant="normal">→</mi>
   <mi>C</mi>
   <mi mathvariant="normal">→</mi>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>normal-→</ci>
    <ci>B</ci>
    <ci>normal-→</ci>
    <ci>C</ci>
    <ci>normal-→</ci>
    <ci>normal-…</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A→B→C→...
  </annotation>
 </semantics>
</math>

 where each cluster is the nearest neighbor of the previous one, until reaching a pair of clusters that are mutual nearest neighbors.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>More formally, the algorithm performs the following steps:<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<ul>
<li>Initialize the set of active clusters to consist of 

<math display="inline" id="Nearest-neighbor_chain_algorithm:1">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 one-point clusters, one for each input point.</li>
<li>Let 

<math display="inline" id="Nearest-neighbor_chain_algorithm:2">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 be a <a href="Stack_(data_structure)" title="wikilink">stack data structure</a>, initially empty, the elements of which will be active clusters.</li>
<li>While there is more than one cluster in the set of clusters:
<ul>
<li>If 

<math display="inline" id="Nearest-neighbor_chain_algorithm:3">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is empty, choose an active cluster arbitrarily and push it onto 

<math display="inline" id="Nearest-neighbor_chain_algorithm:4">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

.</li>
<li>Let 

<math display="inline" id="Nearest-neighbor_chain_algorithm:5">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 be the active cluster on the top of 

<math display="inline" id="Nearest-neighbor_chain_algorithm:6">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

. Compute the distances from 

<math display="inline" id="Nearest-neighbor_chain_algorithm:7">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 to all other clusters, and let 

<math display="inline" id="Nearest-neighbor_chain_algorithm:8">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 be the nearest other cluster.</li>
<li>If 

<math display="inline" id="Nearest-neighbor_chain_algorithm:9">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 is already in 

<math display="inline" id="Nearest-neighbor_chain_algorithm:10">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, it must be the immediate predecessor of 

<math display="inline" id="Nearest-neighbor_chain_algorithm:11">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

. Pop both clusters from 

<math display="inline" id="Nearest-neighbor_chain_algorithm:12">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, merge them, and push the merged cluster onto 

<math display="inline" id="Nearest-neighbor_chain_algorithm:13">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

.</li>
<li>Otherwise, if 

<math display="inline" id="Nearest-neighbor_chain_algorithm:14">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 is not already in 

<math display="inline" id="Nearest-neighbor_chain_algorithm:15">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, push it onto 

<math display="inline" id="Nearest-neighbor_chain_algorithm:16">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

.</li>
</ul></li>
</ul>

<p>If there may be multiple equal nearest neighbors to a cluster, the algorithm requires a consistent tie-breaking rule: for instance, in this case, the nearest neighbor may be chosen, among the clusters at equal minimum distance from 

<math display="inline" id="Nearest-neighbor_chain_algorithm:17">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

, by numbering the clusters arbitrarily and choosing the one with the smallest index.</p>
<h2 id="time-and-space-analysis">Time and space analysis</h2>

<p>Each iteration of the loop performs a single search for the nearest neighbor of a cluster, and either adds one cluster to the stack or removes two clusters from it. Every cluster is only ever added once to the stack, because when it is removed again it is immediately made inactive and merged. There are a total of 

<math display="inline" id="Nearest-neighbor_chain_algorithm:18">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>n</mi>
   <mi mathvariant="normal">−</mi>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>n</ci>
    <ci>normal-−</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2n−2
  </annotation>
 </semantics>
</math>

 clusters that ever get added to the stack: 

<math display="inline" id="Nearest-neighbor_chain_algorithm:19">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 single-point clusters in the initial set, and 

<math display="inline" id="Nearest-neighbor_chain_algorithm:20">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">−</mi>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-−</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n−2
  </annotation>
 </semantics>
</math>

 internal nodes other than the root in the binary tree representing the clustering. Therefore, the algorithm performs 

<math display="inline" id="Nearest-neighbor_chain_algorithm:21">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>n</mi>
   <mi mathvariant="normal">−</mi>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>n</ci>
    <ci>normal-−</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2n−2
  </annotation>
 </semantics>
</math>

 pushing iterations and 

<math display="inline" id="Nearest-neighbor_chain_algorithm:22">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">−</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n−1
  </annotation>
 </semantics>
</math>

 popping iterations, each time scanning as many as 

<math display="inline" id="Nearest-neighbor_chain_algorithm:23">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">−</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n−1
  </annotation>
 </semantics>
</math>

 inter-cluster distances to find the nearest neighbor. The total number of distance calculations it makes is therefore less than <mtpl></mtpl>, and the total time it uses outside of the distance calculations is <mtpl></mtpl>.</p>

<p>Since the only data structure is the set of active clusters and the stack containing a subset of the active clusters, the space required is linear in the number of input points.</p>
<h2 id="correctness">Correctness</h2>

<p>The correctness of this algorithm relies on a property of its distance function called <em>reducibility</em>, identified by  in connection with an earlier clustering method that used mutual nearest neighbor pairs but not chains of nearest neighbors.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> A distance function 

<math display="inline" id="Nearest-neighbor_chain_algorithm:24">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 on clusters is defined to be reducible if, for every three clusters 

<math display="inline" id="Nearest-neighbor_chain_algorithm:25">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Nearest-neighbor_chain_algorithm:26">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Nearest-neighbor_chain_algorithm:27">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 in the greedy hierarchical clustering such that 

<math display="inline" id="Nearest-neighbor_chain_algorithm:28">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Nearest-neighbor_chain_algorithm:29">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 are mutual nearest neighbors, the following inequality holds:</p>
<dl>
<dd>

<math display="inline" id="Nearest-neighbor_chain_algorithm:30">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mi mathvariant="normal">∪</mi>
     <mi>B</mi>
    </mrow>
    <mo>,</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="normal">≥</mi>
   <mi>m</mi>
   <mi>i</mi>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo>,</mo>
      <mi>C</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo>,</mo>
      <mi>C</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>normal-∪</ci>
      <ci>B</ci>
     </apply>
     <ci>C</ci>
    </interval>
    <ci>normal-≥</ci>
    <ci>m</ci>
    <ci>i</ci>
    <ci>n</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>d</ci>
      <interval closure="open">
       <ci>A</ci>
       <ci>C</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <interval closure="open">
       <ci>B</ci>
       <ci>C</ci>
      </interval>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(A∪B,C)≥min(d(A,C),d(B,C))
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>

<p>If a distance function has the reducibility property, then merging two clusters 

<math display="inline" id="Nearest-neighbor_chain_algorithm:31">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Nearest-neighbor_chain_algorithm:32">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 can only cause the nearest neighbor of 

<math display="inline" id="Nearest-neighbor_chain_algorithm:33">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 to change if that nearest neighbor was one of 

<math display="inline" id="Nearest-neighbor_chain_algorithm:34">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Nearest-neighbor_chain_algorithm:35">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

. This has two important consequences for the nearest neighbor chain algorithm: first, it can be shown using this property that, at each step of the algorithm, the clusters on the stack 

<math display="inline" id="Nearest-neighbor_chain_algorithm:36">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 form a valid chain of nearest neighbors, because whenever a nearest neighbor becomes invalidated it is immediately removed from the stack.</p>

<p>Second, and even more importantly, it follows from this property that, if two clusters 

<math display="inline" id="Nearest-neighbor_chain_algorithm:37">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Nearest-neighbor_chain_algorithm:38">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 both belong to the greedy hierarchical clustering, and are mutual nearest neighbors at any point in time, then they will be merged by the greedy clustering, for they must remain mutual nearest neighbors until they are merged. It follows that each mutual nearest neighbor pair found by the nearest neighbor chain algorithm is also a pair of clusters found by the greedy algorithm, and therefore that the nearest neighbor chain algorithm computes exactly the same clustering (although in a different order) as the greedy algorithm.</p>
<h2 id="application-to-specific-clustering-distances">Application to specific clustering distances</h2>
<h3 id="wards-method">Ward's method</h3>

<p><a href="Ward's_method" title="wikilink">Ward's method</a> is an agglomerative clustering method in which the dissimilarity between two clusters 

<math display="inline" id="Nearest-neighbor_chain_algorithm:39">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Nearest-neighbor_chain_algorithm:40">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is measured by the amount by which merging the two clusters into a single larger cluster would increase the average squared distance of a point to its cluster <a class="uri" href="centroid" title="wikilink">centroid</a>.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> That is,</p>

<p>

<math display="block" id="Nearest-neighbor_chain_algorithm:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo>,</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mrow>
         <mi>x</mi>
         <mo>∈</mo>
         <mi>A</mi>
        </mrow>
        <mo>,</mo>
        <mrow>
         <mi>y</mi>
         <mo>∈</mo>
         <mi>B</mi>
        </mrow>
       </mrow>
      </munder>
      <mfrac>
       <mrow>
        <msup>
         <mi>d</mi>
         <mn>2</mn>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mrow>
         <mo stretchy="false">|</mo>
         <mi>A</mi>
         <mo stretchy="false">|</mo>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mo stretchy="false">|</mo>
         <mi>B</mi>
         <mo stretchy="false">|</mo>
        </mrow>
       </mrow>
      </mfrac>
     </mrow>
     <mo>-</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mrow>
         <mi>x</mi>
         <mo>,</mo>
         <mi>y</mi>
        </mrow>
        <mo>∈</mo>
        <mi>A</mi>
       </mrow>
      </munder>
      <mfrac>
       <mrow>
        <msup>
         <mi>d</mi>
         <mn>2</mn>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>A</mi>
        <mo stretchy="false">|</mo>
       </mrow>
      </mfrac>
     </mrow>
     <mo>-</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mrow>
         <mi>x</mi>
         <mo>,</mo>
         <mi>y</mi>
        </mrow>
        <mo>∈</mo>
        <mi>B</mi>
       </mrow>
      </munder>
      <mfrac>
       <mrow>
        <msup>
         <mi>d</mi>
         <mn>2</mn>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>B</mi>
        <mo stretchy="false">|</mo>
       </mrow>
      </mfrac>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <ci>A</ci>
      <ci>B</ci>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <apply>
         <in></in>
         <ci>x</ci>
         <ci>A</ci>
        </apply>
        <apply>
         <in></in>
         <ci>y</ci>
         <ci>B</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>d</ci>
         <cn type="integer">2</cn>
        </apply>
        <interval closure="open">
         <ci>x</ci>
         <ci>y</ci>
        </interval>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <abs></abs>
         <ci>A</ci>
        </apply>
        <apply>
         <abs></abs>
         <ci>B</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <list>
         <ci>x</ci>
         <ci>y</ci>
        </list>
        <ci>A</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>d</ci>
         <cn type="integer">2</cn>
        </apply>
        <interval closure="open">
         <ci>x</ci>
         <ci>y</ci>
        </interval>
       </apply>
       <apply>
        <abs></abs>
        <ci>A</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <list>
         <ci>x</ci>
         <ci>y</ci>
        </list>
        <ci>B</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>d</ci>
         <cn type="integer">2</cn>
        </apply>
        <interval closure="open">
         <ci>x</ci>
         <ci>y</ci>
        </interval>
       </apply>
       <apply>
        <abs></abs>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(A,B)=\sum_{x\in A,y\in B}\frac{d^{2}(x,y)}{|A|+|B|}-\sum_{x,y\in A}\frac{d^{%
2}(x,y)}{|A|}-\sum_{x,y\in B}\frac{d^{2}(x,y)}{|B|}.
  </annotation>
 </semantics>
</math>

</p>

<p>Expressed in terms of the centroid 

<math display="inline" id="Nearest-neighbor_chain_algorithm:42">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{A}
  </annotation>
 </semantics>
</math>

 and <a class="uri" href="cardinality" title="wikilink">cardinality</a> 

<math display="inline" id="Nearest-neighbor_chain_algorithm:43">
 <semantics>
  <msub>
   <mi>n</mi>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{A}
  </annotation>
 </semantics>
</math>

 of the two clusters, it has the simpler formula</p>

<p>

<math display="block" id="Nearest-neighbor_chain_algorithm:44">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo>,</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <msup>
       <mi>d</mi>
       <mn>2</mn>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>c</mi>
        <mi>a</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>c</mi>
        <mi>b</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <msub>
        <mi>n</mi>
        <mi>A</mi>
       </msub>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <msub>
        <mi>n</mi>
        <mi>B</mi>
       </msub>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <ci>A</ci>
      <ci>B</ci>
     </interval>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>d</ci>
       <cn type="integer">2</cn>
      </apply>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>a</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>b</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>A</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(A,B)=\frac{d^{2}(c_{a},c_{b})}{1/n_{A}+1/n_{B}},
  </annotation>
 </semantics>
</math>

 allowing it to be computed in constant time per distance calculation. Although highly sensitive to <a href="outlier" title="wikilink">outliers</a>, Ward's method is the most popular variation of agglomerative clustering both because of the round shape of the clusters it typically forms and because of its principled definition as the clustering that at each step has the smallest variance within its clusters.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Alternatively, this distance can be seen as the difference in <a href=":en:k-means_clustering" title="wikilink">k-means cost</a> between the new cluster and the two old clusters.</p>

<p>Ward's distance is also reducible, as can be seen more easily from a different formula of Lance–Williams type for calculating the distance of a merged cluster from the distances of the clusters it was merged from:<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>

<math display="block" id="Nearest-neighbor_chain_algorithm:45">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mo>∪</mo>
       <mi>B</mi>
      </mrow>
      <mo>,</mo>
      <mi>C</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mfrac>
        <mrow>
         <msub>
          <mi>n</mi>
          <mi>A</mi>
         </msub>
         <mo>+</mo>
         <msub>
          <mi>n</mi>
          <mi>C</mi>
         </msub>
        </mrow>
        <mrow>
         <msub>
          <mi>n</mi>
          <mi>A</mi>
         </msub>
         <mo>+</mo>
         <msub>
          <mi>n</mi>
          <mi>B</mi>
         </msub>
         <mo>+</mo>
         <msub>
          <mi>n</mi>
          <mi>C</mi>
         </msub>
        </mrow>
       </mfrac>
       <mi>d</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo>,</mo>
        <mi>C</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <mrow>
         <msub>
          <mi>n</mi>
          <mi>B</mi>
         </msub>
         <mo>+</mo>
         <msub>
          <mi>n</mi>
          <mi>C</mi>
         </msub>
        </mrow>
        <mrow>
         <msub>
          <mi>n</mi>
          <mi>A</mi>
         </msub>
         <mo>+</mo>
         <msub>
          <mi>n</mi>
          <mi>B</mi>
         </msub>
         <mo>+</mo>
         <msub>
          <mi>n</mi>
          <mi>C</mi>
         </msub>
        </mrow>
       </mfrac>
       <mi>d</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>B</mi>
        <mo>,</mo>
        <mi>C</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <msub>
        <mi>n</mi>
        <mi>C</mi>
       </msub>
       <mrow>
        <msub>
         <mi>n</mi>
         <mi>A</mi>
        </msub>
        <mo>+</mo>
        <msub>
         <mi>n</mi>
         <mi>B</mi>
        </msub>
        <mo>+</mo>
        <msub>
         <mi>n</mi>
         <mi>C</mi>
        </msub>
       </mrow>
      </mfrac>
      <mi>d</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>,</mo>
       <mi>B</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <apply>
       <union></union>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
      <ci>C</ci>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>A</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>C</ci>
         </apply>
        </apply>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>A</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>B</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>C</ci>
         </apply>
        </apply>
       </apply>
       <ci>d</ci>
       <interval closure="open">
        <ci>A</ci>
        <ci>C</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>B</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>C</ci>
         </apply>
        </apply>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>A</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>B</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>C</ci>
         </apply>
        </apply>
       </apply>
       <ci>d</ci>
       <interval closure="open">
        <ci>B</ci>
        <ci>C</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>C</ci>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>n</ci>
         <ci>A</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>n</ci>
         <ci>B</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>n</ci>
         <ci>C</ci>
        </apply>
       </apply>
      </apply>
      <ci>d</ci>
      <interval closure="open">
       <ci>A</ci>
       <ci>B</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(A\cup B,C)=\frac{n_{A}+n_{C}}{n_{A}+n_{B}+n_{C}}d(A,C)+\frac{n_{B}+n_{C}}{n_%
{A}+n_{B}+n_{C}}d(B,C)-\frac{n_{C}}{n_{A}+n_{B}+n_{C}}d(A,B).
  </annotation>
 </semantics>
</math>

 If 

<math display="inline" id="Nearest-neighbor_chain_algorithm:46">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <interval closure="open">
     <ci>A</ci>
     <ci>B</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(A,B)
  </annotation>
 </semantics>
</math>

 is the smallest of the three distances on the right hand side (as would necessarily be true if 

<math display="inline" id="Nearest-neighbor_chain_algorithm:47">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Nearest-neighbor_chain_algorithm:48">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 are mutual nearest-neighbors) then the negative contribution from its term is cancelled by the 

<math display="inline" id="Nearest-neighbor_chain_algorithm:49">
 <semantics>
  <msub>
   <mi>n</mi>
   <mi>C</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{C}
  </annotation>
 </semantics>
</math>

 coefficient of one of the two other terms, leaving a positive value added to the weighted average of the other two distances. Therefore, the combined distance is always at least as large as the minimum of 

<math display="inline" id="Nearest-neighbor_chain_algorithm:50">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <interval closure="open">
     <ci>A</ci>
     <ci>C</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(A,C)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Nearest-neighbor_chain_algorithm:51">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>,</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <interval closure="open">
     <ci>B</ci>
     <ci>C</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(B,C)
  </annotation>
 </semantics>
</math>

, meeting the definition of reducibility.</p>

<p>Therefore, the nearest-neighbor chain algorithm using Ward's distance calculates exactly the same clustering as the standard greedy algorithm. For 

<math display="inline" id="Nearest-neighbor_chain_algorithm:52">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 points in a <a href="Euclidean_space" title="wikilink">Euclidean space</a> of constant dimension, it takes time <mtpl></mtpl> and space 

<math display="inline" id="Nearest-neighbor_chain_algorithm:53">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<h3 id="complete-linkage-and-average-distance">Complete linkage and average distance</h3>

<p><a href="Complete-linkage_clustering" title="wikilink">Complete-linkage</a> or furthest-neighbor clustering is a form of agglomerative clustering that uses the maximum distance between any two points from the two clusters as the dissimilarity, and similarly average-distance clustering uses the average pairwise distance. Like Ward's distance, these forms of clustering obey a formula of Lance-Williams type: in complete linkage, the distance 

<math display="inline" id="Nearest-neighbor_chain_algorithm:54">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mo>∪</mo>
     <mi>B</mi>
    </mrow>
    <mo>,</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <interval closure="open">
     <apply>
      <union></union>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <ci>C</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(A\cup B,C)
  </annotation>
 </semantics>
</math>

 is the average of the distances 

<math display="inline" id="Nearest-neighbor_chain_algorithm:55">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <interval closure="open">
     <ci>A</ci>
     <ci>C</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(A,C)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Nearest-neighbor_chain_algorithm:56">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>,</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <interval closure="open">
     <ci>B</ci>
     <ci>C</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(B,C)
  </annotation>
 </semantics>
</math>

 plus a positive correction term, while for average distance it is just a weighted average of the distances 

<math display="inline" id="Nearest-neighbor_chain_algorithm:57">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <interval closure="open">
     <ci>A</ci>
     <ci>C</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(A,C)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Nearest-neighbor_chain_algorithm:58">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>,</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <interval closure="open">
     <ci>B</ci>
     <ci>C</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(B,C)
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> Thus, in both of these cases, the distance is reducible.</p>

<p>Unlike Ward's method, these two forms of clustering do not have a constant-time method for computing distances between pairs of clusters. Instead it is possible to maintain an array of distances between all pairs of clusters, using the Lance–Williams formula to update the array as pairs of clusters are merged, in time and space <mtpl></mtpl>. The nearest-neighbor chain algorithm may be used in conjunction with this array of distances to find the same clustering as the greedy algorithm for these cases in total time and space <mtpl></mtpl>. The same <mtpl></mtpl> time and space bounds can also be achieved by a different and more general technique that overlays a <a class="uri" href="quadtree" title="wikilink">quadtree</a>-based priority queue data structure on top of the distance matrix and uses it to perform the standard greedy clustering algorithm, avoiding the need for reducibility,<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> but the nearest-neighbor chain algorithm matches its time and space bounds while using simpler data structures.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>
<h3 id="single-linkage">Single linkage</h3>

<p>In <a href="Single-linkage_clustering" title="wikilink">single-linkage</a> or nearest-neighbor clustering, the oldest form of agglomerative hierarchical clustering,<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> the dissimilarity between clusters is measured as the minimum distance between any two points from the two clusters. With this dissimilarity,</p>

<p>

<math display="block" id="Nearest-neighbor_chain_algorithm:59">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mo>∪</mo>
       <mi>B</mi>
      </mrow>
      <mo>,</mo>
      <mi>C</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>min</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>d</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo>,</mo>
        <mi>C</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>d</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>B</mi>
        <mo>,</mo>
        <mi>C</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <apply>
       <union></union>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
      <ci>C</ci>
     </interval>
    </apply>
    <apply>
     <min></min>
     <apply>
      <times></times>
      <ci>d</ci>
      <interval closure="open">
       <ci>A</ci>
       <ci>C</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <interval closure="open">
       <ci>B</ci>
       <ci>C</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(A\cup B,C)=\min(d(A,C),d(B,C)),
  </annotation>
 </semantics>
</math>

 meeting as an equality rather than an inequality the requirement of reducibility. (Single-linkage also obeys a Lance–Williams formula,<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a><a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> but with a negative coefficient from which it is more difficult to prove reducibility.)</p>

<p>As with complete linkage and average distance, the difficulty of calculating cluster distances causes the nearest-neighbor chain algorithm to take time and space <mtpl></mtpl> to compute the single-linkage clustering. However, the single-linkage clustering can be found more efficiently by an alternative algorithm that computes the <a href="minimum_spanning_tree" title="wikilink">minimum spanning tree</a> of the input distances using <a href="Prim's_algorithm" title="wikilink">Prim's algorithm</a> (with an unsorted list of vertices and their priorities in place of the usual priority queue), and then sorts the minimum spanning tree edges and uses this sorted list to guide the merger of pairs of clusters. This alternative method would take time <mtpl></mtpl> and space 

<math display="inline" id="Nearest-neighbor_chain_algorithm:60">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

, matching the best bounds that could be achieved with the nearest-neighbor chain algorithm for distances with constant-time calculations.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>
<h3 id="centroid-distance">Centroid distance</h3>

<p>Another distance measure commonly used in agglomerative clustering is the distance between the centroids of pairs of clusters, also known as the weighted group method.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a><a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> It can be calculated easily in constant time per distance calculation. However, it is not reducible: for instance, if the input forms the set of three points of an equilateral triangle, merging two of these points into a larger cluster causes the inter-cluster distance to decrease, a violation of reducibility. Therefore, the nearest-neighbor chain algorithm will not necessarily find the same clustering as the greedy algorithm. A different algorithm by Day and Edelsbrunner can be used to find the clustering in <mtpl></mtpl> time for this distance measure.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p>
<h3 id="distances-sensitive-to-merge-order">Distances sensitive to merge order</h3>

<p>The above presentation explicitly disallowed distances sensitive to merge order; indeed, allowing such distances can cause problems. In particular, there exist order-sensitive cluster distances which satisfy reducibility, but the above algorithm will return a hierarchy with suboptimal costs.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> Following the earlier discussion of the value of defining cluster distances recursively (so that <a class="uri" href="memoization" title="wikilink">memoization</a> can be used to greatly speed up distance computations), care must be taken with recursively defined distances so that they are not using the hierarchy in a way which is sensitive to merge order.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Data_clustering_algorithms" title="wikilink">Category:Data clustering algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">.<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5">.<a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7">.<a href="#fnref7">↩</a></li>
<li id="fn8">.<a href="#fnref8">↩</a></li>
<li id="fn9">.<a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12">.<a href="#fnref12">↩</a></li>
<li id="fn13">.<a href="#fnref13">↩</a></li>
<li id="fn14">.<a href="#fnref14">↩</a></li>
<li id="fn15"></li>
<li id="fn16">.<a href="#fnref16">↩</a></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21">.<a href="#fnref21">↩</a></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24"></li>
<li id="fn25">.<a href="#fnref25">↩</a></li>
<li id="fn26"></li>
<li id="fn27"></li>
<li id="fn28"></li>
<li id="fn29">.<a href="#fnref29">↩</a></li>
</ol>
</section>
</body>
</html>
