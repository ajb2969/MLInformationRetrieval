<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1910">Wiener deconvolution</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Wiener deconvolution</h1>
<hr/>

<p> In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <strong>Wiener deconvolution</strong> is an application of the <a href="Wiener_filter" title="wikilink">Wiener filter</a> to the <a class="uri" href="noise" title="wikilink">noise</a> problems inherent in <a class="uri" href="deconvolution" title="wikilink">deconvolution</a>. It works in the <a href="frequency_domain" title="wikilink">frequency domain</a>, attempting to minimize the impact of deconvolved noise at frequencies which have a poor <a href="signal-to-noise_ratio" title="wikilink">signal-to-noise ratio</a>.</p>

<p>The Wiener deconvolution method has widespread use in <a class="uri" href="image" title="wikilink">image</a> deconvolution applications, as the frequency spectrum of most visual images is fairly well behaved and may be estimated easily.</p>

<p>Wiener deconvolution is named after <a href="Norbert_Wiener" title="wikilink">Norbert Wiener</a>.</p>
<h2 id="definition">Definition</h2>

<p>Given a system:</p>

<p>

<math display="block" id="Wiener_deconvolution:0">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="5pt" width="+5pt">
     <mi>y</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>h</mi>
       <mo>*</mo>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>x</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ y(t)=(h*x)(t)+n(t)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Wiener_deconvolution:1">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>

 denotes <a class="uri" href="convolution" title="wikilink">convolution</a> and:</p>
<ul>
<li>

<math display="inline" id="Wiener_deconvolution:2">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>x</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ x(t)
  </annotation>
 </semantics>
</math>

 is some input signal (unknown) at time 

<math display="inline" id="Wiener_deconvolution:3">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>t</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ t
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Wiener_deconvolution:4">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>h</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ h(t)
  </annotation>
 </semantics>
</math>

 is the known <a href="impulse_response" title="wikilink">impulse response</a> of a <a href="LTI_system_theory" title="wikilink">linear time-invariant</a> system</li>
<li>

<math display="inline" id="Wiener_deconvolution:5">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>n</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ n(t)
  </annotation>
 </semantics>
</math>

 is some unknown additive noise, <a href="statistical_independence" title="wikilink">independent</a> of 

<math display="inline" id="Wiener_deconvolution:6">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>x</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ x(t)
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Wiener_deconvolution:7">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>y</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ y(t)
  </annotation>
 </semantics>
</math>

 is our observed signal</li>
</ul>

<p>Our goal is to find some 

<math display="inline" id="Wiener_deconvolution:8">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>g</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ g(t)
  </annotation>
 </semantics>
</math>

 so that we can estimate 

<math display="inline" id="Wiener_deconvolution:9">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>x</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ x(t)
  </annotation>
 </semantics>
</math>

 as follows:</p>

<p>

<math display="block" id="Wiener_deconvolution:10">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="5pt" width="+5pt">
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">^</mo>
     </mover>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>g</mi>
      <mo>*</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>x</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>y</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \hat{x}(t)=(g*y)(t)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Wiener_deconvolution:11">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">^</mo>
    </mover>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>x</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \hat{x}(t)
  </annotation>
 </semantics>
</math>

 is an estimate of 

<math display="inline" id="Wiener_deconvolution:12">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>x</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ x(t)
  </annotation>
 </semantics>
</math>

 that minimizes the <a href="mean_square_error" title="wikilink">mean square error</a>.</p>

<p>The Wiener deconvolution filter provides such a 

<math display="inline" id="Wiener_deconvolution:13">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>g</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ g(t)
  </annotation>
 </semantics>
</math>

. The filter is most easily described in the <a href="frequency_domain" title="wikilink">frequency domain</a>:</p>

<p>

<math display="block" id="Wiener_deconvolution:14">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="5pt" width="+5pt">
     <mi>G</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msup>
      <mi>H</mi>
      <mo>*</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <mi>H</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>f</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">|</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>N</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <times></times>
      </apply>
      <ci>f</ci>
      <ci>S</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <abs></abs>
         <apply>
          <times></times>
          <ci>H</ci>
          <ci>f</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>S</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <times></times>
       <ci>N</ci>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ G(f)=\frac{H^{*}(f)S(f)}{|H(f)|^{2}S(f)+N(f)}
  </annotation>
 </semantics>
</math>

</p>

<p>where:</p>
<ul>
<li>

<math display="inline" id="Wiener_deconvolution:15">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>G</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ G(f)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Wiener_deconvolution:16">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>H</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ H(f)
  </annotation>
 </semantics>
</math>

 are the <a href="Fourier_transform" title="wikilink">Fourier transforms</a> of 

<math display="inline" id="Wiener_deconvolution:17">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>g</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ g
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Wiener_deconvolution:18">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>h</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ h
  </annotation>
 </semantics>
</math>

, respectively at frequency 

<math display="inline" id="Wiener_deconvolution:19">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>f</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ f
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Wiener_deconvolution:20">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>S</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ S(f)
  </annotation>
 </semantics>
</math>

 is the mean <a href="power_spectral_density" title="wikilink">power spectral density</a> of the input signal 

<math display="inline" id="Wiener_deconvolution:21">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>x</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ x(t)
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Wiener_deconvolution:22">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>N</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ N(f)
  </annotation>
 </semantics>
</math>

 is the mean power spectral density of the noise 

<math display="inline" id="Wiener_deconvolution:23">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>n</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ n(t)
  </annotation>
 </semantics>
</math>

</li>
<li>the superscript 

<math display="inline" id="Wiener_deconvolution:24">
 <semantics>
  <msup>
   <mi></mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}^{*}
  </annotation>
 </semantics>
</math>

 denotes <a href="complex_conjugate" title="wikilink">complex conjugation</a>.</li>
</ul>

<p>The filtering operation may either be carried out in the time-domain, as above, or in the frequency domain:</p>

<p>

<math display="block" id="Wiener_deconvolution:25">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="5pt" width="+5pt">
     <mover accent="true">
      <mi>X</mi>
      <mo stretchy="false">^</mo>
     </mover>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>Y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>X</ci>
     </apply>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>f</ci>
     <ci>Y</ci>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \hat{X}(f)=G(f)Y(f)
  </annotation>
 </semantics>
</math>

</p>

<p>(where 

<math display="inline" id="Wiener_deconvolution:26">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mover accent="true">
     <mi>X</mi>
     <mo stretchy="false">^</mo>
    </mover>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>X</ci>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \hat{X}(f)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Wiener_deconvolution:27">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>Y</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Y</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ Y(f)
  </annotation>
 </semantics>
</math>

 are the Fourier transforms of 

<math display="inline" id="Wiener_deconvolution:28">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>x</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{x}(t)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Wiener_deconvolution:29">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(t)
  </annotation>
 </semantics>
</math>

, respectively) and then performing an <a href="inverse_Fourier_transform" title="wikilink">inverse Fourier transform</a> on 

<math display="inline" id="Wiener_deconvolution:30">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mover accent="true">
     <mi>X</mi>
     <mo stretchy="false">^</mo>
    </mover>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>X</ci>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \hat{X}(f)
  </annotation>
 </semantics>
</math>

 to obtain 

<math display="inline" id="Wiener_deconvolution:31">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">^</mo>
    </mover>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>x</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \hat{x}(t)
  </annotation>
 </semantics>
</math>

.</p>

<p>Note that in the case of images, the arguments 

<math display="inline" id="Wiener_deconvolution:32">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>t</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ t
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Wiener_deconvolution:33">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>f</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ f
  </annotation>
 </semantics>
</math>

 above become two-dimensional; however the result is the same.</p>
<h2 id="interpretation">Interpretation</h2>

<p>The operation of the Wiener filter becomes apparent when the filter equation above is rewritten:</p>

<p>

<math display="inline" id="Wiener_deconvolution:34">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle G(f)
  </annotation>
 </semantics>
</math>


</p>

<p>Here, 

<math display="inline" id="Wiener_deconvolution:35">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mi>H</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="float">1</cn>
     <ci>H</ci>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ 1/H(f)
  </annotation>
 </semantics>
</math>

 is the inverse of the original system, and 

<math display="inline" id="Wiener_deconvolution:36">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="5pt" width="+5pt">
     <mi>SNR</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>/</mo>
     <mi>N</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>SNR</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>S</ci>
       <ci>f</ci>
      </apply>
      <ci>N</ci>
     </apply>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \mathrm{SNR}(f)=S(f)/N(f)
  </annotation>
 </semantics>
</math>

 is the <a href="signal-to-noise_ratio" title="wikilink">signal-to-noise ratio</a>. When there is zero noise (i.e. infinite signal-to-noise), the term inside the square brackets equals 1, which means that the Wiener filter is simply the inverse of the system, as we might expect. However, as the noise at certain frequencies increases, the signal-to-noise ratio drops, so the term inside the square brackets also drops. This means that the Wiener filter attenuates frequencies dependent on their signal-to-noise ratio.</p>

<p>The Wiener filter equation above requires us to know the spectral content of a typical image, and also that of the noise. Often, we do not have access to these exact quantities, but we may be in a situation where good estimates can be made. For instance, in the case of photographic images, the signal (the original image) typically has strong low frequencies and weak high frequencies, and in many cases the noise content will be relatively flat with frequency.</p>
<h2 id="derivation">Derivation</h2>

<p>As mentioned above, we want to produce an estimate of the original signal that minimizes the mean square error, which may be expressed:</p>

<p>

<math display="block" id="Wiener_deconvolution:37">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="5pt" width="+5pt">
     <mi>系</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi></mi>
    <msup>
     <mrow>
      <mo>|</mo>
      <mrow>
       <mrow>
        <mi>X</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>f</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mover accent="true">
         <mi>X</mi>
         <mo stretchy="false">^</mo>
        </mover>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>f</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>|</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>系</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci></ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>X</ci>
         <ci>f</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <ci>normal-^</ci>
          <ci>X</ci>
         </apply>
         <ci>f</ci>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \epsilon(f)=\mathbb{E}\left|X(f)-\hat{X}(f)\right|^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Wiener_deconvolution:38">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi></mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci></ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \mathbb{E}
  </annotation>
 </semantics>
</math>


 denotes <a href="Expected_value" title="wikilink">expectation</a>.</p>

<p>If we substitute in the expression for 

<math display="inline" id="Wiener_deconvolution:39">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mover accent="true">
     <mi>X</mi>
     <mo stretchy="false">^</mo>
    </mover>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>X</ci>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \hat{X}(f)
  </annotation>
 </semantics>
</math>

, the above can be rearranged to</p>

<p>

<math display="inline" id="Wiener_deconvolution:40">
 <semantics>
  <mrow>
   <mi>系</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>系</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\epsilon(f)
  </annotation>
 </semantics>
</math>


</p>

<p>If we expand the quadratic, we get the following:</p>

<p>

<math display="inline" id="Wiener_deconvolution:41">
 <semantics>
  <mrow>
   <mi>系</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>系</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\epsilon(f)
  </annotation>
 </semantics>
</math>


</p>

<p>However, we are assuming that the noise is independent of the signal, therefore:</p>

<p>

<math display="block" id="Wiener_deconvolution:42">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="5pt" width="+5pt">
     <mi></mi>
    </mpadded>
    <mrow>
     <mo maxsize="160%" minsize="160%">{</mo>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>V</mi>
       <mo>*</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo maxsize="160%" minsize="160%">}</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi></mi>
    <mrow>
     <mo maxsize="160%" minsize="160%">{</mo>
     <mrow>
      <mi>V</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>X</mi>
       <mo>*</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo maxsize="160%" minsize="160%">}</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci></ci>
      <set>
       <apply>
        <times></times>
        <ci>X</ci>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>V</ci>
         <times></times>
        </apply>
        <ci>f</ci>
       </apply>
      </set>
     </apply>
     <apply>
      <times></times>
      <ci></ci>
      <set>
       <apply>
        <times></times>
        <ci>V</ci>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>X</ci>
         <times></times>
        </apply>
        <ci>f</ci>
       </apply>
      </set>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \mathbb{E}\Big\{X(f)V^{*}(f)\Big\}=\mathbb{E}\Big\{V(f)X^{*}(f)\Big\}=0
  </annotation>
 </semantics>
</math>

</p>

<p>Also, we are defining the power spectral densities as follows:</p>

<p>

<math display="block" id="Wiener_deconvolution:43">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="5pt" width="+5pt">
     <mi>S</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi></mi>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>X</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>f</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci></ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <ci>X</ci>
        <ci>f</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ S(f)=\mathbb{E}|X(f)|^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Wiener_deconvolution:44">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="5pt" width="+5pt">
     <mi>N</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi></mi>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>V</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>f</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci></ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <ci>V</ci>
        <ci>f</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ N(f)=\mathbb{E}|V(f)|^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>Therefore, we have:</p>

<p>

<math display="block" id="Wiener_deconvolution:45">
 <semantics>
  <mrow>
   <mrow>
    <mi>系</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo maxsize="160%" minsize="160%">[</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mrow>
        <mi>G</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>f</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>H</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>f</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo maxsize="160%" minsize="160%">]</mo>
     </mrow>
     <msup>
      <mrow>
       <mo maxsize="160%" minsize="160%">[</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <mi>G</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>f</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>H</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>f</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo maxsize="160%" minsize="160%">]</mo>
      </mrow>
      <mo>*</mo>
     </msup>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>G</mi>
      <mo>*</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>N</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>系</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <ci>G</ci>
         <ci>f</ci>
         <ci>H</ci>
         <ci>f</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <apply>
          <times></times>
          <ci>G</ci>
          <ci>f</ci>
          <ci>H</ci>
          <ci>f</ci>
         </apply>
        </apply>
       </apply>
       <times></times>
      </apply>
      <ci>S</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>G</ci>
       <times></times>
      </apply>
      <ci>f</ci>
      <ci>N</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon(f)=\Big[1-G(f)H(f)\Big]\Big[1-G(f)H(f)\Big]^{*}S(f)+G(f)G^{*}(f)N(f)
  </annotation>
 </semantics>
</math>

</p>

<p>To find the minimum error value, we calculate the <a href="Wirtinger_derivatives" title="wikilink">Wirtinger derivative</a> with respect to 

<math display="inline" id="Wiener_deconvolution:46">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>G</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ G(f)
  </annotation>
 </semantics>
</math>

 and set it equal to zero.</p>

<p>

<math display="block" id="Wiener_deconvolution:47">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mfrac>
     <mrow>
      <mi>d</mi>
      <mi>系</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>d</mi>
      <mi>G</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mpadded>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>G</mi>
      <mo>*</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>N</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>H</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mrow>
       <mo maxsize="160%" minsize="160%">[</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <mi>G</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>f</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>H</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>f</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo maxsize="160%" minsize="160%">]</mo>
      </mrow>
      <mo>*</mo>
     </msup>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>系</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>G</ci>
       <ci>f</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>G</ci>
        <times></times>
       </apply>
       <ci>f</ci>
       <ci>N</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <times></times>
       <ci>H</ci>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
          <apply>
           <times></times>
           <ci>G</ci>
           <ci>f</ci>
           <ci>H</ci>
           <ci>f</ci>
          </apply>
         </apply>
        </apply>
        <times></times>
       </apply>
       <ci>S</ci>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \frac{d\epsilon(f)}{dG(f)}=G^{*}(f)N(f)-H(f)\Big[1-G(f)H(f)\Big]^{*}S(f)=0
  </annotation>
 </semantics>
</math>

</p>

<p>This final equality can be rearranged to give the Wiener filter.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Deconvolution" title="wikilink">Deconvolution</a></li>
<li><a href="Wiener_filter" title="wikilink">Wiener filter</a></li>
<li><a href="Point_spread_function" title="wikilink">Point spread function</a></li>
<li><a href="Blind_deconvolution" title="wikilink">Blind deconvolution</a></li>
<li><a href="Fourier_transform" title="wikilink">Fourier transform</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Rafael Gonzalez, Richard Woods, and Steven Eddins. <em>Digital Image Processing Using Matlab</em>. Prentice Hall, 2003.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.owlnet.rice.edu/~elec539/Projects99/BACH/proj2/blind/bd.html">Comparison of different deconvolution methods.</a></li>
<li><a href="http://cnx.org/content/m13144/latest/">Deconvolution with a Wiener filter</a></li>
</ul>

<p>"</p>

<p><a href="Category:Signal_processing" title="wikilink">Category:Signal processing</a> <a href="Category:Image_noise_reduction_techniques" title="wikilink">Category:Image noise reduction techniques</a> <a href="Category:Estimation_theory" title="wikilink">Category:Estimation theory</a></p>
</body>
</html>
