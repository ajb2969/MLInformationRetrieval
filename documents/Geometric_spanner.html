<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1686">Geometric spanner</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Geometric spanner</h1>
<hr/>

<p>A <strong>geometric spanner</strong> or a <strong><em>t</em>-spanner graph</strong> or a <strong><em>t</em>-spanner</strong> was initially introduced as a <a href="weighted_graph" title="wikilink">weighted graph</a> over a set of points as its vertices for which there is a <strong><em>t</em>-path</strong> between any pair of vertices for a fixed parameter <em>t</em>. A <em>t</em>-path is defined as a path through the graph with weight at most <em>t</em> times the spatial distance between its endpoints. The parameter <em>t</em> is called the <strong>stretch factor</strong> or <strong>dilation factor</strong> of the spanner.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>In <a href="computational_geometry" title="wikilink">computational geometry</a>, the concept was first discussed by L.P. Chew in 1986,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> although the term "spanner" was not used in the original paper.</p>

<p>The notion of <a href="graph_spanner" title="wikilink">graph spanners</a> has been known in <a href="graph_theory" title="wikilink">graph theory</a>: <em>t</em>-spanners are <a href="spanning_subgraph" title="wikilink">spanning subgraphs</a> of graphs with similar dilation property, where distances between graph vertices are defined in <a href="Glossary_of_graph_theory#Distance" title="wikilink">graph-theoretical terms</a>. Therefore geometric spanners are graph spanners of <a href="complete_graph" title="wikilink">complete graphs</a> <a href="graph_embedding" title="wikilink">embedded in the plane</a> with edge weights equal to the distances between the embedded vertices in the corresponding metric.</p>

<p>Spanners may be used in <a href="computational_geometry" title="wikilink">computational geometry</a> for solving some <a href="proximity_problems" title="wikilink">proximity problems</a>. They have also found applications in other areas, such as in <a href="motion_planning" title="wikilink">motion planning</a>, in <a href="telecommunication_network" title="wikilink">telecommunication networks</a>: network reliability, optimization of <a class="uri" href="roaming" title="wikilink">roaming</a> in <a href="mobile_network" title="wikilink">mobile networks</a>, etc.</p>
<h2 id="different-spanners-and-quality-measures">Different spanners and quality measures</h2>

<p>There are different measures which can be used to analyze the quality of a spanner. The most common measures are edge count, total weight and maximum vertex <a href="Degree_(graph_theory)" title="wikilink">degree</a>. <a href="Asymptotic_notation" title="wikilink">Asymptotically</a> optimal values for these measures are 

<math display="inline" id="Geometric_spanner:0">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 edges, 

<math display="inline" id="Geometric_spanner:1">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>M</mi>
     <mi>S</mi>
     <mi>T</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>M</ci>
     <ci>S</ci>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(MST)
  </annotation>
 </semantics>
</math>

 weight and 

<math display="inline" id="Geometric_spanner:2">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1)
  </annotation>
 </semantics>
</math>

 maximum degree (here MST denotes the weight of the <a href="minimum_spanning_tree" title="wikilink">minimum spanning tree</a>).</p>

<p>Finding a <em>spanner</em> in the Euclidean plane with minimal dilation over <em>n</em> points with at most <em>m</em> edges is known to be <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Many spanner algorithms exist which excel in different quality measures. Fast algorithms include the <a href="Well-separated_pair_decomposition" title="wikilink">WSPD</a> spanner and the <a href="Theta_graph" title="wikilink">Theta graph</a> which both construct spanners with a linear number of edges in 

<math display="inline" id="Geometric_spanner:3">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n\log n)
  </annotation>
 </semantics>
</math>


 time. If better weight and vertex degree is required the Greedy spanner can be computed in near quadratic time.</p>
<h2 id="the-theta-graph">The Theta graph</h2>

<p>The <em>Theta graph</em> or <em>

<math display="inline" id="Geometric_spanner:4">
 <semantics>
  <mi mathvariant="normal">Θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta
  </annotation>
 </semantics>
</math>

-graph</em> belongs to the family of cone-based spanners. The basic method of construction involves partitioning the space around each vertex into a set of cones, which themselves partition the remaining vertices of the graph. Like <a href="Yao_graph" title="wikilink">Yao Graphs</a>, a 

<math display="inline" id="Geometric_spanner:5">
 <semantics>
  <mi mathvariant="normal">Θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta
  </annotation>
 </semantics>
</math>

-graph contains at most one edge per cone; where they differ is how that edge is selected. Whereas Yao Graphs will select the nearest vertex according to the metric space of the graph, the 

<math display="inline" id="Geometric_spanner:6">
 <semantics>
  <mi mathvariant="normal">Θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta
  </annotation>
 </semantics>
</math>

-graph defines a fixed ray contained within each cone (conventionally the bisector of the cone) and selects the nearest neighbour with respect to orthogonal projections to that ray.</p>

<p>See the page on the <a href="Theta_graph" title="wikilink">Theta graph</a> for more detailed information on this spanner.</p>
<h2 id="the-greedy-spanner">The greedy spanner</h2>

<p>The <em>greedy spanner</em> or <em>greedy graph</em> is defined as the graph resulting from repeatedly adding an edge between the closest pair of points without a <em>t</em>-path. Algorithms which compute this graph are referred to as greedy spanner algorithms. From the construction it trivially follows that the greedy graph is a <em>t</em>-spanner.</p>

<p>The greedy spanner was first discovered in 1989 independently by Althöfer<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> and Bern (unpublished).</p>

<p>The greedy spanner achieves asymptotically optimal edge count, total weight and maximum vertex degree and also performs best on these measures in practice.</p>
<h3 id="computing-the-greedy-spanner">Computing the greedy spanner</h3>

<p>The original naive algorithm for computing the greedy spanner sorts all pairs of points in ascending order by distance from each other. Starting at the closest pair of points it repeatedly checks if there is a t-path connecting the pair by computing the shortest path. If no t-path exists it adds an edge for this pair. Since there are a quadratic number of pairs of points and computing the shortest path on a sparse graph can be done in 

<math display="inline" id="Geometric_spanner:7">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n\log n)
  </annotation>
 </semantics>
</math>

 time using <a href="Dijkstra's_algorithm" title="wikilink">Dijkstra's algorithm</a> the naive algorithm computes the greedy spanner in 

<math display="inline" id="Geometric_spanner:8">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>n</mi>
      <mn>3</mn>
     </msup>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3}\log n)
  </annotation>
 </semantics>
</math>


 time. Since the naive algorithm sorts a quadratic number of edges its space usage is 

<math display="inline" id="Geometric_spanner:9">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2})
  </annotation>
 </semantics>
</math>

.</p>

<p>Several faster, near-quadratic time, algorithms exist. Most of these algorithms rely on some kind of caching or other method of reusing information gained from shortest path queries.</p>

<p>The asymptotically fastest greedy spanner algorithm runs in 

<math display="inline" id="Geometric_spanner:10">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>n</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2}\log n)
  </annotation>
 </semantics>
</math>

 time using 

<math display="inline" id="Geometric_spanner:11">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2})
  </annotation>
 </semantics>
</math>

 space.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>The quadratic space usage of this algorithm makes using it to compute the greedy graph on large point sets impossible in practice. A Linear space algorithm exists which runs in 

<math display="inline" id="Geometric_spanner:12">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>n</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <msup>
       <mi>log</mi>
       <mn>2</mn>
      </msup>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <log></log>
       <cn type="integer">2</cn>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2}\log^{2}n)
  </annotation>
 </semantics>
</math>

 time<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> making it possible to compute the greedy graph on larger point sets.</p>
<h2 id="the-delaunay-triangulation">The Delaunay triangulation</h2>

<p>Chew's main result was that for a set of points in the plane there is a <a class="uri" href="triangulation" title="wikilink">triangulation</a> of this pointset such that for any two points there is a path along the edges of the triangulation with length at most 

<math display="inline" id="Geometric_spanner:13">
 <semantics>
  <mrow>
   <msqrt>
    <mn>1</mn>
   </msqrt>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <root></root>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\sqrt{1}0
  </annotation>
 </semantics>
</math>


 the <a href="Euclidean_distance" title="wikilink">Euclidean distance</a> between the two points. The result was applied in motion planning for finding reasonable approximations of shortest paths among obstacles.</p>

<p>The best upper bound known for the Euclidean <a href="Delaunay_triangulation" title="wikilink">Delaunay triangulation</a> is that it is a 

<math display="inline" id="Geometric_spanner:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mn>4</mn>
       <msqrt>
        <mn>3</mn>
       </msqrt>
      </mrow>
      <mo>/</mo>
      <mn>9</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>π</mi>
   </mrow>
   <mo>≈</mo>
   <mn>2.418</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <cn type="integer">4</cn>
       <apply>
        <root></root>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <cn type="integer">9</cn>
     </apply>
     <ci>π</ci>
    </apply>
    <cn type="float">2.418</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle{(4\sqrt{3}/9)\pi}\approx 2.418
  </annotation>
 </semantics>
</math>

-spanner for its vertices.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> The lower bound has been increased from 

<math display="inline" id="Geometric_spanner:15">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>π</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle{{\pi}/2}
  </annotation>
 </semantics>
</math>

 to just over that, to 1.5846. <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Geometric_algorithms" title="wikilink">Category:Geometric algorithms</a> <a href="Category:Geometric_graphs" title="wikilink">Category:Geometric graphs</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">.<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6">S. P. A. Alewijnse, Q. W. Bouts, A. P. T. Brink and K. Buchin. (2013). "Computing the Greedy Spanner in Linear Space", <em><a href="European_Symposium_on_Algorithms" title="wikilink">Proc. 21st Annual European Symposium on Algorithms</a>, Sophia Antipolis, France, 2013</em>, <a href="Lecture_Notes_in_Computer_Science" title="wikilink">Lecture Notes in Computer Science</a> <strong>8125</strong>, <a href="Springer_Verlag" title="wikilink">Springer Verlag</a>, pp. 37-48<a href="#fnref6">↩</a></li>
<li id="fn7">.<a href="#fnref7">↩</a></li>
<li id="fn8">.<a href="#fnref8">↩</a></li>
</ol>
</section>
</body>
</html>
