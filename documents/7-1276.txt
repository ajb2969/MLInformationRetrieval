   Separation logic      Separation logic   In computer science , separation logic 1 is an extension of Hoare logic , a way of reasoning about programs. It was developed by John C. Reynolds , Peter O'Hearn , Samin Ishtiaq and Hongseok Yang, 2 3 4 5 drawing upon early work by Rod Burstall . 6 The assertion language of separation logic is a special case of the logic of bunched implications (BI). 7  Separation logic facilitates reasoning about:   programs that manipulate pointer data structures â€” including information hiding in the presence of pointers;  "transfer of ownership" (avoidance of semantic frame axioms ); and  virtual separation (modular reasoning) between concurrent modules.   Separation logic supports the developing field of research described by Peter O'Hearn and others as local reasoning , whereby specifications and proofs of a program component mention only the portion of memory used by the component, and not the entire global state of the system. Applications include automated program verification (where an algorithm checks the validity of another algorithm) and automated parallelization of software.  Assertions: Operators and semantics  Separation logic assertions describe "states" consisting of a store and a heap , roughly corresponding to the state of local (or stack-allocated ) variables and dynamically-allocated objects in common programming languages such as C and Java . A store   s   s   s   is a function mapping variables to values. A heap   h   h   h   is a partial function mapping memory addresses to values. Two heaps   h   h   h   and    h  â€²     superscript  h  normal-â€²    h^{\prime}   are disjoint (denoted     h   âŠ¥   h  â€²      bottom  h   superscript  h  normal-â€²     h\,\bot\,h^{\prime}   ) if their domains do not overlap (i.e., if for every memory address   â„“   normal-â„“   \ell   , at least one of    h   (  â„“  )       h  normal-â„“    h(\ell)   and     h  â€²    (  â„“  )        superscript  h  normal-â€²   normal-â„“    h^{\prime}(\ell)   is undefined).  The logic allows to prove judgements of the form     s  ,  h   âŠ§  P     models   s  h   P    s,h\models P   , where   s   s   s   is a store,   h   h   h   is a heap, and   P   P   P   is an assertion over the given store and heap. Separation logic assertions (denoted as   P   P   P   ,   Q   Q   Q   ,   R   R   R   ) contain the standard boolean connectives and, in addition,   ğğ¦ğ©   ğğ¦ğ©   \mathbf{e}\mathbf{m}\mathbf{p}   ,    e  â†¦   e  â€²      maps-to  e   superscript  e  normal-â€²     e\mapsto e^{\prime}   ,    P  âˆ—  Q     normal-âˆ—  P  Q    P\ast Q   , and    P  -  âˆ—  Q     fragments  P   normal-âˆ—  Q    P{-\!\!\ast}\,Q   , where   e   e   e   and    e  â€²     superscript  e  normal-â€²    e^{\prime}   are expressions.   The constant   ğğ¦ğ©   ğğ¦ğ©   \mathbf{e}\mathbf{m}\mathbf{p}   asserts that the heap is empty , i.e.,     s  ,  h   âŠ§  ğğ¦ğ©     models   s  h   ğğ¦ğ©    s,h\models\mathbf{e}\mathbf{m}\mathbf{p}   when   h   h   h   is undefined for all addresses.  The binary operator   â†¦   maps-to   \mapsto   takes an address and a value and asserts that the heap is defined at exactly one location, mapping the given address to the given value. I.e.,     s  ,  h   âŠ§  e  â†¦   e  â€²        models   s  h   e    maps-to     superscript  e  normal-â€²      s,h\models e\mapsto e^{\prime}   when     h   (    [   [  e  ]   ]   s   )    =    [   [   e  â€²   ]   ]   s         h   subscript   delimited-[]   delimited-[]  e    s     subscript   delimited-[]   delimited-[]   superscript  e  normal-â€²     s     h([\![e]\!]_{s})=[\![e^{\prime}]\!]_{s}   (where     [   [  e  ]   ]   s     subscript   delimited-[]   delimited-[]  e    s    [\![e]\!]_{s}   denotes the value of expression   e   e   e   evaluated in store   s   s   s   ) and   h   h   h   is otherwise undefined.  The binary operator   âˆ—   normal-âˆ—   \ast   (pronounced star or separating conjunction ) asserts that the heap can be split into two disjoint parts where its two arguments hold, respectively. I.e.,     s  ,  h   âŠ§   P  âˆ—  Q      models   s  h    normal-âˆ—  P  Q     s,h\models P\ast Q   when there exist     h  1   ,   h  2       subscript  h  1    subscript  h  2     h_{1},h_{2}   such that      h  1    âŠ¥   h  2      bottom   subscript  h  1    subscript  h  2     h_{1}\,\bot\,h_{2}   and    h  =    h  1   âˆª   h  2        h     subscript  h  1    subscript  h  2      h=h_{1}\cup h_{2}   and     s  ,   h  1    âŠ§  P     models   s   subscript  h  1    P    s,h_{1}\models P   and     s  ,   h  2    âŠ§  Q     models   s   subscript  h  2    Q    s,h_{2}\models Q   .  The binary operator    -  âˆ—      normal-âˆ—    -\!\!\ast   (pronounced magic wand or separating implication ) asserts that extending the heap with a disjoint part that satisfies its first argument results in a heap that satisfies its second argument. I.e,.    s  ,  h  âŠ§  P  -  âˆ—  Q     fragments  s  normal-,  h  models  P   normal-âˆ—  Q    s,h\models P-\!\!\ast\,Q   when for every heap      h  â€²    âŠ¥  h     bottom   superscript  h  normal-â€²   h    h^{\prime}\,\bot\,h   such that     s  ,   h  â€²    âŠ§  P     models   s   superscript  h  normal-â€²    P    s,h^{\prime}\models P   , also     s  ,   h  âˆª   h  â€²     âŠ§  Q     models   s    h   superscript  h  normal-â€²     Q    s,h\cup h^{\prime}\models Q   holds.   The operators   âˆ—   normal-âˆ—   \ast   and    -  âˆ—      normal-âˆ—    -\!\!\ast   share some properties with the classical conjunction and implication operators. They can be combined using an inference rule similar to modus ponens       s  ,  h  âŠ§  P  âˆ—   (  P  -  âˆ—  Q  )      s  ,  h   âŠ§  Q        fragments  s  normal-,  h  models  P  normal-âˆ—   fragments  normal-(  P   normal-âˆ—  Q  normal-)     models   s  h   Q     \frac{s,h\models P\ast(P-\!\!\ast\,Q)}{s,h\models Q}   and they form an adjunction , i.e.,     s  ,   h  âˆª   h  â€²     âŠ§   P  âˆ—  Q   â‡’  R       models   s    h   superscript  h  normal-â€²      normal-âˆ—  P  Q     normal-â‡’    R     s,h\cup h^{\prime}\models P\ast Q\Rightarrow R   if and only if    s  ,  h  âŠ§  P  â‡’  Q  -  âˆ—  R     fragments  s  normal-,  h  models  P  normal-â‡’  Q   normal-âˆ—  R    s,h\models P\Rightarrow Q-\!\!\ast\,R   for     h   âŠ¥   h  â€²      bottom  h   superscript  h  normal-â€²     h\,\bot\,h^{\prime}   ; more precisely, the adjoint operators are    _  âˆ—  Q     normal-âˆ—  normal-_  Q    \_\ast Q   and    Q  -  âˆ—  _     fragments  Q   normal-âˆ—  _    Q-\!\!\ast\,\_   .  Reasoning about programs: triples and proof rules  In separation logic, Hoare triples have a slightly different meaning than in Hoare logic . The triple     {  P  }    C    {  Q  }        P   C   Q     \{P\}\ C\ \{Q\}   asserts that if the program,   C   C   C   , executes from an initial state satisfying the precondition,   P   P   P   , then the program will not go wrong (e.g., have undefined behaviour), and if it terminates, then the final state will satisfy the postcondition,   Q   Q   Q   . In essence, during its execution,   C   C   C   may access only memory locations whose existence is asserted in the precondition or that have been allocated by   C   C   C   itself.  In addition to the standard rules from Hoare logic , separation logic supports the following very important rule:            {  P  }    C    {  Q  }      {   P  âˆ—  R   }    C    {   Q  âˆ—  R   }      ğ—†ğ—ˆğ–½   (  C  )    âˆ©   ğ–¿ğ—   (  R  )     =  âˆ…               P   C   Q        normal-âˆ—  P  R    C    normal-âˆ—  Q  R      ğ—†ğ—ˆğ–½  C     ğ–¿ğ—  R       \frac{\{P\}\ C\ \{Q\}}{\{P\ast R\}\ C\ \{Q\ast R\}}~{}\mathsf{mod}(C)\cap%
 \mathsf{fv}(R)=\emptyset     This is known as the frame rule (named after the frame problem ) and enables local reasoning. It says that a program that executes safely in a small state (satisfying   P   P   P   ), can also execute in any bigger state (satisfying    P  âˆ—  R     normal-âˆ—  P  R    P\ast R   ) and that its execution will not affect the additional part of the state (and so   R   R   R   will remain true in the postcondition). The side condition enforces this by specifying that none of the variables modified by   C   C   C   occur free in   R   R   R   , i.e. none of them are in the 'free variable' set   ğ–¿ğ—   ğ–¿ğ—   \mathsf{fv}   of   R   R   R   .  Implementations  The Ynot 8 library for the Coq proof assistant contains an implementation.  The Infer 9 tool for static analysis of Java, C, and Objective-C is based on separation logic and bi-abduction as its foundation. 10  References    "  Category:Program logic  Category:Substructural logic  Category:Logic in computer science     Separation Logic: A Logic for Shared Mutable Data Structures. John C. Reynolds. LICS 2002. â†©   Intuitionistic Reasoning about Shared Mutable Data Structure. John Reynolds. Millennial Perspectives in Computer Science, Proceedings of the 1999 Oxford-Microsoft Symposium in Honour of Sir Tony Hoare â†©  BI as an Assertion Language for Mutable Data Structures. Samin Ishtiaq, Peter O'Hearn. POPL 2001. â†©  Local Reasoning about Programs that Alter Data Structures. Peter O'Hearn, John Reynolds, Hongseok Yang. CSL 2001 â†©  Some techniques for proving programs which alter data structures. R.M. Burstall. Machine Intelligence 7, 1972. â†©  The Logic of Bunched Implications P.W. O'Hearn and D. J. Pym. Bulletin of Symbolic Logic , 5(2), June 1999, pp215-244 â†©  The Ynot Project homepage â†©  The Infer project page on Github â†©  Separation logic and bi-abduction, page on Infer project site â†©     