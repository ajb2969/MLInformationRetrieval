   Normalisation by evaluation      Normalisation by evaluation   In programming language  semantics , normalisation by evaluation (NBE) is a style of obtaining the normal form of terms in the Î» calculus by appealing to their denotational semantics . A term is first interpreted into a denotational model of the Î»-term structure, and then a canonical (Î²-normal and Î·-long) representative is extracted by reifying the denotation. Such an essentially semantic approach differs from the more traditional syntactic description of normalisation as a reductions in a term rewrite system where Î²-reductions are allowed deep inside Î»-terms.  NBE was first described for the simply typed lambda calculus . 1 It has since been extended both to weaker type systems such as the untyped lambda calculus 2 using a domain theoretic approach, and to richer type systems such as several variants of Martin-LÃ¶f type theory . 3 4  Outline  Consider the simply typed lambda calculus , where types Ï„ can be basic types (Î±), function types (â†’), or products (Ã—), given by the following Backusâ€“Naur Form grammar (â†’ associating to the right, as usual):   (Types) Ï„ ::= Î± | Ï„ 1 â†’ Ï„ 2 | Ï„ 1 Ã— Ï„ 2    These can be implemented as a datatype in the meta-language; for example, for Standard ML , we might use:  datatype ty = Basic of string
              | Arrow of ty * ty
              | Prod of ty * ty  Terms are defined at two levels. 5 The lower syntactic level (sometimes called the dynamic level) is the representation that one intends to normalise.   (Syntax Terms) s , t ,â€¦ ::= var  x | lam ( x , t ) | app ( s , t ) | pair ( s , t ) | fst  t | snd  t    Here lam / app (resp. pair / fst , snd ) are the intro / elim forms for â†’ (resp. Ã—), and x are variables . These terms are intended to be implemented as a first-order in the meta-language:  datatype tm = var of string
              | lam of string * tm | app of tm * tm
              | pair of tm * tm | fst of tm | snd of tm  The denotational semantics of (closed) terms in the meta-language interprets the constructs of the syntax in terms of features of the meta-language; thus, lam is interpreted as abstraction, app as application, etc. The semantic objects constructed are as follows:   (Semantic Terms) S , T ,â€¦ ::= LAM (Î» x . S  x ) | PAIR ( S , T ) | SYN  t    Note that there are no variables or elimination forms in the semantics; they are represented simply as syntax. These semantic objects are represented by the following datatype:  datatype sem = LAM of (sem -> sem)
               | PAIR of sem * sem
               | SYN of tm  There are a pair of type-indexed functions that move back and forth between the syntactic and semantic layer. The first function, usually written â†‘ Ï„ , reflects the term syntax into the semantics, while the second reifies the semantics as a syntactic term (written as â†“ Ï„ ). Their definitions are mutually recursive as follows:            â†‘  Î±   t       =    ð’ð˜ð   t           â†‘    Ï„  1   â†’   Ï„  2     v      =  ð‹ð€ðŒ   (  Î»  S  .   â†‘   Ï„  2     (   ðšð©ð©    (  v  ,   â†“   Ï„  1    S  )   )   )           â†‘    Ï„  1   Ã—   Ï„  2     v      =  ðð€ðˆð‘   (   â†‘   Ï„  1     (   ðŸð¬ð­   v  )   ,   â†‘   Ï„  2     (   ð¬ð§ð   v  )   )           â†“  Î±    (    ð’ð˜ð   t   )        =  t          â†“    Ï„  1   â†’   Ï„  2      (    ð‹ð€ðŒ   S   )       =   ð¥ðšð¦    (  x  ,   â†“   Ï„  2     (   S    (   â†‘   Ï„  1     (   ð¯ðšð«   x  )   )   )   )   where  x  is fresh          â†“    Ï„  1   Ã—   Ï„  2      (    ðð€ðˆð‘    (  S  ,  T  )    )       =   ð©ðšð¢ð«    (   â†“   Ï„  1    S  ,   â†“   Ï„  2    T  )            subscript  normal-â†‘  Î±   absent  t     absent    ð’ð˜ð  t        subscript  normal-â†‘   normal-â†’   subscript  Ï„  1    subscript  Ï„  2     absent  v    fragments   LAM   fragments  normal-(  Î»  S  normal-.   subscript  normal-â†‘   subscript  Ï„  2     fragments  normal-(  app   fragments  normal-(  v  normal-,   superscript  normal-â†“   subscript  Ï„  1    S  normal-)   normal-)   normal-)        subscript  normal-â†‘     subscript  Ï„  1    subscript  Ï„  2     absent  v    fragments   PAIR   fragments  normal-(   subscript  normal-â†‘   subscript  Ï„  1     fragments  normal-(  fst  v  normal-)   normal-,   subscript  normal-â†‘   subscript  Ï„  2     fragments  normal-(  snd  v  normal-)   normal-)        superscript  normal-â†“  Î±   absent    ð’ð˜ð  t      absent  t       superscript  normal-â†“   normal-â†’   subscript  Ï„  1    subscript  Ï„  2     absent    ð‹ð€ðŒ  S     fragments   lam   fragments  normal-(  x  normal-,   superscript  normal-â†“   subscript  Ï„  2     fragments  normal-(  S   fragments  normal-(   subscript  normal-â†‘   subscript  Ï„  1     fragments  normal-(  var  x  normal-)   normal-)   normal-)   normal-)   where  x  is fresh       superscript  normal-â†“     subscript  Ï„  1    subscript  Ï„  2     absent    ðð€ðˆð‘   S  T      fragments   pair   fragments  normal-(   superscript  normal-â†“   subscript  Ï„  1    S  normal-,   superscript  normal-â†“   subscript  Ï„  2    T  normal-)       \begin{aligned}\displaystyle\uparrow_{\alpha}t&\displaystyle=\mathbf{SYN}\ t\\
 \displaystyle\uparrow_{\tau_{1}\to\tau_{2}}v&\displaystyle=\mathbf{LAM}(%
 \lambda S.\ \uparrow_{\tau_{2}}(\mathbf{app}\ (v,\downarrow^{\tau_{1}}S)))\\
 \displaystyle\uparrow_{\tau_{1}\times\tau_{2}}v&\displaystyle=\mathbf{PAIR}(%
 \uparrow_{\tau_{1}}(\mathbf{fst}\ v),\uparrow_{\tau_{2}}(\mathbf{snd}\ v))\\
 \displaystyle\downarrow^{\alpha}(\mathbf{SYN}\ t)&\displaystyle=t\\
 \displaystyle\downarrow^{\tau_{1}\to\tau_{2}}(\mathbf{LAM}\ S)&\displaystyle=%
 \mathbf{lam}\ (x,\downarrow^{\tau_{2}}(S\ (\uparrow_{\tau_{1}}(\mathbf{var}\ x%
 ))))\text{ where }x\text{ is fresh}\\
 \displaystyle\downarrow^{\tau_{1}\times\tau_{2}}(\mathbf{PAIR}\ (S,T))&%
 \displaystyle=\mathbf{pair}\ (\downarrow^{\tau_{1}}S,\downarrow^{\tau_{2}}T)%
 \end{aligned}      These definitions are easily implemented in the meta-language:  (* reflect : ty -> tm -> sem *)
  fun reflect (Arrow (a, b)) t =
        LAM (fn S => reflect b (app t (reify a S)))
    | reflect (Prod (a, b)) t =
        PAIR (reflect a (fst t)) (reflect b (snd t))
    | reflect (Basic _) t =
        SYN t
 
  (* reify   : ty -> sem -> tm *)
  and reify (Arrow (a, b)) (LAM S) =
        let x = fresh_var () in
          Lam (x, reify b (S (reflect a (var x))))
        end
    | reify (Prod (a, b)) (PAIR S T) =
        Pair (reify a S, reify b T)
    | reify (Basic _) (SYN t) = t  By induction on the structure of types, it follows that if the semantic object S denotes a well-typed term s of type Ï„, then reifying the object (i.e., â†“ Ï„ S) produces the Î²-normal Î·-long form of s . All that remains is, therefore, to construct the initial semantic interpretation S from a syntactic term s . This operation, written âˆ¥ s âˆ¥ Î“ , where Î“ is a context of bindings, proceeds by induction solely on the term structure:           âˆ¥    ð¯ðšð«   x   âˆ¥   Î“       =   Î“   (  x  )           âˆ¥    ð¥ðšð¦    (  x  ,  s  )    âˆ¥   Î“      =   ð‹ð€ðŒ    (  Î»  S  .  âˆ¥  s   âˆ¥    Î“  ,  x   â†¦  S    )          âˆ¥    ðšð©ð©    (  s  ,  t  )    âˆ¥   Î“       =    S    (    âˆ¥  t  âˆ¥   Î“   )   where    âˆ¥  s  âˆ¥   Î“    =    ð‹ð€ðŒ   S          âˆ¥    ð©ðšð¢ð«    (  s  ,  t  )    âˆ¥   Î“       =    ðð€ðˆð‘    (    âˆ¥  s  âˆ¥   Î“   ,    âˆ¥  t  âˆ¥   Î“   )           âˆ¥    ðŸð¬ð­   s   âˆ¥   Î“       =   S  where    âˆ¥  s  âˆ¥   Î“    =    ðð€ðˆð‘    (  S  ,  T  )           âˆ¥    ð¬ð§ð   t   âˆ¥   Î“       =   T  where    âˆ¥  t  âˆ¥   Î“    =    ðð€ðˆð‘    (  S  ,  T  )            subscript   norm    ð¯ðšð«  x    normal-Î“     absent    normal-Î“  x       subscript   norm    ð¥ðšð¦   x  s     normal-Î“    fragments   LAM   fragments  normal-(  Î»  S  normal-.  parallel-to  s   subscript  parallel-to   maps-to   normal-Î“  x   S    normal-)       subscript   norm    ðšð©ð©   s  t     normal-Î“       absent    S   subscript   norm  t   normal-Î“   where   subscript   norm  s   normal-Î“           ð‹ð€ðŒ  S        subscript   norm    ð©ðšð¢ð«   s  t     normal-Î“     absent    ðð€ðˆð‘    subscript   norm  s   normal-Î“    subscript   norm  t   normal-Î“         subscript   norm    ðŸð¬ð­  s    normal-Î“       absent    S  where   subscript   norm  s   normal-Î“           ðð€ðˆð‘   S  T         subscript   norm    ð¬ð§ð  t    normal-Î“       absent    T  where   subscript   norm  t   normal-Î“           ðð€ðˆð‘   S  T         \begin{aligned}\displaystyle\|\mathbf{var}\ x\|_{\Gamma}&\displaystyle=\Gamma(%
 x)\\
 \displaystyle\|\mathbf{lam}\ (x,s)\|_{\Gamma}&\displaystyle=\mathbf{LAM}\ (%
 \lambda S.\ \|s\|_{\Gamma,x\mapsto S})\\
 \displaystyle\|\mathbf{app}\ (s,t)\|_{\Gamma}&\displaystyle=S\ (\|t\|_{\Gamma}%
 )\text{ where }\|s\|_{\Gamma}=\mathbf{LAM}\ S\\
 \displaystyle\|\mathbf{pair}\ (s,t)\|_{\Gamma}&\displaystyle=\mathbf{PAIR}\ (%
 \|s\|_{\Gamma},\|t\|_{\Gamma})\\
 \displaystyle\|\mathbf{fst}\ s\|_{\Gamma}&\displaystyle=S\text{ where }\|s\|_{%
 \Gamma}=\mathbf{PAIR}\ (S,T)\\
 \displaystyle\|\mathbf{snd}\ t\|_{\Gamma}&\displaystyle=T\text{ where }\|t\|_{%
 \Gamma}=\mathbf{PAIR}\ (S,T)\end{aligned}      In the implementation:  (* meaning : ctx -> tm -> sem *)
  fun meaning G t =
        case t of
          var x => lookup G x
        | lam (x, s) => LAM (fn S => meaning (add G (x, S)) s)
        | app (s, t) => (case meaning G s of
                           LAM S => S (meaning G t))
        | pair (s, t) => PAIR (meaning G s, meaning G t)
        | fst s => (case meaning G s of
                      PAIR (S, T) => S)
        | snd t => (case meaning G t of
                      PAIR (S, T) => T)  Note that there are many non-exhaustive cases; however, if applied to a closed well-typed term, none of these missing cases are ever encountered. The NBE operation on closed terms is then:  (* nbe : ty -> tm -> tm *)
  fun nbe a t = reify a (meaning empty t)  As an example of its use, consider the syntactic term SKK defined below:  val K = lam ("x", lam ("y", var "x"))
  val S = lam ("x", lam ("y", lam ("z", app (app (var "x", var "z"), app (var "y", var "z")))))
  val SKK = app (app (S, K), K)  This is the well-known encoding of the identity function in combinatory logic . Normalising it at an identity type produces:  - nbe (Arrow (Basic "a", Basic "a")) SKK;
  val it = lam ("v0",var "v0") : tm  The result is actually in Î·-long form, as can be easily seen by normalizing it at a different identity type:  - nbe (Arrow (Arrow (Basic "a", Basic "b"), Arrow (Basic "a", Basic "b"))) SKK;
  val it = lam ("v1",lam ("v2",app (var "v1",var "v2"))) : tm  Correctness  Extensions  See also   MINLOG , a proof assistant that uses NBE as its rewrite engine.   References  "  Category:Lambda calculus  Category:Programming language semantics     â†©  â†©  â†©  â†©  â†©     