<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="635">Non-negative matrix factorization</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Non-negative matrix factorization</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Illustration of approximate non-negative matrix factorization: the matrix <em>V</em> is represented by the two smaller matrices <em>W</em> and <em>H</em>, which, when multiplied, approximately reconstruct <em>V</em>.</figcaption>
</figure>
<dl>
<dd><em>NMF redirects here. For the <a href="contract_bridge" title="wikilink">bridge</a> convention, see <a href="new_minor_forcing" title="wikilink">new minor forcing</a>.</em>
</dd>
</dl>

<p><strong>Non-negative matrix factorization (NMF)</strong>, also <strong>non-negative matrix approximation</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> is a group of <a href="algorithm" title="wikilink">algorithms</a> in <a href="multivariate_analysis" title="wikilink">multivariate analysis</a> and <a href="linear_algebra" title="wikilink">linear algebra</a> where a <a href="matrix_(mathematics)" title="wikilink">matrix</a> <strong>V</strong> is <a href="Matrix_decomposition" title="wikilink">factorized</a> into (usually) two matrices <strong>W</strong> and <strong>H</strong>, with the property that all three matrices have no negative elements. This non-negativity makes the resulting matrices easier to inspect. Also, in applications such as processing of audio spectrograms non-negativity is inherent to the data being considered. Since the problem is not exactly solvable in general, it is commonly approximated numerically.</p>

<p>NMF finds applications in such fields as <a href="computer_vision" title="wikilink">computer vision</a>, document <a href="Cluster_analysis" title="wikilink">clustering</a>,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <a class="uri" href="chemometrics" title="wikilink">chemometrics</a>, <a href="audio_signal_processing" title="wikilink">audio signal processing</a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> and <a href="recommender_system" title="wikilink">recommender systems</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="history">History</h2>

<p>In <a class="uri" href="chemometrics" title="wikilink">chemometrics</a> non-negative matrix factorization has a long history under the name "self modeling curve resolution".<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> In this framework the vectors in the right matrix are continuous curves rather than discrete vectors. Also early work on non-negative matrix factorizations was performed by a Finnish group of researchers in the middle of the 1990s under the name <em>positive matrix factorization</em>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> It became more widely known as <em>non-negative matrix factorization</em> after Lee and Seung investigated the properties of the algorithm and published some simple and useful algorithms for two types of factorizations.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h2 id="background">Background</h2>

<p>Let matrix <strong>V</strong> be the product of the matrices <strong>W</strong> and <strong>H</strong>,</p>

<p>

<math display="block" id="Non-negative_matrix_factorization:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>ùêï</mi>
    <mo>=</mo>
    <mpadded width="+1.7pt">
     <mi>ùêñùêá</mi>
    </mpadded>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ùêï</ci>
    <ci>ùêñùêá</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}=\mathbf{W}\mathbf{H}\,.
  </annotation>
 </semantics>
</math>

</p>

<p>Matrix multiplication can be implemented as computing the columns vectors of <strong>V</strong> as linear combinations of the column vectors in <strong>W</strong> using coefficients supplied by columns of <strong>H</strong>. That is, each column of <strong>V</strong> can be computed as follows:</p>

<p>

<math display="block" id="Non-negative_matrix_factorization:1">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ùêØ</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mpadded width="+1.7pt">
     <msub>
      <mi>ùêñùê°</mi>
      <mi>i</mi>
     </msub>
    </mpadded>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ùêØ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ùêñùê°</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{v}_{i}=\mathbf{W}\mathbf{h}_{i}\,,
  </annotation>
 </semantics>
</math>

</p>

<p>where <strong>v</strong><sub><em>i</em></sub> is the i<em>th</em> column vector of the product matrix <strong>V</strong> and <strong>h</strong><sub><em>i</em></sub> is the i<em>th</em> column vector of the matrix <strong>H</strong>.</p>

<p>When multiplying matrices, the dimensions of the factor matrices may be significantly lower than those of the product matrix and it is this property that forms the basis of NMF. NMF generates factors with significantly reduced dimensions compared to the original matrix. For example, if <strong>V</strong> is an <em>m</em>√ó<em>n</em> matrix, <strong>W</strong> is an <em>m</em>√ó<em>p</em> matrix, and <strong>H</strong> is a <em>p</em>√ó<em>n</em> matrix then <em>p</em> can be significantly less than both <em>m</em> and <em>n</em>.</p>

<p>Here's an example based on a text-mining application:</p>
<ul>
<li>Let the input matrix (the matrix to be factored) be <strong>V</strong> with 10000 rows and 500 columns where words are in rows and documents are in columns. That is, we have 500 documents indexed by 10000 words. It follows that a column vector <strong>v</strong> in <strong>V</strong> represents a document.</li>
<li>Assume we ask the algorithm to find 10 features in order to generate a features matrix <strong>W</strong> with 10000 rows and 10 columns and a coefficients matrix <strong>H</strong> with 10 rows and 500 columns.</li>
<li>The product of <strong>W</strong> and <strong>H</strong> is a matrix with 10000 rows and 500 columns, the same shape as the input matrix <strong>V</strong> and, if the factorization worked, also a reasonable approximation to the input matrix <strong>V</strong>.</li>
<li>From the treatment of matrix multiplication above it follows that each column in the product matrix <strong>WH</strong> is a linear combination of the 10 column vectors in the features matrix <strong>W</strong> with coefficients supplied by the coefficients matrix <strong>H</strong>.</li>
</ul>

<p>This last point is the basis of NMF because we can consider each original document in our example as being built from a small set of hidden features. NMF generates these features.</p>

<p>It's useful to think of each feature (column vector) in the features matrix <strong>W</strong> as a document archetype comprising a set of words where each word's cell value defines the word's rank in the feature: The higher a word's cell value the higher the word's rank in the feature. A column in the coefficients matrix <strong>H</strong> represents an original document with a cell value defining the document's rank for a feature. This follows because each row in <strong>H</strong> represents a feature. We can now reconstruct a document (column vector) from our input matrix by a linear combination of our features (column vectors in <strong>W</strong> where each feature is weighted by the feature's cell value from the document's column in <strong>H</strong>.</p>
<h2 id="types">Types</h2>
<h3 id="approximate-non-negative-matrix-factorization">Approximate non-negative matrix factorization</h3>

<p>Usually the number of columns of <strong>W</strong> and the number of rows of <strong>H</strong> in NMF are selected so the product <strong>WH</strong> will become an approximation to <strong>V</strong>. The full decomposition of <strong>V</strong> then amounts to the two non-negative matrices <strong>W</strong> and <strong>H</strong> as well as a residual <strong>U</strong>, such that: <strong>V</strong> = <strong>WH</strong> + <strong>U</strong>. The elements of the residual matrix can either be negative or positive.</p>

<p>When <strong>W</strong> and <strong>H</strong> are smaller than <strong>V</strong> they become easier to store and manipulate. Another reason for factorizing <strong>V</strong> into smaller matrices <strong>W</strong> and <strong>H</strong>, is that if one is able to approximately represent the elements of <strong>V</strong> by significantly less data, then one has to infer some latent structure in the data.</p>
<h3 id="convex-non-negative-matrix-factorization">Convex non-negative matrix factorization</h3>

<p>In standard NMF, matrix factor 

<math display="inline" id="Non-negative_matrix_factorization:2">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mo>‚àà</mo>
   <msubsup>
    <mi mathvariant="normal">‚Ñú</mi>
    <mo>+</mo>
    <mrow>
     <mi>m</mi>
     <mo>√ó</mo>
     <mi>k</mi>
    </mrow>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>W</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <real></real>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <plus></plus>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W\in\Re^{m\times k}_{+}
  </annotation>
 </semantics>
</math>

Ôºå i.e., <strong>W</strong> can be anything in that space. Convex NMF <a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> restricts 

<math display="inline" id="Non-negative_matrix_factorization:3">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 to a be convex combination of the input data vectors 

<math display="inline" id="Non-negative_matrix_factorization:4">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>v</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">‚ãØ</mi>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-‚ãØ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>n</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (v_{1},\cdots,v_{n})
  </annotation>
 </semantics>
</math>


. This greatly improves the quality of data representation of <strong>W</strong>. Furthermore, the resulting matrix factor <strong>H</strong> becomes more sparse and orthogonal.</p>
<h3 id="nonnegative-rank-factorization">Nonnegative rank factorization</h3>

<p>In case the <a href="Nonnegative_rank_(linear_algebra)" title="wikilink">nonnegative rank</a> of <strong>V</strong> is equal to its actual rank, <strong>V=WH</strong> is called a nonnegative rank factorization.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> The problem of finding the NRF of <strong>V</strong>, if it exists, is known to be NP-hard.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<h3 id="different-cost-functions-and-regularizations">Different cost functions and regularizations</h3>

<p>There are different types of non-negative matrix factorizations. The different types arise from using different <a href="Loss_function" title="wikilink">cost functions</a> for measuring the divergence between <strong>V</strong> and <strong>WH</strong> and possibly by <a href="regularization_(mathematics)" title="wikilink">regularization</a> of the <strong>W</strong> and/or <strong>H</strong> matrices.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p>Two simple divergence functions studied by Lee and Seung are the squared error (or <a href="Frobenius_norm" title="wikilink">Frobenius norm</a>) and an extension of the Kullback‚ÄìLeibler divergence to positive matrices (the original <a href="Kullback‚ÄìLeibler_divergence" title="wikilink">Kullback‚ÄìLeibler divergence</a> is defined on probability distributions). Each divergence leads to a different NMF algorithm, usually minimizing the divergence using iterative update rules.</p>

<p>The factorization problem in the squared error version of NMF may be stated as: Given a matrix 

<math display="inline" id="Non-negative_matrix_factorization:5">
 <semantics>
  <mi>ùêï</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêï</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}
  </annotation>
 </semantics>
</math>

 find nonnegative matrices W and H that minimize the function</p>

<p>

<math display="block" id="Non-negative_matrix_factorization:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ùêñ</mi>
     <mo>,</mo>
     <mi>ùêá</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msubsup>
    <mrow>
     <mo>‚à•</mo>
     <mrow>
      <mi>ùêï</mi>
      <mo>-</mo>
      <mi>ùêñùêá</mi>
     </mrow>
     <mo>‚à•</mo>
    </mrow>
    <mi>F</mi>
    <mn>2</mn>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <interval closure="open">
      <ci>ùêñ</ci>
      <ci>ùêá</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <ci>ùêï</ci>
        <ci>ùêñùêá</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <ci>F</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\mathbf{W},\mathbf{H})=\|\mathbf{V}-\mathbf{WH}\|^{2}_{F}
  </annotation>
 </semantics>
</math>

</p>

<p>Another type of NMF for images is based on the <a href="total_variation_norm" title="wikilink">total variation norm</a>.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>

<p>When <a href="Tikhnov_regularization" title="wikilink">L1 regularization</a> (akin to <a href="Least_squares#Lasso_method" title="wikilink">Lasso</a>) is added to NMF with the mean squared error cost function, the resulting problem may be called <strong>non-negative sparse coding</strong> due to the similarity to the <a href="sparse_coding" title="wikilink">sparse coding</a> problem,<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> although it may also still be referred to as NMF.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h3 id="online-nmf">Online NMF</h3>

<p>Many standard NMF algorithms analyze all the data together; i.e., the whole matrix is available from the start. This may be unsatisfactory in applications where there are too many data to fit into memory or where the data are provided in <a class="uri" href="streaming" title="wikilink">streaming</a> fashion. One such use is for <a href="collaborative_filtering" title="wikilink">collaborative filtering</a> in <a href="recommendation_systems" title="wikilink">recommendation systems</a>, where there may be many users and many items to recommend, and it would be inefficient to recalculate everything when one user or one item is added to the system. The cost function for optimization in these cases may or may not be the same as for standard NMF, but the algorithms need to be rather different.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a><a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>
<h2 id="algorithms">Algorithms</h2>

<p>There are several ways in which the <strong>W</strong> and <strong>H</strong> may be found: Lee and Seung's multiplicative update rule <a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> has been a popular method due to the simplicity of implementation. Since then, a few other algorithmic approaches have been developed.</p>

<p>Some successful algorithms are based on alternating <a href="non-negative_least_squares" title="wikilink">non-negative least squares</a>: in each step of such an algorithm, first <strong>H</strong> is fixed and <strong>W</strong> found by a non-negative least squares solver, then <strong>W</strong> is fixed and <strong>H</strong> is found analogously. The procedures used to solve for <strong>W</strong> and <strong>H</strong> may be the same<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> or different, as some NMF variants regularize one of <strong>W</strong> and <strong>H</strong>.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> Specific approaches include the projected <a href="gradient_descent" title="wikilink">gradient descent</a> methods,<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a><a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> the <a href="active_set" title="wikilink">active set</a> method,<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a><a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> and the block principal pivoting method<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> among several others.</p>

<p>The currently available algorithms are sub-optimal as they can only guarantee finding a local minimum, rather than a global minimum of the cost function. A provably optimal algorithm is unlikely in the near future as the problem has been shown to generalize the k-means clustering problem which is known to be <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> However, as in many other data mining applications, a local minimum may still prove to be useful.</p>
<h3 id="exact-nmf">Exact NMF</h3>

<p>Exact solutions for the variants of NMF can be expected (in polynomial time) when additional constraints hold for matrix <strong>V</strong>. A polynomial time algorithm for solving nonnegative rank factorization if <strong>V</strong> contains a monomial sub matrix of rank equal to its rank was given by Campbell and Poole in 1981.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> Kalofolias and Gallopoulos (2012)<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> solved the symmetric counterpart of this problem, where <strong>V</strong> is symmetric and contains a diagonal principal sub matrix of rank r. Their algorithm runs in O(rm^2) time in the dense case. Arora, Ge, Halpern, Mimno, Moitra, Sontag, Wu, &amp; Zhu (2013) give a polynomial time algorithm for exact NMF that works for the case where one of the factors W satisfies the separability condition.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></p>
<h2 id="relation-to-other-techniques">Relation to other techniques</h2>

<p>In <em>Learning the parts of objects by non-negative matrix factorization</em> Lee and Seung proposed NMF mainly for parts-based decomposition of images. It compares NMF to <a href="vector_quantization" title="wikilink">vector quantization</a> and <a href="principal_component_analysis" title="wikilink">principal component analysis</a>, and shows that although the three techniques may be written as factorizations, they implement different constraints and therefore produce different results.</p>

<p> It was later shown that some types of NMF are an instance of a more general probabilistic model called "multinomial PCA".<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> When NMF is obtained by minimizing the <a href="Kullback‚ÄìLeibler_divergence" title="wikilink">Kullback‚ÄìLeibler divergence</a>, it is in fact equivalent to another instance of multinomial PCA, <a href="probabilistic_latent_semantic_analysis" title="wikilink">probabilistic latent semantic analysis</a>,<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> trained by <a href="maximum_likelihood" title="wikilink">maximum likelihood</a> estimation. That method is commonly used for analyzing and clustering textual data and is also related to the <a href="latent_class_model" title="wikilink">latent class model</a>.</p>

<p>It has been shown <a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a><a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> NMF is equivalent to a relaxed form of <a href="K-means_clustering" title="wikilink">K-means clustering</a>: matrix factor <strong>W</strong> contains cluster centroids and <strong>H</strong> contains cluster membership indicators, when using the least square as NMF objective. This provides theoretical foundation for using NMF for data clustering. However note that k-means does not enforce non-negativity on its centroids, so the closest analogy is in fact with "semi-NMF".<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a></p>

<p>NMF can be seen as a two-layer <a href="Bayesian_network" title="wikilink">directed graphical</a> model with one layer of observed random variables and one layer of hidden random variables.<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a></p>

<p>NMF extends beyond matrices to tensors of arbitrary order.<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a><a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a><a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> This extension may be viewed as a non-negative version of, e.g., the <a class="uri" href="PARAFAC" title="wikilink">PARAFAC</a> model.</p>

<p>Other extensions of NMF include joint factorisation of several data matrices and tensors where some factors are shared. Such models are useful for sensor fusion and relational learning.<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a></p>

<p>NMF is an instance of the nonnegative <a href="quadratic_programming" title="wikilink">quadratic programming</a> (<a class="uri" href="NQP" title="wikilink">NQP</a>) as well as many other important problems including the <a href="support_vector_machine" title="wikilink">support vector machine</a> (SVM). However, SVM and NMF are related at a more intimate level than that of NQP, which allows direct application of the solution algorithms developed for either of the two methods to problems in both domains.<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a></p>
<h2 id="uniqueness">Uniqueness</h2>

<p>The factorization is not unique: A matrix and its <a href="inverse_matrix" title="wikilink">inverse</a> can be used to transform the two factorization matrices by, e.g.,<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a></p>

<p>

<math display="block" id="Non-negative_matrix_factorization:7">
 <semantics>
  <mrow>
   <mi>ùêñùêá</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>ùêñùêÅùêÅ</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>ùêá</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ùêñùêá</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ùêñùêÅùêÅ</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>ùêá</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{WH}=\mathbf{WBB}^{-1}\mathbf{H}
  </annotation>
 </semantics>
</math>

 If the two new matrices 

<math display="inline" id="Non-negative_matrix_factorization:8">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>ùêñ</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>=</mo>
   <mi>ùêñùêÅ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-~</ci>
     <ci>ùêñ</ci>
    </apply>
    <ci>ùêñùêÅ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\tilde{W}=WB}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Non-negative_matrix_factorization:9">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>ùêá</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>ùêÅ</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>ùêá</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-~</ci>
     <ci>ùêá</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ùêÅ</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>ùêá</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\tilde{H}}=\mathbf{B}^{-1}\mathbf{H}
  </annotation>
 </semantics>
</math>


 are <a href="non-negative_matrix" title="wikilink">non-negative</a> they form another parametrization of the factorization.</p>

<p>The non-negativity of 

<math display="inline" id="Non-negative_matrix_factorization:10">
 <semantics>
  <mover accent="true">
   <mi>ùêñ</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>ùêñ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\tilde{W}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Non-negative_matrix_factorization:11">
 <semantics>
  <mover accent="true">
   <mi>ùêá</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>ùêá</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\tilde{H}}
  </annotation>
 </semantics>
</math>

 applies at least if <strong>B</strong> is a non-negative <a href="monomial_matrix" title="wikilink">monomial matrix</a>. In this simple case it will just correspond to a scaling and a <a class="uri" href="permutation" title="wikilink">permutation</a>.</p>

<p>More control over the non-uniqueness of NMF is obtained with sparsity constraints.<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a></p>
<h2 id="clustering-property">Clustering property</h2>

<p>NMF has an inherent clustering property,<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a> i.e., it automatically clusters the columns of input data 

<math display="inline" id="Non-negative_matrix_factorization:12">
 <semantics>
  <mrow>
   <mi>ùêï</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚ãØ</mi>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ùêï</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-‚ãØ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}=(v_{1},\cdots,v_{n})
  </annotation>
 </semantics>
</math>

.</p>

<p>More specifically, the approximation of 

<math display="inline" id="Non-negative_matrix_factorization:13">
 <semantics>
  <mi>ùêï</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêï</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Non-negative_matrix_factorization:14">
 <semantics>
  <mrow>
   <mi>ùêï</mi>
   <mo>‚âÉ</mo>
   <mi>ùêñùêá</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to-or-equals</csymbol>
    <ci>ùêï</ci>
    <ci>ùêñùêá</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}\simeq\mathbf{W}\mathbf{H}
  </annotation>
 </semantics>
</math>


 is achieved by minimizing the error function</p>

<p>

<math display="inline" id="Non-negative_matrix_factorization:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>min</mi>
     <mrow>
      <mi>W</mi>
      <mo>,</mo>
      <mi>H</mi>
     </mrow>
    </msub>
    <msub>
     <mrow>
      <mo fence="true">||</mo>
      <mrow>
       <mi>V</mi>
       <mo>-</mo>
       <mrow>
        <mi>W</mi>
        <mi>H</mi>
       </mrow>
      </mrow>
      <mo fence="true">||</mo>
     </mrow>
     <mi>F</mi>
    </msub>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <min></min>
     <list>
      <ci>W</ci>
      <ci>H</ci>
     </list>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <ci>V</ci>
       <apply>
        <times></times>
        <ci>W</ci>
        <ci>H</ci>
       </apply>
      </apply>
     </apply>
     <ci>F</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min_{W,H}||V-WH||_{F},
  </annotation>
 </semantics>
</math>

 subject to 

<math display="inline" id="Non-negative_matrix_factorization:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>W</mi>
    <mo>‚â•</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>H</mi>
    <mo>‚â•</mo>
    <mn>0.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <geq></geq>
     <ci>W</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <geq></geq>
     <ci>H</ci>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W\geq 0,H\geq 0.
  </annotation>
 </semantics>
</math>

</p>

<p>If we add additional orthogonality constraint on 

<math display="inline" id="Non-negative_matrix_factorization:17">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

, i.e., 

<math display="inline" id="Non-negative_matrix_factorization:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <msup>
     <mi>H</mi>
     <mi>T</mi>
    </msup>
   </mrow>
   <mo>=</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <ci>T</ci>
     </apply>
    </apply>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   HH^{T}=I
  </annotation>
 </semantics>
</math>

, then the above minimization is identical to the minimization of <a href="K-means_clustering" title="wikilink">K-means clustering</a>, except for the non-negativity constraints.</p>

<p>Furthermore, the computed 

<math display="inline" id="Non-negative_matrix_factorization:19">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>


 gives the <a href="cluster_indicator" title="wikilink">cluster indicator</a>, i.e., if 

<math display="inline" id="Non-negative_matrix_factorization:20">
 <semantics>
  <mrow>
   <msub>
    <mi>ùêá</mi>
    <mrow>
     <mi>k</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ùêá</ci>
     <apply>
      <times></times>
      <ci>k</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{H}_{kj}>0
  </annotation>
 </semantics>
</math>

, that fact indicates input data 

<math display="inline" id="Non-negative_matrix_factorization:21">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{j}
  </annotation>
 </semantics>
</math>

 belongs/assigned to 

<math display="inline" id="Non-negative_matrix_factorization:22">
 <semantics>
  <msup>
   <mi>k</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{th}
  </annotation>
 </semantics>
</math>

 cluster. And the computed 

<math display="inline" id="Non-negative_matrix_factorization:23">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 gives the cluster centroids, i.e., the 

<math display="inline" id="Non-negative_matrix_factorization:24">
 <semantics>
  <msup>
   <mi>k</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{th}
  </annotation>
 </semantics>
</math>


 column gives the cluster centroid of 

<math display="inline" id="Non-negative_matrix_factorization:25">
 <semantics>
  <msup>
   <mi>k</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{th}
  </annotation>
 </semantics>
</math>

 cluster.</p>

<p>When the orthogonality 

<math display="inline" id="Non-negative_matrix_factorization:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <msup>
     <mi>H</mi>
     <mi>T</mi>
    </msup>
   </mrow>
   <mo>=</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <ci>T</ci>
     </apply>
    </apply>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   HH^{T}=I
  </annotation>
 </semantics>
</math>

 is not explicitly imposed, the orthogonality may hold to a large extent, in which case the clustering property holds too, as may be found in some practical applications of NMF.</p>

<p>When the error function to be used is <a href="Kullback‚ÄìLeibler_divergence" title="wikilink">Kullback‚ÄìLeibler divergence</a>, NMF is identical to the <a href="Probabilistic_latent_semantic_analysis" title="wikilink">Probabilistic latent semantic analysis</a>, a popular document clustering method.<a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a></p>
<h2 id="applications">Applications</h2>
<h3 id="text-mining">Text mining</h3>

<p>NMF can be used for <a href="text_mining" title="wikilink">text mining</a> applications. In this process, a <a href="document-term_matrix" title="wikilink"><em>document-term</em> matrix</a> is constructed with the weights of various terms (typically weighted word frequency information) from a set of documents. This matrix is factored into a <em>term-feature</em> and a <em>feature-document</em> matrix. The features are derived from the contents of the documents, and the feature-document matrix describes <a href="Data_clustering" title="wikilink">data clusters</a> of related documents.</p>

<p>One specific application used hierarchical NMF on a small subset of scientific abstracts from <a class="uri" href="PubMed" title="wikilink">PubMed</a>.<a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a> Another research group clustered parts of the <a class="uri" href="Enron" title="wikilink">Enron</a> email dataset<a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a> with 65,033 messages and 91,133 terms into 50 clusters.<a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a> NMF has also been applied to citations data, with one example clustering <a class="uri" href="Wikipedia" title="wikilink">Wikipedia</a> articles and <a href="scientific_journal" title="wikilink">scientific journals</a> based on the outbound scientific citations in Wikipedia.<a class="footnoteRef" href="#fn53" id="fnref53"><sup>53</sup></a></p>

<p>Arora, Ge, Halpern, Mimno, Moitra, Sontag, Wu, &amp; Zhu (2013) have given polynomial-time algorithms to learn topic models using NMF. The algorithm assumes that the topic matrix satisfies a separability condition that is often found to hold in these settings. <a class="footnoteRef" href="#fn54" id="fnref54"><sup>54</sup></a></p>
<h3 id="spectral-data-analysis">Spectral data analysis</h3>

<p>NMF is also used to analyze spectral data; one such use is in the classification of space objects and debris.<a class="footnoteRef" href="#fn55" id="fnref55"><sup>55</sup></a></p>
<h3 id="scalable-internet-distance-prediction">Scalable Internet distance prediction</h3>

<p>NMF is applied in scalable Internet distance (round-trip time) prediction. For a network with 

<math display="inline" id="Non-negative_matrix_factorization:27">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 hosts, with the help of NMF, the distances of all the 

<math display="inline" id="Non-negative_matrix_factorization:28">
 <semantics>
  <msup>
   <mi>N</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>N</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N^{2}
  </annotation>
 </semantics>
</math>

 end-to-end links can be predicted after conducting only 

<math display="inline" id="Non-negative_matrix_factorization:29">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(N)
  </annotation>
 </semantics>
</math>


 measurements. This kind of method was firstly introduced in Internet Distance Estimation Service (IDES).<a class="footnoteRef" href="#fn56" id="fnref56"><sup>56</sup></a> Afterwards, as a fully decentralized approach, Phoenix network coordinate system <a class="footnoteRef" href="#fn57" id="fnref57"><sup>57</sup></a> is proposed. It achieves better overall prediction accuracy by introducing the concept of weight.</p>
<h3 id="non-stationary-speech-denoising">Non-stationary speech denoising</h3>

<p>Speech denoising has been a long lasting problem in <a href="audio_signal_processing" title="wikilink">audio signal processing</a>. There are lots of algorithms for denoising if the noise is stationary. For example, the <a href="Wiener_filter" title="wikilink">Wiener filter</a> is suitable for additive <a href="Gaussian_noise" title="wikilink">Gaussian noise</a>. However, if the noise is non-stationary, the classical denoising algorithms usually have poor performance because the statistical information of the non-stationary noise is difficult to estimate. Schmidt et al.<a class="footnoteRef" href="#fn58" id="fnref58"><sup>58</sup></a> use NMF to do speech denoising under non-stationary noise, which is completely different from classical statistical approaches.The key idea is that clean speech signal can be sparsely represented by a speech dictionary, but non-stationary noise cannot. Similarly, non-stationary noise can also be sparsely represented by a noise dictionary, but speech cannot.</p>

<p>The algorithm for NMF denoising goes as follows. Two dictionaries, one for speech and one for noise, need to be trained offline. Once a noisy speech is given, we first calculate the magnitude of the Short-Time-Fourier-Transform. Second, separate it into two parts via NMF, one can be sparsely represented by the speech dictionary, and the other part can be sparsely represented by the noise dictionary. Third, the part that is represented by the speech dictionary will be the estimated clean speech.</p>
<h3 id="bioinformatics">Bioinformatics</h3>

<p>NMF has been successfully applied in <a class="uri" href="bioinformatics" title="wikilink">bioinformatics</a> for clustering <a href="gene_expression" title="wikilink">gene expression</a> and <a href="dna_methylation" title="wikilink">dna methylation</a> data and finding the genes most representative of the clusters.<a class="footnoteRef" href="#fn59" id="fnref59"><sup>59</sup></a><a class="footnoteRef" href="#fn60" id="fnref60"><sup>60</sup></a> <a class="footnoteRef" href="#fn61" id="fnref61"><sup>61</sup></a></p>
<h3 id="nuclear-imaging">Nuclear Imaging</h3>

<p>NMF, also referred in this field as factor analysis, has been used since the <a class="uri" href="80s" title="wikilink">80s</a> <a class="footnoteRef" href="#fn62" id="fnref62"><sup>62</sup></a> to analyze sequences of images in <a class="uri" href="SPECT" title="wikilink">SPECT</a> and <a href="Positron_emission_tomography" title="wikilink">PET</a> dynamic medical imaging. Non-uniqueness of NMF was addressed using sparsity constraints.<a class="footnoteRef" href="#fn63" id="fnref63"><sup>63</sup></a></p>
<h2 id="current-research">Current research</h2>

<p>Current research in nonnegative matrix factorization includes, but not limited to,</p>

<p>(1) Algorithmic: searching for global minima of the factors and factor initialization.<a class="footnoteRef" href="#fn64" id="fnref64"><sup>64</sup></a></p>

<p>(2) Scalability: how to factorize million-by-billion matrices, which are commonplace in Web-scale data mining, e.g., see Distributed Nonnegative Matrix Factorization (DNMF)<a class="footnoteRef" href="#fn65" id="fnref65"><sup>65</sup></a> and Scalable Nonnegative Matrix Factorization (ScalableNMF)<a class="footnoteRef" href="#fn66" id="fnref66"><sup>66</sup></a></p>

<p>(3) Online: how to update the factorization when new data comes in without recomputing from scratch, e.g., see online CNSC <a class="footnoteRef" href="#fn67" id="fnref67"><sup>67</sup></a></p>

<p>(4) Collective (joint) factorization: factorizing multiple interrelated matrices for multiple-view learning, e.g. mutli-view clustering, see CoNMF <a class="footnoteRef" href="#fn68" id="fnref68"><sup>68</sup></a> and MultiNMF <a class="footnoteRef" href="#fn69" id="fnref69"><sup>69</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Multilinear_algebra" title="wikilink">Multilinear algebra</a></li>
<li><a href="Multilinear_subspace_learning" title="wikilink">Multilinear subspace learning</a></li>
<li><a class="uri" href="Tensor" title="wikilink">Tensor</a></li>
<li><a href="Tensor_decomposition" title="wikilink">Tensor decomposition</a></li>
<li><a href="Tensor_software" title="wikilink">Tensor software</a></li>
</ul>
<h2 id="sources-and-external-links">Sources and external links</h2>
<h3 id="notes">Notes</h3>
<h3 id="others">Others</h3>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Linear_algebra" title="wikilink">Category:Linear algebra</a> <a href="Category:Matrix_theory" title="wikilink">Category:Matrix theory</a> <a href="Category:Multivariate_statistics" title="wikilink">Category:Multivariate statistics</a> <a href="Category:Machine_learning_algorithms" title="wikilink">Category:Machine learning algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"><a href="#fnref2">‚Ü©</a></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">‚Ü©</a></li>
<li id="fn5"><a href="#fnref5">‚Ü©</a></li>
<li id="fn6"><a href="#fnref6">‚Ü©</a></li>
<li id="fn7"><a href="#fnref7">‚Ü©</a></li>
<li id="fn8"><a href="#fnref8">‚Ü©</a></li>
<li id="fn9"><a href="#fnref9">‚Ü©</a></li>
<li id="fn10"><a href="#fnref10">‚Ü©</a></li>
<li id="fn11"><a href="#fnref11">‚Ü©</a></li>
<li id="fn12">C Ding, T Li, MI Jordan, Convex and semi-nonnegative matrix factorizations, IEEE Transactions on Pattern Analysis and Machine Intelligence, 32, 45-55, 2010<a href="#fnref12">‚Ü©</a></li>
<li id="fn13"><a href="#fnref13">‚Ü©</a></li>
<li id="fn14"><a href="#fnref14">‚Ü©</a></li>
<li id="fn15"><a href="#fnref15">‚Ü©</a></li>
<li id="fn16"><a href="#fnref16">‚Ü©</a></li>
<li id="fn17"><a href="#fnref17">‚Ü©</a></li>
<li id="fn18"><a href="#fnref18">‚Ü©</a></li>
<li id="fn19"><a href="#fnref19">‚Ü©</a></li>
<li id="fn20"><a href="#fnref20">‚Ü©</a></li>
<li id="fn21"><a class="uri" href="http://www.ijcai.org/papers07/Papers/IJCAI07-432.pdf">http://www.ijcai.org/papers07/Papers/IJCAI07-432.pdf</a><a href="#fnref21">‚Ü©</a></li>
<li id="fn22"><a class="uri" href="http://portal.acm.org/citation.cfm?id=1339264.1339709">http://portal.acm.org/citation.cfm?id=1339264.1339709</a><a href="#fnref22">‚Ü©</a></li>
<li id="fn23"></li>
<li id="fn24"></li>
<li id="fn25"></li>
<li id="fn26"><a href="#fnref26">‚Ü©</a></li>
<li id="fn27"><a href="#fnref27">‚Ü©</a></li>
<li id="fn28"></li>
<li id="fn29"><a href="#fnref29">‚Ü©</a></li>
<li id="fn30"><a href="#fnref30">‚Ü©</a></li>
<li id="fn31"><a href="#fnref31">‚Ü©</a></li>
<li id="fn32"><a href="#fnref32">‚Ü©</a></li>
<li id="fn33"><a href="#fnref33">‚Ü©</a></li>
<li id="fn34"><a href="#fnref34">‚Ü©</a></li>
<li id="fn35"><a href="#fnref35">‚Ü©</a></li>
<li id="fn36"><a href="#fnref36">‚Ü©</a></li>
<li id="fn37">C. Ding, X. He, H.D. Simon (2005). <a href="http://ranger.uta.edu/~chqding/papers/NMF-SDM2005.pdf">"On the Equivalence of Nonnegative Matrix Factorization and Spectral Clustering"</a>. Proc. SIAM Int'l Conf. Data Mining, pp. 606-610. May 2005<a href="#fnref37">‚Ü©</a></li>
<li id="fn38">Ron Zass and <a href="Amnon_Shashua" title="wikilink">Amnon Shashua</a> (2005). "<a href="http://www.cs.huji.ac.il/~zass/papers/cp-iccv05.pdf">A Unifying Approach to Hard and Probabilistic Clustering</a>". International Conference on Computer Vision (ICCV) Beijing, China, Oct., 2005.<a href="#fnref38">‚Ü©</a></li>
<li id="fn39"></li>
<li id="fn40"><a href="#fnref40">‚Ü©</a></li>
<li id="fn41"><a href="#fnref41">‚Ü©</a></li>
<li id="fn42"><a href="#fnref42">‚Ü©</a></li>
<li id="fn43"><a href="#fnref43">‚Ü©</a></li>
<li id="fn44"><a href="#fnref44">‚Ü©</a></li>
<li id="fn45"><a href="#fnref45">‚Ü©</a></li>
<li id="fn46"><a href="#fnref46">‚Ü©</a></li>
<li id="fn47">Julian Eggert, Edgar K√∂rner, "<a href="http://dx.doi.org/10.1109/IJCNN.2004.1381036">Sparse coding and NMF</a>", ''Proceedings. 2004 IEEE International Joint Conference on Neural Networks, 2004, pp. 2529-2533, 2004.<a href="#fnref47">‚Ü©</a></li>
<li id="fn48"></li>
<li id="fn49">C Ding, T Li, W Peng, <a href="http://users.cis.fiu.edu/~taoli/pub/NMFpLSIequiv.pdf">" On the equivalence between non-negative matrix factorization and probabilistic latent semantic indexing"</a> Computational Statistics &amp; Data Analysis 52, 3913-3927<a href="#fnref49">‚Ü©</a></li>
<li id="fn50"><a href="#fnref50">‚Ü©</a></li>
<li id="fn51"><a href="#fnref51">‚Ü©</a></li>
<li id="fn52"><a href="#fnref52">‚Ü©</a></li>
<li id="fn53"><a href="#fnref53">‚Ü©</a></li>
<li id="fn54"></li>
<li id="fn55"><a href="#fnref55">‚Ü©</a></li>
<li id="fn56"><a href="#fnref56">‚Ü©</a></li>
<li id="fn57"><a href="#fnref57">‚Ü©</a></li>
<li id="fn58">Schmidt, M.N., J. Larsen, and F.T. Hsiao. (2007). "Wind noise reduction using non-negative sparse coding", <em>Machine Learning for Signal Processing, IEEE Workshop on</em>, 431‚Äì436<a href="#fnref58">‚Ü©</a></li>
<li id="fn59"><a href="#fnref59">‚Ü©</a></li>
<li id="fn60"><a href="#fnref60">‚Ü©</a></li>
<li id="fn61"><a href="#fnref61">‚Ü©</a></li>
<li id="fn62"><a href="#fnref62">‚Ü©</a></li>
<li id="fn63"><a href="#fnref63">‚Ü©</a></li>
<li id="fn64"><a href="#fnref64">‚Ü©</a></li>
<li id="fn65"><a href="#fnref65">‚Ü©</a></li>
<li id="fn66"><a href="#fnref66">‚Ü©</a></li>
<li id="fn67"><a href="#fnref67">‚Ü©</a></li>
<li id="fn68"><a href="#fnref68">‚Ü©</a></li>
<li id="fn69"><a href="#fnref69">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
