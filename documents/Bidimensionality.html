<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="177">Bidimensionality</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Bidimensionality</h1>
<hr/>

<p><strong>Bidimensionality</strong> theory characterizes a broad range of graph problems (<strong>bidimensional</strong>) that admit efficient approximate, fixed-parameter or kernel solutions in a broad range of graphs. These graph classes include <a href="planar_graph" title="wikilink">planar graphs</a>, map graphs, <a href="Graph_embedding" title="wikilink">bounded-genus</a> graphs and graphs excluding any fixed minor. In particular, bidimensionality theory builds on the <a href="graph_minor" title="wikilink">graph minor</a> theory of <a href="Neil_Robertson_(mathematician)" title="wikilink">Robertson</a> and <a href="Paul_Seymour_(mathematician)" title="wikilink">Seymour</a> by extending the mathematical results and building new algorithmic tools. The theory was introduced in the work of <a href="Erik_Demaine" title="wikilink">Demaine</a>, Fomin, Hajiaghayi, and Thilikos,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> for which the authors received the <a href="Nerode_Prize" title="wikilink">Nerode Prize</a> in 2015.</p>
<h2 id="definition">Definition</h2>

<p>A <a href="Parameterized_complexity" title="wikilink">parameterized problem</a> 

<math display="inline" id="Bidimensionality:0">
 <semantics>
  <mi mathvariant="normal">Π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi
  </annotation>
 </semantics>
</math>

 is a subset of 

<math display="inline" id="Bidimensionality:1">
 <semantics>
  <mrow>
   <msup>
    <mi mathvariant="normal">Γ</mi>
    <mo>*</mo>
   </msup>
   <mo>×</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Γ</ci>
     <times></times>
    </apply>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma^{*}\times\mathbb{N}
  </annotation>
 </semantics>
</math>

 for some finite alphabet 

<math display="inline" id="Bidimensionality:2">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

. An instance of a parameterized problem consists of <em>(x,k)</em>, where <em>k</em> is called the parameter.</p>

<p>A parameterized problem 

<math display="inline" id="Bidimensionality:3">
 <semantics>
  <mi mathvariant="normal">Π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi
  </annotation>
 </semantics>
</math>

 is <em>minor-bidimensional</em> if</p>
<ol>
<li>For any pair of graphs 

<math display="inline" id="Bidimensionality:4">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>,</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>H</ci>
    <ci>G</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H,G
  </annotation>
 </semantics>
</math>

, such that 

<math display="inline" id="Bidimensionality:5">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 is a minor of 

<math display="inline" id="Bidimensionality:6">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 and integer 

<math display="inline" id="Bidimensionality:7">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Bidimensionality:8">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Π</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>G</ci>
     <ci>k</ci>
    </interval>
    <ci>normal-Π</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (G,k)\in\Pi
  </annotation>
 </semantics>
</math>

 yields that 

<math display="inline" id="Bidimensionality:9">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Π</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>H</ci>
     <ci>k</ci>
    </interval>
    <ci>normal-Π</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (H,k)\in\Pi
  </annotation>
 </semantics>
</math>

. In other words, contracting or deleting an edge in a graph 

<math display="inline" id="Bidimensionality:10">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 cannot increase the parameter; and</li>
<li>there is 

<math display="inline" id="Bidimensionality:11">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>δ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta>0
  </annotation>
 </semantics>
</math>

 such that for every 

<math display="inline" id="Bidimensionality:12">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>r</mi>
    <mo>×</mo>
    <mi>r</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (r\times r)
  </annotation>
 </semantics>
</math>

-grid 

<math display="inline" id="Bidimensionality:13">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Bidimensionality:14">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∉</mo>
   <mi mathvariant="normal">Π</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <interval closure="open">
     <ci>R</ci>
     <ci>k</ci>
    </interval>
    <ci>normal-Π</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (R,k)\not\in\Pi
  </annotation>
 </semantics>
</math>

 for every 

<math display="inline" id="Bidimensionality:15">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>≤</mo>
   <mrow>
    <mi>δ</mi>
    <msup>
     <mi>r</mi>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>δ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>r</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\leq\delta r^{2}
  </annotation>
 </semantics>
</math>

. In other words, the value of the solution on 

<math display="inline" id="Bidimensionality:16">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 should be at least 

<math display="inline" id="Bidimensionality:17">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <msup>
    <mi>r</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>δ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>r</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta r^{2}
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>Examples of minor-bidimensional problems are the parameterized versions of <a href="vertex_cover" title="wikilink">vertex cover</a>, <a href="feedback_vertex_set" title="wikilink">feedback vertex set</a>, minimum maximal matching, and <a href="longest_path" title="wikilink">longest path</a>.</p>
<figure><b>(Figure)</b>
<figcaption> Graph 

<math display="inline" id="Bidimensionality:18">
 <semantics>
  <msub>
   <mi mathvariant="normal">Γ</mi>
   <mn>6</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Γ</ci>
    <cn type="integer">6</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma_{6}
  </annotation>
 </semantics>
</math>

</figcaption>
</figure>

<p>Let 

<math display="inline" id="Bidimensionality:19">
 <semantics>
  <msub>
   <mi mathvariant="normal">Γ</mi>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Γ</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma_{r}
  </annotation>
 </semantics>
</math>

 be the graph obtained from the 

<math display="inline" id="Bidimensionality:20">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>r</mi>
    <mo>×</mo>
    <mi>r</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (r\times r)
  </annotation>
 </semantics>
</math>

-grid by triangulating internal faces such that all internal vertices become of degree 6, and then one corner of degree two joined by edges with all vertices of the external face. A parameterized problem 

<math display="inline" id="Bidimensionality:21">
 <semantics>
  <mi mathvariant="normal">Π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi
  </annotation>
 </semantics>
</math>

 is <em>contraction-bidimensional</em> if</p>
<ol>
<li>For any pair of graphs 

<math display="inline" id="Bidimensionality:22">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>,</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>H</ci>
    <ci>G</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H,G
  </annotation>
 </semantics>
</math>

, such that 

<math display="inline" id="Bidimensionality:23">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 is a contraction of 

<math display="inline" id="Bidimensionality:24">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 and integer 

<math display="inline" id="Bidimensionality:25">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Bidimensionality:26">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Π</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>G</ci>
     <ci>k</ci>
    </interval>
    <ci>normal-Π</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (G,k)\in\Pi
  </annotation>
 </semantics>
</math>

 yields that 

<math display="inline" id="Bidimensionality:27">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Π</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>H</ci>
     <ci>k</ci>
    </interval>
    <ci>normal-Π</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (H,k)\in\Pi
  </annotation>
 </semantics>
</math>

. In other words, contracting an edge in a graph 

<math display="inline" id="Bidimensionality:28">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 cannot increase the parameter; and</li>
<li>there is 

<math display="inline" id="Bidimensionality:29">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>δ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta>0
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Bidimensionality:30">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi mathvariant="normal">Γ</mi>
     <mi>r</mi>
    </msub>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∉</mo>
   <mi mathvariant="normal">Π</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Γ</ci>
      <ci>r</ci>
     </apply>
     <ci>k</ci>
    </interval>
    <ci>normal-Π</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Gamma_{r},k)\not\in\Pi
  </annotation>
 </semantics>
</math>

 for every 

<math display="inline" id="Bidimensionality:31">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>≤</mo>
   <mrow>
    <mi>δ</mi>
    <msup>
     <mi>r</mi>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>δ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>r</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\leq\delta r^{2}
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>Examples of contraction-bidimensional problems are <a href="dominating_set" title="wikilink">dominating set</a>, <a href="connected_dominating_set" title="wikilink">connected dominating set</a>, max-leaf spanning tree, and <a href="edge_dominating_set" title="wikilink">edge dominating set</a>.</p>
<h2 id="excluded-grid-theorems">Excluded grid theorems</h2>

<p>All algorithmic applications of bidimensionality are based on the following combinatorial property: either the <a class="uri" href="treewidth" title="wikilink">treewidth</a> of a graph is small, or the graph contains a large grid as a minor or contraction. More precisely,</p>
<ol>
<li>There is a function <em>f</em> such that every graph <em>G</em> excluding a fixed <em>h</em>-vertex graph as a <a href="Minor_(graph_theory)" title="wikilink">minor</a> and of treewidth at least <em>f(h)r</em> contains '' (r x r)''-grid as a minor.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></li>
<li>There is a function <em>g</em> such that every graph <em>G</em> excluding a fixed <em>h</em>-vertex <a href="apex_graph" title="wikilink">apex graph</a> as a minor and of treewidth at least <em>g(h) r</em> can be edge-contracted to 

<math display="inline" id="Bidimensionality:32">
 <semantics>
  <msub>
   <mi mathvariant="normal">Γ</mi>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Γ</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma_{r}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
</ol>

<p><a href="Halin's_grid_theorem" title="wikilink">Halin's grid theorem</a> is an analogous excluded grid theorem for infinite graphs.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="subexponential-parameterized-algorithms">Subexponential parameterized algorithms</h2>

<p>Let 

<math display="inline" id="Bidimensionality:33">
 <semantics>
  <mi mathvariant="normal">Π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi
  </annotation>
 </semantics>
</math>

 be a minor-bidimensional problem such that for any graph <em>G</em> excluding some fixed graph as a minor and of treewidth at most <em>t</em>, deciding whether 

<math display="inline" id="Bidimensionality:34">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Π</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>G</ci>
     <ci>k</ci>
    </interval>
    <ci>normal-Π</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (G,k)\in\Pi
  </annotation>
 </semantics>
</math>

 can be done in time 

<math display="inline" id="Bidimensionality:35">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mo>⋅</mo>
   <msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>G</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <ci>G</ci>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{O(t)}\cdot|G|^{O(1)}
  </annotation>
 </semantics>
</math>

. Then for every graph <em>G</em> excluding some fixed graph as a minor, deciding whether 

<math display="inline" id="Bidimensionality:36">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Π</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>G</ci>
     <ci>k</ci>
    </interval>
    <ci>normal-Π</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (G,k)\in\Pi
  </annotation>
 </semantics>
</math>

 can be done in time 

<math display="inline" id="Bidimensionality:37">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msqrt>
       <mi>k</mi>
      </msqrt>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mo>⋅</mo>
   <msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>G</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <root></root>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <ci>G</ci>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{O(\sqrt{k})}\cdot|G|^{O(1)}
  </annotation>
 </semantics>
</math>

. Similarly, for contraction-bidimensional problems, for graph <em>G</em> excluding some fixed <a href="apex_graph" title="wikilink">apex graph</a> as a minor, inclusion 

<math display="inline" id="Bidimensionality:38">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Π</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>G</ci>
     <ci>k</ci>
    </interval>
    <ci>normal-Π</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (G,k)\in\Pi
  </annotation>
 </semantics>
</math>

 can be decided in time 

<math display="inline" id="Bidimensionality:39">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msqrt>
       <mi>k</mi>
      </msqrt>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mo>⋅</mo>
   <msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>G</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <root></root>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <ci>G</ci>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{O(\sqrt{k})}\cdot|G|^{O(1)}
  </annotation>
 </semantics>
</math>

.</p>

<p>Thus many bidimensional problems like Vertex Cover, Dominating Set, k-Path, are solvable in time 

<math display="inline" id="Bidimensionality:40">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msqrt>
       <mi>k</mi>
      </msqrt>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mo>⋅</mo>
   <msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>G</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <root></root>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <ci>G</ci>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{O(\sqrt{k})}\cdot|G|^{O(1)}
  </annotation>
 </semantics>
</math>

 on graphs excluding some fixed graph as a minor.</p>
<h2 id="polynomial-time-approximation-schemes">Polynomial time approximation schemes</h2>

<p>Bidimensionality theory has been used to obtain <a href="polynomial-time_approximation_scheme" title="wikilink">polynomial-time approximation schemes</a> for many bidimensional problems. If a minor (contraction) bidimensional problem has several additional properties <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> then the problem poses efficient polynomial-time approximation schemes on (apex) minor-free graphs.</p>

<p>In particular, by making use of bidimensionality, it was shown that <a href="feedback_vertex_set" title="wikilink">feedback vertex set</a>, <a href="vertex_cover" title="wikilink">vertex cover</a>, connected vertex cover, cycle packing, diamond hitting set, maximum induced forest, maximum induced bipartite subgraph and maximum induced planar subgraph admit an EPTAS on H-minor-free graphs. Edge dominating set, <a href="dominating_set" title="wikilink">dominating set</a>, r-dominating set, connected dominating set, r-scattered set, minimum maximal matching, <a href="independent_set_(graph_theory)" title="wikilink">independent set</a>, maximum full-degree spanning tree, maximum induced at most d-degree subgraph, <a href="maximum_internal_spanning_tree" title="wikilink">maximum internal spanning tree</a>, induced matching, triangle packing, partial r-dominating set and partial vertex cover admit an EPTAS on apex-minor-free graphs.</p>
<h2 id="kernelization">Kernelization</h2>

<p>A parameterized problem with a parameter <em>k</em> is said to admit a linear vertex kernel if there is a polynomial time reduction, called a <a class="uri" href="kernelization" title="wikilink">kernelization</a> algorithm, that maps the input instance to an equivalent instance with at most <em>O(k)</em> vertices.</p>

<p>Every minor-bidimensional problem 

<math display="inline" id="Bidimensionality:41">
 <semantics>
  <mi mathvariant="normal">Π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi
  </annotation>
 </semantics>
</math>

 with additional properties, namely, with the separation property and with finite integer index, has a linear vertex kernel on graphs excluding some fixed graph as a minor. Similarly, every contraction-bidimensional problem 

<math display="inline" id="Bidimensionality:42">
 <semantics>
  <mi mathvariant="normal">Π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi
  </annotation>
 </semantics>
</math>

 with the separation property and with finite integer index has a linear vertex kernel on graphs excluding some fixed <a href="apex_graph" title="wikilink">apex graph</a> as a minor.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Analysis_of_algorithms" title="wikilink">Category:Analysis of algorithms</a> <a href="Category:Approximation_algorithms" title="wikilink">Category:Approximation algorithms</a> <a href="Category:Graph_minor_theory" title="wikilink">Category:Graph minor theory</a> <a href="Category:Parameterized_complexity" title="wikilink">Category:Parameterized complexity</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
