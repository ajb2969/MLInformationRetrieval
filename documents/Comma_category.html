<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="792">Comma category</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Comma category</h1>
<hr/>

<p>In mathematics, a <strong>comma category</strong> (a special case being a <strong>slice category</strong>) is a construction in <a href="category_theory" title="wikilink">category theory</a>. It provides another way of looking at <a href="morphism" title="wikilink">morphisms</a>: instead of simply relating objects of a <a href="Category_(mathematics)" title="wikilink">category</a> to one another, morphisms become objects in their own right. This notion was introduced in 1963 by <a href="William_Lawvere" title="wikilink">F. W. Lawvere</a> (Lawvere, 1963 p. 36), although the technique did not become generally known until many years later. Several mathematical concepts can be treated as comma categories. Comma categories also guarantee the existence of some <a href="Limit_(category_theory)" title="wikilink">limits</a> and <a href="colimit" title="wikilink">colimits</a>. The name comes from the notation originally used by Lawvere, which involved the <a class="uri" href="comma" title="wikilink">comma</a> punctuation mark. Although standard notation has changed since the use of a comma as an operator is potentially confusing, and even Lawvere dislikes the uninformative term "comma category" (Lawvere, 1963 p. 13), the name persists.</p>
<h2 id="definition">Definition</h2>

<p>The most general comma category construction involves two <a href="functor" title="wikilink">functors</a> with the same codomain. Often one of these will have domain <strong>1</strong> (the one-object one-morphism category). Some accounts of category theory consider only these special cases, but the term comma category is actually much more general.</p>
<h3 id="general-form">General form</h3>

<p>Suppose that 

<math display="inline" id="Comma_category:0">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Comma_category:1">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Comma_category:2">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 are categories, and 

<math display="inline" id="Comma_category:3">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Comma_category:4">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 (for source and target) are <a href="functor" title="wikilink">functors</a></p>

<p>

<math display="block" id="Comma_category:5">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mover accent="true">
    <mo>→</mo>
    <mo lspace="8.1pt" rspace="8.1pt">𝑆</mo>
   </mover>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   <mover accent="true">
    <mo>←</mo>
    <mo lspace="8.1pt" rspace="8.1pt">𝑇</mo>
   </mover>
   <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <ci>S</ci>
      <ci>normal-→</ci>
     </apply>
     <ci>𝒜</ci>
     <ci>𝒞</ci>
    </apply>
    <apply>
     <apply>
      <ci>T</ci>
      <ci>normal-←</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <ci>ℬ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}\xrightarrow{\;\;S\;\;}\mathcal{C}\xleftarrow{\;\;T\;\;}\mathcal{B}
  </annotation>
 </semantics>
</math>

 We can form the comma category 

<math display="inline" id="Comma_category:6">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>S</mi>
    <mo>↓</mo>
    <mi>T</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <ci>S</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S\downarrow T)
  </annotation>
 </semantics>
</math>

 as follows:</p>
<ul>
<li>The objects are all triples 

<math display="inline" id="Comma_category:7">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>α</mi>
   <mo>,</mo>
   <mi>β</mi>
   <mo>,</mo>
   <mi>f</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>α</ci>
    <ci>β</ci>
    <ci>f</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\alpha,\beta,f)
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Comma_category:8">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 an object in 

<math display="inline" id="Comma_category:9">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Comma_category:10">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 an object in 

<math display="inline" id="Comma_category:11">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Comma_category:12">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>α</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>β</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>α</ci>
     </apply>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>β</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:S(\alpha)\rightarrow T(\beta)
  </annotation>
 </semantics>
</math>

 a morphism in 

<math display="inline" id="Comma_category:13">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

.</li>
<li>The morphisms from 

<math display="inline" id="Comma_category:14">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>α</mi>
   <mo>,</mo>
   <mi>β</mi>
   <mo>,</mo>
   <mi>f</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>α</ci>
    <ci>β</ci>
    <ci>f</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\alpha,\beta,f)
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Comma_category:15">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msup>
    <mi>α</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>β</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>f</mi>
    <mo>′</mo>
   </msup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>α</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>β</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <ci>normal-′</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\alpha^{\prime},\beta^{\prime},f^{\prime})
  </annotation>
 </semantics>
</math>

 are all pairs 

<math display="inline" id="Comma_category:16">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>g</mi>
   <mo>,</mo>
   <mi>h</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>g</ci>
    <ci>h</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (g,h)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Comma_category:17">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>:</mo>
   <mrow>
    <mi>α</mi>
    <mo>→</mo>
    <msup>
     <mi>α</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>g</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>α</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>α</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g:\alpha\rightarrow\alpha^{\prime}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Comma_category:18">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>:</mo>
   <mrow>
    <mi>β</mi>
    <mo>→</mo>
    <msup>
     <mi>β</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>h</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>β</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>β</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h:\beta\rightarrow\beta^{\prime}
  </annotation>
 </semantics>
</math>

 are morphisms in 

<math display="inline" id="Comma_category:19">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Comma_category:20">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>

 respectively, such that the following diagram <a href="commutative_diagram" title="wikilink">commutes</a>:</li>
</ul>

<p>

<math display="inline" id="Comma_category:21">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="center">
     <mrow>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>α</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mover accent="true">
      <mo>→</mo>
      <mrow>
       <mi>S</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>g</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mover>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>α</mi>
        <mo>′</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mrow>
      <mi>f</mi>
      <mo mathsize="260%" stretchy="false">↓</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mi></mi>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi></mi>
      <mo mathsize="260%" stretchy="false">↓</mo>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mrow>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>β</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <munderover accent="true" accentunder="true">
      <mo>→</mo>
      <mrow>
       <mi>T</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>h</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mi></mi>
     </munderover>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>β</mi>
        <mo>′</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>α</ci>
     </apply>
     <apply>
      <apply>
       <times></times>
       <ci>S</ci>
       <ci>g</ci>
      </apply>
      <ci>normal-→</ci>
     </apply>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>α</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-↓</ci>
      <ci>f</ci>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <ci>normal-↓</ci>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>β</ci>
     </apply>
     <apply>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>h</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">absent</csymbol>
       <ci>normal-→</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>T</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>β</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{matrix}S(\alpha)&\xrightarrow{S(g)}&S(\alpha^{\prime})\\
f\Bigg\downarrow&&\Bigg\downarrow f^{\prime}\\
T(\beta)&\xrightarrow[T(h)]{}&T(\beta^{\prime})\end{matrix}
  </annotation>
 </semantics>
</math>

</p>

<p>Morphisms are composed by taking 

<math display="inline" id="Comma_category:22">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>g</mi>
    <mo>,</mo>
    <mi>h</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∘</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>g</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>h</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <interval closure="open">
     <ci>g</ci>
     <ci>h</ci>
    </interval>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>h</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (g,h)\circ(g^{\prime},h^{\prime})
  </annotation>
 </semantics>
</math>

 to be 

<math display="inline" id="Comma_category:23">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>g</mi>
    <mo>∘</mo>
    <msup>
     <mi>g</mi>
     <mo>′</mo>
    </msup>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>h</mi>
    <mo>∘</mo>
    <msup>
     <mi>h</mi>
     <mo>′</mo>
    </msup>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <compose></compose>
     <ci>g</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <compose></compose>
     <ci>h</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>h</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (g\circ g^{\prime},h\circ h^{\prime})
  </annotation>
 </semantics>
</math>

, whenever the latter expression is defined. The identity morphism on an object 

<math display="inline" id="Comma_category:24">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>α</mi>
   <mo>,</mo>
   <mi>β</mi>
   <mo>,</mo>
   <mi>f</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>α</ci>
    <ci>β</ci>
    <ci>f</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\alpha,\beta,f)
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Comma_category:25">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>id</mi>
    <mi>α</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>id</mi>
    <mi>β</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>id</ci>
     <ci>α</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>id</ci>
     <ci>β</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathrm{id}_{\alpha},\mathrm{id}_{\beta})
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="slice-category">Slice category</h3>

<p>The first special case occurs when 

<math display="inline" id="Comma_category:26">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>=</mo>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒜</ci>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}=\mathcal{C}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Comma_category:27">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is the <a href="identity_functor" title="wikilink">identity functor</a>, and 

<math display="inline" id="Comma_category:28">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℬ</mi>
   <mo>=</mo>
   <mtext>𝟏</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ℬ</ci>
    <mtext>1</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}=\textbf{1}
  </annotation>
 </semantics>
</math>

 (the category with one object 

<math display="inline" id="Comma_category:29">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>

 and one morphism). Then 

<math display="inline" id="Comma_category:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>*</mo>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <times></times>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(*)=A
  </annotation>
 </semantics>
</math>

 for some object 

<math display="inline" id="Comma_category:31">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Comma_category:32">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

. In this case, the comma category is written 

<math display="inline" id="Comma_category:33">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo>↓</mo>
    <mi>A</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <ci>𝒞</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathcal{C}\downarrow A)
  </annotation>
 </semantics>
</math>

, and is often called the <em>slice category</em> over 

<math display="inline" id="Comma_category:34">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 or the category of <em>objects over 

<math display="inline" id="Comma_category:35">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

</em>. The objects 

<math display="inline" id="Comma_category:36">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>α</mi>
   <mo>,</mo>
   <mo>*</mo>
   <mo>,</mo>
   <mi>f</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>α</ci>
    <times></times>
    <ci>f</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\alpha,*,f)
  </annotation>
 </semantics>
</math>

 can be simplified to pairs 

<math display="inline" id="Comma_category:37">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>α</mi>
   <mo>,</mo>
   <mi>f</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>α</ci>
    <ci>f</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\alpha,f)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Comma_category:38">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>α</mi>
    <mo>→</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>α</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\alpha\rightarrow A
  </annotation>
 </semantics>
</math>

. Sometimes, 

<math display="inline" id="Comma_category:39">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is denoted 

<math display="inline" id="Comma_category:40">
 <semantics>
  <msub>
   <mi>π</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>π</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{\alpha}
  </annotation>
 </semantics>
</math>

. A morphism from 

<math display="inline" id="Comma_category:41">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>B</mi>
   <mo>,</mo>
   <msub>
    <mi>π</mi>
    <mi>B</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>B</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <ci>B</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (B,\pi_{B})
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Comma_category:42">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msup>
    <mi>B</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
   <msub>
    <mi>π</mi>
    <msup>
     <mi>B</mi>
     <mo>′</mo>
    </msup>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>B</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (B^{\prime},\pi_{B^{\prime}})
  </annotation>
 </semantics>
</math>

 in the slice category is then an arrow 

<math display="inline" id="Comma_category:43">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>:</mo>
   <mrow>
    <mi>B</mi>
    <mo>→</mo>
    <msup>
     <mi>B</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>g</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>B</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g:B\rightarrow B^{\prime}
  </annotation>
 </semantics>
</math>

 making the following diagram commute:</p>
<div style="text-align: center;">
<figure><b>(Figure)</b>
<figcaption>CommaCategory-01.png</figcaption>
</figure>
</div>
<h3 id="coslice-category">Coslice category</h3>

<p>The <a href="Dual_(category_theory)" title="wikilink">dual</a> concept to a slice category is a coslice category. Here, 

<math display="inline" id="Comma_category:44">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 has domain <strong>1</strong> and 

<math display="inline" id="Comma_category:45">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is an identity functor. In this case, the comma category is often written 

<math display="inline" id="Comma_category:46">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>A</mi>
    <mo>↓</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <ci>A</ci>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\downarrow\mathcal{C})
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Comma_category:47">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is the object of 

<math display="inline" id="Comma_category:48">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 selected by 

<math display="inline" id="Comma_category:49">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

. It is called the <em>coslice category</em> with respect to 

<math display="inline" id="Comma_category:50">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, or the category of <em>objects under 

<math display="inline" id="Comma_category:51">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

</em>. The objects are pairs 

<math display="inline" id="Comma_category:52">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>B</mi>
   <mo>,</mo>
   <msub>
    <mi>i</mi>
    <mi>B</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>B</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>i</ci>
     <ci>B</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (B,i_{B})
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Comma_category:53">
 <semantics>
  <mrow>
   <msub>
    <mi>i</mi>
    <mi>B</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi>A</mi>
    <mo>→</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>i</ci>
     <ci>B</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i_{B}:A\rightarrow B
  </annotation>
 </semantics>
</math>

. Given 

<math display="inline" id="Comma_category:54">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>B</mi>
   <mo>,</mo>
   <msub>
    <mi>i</mi>
    <mi>B</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>B</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>i</ci>
     <ci>B</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (B,i_{B})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Comma_category:55">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msup>
    <mi>B</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
   <msub>
    <mi>i</mi>
    <msup>
     <mi>B</mi>
     <mo>′</mo>
    </msup>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>B</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (B^{\prime},i_{B^{\prime}})
  </annotation>
 </semantics>
</math>

, a morphism in the coslice category is a map 

<math display="inline" id="Comma_category:56">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>:</mo>
   <mrow>
    <mi>B</mi>
    <mo>→</mo>
    <msup>
     <mi>B</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>h</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>B</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h:B\rightarrow B^{\prime}
  </annotation>
 </semantics>
</math>

 making the following diagram commute:</p>
<div style="text-align: center;">
<figure><b>(Figure)</b>
<figcaption>CommaCategory-02.png</figcaption>
</figure>
</div>
<h3 id="arrow-category">Arrow category</h3>

<p>

<math display="inline" id="Comma_category:57">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Comma_category:58">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 are <a href="identity_functor" title="wikilink">identity functors</a> on 

<math display="inline" id="Comma_category:59">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 (so 

<math display="inline" id="Comma_category:60">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>=</mo>
   <mi class="ltx_font_mathcaligraphic">ℬ</mi>
   <mo>=</mo>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>𝒜</ci>
     <ci>ℬ</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>𝒞</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}=\mathcal{B}=\mathcal{C}
  </annotation>
 </semantics>
</math>

). In this case, the comma category is the arrow category 

<math display="inline" id="Comma_category:61">
 <semantics>
  <msup>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   <mo>→</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝒞</ci>
    <ci>normal-→</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}^{\rightarrow}
  </annotation>
 </semantics>
</math>

. Its objects are the morphisms of 

<math display="inline" id="Comma_category:62">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

, and its morphisms are commuting squares in 

<math display="inline" id="Comma_category:63">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h3 id="other-variations">Other variations</h3>

<p>In the case of the slice or coslice category, the identity functor may be replaced with some other functor; this yields a family of categories particularly useful in the study of <a href="adjoint_functor" title="wikilink">adjoint functors</a>. For example, if 

<math display="inline" id="Comma_category:64">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is the <a href="forgetful_functor" title="wikilink">forgetful functor</a> mapping an <a href="abelian_group" title="wikilink">abelian group</a> to its underlying <a href="Set_(mathematics)" title="wikilink">set</a>, and 

<math display="inline" id="Comma_category:65">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 is some fixed set (regarded as a functor from <strong>1</strong>), then the comma category 

<math display="inline" id="Comma_category:66">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>s</mi>
    <mo>↓</mo>
    <mi>T</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <ci>s</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s\downarrow T)
  </annotation>
 </semantics>
</math>

 has objects that are maps from 

<math display="inline" id="Comma_category:67">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 to a set underlying a group. This relates to the left adjoint of 

<math display="inline" id="Comma_category:68">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

, which is the functor that maps a set to the <a href="free_abelian_group" title="wikilink">free abelian group</a> having that set as its basis. In particular, the initial object of 

<math display="inline" id="Comma_category:69">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>s</mi>
    <mo>↓</mo>
    <mi>T</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <ci>s</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s\downarrow T)
  </annotation>
 </semantics>
</math>

 is the canonical injection 

<math display="inline" id="Comma_category:70">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>→</mo>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>s</ci>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\rightarrow T(G)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Comma_category:71">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is the free group generated by 

<math display="inline" id="Comma_category:72">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

.</p>

<p>An object of 

<math display="inline" id="Comma_category:73">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>s</mi>
    <mo>↓</mo>
    <mi>T</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <ci>s</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s\downarrow T)
  </annotation>
 </semantics>
</math>

 is called a <em>morphism from 

<math display="inline" id="Comma_category:74">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Comma_category:75">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

</em> or a <em>

<math display="inline" id="Comma_category:76">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

-structured arrow with domain 

<math display="inline" id="Comma_category:77">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

</em> in.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> An object of 

<math display="inline" id="Comma_category:78">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>S</mi>
    <mo>↓</mo>
    <mi>t</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <ci>S</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S\downarrow t)
  </annotation>
 </semantics>
</math>

 is called a <em>morphism from 

<math display="inline" id="Comma_category:79">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Comma_category:80">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

</em> or a <em>

<math display="inline" id="Comma_category:81">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

-costructured arrow with codomain 

<math display="inline" id="Comma_category:82">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

</em> in.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Another special case occurs when both 

<math display="inline" id="Comma_category:83">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Comma_category:84">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 are functors with domain <strong>1</strong>. If 

<math display="inline" id="Comma_category:85">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>*</mo>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <times></times>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(*)=A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Comma_category:86">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>*</mo>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <times></times>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(*)=B
  </annotation>
 </semantics>
</math>

, then the comma category 

<math display="inline" id="Comma_category:87">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>S</mi>
    <mo>↓</mo>
    <mi>T</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <ci>S</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S\downarrow T)
  </annotation>
 </semantics>
</math>

, written 

<math display="inline" id="Comma_category:88">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>A</mi>
    <mo>↓</mo>
    <mi>B</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\downarrow B)
  </annotation>
 </semantics>
</math>

, is the <a href="discrete_category" title="wikilink">discrete category</a> whose objects are morphisms from 

<math display="inline" id="Comma_category:89">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Comma_category:90">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="properties">Properties</h2>

<p>For each comma category there are forgetful functors from it.</p>
<ul>
<li>Domain functor, 

<math display="inline" id="Comma_category:91">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>↓</mo>
   <mi>T</mi>
   <mo>→</mo>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-↓</ci>
     <ci>S</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>𝒜</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\downarrow T\to\mathcal{A}
  </annotation>
 </semantics>
</math>

, which maps:
<ul>
<li>objects

<math display="block" id="Comma_category:92">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo>,</mo>
    <mi>β</mi>
    <mo>,</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↦</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <vector>
     <ci>α</ci>
     <ci>β</ci>
     <ci>f</ci>
    </vector>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\alpha,\beta,f)\mapsto\alpha
  </annotation>
 </semantics>
</math>

;</li>
<li>morphisms

<math display="block" id="Comma_category:93">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>g</mi>
    <mo>,</mo>
    <mi>h</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↦</mo>
   <mi>g</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <interval closure="open">
     <ci>g</ci>
     <ci>h</ci>
    </interval>
    <ci>g</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (g,h)\mapsto g
  </annotation>
 </semantics>
</math>

;</li>
</ul></li>
<li>Codomain functor, 

<math display="inline" id="Comma_category:94">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>↓</mo>
   <mi>T</mi>
   <mo>→</mo>
   <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-↓</ci>
     <ci>S</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>ℬ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\downarrow T\to\mathcal{B}
  </annotation>
 </semantics>
</math>

, which maps:
<ul>
<li>objects

<math display="block" id="Comma_category:95">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo>,</mo>
    <mi>β</mi>
    <mo>,</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↦</mo>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <vector>
     <ci>α</ci>
     <ci>β</ci>
     <ci>f</ci>
    </vector>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\alpha,\beta,f)\mapsto\beta
  </annotation>
 </semantics>
</math>

;</li>
<li>morphisms

<math display="block" id="Comma_category:96">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>g</mi>
    <mo>,</mo>
    <mi>h</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↦</mo>
   <mi>h</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <interval closure="open">
     <ci>g</ci>
     <ci>h</ci>
    </interval>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (g,h)\mapsto h
  </annotation>
 </semantics>
</math>

.</li>
</ul></li>
<li>Arrow functor, 

<math display="inline" id="Comma_category:97">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>↓</mo>
   <mi>T</mi>
   <mo>→</mo>
   <msup>
    <mi>C</mi>
    <mo>↓</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-↓</ci>
     <ci>S</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>C</ci>
      <ci>normal-↓</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\downarrow T\to C^{\downarrow}
  </annotation>
 </semantics>
</math>

, which maps:
<ul>
<li>objects

<math display="block" id="Comma_category:98">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo>,</mo>
    <mi>β</mi>
    <mo>,</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↦</mo>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <vector>
     <ci>α</ci>
     <ci>β</ci>
     <ci>f</ci>
    </vector>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\alpha,\beta,f)\mapsto f
  </annotation>
 </semantics>
</math>

;</li>
<li>morphisms

<math display="block" id="Comma_category:99">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>g</mi>
    <mo>,</mo>
    <mi>h</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↦</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>S</mi>
     <mi>g</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>T</mi>
     <mi>h</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <interval closure="open">
     <ci>g</ci>
     <ci>h</ci>
    </interval>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>g</ci>
     </apply>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>h</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (g,h)\mapsto(Sg,Th)
  </annotation>
 </semantics>
</math>

;</li>
</ul></li>
</ul>
<h2 id="examples-of-use">Examples of use</h2>
<h3 id="some-notable-categories">Some notable categories</h3>

<p>Several interesting categories have a natural definition in terms of comma categories.</p>
<ul>
<li>The category of <a href="pointed_set" title="wikilink">pointed sets</a> is a comma category, 

<math display="inline" id="Comma_category:100">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\bull</mtext>
    </merror>
    <mo>↓</mo>
    <mi>𝐒𝐞𝐭</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <mtext>\bull</mtext>
    <ci>𝐒𝐞𝐭</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle{(\bull\downarrow\mathbf{Set})}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Comma_category:101">
 <semantics>
  <merror class="ltx_ERROR undefined undefined">
   <mtext>\bull</mtext>
  </merror>
  <annotation-xml encoding="MathML-Content">
   <mtext>\bull</mtext>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle{\bull}
  </annotation>
 </semantics>
</math>

 being (a functor selecting) any <a href="singleton_set" title="wikilink">singleton set</a>, and 

<math display="inline" id="Comma_category:102">
 <semantics>
  <mi>𝐒𝐞𝐭</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐒𝐞𝐭</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle{\mathbf{Set}}
  </annotation>
 </semantics>
</math>

 (the identity functor of) the <a href="category_of_sets" title="wikilink">category of sets</a>. Each object of this category is a set, together with a function selecting some element of the set: the "basepoint". Morphisms are functions on sets which map basepoints to basepoints. In a similar fashion one can form the category of <a href="pointed_space" title="wikilink">pointed spaces</a> 

<math display="inline" id="Comma_category:103">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\bull</mtext>
    </merror>
    <mo>↓</mo>
    <mi>𝐓𝐨𝐩</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <mtext>\bull</mtext>
    <ci>𝐓𝐨𝐩</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle{(\bull\downarrow\mathbf{Top})}
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li>The category of <a href="Graph_(mathematics)" title="wikilink">graphs</a> is 

<math display="inline" id="Comma_category:104">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>𝐒𝐞𝐭</mi>
    <mo>↓</mo>
    <mi>D</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <ci>𝐒𝐞𝐭</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle{(\mathbf{Set}\downarrow D)}
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="Comma_category:105">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>:</mo>
   <mrow>
    <mi>𝐒𝐞𝐭</mi>
    <mo>→</mo>
    <mi>𝐒𝐞𝐭</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>D</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>𝐒𝐞𝐭</ci>
     <ci>𝐒𝐞𝐭</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle{D:\mathbf{Set}\rightarrow\mathbf{Set}}
  </annotation>
 </semantics>
</math>

 the functor taking a set 

<math display="inline" id="Comma_category:106">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Comma_category:107">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>×</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\times s
  </annotation>
 </semantics>
</math>

. The objects 

<math display="inline" id="Comma_category:108">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo>,</mo>
   <mi>f</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>a</ci>
    <ci>b</ci>
    <ci>f</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b,f)
  </annotation>
 </semantics>
</math>

 then consist of two sets and a function; 

<math display="inline" id="Comma_category:109">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is an indexing set, 

<math display="inline" id="Comma_category:110">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 is a set of nodes, and 

<math display="inline" id="Comma_category:111">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>a</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mo>×</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>a</ci>
     <apply>
      <times></times>
      <ci>b</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:a\rightarrow(b\times b)
  </annotation>
 </semantics>
</math>

 chooses pairs of elements of 

<math display="inline" id="Comma_category:112">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 for each input from 

<math display="inline" id="Comma_category:113">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

. That is, 

<math display="inline" id="Comma_category:114">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 picks out certain edges from the set 

<math display="inline" id="Comma_category:115">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>×</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>b</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\times b
  </annotation>
 </semantics>
</math>

 of possible edges. A morphism in this category is made up of two functions, one on the indexing set and one on the node set. They must "agree" according to the general definition above, meaning that 

<math display="inline" id="Comma_category:116">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>g</mi>
    <mo>,</mo>
    <mi>h</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo>,</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>a</mi>
      <mo>′</mo>
     </msup>
     <mo>,</mo>
     <msup>
      <mi>b</mi>
      <mo>′</mo>
     </msup>
     <mo>,</mo>
     <msup>
      <mi>f</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <interval closure="open">
     <ci>g</ci>
     <ci>h</ci>
    </interval>
    <apply>
     <ci>normal-→</ci>
     <vector>
      <ci>a</ci>
      <ci>b</ci>
      <ci>f</ci>
     </vector>
     <vector>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>normal-′</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (g,h):(a,b,f)\rightarrow(a^{\prime},b^{\prime},f^{\prime})
  </annotation>
 </semantics>
</math>

 must satisfy 

<math display="inline" id="Comma_category:117">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mo>∘</mo>
    <mi>g</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>h</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∘</mo>
    <mi>f</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>g</ci>
    </apply>
    <apply>
     <compose></compose>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>h</ci>
     </apply>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}\circ g=T(h)\circ f
  </annotation>
 </semantics>
</math>

. In other words, the edge corresponding to a certain element of the indexing set, when translated, must be the same as the edge for the translated index.</li>
</ul>
<ul>
<li>Many "augmentation" or "labelling" operations can be expressed in terms of comma categories. Let 

<math display="inline" id="Comma_category:118">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 be the functor taking each graph to the set of its edges, and let 

<math display="inline" id="Comma_category:119">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 be (a functor selecting) some particular set: then 

<math display="inline" id="Comma_category:120">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>S</mi>
    <mo>↓</mo>
    <mi>A</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <ci>S</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S\downarrow A)
  </annotation>
 </semantics>
</math>

 is the category of graphs whose edges are labelled by elements of 

<math display="inline" id="Comma_category:121">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. This form of comma category is often called <em>objects 

<math display="inline" id="Comma_category:122">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

-over 

<math display="inline" id="Comma_category:123">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

</em> - closely related to the "objects over 

<math display="inline" id="Comma_category:124">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

" discussed above. Here, each object takes the form 

<math display="inline" id="Comma_category:125">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>B</mi>
   <mo>,</mo>
   <msub>
    <mi>π</mi>
    <mi>B</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>B</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <ci>B</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (B,\pi_{B})
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Comma_category:126">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is a graph and 

<math display="inline" id="Comma_category:127">
 <semantics>
  <msub>
   <mi>π</mi>
   <mi>B</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>π</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{B}
  </annotation>
 </semantics>
</math>

 a function from the edges of 

<math display="inline" id="Comma_category:128">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Comma_category:129">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. The nodes of the graph could be labelled in essentially the same way.</li>
</ul>
<ul>
<li>A category is said to be <em>locally cartesian closed</em> if every slice of it is <a href="cartesian_closed" title="wikilink">cartesian closed</a> (see above for the notion of <em>slice</em>). Locally cartesian closed categories are the <a href="classifying_category" title="wikilink">classifying categories</a> of <a href="dependent_type_theory" title="wikilink">dependent type theories</a>.</li>
</ul>
<h3 id="limits-and-universal-morphisms">Limits and universal morphisms</h3>

<p><a href="Limit_(category_theory)" title="wikilink">Colimits</a> in comma categories may be "inherited". If 

<math display="inline" id="Comma_category:130">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Comma_category:131">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>

 are cocomplete, 

<math display="inline" id="Comma_category:132">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    <mo>→</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>S</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>𝒜</ci>
     <ci>𝒞</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S:\mathcal{A}\rightarrow\mathcal{C}
  </annotation>
 </semantics>
</math>

 is a cocontinuous functor, and 

<math display="inline" id="Comma_category:133">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℬ</mi>
    <mo>→</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>T</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>ℬ</ci>
     <ci>𝒞</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T:\mathcal{B}\rightarrow\mathcal{C}
  </annotation>
 </semantics>
</math>

 another functor (not necessarily cocontinuous), then the comma category 

<math display="inline" id="Comma_category:134">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>S</mi>
    <mo>↓</mo>
    <mi>T</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <ci>S</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S\downarrow T)
  </annotation>
 </semantics>
</math>

 produced will also be cocomplete. For example, in the above construction of the category of graphs, the category of sets is cocomplete, and the identity functor is cocontinuous: so graphs are also cocomplete - all (small) colimits exist. This result is much harder to obtain directly.</p>

<p>If 

<math display="inline" id="Comma_category:135">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Comma_category:136">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>

 are complete, and both 

<math display="inline" id="Comma_category:137">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    <mo>→</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>S</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>𝒜</ci>
     <ci>𝒞</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S:\mathcal{A}\rightarrow\mathcal{C}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Comma_category:138">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℬ</mi>
    <mo>→</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>T</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>ℬ</ci>
     <ci>𝒞</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T:\mathcal{B}\rightarrow\mathcal{C}
  </annotation>
 </semantics>
</math>

 are <a href="continuous_functor" title="wikilink">continuous functors</a>,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> then the comma category 

<math display="inline" id="Comma_category:139">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>S</mi>
    <mo>↓</mo>
    <mi>T</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <ci>S</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S\downarrow T)
  </annotation>
 </semantics>
</math>

 is also complete, and the projection functors 

<math display="inline" id="Comma_category:140">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>↓</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-↓</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">A</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S\downarrow T)\rightarrow\mathcal{A}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Comma_category:141">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>↓</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-↓</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">B</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S\downarrow T)\rightarrow\mathcal{B}
  </annotation>
 </semantics>
</math>

 are limit preserving.</p>

<p>The notion of a <a href="Universal_property" title="wikilink">universal morphism</a> to a particular colimit, or from a limit, can be expressed in terms of a comma category. Essentially, we create a category whose objects are cones, and where the limiting cone is a terminal object; then, each universal morphism for the limit is just the morphism to the terminal object. This works in the dual case, with a category of cocones having an initial object. For example, let 

<math display="inline" id="Comma_category:142">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 be a category with 

<math display="inline" id="Comma_category:143">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo>→</mo>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     <mo>×</mo>
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>F</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>𝒞</ci>
     <apply>
      <times></times>
      <ci>𝒞</ci>
      <ci>𝒞</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F:\mathcal{C}\rightarrow\mathcal{C}\times\mathcal{C}
  </annotation>
 </semantics>
</math>

 the functor taking each object 

<math display="inline" id="Comma_category:144">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Comma_category:145">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>c</mi>
   <mo>,</mo>
   <mi>c</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>c</ci>
    <ci>c</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (c,c)
  </annotation>
 </semantics>
</math>

 and each arrow 

<math display="inline" id="Comma_category:146">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Comma_category:147">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>f</mi>
   <mo>,</mo>
   <mi>f</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>f</ci>
    <ci>f</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f,f)
  </annotation>
 </semantics>
</math>

. A universal morphism from 

<math display="inline" id="Comma_category:148">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>a</ci>
    <ci>b</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b)
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Comma_category:149">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 consists, by definition, of an object 

<math display="inline" id="Comma_category:150">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>c</mi>
   <mo>,</mo>
   <mi>c</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>c</ci>
    <ci>c</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (c,c)
  </annotation>
 </semantics>
</math>

 and morphism 

<math display="inline" id="Comma_category:151">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo>,</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>ρ</ci>
    <apply>
     <ci>normal-→</ci>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
     <interval closure="open">
      <ci>c</ci>
      <ci>c</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho:(a,b)\rightarrow(c,c)
  </annotation>
 </semantics>
</math>

 with the universal property that for any morphism 

<math display="inline" id="Comma_category:152">
 <semantics>
  <mrow>
   <msup>
    <mi>ρ</mi>
    <mo>′</mo>
   </msup>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>d</mi>
     <mo>,</mo>
     <mi>d</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ρ</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
     <interval closure="open">
      <ci>d</ci>
      <ci>d</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho^{\prime}:(a,b)\rightarrow(d,d)
  </annotation>
 </semantics>
</math>

 there is a unique morphism 

<math display="inline" id="Comma_category:153">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>:</mo>
   <mrow>
    <mi>c</mi>
    <mo>→</mo>
    <mi>d</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>σ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>c</ci>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma:c\rightarrow d
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Comma_category:154">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>σ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∘</mo>
    <mi>ρ</mi>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>ρ</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>σ</ci>
     </apply>
     <ci>ρ</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ρ</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\sigma)\circ\rho=\rho^{\prime}
  </annotation>
 </semantics>
</math>

. In other words, it is an object in the comma category 

<math display="inline" id="Comma_category:155">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>↓</mo>
    <mi>F</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <interval closure="open">
     <ci>a</ci>
     <ci>b</ci>
    </interval>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((a,b)\downarrow F)
  </annotation>
 </semantics>
</math>

 having a morphism to any other object in that category; it is initial. This serves to define the <a class="uri" href="coproduct" title="wikilink">coproduct</a> in 

<math display="inline" id="Comma_category:156">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

, when it exists.</p>
<h3 id="adjunctions">Adjunctions</h3>

<p>Lawvere showed that the functors 

<math display="inline" id="Comma_category:157">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo>→</mo>
    <mi class="ltx_font_mathcaligraphic">𝒟</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>F</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>𝒞</ci>
     <ci>𝒟</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F:\mathcal{C}\rightarrow\mathcal{D}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Comma_category:158">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒟</mi>
    <mo>→</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>G</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>𝒟</ci>
     <ci>𝒞</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G:\mathcal{D}\rightarrow\mathcal{C}
  </annotation>
 </semantics>
</math>

 are <a href="adjoint_functors" title="wikilink">adjoint</a> if and only if the comma categories 

<math display="inline" id="Comma_category:159">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>F</mi>
    <mo>↓</mo>
    <mrow>
     <mi>i</mi>
     <msub>
      <mi>d</mi>
      <mi class="ltx_font_mathcaligraphic">𝒟</mi>
     </msub>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <ci>F</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>𝒟</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (F\downarrow id_{\mathcal{D}})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Comma_category:160">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mi>i</mi>
     <msub>
      <mi>d</mi>
      <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     </msub>
    </mrow>
    <mo>↓</mo>
    <mi>G</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>𝒞</ci>
     </apply>
    </apply>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (id_{\mathcal{C}}\downarrow G)
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="Comma_category:161">
 <semantics>
  <mrow>
   <mi>i</mi>
   <msub>
    <mi>d</mi>
    <mi class="ltx_font_mathcaligraphic">𝒟</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>i</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>𝒟</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   id_{\mathcal{D}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Comma_category:162">
 <semantics>
  <mrow>
   <mi>i</mi>
   <msub>
    <mi>d</mi>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>i</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>𝒞</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   id_{\mathcal{C}}
  </annotation>
 </semantics>
</math>

 the identity functors on 

<math display="inline" id="Comma_category:163">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Comma_category:164">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒟</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒟</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{D}
  </annotation>
 </semantics>
</math>

 respectively, are isomorphic, and equivalent elements in the comma category can be projected onto the same element of 

<math display="inline" id="Comma_category:165">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   <mo>×</mo>
   <mi class="ltx_font_mathcaligraphic">𝒟</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒞</ci>
    <ci>𝒟</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}\times\mathcal{D}
  </annotation>
 </semantics>
</math>

. This allows adjunctions to be described without involving sets, and was in fact the original motivation for introducing comma categories.</p>
<h3 id="natural-transformations">Natural transformations</h3>

<p>If the domains of 

<math display="inline" id="Comma_category:166">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>,</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>S</ci>
    <ci>T</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S,T
  </annotation>
 </semantics>
</math>

 are equal, then the diagram which defines morphisms in 

<math display="inline" id="Comma_category:167">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>↓</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <ci>S</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\downarrow T
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Comma_category:168">
 <semantics>
  <mrow>
   <mrow>
    <mi>α</mi>
    <mo>=</mo>
    <mi>β</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>α</mi>
      <mo>′</mo>
     </msup>
     <mo>=</mo>
     <msup>
      <mi>β</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>g</mi>
     <mo>=</mo>
     <mi>h</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>α</ci>
     <ci>β</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>α</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>β</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <ci>g</ci>
      <ci>h</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=\beta,\alpha^{\prime}=\beta^{\prime},g=h
  </annotation>
 </semantics>
</math>

 is identical to the diagram which defines a <a href="natural_transformation" title="wikilink">natural transformation</a> 

<math display="inline" id="Comma_category:169">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>→</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>S</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\to T
  </annotation>
 </semantics>
</math>

. The difference between the two notions is that a natural transformation is a particular collection of morphisms of type of the form 

<math display="inline" id="Comma_category:170">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>α</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>α</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>α</ci>
    </apply>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\alpha)\to T(\alpha)
  </annotation>
 </semantics>
</math>

, while objects of the comma category contains <em>all</em> morphisms of type of such form. A functor to the comma category selects that particular collection of morphisms. This is described succinctly by an observation by Huq that a natural transformation 

<math display="inline" id="Comma_category:171">
 <semantics>
  <mrow>
   <mi>η</mi>
   <mo>:</mo>
   <mrow>
    <mi>S</mi>
    <mo>→</mo>
    <mi>T</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>η</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>S</ci>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta:S\to T
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="Comma_category:172">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mo>,</mo>
    <mi>T</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    <mo>→</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <list>
     <ci>S</ci>
     <ci>T</ci>
    </list>
    <apply>
     <ci>normal-→</ci>
     <ci>𝒜</ci>
     <ci>𝒞</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S,T:\mathcal{A}\to\mathcal{C}
  </annotation>
 </semantics>
</math>

, corresponds to a functor 

<math display="inline" id="Comma_category:173">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>↓</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-↓</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}\to(S\downarrow T)
  </annotation>
 </semantics>
</math>

 which maps each object 

<math display="inline" id="Comma_category:174">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Comma_category:175">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>α</mi>
   <mo>,</mo>
   <mi>α</mi>
   <mo>,</mo>
   <msub>
    <mi>η</mi>
    <mi>α</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>α</ci>
    <ci>α</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>η</ci>
     <ci>α</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\alpha,\alpha,\eta_{\alpha})
  </annotation>
 </semantics>
</math>

 and maps each morphism 

<math display="inline" id="Comma_category:176">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Comma_category:177">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>g</mi>
   <mo>,</mo>
   <mi>g</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>g</ci>
    <ci>g</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (g,g)
  </annotation>
 </semantics>
</math>

. This is a <a href="bijection" title="wikilink">bijective</a> correspondence between natural transformations 

<math display="inline" id="Comma_category:178">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>→</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>S</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\to T
  </annotation>
 </semantics>
</math>

 and functors 

<math display="inline" id="Comma_category:179">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>↓</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-↓</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}\to(S\downarrow T)
  </annotation>
 </semantics>
</math>

 which are <a href="section_(category_theory)" title="wikilink">sections</a> of both forgetful functors from 

<math display="inline" id="Comma_category:180">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>↓</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <ci>S</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\downarrow T
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="references">References</h2>
<references>
</references>
<ul>
<li></li>
<li>Lawvere, W (1963). "FUNCTORIAL SEMANTICS OF ALGEBRAIC THEORIES AND SOME ALGEBRAIC PROBLEMS IN THE CONTEXT OF FUNCTORIAL SEMANTICS OF ALGEBRAIC THEORIES" <a class="uri" href="http://www.tac.mta.ca/tac/reprints/articles/5/tr5.pdf">http://www.tac.mta.ca/tac/reprints/articles/5/tr5.pdf</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>J. Adamek, H. Herrlich, G. Stecker, <a href="http://katmat.math.uni-bremen.de/acc/acc.pdf">Abstract and Concrete Categories-The Joy of Cats</a></li>
<li><a href="http://wildcatsformma.wordpress.com">WildCats</a> is a category theory package for <a class="uri" href="Mathematica" title="wikilink">Mathematica</a>. Manipulation and visualization of objects, <a href="morphism" title="wikilink">morphisms</a>, categories, <a href="functor" title="wikilink">functors</a>, <a href="natural_transformation" title="wikilink">natural transformations</a>, <a href="universal_properties" title="wikilink">universal properties</a>.</li>
<li><a href="http://www.j-paine.org/cgi-bin/webcats/webcats.php">Interactive Web page</a> which generates examples of categorical constructions in the category of finite sets.</li>
</ul>

<p>"</p>

<p><a href="Category:Category-theoretic_categories" title="wikilink">Category:Category-theoretic categories</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4">See I. 2.16.1 in Francis Borceux (1994), <em>Handbook of Categorical Algebra 1</em>, Cambridge University Press. ISBN 0-521-44178-1.<a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
