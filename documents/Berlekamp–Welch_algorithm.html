<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1042">Berlekamp–Welch algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Berlekamp–Welch algorithm</h1>
<hr/>

<p>The <strong>Berlekamp–Welch algorithm</strong>, also known as the <strong>Welch–Berlekamp algorithm</strong>, is named for <a href="Elwyn_R._Berlekamp" title="wikilink">Elwyn R. Berlekamp</a> and <a href="Lloyd_R._Welch" title="wikilink">Lloyd R. Welch</a>. The algorithm efficiently corrects errors in <a href="BCH_code" title="wikilink">BCH codes</a> and <a href="Reed–Solomon_error_correction" title="wikilink">Reed–Solomon codes</a> (which are a subset of BCH codes). Unlike many other decoding algorithms, and in correspondence with the code-domain <a href="Berlekamp–Massey_algorithm" title="wikilink">Berlekamp–Massey algorithm</a> that uses <a href="Decoding_methods#Syndrome_decoding" title="wikilink">syndrome decoding</a> and the dual of the codes, the Berlekamp–Welch decoding algorithm provides a method for decoding Reed–Solomon codes using just the generator matrix and not syndromes.</p>
<h2 id="history-on-decoding-reedsolomon-codes">History on decoding Reed–Solomon codes</h2>
<ol>
<li>In 1960, Peterson came up with an algorithm for decoding <a href="BCH_codes" title="wikilink">BCH codes</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> His algorithm solves the important second stage of the generalized BCH decoding procedure and is used to calculate the error locator polynomial coefficients that in turn provide the error locator polynomial. This is crucial to the decoding of BCH codes.</li>
<li>In 1963, Gorenstein–Zierler saw that BCH codes and <a href="Reed–Solomon_error_correction" title="wikilink">Reed–Solomon codes</a> have a common generalization and that the decoding algorithm extends to more general situation.</li>
<li>In 1968 / 69, <a href="Elwyn_Berlekamp" title="wikilink">Elwyn Berlekamp</a> invented an algorithm for decoding BCH codes. <a href="James_Massey" title="wikilink">James Massey</a> recognized its application to linear feedback shift registers and simplified the algorithm.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Massey termed the algorithm the LFSR Synthesis Algorithm (Berlekamp Iterative Algorithm) but it is now known as the <a href="Berlekamp–Massey_algorithm" title="wikilink">Berlekamp–Massey algorithm</a>.</li>
<li>In 1986, The Welch–Berlekamp algorithm was developed to solve the decoding equation of <a href="Reed–Solomon_error_correction" title="wikilink">Reed–Solomon codes</a>, using a fast method to solve a certain polynomial equation. The Berlekamp – Welch algorithm has a running time complexity of 

<math display="inline" id="Berlekamp–Welch_algorithm:0">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>N</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>N</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(N^{3})
  </annotation>
 </semantics>
</math>

. We will in the following sections look at the Gemmel and Sudan’s exposition of the Berlekamp Welch Algorithm.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
</ol>
<h2 id="error-locator-polynomial-of-reedsolomon-codes">Error locator polynomial of Reed–Solomon codes</h2>

<p>In the problem of decoding Reed–Solomon codes, the inputs are pair wise distinct evaluation points 

<math display="inline" id="Berlekamp–Welch_algorithm:1">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}
  </annotation>
 </semantics>
</math>

’s (<em>i</em> = 1, . . ., <em>n</em>) where 

<math display="inline" id="Berlekamp–Welch_algorithm:2">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mi>𝔽</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>i</ci>
    </apply>
    <ci>𝔽</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}\in\mathbb{F}
  </annotation>
 </semantics>
</math>

 with <a href="Block_code#Definitions" title="wikilink">dimension</a> 

<math display="inline" id="Berlekamp–Welch_algorithm:3">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 and <a href="Block_code#Minimum_distance" title="wikilink">distance</a> 

<math display="inline" id="Berlekamp–Welch_algorithm:4">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mi>K</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <ci>K</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=N-K+1
  </annotation>
 </semantics>
</math>

 and a codeword 

<math display="inline" id="Berlekamp–Welch_algorithm:5">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 = 

<math display="inline" id="Berlekamp–Welch_algorithm:6">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi>𝔽</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝔽</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (y_{1},\ldots,y_{n})\in\mathbb{F}_{n}
  </annotation>
 </semantics>
</math>

. Our goal is to describe an algorithm that can correct 

<math display="inline" id="Berlekamp–Welch_algorithm:7">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo><</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mi>K</mi>
     </mrow>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>e</ci>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <ci>K</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e<{N-K+1\over 2}
  </annotation>
 </semantics>
</math>

 many errors in polynomial time. To do so we have to find a polynomial 

<math display="inline" id="Berlekamp–Welch_algorithm:8">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 over 

<math display="inline" id="Berlekamp–Welch_algorithm:9">
 <semantics>
  <mi>𝔽</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔽</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{F}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Berlekamp–Welch_algorithm:10">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 has degree less than 

<math display="inline" id="Berlekamp–Welch_algorithm:11">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>k</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k-1
  </annotation>
 </semantics>
</math>

 and (the number of 

<math display="inline" id="Berlekamp–Welch_algorithm:12">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

’s such that 

<math display="inline" id="Berlekamp–Welch_algorithm:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>≤</mo>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <neq></neq>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\alpha_{i})\neq y_{i}\leq e
  </annotation>
 </semantics>
</math>

. We can assume that there exists a polynomial 

<math display="inline" id="Berlekamp–Welch_algorithm:14">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X)
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Berlekamp–Welch_algorithm:15">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>,</mo>
    <msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>α</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <interval closure="open">
     <ci>y</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <ci>P</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(y,(P(\alpha_{i}))^{N}_{i=1})
  </annotation>
 </semantics>
</math>

 ≤ 

<math display="inline" id="Berlekamp–Welch_algorithm:16">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>≤</mo>
   <mfrac>
    <mi>D</mi>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>e</ci>
    <apply>
     <divide></divide>
     <ci>D</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e\leq{D\over 2}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Berlekamp–Welch_algorithm:17">
 <semantics>
  <mfrac>
   <mrow>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mi>K</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mn>2</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <ci>K</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {N-K+1\over 2}
  </annotation>
 </semantics>
</math>

.</p>

<p>Note that the coefficients of 

<math display="inline" id="Berlekamp–Welch_algorithm:18">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 are the encoded information. To solve this, we use an indicator for those 

<math display="inline" id="Berlekamp–Welch_algorithm:19">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

’s where an error may have occurred. Thus we define 

<math display="inline" id="Berlekamp–Welch_algorithm:20">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(X)
  </annotation>
 </semantics>
</math>

, which is an error locator polynomial over 

<math display="inline" id="Berlekamp–Welch_algorithm:21">
 <semantics>
  <mi>𝔽</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔽</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{F}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Berlekamp–Welch_algorithm:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\alpha_{i})=0
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Berlekamp–Welch_algorithm:23">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>≠</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}\neq P(\alpha_{i})
  </annotation>
 </semantics>
</math>

 and the degree of 

<math display="inline" id="Berlekamp–Welch_algorithm:24">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 can be given by

<math display="block" id="Berlekamp–Welch_algorithm:25">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>≤</mo>
   <mfrac>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mi>k</mi>
    </mrow>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>E</ci>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\leq{n-k\over 2}
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Berlekamp–Welch_algorithm:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mrow>
      <msub>
       <mi>α</mi>
       <mi>i</mi>
      </msub>
      <mo>∈</mo>
      <mi>S</mi>
     </mrow>
    </munder>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>X</mi>
      <mo>-</mo>
      <msub>
       <mi>α</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <in></in>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>i</ci>
       </apply>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>X</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(X)=\prod_{\alpha_{i}\in S}(X-\alpha_{i})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Berlekamp–Welch_algorithm:27">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>α</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>α</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>≠</mo>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <neq></neq>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\{\alpha_{i}|P(\alpha_{i})\neq y_{i}\}
  </annotation>
 </semantics>
</math>

</p>

<p>We can also claim that for every 

<math display="inline" id="Berlekamp–Welch_algorithm:28">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>i</mi>
   <mo>≤</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq i\leq N
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Berlekamp–Welch_algorithm:29">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}E(\alpha_{i})=P(\alpha_{i})E(\alpha_{i})
  </annotation>
 </semantics>
</math>

. This fact holds true because in the event of 

<math display="inline" id="Berlekamp–Welch_algorithm:30">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>≠</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}\neq P(\alpha_{i})
  </annotation>
 </semantics>
</math>

, both sides of the above equation become 

<math display="inline" id="Berlekamp–Welch_algorithm:31">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 because 

<math display="inline" id="Berlekamp–Welch_algorithm:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\alpha_{i})=0
  </annotation>
 </semantics>
</math>

.</p>

<p>However since both 

<math display="inline" id="Berlekamp–Welch_algorithm:33">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(X)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Berlekamp–Welch_algorithm:34">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X)
  </annotation>
 </semantics>
</math>

 are unknown, the main task of the decoding algorithm would be to find 

<math display="inline" id="Berlekamp–Welch_algorithm:35">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X)
  </annotation>
 </semantics>
</math>

. To do this we use a seemingly useless yet very powerful method and define another polynomial 

<math display="inline" id="Berlekamp–Welch_algorithm:36">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X)
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Berlekamp–Welch_algorithm:37">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X)
  </annotation>
 </semantics>
</math>

 = 

<math display="inline" id="Berlekamp–Welch_algorithm:38">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>X</ci>
    <ci>E</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X)E(X)
  </annotation>
 </semantics>
</math>

. This is because the 

<math display="inline" id="Berlekamp–Welch_algorithm:39">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 equations with 

<math display="inline" id="Berlekamp–Welch_algorithm:40">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>+</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>e</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e+k
  </annotation>
 </semantics>
</math>

 we need to solve are quadratic in nature. Thus by defining a product of two variables that gives rise to a quadratic term as one unknown variable, we increase the number of unknowns but make the equations linear in nature. This method is called linearization<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> and is a very powerful tool.</p>

<p>Thus 

<math display="inline" id="Berlekamp–Welch_algorithm:41">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X)
  </annotation>
 </semantics>
</math>

 is a polynomial over 

<math display="inline" id="Berlekamp–Welch_algorithm:42">
 <semantics>
  <mi>𝔽</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔽</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{F}
  </annotation>
 </semantics>
</math>

 having the properties:</p>
<ol>
<li>

<math display="inline" id="Berlekamp–Welch_algorithm:43">
 <semantics>
  <mrow>
   <mrow>
    <mi>deg</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mi>k</mi>
      </mrow>
      <mn>2</mn>
     </mfrac>
     <mo>+</mo>
     <mi>k</mi>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="latexml">degree</csymbol>
     <ci>Q</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <ci>k</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \deg(Q)\leq{{n-k\over 2}+k-1}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Berlekamp–Welch_algorithm:44">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>α</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall Q(\alpha_{i})=E(\alpha_{i})y_{i}
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>This helps because if we now manage to find 

<math display="inline" id="Berlekamp–Welch_algorithm:45">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Berlekamp–Welch_algorithm:46">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(X)
  </annotation>
 </semantics>
</math>

, we can easily find 

<math display="inline" id="Berlekamp–Welch_algorithm:47">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X)
  </annotation>
 </semantics>
</math>

 using 

<math display="inline" id="Berlekamp–Welch_algorithm:48">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X)={Q(X)\over E(X)}
  </annotation>
 </semantics>
</math>

. The main purpose of the Berlekamp Welch algorithm is to find out 

<math display="inline" id="Berlekamp–Welch_algorithm:49">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X)
  </annotation>
 </semantics>
</math>

 using degree bounded polynomials 

<math display="inline" id="Berlekamp–Welch_algorithm:50">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Berlekamp–Welch_algorithm:51">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(X)
  </annotation>
 </semantics>
</math>

 and the properties of 

<math display="inline" id="Berlekamp–Welch_algorithm:52">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Berlekamp–Welch_algorithm:53">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

.</p>

<p>Computing 

<math display="inline" id="Berlekamp–Welch_algorithm:54">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(X)
  </annotation>
 </semantics>
</math>

 is as hard as ﬁnding the end solution, polynomial 

<math display="inline" id="Berlekamp–Welch_algorithm:55">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X)
  </annotation>
 </semantics>
</math>

. Once 

<math display="inline" id="Berlekamp–Welch_algorithm:56">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(X)
  </annotation>
 </semantics>
</math>

 is computed, using erasure decoding for Reed–Solomon codes, we can easily recover 

<math display="inline" id="Berlekamp–Welch_algorithm:57">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X)
  </annotation>
 </semantics>
</math>

. However in a few cases, even the polynomial 

<math display="inline" id="Berlekamp–Welch_algorithm:58">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X)
  </annotation>
 </semantics>
</math>

 is as hard to ﬁnd as 

<math display="inline" id="Berlekamp–Welch_algorithm:59">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(X)
  </annotation>
 </semantics>
</math>

. As an example, given 

<math display="inline" id="Berlekamp–Welch_algorithm:60">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Berlekamp–Welch_algorithm:61">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 (such that 

<math display="inline" id="Berlekamp–Welch_algorithm:62">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}\neq 0
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Berlekamp–Welch_algorithm:63">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>i</mi>
   <mo>≤</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq i\leq n
  </annotation>
 </semantics>
</math>

), by checking positions where 

<math display="inline" id="Berlekamp–Welch_algorithm:64">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(i)=0
  </annotation>
 </semantics>
</math>

, we can ﬁnd the error locations. Thus the algorithm works on the principle that while each of the polynomials 

<math display="inline" id="Berlekamp–Welch_algorithm:65">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(X)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Berlekamp–Welch_algorithm:66">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X)
  </annotation>
 </semantics>
</math>

 are hard to ﬁnd individually; computing them together is much easier.</p>
<h2 id="the-berlekampwelch-decoder-and-algorithm">The Berlekamp–Welch decoder and algorithm</h2>

<p>The Welch–Berlekamp decoder for Reed–Solomon codes consists of the Welch– Berlekamp algorithm augmented by some additional steps that prepare the received word for the algorithm and interpret the result of the algorithm.</p>

<p>The inputs given to the Berlekamp Welch decoder are the integers denoting Block Length 

<math display="inline" id="Berlekamp–Welch_algorithm:67">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, the number of errors 

<math display="inline" id="Berlekamp–Welch_algorithm:68">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Berlekamp–Welch_algorithm:69">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 {N - K + 1 \over 2}, and the received word 

<math display="inline" id="Berlekamp–Welch_algorithm:70">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>α</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>N</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
     </interval>
     <ci>N</ci>
    </apply>
    <apply>
     <eq></eq>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (y_{i},\alpha_{i})^{N}_{i=1}
  </annotation>
 </semantics>
</math>

 satisfying the condition that there exists at most one 

<math display="inline" id="Berlekamp–Welch_algorithm:71">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X)
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Berlekamp–Welch_algorithm:72">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mi>e</mi>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>k</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>e</ci>
     <ci>g</ci>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   deg(P(X))\leq{k-1}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Berlekamp–Welch_algorithm:73">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mrow>
      <mi>P</mi>
      <msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>α</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <interval closure="open">
      <ci>y</ci>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <ci>i</ci>
        </apply>
        <ci>i</ci>
       </apply>
      </apply>
     </interval>
    </apply>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(y,{P(\alpha_{i})_{i}})\leq e
  </annotation>
 </semantics>
</math>

.</p>

<p>The output of the decoder is either the polynomial 

<math display="inline" id="Berlekamp–Welch_algorithm:74">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X)
  </annotation>
 </semantics>
</math>

, or in some cases, a failure. This decoder functions in two steps as follows:</p>
<ol>
<li>This step is called the interpolation step in which the decoder computes a non zero polynomial 

<math display="inline" id="Berlekamp–Welch_algorithm:75">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(X)
  </annotation>
 </semantics>
</math>

 of degree e (This implies that the coefficient of 

<math display="inline" id="Berlekamp–Welch_algorithm:76">
 <semantics>
  <msup>
   <mi>X</mi>
   <mi>e</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>X</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{e}
  </annotation>
 </semantics>
</math>

 must be 1 <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a>) and another polynomial 

<math display="inline" id="Berlekamp–Welch_algorithm:77">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X)
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Berlekamp–Welch_algorithm:78">
 <semantics>
  <mrow>
   <mrow>
    <mi>deg</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>Q</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mi>e</mi>
     <mo>+</mo>
     <mi>K</mi>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="latexml">degree</csymbol>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <ci>e</ci>
      <ci>K</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \deg(Q(X))\leq{e+K-1}
  </annotation>
 </semantics>
</math>

. These polynomials are created such that the condition 

<math display="inline" id="Berlekamp–Welch_algorithm:79">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}E(\alpha_{i})=Q(\alpha_{i})
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Berlekamp–Welch_algorithm:80">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>i</mi>
   <mo>≤</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq i\leq n
  </annotation>
 </semantics>
</math>

. In the case that polynomials satisfying the above condition cannot be computed, the output of the decoder would be a failure.</li>
<li>If 

<math display="inline" id="Berlekamp–Welch_algorithm:81">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(X)
  </annotation>
 </semantics>
</math>

 divides 

<math display="inline" id="Berlekamp–Welch_algorithm:82">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X)
  </annotation>
 </semantics>
</math>

, then a 

<math display="inline" id="Berlekamp–Welch_algorithm:83">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

’

<math display="inline" id="Berlekamp–Welch_algorithm:84">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>X</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (X)
  </annotation>
 </semantics>
</math>

 is defined which equals 

<math display="inline" id="Berlekamp–Welch_algorithm:85">
 <semantics>
  <mfrac>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X)\over E(X)
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Berlekamp–Welch_algorithm:86">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>P</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Δ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-,</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">P</csymbol>
      </cerror>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta((y,(P
  </annotation>
 </semantics>
</math>

’

<math display="inline" id="Berlekamp–Welch_algorithm:87">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>α</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≤</mo>
   <mi>e</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <leq></leq>
    <csymbol cd="unknown">e</csymbol>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\alpha_{i})_{i})\leq e)
  </annotation>
 </semantics>
</math>

, then the decoder outputs 

<math display="inline" id="Berlekamp–Welch_algorithm:88">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

’

<math display="inline" id="Berlekamp–Welch_algorithm:89">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>X</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (X)
  </annotation>
 </semantics>
</math>

. If the above condition is not satisfied, i.e. if 

<math display="inline" id="Berlekamp–Welch_algorithm:90">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(X)
  </annotation>
 </semantics>
</math>

 does not divide 

<math display="inline" id="Berlekamp–Welch_algorithm:91">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X)
  </annotation>
 </semantics>
</math>

then a failure is returned by the decoder.</li>
</ol>

<p>According to the algorithm, in the cases where it does not output a failure, it outputs a 

<math display="inline" id="Berlekamp–Welch_algorithm:92">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X)
  </annotation>
 </semantics>
</math>

 that is the correct and desired polynomial. To prove that, the algorithm always outputs the desired polynomial, we need to prove a few claims we have made while describing the algorithm. Let us go ahead and do so now.</p>

<p><strong><em>Claim 1: There exist a pair of polynomials 

<math display="inline" id="Berlekamp–Welch_algorithm:93">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(X)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Berlekamp–Welch_algorithm:94">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X)
  </annotation>
 </semantics>
</math>

 that satisfy Step 1 of the BW algorithm such that 

<math display="inline" id="Berlekamp–Welch_algorithm:95">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {Q(X)\over E(X)}=P(X)
  </annotation>
 </semantics>
</math>

.</em></strong></p>

<p>Let <em>E</em>(<em>x</em>) be the error-locating polynomial for 

<math display="inline" id="Berlekamp–Welch_algorithm:96">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X)
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Berlekamp–Welch_algorithm:97">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>X</mi>
     <mrow>
      <mi>e</mi>
      <mo>-</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo>,</mo>
        <mrow>
         <mi>P</mi>
         <msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>α</mi>
            <mi>i</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi>i</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msup>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∏</mo>
      <mrow>
       <mn>1</mn>
       <mo>≤</mo>
       <mi>i</mi>
       <mo>≤</mo>
       <mi>n</mi>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mo>≠</mo>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>α</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>X</mi>
       <mo>-</mo>
       <msub>
        <mi>α</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <apply>
       <minus></minus>
       <ci>e</ci>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <interval closure="open">
         <ci>y</ci>
         <apply>
          <times></times>
          <ci>P</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>α</ci>
            <ci>i</ci>
           </apply>
           <ci>i</ci>
          </apply>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <cn type="integer">1</cn>
        <leq></leq>
        <csymbol cd="unknown">i</csymbol>
        <leq></leq>
        <csymbol cd="unknown">n</csymbol>
        <ci>normal-|</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <neq></neq>
        <csymbol cd="unknown">P</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>α</ci>
          <ci>i</ci>
         </apply>
         <ci>normal-)</ci>
        </cerror>
       </cerror>
      </apply>
      <apply>
       <minus></minus>
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(X)=X^{e-\Delta(y,P(\alpha_{i})_{i})}\prod_{1\leq i\leq n|y_{i}\neq P(\alpha_%
{i})}(X-\alpha_{i})
  </annotation>
 </semantics>
</math>

and let 

<math display="inline" id="Berlekamp–Welch_algorithm:98">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>X</ci>
     <ci>E</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X)=P(X)E(X)
  </annotation>
 </semantics>
</math>

. Note that 

<math display="inline" id="Berlekamp–Welch_algorithm:99">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mi>e</mi>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>Q</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mi>e</mi>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>d</mi>
     <mi>e</mi>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>E</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mi>e</mi>
     <mo>+</mo>
     <mi>k</mi>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>g</ci>
      <apply>
       <times></times>
       <ci>Q</ci>
       <ci>X</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>e</ci>
       <ci>g</ci>
       <apply>
        <times></times>
        <ci>P</ci>
        <ci>X</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>e</ci>
       <ci>g</ci>
       <apply>
        <times></times>
        <ci>E</ci>
        <ci>X</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <ci>e</ci>
       <ci>k</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   deg(Q(X))\leq{deg(P(X))+deg(E(X))}\leq{e+k-1}
  </annotation>
 </semantics>
</math>

. We also stated that 

<math display="inline" id="Berlekamp–Welch_algorithm:100">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(X)
  </annotation>
 </semantics>
</math>

 is a polynomial of degree exactly 

<math display="inline" id="Berlekamp–Welch_algorithm:101">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

. Note that 

<math display="inline" id="Berlekamp–Welch_algorithm:102">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(X)
  </annotation>
 </semantics>
</math>

 is a polynomial following the property that 

<math display="inline" id="Berlekamp–Welch_algorithm:103">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\alpha_{i})=0
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Berlekamp–Welch_algorithm:104">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>≠</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}\neq P(\alpha_{i})
  </annotation>
 </semantics>
</math>

.We can now state that 

<math display="inline" id="Berlekamp–Welch_algorithm:105">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(X)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Berlekamp–Welch_algorithm:106">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X)
  </annotation>
 </semantics>
</math>

 satisfy the equation 

<math display="inline" id="Berlekamp–Welch_algorithm:107">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}E(\alpha_{i})=Q(\alpha_{i})
  </annotation>
 </semantics>
</math>

 from the first step of the BW algorithm. If 

<math display="inline" id="Berlekamp–Welch_algorithm:108">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\alpha_{i})=0
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Berlekamp–Welch_algorithm:109">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
      <ci>E</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <ci>E</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(\alpha_{i})=P(\alpha_{i})E(\alpha_{i})=y_{i}E(\alpha_{i})=0
  </annotation>
 </semantics>
</math>

. However whenever 

<math display="inline" id="Berlekamp–Welch_algorithm:110">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\alpha_{i})\neq 0
  </annotation>
 </semantics>
</math>

, we can easily state that 

<math display="inline" id="Berlekamp–Welch_algorithm:111">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\alpha_{i})=y_{i}
  </annotation>
 </semantics>
</math>

 and therefore also state that 

<math display="inline" id="Berlekamp–Welch_algorithm:112">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\alpha_{i})E(\alpha_{i})=y_{i}E(\alpha_{i})
  </annotation>
 </semantics>
</math>

 just as we claimed.</p>

<p>This above claim however just reiterates and proves the fact that there exists a pair of polynomials 

<math display="inline" id="Berlekamp–Welch_algorithm:113">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(X)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Berlekamp–Welch_algorithm:114">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X)
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Berlekamp–Welch_algorithm:115">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X)
  </annotation>
 </semantics>
</math>

 = 

<math display="inline" id="Berlekamp–Welch_algorithm:116">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mi>E</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>X</ci>
     </apply>
     <ci>E</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X)/E(X)
  </annotation>
 </semantics>
</math>

. It however does not necessarily guarantee the fact that the algorithm we discussed above would indeed output such a pair of polynomials. We therefore move on to look at another claim that helps establish this fact using the above claim and thereby proving the correctness of the algorithm.</p>

<p><strong><em>Claim 2: For any two distinct solutions 

<math display="inline" id="Berlekamp–Welch_algorithm:117">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>E</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≠</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>E</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <interval closure="open">
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>X</ci>
     </apply>
    </interval>
    <interval closure="open">
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>X</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (E_{1}(X),Q_{1}(X))\neq(E_{2}(X),Q_{2}(X))
  </annotation>
 </semantics>
</math>

 that satisfy the first step of the Berlekamp Welch algorithm given above, they will also satisfy the equation 

<math display="inline" id="Berlekamp–Welch_algorithm:118">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mi>E</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mi>E</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {Q_{1}(X)\over E_{1}(X)}={Q_{2}(X)\over E_{2}(X)}
  </annotation>
 </semantics>
</math>

</em></strong></p>

<p>The total degrees of the polynomials 

<math display="inline" id="Berlekamp–Welch_algorithm:119">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <msub>
    <mi>E</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>X</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{1}(X)E_{1}(X)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Berlekamp–Welch_algorithm:120">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Q</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>E</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>e</mi>
     </mrow>
     <mo>+</mo>
     <mi>k</mi>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>X</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>e</ci>
      </apply>
      <ci>k</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{2}(X)E_{2}(X)\leq{2e+k-1}
  </annotation>
 </semantics>
</math>

. We define another polynomial 

<math display="inline" id="Berlekamp–Welch_algorithm:121">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>E</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>E</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>X</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>X</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(X)=Q_{1}(X)E_{2}(X)-Q_{2}(X)E_{1}(X)
  </annotation>
 </semantics>
</math>

 ....................................(i)</p>

<p>Note that 

<math display="inline" id="Berlekamp–Welch_algorithm:122">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(X)
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Berlekamp–Welch_algorithm:123">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mi>e</mi>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>e</mi>
     </mrow>
     <mo>+</mo>
     <mi>k</mi>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>e</ci>
     <ci>g</ci>
     <apply>
      <times></times>
      <ci>R</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>e</ci>
      </apply>
      <ci>k</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   deg(R(X))\leq{2e+k-1}
  </annotation>
 </semantics>
</math>

. From step 1 of the Berlekamp Welch algorithm we also know that 

<math display="inline" id="Berlekamp–Welch_algorithm:124">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>E</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>Q</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}E_{1}(\alpha_{i})=Q_{1}(\alpha_{i})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Berlekamp–Welch_algorithm:125">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <msub>
    <mi>E</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>α</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>Q</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>α</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <cn type="integer">2</cn>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <cn type="integer">2</cn>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}E_{2}(\alpha_{i})=Q_{2}(\alpha_{i}
  </annotation>
 </semantics>
</math>

) ........…..........(ii)</p>

<p>Now, substituting the values of 

<math display="inline" id="Berlekamp–Welch_algorithm:126">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X)
  </annotation>
 </semantics>
</math>

 from equation (ii) into equation (i), we get: 

<math display="inline" id="Berlekamp–Welch_algorithm:127">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>E</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>α</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>E</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>α</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>E</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>α</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>E</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>α</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>R</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(\alpha_{i})=y_{i}E_{1}(\alpha_{i})E_{2}(\alpha_{i})-y_{i}E_{2}(\alpha_{i})E_%
{1}(\alpha_{i})=0
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Berlekamp–Welch_algorithm:128">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>i</mi>
   <mo>≤</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq i\leq n
  </annotation>
 </semantics>
</math>

.</p>

<p>Thus, the above polynomial 

<math display="inline" id="Berlekamp–Welch_algorithm:129">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(X)
  </annotation>
 </semantics>
</math>

 has 

<math display="inline" id="Berlekamp–Welch_algorithm:130">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 roots and 

<math display="inline" id="Berlekamp–Welch_algorithm:131">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mi>e</mi>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>e</mi>
     </mrow>
     <mo>+</mo>
     <mi>k</mi>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>e</ci>
     <ci>g</ci>
     <apply>
      <times></times>
      <ci>R</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>e</ci>
      </apply>
      <ci>k</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   deg(R(X))\leq{2e+k-1}
  </annotation>
 </semantics>
</math>

 which implies that 

<math display="inline" id="Berlekamp–Welch_algorithm:132">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>e</mi>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>e</ci>
    <ci>g</ci>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   deg(R(X))
  </annotation>
 </semantics>
</math>

 n because of the upper bound on 

<math display="inline" id="Berlekamp–Welch_algorithm:133">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Berlekamp–Welch_algorithm:134">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>e</mi>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>e</ci>
    <ci>g</ci>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   deg(R(X))
  </annotation>
 </semantics>
</math>

 n, we can come to the conclusion that the polynomials 

<math display="inline" id="Berlekamp–Welch_algorithm:135">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <msub>
    <mi>E</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>X</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{1}(X)E_{2}(X)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Berlekamp–Welch_algorithm:136">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <msub>
    <mi>E</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>X</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{2}(X)E_{1}(X)
  </annotation>
 </semantics>
</math>

 agree on more points than their degree, and hence they are identical. Note that since 

<math display="inline" id="Berlekamp–Welch_algorithm:137">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>E</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>X</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{1}(X)\neq 0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Berlekamp–Welch_algorithm:138">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>E</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>X</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{2}(X)\neq 0
  </annotation>
 </semantics>
</math>

, it can be implied that 

<math display="inline" id="Berlekamp–Welch_algorithm:139">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mi>E</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mi>E</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {Q_{1}(X)\over E_{1}(X)}={Q_{2}(X)\over E_{2}(X)}
  </annotation>
 </semantics>
</math>

 as per our initial claim.</p>

<p>Thus based on the above claims, we can safely state that the output of the Berlekamp Welch algorithm, when outputting the polynomial 

<math display="inline" id="Berlekamp–Welch_algorithm:140">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X)
  </annotation>
 </semantics>
</math>

 is correct.</p>

<p>We can now claim that the algorithm can be implemented such that it has a running time of 

<math display="inline" id="Berlekamp–Welch_algorithm:141">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3})
  </annotation>
 </semantics>
</math>

. This can be proved as follows: In Step 1 of the algorithm, the polynomials 

<math display="inline" id="Berlekamp–Welch_algorithm:142">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Berlekamp–Welch_algorithm:143">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(X)
  </annotation>
 </semantics>
</math>

 have 

<math display="inline" id="Berlekamp–Welch_algorithm:144">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>+</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>e</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e+k
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Berlekamp–Welch_algorithm:145">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>e</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e+1
  </annotation>
 </semantics>
</math>

 unknown values respectively and the constraints 

<math display="inline" id="Berlekamp–Welch_algorithm:146">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}E(\alpha_{i})=Q(\alpha_{i})
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Berlekamp–Welch_algorithm:147">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>i</mi>
   <mo>≤</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq i\leq n
  </annotation>
 </semantics>
</math>

 acts as a linear equation with these unknowns. We therefore get a system of 

<math display="inline" id="Berlekamp–Welch_algorithm:148">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 linear equations in 

<math display="inline" id="Berlekamp–Welch_algorithm:149">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>e</mi>
   </mrow>
   <mo>+</mo>
   <mi>k</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>e</ci>
    </apply>
    <ci>k</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2e+k+1
  </annotation>
 </semantics>
</math>

 n + 2 unknowns. Using our first claim, this system of equations has a solution since the degree of polynomial 

<math display="inline" id="Berlekamp–Welch_algorithm:150">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(X)
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Berlekamp–Welch_algorithm:151">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

. This can be solved in 

<math display="inline" id="Berlekamp–Welch_algorithm:152">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3})
  </annotation>
 </semantics>
</math>

 time, by say Gaussian elimination. Finally, we can note that Step 2 of the algorithm can also be implemented in time 

<math display="inline" id="Berlekamp–Welch_algorithm:153">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3})
  </annotation>
 </semantics>
</math>

 by "long division" method. Hence we can state that the Berlekamp Welch algorithm can be used to uniquely decode any 

<math display="inline" id="Berlekamp–Welch_algorithm:154">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <interval closure="closed">
     <ci>n</ci>
     <ci>k</ci>
    </interval>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [n,k]_{q}
  </annotation>
 </semantics>
</math>

 Reed–Solomon code in 

<math display="inline" id="Berlekamp–Welch_algorithm:155">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3})
  </annotation>
 </semantics>
</math>

 time for a maximum of 

<math display="inline" id="Berlekamp–Welch_algorithm:156">
 <semantics>
  <mfrac>
   <mrow>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mi>k</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mn>2</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {n-k+1}\over 2
  </annotation>
 </semantics>
</math>

 errors.</p>
<h2 id="example">Example</h2>

<p><a href="File:Recovering_P(x)_with_an_Error_Locator_Polynomial.png" title="wikilink">thumb|upright=1.5|The error locator polynomial serves to "neutralize" errors in P by making Q zero at those points, so that the system of linear equations is not affected by the inaccuracy in the input.</a></p>

<p>Consider a simple example where a redundant set of points are used to represent the line 

<math display="inline" id="Berlekamp–Welch_algorithm:157">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mn>5</mn>
    <mo>-</mo>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <minus></minus>
     <cn type="integer">5</cn>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=5-x
  </annotation>
 </semantics>
</math>

, and one of the points is incorrect. The points that the algorithm gets as an input are 

<math display="inline" id="Berlekamp–Welch_algorithm:158">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>4</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mn>3</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>3</mn>
    <mo>,</mo>
    <mn>4</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>4</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <interval closure="open">
     <cn type="integer">1</cn>
     <cn type="integer">4</cn>
    </interval>
    <interval closure="open">
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
    </interval>
    <interval closure="open">
     <cn type="integer">3</cn>
     <cn type="integer">4</cn>
    </interval>
    <interval closure="open">
     <cn type="integer">4</cn>
     <cn type="integer">1</cn>
    </interval>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1,4),(2,3),(3,4),(4,1)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Berlekamp–Welch_algorithm:159">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>3</mn>
   <mo>,</mo>
   <mn>4</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">3</cn>
    <cn type="integer">4</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (3,4)
  </annotation>
 </semantics>
</math>

 is the defective point. The algorithm must solve the following system of equations:<br/>
<br/>


<math display="inline" id="Berlekamp–Welch_algorithm:160">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle Q(1)
  </annotation>
 </semantics>
</math>


<br/>
Given a solution 

<math display="inline" id="Berlekamp–Welch_algorithm:161">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Berlekamp–Welch_algorithm:162">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 to this system of equations, it is evident that at any of the points 

<math display="inline" id="Berlekamp–Welch_algorithm:163">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mn>3</mn>
    <mo>,</mo>
    <mn>4</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <list>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
     <cn type="integer">4</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=1,2,3,4
  </annotation>
 </semantics>
</math>

 one of the following must be true: either 

<math display="inline" id="Berlekamp–Welch_algorithm:164">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x_{i})=E(x_{i})=0
  </annotation>
 </semantics>
</math>

, or 

<math display="inline" id="Berlekamp–Welch_algorithm:165">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>Q</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>E</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x_{i})={Q(x_{i})\over E(x_{i})}=y_{i}
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Berlekamp–Welch_algorithm:166">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 is defined as only having a degree of one, the former can only be true in one point. Therefore, 

<math display="inline" id="Berlekamp–Welch_algorithm:167">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x_{i})
  </annotation>
 </semantics>
</math>

 must equal 

<math display="inline" id="Berlekamp–Welch_algorithm:168">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}
  </annotation>
 </semantics>
</math>

 at the three other points.</p>

<p>Letting 

<math display="inline" id="Berlekamp–Welch_algorithm:169">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <msub>
     <mi>e</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(x)=x+e_{0}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Berlekamp–Welch_algorithm:170">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>q</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>q</mi>
      <mn>1</mn>
     </msub>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>q</mi>
      <mn>2</mn>
     </msub>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x)=q_{0}+q_{1}x+q_{2}x^{2}
  </annotation>
 </semantics>
</math>

 and bringing 

<math display="inline" id="Berlekamp–Welch_algorithm:171">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(x)
  </annotation>
 </semantics>
</math>

 to the left, we can rewrite the system thus:<br/>
<br/>


<math display="inline" id="Berlekamp–Welch_algorithm:172">
 <semantics>
  <msub>
   <mi>q</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle q_{0}
  </annotation>
 </semantics>
</math>


<br/>
This system can be solved through <a href="Gaussian_elimination" title="wikilink">Gaussian elimination</a>, and gives the values:<br/>
<br/>


<math display="block" id="Berlekamp–Welch_algorithm:173">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>q</mi>
     <mn>0</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mn>15</mn>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>q</mi>
      <mn>1</mn>
     </msub>
     <mo>=</mo>
     <mn>8</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>q</mi>
       <mn>2</mn>
      </msub>
      <mo>=</mo>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>e</mi>
       <mn>0</mn>
      </msub>
      <mo>=</mo>
      <mrow>
       <mo>-</mo>
       <mn>3</mn>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">15</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">8</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>q</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{0}=-15,q_{1}=8,q_{2}=-1,e_{0}=-3
  </annotation>
 </semantics>
</math>

<br/>
Thus, 

<math display="inline" id="Berlekamp–Welch_algorithm:174">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo>-</mo>
       <msup>
        <mi>x</mi>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mn>8</mn>
       <mi>x</mi>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mn>15</mn>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <mn>3</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">8</cn>
        <ci>x</ci>
       </apply>
      </apply>
      <cn type="integer">15</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x)=-x^{2}+8x-15,E(x)=x-3
  </annotation>
 </semantics>
</math>

. Dividing the two gives:<br/>
<br/>


<math display="block" id="Berlekamp–Welch_algorithm:175">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>5</mn>
    <mo>-</mo>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>Q</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>E</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <cn type="integer">5</cn>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {Q(x)\over E(x)}=P(x)=5-x
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="Berlekamp–Welch_algorithm:176">
 <semantics>
  <mrow>
   <mn>5</mn>
   <mo>-</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">5</cn>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   5-x
  </annotation>
 </semantics>
</math>

 fits three of the four points given, so it is the most likely to be the original polynomial.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="BCH_code" title="wikilink">BCH code</a></li>
<li><a href="Berlekamp–Massey_algorithm" title="wikilink">Berlekamp–Massey algorithm</a></li>
<li><a href="Reed–Solomon_error_correction" title="wikilink">Reed–Solomon error correction</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://people.csail.mit.edu/madhu/FT02/">MIT Lecture Notes on Essential Coding Theory – Dr. Madhu Sudan</a></li>
<li><a href="http://www.cse.buffalo.edu/~atri/courses/coding-theory/fall07.html">University at Buffalo Lecture Notes on Coding Theory – Dr. Atri Rudra</a></li>
<li>Algebraic Codes on Lines, Planes and Curves, An Engineering Approach – Richard E. Blahut</li>
<li>Welch Berlekamp Decoding of Reed–Solomon Codes – L. R. Welch</li>
<li>

<p>– The patent by Lloyd R. Welch and Elewyn R. Berlekamp</p></li>
</ul>

<p>"</p>

<p><a href="Category:Finite_fields" title="wikilink">Category:Finite fields</a> <a href="Category:Coding_theory" title="wikilink">Category:Coding theory</a> <a href="Category:Information_theory" title="wikilink">Category:Information theory</a> <a href="Category:Error_detection_and_correction" title="wikilink">Category:Error detection and correction</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">. Previous publisher McGraw–Hill, New York, NY.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="http://people.csail.mit.edu/madhu/papers/1992/gemmell.pdf">Highly resilient correctors for polynomials – Peter Gemmel and Madhu Sudan's Exposition.</a><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="http://rjlipton.wordpress.com/2010/12/13/making-a-heuristic-into-a-theorem/">A provable example of the linearization method – Dick Lipton</a><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
