<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="764">Modular multiplicative inverse</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Modular multiplicative inverse</h1>
<hr/>

<p>In <a href="modular_arithmetic" title="wikilink">modular arithmetic</a>, the <strong>modular multiplicative inverse</strong> of an <a class="uri" href="integer" title="wikilink">integer</a> <em>a</em> <a href="modular_arithmetic" title="wikilink">modulo</a> <em>m</em> is an integer <em>x</em> such that</p>

<p>

<math display="block" id="Modular_multiplicative_inverse:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>a</mi>
     </mpadded>
     <mi>x</mi>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mn>1</mn>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mi>m</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <ci>pmod</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,x\equiv 1\;\;(\mathop{{\rm mod}}m).
  </annotation>
 </semantics>
</math>

</p>

<p>That is, it is the <a href="multiplicative_inverse" title="wikilink">multiplicative inverse</a> in the <a href="Ring_(mathematics)" title="wikilink">ring</a> of integers modulo <em>m</em>, denoted 

<math display="inline" id="Modular_multiplicative_inverse:1">
 <semantics>
  <msub>
   <mi>ℤ</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ℤ</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{m}
  </annotation>
 </semantics>
</math>

.</p>

<p>Once defined, <em>x</em> may be noted 

<math display="inline" id="Modular_multiplicative_inverse:2">
 <semantics>
  <msup>
   <mi>a</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>a</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{-1}
  </annotation>
 </semantics>
</math>

, where the fact that the inversion is m-modular is implicit.</p>

<p>The multiplicative inverse of <em>a</em> modulo <em>m</em> exists <a href="Iff" title="wikilink">if and only if</a> <em>a</em> and <em>m</em> are <a class="uri" href="coprime" title="wikilink">coprime</a> (i.e., if ).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> If the modular multiplicative inverse of <em>a</em> modulo <em>m</em> exists, the operation of <a href="Division_(mathematics)" title="wikilink">division</a> by <em>a</em> modulo <em>m</em> can be defined as multiplying by the inverse, which is in essence the same concept as division in the <a href="field_(mathematics)" title="wikilink">field</a> of reals.</p>
<h2 id="example">Example</h2>

<p>Suppose we wish to find modular multiplicative inverse <em>x</em> of 3 modulo 11.</p>

<p>

<math display="block" id="Modular_multiplicative_inverse:3">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≡</mo>
   <mrow>
    <msup>
     <mn>3</mn>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>11</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">3</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">11</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\equiv 3^{-1}\;\;(\mathop{{\rm mod}}11)
  </annotation>
 </semantics>
</math>

</p>

<p>This is the same as finding <em>x</em> such that</p>

<p>

<math display="block" id="Modular_multiplicative_inverse:4">
 <semantics>
  <mrow>
   <mrow>
    <mn>3</mn>
    <mi>x</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mn>1</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>11</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <cn type="integer">3</cn>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">11</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3x\equiv 1\;\;(\mathop{{\rm mod}}11)
  </annotation>
 </semantics>
</math>

</p>

<p>Working in 

<math display="inline" id="Modular_multiplicative_inverse:5">
 <semantics>
  <msub>
   <mi>ℤ</mi>
   <mn>11</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ℤ</ci>
    <cn type="integer">11</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{11}
  </annotation>
 </semantics>
</math>

 we find one value of <em>x</em> that satisfies this congruence is 4 because</p>

<p>

<math display="block" id="Modular_multiplicative_inverse:6">
 <semantics>
  <mrow>
   <mrow>
    <mn>3</mn>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>4</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>12</mn>
   <mo>≡</mo>
   <mrow>
    <mn>1</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>11</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <cn type="integer">4</cn>
     </apply>
     <cn type="integer">12</cn>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <cn type="integer">1</cn>
      <apply>
       <ci>pmod</ci>
       <cn type="integer">11</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3(4)=12\equiv 1\;\;(\mathop{{\rm mod}}11)
  </annotation>
 </semantics>
</math>

</p>

<p>and there are no other values of <em>x</em> in 

<math display="inline" id="Modular_multiplicative_inverse:7">
 <semantics>
  <msub>
   <mi>ℤ</mi>
   <mn>11</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ℤ</ci>
    <cn type="integer">11</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{11}
  </annotation>
 </semantics>
</math>

 that satisfy this congruence. Therefore, the modular multiplicative inverse of 3 modulo 11 is 4.</p>

<p>Once we have found the inverse of 3 in 

<math display="inline" id="Modular_multiplicative_inverse:8">
 <semantics>
  <msub>
   <mi>ℤ</mi>
   <mn>11</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ℤ</ci>
    <cn type="integer">11</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{11}
  </annotation>
 </semantics>
</math>


, we can find other values of <em>x</em> in 

<math display="inline" id="Modular_multiplicative_inverse:9">
 <semantics>
  <mi>ℤ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℤ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}
  </annotation>
 </semantics>
</math>

 that also satisfy the congruence. They may be found by adding multiples of  to the found inverse. Generalizing, all possible <em>x</em> for this example can be formed from</p>

<p>

<math display="block" id="Modular_multiplicative_inverse:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mn>4</mn>
     <mo>+</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>11</mn>
       <mo>⋅</mo>
       <mi>z</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi>z</mi>
   </mrow>
   <mo>∈</mo>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <plus></plus>
      <cn type="integer">4</cn>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="integer">11</cn>
       <ci>z</ci>
      </apply>
     </apply>
     <ci>z</ci>
    </list>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4+(11\cdot z),z\in\mathbb{Z}
  </annotation>
 </semantics>
</math>

</p>

<p>yielding {..., −18, −7, <strong>4</strong>, 15, 26, ...}.</p>
<h2 id="computation">Computation</h2>
<h3 id="extended-euclidean-algorithm">Extended Euclidean algorithm</h3>

<p>The modular multiplicative inverse of <em>a</em> modulo <em>m</em> can be found with the <a href="extended_Euclidean_algorithm" title="wikilink">extended Euclidean algorithm</a>. The algorithm finds solutions to <a href="Bézout's_identity" title="wikilink">Bézout's identity</a></p>

<p>

<math display="block" id="Modular_multiplicative_inverse:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>b</mi>
     <mi>y</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>gcd</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>b</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <gcd></gcd>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ax+by=\gcd(a,b)\,
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>a</em> and <em>b</em> are given and <em>x</em>, <em>y</em> and gcd(<em>a</em>, <em>b</em>) are the integers that the algorithm discovers. So, since the modular multiplicative inverse is the solution to</p>

<p>

<math display="block" id="Modular_multiplicative_inverse:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mi>x</mi>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mn>1</mn>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mi>m</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <ci>pmod</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ax\equiv 1\;\;(\mathop{{\rm mod}}m),
  </annotation>
 </semantics>
</math>

</p>

<p>by the definition of congruence, , which means that m is a <a class="uri" href="divisor" title="wikilink">divisor</a> of . This, in turn, means that</p>

<p>

<math display="block" id="Modular_multiplicative_inverse:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>a</mi>
      <mi>x</mi>
     </mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>q</mi>
     <mi>m</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>x</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>q</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ax-1=qm.\,
  </annotation>
 </semantics>
</math>

</p>

<p>Rearranging produces</p>

<p>

<math display="block" id="Modular_multiplicative_inverse:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>a</mi>
      <mi>x</mi>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>q</mi>
      <mi>m</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>q</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ax-qm=1,\,
  </annotation>
 </semantics>
</math>

</p>

<p>with <em>a</em> and <em>m</em> given, <em>x</em> the inverse, and <em>q</em> an integer multiple that will be discarded. This is the exact form of equation that the extended Euclidean algorithm solves—the only difference being that  is predetermined instead of discovered. Thus, <em>a</em> needs to be <a class="uri" href="coprime" title="wikilink">coprime</a> to the modulus, or the inverse won't exist.</p>

<p>This algorithm runs in time O(log(<em>m</em>)<sup>2</sup>), assuming , and is generally more efficient than exponentiation.</p>
<h3 id="using-eulers-theorem">Using Euler's theorem</h3>

<p>As an alternative to the extended Euclidean algorithm, Euler's theorem may be used to compute modular inverse:<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>According to <a href="Euler's_theorem" title="wikilink">Euler's theorem</a>, if <em>a</em> is <a class="uri" href="coprime" title="wikilink">coprime</a> to <em>m</em>, that is, , then</p>

<p>

<math display="block" id="Modular_multiplicative_inverse:15">
 <semantics>
  <mrow>
   <msup>
    <mi>a</mi>
    <mrow>
     <mi>φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>m</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mn>1</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>m</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <apply>
      <times></times>
      <ci>φ</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <ci>pmod</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{\varphi(m)}\equiv 1\;\;(\mathop{{\rm mod}}m)
  </annotation>
 </semantics>
</math>

</p>

<p>where φ(<em>m</em>) is <a href="Euler's_totient_function" title="wikilink">Euler's totient function</a>. This follows from the fact that <em>a</em> belongs to the <a href="multiplicative_group_of_integers_modulo_n" title="wikilink">multiplicative group</a> (<strong>Z</strong>/<em>m</em><strong>Z</strong>)<sup>×</sup> <a href="if_and_only_if" title="wikilink">iff</a> <em>a</em> is <a class="uri" href="coprime" title="wikilink">coprime</a> to <em>m</em>. Therefore the modular multiplicative inverse can be found directly:</p>

<p>

<math display="block" id="Modular_multiplicative_inverse:16">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>a</mi>
     <mrow>
      <mrow>
       <mi>φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>m</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>≡</mo>
    <mrow>
     <msup>
      <mi>a</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mi>m</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>φ</ci>
       <ci>m</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{\varphi(m)-1}\equiv a^{-1}\;\;(\mathop{{\rm mod}}m).
  </annotation>
 </semantics>
</math>

</p>

<p>In the special case when <em>m</em> is a prime, the modular inverse is given by the below equation as:</p>

<p>

<math display="block" id="Modular_multiplicative_inverse:17">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>a</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>≡</mo>
    <mrow>
     <msup>
      <mi>a</mi>
      <mrow>
       <mi>m</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mi>m</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <ci>m</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{-1}\equiv a^{m-2}\;\;(\mathop{{\rm mod}}m).
  </annotation>
 </semantics>
</math>

</p>

<p>This method is generally slower than the extended Euclidean algorithm, but is sometimes used when an implementation for modular exponentiation is already available. Some disadvantages of this method include:</p>
<ul>
<li>The value <em>φ</em>(<em>m</em>) must be known, whose most efficient computation requires <em>m</em>'s <a class="uri" href="factorization" title="wikilink">factorization</a>. Factorization is widely believed to be a computationally hard problem. However, calculating <em>φ</em>(<em>m</em>) is straightforward when the prime factorisation of <em>m</em> is known.</li>
<li>The relative cost of exponentiation. Though it can be implemented more efficiently using <a href="modular_exponentiation" title="wikilink">modular exponentiation</a>, when large values of <em>m</em> are involved this is most efficiently computed with the <a href="Montgomery_reduction" title="wikilink">Montgomery reduction</a> method. This algorithm itself requires a modular inverse mod <em>m</em>, which is what was to be calculated in the first place. Without the Montgomery method, we're left with standard <a href="binary_exponentiation" title="wikilink">binary exponentiation</a> which requires division mod <em>m</em> at every step, a slow operation when <em>m</em> is large. Furthermore, any kind of modular exponentiation is a taxing operation.</li>
</ul>
<h2 id="applications">Applications</h2>

<p>The modular multiplicative inverse has many applications in algorithms, particularly those related to number theory, since many such algorithms rely heavily on the theory of modular arithmetic. As a simple example, consider the <em>exact division problem</em> where you have a list of odd word-sized numbers each divisible by <em>k</em> and you wish to divide them all by <em>k</em>. One solution is as follows:</p>
<ol>
<li>Use the extended Euclidean algorithm to compute <em>k</em><sup>−1</sup>, the modular multiplicative inverse of <em>k</em> mod 2<sup><em>w</em></sup>, where <em>w</em> is the number of bits in a word. This inverse will exist since the numbers are odd and the modulus has no odd factors.</li>
<li>For each number in the list, multiply it by <em>k</em><sup>−1</sup> and take the least significant word of the result.</li>
</ol>

<p>On many machines, particularly those without hardware support for division, division is a slower operation than multiplication, so this approach can yield a considerable speedup. The first step is relatively slow but only needs to be done once.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Inversive_congruential_generator" title="wikilink">Inversive congruential generator</a></li>
<li><a href="Modular_arithmetic" title="wikilink">Modular arithmetic</a></li>
<li><a href="Number_theory" title="wikilink">Number theory</a></li>
<li><a href="Public-key_cryptography" title="wikilink">Public-key cryptography</a></li>
<li><a href="Rational_reconstruction_(mathematics)" title="wikilink">Rational reconstruction (mathematics)</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Modular_arithmetic" title="wikilink">Category:Modular arithmetic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">.<a href="#fnref1">↩</a></li>
<li id="fn2">Thomas Koshy. [<a class="uri" href="http://books.google.com/books?id=d5Z5I3gnFh0C&amp;pg">http://books.google.com/books?id=d5Z5I3gnFh0C&amp;pg;</a>;=PA346 Elementary number theory with applications], 2nd edition. ISBN 978-0-12-372487-8. P. 346.<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
