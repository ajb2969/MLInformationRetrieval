<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1082">Loop variant</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Loop variant</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, a <strong>loop variant</strong> is a <a href="function_(mathematics)" title="wikilink">mathematical function</a> defined on the <a href="State_(computer_science)" title="wikilink">state space</a> of a computer program whose value is monotonically decreased with respect to a (strict) <a href="well-founded_relation" title="wikilink">well-founded relation</a> by the iteration of a <a href="while_loop" title="wikilink">while loop</a> under some <a href="Loop_invariant" title="wikilink">invariant conditions</a>, thereby <a href="Termination_analysis" title="wikilink">ensuring its termination</a>. A loop variant whose range is restricted to the non-negative integers is also known as a <strong>bound function</strong>, because in this case it provides a trivial upper bound on the number of iterations of a loop before it terminates. However, a loop variant may be <a href="Transfinite_number" title="wikilink">transfinite</a>, and thus is not necessarily restricted to integer values.</p>

<p>A well-founded relation is characterized by the existence of a minimal element of every non-empty subset of its domain. The existence of a variant proves the termination of a <a href="while_loop" title="wikilink">while loop</a> in a computer program by <strong><a href="Transfinite_induction" title="wikilink">well-founded descent</a></strong>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> A basic property of a well-founded relation is that it has no <a href="infinite_descending_chain" title="wikilink">infinite descending chains</a>. Therefore a loop possessing a variant will terminate after a finite number of iterations, as long as its body terminates each time.</p>

<p>A <a href="while_loop" title="wikilink">while loop</a>, or, more generally, a computer program that may contain while loops, is said to be <strong>totally correct</strong> if it is <a href="Partial_correctness" title="wikilink">partially correct</a> and it terminates.</p>
<h2 id="rule-of-inference-for-total-correctness">Rule of inference for total correctness</h2>

<p>In order to formally state the rule of inference for the termination of a while loop we have demonstrated above, recall that in <a href="Floyd–Hoare_logic" title="wikilink">Floyd–Hoare logic</a>, the rule for expressing the partial correctness of a while loop is:</p>

<p>

<math display="block" id="Loop_variant:0">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mi>I</mi>
       <mo>∧</mo>
       <mi>C</mi>
      </mrow>
      <mo rspace="5.3pt" stretchy="false">}</mo>
     </mrow>
     <mpadded width="+2.8pt">
      <mi>S</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>I</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>I</mi>
      <mo rspace="5.3pt" stretchy="false">}</mo>
     </mrow>
     <mpadded width="+2.8pt">
      <mi>𝐰𝐡𝐢𝐥𝐞</mi>
     </mpadded>
     <mpadded width="+2.8pt">
      <mi>C</mi>
     </mpadded>
     <mpadded width="+2.8pt">
      <mi>𝐝𝐨</mi>
     </mpadded>
     <mpadded width="+2.8pt">
      <mi>S</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mi>I</mi>
       <mo>∧</mo>
       <mrow>
        <mi mathvariant="normal">¬</mi>
        <mi>C</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <set>
      <apply>
       <and></and>
       <ci>I</ci>
       <ci>C</ci>
      </apply>
     </set>
     <ci>S</ci>
     <set>
      <ci>I</ci>
     </set>
    </apply>
    <apply>
     <times></times>
     <set>
      <ci>I</ci>
     </set>
     <ci>𝐰𝐡𝐢𝐥𝐞</ci>
     <ci>C</ci>
     <ci>𝐝𝐨</ci>
     <ci>S</ci>
     <set>
      <apply>
       <and></and>
       <ci>I</ci>
       <apply>
        <times></times>
        <not></not>
        <ci>C</ci>
       </apply>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\{I\land C\}\;S\;\{I\}}{\{I\}\;\mathbf{while}\;C\;\mathbf{do}\;S\;\{I%
\land\lnot C\}},
  </annotation>
 </semantics>
</math>

 where <em>I</em> is the <em><a href="loop_invariant" title="wikilink">invariant</a></em>, <em>C</em> is the <em>condition</em>, and <em>S</em> is the <em>body</em> of the loop. To express total correctness, we write instead:</p>

<p>

<math display="block" id="Loop_variant:1">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo><</mo>
     <mtext>is well-founded</mtext>
     <mo rspace="5.3pt">,</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>I</mi>
      <mo>∧</mo>
      <mi>C</mi>
      <mo>∧</mo>
      <mi>V</mi>
      <mo>=</mo>
      <mi>z</mi>
      <mo rspace="5.3pt" stretchy="false">]</mo>
     </mrow>
     <mpadded width="+2.8pt">
      <mi>S</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>I</mi>
      <mo>∧</mo>
      <mi>V</mi>
      <mo><</mo>
      <mi>z</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>I</mi>
      <mo rspace="5.3pt" stretchy="false">]</mo>
     </mrow>
     <mpadded width="+2.8pt">
      <mi>𝐰𝐡𝐢𝐥𝐞</mi>
     </mpadded>
     <mpadded width="+2.8pt">
      <mi>C</mi>
     </mpadded>
     <mpadded width="+2.8pt">
      <mi>𝐝𝐨</mi>
     </mpadded>
     <mpadded width="+2.8pt">
      <mi>S</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>I</mi>
       <mo>∧</mo>
       <mrow>
        <mi mathvariant="normal">¬</mi>
        <mi>C</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <lt></lt>
     <mtext>is well-founded</mtext>
     <ci>normal-,</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">I</csymbol>
      <and></and>
      <csymbol cd="unknown">C</csymbol>
      <and></and>
      <csymbol cd="unknown">V</csymbol>
      <eq></eq>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <csymbol cd="unknown">S</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">I</csymbol>
      <and></and>
      <csymbol cd="unknown">V</csymbol>
      <lt></lt>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-]</ci>
     </cerror>
    </cerror>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>I</ci>
     </apply>
     <ci>𝐰𝐡𝐢𝐥𝐞</ci>
     <ci>C</ci>
     <ci>𝐝𝐨</ci>
     <ci>S</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <and></and>
       <ci>I</ci>
       <apply>
        <times></times>
        <not></not>
        <ci>C</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{<\textrm{\ is\ well-founded},\;[I\land C\land V=z]\;S\;[I\land V<z]}{[I]%
\;\mathbf{while}\;C\;\mathbf{do}\;S\;[I\land\lnot C]},
  </annotation>
 </semantics>
</math>

 where, in addition, <em>V</em> is the <em>variant</em>, and by convention the unbound symbol <em>z</em> is taken to be <a href="Universal_quantification" title="wikilink">universally quantified</a>.</p>
<h2 id="every-loop-that-terminates-has-a-variant">Every loop that terminates has a variant</h2>

<p>The existence of a variant implies that a while loop terminates. It may seem surprising, but the converse is true, as well, as long as we assume the <a href="axiom_of_choice" title="wikilink">axiom of choice</a>: every while loop that terminates (given its invariant) has a variant. To prove this, assume that the loop</p>

<p>

<math display="block" id="Loop_variant:2">
 <semantics>
  <mrow>
   <mpadded width="+2.8pt">
    <mi>𝐰𝐡𝐢𝐥𝐞</mi>
   </mpadded>
   <mpadded width="+2.8pt">
    <mi>C</mi>
   </mpadded>
   <mpadded width="+2.8pt">
    <mi>𝐝𝐨</mi>
   </mpadded>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐰𝐡𝐢𝐥𝐞</ci>
    <ci>C</ci>
    <ci>𝐝𝐨</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{while}\;C\;\mathbf{do}\;S
  </annotation>
 </semantics>
</math>

 terminates given the invariant <em>I</em> where we have the total correctness assertion</p>

<p>

<math display="block" id="Loop_variant:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>I</mi>
      <mo>∧</mo>
      <mi>C</mi>
     </mrow>
     <mo rspace="5.3pt" stretchy="false">]</mo>
    </mrow>
    <mpadded width="+2.8pt">
     <mi>S</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>I</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <and></and>
      <ci>I</ci>
      <ci>C</ci>
     </apply>
    </apply>
    <ci>S</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [I\land C]\;S\;[I].
  </annotation>
 </semantics>
</math>

 Consider the "successor" relation on the state space 

<math display="inline" id="Loop_variant:4">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

 induced by the execution of the statement <em>S</em> from a state satisfying both the invariant <em>I</em> and the condition <em>C</em>. That is, we say that a state 

<math display="inline" id="Loop_variant:5">
 <semantics>
  <msup>
   <mi>σ</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>σ</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{\prime}
  </annotation>
 </semantics>
</math>

 is a "successor" of 

<math display="inline" id="Loop_variant:6">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 if and only if</p>
<ul>
<li><em>I</em> and <em>C</em> are both true in the state 

<math display="inline" id="Loop_variant:7">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma,
  </annotation>
 </semantics>
</math>

 and</li>
<li>

<math display="inline" id="Loop_variant:8">
 <semantics>
  <msup>
   <mi>σ</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>σ</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{\prime}
  </annotation>
 </semantics>
</math>

 is the state that results from the execution of the statement <em>S</em> in the state 

<math display="inline" id="Loop_variant:9">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma.
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>We note that 

<math display="inline" id="Loop_variant:10">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>σ</mi>
     <mo>′</mo>
    </msup>
    <mo>≠</mo>
    <mi>σ</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>σ</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{\prime}\neq\sigma,
  </annotation>
 </semantics>
</math>

 for otherwise the loop would fail to terminate.</p>

<p>Next consider the reflexive, transitive closure of the "successor" relation. Call this <em>iteration</em>: we say that a state 

<math display="inline" id="Loop_variant:11">
 <semantics>
  <msup>
   <mi>σ</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>σ</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{\prime}
  </annotation>
 </semantics>
</math>

 is an <em>iterate</em> of 

<math display="inline" id="Loop_variant:12">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 if either 

<math display="inline" id="Loop_variant:13">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>σ</mi>
     <mo>′</mo>
    </msup>
    <mo>=</mo>
    <mi>σ</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>σ</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{\prime}=\sigma,
  </annotation>
 </semantics>
</math>

 or there is a finite chain 

<math display="inline" id="Loop_variant:14">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>σ</mi>
    <mn>1</mn>
   </msub>
   <mo rspace="4.2pt">,</mo>
   <mpadded width="+1.7pt">
    <mi mathvariant="normal">…</mi>
   </mpadded>
   <mo>,</mo>
   <msub>
    <mi>σ</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{0},\sigma_{1},\,\dots\,,\sigma_{n}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Loop_variant:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>σ</mi>
     <mn>0</mn>
    </msub>
    <mo>=</mo>
    <mi>σ</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{0}=\sigma,
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Loop_variant:16">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <msup>
    <mi>σ</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>σ</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{n}=\sigma^{\prime}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Loop_variant:17">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{i+1}
  </annotation>
 </semantics>
</math>

 is a "successor" of 

<math display="inline" id="Loop_variant:18">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{i}
  </annotation>
 </semantics>
</math>

 for all <em>i</em>, 

<math display="inline" id="Loop_variant:19">
 <semantics>
  <mrow>
   <mrow>
    <mn>0</mn>
    <mo>≤</mo>
    <mi>i</mi>
    <mo><</mo>
    <mi>n</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq i<n.
  </annotation>
 </semantics>
</math>

</p>

<p>We note that if 

<math display="inline" id="Loop_variant:20">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Loop_variant:21">
 <semantics>
  <msup>
   <mi>σ</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>σ</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{\prime}
  </annotation>
 </semantics>
</math>

 are two distinct states, and 

<math display="inline" id="Loop_variant:22">
 <semantics>
  <msup>
   <mi>σ</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>σ</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{\prime}
  </annotation>
 </semantics>
</math>

 is an iterate of 

<math display="inline" id="Loop_variant:23">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Loop_variant:24">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 cannot be an iterate of 

<math display="inline" id="Loop_variant:25">
 <semantics>
  <mrow>
   <msup>
    <mi>σ</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>σ</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{\prime},
  </annotation>
 </semantics>
</math>

 for again, otherwise the loop would fail to terminate. In other words, iteration is antisymmetric, and thus, a <a href="partial_order" title="wikilink">partial order</a>.</p>

<p>Now, since the while loop terminates after a finite number of steps given the invariant <em>I</em>, and no state has a successor unless <em>I</em> is true in that state, we conclude that every state has only finitely many iterates, every descending chain with respect to iteration has only finitely many distinct values, and thus there is no <a href="infinite_descending_chain" title="wikilink">infinite descending chain</a>, i.e. loop iteration satisfies the <a href="descending_chain_condition" title="wikilink">descending chain condition</a>.</p>

<p>Therefore—assuming the <a href="axiom_of_choice" title="wikilink">axiom of choice</a>—the "successor" relation we originally defined for the loop is <a href="Well-founded_relation" title="wikilink">well-founded</a> on the state space 

<math display="inline" id="Loop_variant:26">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Σ</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma,
  </annotation>
 </semantics>
</math>

 since it is strict (irreflexive) and contained in the "iterate" relation. Thus the identity function on this state space is a variant for the while loop, as we have shown that the state must strictly decrease—as a "successor" and an "iterate"—each time the body <em>S</em> is executed given the invariant <em>I</em> and the condition <em>C</em>.</p>

<p>Moreover, we can show by a counting argument that the existence of any variant implies the existence of a variant in <strong>ω<sub>1</sub></strong>, the <a href="first_uncountable_ordinal" title="wikilink">first uncountable ordinal</a>, i.e.,</p>

<p>

<math display="block" id="Loop_variant:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mo>:</mo>
    <mrow>
     <mi mathvariant="normal">Σ</mi>
     <mo>→</mo>
     <msub>
      <mi>ω</mi>
      <mn>1</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>V</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>normal-Σ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V:\Sigma\rightarrow\omega_{1}.
  </annotation>
 </semantics>
</math>

 This is because the collection of all states reachable by a finite computer program in a finite number of steps from a finite input is countably infinite, and <strong>ω<sub>1</sub></strong> is the enumeration of all <a class="uri" href="well-order" title="wikilink">well-order</a> <a href="Order_type" title="wikilink">types</a> on countable sets.</p>
<h2 id="practical-considerations">Practical considerations</h2>

<p>In practice, loop variants are often taken to be non-negative <a href="integer" title="wikilink">integers</a>, or even required to be so,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> but the requirement that every loop have an integer variant removes the expressive power of <strong><a href="μ_operator" title="wikilink">unbounded iteration</a></strong> from a programming language. Unless such a (formally verified) language allows a transfinite proof of termination for some other equally powerful construct such as a <a href="Recursion_(computer_science)" title="wikilink">recursive function call</a>, it is no longer capable of full <strong><a href="μ-recursive_function" title="wikilink">μ-recursion</a></strong>, but only <strong><a href="Primitive_recursive_function" title="wikilink">primitive recursion</a></strong>. <a href="Ackermann's_function" title="wikilink">Ackermann's function</a> is the canonical example of a recursive function that cannot be computed in a <a href="For_loop" title="wikilink">loop with an integer variant</a>.</p>

<p>In terms of their <a href="Computational_complexity_theory" title="wikilink">computational complexity</a>, however, functions that are not primitive recursive lie far beyond the realm of what is usually considered <a class="uri" href="tractable" title="wikilink">tractable</a>. Considering even the simple case of exponentiation as a primitive recursive function, and that the composition of primitive recursive functions is primitive recursive, one can begin to see how quickly a primitive recursive function can grow. And any function that can be computed by a <a href="Turing_machine" title="wikilink">Turing machine</a> in a running time bounded by a primitive recursive function is itself primitive recursive. So it is difficult to imagine a practical use for full μ-recursion where primitive recursion will not do, especially since the former can be simulated by the latter up to exceedingly long running times.</p>

<p>And in any case, <a href="Kurt_Gödel" title="wikilink">Kurt Gödel</a>'s first <a href="Gödel's_incompleteness_theorems" title="wikilink">incompleteness theorem</a> and the <a href="halting_problem" title="wikilink">halting problem</a> imply that there are while loops that always terminate but cannot be proven to do so; thus it is unavoidable that any requirement for a formal proof of termination must reduce the expressive power of a programming language. While we have shown that every loop that terminates has a variant, this does not mean that the well-foundedness of the loop iteration can be proven.</p>
<h3 id="example">Example</h3>

<p>Here is an example, in <a href="C_(programming_language)" title="wikilink">C</a>-like <a class="uri" href="pseudocode" title="wikilink">pseudocode</a>, of an integer variant computed from some upper bound on the number of iterations remaining in a while loop. However, <a href="C_(programming_language)" title="wikilink">C</a> allows side effects in the evaluation of expressions, which is unacceptable from the point of view of formally verifying a computer program.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">unsigned</span> <span class="dt">int</span> B(); <span class="co">/* computes a loop iteration bound without side effects */</span>
<span class="dt">unsigned</span> <span class="dt">int</span> V = B(); <span class="co">/* set variant equal to bound */</span>
assert(I); <span class="co">/* loop invariant */</span>
<span class="kw">while</span> (C) {
    assert(V &gt; <span class="dv">0</span>); <span class="co">/* this assertion is the variant's raison d'être (reason of existence) */</span>
    S(); <span class="co">/* body of loop must not alter V */</span>
    V = min(B(), V - <span class="dv">1</span>); <span class="co">/* variant must decrease by at least one */</span>
}
assert(I &amp;&amp; !C); <span class="co">/* invariant is still true and condition is false */</span></code></pre></div>
<h3 id="why-even-consider-a-non-integer-variant">Why even consider a non-integer variant?</h3>

<p>Why even consider a non-integer or transfinite variant? This question has been raised because in all practical instances where we want to prove that a program terminates, we also want to prove that it terminates in a reasonable amount of time. There are at least two possibilities:</p>
<ul>
<li>An upper bound on the number of iterations of a loop may be conditional on proving termination in the first place. It may be desirable to separately (or progressively) prove the three properties of
<ul>
<li>partial correctness,</li>
<li>termination, and</li>
<li>running time.</li>
</ul></li>
<li>Generality: considering transfinite variants allows all possible proofs of termination for a while loop to be seen in terms of the existence of a variant.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="While_loop" title="wikilink">While loop</a></li>
<li><a href="Loop_invariant" title="wikilink">Loop invariant</a></li>
<li><a href="Transfinite_induction" title="wikilink">Transfinite induction</a></li>
<li><a href="Descending_chain_condition" title="wikilink">Descending chain condition</a></li>
<li><a href="Large_countable_ordinal" title="wikilink">Large countable ordinal</a></li>
<li><a href="Correctness_(computer_science)" title="wikilink">Correctness (computer science)</a></li>
<li><a href="Predicate_transformer_semantics#While_loop" title="wikilink"> Weakest-preconditions of While loop</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Formal_methods" title="wikilink">Category:Formal methods</a> <a href="Category:Control_flow" title="wikilink">Category:Control flow</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>

