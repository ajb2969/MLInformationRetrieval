   YDS algorithm      YDS algorithm   YDS is a scheduling algorithm for dynamic speed scaling processors which minimizes the total energy consumption. It was named after and developed by Yao et al. 1 There is both an online and an offline version of the algorithm.  Offline Algorithm  Definitions:   There is a set of n Jobs    J  :=    J  1   ,  …  ,   J  n       assign  J    subscript  J  1   normal-…   subscript  J  n      J:=J_{1},...,J_{n}   , where each job    J  i     subscript  J  i    J_{i}   has a release time    r  i     subscript  r  i    r_{i}   , deadline    d  i     subscript  d  i    d_{i}   and a processing volume    w  i     subscript  w  i    w_{i}   .     I   I   I   is a certain time interval.  Also we have     Δ  I   =    1   |  I  |      ∑    J  i   ∈   S  I      w  i          subscript  normal-Δ  I       1    I      subscript      subscript  J  i    subscript  S  I      subscript  w  i       \Delta_{I}=\frac{1}{|I|}\sum_{J_{i}\in S_{I}}w_{i}   , the work density in   I   I   I   .  And finally     S  I   ∈  J       subscript  S  I   J    S_{I}\in J   is the set of Jobs that that must be processed in   I   I   I   , that means Jobs with     [   r  i   ,   d  i   ]   ∈  I        subscript  r  i    subscript  d  i    I    [r_{i},d_{i}]\in I   .   The algorithm then works as follows: :While J \neq \{\} ::Determine the time interval I of maximum density \Delta_I .
 ::In I process the jobs of S_I at speed \Delta_I according to [[Earliest_deadline_first_scheduling|EDF]]
 ::Set J := J \setminus S_I . 
 ::Remove I from the time horizon and update the release times and deadlines of unscheduled jobs accordingly.
 :end While  In other terms it's a recursive algorithm that will follow these steps until all jobs are scheduled:   Calculate all intensities for all possible combinations of intervals. This means that for every start time and end time combination the intensity of work is calculated. For this the times of all jobs whose arrival time and deadline lie inside the interval are added and divided by the interval length. To speed up the process, only combinations of arrival times and later deadlines need to be considered, as times without arrival of a process or deadline can be shrunk to a smaller interval with the same processes, thus increasing intensity, and negative intervals are invalid. Then the maximum intensity interval is selected. In case of multiple equally intense intervals, one can be chosen at will, as intensities of non-overlapping intervals do not influence each other, and removing a part of an interval will not change the intensity of the rest, as processes are removed proportionally.  The processes inside this interval are scheduled using Earliest Deadline First, meaning that the job inside this interval whose deadline will arrive soonest is scheduled first, and so on. The jobs are executed at the above calculated intensity to fit all jobs inside the interval.  The interval is removed from the timeline, as no more calculations can be scheduled here. To simplify further calculations, all arrival times and deadlines of remaining jobs are recalculated to omit already occupied times. For example, assume a job   A   A   A   with arrival time     a  A   =  0       subscript  a  A   0    a_{A}=0   , deadline     d  A   =  10       subscript  d  A   10    d_{A}=10   and a workload     w  A   =  5       subscript  w  A   5    w_{A}=5   , and a job   B   B   B   with     a  B   =  5       subscript  a  B   5    a_{B}=5   ,     d  B   =  10       subscript  d  B   10    d_{B}=10   and     w  B   =  4       subscript  w  B   4    w_{B}=4   . Assume the previous interval was from time   3   3   3   to   8   8   8   . To omit this interval the times of   A   A   A   and   B   B   B   need to be adjusted; workloads are unaffected, as no work has been done for either   A   A   A   or   B   B   B   .    a  A     subscript  a  A    a_{A}   stays the same, as it's unaffected by later omissions.    d  A     subscript  d  A    d_{A}   , however, needs to be changed to   5   5   5   , as     10  -   (   8  -  3   )    =  5        10    8  3    5    10-(8-3)=5   . This is the time job   A   A   A   has left before its deadline. The arrival time    a  B     subscript  a  B    a_{B}   becomes   3   3   3   , as it would have been inside the removed interval.    d  B     subscript  d  B    d_{B}   also becomes   5   5   5   , as the time left after the removed interval is   2   2   2   . It is important, however, to remember the actual arrival and deadline times for later assembly of the scheduling.  Repeat steps 1-3 until all jobs have been scheduled.  Assemble jobs into final scheduling according to their allotted time intervals. Remember, though, that an interval may be split in two by another interval calculated earlier.   For any Job instance, the algorithm computes an optimal schedule minimizing the total energy consumption. 2  See also   EDF algorithm   References   "  Category:Real-time computing  Category:Processor scheduling algorithms     F.F. Yao, A.J. Demers and S. Shenker. A scheduling model for reduced CPU energy. Proc. 36th IEEE Symposium on Foundations of Computer Science , 374–382, 1995. ↩  Susanne Albers , "Algorithms for Dynamic Speed Scaling" ↩     