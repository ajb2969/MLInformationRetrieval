<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1830">Shape context</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Shape context</h1>
<hr/>

<p><strong>Shape context</strong> is a feature descriptor used in <a href="object_recognition" title="wikilink">object recognition</a>. <a href="Serge_Belongie" title="wikilink">Serge Belongie</a> and <a href="Jitendra_Malik" title="wikilink">Jitendra Malik</a> proposed the term in their paper "Matching with Shape Contexts" in 2000.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="theory">Theory</h2>

<p>The shape context is intended to be a way of describing shapes that allows for measuring shape similarity and the recovering of point correspondences.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The basic idea is to pick <em>n</em> points on the contours of a shape. For each point <em>p</em><sub><em>i</em></sub> on the shape, consider the <em>n</em> − 1 vectors obtained by connecting <em>p</em><sub><em>i</em></sub> to all other points. The set of all these vectors is a rich description of the shape localized at that point but is far too detailed. The key idea is that the distribution over relative positions is a robust, compact, and highly discriminative descriptor. So, for the point <em>p</em><sub><em>i</em></sub>, the coarse histogram of the relative coordinates of the remaining <em>n</em> − 1 points,</p>

<p>

<math display="block" id="Shape_context:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">#</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>q</mi>
      <mo>≠</mo>
      <msub>
       <mi>p</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo>:</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>q</mi>
        <mo>-</mo>
        <msub>
         <mi>p</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mrow>
       <mtext>bin</mtext>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>k</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>i</ci>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-#</ci>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <neq></neq>
       <ci>q</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <in></in>
       <apply>
        <minus></minus>
        <ci>q</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <mtext>bin</mtext>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{i}(k)=\#\{q\neq p_{i}:(q-p_{i})\in\mbox{bin}(k)\}
  </annotation>
 </semantics>
</math>

</p>

<p>is defined to be the shape context of 

<math display="inline" id="Shape_context:1">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}
  </annotation>
 </semantics>
</math>

. The bins are normally taken to be uniform in log-polar space. The fact that the shape context is a rich and discriminative descriptor can be seen in the figure below, in which the shape contexts of two different versions of the letter "A" are shown.</p>
<figure><b>(Figure)</b>
<figcaption>shapecontext.jpg</figcaption>
</figure>

<p>(a) and (b) are the sampled edge points of the two shapes. (c) is the diagram of the log-polar bins used to compute the shape context. (d) is the shape context for the point marked with a circle in (a), (e) is that for the point marked as a diamond in (b), and (f) is that for the triangle. As can be seen, since (d) and (e) are the shape contexts for two closely related points, they are quite similar, while the shape context in (f) is very different.</p>

<p>Now in order for a feature descriptor to be useful, it needs to have certain invariances. In particular it needs to be invariant to translation, scale, small perturbations, and depending on application rotation. Translational invariance come naturally to shape context. Scale invariance is obtained by normalizing all radial distances by the mean distance 

<math display="inline" id="Shape_context:2">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 between all the point pairs in the shape <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> although the median distance can also be used.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Shape contexts are empirically demonstrated to be robust to deformations, noise, and outliers<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> using synthetic point set matching experiments.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>One can provide complete rotation invariance in shape contexts. One way is to measure angles at each point relative to the direction of the tangent at that point (since the points are chosen on edges). This results in a completely rotationally invariant descriptor. But of course this is not always desired since some local features lose their discriminative power if not measured relative to the same frame. Many applications in fact forbid rotation invariance e.g. distinguishing a "6" from a "9".</p>
<h2 id="use-in-shape-matching">Use in shape matching</h2>

<p>A complete system that uses shape contexts for shape matching consists of the following steps (which will be covered in more detail in the <a href="#Details_of_implementation" title="wikilink">Details of Implementation</a> section):</p>
<ol>
<li>Randomly select a set of points that lie on the edges of a known shape and another set of points on an unknown shape.</li>
<li>Compute the shape context of each point found in step 1.</li>
<li>Match each point from the known shape to a point on an unknown shape. To minimize the cost of matching, first choose a transformation (e.g. <a href="affine_transformation" title="wikilink">affine</a>, <a href="thin_plate_spline" title="wikilink">thin plate spline</a>, etc.) that warps the edges of the known shape to the unknown (essentially aligning the two shapes). Then select the point on the unknown shape that most closely corresponds to each warped point on the known shape.</li>
<li>Calculate the "shape distance" between each pair of points on the two shapes. Use a weighted sum of the shape context distance, the image appearance distance, and the bending energy (a measure of how much transformation is required to bring the two shapes into alignment).</li>
<li>To identify the unknown shape, use a <a href="Nearest_neighbor_search" title="wikilink">nearest-neighbor classifier</a> to compare its shape distance to shape distances of known objects.</li>
</ol>
<h2 id="details-of-implementation">Details of implementation</h2>
<h3 id="step-1-finding-a-list-of-points-on-shape-edges">Step 1: Finding a list of points on shape edges</h3>

<p>The approach assumes that the shape of an object is essentially captured by a finite subset of the points on the internal or external contours on the object. These can be simply obtained using the <a href="Canny_edge_detector" title="wikilink">Canny edge detector</a> and picking a random set of points from the edges. Note that these points need not and in general do not correspond to key-points such as maxima of curvature or <a href="inflection_point" title="wikilink">inflection points</a>. It is preferable to sample the shape with roughly uniform spacing, though it is not critical.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h3 id="step-2-computing-the-shape-context">Step 2: Computing the shape context</h3>

<p>This step is described in detail in the <a href="#Theory" title="wikilink">Theory section</a>.</p>
<h3 id="step-3-computing-the-cost-matrix">Step 3: Computing the cost matrix</h3>

<p>Consider two points <em>p</em> and <em>q</em> that have normalized <em>K</em>-bin histograms (i.e. shape contexts) <em>g</em>(<em>k</em>) and <em>h</em>(<em>k</em>). As shape contexts are distributions represented as histograms, it is natural to use the <a href="chi-squared_statistic" title="wikilink"><em>χ</em><sup>2</sup> test statistic</a> as the "shape context cost" of matching the two points:</p>

<p>

<math display="block" id="Shape_context:3">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>S</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>K</mi>
     </munderover>
     <mfrac>
      <msup>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mrow>
          <mi>g</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>k</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>-</mo>
         <mrow>
          <mi>h</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>k</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mrow>
       <mrow>
        <mi>g</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>k</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>h</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>k</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>K</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <ci>g</ci>
           <ci>k</ci>
          </apply>
          <apply>
           <times></times>
           <ci>h</ci>
           <ci>k</ci>
          </apply>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>g</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <times></times>
         <ci>h</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{S}=\frac{1}{2}\sum_{k=1}^{K}\frac{[g(k)-h(k)]^{2}}{g(k)+h(k)}
  </annotation>
 </semantics>
</math>

</p>

<p>The values of this range from 0 to 1.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> In addition to the shape context cost, an extra cost based on the appearance can be added. For instance, it could be a measure of tangent angle dissimilarity (particularly useful in digit recognition):</p>

<p>

<math display="block" id="Shape_context:4">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>A</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mo>∥</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mrow>
          <mo>(</mo>
          <mtable columnspacing="0.4em" rowspacing="0.2ex">
           <mtr>
            <mtd>
             <mrow>
              <mi>cos</mi>
              <mrow>
               <mo stretchy="false">(</mo>
               <msub>
                <mi>θ</mi>
                <mn>1</mn>
               </msub>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
            </mtd>
           </mtr>
           <mtr>
            <mtd>
             <mrow>
              <mi>sin</mi>
              <mrow>
               <mo stretchy="false">(</mo>
               <msub>
                <mi>θ</mi>
                <mn>1</mn>
               </msub>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
            </mtd>
           </mtr>
          </mtable>
          <mo>)</mo>
         </mrow>
         <mo>-</mo>
         <mrow>
          <mo>(</mo>
          <mtable columnspacing="0.4em" rowspacing="0.2ex">
           <mtr>
            <mtd>
             <mrow>
              <mi>cos</mi>
              <mrow>
               <mo stretchy="false">(</mo>
               <msub>
                <mi>θ</mi>
                <mn>2</mn>
               </msub>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
            </mtd>
           </mtr>
           <mtr>
            <mtd>
             <mrow>
              <mi>sin</mi>
              <mrow>
               <mo stretchy="false">(</mo>
               <msub>
                <mi>θ</mi>
                <mn>2</mn>
               </msub>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
            </mtd>
           </mtr>
          </mtable>
          <mo>)</mo>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>∥</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <matrix>
       <matrixrow>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="latexml">binomial</csymbol>
          <apply>
           <cos></cos>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>θ</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <apply>
           <sin></sin>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>θ</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
         </apply>
         <apply>
          <csymbol cd="latexml">binomial</csymbol>
          <apply>
           <cos></cos>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>θ</ci>
            <cn type="integer">2</cn>
           </apply>
          </apply>
          <apply>
           <sin></sin>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>θ</ci>
            <cn type="integer">2</cn>
           </apply>
          </apply>
         </apply>
        </apply>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{A}=\frac{1}{2}\begin{Vmatrix}{\displaystyle\left({{\cos(\theta_{1})}\atop{%
\sin(\theta_{1})}}\right)}-{\displaystyle\left({{\cos(\theta_{2})}\atop{\sin(%
\theta_{2})}}\right)}\end{Vmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>This is half the length of the chord in unit circle between the unit vectors with angles 

<math display="inline" id="Shape_context:5">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Shape_context:6">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{2}
  </annotation>
 </semantics>
</math>

. Its values also range from 0 to 1. Now the total cost of matching the two points could be a weighted-sum of the two costs:</p>

<p>

<math display="block" id="Shape_context:7">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>β</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>C</mi>
      <mi>S</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>β</mi>
     <msub>
      <mi>C</mi>
      <mi>A</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>β</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>β</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=(1-\beta)C_{S}+\beta C_{A}\!\,
  </annotation>
 </semantics>
</math>

</p>

<p>Now for each point <em>p</em><sub><em>i</em></sub> on the first shape and a point <em>q</em><sub><em>j</em></sub> on the second shape, calculate the cost as described and call it <em>C</em><sub><em>i</em>,<em>j</em></sub>. This is the cost matrix.</p>
<h3 id="step-4-finding-the-matching-that-minimizes-total-cost">Step 4: Finding the matching that minimizes total cost</h3>

<p> Now, a one-to-one matching <em>p</em><sub><em>i</em></sub> that matches each point <em>p</em><sub><em>i</em></sub> on shape 1 and <em>q</em><sub><em>j</em></sub> on shape 2 that minimizes the total cost of matching,</p>

<p>

<math display="block" id="Shape_context:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>π</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <mi>C</mi>
     <mrow>
      <mo>(</mo>
      <msub>
       <mi>p</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>q</mi>
       <mrow>
        <mi>π</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>i</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </msub>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>π</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>C</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>q</ci>
        <apply>
         <times></times>
         <ci>π</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(\pi)=\sum_{i}C\left(p_{i},q_{\pi(i)}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>is needed. This can be done in 

<math display="inline" id="Shape_context:9">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>N</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>N</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(N^{3})
  </annotation>
 </semantics>
</math>

 time using the <a href="Hungarian_method" title="wikilink">Hungarian method</a>, although there are more efficient algorithms.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> To have robust handling of outliers, one can add "dummy" nodes that have a constant but reasonably large cost of matching to the cost matrix. This would cause the matching algorithm to match outliers to a "dummy" if there is no real match.</p>
<h3 id="step-5-modeling-transformation">Step 5: Modeling transformation</h3>

<p>Given the set of correspondences between a finite set of points on the two shapes, a transformation 

<math display="inline" id="Shape_context:10">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>ℝ</mi>
     <mn>2</mn>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>ℝ</mi>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>T</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T:\mathbb{R}^{2}\to\mathbb{R}^{2}
  </annotation>
 </semantics>
</math>

 can be estimated to map any point from one shape to the other. There are several choices for this transformation, described below.</p>
<h4 id="affine">Affine</h4>

<p>The <a href="Affine_transformation" title="wikilink">affine model</a> is a standard choice

<math display="block" id="Shape_context:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mi>p</mi>
    </mrow>
    <mo>+</mo>
    <mpadded width="-1.7pt">
     <mi>o</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>p</ci>
     </apply>
     <ci>o</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(p)=Ap+o\!
  </annotation>
 </semantics>
</math>

. The <a href="least_squares" title="wikilink">least squares</a> solution for the matrix 

<math display="inline" id="Shape_context:12">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and the translational offset vector <em>o</em> is obtained by:</p>

<p>

<math display="block" id="Shape_context:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>o</mi>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>n</mi>
     </mfrac>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <mo>(</mo>
       <mrow>
        <msub>
         <mi>p</mi>
         <mi>i</mi>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>q</mi>
         <mrow>
          <mi>π</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>i</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </msub>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>A</mi>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>Q</mi>
        <mo>+</mo>
       </msup>
       <mi>P</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>t</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>o</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>n</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>q</ci>
         <apply>
          <times></times>
          <ci>π</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Q</ci>
        <plus></plus>
       </apply>
       <ci>P</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o=\frac{1}{n}\sum_{i=1}^{n}\left(p_{i}-q_{\pi(i)}\right),A=(Q^{+}P)^{t}
  </annotation>
 </semantics>
</math>

</p>

<p>Where 

<math display="inline" id="Shape_context:14">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>p</mi>
        <mn>11</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>p</mi>
        <mn>12</mn>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>p</mi>
        <mrow>
         <mi>n</mi>
         <mn>1</mn>
        </mrow>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>p</mi>
        <mrow>
         <mi>n</mi>
         <mn>2</mn>
        </mrow>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">11</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">12</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <ci>normal-⋮</ci>
      <ci>normal-⋮</ci>
      <ci>normal-⋮</ci>
     </matrixrow>
     <matrixrow>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <apply>
        <times></times>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <apply>
        <times></times>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=\begin{pmatrix}1&p_{11}&p_{12}\\
\vdots&\vdots&\vdots\\
1&p_{n1}&p_{n2}\end{pmatrix}
  </annotation>
 </semantics>
</math>

 with a similar expression for 

<math display="inline" id="Shape_context:15">
 <semantics>
  <mpadded width="-1.7pt">
   <mi>Q</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q\!
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Shape_context:16">
 <semantics>
  <mpadded width="-1.7pt">
   <msup>
    <mi>Q</mi>
    <mo>+</mo>
   </msup>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>Q</ci>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q^{+}\!
  </annotation>
 </semantics>
</math>

 is the <a href="Moore-Penrose_pseudoinverse" title="wikilink">pseudoinverse</a> of 

<math display="inline" id="Shape_context:17">
 <semantics>
  <mpadded width="-1.7pt">
   <mi>Q</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q\!
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="thin-plate-spline">Thin plate spline</h4>

<p>The <a href="Thin_plate_spline" title="wikilink">thin plate spline (TPS)</a> model is the most widely used model for transformations when working with shape contexts. A 2D transformation can be separated into two TPS function to model a coordinate transform:</p>

<p>

<math display="block" id="Shape_context:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>x</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>y</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <interval closure="open">
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>y</ci>
      </apply>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(x,y)=\left(f_{x}(x,y),f_{y}(x,y)\right)
  </annotation>
 </semantics>
</math>

</p>

<p>where each of the <em>ƒ</em><sub><em>x</em></sub> and <em>ƒ</em><sub><em>y</em></sub> have the form:</p>

<p>

<math display="block" id="Shape_context:19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>x</mi>
      </msub>
      <mi>x</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>y</mi>
      </msub>
      <mi>y</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>ω</mi>
        <mi>i</mi>
       </msub>
       <mi>U</mi>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mo>∥</mo>
         <mtable displaystyle="true">
          <mtr>
           <mtd columnalign="center">
            <mrow>
             <mrow>
              <mo stretchy="false">(</mo>
              <msub>
               <mi>x</mi>
               <mi>i</mi>
              </msub>
              <mo>,</mo>
              <msub>
               <mi>y</mi>
               <mi>i</mi>
              </msub>
              <mo stretchy="false">)</mo>
             </mrow>
             <mo>-</mo>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>x</mi>
              <mo>,</mo>
              <mi>y</mi>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
           </mtd>
          </mtr>
         </mtable>
         <mo>∥</mo>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>x</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>y</ci>
      </apply>
      <ci>y</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>i</ci>
       </apply>
       <ci>U</ci>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <matrix>
         <matrixrow>
          <apply>
           <minus></minus>
           <interval closure="open">
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <ci>i</ci>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>y</ci>
             <ci>i</ci>
            </apply>
           </interval>
           <interval closure="open">
            <ci>x</ci>
            <ci>y</ci>
           </interval>
          </apply>
         </matrixrow>
        </matrix>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)=a_{1}+a_{x}x+a_{y}y+\sum_{i=1}^{n}\omega_{i}U\left(\begin{Vmatrix}(x_{i%
},y_{i})-(x,y)\end{Vmatrix}\right),
  </annotation>
 </semantics>
</math>

</p>

<p>and the kernel function 

<math display="inline" id="Shape_context:20">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo rspace="0.8pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(r)\!
  </annotation>
 </semantics>
</math>

 is defined by 

<math display="inline" id="Shape_context:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>r</mi>
     <mn>2</mn>
    </msup>
    <mrow>
     <mi>log</mi>
     <mpadded width="-1.7pt">
      <msup>
       <mi>r</mi>
       <mn>2</mn>
      </msup>
     </mpadded>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>U</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>r</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <log></log>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>r</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(r)=r^{2}\log r^{2}\!
  </annotation>
 </semantics>
</math>

. The exact details of how to solve for the parameters can be found elsewhere<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> but it essentially involves solving a <a href="System_of_linear_equations" title="wikilink">linear system of equations</a>. The bending energy (a measure of how much transformation is needed to align the points) will also be easily obtained.</p>
<h4 id="regularized-tps">Regularized TPS</h4>

<p>The TPS formulation above has exact matching requirement for the pairs of points on the two shapes. For noisy data, it is best to relax this exact requirement. If we let 

<math display="inline" id="Shape_context:22">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

 denote the target function values at corresponding locations 

<math display="inline" id="Shape_context:23">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>i</ci>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}=(x_{i},y_{i})
  </annotation>
 </semantics>
</math>

 (Note that for 

<math display="inline" id="Shape_context:24">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{x}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Shape_context:25">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

 would 

<math display="inline" id="Shape_context:26">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

 the x-coordinate of the point corresponding to 

<math display="inline" id="Shape_context:27">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}
  </annotation>
 </semantics>
</math>

 and for 

<math display="inline" id="Shape_context:28">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>y</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{y}
  </annotation>
 </semantics>
</math>

 it would be the y-coordinate, 

<math display="inline" id="Shape_context:29">
 <semantics>
  <msup>
   <mi>y</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>y</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}
  </annotation>
 </semantics>
</math>

), relaxing the requirement amounts to minimizing</p>

<p>

<math display="block" id="Shape_context:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>f</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>v</mi>
         <mi>i</mi>
        </msub>
        <mo>-</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mi>i</mi>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>y</mi>
           <mi>i</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>λ</mi>
     <msub>
      <mi>I</mi>
      <mi>f</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>i</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>i</ci>
          </apply>
         </interval>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H[f]=\sum_{i=1}^{n}(v_{i}-f(x_{i},y_{i}))^{2}+\lambda I_{f}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Shape_context:31">
 <semantics>
  <mpadded width="-1.7pt">
   <msub>
    <mi>I</mi>
    <mi>f</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{f}\!
  </annotation>
 </semantics>
</math>

 is the bending energy and 

<math display="inline" id="Shape_context:32">
 <semantics>
  <mpadded width="-1.7pt">
   <mi>λ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\!
  </annotation>
 </semantics>
</math>

 is called the regularization parameter. This <em>ƒ</em> that minimizes <em>H</em>[<em>ƒ</em>] can be found in a fairly straightforward way.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> If one uses normalize coordinates for 

<math display="inline" id="Shape_context:33">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mtext>and</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>x</mi>
     <mi>i</mi>
     <mo>′</mo>
    </msubsup>
    <mo>,</mo>
    <msubsup>
     <mi>y</mi>
     <mi>i</mi>
     <mo>′</mo>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
    </interval>
    <mtext>and</mtext>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>i</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{i},y_{i})\mbox{ and }(x^{\prime}_{i},y^{\prime}_{i})
  </annotation>
 </semantics>
</math>

, then scale invariance is kept. However, if one uses the original non-normalized coordinates, then the regularization parameter needs to be normalized.</p>

<p>Note that in many cases, regardless of the transformation used, the initial estimate of the correspondences contains some errors which could reduce the quality of the transformation. If we iterate the steps of finding correspondences and estimating transformations (i.e. repeating steps 2–5 with the newly transformed shape) we can overcome this problem. Typically, three iterations are all that is needed to obtain reasonable results.</p>
<h3 id="step-6-computing-the-shape-distance">Step 6: Computing the shape distance</h3>

<p>Now, a shape distance between two shapes 

<math display="inline" id="Shape_context:34">
 <semantics>
  <mpadded width="-1.7pt">
   <mi>P</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\!
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Shape_context:35">
 <semantics>
  <mpadded width="-1.7pt">
   <mi>Q</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q\!
  </annotation>
 </semantics>
</math>

. This distance is going to be a weighted sum of three potential terms:</p>

<p><strong>Shape context distance</strong>: this is the symmetric sum of shape context matching costs over best matching points:</p>

<p>

<math display="block" id="Shape_context:36">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>D</mi>
     <mrow>
      <mi>s</mi>
      <mi>c</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>P</mi>
     <mo>,</mo>
     <mi>Q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>n</mi>
     </mfrac>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>p</mi>
        <mo>∈</mo>
        <mi>P</mi>
       </mrow>
      </munder>
      <mrow>
       <mrow>
        <mi>arg</mi>
        <mrow>
         <munder accentunder="true">
          <mi>min</mi>
          <mrow>
           <mi>q</mi>
           <mo>∈</mo>
           <mi>Q</mi>
          </mrow>
         </munder>
         <mi>C</mi>
        </mrow>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>p</mi>
        <mo>,</mo>
        <mrow>
         <mi>T</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>q</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>m</mi>
     </mfrac>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>q</mi>
        <mo>∈</mo>
        <mi>Q</mi>
       </mrow>
      </munder>
      <mrow>
       <mrow>
        <mi>arg</mi>
        <mrow>
         <munder accentunder="true">
          <mi>min</mi>
          <mrow>
           <mi>p</mi>
           <mo>∈</mo>
           <mi>P</mi>
          </mrow>
         </munder>
         <mi>C</mi>
        </mrow>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>p</mi>
        <mo>,</mo>
        <mrow>
         <mi>T</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>q</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>c</ci>
      </apply>
     </apply>
     <interval closure="open">
      <ci>P</ci>
      <ci>Q</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>n</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <in></in>
         <ci>p</ci>
         <ci>P</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <arg></arg>
         <apply>
          <times></times>
          <apply>
           <apply>
            <in></in>
            <ci>q</ci>
            <ci>Q</ci>
           </apply>
           <min></min>
          </apply>
          <ci>C</ci>
         </apply>
        </apply>
        <interval closure="open">
         <ci>p</ci>
         <apply>
          <times></times>
          <ci>T</ci>
          <ci>q</ci>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>m</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <in></in>
         <ci>q</ci>
         <ci>Q</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <arg></arg>
         <apply>
          <times></times>
          <apply>
           <apply>
            <in></in>
            <ci>p</ci>
            <ci>P</ci>
           </apply>
           <min></min>
          </apply>
          <ci>C</ci>
         </apply>
        </apply>
        <interval closure="open">
         <ci>p</ci>
         <apply>
          <times></times>
          <ci>T</ci>
          <ci>q</ci>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{sc}(P,Q)=\frac{1}{n}\sum_{p\in P}\arg\underset{q\in Q}{\min}C(p,T(q))+\frac%
{1}{m}\sum_{q\in Q}\arg\underset{p\in P}{\min}C(p,T(q))
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>T</em>(·) is the estimated TPS transform that maps the points in <em>Q</em> to those in <em>P</em>.</p>

<p><strong>Appearance cost</strong>: After establishing image correspondences and properly warping one image to match the other, one can define an appearance cost as the sum of squared brightness differences in <a href="Gaussian_filter" title="wikilink">Gaussian windows</a> around corresponding image points:</p>

<p>

<math display="block" id="Shape_context:37">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>D</mi>
     <mrow>
      <mi>a</mi>
      <mi>c</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>P</mi>
     <mo>,</mo>
     <mi>Q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>n</mi>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi mathvariant="normal">Δ</mi>
        <mo>∈</mo>
        <msup>
         <mi>Z</mi>
         <mn>2</mn>
        </msup>
       </mrow>
      </munder>
      <mrow>
       <mi>G</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi mathvariant="normal">Δ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <msup>
        <mrow>
         <mo>[</mo>
         <mrow>
          <mrow>
           <msub>
            <mi>I</mi>
            <mi>P</mi>
           </msub>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <msub>
              <mi>p</mi>
              <mi>i</mi>
             </msub>
             <mo>+</mo>
             <mi mathvariant="normal">Δ</mi>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>-</mo>
          <mrow>
           <msub>
            <mi>I</mi>
            <mi>Q</mi>
           </msub>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mrow>
              <mi>T</mi>
              <mrow>
               <mo stretchy="false">(</mo>
               <msub>
                <mi>q</mi>
                <mrow>
                 <mi>π</mi>
                 <mrow>
                  <mo stretchy="false">(</mo>
                  <mi>i</mi>
                  <mo stretchy="false">)</mo>
                 </mrow>
                </mrow>
               </msub>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
             <mo>+</mo>
             <mi mathvariant="normal">Δ</mi>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo>]</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>c</ci>
      </apply>
     </apply>
     <interval closure="open">
      <ci>P</ci>
      <ci>Q</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <in></in>
         <ci>normal-Δ</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>Z</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>G</ci>
        <ci>normal-Δ</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <minus></minus>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>I</ci>
             <ci>P</ci>
            </apply>
            <apply>
             <plus></plus>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>p</ci>
              <ci>i</ci>
             </apply>
             <ci>normal-Δ</ci>
            </apply>
           </apply>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>I</ci>
             <ci>Q</ci>
            </apply>
            <apply>
             <plus></plus>
             <apply>
              <times></times>
              <ci>T</ci>
              <apply>
               <csymbol cd="ambiguous">subscript</csymbol>
               <ci>q</ci>
               <apply>
                <times></times>
                <ci>π</ci>
                <ci>i</ci>
               </apply>
              </apply>
             </apply>
             <ci>normal-Δ</ci>
            </apply>
           </apply>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{ac}(P,Q)=\frac{1}{n}\sum_{i=1}^{n}\sum_{\Delta\in Z^{2}}G(\Delta)\left[I_{P%
}(p_{i}+\Delta)-I_{Q}(T(q_{\pi(i)})+\Delta)\right]^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Shape_context:38">
 <semantics>
  <mpadded width="-1.7pt">
   <msub>
    <mi>I</mi>
    <mi>P</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{P}\!
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Shape_context:39">
 <semantics>
  <mpadded width="-1.7pt">
   <msub>
    <mi>I</mi>
    <mi>Q</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{Q}\!
  </annotation>
 </semantics>
</math>

 are the gray-level images (

<math display="inline" id="Shape_context:40">
 <semantics>
  <mpadded width="-1.7pt">
   <msub>
    <mi>I</mi>
    <mi>Q</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{Q}\!
  </annotation>
 </semantics>
</math>

 is the image after warping) and 

<math display="inline" id="Shape_context:41">
 <semantics>
  <mpadded width="-1.7pt">
   <mi>G</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\!
  </annotation>
 </semantics>
</math>

 is a Gaussian windowing function.</p>

<p><strong>Transformation cost</strong>: The final cost 

<math display="inline" id="Shape_context:42">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mrow>
     <mi>b</mi>
     <mi>e</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo>,</mo>
    <mi>Q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <apply>
      <times></times>
      <ci>b</ci>
      <ci>e</ci>
     </apply>
    </apply>
    <interval closure="open">
     <ci>P</ci>
     <ci>Q</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{be}(P,Q)\!\,
  </annotation>
 </semantics>
</math>

 measures how much transformation is necessary to bring the two images into alignment. In the case of TPS, it is assigned to be the bending energy.</p>

<p>Now that we have a way of calculating the distance between two shapes, we can use a <a href="k-nearest_neighbor_algorithm" title="wikilink">nearest neighbor</a> <a href="Classifier_(mathematics)" title="wikilink">classifier</a> (k-NN) with distance defined as the shape distance calculated here. The results of applying this to different situations is given in the following section.</p>
<h2 id="results">Results</h2>
<h3 id="digit-recognition">Digit recognition</h3>

<p>The authors <a href="Serge_Belongie" title="wikilink">Serge Belongie</a> and <a href="Jitendra_Malik" title="wikilink">Jitendra Malik</a> tested their approach on the <a href="MNIST_database" title="wikilink">MNIST database</a>. Currently, more than 50 algorithms have been tested on the database. The database has a training set of 60,000 examples, and a test set of 10,000 examples. The error rate for this approach was 0.63% using 20,000 training examples and 3-NN. At the time of publication, this error rate was the lowest. Currently, the lowest error rate is 0.23%.</p>
<h3 id="silhouette-similarity-based-retrieval">Silhouette similarity-based retrieval</h3>

<p>The authors experimented with the MPEG-7 shape silhouette database, performing Core Experiment CE-Shape-1 part B, which measures performance of similarity-based retrieval.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> The database has 70 shape categories and 20 images per shape category. Performance of a retrieval scheme is tested by using each image as a query and counting the number of correct images in the top 40 matches. For this experiment, the authors increased the amount of points sampled from each shape. Also, since the shapes in the database sometimes were rotated or flipped, the authors took defined the distance between a reference shape and query shape to be minimum shape distance between the query shape and either the unchanged reference, the vertically flipped, or the reference horizontally flipped.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> With these changes, they obtained a retrieval rate of 76.45%, which by 2002 was the best.</p>
<h3 id="d-object-recognition">3D object recognition</h3>

<p>The next experiment performed on shape contexts involved the 20 common household objects in the <a href="http://www1.cs.columbia.edu/CAVE/software/softlib/coil-20.php">Columbia Object Image Library (COIL-20)</a>. Each object has 72 views in the database. In the experiment, the method was trained on a number of equally spaced views for each object and the remaining views were used for testing. A 1-NN classifier was used. The authors also developed an <em>editing</em> algorithm based on shape context similarity and <a class="uri" href="k-medoid" title="wikilink">k-medoid</a> clustering that improved on their performance.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h3 id="trademark-retrieval">Trademark retrieval</h3>

<p>Shape contexts were used to retrieve the closest matching trademarks from a database to a query trademark (useful in detecting trademark infringement). No visually similar trademark was missed by the algorithm (verified manually by the authors).<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.eecs.berkeley.edu/Research/Projects/CS/vision/shape/sc_digits.html">Matching with Shape Contexts</a></li>
<li><a href="http://yann.lecun.com/exdb/mnist/">MNIST database of handwritten digits</a></li>
<li><a href="http://www1.cs.columbia.edu/CAVE/software/softlib/coil-20.php">Columbia Object Image Library (COIL-20)</a></li>
<li><a href="http://www.vision.caltech.edu/Image_Datasets/Caltech101/">Caltech101 Database</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Computer_vision" title="wikilink">Category:Computer vision</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
</ol>
</section>
</body>
</html>
