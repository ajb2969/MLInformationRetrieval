<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1184">SP-DEVS</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>SP-DEVS</h1>
<hr/>

<p><strong>SP-DEVS</strong> abbreviating "Schedule-Preserving Discrete Event System Specification" is a formalism for modeling and analyzing discrete event systems in both simulation and verification ways. SP-DEVS also provides modular and hierarchical modeling features which have been inherited from the Classic <a class="uri" href="DEVS" title="wikilink">DEVS</a>.</p>
<h2 id="history">History</h2>

<p>SP-DEVS has been designed to support verification analysis of its networks by guaranting to obtain a finite-vertex reachability graph of the original networks, which had been an open problem of DEVS formalism for roughly 30 years. To get such a reachability graph of its networks, SP-DEVS has been imposed the three restrictions:</p>
<ol>
<li>finiteness of event sets and state set,</li>
<li>the lifespan of a state can be scheduled by a rational number or infinity, and</li>
<li>preserving the internal schedule from any external events.</li>
</ol>

<p>Thus, SP-DEVS is a sub-class of both <a class="uri" href="DEVS" title="wikilink">DEVS</a> and <a class="uri" href="FD-DEVS" title="wikilink">FD-DEVS</a>. These three restrictions lead that SP-DEVS class is closed under coupling even though the number of states are finite. This property enables a finite-vertex graph-based verification for some qualitative properties and quantitative property, even with SP-DEVS coupled models.</p>
<h2 id="crosswalk-controller-example">Crosswalk Controller Example</h2>
<dl>
<dt>System Requirements</dt>
</dl>

<p>Let's consider a crosswalk system. Since a red light (resp. don't-walk light) behaves the opposite way of a green light (resp. walk light), for simplicity, we consider just two lights: a green light (G) and a walk light (W); and one push button as shown in Fig. 1. We want to control two lights of G and W with a set of timing constraints.</p>

<p>To initialize two lights, it takes 0.5 seconds to turn G on and 0.5 seconds later, W gets off. Then, every 30 seconds, there is a chance that G becomes off and W on if someone pushed the push button. For a safety reason, W becomes on two seconds after G got off. 26 seconds later, W gets off and then two seconds later G gets back on. These behaviors repeats.</p>
<dl>
<dt>Controller Design</dt>
</dl>

<p>To build a controller for above requirements, we can consider one input event 'push-button' (abbreviated by ?p) and four output events 'green-on' (!g:1), 'green-off' (!g:0), 'walk-on' (!w:1) and 'walk-off (!w:0) which will be used as commands signals for the green light and the walk light. As a set of states of the controller, we considers 'booting-green' (BG), 'booting-walk' (BW), 'green-on' (G), 'green-to-red' (GR), 'red-on' (R), 'walk-on' (W), 'delay' (D). Let's design the state transitions as shown in Fig. 2. Initially, the controller starts at BG whose lifespan is 0.5 seconds. After the lifespan, it moves to BW state at this moment, it generates the 'green-on' event, too. After 0.5 seconds staying at BW, it moves to G state whose lifespan is 30 seconds. The controller can keep staying at G by looping G to G without generating any output event or can move to GR state when it receives the external input event ?p. But, the <em>actual staying time</em> at GR is the remaining time for looping at G. From GR, it moves to R state with generating an output event !g:0 and its R state last two seconds then it will move to W state with output event !w:1. 26 seconds later, it moves to D state with generating !w:0 and after staying 2 seconds at D, it moves back to G with output event !g:1.</p>
<h2 id="atomic-sp-devs">Atomic SP-DEVS</h2>
<h3 id="formal-definition">Formal Definition</h3>

<p>The above controller for crosswalk lights can be modeled by an atomic SP-DEVS model. Formally, an atomic SP-DEVS is a 7-<a class="uri" href="tuple" title="wikilink">tuple</a></p>
<center>

<p>

<math display="inline" id="SP-DEVS:0">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

</p>
</center>

<p>where</p>
<blockquote>
<ul>
<li>

<math display="inline" id="SP-DEVS:1">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 is <em>a finite set of input events</em>;</li>
<li>

<math display="inline" id="SP-DEVS:2">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is <em>a finite set of output events</em>;</li>
<li>

<math display="inline" id="SP-DEVS:3">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mn>0</mn>
   </msub>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{0}\in S
  </annotation>
 </semantics>
</math>

 is <em>a finite set of states</em>;</li>
<li>

<math display="inline" id="SP-DEVS:4">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mo>:</mo>
   <mrow>
    <mi>S</mi>
    <mo>→</mo>
    <msub>
     <mi>ℚ</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mi mathvariant="normal">∞</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>τ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>S</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℚ</ci>
      <interval closure="closed">
       <cn type="integer">0</cn>
       <infinity></infinity>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau:S\rightarrow\mathbb{Q}_{[0,\infty]}
  </annotation>
 </semantics>
</math>

 is <em>the initial state</em>;</li>
<li>

<math display="inline" id="SP-DEVS:5">
 <semantics>
  <msub>
   <mi>ℚ</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">∞</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ℚ</ci>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <infinity></infinity>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Q}_{[0,\infty]}
  </annotation>
 </semantics>
</math>

 is <em>the time advanced function</em> which defines the lifespan of a state where 

<math display="inline" id="SP-DEVS:6">
 <semantics>
  <mrow>
   <msub>
    <mi>δ</mi>
    <mi>x</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mo>×</mo>
     <mi>X</mi>
    </mrow>
    <mo>→</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>δ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>X</ci>
     </apply>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{x}:S\times X\rightarrow S
  </annotation>
 </semantics>
</math>

 is the set of non-negative rational numbers plus infinity.</li>
<li>

<math display="inline" id="SP-DEVS:7">
 <semantics>
  <mrow>
   <msub>
    <mi>δ</mi>
    <mi>y</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi>S</mi>
    <mo>→</mo>
    <mrow>
     <msup>
      <mi>Y</mi>
      <mi>ϕ</mi>
     </msup>
     <mo>×</mo>
     <mi>S</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>δ</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>S</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Y</ci>
       <ci>ϕ</ci>
      </apply>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{y}:S\rightarrow Y^{\phi}\times S
  </annotation>
 </semantics>
</math>

 is <em>the external transition function</em> which defines how an input event changes a state of the system.</li>
<li>

<math display="inline" id="SP-DEVS:8">
 <semantics>
  <mrow>
   <msup>
    <mi>Y</mi>
    <mi>ϕ</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>Y</mi>
    <mo>∪</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>ϕ</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Y</ci>
     <ci>ϕ</ci>
    </apply>
    <apply>
     <union></union>
     <ci>Y</ci>
     <set>
      <ci>ϕ</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y^{\phi}=Y\cup\{\phi\}
  </annotation>
 </semantics>
</math>

 is <em>the output and internal transition function</em> where 

<math display="inline" id="SP-DEVS:9">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>∉</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>ϕ</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\notin Y
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="SP-DEVS:10">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 denotes <em>the silent event</em>. The output and internal transition function defines how a state generates an output event, at the same time, how the state changes internally.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></li>
</ul>
</blockquote>
<dl>
<dt>Formal Representation of Crosswalk Controller</dt>
</dl>

<p>The above controller shown in Fig. 2 can be written as 

<math display="inline" id="SP-DEVS:11">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="SP-DEVS:12">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

={?p}; 

<math display="inline" id="SP-DEVS:13">
 <semantics>
  <msub>
   <mi>s</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{0}
  </annotation>
 </semantics>
</math>

={!g:0, !g:1, !w:0, !w:1}; 

<math display="inline" id="SP-DEVS:14">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

={BG, BW, G, GR, R, W, D}; 

<math display="inline" id="SP-DEVS:15">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

=BG, 

<math display="inline" id="SP-DEVS:16">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

(BG)=0.5,

<math display="inline" id="SP-DEVS:17">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

(BW)=0.5, 

<math display="inline" id="SP-DEVS:18">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

(G)=30, 

<math display="inline" id="SP-DEVS:19">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

(GR)=30,

<math display="inline" id="SP-DEVS:20">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

(R)=2, 

<math display="inline" id="SP-DEVS:21">
 <semantics>
  <msub>
   <mi>δ</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>δ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{x}
  </annotation>
 </semantics>
</math>

(W)=26, 

<math display="inline" id="SP-DEVS:22">
 <semantics>
  <msub>
   <mi>δ</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>δ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{x}
  </annotation>
 </semantics>
</math>

(D)=2; 

<math display="inline" id="SP-DEVS:23">
 <semantics>
  <mo>≠</mo>
  <annotation-xml encoding="MathML-Content">
   <neq></neq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neq
  </annotation>
 </semantics>
</math>

(G,?p)=GR, 

<math display="inline" id="SP-DEVS:24">
 <semantics>
  <msub>
   <mi>δ</mi>
   <mi>y</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>δ</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{y}
  </annotation>
 </semantics>
</math>

(s,?p)=s if s 

<math display="inline" id="SP-DEVS:25">
 <semantics>
  <msub>
   <mi>δ</mi>
   <mi>y</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>δ</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{y}
  </annotation>
 </semantics>
</math>

G; 

<math display="inline" id="SP-DEVS:26">
 <semantics>
  <msub>
   <mi>δ</mi>
   <mi>y</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>δ</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{y}
  </annotation>
 </semantics>
</math>

(BG)=(!g:1, BW), 

<math display="inline" id="SP-DEVS:27">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

(BW)=(!w:0, G),

<math display="inline" id="SP-DEVS:28">
 <semantics>
  <msub>
   <mi>δ</mi>
   <mi>y</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>δ</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{y}
  </annotation>
 </semantics>
</math>

(G)=(

<math display="inline" id="SP-DEVS:29">
 <semantics>
  <msub>
   <mi>δ</mi>
   <mi>y</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>δ</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{y}
  </annotation>
 </semantics>
</math>

, G), 

<math display="inline" id="SP-DEVS:30">
 <semantics>
  <msub>
   <mi>δ</mi>
   <mi>y</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>δ</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{y}
  </annotation>
 </semantics>
</math>

(GR)=(!g:0, R), 

<math display="inline" id="SP-DEVS:31">
 <semantics>
  <msub>
   <mi>δ</mi>
   <mi>y</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>δ</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{y}
  </annotation>
 </semantics>
</math>

(R)=(!w:1, W), 

<math display="inline" id="SP-DEVS:32">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mi>s</mi>
   </msub>
   <mo>∈</mo>
   <msub>
    <mi>ℚ</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mi mathvariant="normal">∞</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℚ</ci>
     <interval closure="closed">
      <cn type="integer">0</cn>
      <infinity></infinity>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{s}\in\mathbb{Q}_{[0,\infty]}
  </annotation>
 </semantics>
</math>

(W)=(!w:0, D), 

<math display="inline" id="SP-DEVS:33">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mi>e</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">∞</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>e</ci>
    </apply>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <infinity></infinity>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{e}\in[0,\infty]
  </annotation>
 </semantics>
</math>

(D)=(!g:1, G);</p>
<h3 id="behaviors-of-a-sp-devs-model">Behaviors of a SP-DEVS model</h3>

<p> To captured the dynamics of an atomic SP-DEVS, we need to introduce two variables associated to time. One is the <em>lifespan</em>, the other is the <em>elapsed time</em> since the last resetting. Let 

<math display="inline" id="SP-DEVS:34">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in S
  </annotation>
 </semantics>
</math>

 be the lifespan which is not continuously increasing but set by when a discrete event happens. Let 

<math display="inline" id="SP-DEVS:35">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>s</mi>
   <mo>,</mo>
   <msub>
    <mi>t</mi>
    <mi>s</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>t</mi>
    <mi>e</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>s</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>e</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s,t_{s},t_{e})
  </annotation>
 </semantics>
</math>

 denote the elapsed time which is continuously increasing over time if there is no resetting.</p>

<p>Fig.3. shows a state trajectory associated with an event segment of the SP-DEVS model shown in Fig. 2. The top of Fig.3. shows an event trajectory in which the horizontal axis is a time axis so it shows an event occurs at a certain time, for example, !g:1 occurs at 0.5 and !w:0 at 1.0 time unit, and so on. The bottom of Fig. 3 shows the state trajectory associated with the above event segment in which the state 

<math display="inline" id="SP-DEVS:36">
 <semantics>
  <msub>
   <mi>t</mi>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{e}
  </annotation>
 </semantics>
</math>

 is associated with its lifespan and its elapsed time in the form of 

<math display="inline" id="SP-DEVS:37">
 <semantics>
  <msub>
   <mi>t</mi>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{e}
  </annotation>
 </semantics>
</math>

. For example, (G, 30, 11) denotes that the state is G, its lifespan is and the elapsed time is 11 time units. The line sgements of the buttom of Fig. 3 shows the time flow of the elapsed time which is the only one continuous variable in SP-DEVS.</p>

<p>One interesting feature of SF-DEVS might be the preservation of schedule the restriction (3) of SP-DEVS which is drawn at time 47 in Fig. 3. when the external event ?p happens. At this moment, even though the state can change from G to GR, the elapsed time does not change so the line segment is not broken at time 47 and 

<math display="inline" id="SP-DEVS:38">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>,</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>X</ci>
    <ci>Y</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X,Y
  </annotation>
 </semantics>
</math>

 can grow up to 

<math display="inline" id="SP-DEVS:39">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℳ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℳ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{M}
  </annotation>
 </semantics>
</math>

 which is 30 in this example. Due to this preservation of the schedule from input events as well as the restriction of the time advance to the non-negative rational number (see restriction (2) above), the height of every saw can be a non-negative rational number or infinity (as shown in the bottom of Fig. 3.) in a SP-DEVS model.</p>
<dl>
<dt>SP-DEVS is a sub-class of DEVS</dt>
</dl>

<p>A SP-DEVS model, 

<math display="inline" id="SP-DEVS:40">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is <a class="uri" href="DEVS" title="wikilink">DEVS</a> 

<math display="inline" id="SP-DEVS:41">
 <semantics>
  <mrow>
   <msup>
    <mi>S</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo>,</mo>
     <msub>
      <mi>t</mi>
      <mi>s</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mi>s</mi>
      <mo>∈</mo>
      <mi>S</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>t</mi>
       <mi>s</mi>
      </msub>
      <mo>∈</mo>
      <msup>
       <mi>𝕋</mi>
       <mi mathvariant="normal">∞</mi>
      </msup>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <interval closure="open">
      <ci>s</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>s</ci>
      </apply>
     </interval>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <in></in>
       <ci>s</ci>
       <ci>S</ci>
      </apply>
      <apply>
       <in></in>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>s</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝕋</ci>
        <infinity></infinity>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{\prime}=\{(s,t_{s}):s\in S,t_{s}\in\mathbb{T}^{\infty}\}
  </annotation>
 </semantics>
</math>

 where</p>
<ul>
<li>

<math display="inline" id="SP-DEVS:42">
 <semantics>
  <mrow>
   <msubsup>
    <mi>s</mi>
    <mn>0</mn>
    <mo>′</mo>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>s</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <mrow>
     <mi>τ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>s</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-′</ci>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <ci>τ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{0}^{\prime}=(s_{0},\tau(s_{0}))
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="SP-DEVS:43">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <msub>
     <mi>t</mi>
     <mi>s</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>S</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>s</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>s</ci>
     </apply>
    </interval>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s,t_{s})\in S^{\prime}
  </annotation>
 </semantics>
</math>

 are the same as those of 

<math display="inline" id="SP-DEVS:44">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>t</mi>
     <mi>a</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo>,</mo>
      <msub>
       <mi>t</mi>
       <mi>s</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>t</mi>
     <mi>s</mi>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>a</ci>
     <interval closure="open">
      <ci>s</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>s</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ta(s,t_{s})=t_{s}.
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="SP-DEVS:45">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <msub>
     <mi>t</mi>
     <mi>s</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>S</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>s</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>s</ci>
     </apply>
    </interval>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s,t_{s})\in S^{\prime}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="SP-DEVS:46">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <msub>
     <mi>t</mi>
     <mi>s</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>S</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>s</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>s</ci>
     </apply>
    </interval>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s,t_{s})\in S^{\prime}
  </annotation>
 </semantics>
</math>

</li>
<li>Given a state 

<math display="inline" id="SP-DEVS:47">
 <semantics>
  <mrow>
   <msub>
    <mi>δ</mi>
    <mrow>
     <mi>i</mi>
     <mi>n</mi>
     <mi>t</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <msub>
     <mi>t</mi>
     <mi>s</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <mi>τ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>s</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>δ</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>n</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>s</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="unknown">τ</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{int}(s,t_{s})=(s^{\prime},\tau(s^{\prime})
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="SP-DEVS:48">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>δ</mi>
      <mi>y</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>,</mo>
     <msup>
      <mi>s</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <ci>y</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <interval closure="open">
     <ci>y</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{y}(s)=(y,s^{\prime}).
  </annotation>
 </semantics>
</math>

</li>
<li>Given a state 

<math display="inline" id="SP-DEVS:49">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <msub>
     <mi>t</mi>
     <mi>s</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>S</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>s</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>s</ci>
     </apply>
    </interval>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s,t_{s})\in S^{\prime}
  </annotation>
 </semantics>
</math>

 and an input event <math> x \in X, \delta_{ext}(s, t_s, t_e, x) = (s',t_s - t_e) \text{ if } \delta_x(s,x)=s'.</math></li>
</ul>

<p></p>
<ul>
<li>Given a state 

<math display="inline" id="SP-DEVS:50">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo>,</mo>
     <msub>
      <mi>t</mi>
      <mi>s</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>λ</ci>
     <interval closure="open">
      <ci>s</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>s</ci>
      </apply>
     </interval>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda(s,t_{s})=y
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="SP-DEVS:51">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>δ</mi>
      <mi>y</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>,</mo>
     <msup>
      <mi>s</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <ci>y</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <interval closure="open">
     <ci>y</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{y}(s)=(y,s^{\prime}).
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="SP-DEVS:52">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>s</mi>
   <mo>,</mo>
   <msub>
    <mi>t</mi>
    <mi>s</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>t</mi>
    <mi>e</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>s</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>e</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s,t_{s},t_{e})
  </annotation>
 </semantics>
</math>

</li>
<li>Given a state 

<math display="inline" id="SP-DEVS:53">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mi>s</mi>
   </msub>
   <mo>=</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>s</ci>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{s}=\infty
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="SP-DEVS:54">
 <semantics>
  <msub>
   <mi>δ</mi>
   <mi>y</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>δ</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{y}
  </annotation>
 </semantics>
</math>

 if 

<math display="block" id="SP-DEVS:55">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>:</mo>
   <mrow>
    <mi>S</mi>
    <mo>→</mo>
    <msup>
     <mi>Y</mi>
     <mi>ϕ</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>λ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>S</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Y</ci>
      <ci>ϕ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda:S\rightarrow Y^{\phi}
  </annotation>
 </semantics>
</math>

</li>
</ul>
<h2 id="advantages">Advantages</h2>
<ul>
<li><strong>Applicability of Time-Line Abstraction</strong></li>
</ul>

<p>The property of non-negative rational-valued lifespans which are not changed by input events along with finite numbers of states and events guarantees that the behavior of SP-DEVS networks can be abstracted as an equivalent finite-vertex reachability graph by abstracting the infinitely-many values of the elaped times.</p>

<p>To abstract the infinitely-many cases of elapsed times for each components of SP-DEVS networks, a time-abstraction method, called the <em>time-line abstraction</em> has been introduced <a href="SP-DEVS#References" title="wikilink">[Hwang05</a>],<a href="SP-DEVS#References" title="wikilink">[HCZF07</a>] in which the orders and relative difference of schedules are preserved. By using the time-line abstraction technique, the behavior of any SP-DEVS network can be abstracted as a reachability graph whose numbers of vertices and edges are finite.</p>
<ul>
<li><strong>Decidability of Safety</strong></li>
</ul>

<p>As a qualitative property, safety of a SP-DEVS network is decidable by (1) generating the finite-vertex reachability graph of the given network and (2) checking whether some bad states are reachable or not <a href="SP-DEVS#References" title="wikilink">[Hwang05</a>].</p>
<ul>
<li><strong>Decidability of Liveness</strong></li>
</ul>

<p>As a qualitative property, liveness of a SP-DEVS network is decidable by (1) generating the finite-vertex reachability graph (RG) of the given network, (2) from RG, generating kernel <a href="directed_acyclic_graph" title="wikilink">directed acyclic graph</a> (KDAG) in which a vertex is <a href="strongly_connected_component" title="wikilink">strongly connected component</a>, and (3) checking if a vertex of KDAG contains a state transition cycle which contains a set of liveness states<a href="SP-DEVS#References" title="wikilink">[Hwang05</a>].</p>
<ul>
<li><strong>Decidability of Min/Max Processing Time Bounds</strong></li>
</ul>

<p>As a quantitative property, minimum and maximum processing time bounds from two events in SP-DEVS networks can be computed by (1) generating the finite-vertex reachability graph and (2.a) by finding the shortest paths for the minimum processing time bound and (2.b) by finding the longest paths (if available) for the maximum processing time bound <a href="SP-DEVS#References" title="wikilink">[HCZF07</a>].</p>
<h2 id="disadvantages">Disadvantages</h2>
<ul>
<li><strong>Less Expressiveness: OPNA problem</strong></li>
</ul>

<p>Let a total state 

<math display="inline" id="SP-DEVS:56">
 <semantics>
  <mrow>
   <msub>
    <mi>δ</mi>
    <mrow>
     <mi>i</mi>
     <mi>n</mi>
     <mi>t</mi>
    </mrow>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi>S</mi>
    <mo>→</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>δ</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>n</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>S</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{int}:S\rightarrow S
  </annotation>
 </semantics>
</math>

 of a SP-DEVS model be <em>passive</em> if <span class="LaTeX">$t_s = \infty$</span>; otherwise, it be <em>active</em>.</p>

<p>One of known SP-DEVS's limitation is a phenomenon that "once an SP-DEVS model becomes passive, it never returns to become active (OPNA)". This phenomenon was found first at <a href="SP-DEVS#References" title="wikilink">[Hwang 05b</a>] although it was originally called ODNR ("once it dies, it never returns."). The reason why this one happens is because of the restriction (3) above in which no input event can change the schedule so the passive state can not be awaken into the active state.</p>

<p>For example, the toaster models drawn in Fig. 3(b) are not SP-DEVS because the total state associated with "idle" (I), is passive but it moves to an active state, "toast" (T) whose toating time is 20 seconds or 40 seconds. Actually, the model shown in Fig. 3(b) is <a class="uri" href="FD-DEVS" title="wikilink">FD-DEVS</a>.</p>
<h2 id="tool">Tool</h2>

<p>There is an open source library, called DEVS# at <a class="uri" href="http://xsy-csharp.sourceforge.net/DEVSsharp/">http://xsy-csharp.sourceforge.net/DEVSsharp/</a>, that supports some algorithms for finding safyness and liveness as well as Min/Max processing time bounds.</p>
<h2 id="footnotes">Footnotes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li>[Hwang05] M. H. Hwang, "Tutorial: Verification of Real-time System Based on Schedule-Preserved DEVS", Proceedings of 2005 DEVS Symposium, San Diego, Apr. 2-8, 2005, ISBN 978-1-56555-293-7 (Available at <a class="uri" href="http://moonho.hwang.googlepages.com/publications">http://moonho.hwang.googlepages.com/publications</a>)</li>
<li>[Hwang05b] M. H. Hwang, "Generating Finite-State Global Behavior of Reconfigurable Automation Systems: DEVS Approach", <em>Proceedings of 2005 IEEE-CASE</em>, Edmonton, Canada, Aug. 1-2, 2005 (Available at <a class="uri" href="http://moonho.hwang.googlepages.com/publications">http://moonho.hwang.googlepages.com/publications</a>)</li>
<li>[HCZF07] M. H. Hwang, S.K. Cho, <a href="Bernard_P._Zeigler" title="wikilink">Bernard Zeigler</a>, and F. Lin, "Processing Time Bounds of Schedule-Preserving DEVS", ACIMS Technical Report, 2007, (Available at <a class="uri" href="http://www.acims.arizona.edu">http://www.acims.arizona.edu</a> and <a class="uri" href="http://moonho.hwang.googlepages.com/publications">http://moonho.hwang.googlepages.com/publications</a>)</li>
<li>[Sedgewick02], R. Sedgewick, <em>Algorithms in C++, Part 5 Graph Algorithm</em>, Addison Wesley, Boston, third edition</li>
<li>[ZKP00] </li>
</ul>

<p>"</p>

<p><a href="Category:Automata_theory" title="wikilink">Category:Automata theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><span class="LaTeX">$\delta_y$</span> can be divided into two functions<span class="LaTeX">$$\lambda:  S \rightarrow Y^\phi$$</span> and <span class="LaTeX">$\delta_{int}:S \rightarrow S$</span>as in <a href="SP-DEVS#References" title="wikilink">[ZKP00</a>].<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
