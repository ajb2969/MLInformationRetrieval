   Very smooth hash      Very smooth hash   In cryptography , Very Smooth Hash (VSH) is a  secure cryptographic hash function invented in 2005 by Scott Contini, Arjen Lenstra and Ron Steinfeld. 1  Provably secure means that finding collisions is as difficult as some known hard mathematical problem. Unlike other  secure collision-resistant hashes, VSH is efficient and usable in practice. Asymptotically , it only requires a single multiplication per log( n ) message-bits and uses RSA-type arithmetic. Therefore, VSH can be useful in embedded environments where code space is limited.  Two major variants of VSH were proposed. For one finding a collision is  as difficult as finding a nontrivial modular square root of a very smooth number modulo n . The other one uses a prime modulus p (with no trapdoor ), and its security proof relies on the hardness of finding discrete logarithms of very smooth numbers modulo p . Both versions have similar efficiency.  VSH is not suitable as a substitute for a random oracle , but can be used to build a  secure randomized trapdoor hash function. This function can replace the trapdoor function used in the Cramer-Shoup signature scheme , maintaining its provable security while speeding up verification time by about 50%.  VSN and VSSR  All cryptographic hash functions that are now widely used are not based on hard mathematical problems. Those few functions that are constructed on hard mathematical problems are called provably secure . Finding collisions is then known to be as hard as solving the hard mathematical problem. For the basic version of Very Smooth Hash function, this hard problem is to find modular square roots (VSSR) of certain special numbers (VSN). 2 This is assumed to be as hard as factoring integers .  For a fixed constant c and n an integer m is a Very Smooth Number (VSN) if the largest prime factor of m is at most (log n ) c .  An integer b is a Very Smooth Quadratic Residue modulo n if the largest prime in b ’s factorization is at most (log n ) c and there exists an integer x such that    b  ≡    x  2   mod  n       b   modulo   superscript  x  2   n     b\equiv x^{2}\mod n   . The integer x is said to be a Modular Square Root of b .  We are interested only in non-trivial square roots, those where x 2 ≥ n . If x 2 k\le(\log n)^c. Let      p  1   =  2   ,     p  2   =  3   ,    p  3   =   5  ,  …        formulae-sequence     subscript  p  1   2    formulae-sequence     subscript  p  2   3      subscript  p  3    5  normal-…       p_{1}=2,p_{2}=3,p_{3}=5,\dots   be the sequence of primes. VSSR is the following problem: Given n , find    x  ∈   ℤ  n  *       x   subscript   superscript  ℤ    n     x\in\mathbb{Z}^{*}_{n}   such that     x  2   ≡    ∏   i  =  0   k    p  i   e  i          superscript  x  2     superscript   subscript  product    i  0    k    superscript   subscript  p  i    subscript  e  i       \textstyle x^{2}\equiv\prod_{i=0}^{k}p_{i}^{e_{i}}   and at least one of e 0 ,..., e k is odd.  The VSSR assumption is that there is no probabilistic polynomial (in    log  n      n    \log n   ) time algorithm which solves VSSR with non-negligible probability. This is considered a useless assumption for practice because it does not tell for what size of moduli VSSR is computationally hard. Instead The computational VSSR assumption is used. It says that solving VSSR is assumed to be as hard as factoring a hard to factor   s   s   s   bit modulus, where   s   s   s   is somewhat smaller than the size of   n   n   n   .  Examples of VSN and VSSR  Let the parameters be fixed as follows    c  =  5      c  5    c=5   and    n  =  31      n  31    n=31   .  Then     m  1   =  35  =   5  ⋅  7          subscript  m  1   35        normal-⋅  5  7      m_{1}=35=5\cdot 7   is a Very Smooth Number with respect to these parameters because       (   log  31   )   5      =  ˙    7.37       superscript    31   5    normal-˙    7.37    (\log 31)^{5}~{}\dot{=}~{}7.37   is greater than all    m  1     subscript  m  1    m_{1}   's prime factors. On the other hand     m  2   =  55  =   5  ⋅  11          subscript  m  2   55        normal-⋅  5  11      m_{2}=55=5\cdot 11   is not a VSN under    c  =  5      c  5    c=5   and    n  =  31      n  31    n=31   .  The integer     b  1   =  9       subscript  b  1   9    b_{1}=9   is Very Smooth Quadratic Residue modulo   n   n   n   because it is Very Smooth Number (under    c  ,  n     c  n    c,n   ) and we have     x  1   =  3       subscript  x  1   3    x_{1}=3   such that     x  1  2   =   b  1        superscript   subscript  x  1   2    subscript  b  1     x_{1}^{2}=b_{1}   (mod   n   n   n   ). This is a trivial modular square root, because     3  2   ≱  n     not-greater-than-or-equals   superscript  3  2   n    3^{2}\not\geq n   and so the modulus is not involved when squaring.  The integer     b  2   =  15       subscript  b  2   15    b_{2}=15   is also Very Smooth Quadratic Residue modulo   n   n   n   . All prime factors are smaller than 7.37 and the Modular Square Root is     x  2   =  20       subscript  x  2   20    x_{2}=20   since     20  2   =  400  ≡  15         superscript  20  2   400       15     20^{2}=400\equiv 15   (mod   n   n   n   ). This is thus a non-trivial root. The VSSR problem is to find    x  2     subscript  x  2    x_{2}   given    b  2     subscript  b  2    b_{2}   and   n   n   n   . And we suppose that this is computationally as hard as factoring   n   n   n   .  VSH Algorithm, basic versions  Let   n   n   n   be a large RSA composite and let      p  1   =  2   ,    p  2   =   3  ,  …       formulae-sequence     subscript  p  1   2      subscript  p  2    3  normal-…      p_{1}=2,p_{2}=3,\ldots   the sequence of primes. Let   k   k   k   , the block length, be the largest integer such that      ∏   i  =  1   k    p  i    <  n        superscript   subscript  product    i  1    k    subscript  p  i    n    \textstyle\prod_{i=1}^{k}p_{i}   . Let   m   m   m   be an   ℓ   normal-ℓ   \ell   -bit message to be hashed consisting of bits    (   m  1   ,  …  ,   m  ℓ   )      subscript  m  1   normal-…   subscript  m  normal-ℓ     (m_{1},\ldots,m_{\ell})   and assume that    ℓ  <   2  k       normal-ℓ   superscript  2  k     \ell<2^{k}   . To compute the hash of   m   m   m   :   x 0 = 1  Let   L   L   L   , the smallest integer greater or equal to    l  /  k      l  k    l/k   , be the number of blocks. Let     m  i   =  0       subscript  m  i   0    m_{i}=0   for    l  <  i  ≤   L  k         l  i         L  k      l   (padding)  Let    ℓ  =    ∑   i  =  1   k     l  i    2   i  -  1          normal-ℓ    superscript   subscript     i  1    k      subscript  l  i    superscript  2    i  1        \textstyle\ell=\sum_{i=1}^{k}l_{i}2^{i-1}   with     ℓ  i   ∈   {  0  ,  1  }        subscript  normal-ℓ  i    0  1     \ell_{i}\in\{0,1\}   be the binary representation of the message length   ℓ   normal-ℓ   \ell   and define     m    L  k   +  i    =   ℓ  i        subscript  m      L  k   i     subscript  normal-ℓ  i     m_{Lk+i}=\ell_{i}   for    1  ≤  i  ≤  k        1  i       k     1\leq i\leq k   .  for j = 0, 1,..., L in succession compute     x   j  +  1    =     x  j  2     ∏   i  =  1   k    p  i   m    j  k   +  i       mod  n        subscript  x    j  1     modulo     superscript   subscript  x  j   2     superscript   subscript  product    i  1    k    superscript   subscript  p  i    subscript  m      j  k   i       n     x_{j+1}=x_{j}^{2}\prod_{i=1}^{k}p_{i}^{m_{jk+i}}\mod n     return x L + 1 .   The function in step 4 is called the compression function.  Properties of VSH   The message length does not need to be known in advance.  A most important theorem states that finding a collision in VSH is as hard as solving VSSR. Thus VSH is (strongly) collision resistant which also implies second preimage resistance. VSH has not been proven to be pre-image resistant.  A curious feature of VSH is that the compression function is not collision-resistant. Nonetheless, the hash function VSH is collision-resistant based on the VSSR assumption. An altered version of VSH, called VSH* , has the compression function collision resistant and furthermore is about 5 times quicker when hashing short messages.  Since the output length of VSH is the length of a secure RSA modulus, VSH seems quite suitable in practice for constructing 'hash-then-sign' RSA signatures for arbitrarily long messages. However, such a signature must be designed carefully to ensure its security. The naive approach could be easily broken under CPA (chosen plaintext attack) .  Efficiency : The cost of each iteration is less than the cost of 3 modular multiplications. The basic version of VSH altogether requires single multiplication per    Ω   (   log   n  /   log   log  n      )       normal-Ω      n      n        \Omega(\log n/\log\log n)   message-bits.   Variants of VSH  Several improvements, speedups and more efficient variants of VSH have been proposed. 3 None of them changes the underlying concept of the function. These improvements are called:   Cubing VSH (instead of squaring).  VSH with increased number of small primes.  VSH with precomputed products of primes.  Fast VSH.  Fast VSH with increased block length.   VSDL and VSH-DL variant  The VSH-DL is a discrete logarithm variant of VSH that has no trapdoor , its security depends on the difficulty of finding discrete logarithm modulo a prime p . 4  Very Smooth Number Discrete Logarithm (VSDL) is a problem where given a very smooth number, we want to find its discrete logarithm modulo some number n .  Similarly as in previous section, by    p  i     subscript  p  i    p_{i}   we denote the   i   i   i   -th prime. Let furthermore   c   c   c   be a fixed constant and   p   p   p   ,   q   q   q   be primes with    p  =    2  q   +  1       p      2  q   1     p=2q+1   and let    k  ≤    (   log  p   )   c       k   superscript    p   c     k\leq(\log p)^{c}   . CSDL is the following problem: given   p   p   p   , find integers     e  1   ,  …  ,   e  k       subscript  e  1   normal-…   subscript  e  k     e_{1},...,e_{k}   such that     2   e  1    ≡     ∏   i  =  2   k    p  i   e  i     mod  p        superscript  2   subscript  e  1     modulo    superscript   subscript  product    i  2    k    superscript   subscript  p  i    subscript  e  i     p     2^{e_{1}}\equiv\prod_{i=2}^{k}p_{i}^{e_{i}}\mod p   with     |   e  i   |   <  q         subscript  e  i    q    |e_{i}|   for    i  =   1  ,  …  ,  k       i   1  normal-…  k     i=1,...,k   and at least one of     e  1   ,  …  ,   e  k       subscript  e  1   normal-…   subscript  e  k     e_{1},...,e_{k}   non-zero.  The VSDL assumption is that there is no probabilistic polynomial (in    log  p      p    \log p   ) time algorithm which solves VSDL with non-negligible probability. There is a strong connection between the hardness of VSDL and the hardness of computing discrete logarithm modulo   p   p   p   , which is reminiscent of, but somewhat weaker than, the connection between VSSR and integer factorization.  Security of VSH  Strong collision resistance is the only property proven for VSH. This does not imply preimage-resistance or other important hash function properties and the authors state that “VSH should not be used to model random oracles ,” and cannot be substituted into constructions that depend upon them ( RSA signatures , some MACs ). 5 VSH should not be considered a general-purpose hash function as usually understood in security engineering.  Multiplicative property  VSH is multiplicative: Let x , y , and z be three bit strings of equal length, where z consists only of zero bits and the strings satisfy x AND y = z . It is easy to see that H(z)H(x OR y) ≡ H(x)H(y) (mod n) . As a result VSH succumbs to a classical time-memory trade-off attack that applies to multiplicative and additive hashes.  This fact can be used to construct a preimage attack against VSH of   ℓ   normal-ℓ   \ell   bits which has    2   ℓ  /  2      superscript  2    normal-ℓ  2     2^{\ell/2}   complexity rather than    2  ℓ     superscript  2  normal-ℓ    2^{\ell}   as expected.  Attack against truncated version  VSH produces a very long hash (typically 1024 bits). There are no indications that a truncated VSH hash offers security that is commensurate with the hash length.  There exists a Partial Collision Attacks on VSH truncated to least significant l bits. 6  The complexity of this attack against is:   Pre-computing the table offline    2   ℓ  /  3      superscript  2    normal-ℓ  3     2^{\ell/3}   time and space.  Finding collisions    2   ℓ  /  3      superscript  2    normal-ℓ  3     2^{\ell/3}   iterations.  Total cost: roughly    2   ℓ  /  3      superscript  2    normal-ℓ  3     2^{\ell/3}   , rather than    2   ℓ  /  2      superscript  2    normal-ℓ  2     2^{\ell/2}   as expected from a hash function with good pseudorandomness properties.   This probably rules out the applicability of VSH in digital signature schemes which produce signatures shorter than the VSH hash result, such as Elliptic Curve signature schemes.  References  See also   Cryptographic hash functions  Provably secure cryptographic hash function   "  Category:Cryptographic hash functions     ↩      ↩     