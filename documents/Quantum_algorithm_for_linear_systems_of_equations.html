<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1004">Quantum algorithm for linear systems of equations</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Quantum algorithm for linear systems of equations</h1>
<hr/>

<p>The <strong>quantum algorithm for linear systems of equations</strong>, designed by Aram Harrow, Avinatan Hassidim, and <a href="Seth_Lloyd" title="wikilink">Seth Lloyd</a>, is a <a href="quantum_algorithm" title="wikilink">quantum algorithm</a> for solving <a href="System_of_linear_equations" title="wikilink">linear systems</a> formulated in 2009. The algorithm estimates the result of a scalar measurement on the solution vector to a given linear system of equations.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The algorithm is one of the main fundamental algorithms expected to provide an exponential speedup over their classical counterparts, along with <a href="Shor's_Algorithm" title="wikilink">Shor's factoring algorithm</a>, <a href="Grover's_algorithm" title="wikilink">Grover's search algorithm</a> and <a href="Universal_quantum_simulator" title="wikilink">quantum simulation</a>. Provided the linear system is a <a href="sparse_matrix" title="wikilink">sparse</a> and has a low <a href="condition_number" title="wikilink">condition number</a> 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:0">
 <semantics>
  <mi>κ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>κ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa
  </annotation>
 </semantics>
</math>

, and that the user is interested in the result of a scalar measurement on the solution vector, instead of the values of the solution vector itself, then the algorithm has a runtime of 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:1">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>N</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <msup>
      <mi>κ</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <log></log>
      <ci>N</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>κ</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log(N)\kappa^{2})
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:2">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 is the number of variables in the linear system.. This offers an exponential speedup over the fastest classical algorithm, which runs in 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:3">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mi>κ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>κ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(N\kappa)
  </annotation>
 </semantics>
</math>

 (or 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:4">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <msqrt>
      <mi>κ</mi>
     </msqrt>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <apply>
      <root></root>
      <ci>κ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(N\sqrt{\kappa})
  </annotation>
 </semantics>
</math>

 for positive semidefinite matrices).</p>

<p>An implementation of the quantum algorithm for linear systems of equations was first demonstrated in 2013 by Cai et al., Barz et al.and Pan et al. in parallel. The demonstrations consisted of simple linear equations on specially designed quantum devices.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Due to the prevalence of linear systems in virtually all areas of science and engineering, the quantum algorithm for linear systems of equations has the potential for widespread applicability.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="procedure">Procedure</h2>

<p>The problem we are trying to solve is: given a Hermitian 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:5">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>×</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\times N
  </annotation>
 </semantics>
</math>

 matrix 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:6">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and a unit vector 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:7">
 <semantics>
  <mover accent="true">
   <mi>b</mi>
   <mo>→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overrightarrow{b}
  </annotation>
 </semantics>
</math>

, find the solution vector 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:8">
 <semantics>
  <mover accent="true">
   <mi>x</mi>
   <mo>→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overrightarrow{x}
  </annotation>
 </semantics>
</math>

 satisfying 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mover accent="true">
     <mi>x</mi>
     <mo>→</mo>
    </mover>
   </mrow>
   <mo>=</mo>
   <mover accent="true">
    <mi>b</mi>
    <mo>→</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\overrightarrow{x}=\overrightarrow{b}
  </annotation>
 </semantics>
</math>

. This algorithm assumes that the user is not interested in the values of 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:10">
 <semantics>
  <mover accent="true">
   <mi>x</mi>
   <mo>→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overrightarrow{x}
  </annotation>
 </semantics>
</math>

 itself, but rather the result of applying some operator 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:11">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 onto x, 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:12">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>x</mi>
   <mo fence="true" stretchy="false">|</mo>
   <mi>M</mi>
   <mo fence="true" stretchy="false">|</mo>
   <mi>x</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">quantum-operator-product</csymbol>
    <ci>x</ci>
    <ci>M</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x|M|x\rangle
  </annotation>
 </semantics>
</math>

.</p>

<p>First, the algorithm represents the vector 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:13">
 <semantics>
  <mover accent="true">
   <mi>b</mi>
   <mo>→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overrightarrow{b}
  </annotation>
 </semantics>
</math>

 as a quantum state of the form:</p>

<p>

<math display="block" id="Quantum_algorithm_for_linear_systems_of_equations:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mi>b</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mrow>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>b</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mi>i</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>b</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <times></times>
        <ci>i</ci>
        <apply>
         <eq></eq>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |b\rangle=\sum_{i\mathop{=}1}^{N}b_{i}|i\rangle.
  </annotation>
 </semantics>
</math>

</p>

<p>Next, Hamiltonian simulation techniques are used to apply the unitary operator 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:15">
 <semantics>
  <msup>
   <mi>e</mi>
   <mrow>
    <mi>i</mi>
    <mi>A</mi>
    <mi>t</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>e</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>A</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{iAt}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:16">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>b</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |b\rangle
  </annotation>
 </semantics>
</math>

 for a superposition of different times 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:17">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

. The ability to decompose 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:18">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>b</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |b\rangle
  </annotation>
 </semantics>
</math>

 into the eigenbasis of 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:19">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and to find the corresponding eigenvalues 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:20">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{j}
  </annotation>
 </semantics>
</math>

 is facilitated by the use of <a href="quantum_phase_estimation" title="wikilink">quantum phase estimation</a>.</p>

<p>The state of the system after this decomposition is approximately:</p>

<p>

<math display="block" id="Quantum_algorithm_for_linear_systems_of_equations:21">
 <semantics>
  <mrow>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mrow>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
     </mrow>
     <mi>N</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>β</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <msub>
       <mi>u</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <msub>
       <mi>λ</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <times></times>
       <ci>j</ci>
       <apply>
        <eq></eq>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{j\mathop{=}1}^{N}\beta_{j}|u_{j}\rangle|\lambda_{j}\rangle,
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:22">
 <semantics>
  <msub>
   <mi>u</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{j}
  </annotation>
 </semantics>
</math>

 is the eigenvector basis of 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:23">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:24">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>b</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mrow>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
     </mrow>
     <mi>N</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>β</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <msub>
       <mi>u</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>b</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <times></times>
        <ci>j</ci>
        <apply>
         <eq></eq>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |b\rangle=\sum_{j\mathop{=}1}^{N}\beta_{j}|u_{j}\rangle
  </annotation>
 </semantics>
</math>

.</p>

<p>We would then like to perform the linear map taking 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:25">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msub>
    <mi>λ</mi>
    <mi>j</mi>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\lambda_{j}\rangle
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:26">
 <semantics>
  <mrow>
   <mi>C</mi>
   <msubsup>
    <mi>λ</mi>
    <mi>j</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>λ</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>λ</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\lambda^{-1}_{j}|\lambda_{j}\rangle
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:27">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is a normalizing constant. The linear mapping operation is not unitary and thus will require a number of repetitions as it has some probability of failing. After it succeeds, we uncompute the 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:28">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msub>
    <mi>λ</mi>
    <mi>j</mi>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\lambda_{j}\rangle
  </annotation>
 </semantics>
</math>

 register and are left with a state proportional to:</p>

<p>

<math display="block" id="Quantum_algorithm_for_linear_systems_of_equations:29">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mrow>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>β</mi>
       <mi>i</mi>
      </msub>
      <msubsup>
       <mi>λ</mi>
       <mi>j</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <msub>
        <mi>u</mi>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>A</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mi>b</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mi>x</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <times></times>
         <ci>i</ci>
         <apply>
          <eq></eq>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>β</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>λ</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i\mathop{=}1}^{N}\beta_{i}\lambda^{-1}_{j}|u_{j}\rangle=A^{-1}|b\rangle=%
|x\rangle,
  </annotation>
 </semantics>
</math>

</p>

<p>Where 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:30">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>x</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |x\rangle
  </annotation>
 </semantics>
</math>

 is a quantum-mechanical representation of the desired solution vector <em>x</em>. To read out all components of <em>x</em> would require the procedure be repeated at least <em>N</em> times. However, it is often the case that one is not interested in 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:31">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 itself, but rather some expectation value of a linear operator <em>M</em> acting on <em>x</em>. By mapping <em>M</em> to a quantum-mechanical operator and performing the quantum measurement corresponding to <em>M</em>, we obtain an estimate of the expectation value 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:32">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>x</mi>
   <mo fence="true" stretchy="false">|</mo>
   <mi>M</mi>
   <mo fence="true" stretchy="false">|</mo>
   <mi>x</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">quantum-operator-product</csymbol>
    <ci>x</ci>
    <ci>M</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x|M|x\rangle
  </annotation>
 </semantics>
</math>

. This allows for a wide variety of features of the vector <em>x</em> to be extracted including normalization, weights in different parts of the state space, and moments without actually computing all the values of the solution vector <em>x</em>.</p>
<h2 id="explanation-of-the-algorithm">Explanation of the algorithm</h2>
<h3 id="initialization">Initialization</h3>

<p>Firstly, the algorithm requires that the matrix 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:33">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 be <a href="Hermitian_matrix" title="wikilink">Hermitian</a> so that it can be converted into a <a href="unitary_operator" title="wikilink">unitary operator</a>. In the case were 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:34">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is not Hermitian, define</p>

<p>

<math display="block" id="Quantum_algorithm_for_linear_systems_of_equations:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐂</mi>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mi>A</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msup>
         <mi>A</mi>
         <mi>t</mi>
        </msup>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐂</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">0</cn>
      <ci>A</ci>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <ci>t</ci>
      </apply>
      <cn type="integer">0</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C}=\begin{bmatrix}0&A\\
A^{t}&0\end{bmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>As 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:36">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is Hermitian, the algorithm can now be used to solve 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:37">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>C</mi>
     <mi>y</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable>
      <mtr>
       <mtd columnalign="center">
        <mi>b</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>y</ci>
    </apply>
    <matrix>
     <matrixrow>
      <ci>b</ci>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Cy=\begin{bmatrix}b\\
0\end{bmatrix}.
  </annotation>
 </semantics>
</math>

 to obtain 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:38">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi>x</mi>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <ci>x</ci>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=\begin{bmatrix}0\\
x\end{bmatrix}
  </annotation>
 </semantics>
</math>

.</p>

<p>Secondly, The algorithm requires an efficient procedure to prepare 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:39">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>b</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |b\rangle
  </annotation>
 </semantics>
</math>

, the quantum representation of b. It is assumed that there exists some linear operator 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:40">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 that can take some arbitrary quantum state 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:41">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>initial</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>initial</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\mathrm{initial}\rangle
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:42">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>b</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |b\rangle
  </annotation>
 </semantics>
</math>

 efficiently or that this algorithm is a subroutine in a larger algorithm and is given 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:43">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>b</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |b\rangle
  </annotation>
 </semantics>
</math>

 as input. Any error in the preparation of state 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:44">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>b</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |b\rangle
  </annotation>
 </semantics>
</math>

 is ignored.</p>

<p>Finally, the algorithm assumes that the state 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:45">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msub>
    <mi>ψ</mi>
    <mn>0</mn>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ψ</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi_{0}\rangle
  </annotation>
 </semantics>
</math>

 can be prepared efficiently. Where</p>

<p>

<math display="block" id="Quantum_algorithm_for_linear_systems_of_equations:46">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>ψ</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <msqrt>
     <mrow>
      <mn>2</mn>
      <mo>/</mo>
      <mi>T</mi>
     </mrow>
    </msqrt>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>τ</mi>
       <mrow>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
      </mrow>
      <mrow>
       <mi>T</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </munderover>
     <mrow>
      <mrow>
       <mi>sin</mi>
       <mi>π</mi>
      </mrow>
      <mrow>
       <mo>(</mo>
       <mstyle displaystyle="false">
        <mfrac>
         <mrow>
          <mi>τ</mi>
          <mo>+</mo>
          <mstyle scriptlevel="-1">
           <mfrac>
            <mn>1</mn>
            <mn>2</mn>
           </mfrac>
          </mstyle>
         </mrow>
         <mi>T</mi>
        </mfrac>
       </mstyle>
       <mo>)</mo>
      </mrow>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mi>τ</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ψ</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <root></root>
      <apply>
       <divide></divide>
       <cn type="integer">2</cn>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <times></times>
         <ci>τ</ci>
         <apply>
          <eq></eq>
          <cn type="integer">0</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>T</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <sin></sin>
        <ci>π</ci>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <plus></plus>
         <ci>τ</ci>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <ci>T</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <ci>τ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi_{0}\rangle:=\sqrt{2/T}\sum_{\tau\mathop{=}0}^{T-1}\sin\pi\left(\tfrac{%
\tau+\tfrac{1}{2}}{T}\right)|\tau\rangle
  </annotation>
 </semantics>
</math>

</p>

<p>for some large 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:47">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

. The coefficients of 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:48">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msub>
    <mi>ψ</mi>
    <mn>0</mn>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ψ</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi_{0}\rangle
  </annotation>
 </semantics>
</math>

 are chosen to minimize a certain quadratic loss function which induces error in the 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:49">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>invert</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>invert</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\mathrm{invert}}
  </annotation>
 </semantics>
</math>

 subroutine described below.</p>
<h3 id="phase-estimation">Phase estimation</h3>

<p><a href="Phase_estimation" title="wikilink">Phase estimation</a> is used to transform the Hermitian matrix 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:50">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 into a unitary operator, which can then be applied at will. This is possible if <em>A</em> is <em>s</em>-sparse and efficiently row computable, meaning it has at most <em>s</em> nonzero entries per row and given a row index these entries can be computed in time O(<em>s</em>). Under these assumptions, quantum phase estimation allows 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:51">
 <semantics>
  <mrow>
   <msup>
    <mi>e</mi>
    <mi>i</mi>
   </msup>
   <mi>A</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <ci>i</ci>
    </apply>
    <ci>A</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{i}At
  </annotation>
 </semantics>
</math>

 to be simulated in time 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:52">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>N</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <msup>
      <mi>s</mi>
      <mn>2</mn>
     </msup>
     <mi>t</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <log></log>
      <ci>N</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log(N)s^{2}t)
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="uinvert-subroutine">Uinvert subroutine</h3>

<p>The key subroutine to the algorithm, denoted 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:53">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>invert</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>invert</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\mathrm{invert}}
  </annotation>
 </semantics>
</math>

, is defined as follows:</p>

<p>1. Prepare 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:54">
 <semantics>
  <msup>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>ψ</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>C</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ψ</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi_{0}\rangle^{C}
  </annotation>
 </semantics>
</math>

 on register <em>C</em></p>

<p>2. Apply the conditional Hamiltonian evolution (sum)</p>

<p>3. Apply the Fourier transform to the register <em>C</em>. Denote the resulting basis states with 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:55">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>k</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |k\rangle
  </annotation>
 </semantics>
</math>

 for <em>k</em> = 0, ..., <em>T</em> − 1. Define 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:56">
 <semantics>
  <mrow>
   <msub>
    <mi>λ</mi>
    <mi>k</mi>
   </msub>
   <mo>:=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>π</mi>
     <mi>k</mi>
    </mrow>
    <mo>/</mo>
    <msub>
     <mi>t</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>π</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{k}:=2\pi k/t_{0}
  </annotation>
 </semantics>
</math>

.</p>

<p>4. Adjoin a three-dimensional register <em>S</em> in the state</p>

<p>

<math display="block" id="Quantum_algorithm_for_linear_systems_of_equations:57">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mrow>
       <mi>h</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>λ</mi>
         <mi>k</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi>S</mi>
    </msup>
    <mo>:=</mo>
    <mrow>
     <mrow>
      <msqrt>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <mi>f</mi>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>λ</mi>
            <mi>k</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
          <mn>2</mn>
         </msup>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>g</mi>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>λ</mi>
            <mi>k</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
          <mn>2</mn>
         </msup>
        </mrow>
       </mrow>
      </msqrt>
      <msup>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mi>nothing</mi>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mi>S</mi>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>λ</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <msup>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mi>well</mi>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mi>S</mi>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>λ</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <msup>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mi>ill</mi>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mi>S</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <apply>
       <times></times>
       <ci>h</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <ci>S</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <root></root>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <ci>f</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>λ</ci>
           <ci>k</ci>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>g</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>λ</ci>
           <ci>k</ci>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <ci>nothing</ci>
       </apply>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <ci>well</ci>
       </apply>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>g</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <ci>ill</ci>
       </apply>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |h(\lambda_{k})\rangle^{S}:=\sqrt{1-f(\lambda_{k})^{2}-g(\lambda_{k})^{2}}|%
\mathrm{nothing}\rangle^{S}+f(\lambda_{k})|\mathrm{well}\rangle^{S}+g(\lambda_%
{k})|\mathrm{ill}\rangle^{S},
  </annotation>
 </semantics>
</math>

</p>

<p>5. Reverse steps 1–3, uncomputing any garbage produced along the way.</p>

<p>where functions <em>f</em>, <em>g</em>, are filter functions. The states 'nothing', 'well' and 'ill' are used to instruct the loop body on how to proceed; 'nothing' indicates that the desired matrix inversion has not yet taken place, 'well' indicates that the inversion has taken place and the loop should halt, and 'ill' indicates that part of 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:58">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>b</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |b\rangle
  </annotation>
 </semantics>
</math>

 is in the ill-conditioned subspace of <em>A</em> and the algorithm will not be able to produce the desired inversion.</p>
<h3 id="main-loop">Main loop</h3>

<p>The body of the algorithm follows the <a href="amplitude_amplification" title="wikilink">amplitude amplification</a> procedure: starting with 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:59">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mi>invert</mi>
   </msub>
   <mi>B</mi>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>initial</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>invert</ci>
    </apply>
    <ci>B</ci>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>initial</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\mathrm{invert}}B|\mathrm{initial}\rangle
  </annotation>
 </semantics>
</math>

, the following operation is repeatedly applied:</p>

<p>

<math display="block" id="Quantum_algorithm_for_linear_systems_of_equations:60">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mi>invert</mi>
   </msub>
   <mi>B</mi>
   <msub>
    <mi>R</mi>
    <mi>init</mi>
   </msub>
   <msup>
    <mi>B</mi>
    <mo>†</mo>
   </msup>
   <msubsup>
    <mi>U</mi>
    <mi>invert</mi>
    <mo>†</mo>
   </msubsup>
   <msub>
    <mi>R</mi>
    <mi>succ</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>invert</ci>
    </apply>
    <ci>B</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>init</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>B</ci>
     <ci>normal-†</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>U</ci>
      <ci>normal-†</ci>
     </apply>
     <ci>invert</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>succ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\mathrm{invert}}BR_{\mathrm{init}}B^{\dagger}U^{\dagger}_{\mathrm{invert}}R%
_{\mathrm{succ}}
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="Quantum_algorithm_for_linear_systems_of_equations:61">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>R</mi>
     <mi>succ</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>I</mi>
      <mn>2</mn>
     </msup>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mi>well</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <msup>
       <mrow>
        <mo stretchy="false">⟨</mo>
        <mi>well</mi>
        <mo fence="true" stretchy="false">|</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>succ</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>I</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <ci>well</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">bra</csymbol>
        <ci>well</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{\mathrm{succ}}=I^{2}-2|\mathrm{well}\rangle\langle\mathrm{well}|^{2},
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Quantum_algorithm_for_linear_systems_of_equations:62">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>R</mi>
     <mi>init</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>I</mi>
      <mn>2</mn>
     </msup>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mi>initial</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>initial</mi>
       <mo fence="true" stretchy="false">|</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>init</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>I</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <ci>initial</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">bra</csymbol>
       <ci>initial</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{\mathrm{init}}=I^{2}-2|\mathrm{initial}\rangle\langle\mathrm{initial}|.
  </annotation>
 </semantics>
</math>

</p>

<p>After each repetition, 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:63">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is measured and will produce a value of 'nothing', 'well', or 'ill' as described above. This loop is repeated until 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:64">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is measured, which occurs with a probability 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:65">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

. Rather than repeating 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:66">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mi>p</mi>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{p}
  </annotation>
 </semantics>
</math>

 times to minimize error, amplitude amplification is used to achieve the same error resilience using only 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:67">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mi>p</mi>
     </msqrt>
    </mfrac>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(\frac{1}{\sqrt{p}}\right)
  </annotation>
 </semantics>
</math>

 repetitions.</p>
<h3 id="scalar-measurement">Scalar measurement</h3>

<p>After successfully measuring 'well' on 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:68">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 the system will be in a state proportional to:</p>

<p>

<math display="block" id="Quantum_algorithm_for_linear_systems_of_equations:69">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mrow>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>β</mi>
       <mi>i</mi>
      </msub>
      <msubsup>
       <mi>λ</mi>
       <mi>j</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <msub>
        <mi>u</mi>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>A</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mi>b</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mi>x</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <times></times>
         <ci>i</ci>
         <apply>
          <eq></eq>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>β</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>λ</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i\mathop{=}1}^{N}\beta_{i}\lambda^{-1}_{j}|u_{j}\rangle=A^{-1}|b\rangle=%
|x\rangle.
  </annotation>
 </semantics>
</math>

</p>

<p>Finally, we perform the quantum-mechanical operator corresponding to M and obtain an estimate of the value of 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:70">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>x</mi>
   <mo fence="true" stretchy="false">|</mo>
   <mi>M</mi>
   <mo fence="true" stretchy="false">|</mo>
   <mi>x</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">quantum-operator-product</csymbol>
    <ci>x</ci>
    <ci>M</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x|M|x\rangle
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="run-time-analysis">Run time analysis</h2>
<h3 id="classical-efficiency">Classical efficiency</h3>

<p>The best classical algorithm which produces the actual solution vector 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:71">
 <semantics>
  <mover accent="true">
   <mi>x</mi>
   <mo>→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overrightarrow{x}
  </annotation>
 </semantics>
</math>

 is <a href="Gaussian_elimination" title="wikilink">Gaussian elimination</a>, which runs in 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:72">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>N</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>N</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(N^{3})
  </annotation>
 </semantics>
</math>

 time.</p>

<p>If <em>A</em> is <em>s</em>-sparse and positive semi-definite, then the <a href="Conjugate_Gradient_method" title="wikilink">Conjugate Gradient method</a> can be used to find the solution vector 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:73">
 <semantics>
  <mover accent="true">
   <mi>x</mi>
   <mo>→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overrightarrow{x}
  </annotation>
 </semantics>
</math>

 can be found in 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:74">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mi>s</mi>
     <mi>κ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>s</ci>
     <ci>κ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(Ns\kappa)
  </annotation>
 </semantics>
</math>

 time by minimizing the quadratic function 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:75">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>A</mi>
      <mover accent="true">
       <mi>x</mi>
       <mo>→</mo>
      </mover>
     </mrow>
     <mo>-</mo>
     <mover accent="true">
      <mi>b</mi>
      <mo>→</mo>
     </mover>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>A</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <ci>normal-→</ci>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A\overrightarrow{x}-\overrightarrow{b}|^{2}
  </annotation>
 </semantics>
</math>

.</p>

<p>When only a summary statistic of the solution vector 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:76">
 <semantics>
  <mover accent="true">
   <mi>x</mi>
   <mo>→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overrightarrow{x}
  </annotation>
 </semantics>
</math>

 is needed, as is the case for the quantum algorithm for linear systems of equations, a classical computer can find an estimate of 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:77">
 <semantics>
  <mrow>
   <msup>
    <mover accent="true">
     <mi>x</mi>
     <mo>→</mo>
    </mover>
    <mo>†</mo>
   </msup>
   <mi>M</mi>
   <mover accent="true">
    <mi>x</mi>
    <mo>→</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-→</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-†</ci>
    </apply>
    <ci>M</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overrightarrow{x}^{\dagger}M\overrightarrow{x}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:78">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <msqrt>
      <mi>κ</mi>
     </msqrt>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <apply>
      <root></root>
      <ci>κ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(N\sqrt{\kappa})
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="quantum-efficiency">Quantum efficiency</h3>

<p>The quantum algorithm for solving linear systems of equations originally proposed by Harrow et al. was shown to be 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:79">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>κ</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mi>log</mi>
      <mi>N</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>κ</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <log></log>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\kappa^{2}\log N)
  </annotation>
 </semantics>
</math>

. The runtime of this algorithm was subsequently improved to 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:80">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>κ</mi>
     <mrow>
      <msup>
       <mi>log</mi>
       <mn>3</mn>
      </msup>
      <mrow>
       <mi>κ</mi>
       <mrow>
        <mi>log</mi>
        <mi>N</mi>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>κ</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <log></log>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <times></times>
       <ci>κ</ci>
       <apply>
        <log></log>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\kappa\log^{3}\kappa\log N)
  </annotation>
 </semantics>
</math>

 by Andris Ambainis.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h3 id="optimality">Optimality</h3>

<p>An important factor in the performance of the matrix inversion algorithm is the condition number of 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:81">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:82">
 <semantics>
  <mi>κ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>κ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa
  </annotation>
 </semantics>
</math>

, which represents the ratio of 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:83">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

's largest and smallest eigenvalues. As the condition number increases, the ease with which the solution vector can be found using gradient descent methods such as the <a href="conjugate_gradient_method" title="wikilink">conjugate gradient method</a> decreases, as 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:84">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 becomes closer to a matrix which cannot be inverted and the solution vector becomes less stable. This algorithm assumes that all elements of the matrix 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:85">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 lie between 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:86">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mi>κ</mi>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>κ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{\kappa}
  </annotation>
 </semantics>
</math>

 and 1, in which case the claimed run-time proportional to 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:87">
 <semantics>
  <msup>
   <mi>κ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>κ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa^{2}
  </annotation>
 </semantics>
</math>

 will be achieved. Therefore, the speedup over classical algorithms is increased further when 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:88">
 <semantics>
  <mi>κ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>κ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa
  </annotation>
 </semantics>
</math>

 is a 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:89">
 <semantics>
  <mrow>
   <mi>poly</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>N</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>poly</ci>
    <apply>
     <log></log>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{poly}(\log(N))
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>If the run-time of the algorithm were made poly-logarithmic in 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:90">
 <semantics>
  <mi>κ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>κ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa
  </annotation>
 </semantics>
</math>

 then problems solvable on <em>n</em> qubits could be solved in poly(<em>n</em>) time, causing the complexity class <a class="uri" href="BQP" title="wikilink">BQP</a> to be equal to <a class="uri" href="PSPACE" title="wikilink">PSPACE</a>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="error-analysis">Error analysis</h2>

<p>Performing the phase estimation, which is the dominant source of error, is done by simulating 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:91">
 <semantics>
  <msup>
   <mi>e</mi>
   <mrow>
    <mi>i</mi>
    <mi>A</mi>
    <mi>t</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>e</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>A</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{iAt}
  </annotation>
 </semantics>
</math>

. Assuming that 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:92">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is s-sparse, this can be done with an error bounded by a constant 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:93">
 <semantics>
  <mi>ε</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

, which will translate to the additive error achieved in the output state 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:94">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>x</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |x\rangle
  </annotation>
 </semantics>
</math>

.</p>

<p>The phase estimation step errs by 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:95">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mn>1</mn>
     <msub>
      <mi>t</mi>
      <mn>0</mn>
     </msub>
    </mfrac>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(\frac{1}{t_{0}}\right)
  </annotation>
 </semantics>
</math>

 in estimating 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:96">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

, which translates into a relative error of 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:97">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mi>λ</mi>
      <msub>
       <mi>t</mi>
       <mn>0</mn>
      </msub>
     </mrow>
    </mfrac>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>λ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(\frac{1}{\lambda t_{0}}\right)
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:98">
 <semantics>
  <msup>
   <mi>λ</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>λ</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda^{-1}
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:99">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>≥</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mi>κ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>λ</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>κ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\geq 1/\kappa
  </annotation>
 </semantics>
</math>

, taking 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:100">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>κ</mi>
      <mi>ε</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <times></times>
      <ci>κ</ci>
      <ci>ε</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{0}=O(\kappa\varepsilon)
  </annotation>
 </semantics>
</math>

 induces a final error of 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:101">
 <semantics>
  <mi>ε</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

. This requires that the overall run-time efficiency be increased proportional to 

<math display="inline" id="Quantum_algorithm_for_linear_systems_of_equations:102">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mn>1</mn>
     <mi>ε</mi>
    </mfrac>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>ε</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(\frac{1}{\varepsilon}\right)
  </annotation>
 </semantics>
</math>

 to minimize error.</p>
<h2 id="experimental-realization">Experimental realization</h2>

<p>While there does not yet exist a quantum computer that can truly offer a speedup over a classical computer, implementation of a "proof of concept" remains an important milestone in the development of a new quantum algorithm. Demonstrating the quantum algorithm for linear systems of equations remained a challenge for years after its proposal until 2013 when it was demonstrated by Cai et al., Barz et al. and Pan et al. in parallel.</p>
<h3 id="cai-et-al.">Cai et al.</h3>

<p>Published in Physical Review Letters 110, 230501 (2013), Cai et al. reported an experimental demonstration of the simplest meaningful instance of this algorithm, that is, solving 2*2 linear equations for various input vectors. The quantum circuit is optimized and compiled into a linear optical network with four photonic quantum bits (qubits) and four controlled logic gates, which is used to coherently implement every subroutine for this algorithm. For various input vectors, the quantum computer gives solutions for the linear equations with reasonably high precision, ranging from fidelities of 0.825 to 0.993.</p>
<h3 id="barz-et-al.">Barz et al.</h3>

<p>On February 5, 2013, Barz et al. demonstrated the quantum algorithm for linear systems of equations on a photonic quantum computing architecture. This implementation used two consecutive entangling gates on the same pair of polarization-encoded qubits. Two separately controlled NOT gates were realized where the successful operation of the first was heralded by a measurement of two ancillary photons. Barz et al. found that the fidelity in the obtained output state ranged from 64.7% to 98.1% due to the influence of higher-order emissions from spontaneous parametric down-conversion.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h3 id="pan-et-al.">Pan et al.</h3>

<p>On February 8, 2013 Pan et al. reported a proof-of-concept experimental demonstration of the quantum algorithm using a 4-qubit nuclear magnetic resonance quantum information processor. The implementation was tested using simple linear systems of only 2 variables. Across three experiments they obtain the solution vector with over 96% fidelity.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="applications">Applications</h2>

<p>Quantum computers are devices that harness quantum mechanics to perform computations in ways that classical computers cannot. For certain problems, quantum algorithms supply exponential speedups over their classical counterparts, the most famous example being Shor's factoring algorithm. Few such exponential speedups are known, and those that are (such as the use of quantum computers to simulate other quantum systems) have so far found limited use outside the domain of quantum mechanics. This algorithm provides an exponentially faster method of estimating features of the solution of a set of linear equations, which is a problem ubiquitous in science an engineering, both on its own and as a subroutine in more complex problems.</p>
<h3 id="linear-differential-equation-solving">Linear differential equation solving</h3>

<p>Dominic Berry proposed a new algorithm for solving linear time dependent differential equations as an extension of the quantum algorithm for solving linear systems of equations. Berry provides an efficient algorithm for solving the full-time evolution under sparse linear differential equations on a quantum computer.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h3 id="least-squares-fitting">Least-squares fitting</h3>

<p>Wiebe et al. provide a new quantum algorithm to determine the quality of a <a href="least-squares_fit" title="wikilink">least-squares fit</a> in which a continuous function is used to approximate a set of discrete points by extending the quantum algorithm for linear systems of equations. As the amount of discrete points increases, the time required to produce a least-squares fit using even a quantum computer running a quantum state tomography algorithm becomes very large. Wiebe et al. find that in many cases, their algorithm can efficiently find a concise approximation of the data points, eliminating the need for the higher-complexity tomography algorithm.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h3 id="machine-learning-and-big-data-analysis">Machine learning and big data analysis</h3>

<p><a href="Machine_learning" title="wikilink">Machine learning</a> is the study of systems that can identify trends in data. Tasks in machine learning frequently involve manipulating and classifying a large volume of data in high-dimensional vector spaces. The runtime of classical machine learning algorithms is limited by a polynomial dependence on both the volume of data and the dimensions of the space. Quantum computers are capable of manipulating high-dimensional vectors using tensor product spaces are thus the perfect platform for machine learning algorithms.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>The quantum algorithm for linear systems of equations has been applied to a support vector machine, which is an optimized linear or non-linear binary classifier. A support vector machine can be used for supervised machine learning, in which training set of already classified data is available, or unsupervised machine learning, in which all data given to the system is unclassified. Rebentrost et al. show that a quantum support vector machine can be used for <a href="big_data" title="wikilink">big data</a> classification and achieve an exponential speedup over classical computers.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Quantum_algorithms" title="wikilink">Category:Quantum algorithms</a> <a href="Category:Integer_factorization_algorithms" title="wikilink">Category:Integer factorization algorithms</a> <a href="Category:Quantum_information_science" title="wikilink">Category:Quantum information science</a> <a href="Category:Articles_containing_proofs" title="wikilink">Category:Articles containing proofs</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://arxiv.org/abs/0811.3171">Quantum algorithm for solving linear systems of equations, by Harrow et al.</a>.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.110.230501">Experimental quantum computing to solve systems of linear equations by Cai et al.</a>.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://arxiv.org/abs/1302.1210v1">Solving systems of linear equations on a quantum computer by Barz et al.</a>.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="http://arxiv.org/abs/1302.1946">Experimental realization of quantum algorithm for solving linear systems of equations, by Pan et al.</a>.<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="http://www.2physics.com/2013/06/quantum-computer-runs-most-practically.html">Quantum Computer Runs The Most Practically Useful Quantum Algorithm, by Lu and Pan</a>.<a href="#fnref5">↩</a></li>
<li id="fn6">[ <a class="uri" href="http://arxiv.org/abs/1010.4458">http://arxiv.org/abs/1010.4458</a> Variable time amplitude amplification and a faster quantum algorithm for solving systems of linear equations by Adris Ambainis].<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="http://arxiv.org/abs/0811.3171">Quantum algorithm for solving linear systems of equations, by Harrow et al.</a>.<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="http://arxiv.org/abs/0811.3171">Quantum algorithm for solving linear systems of equations, by Harrow et al.</a>.<a href="#fnref8">↩</a></li>
<li id="fn9"><a href="http://arxiv.org/abs/1302.1210v1">Solving systems of linear equations on a quantum computer, by Barz et al.</a>.<a href="#fnref9">↩</a></li>
<li id="fn10"><a href="http://arxiv.org/abs/1302.1946">Experimental realization of quantum algorithm for solving linear systems of equations, by Pan et al.</a>.<a href="#fnref10">↩</a></li>
<li id="fn11">[ <a class="uri" href="http://arxiv.org/abs/1010.2745">http://arxiv.org/abs/1010.2745</a> High-order quantum algorithm for solving linear differential equations by Dominic Berry].<a href="#fnref11">↩</a></li>
<li id="fn12"><a href="http://arxiv.org/abs/1204.5242">Quantum Data Fitting by Wiebe et al.</a>.<a href="#fnref12">↩</a></li>
<li id="fn13"><a href="http://arxiv.org/abs/1307.0411">Quantum algorithms for supervised and unsupervised machine learning, by Lloyd et al.</a>.<a href="#fnref13">↩</a></li>
<li id="fn14"><a href="http://arxiv.org/pdf/1307.0471v2.pdf">Quantum support vector machine for big feature and big data classification, by Rebentrost et al.</a>.<a href="#fnref14">↩</a></li>
</ol>
</section>
</body>
</html>
