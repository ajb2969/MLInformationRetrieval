   CTL*      CTL*   CTL* is a superset of computational tree logic (CTL) and linear temporal logic (LTL). It freely combines path quantifiers and temporal operators. Like CTL, CTL* is a branching time logic. The formal semantics of CTL* formulae are defined with respect to a given Kripke structure .  History  LTL has been proposed for the verification of computer programs first by Amir Pnueli in 1977. Four years later in 1981 E. M. Clarke and E. A. Emerson invented CTL and CTL model checking. CTL* was defined by E. A. Emerson and Joseph Y. Halpern in 1986.  Interestingly, CTL and LTL have been developed independently before CTL*. Both sublogics have become standards in the model checking community, while CTL* is of practical importance because it provides an expressive testbed for representing and comparing these and other logics. This is surprising because the computational complexity of model checking in CTL* is not worse than that of LTL: they both lie in PSPACE .  Syntax  The language of well-formed CTL* formulae is generated by the following unambiguous (wrt bracketing) context-free grammar :      Φ  :  :=  ⊥  ∣  ⊤  ∣  p  ∣   (  ¬  Φ  )   ∣   (  Φ  and  Φ  )   ∣   (  Φ  Φ  )   ∣   (  Φ  ⇒  Φ  )   ∣   (  Φ  ⇔  Φ  )   ∣  A  ϕ  ∣  E  ϕ     fragments  Φ  normal-:  assign  bottom  normal-∣  top  normal-∣  p  normal-∣   fragments  normal-(   Φ  normal-)   normal-∣   fragments  normal-(  Φ  and  Φ  normal-)   normal-∣   fragments  normal-(  Φ  Φ  normal-)   normal-∣   fragments  normal-(  Φ  normal-⇒  Φ  normal-)   normal-∣   fragments  normal-(  Φ  normal-⇔  Φ  normal-)   normal-∣  A  ϕ  normal-∣  E  ϕ    \Phi::=\bot\mid\top\mid p\mid(\neg\Phi)\mid(\Phi\and\Phi)\mid(\Phi\Phi)\mid(%
 \Phi\Rightarrow\Phi)\mid(\Phi\Leftrightarrow\Phi)\mid A\phi\mid E\phi         ϕ  :  :=  Φ  ∣   (  ¬  ϕ  )   ∣   (  ϕ  and  ϕ  )   ∣   (  ϕ  ϕ  )   ∣   (  ϕ  ⇒  ϕ  )   ∣   (  ϕ  ⇔  ϕ  )   ∣  X  ϕ  ∣  F  ϕ  ∣  G  ϕ  ∣   [  ϕ  U  ϕ  ]      fragments  ϕ  normal-:  assign  Φ  normal-∣   fragments  normal-(   ϕ  normal-)   normal-∣   fragments  normal-(  ϕ  and  ϕ  normal-)   normal-∣   fragments  normal-(  ϕ  ϕ  normal-)   normal-∣   fragments  normal-(  ϕ  normal-⇒  ϕ  normal-)   normal-∣   fragments  normal-(  ϕ  normal-⇔  ϕ  normal-)   normal-∣  X  ϕ  normal-∣  F  ϕ  normal-∣  G  ϕ  normal-∣   fragments  normal-[  ϕ  U  ϕ  normal-]     \phi::=\Phi\mid(\neg\phi)\mid(\phi\and\phi)\mid(\phi\phi)\mid(\phi\Rightarrow%
 \phi)\mid(\phi\Leftrightarrow\phi)\mid X\phi\mid F\phi\mid G\phi\mid[\phi U\phi]     where   p   p   p   ranges over a set of atomic formulas . Valid CTL*-formulae are built using the nonterminal   Φ   normal-Φ   \Phi   . These formulae are called state formulae , while those created by the symbol   ϕ   ϕ   \phi   are called path formulae . (The above grammar contains some redundancies; for example    Φ  Φ      normal-Φ  normal-Φ    \Phi\Phi   as well as implication and equivalence can be defined as just for Boolean algebras (or propositional logic ) from negation and conjunction, and the temporal operators X and U are sufficient to define the other two .)  The operators basically are the same as in CTL . However, in CTL, every temporal operator (    X  ,  F  ,  G  ,  U     X  F  G  U    X,F,G,U   ) has to be directly preceded by a quantifier, while in CTL* this is not required. The universal path quantifier may be defined in CTL* in the same way as for classical predicate calculus      A  ϕ   =   ¬  E  ¬  ϕ         A  ϕ      E   ϕ     A\phi=\neg E\neg\phi   , although this in not possible in the CTL fragment.  Examples of formulae   CTL* formula that is neither in LTL or in CTL    E  X   (  p  )   and  A  F  G   (  p  )       E  X  p  italic- and  A  F  G  p    EX(p)\and AFG(p)     LTL formula that is not in CTL     A   F  G   (  p  )       A  F  G  p    \ AFG(p)     CTL formula that is not in LTL     E   X   (  p  )       E  X  p    \ EX(p)     CTL* formula that is in CTL and LTL     A   G   (  p  )       A  G  p    \ AG(p)      Remark: When taking LTL as subset of CTL*, any LTL formula is implicitly prefixed with the universal path quantifier    A    A   \ A     Semantics  The semantics of CTL* are defined with respect to some Kripke structure . As the names imply, state formulae are interpreted with respect to the states of this structure, while path formulae are interpreted over paths on it.  State formulae  If a state   s   s   s   of the Kripke structure satisfies a state formula   Φ   normal-Φ   \Phi   it is denoted    s  ⊧  Φ     models  s  normal-Φ    s\models\Phi   . This relation is defined inductively as follows:        (   (  ℳ  ,  s  )   ⊧  ⊤  )   ∧   (   (  ℳ  ,  s  )   ⊧̸  ⊥  )      fragments   fragments  normal-(   fragments  normal-(  M  normal-,  s  normal-)   models  top  normal-)     fragments  normal-(   fragments  normal-(  M  normal-,  s  normal-)   not-models  bottom  normal-)     \Big((\mathcal{M},s)\models\top\Big)\land\Big((\mathcal{M},s)\not\models\bot\Big)          (   (  ℳ  ,  s  )   ⊧  p  )   ⇔   (  p  ∈  L   (  s  )   )      fragments   fragments  normal-(   fragments  normal-(  M  normal-,  s  normal-)   models  p  normal-)   normal-⇔   fragments  normal-(  p   L   fragments  normal-(  s  normal-)   normal-)     \Big((\mathcal{M},s)\models p\Big)\Leftrightarrow\Big(p\in L(s)\Big)          (   (  ℳ  ,  s  )   ⊧  ¬  Φ  )   ⇔   (   (  ℳ  ,  s  )   ⊧̸  Φ  )      fragments   fragments  normal-(   fragments  normal-(  M  normal-,  s  normal-)   models   Φ  normal-)   normal-⇔   fragments  normal-(   fragments  normal-(  M  normal-,  s  normal-)   not-models  Φ  normal-)     \Big((\mathcal{M},s)\models\neg\Phi\Big)\Leftrightarrow\Big((\mathcal{M},s)%
 \not\models\Phi\Big)          (   (  ℳ  ,  s  )   ⊧   Φ  1   ∧   Φ  2   )   ⇔   (   (   (  ℳ  ,  s  )   ⊧   Φ  1   )   ∧   (   (  ℳ  ,  s  )   ⊧   Φ  2   )   )      fragments   fragments  normal-(   fragments  normal-(  M  normal-,  s  normal-)   models   subscript  normal-Φ  1     subscript  normal-Φ  2   normal-)   normal-⇔   fragments  normal-(   fragments  normal-(   fragments  normal-(  M  normal-,  s  normal-)   models   subscript  normal-Φ  1   normal-)     fragments  normal-(   fragments  normal-(  M  normal-,  s  normal-)   models   subscript  normal-Φ  2   normal-)   normal-)     \Big((\mathcal{M},s)\models\Phi_{1}\land\Phi_{2}\Big)\Leftrightarrow\Big(\big(%
 (\mathcal{M},s)\models\Phi_{1}\big)\land\big((\mathcal{M},s)\models\Phi_{2}%
 \big)\Big)          (   (  ℳ  ,  s  )   ⊧   Φ  1   ∨   Φ  2   )   ⇔   (   (   (  ℳ  ,  s  )   ⊧   Φ  1   )   ∨   (   (  ℳ  ,  s  )   ⊧   Φ  2   )   )      fragments   fragments  normal-(   fragments  normal-(  M  normal-,  s  normal-)   models   subscript  normal-Φ  1     subscript  normal-Φ  2   normal-)   normal-⇔   fragments  normal-(   fragments  normal-(   fragments  normal-(  M  normal-,  s  normal-)   models   subscript  normal-Φ  1   normal-)     fragments  normal-(   fragments  normal-(  M  normal-,  s  normal-)   models   subscript  normal-Φ  2   normal-)   normal-)     \Big((\mathcal{M},s)\models\Phi_{1}\lor\Phi_{2}\Big)\Leftrightarrow\Big(\big((%
 \mathcal{M},s)\models\Phi_{1}\big)\lor\big((\mathcal{M},s)\models\Phi_{2}\big)\Big)          (   (  ℳ  ,  s  )   ⊧   Φ  1   ⇒   Φ  2   )   ⇔   (   (   (  ℳ  ,  s  )   ⊧̸   Φ  1   )   ∨   (   (  ℳ  ,  s  )   ⊧   Φ  2   )   )      fragments   fragments  normal-(   fragments  normal-(  M  normal-,  s  normal-)   models   subscript  normal-Φ  1   normal-⇒   subscript  normal-Φ  2   normal-)   normal-⇔   fragments  normal-(   fragments  normal-(   fragments  normal-(  M  normal-,  s  normal-)   not-models   subscript  normal-Φ  1   normal-)     fragments  normal-(   fragments  normal-(  M  normal-,  s  normal-)   models   subscript  normal-Φ  2   normal-)   normal-)     \Big((\mathcal{M},s)\models\Phi_{1}\Rightarrow\Phi_{2}\Big)\Leftrightarrow\Big%
 (\big((\mathcal{M},s)\not\models\Phi_{1}\big)\lor\big((\mathcal{M},s)\models%
 \Phi_{2}\big)\Big)          (   (  ℳ  ,  s  )   ⊧   Φ  1   ⇔   Φ  2   )   ⇔   (   (   (   (  ℳ  ,  s  )   ⊧   Φ  1   )   ∧   (   (  ℳ  ,  s  )   ⊧   Φ  2   )   )   ∨   (  ¬   (   (  ℳ  ,  s  )   ⊧   Φ  1   )   ∧  ¬   (   (  ℳ  ,  s  )   ⊧   Φ  2   )   )   )      fragments   fragments  normal-(   fragments  normal-(  M  normal-,  s  normal-)   models   subscript  normal-Φ  1   normal-⇔   subscript  normal-Φ  2   normal-)   normal-⇔   fragments  normal-(   fragments  normal-(   fragments  normal-(   fragments  normal-(  M  normal-,  s  normal-)   models   subscript  normal-Φ  1   normal-)     fragments  normal-(   fragments  normal-(  M  normal-,  s  normal-)   models   subscript  normal-Φ  2   normal-)   normal-)     fragments  normal-(    fragments  normal-(   fragments  normal-(  M  normal-,  s  normal-)   models   subscript  normal-Φ  1   normal-)      fragments  normal-(   fragments  normal-(  M  normal-,  s  normal-)   models   subscript  normal-Φ  2   normal-)   normal-)   normal-)     \bigg((\mathcal{M},s)\models\Phi_{1}\Leftrightarrow\Phi_{2}\bigg)%
 \Leftrightarrow\bigg(\Big(\big((\mathcal{M},s)\models\Phi_{1}\big)\land\big((%
 \mathcal{M},s)\models\Phi_{2}\big)\Big)\lor\Big(\neg\big((\mathcal{M},s)%
 \models\Phi_{1}\big)\land\neg\big((\mathcal{M},s)\models\Phi_{2}\big)\Big)\bigg)          (   (  ℳ  ,  s  )   ⊧  A  ϕ  )   ⇔   (  π  ⊧  ϕ      fragments   fragments  normal-(   fragments  normal-(  M  normal-,  s  normal-)   models  A  ϕ  normal-)   normal-⇔   fragments  normal-(  π  models  ϕ     \Big((\mathcal{M},s)\models A\phi\Big)\Leftrightarrow\Big(\pi\models\phi   for all paths    π    π   \ \pi   starting in    s  )     fragments  s  normal-)    s\Big)          (   (  ℳ  ,  s  )   ⊧  E  ϕ  )   ⇔   (  π  ⊧  ϕ      fragments   fragments  normal-(   fragments  normal-(  M  normal-,  s  normal-)   models  E  ϕ  normal-)   normal-⇔   fragments  normal-(  π  models  ϕ     \Big((\mathcal{M},s)\models E\phi\Big)\Leftrightarrow\Big(\pi\models\phi   for some path    π    π   \ \pi   starting in    s  )     fragments  s  normal-)    s\Big)      Path formulae  The satisfaction relation    π  ⊧  ϕ     models  π  ϕ    \pi\models\phi   for path formulae    ϕ    ϕ   \ \phi   and a path    π  =   s  0   →   s  1   →  ⋯        π   subscript  s  0     normal-→     subscript  s  1     normal-→    normal-⋯     \pi=s_{0}\to s_{1}\to\cdots   is also defined inductively. For this, let     π    [  n  ]       π   delimited-[]  n     \ \pi[n]   denote the sub-path     s  n   →   s   n  +  1    →  ⋯       normal-→   subscript  s  n    subscript  s    n  1      normal-→    normal-⋯     s_{n}\to s_{n+1}\to\cdots   :        (  π  ⊧  Φ  )   ⇔   (   (  ℳ  ,   s  0   )   ⊧  Φ  )      fragments   fragments  normal-(  π  models  Φ  normal-)   normal-⇔   fragments  normal-(   fragments  normal-(  M  normal-,   subscript  s  0   normal-)   models  Φ  normal-)     \Big(\pi\models\Phi\Big)\Leftrightarrow\Big((\mathcal{M},s_{0})\models\Phi\Big)          (  π  ⊧  ¬  ϕ  )   ⇔   (  π  ⊧̸  ϕ  )      fragments   fragments  normal-(  π  models   ϕ  normal-)   normal-⇔   fragments  normal-(  π  not-models  ϕ  normal-)     \Big(\pi\models\neg\phi\Big)\Leftrightarrow\Big(\pi\not\models\phi\Big)          (  π  ⊧   ϕ  1   ∧   ϕ  2   )   ⇔   (   (  π  ⊧   ϕ  1   )   ∧   (  π  ⊧   ϕ  2   )   )      fragments   fragments  normal-(  π  models   subscript  ϕ  1     subscript  ϕ  2   normal-)   normal-⇔   fragments  normal-(   fragments  normal-(  π  models   subscript  ϕ  1   normal-)     fragments  normal-(  π  models   subscript  ϕ  2   normal-)   normal-)     \Big(\pi\models\phi_{1}\land\phi_{2}\Big)\Leftrightarrow\Big(\big(\pi\models%
 \phi_{1}\big)\land\big(\pi\models\phi_{2}\big)\Big)          (  π  ⊧   ϕ  1   ∨   ϕ  2   )   ⇔   (   (  π  ⊧   ϕ  1   )   ∨   (  π  ⊧   ϕ  2   )   )      fragments   fragments  normal-(  π  models   subscript  ϕ  1     subscript  ϕ  2   normal-)   normal-⇔   fragments  normal-(   fragments  normal-(  π  models   subscript  ϕ  1   normal-)     fragments  normal-(  π  models   subscript  ϕ  2   normal-)   normal-)     \Big(\pi\models\phi_{1}\lor\phi_{2}\Big)\Leftrightarrow\Big(\big(\pi\models%
 \phi_{1}\big)\lor\big(\pi\models\phi_{2}\big)\Big)          (  π  ⊧   ϕ  1   ⇒   ϕ  2   )   ⇔   (   (  π  ⊧̸   ϕ  1   )   ∨   (  π  ⊧   ϕ  2   )   )      fragments   fragments  normal-(  π  models   subscript  ϕ  1   normal-⇒   subscript  ϕ  2   normal-)   normal-⇔   fragments  normal-(   fragments  normal-(  π  not-models   subscript  ϕ  1   normal-)     fragments  normal-(  π  models   subscript  ϕ  2   normal-)   normal-)     \Big(\pi\models\phi_{1}\Rightarrow\phi_{2}\Big)\Leftrightarrow\Big(\big(\pi%
 \not\models\phi_{1}\big)\lor\big(\pi\models\phi_{2}\big)\Big)          (  π  ⊧   ϕ  1   ⇔   ϕ  2   )   ⇔   (   (   (  π  ⊧   ϕ  1   )   ∧   (  π  ⊧   ϕ  2   )   )   ∨   (  ¬   (  π  ⊧   ϕ  1   )   ∧  ¬   (  π  ⊧   ϕ  2   )   )   )      fragments   fragments  normal-(  π  models   subscript  ϕ  1   normal-⇔   subscript  ϕ  2   normal-)   normal-⇔   fragments  normal-(   fragments  normal-(   fragments  normal-(  π  models   subscript  ϕ  1   normal-)     fragments  normal-(  π  models   subscript  ϕ  2   normal-)   normal-)     fragments  normal-(    fragments  normal-(  π  models   subscript  ϕ  1   normal-)      fragments  normal-(  π  models   subscript  ϕ  2   normal-)   normal-)   normal-)     \bigg(\pi\models\phi_{1}\Leftrightarrow\phi_{2}\bigg)\Leftrightarrow\bigg(\Big%
 (\big(\pi\models\phi_{1}\big)\land\big(\pi\models\phi_{2}\big)\Big)\lor\Big(%
 \neg\big(\pi\models\phi_{1}\big)\land\neg\big(\pi\models\phi_{2}\big)\Big)\bigg)          (  π  ⊧  X  ϕ  )   ⇔   (  π   [  1  ]   ⊧  ϕ  )      fragments   fragments  normal-(  π  models  X  ϕ  normal-)   normal-⇔   fragments  normal-(  π   fragments  normal-[  1  normal-]   models  ϕ  normal-)     \Big(\pi\models X\phi\Big)\Leftrightarrow\Big(\pi[1]\models\phi\Big)          (  π  ⊧  F  ϕ  )   ⇔   (  ∃  n  ⩾  0  :  π   [  n  ]   ⊧  ϕ  )      fragments   fragments  normal-(  π  models  F  ϕ  normal-)   normal-⇔   fragments  normal-(   n   0  normal-:  π   fragments  normal-[  n  normal-]   models  ϕ  normal-)     \Big(\pi\models F\phi\Big)\Leftrightarrow\Big(\exists n\geqslant 0:\pi[n]%
 \models\phi\Big)          (  π  ⊧  G  ϕ  )   ⇔   (  ∀  n  ⩾  0  :  π   [  n  ]   ⊧  ϕ  )      fragments   fragments  normal-(  π  models  G  ϕ  normal-)   normal-⇔   fragments  normal-(  for-all  n   0  normal-:  π   fragments  normal-[  n  normal-]   models  ϕ  normal-)     \Big(\pi\models G\phi\Big)\Leftrightarrow\Big(\forall n\geqslant 0:\pi[n]%
 \models\phi\Big)          (  π  ⊧   [   ϕ  1   U   ϕ  2   ]   )   ⇔   (  ∃  n  ⩾  0  :   (  π   [  n  ]   ⊧   ϕ  2   ∧  ∀  0  ⩽  k  <  n  :  π   [  k  ]   ⊧   ϕ  1   )   )      fragments   fragments  normal-(  π  models   fragments  normal-[   subscript  ϕ  1   U   subscript  ϕ  2   normal-]   normal-)   normal-⇔   fragments  normal-(   n   0  normal-:   fragments  normal-(  π   fragments  normal-[  n  normal-]   models   subscript  ϕ  2    for-all  0   k   n  normal-:  π   fragments  normal-[  k  normal-]   models   subscript  ϕ  1   normal-)   normal-)     \Big(\pi\models[\phi_{1}U\phi_{2}]\Big)\Leftrightarrow\Big(\exists n\geqslant 0%
 :\big(\pi[n]\models\phi_{2}\land\forall 0\leqslant k      See also   Temporal logic  Kripke structure  Model checking  Reo Coordination Language   References   Amir Pnueli : The temporal logic of programs. Proceedings of the 18th Annual Symposium on Foundations of Computer Science (FOCS), 1977, 46–57. DOI= 10.1109/SFCS.1977.32  E. Allen Emerson , Joseph Y. Halpern : "Sometimes" and "not never" revisited: on branching versus linear time temporal logic. J. ACM 33, 1 (Jan. 1986), 151–178. DOI= http://doi.acm.org/10.1145/4904.4999  Ph. Schnoebelen: The Complexity of Temporal Logic Model Checking. Advances in Modal Logic 2002: 393–436   External links   CTL Teaching slides of professor Alessandro Artale at the Free University of Bozen-Bolzano   "  Category:Logic in computer science  Category:Temporal logic   