   Reedâ€“Muller code      Reedâ€“Muller code   Reedâ€“Muller codes are a family of linear  error-correcting codes used in communications. Reedâ€“Muller codes belong to the classes of locally testable codes and locally decodable codes , which is why they are useful in the design of probabilistically checkable proofs in computational complexity theory . They are named after Irving S. Reed and David E. Muller . Muller discovered the codes, and Reed proposed the majority logic decoding for the first time. Special cases of Reedâ€“Muller codes include the Hadamard code , the Walshâ€“Hadamard code , and the Reedâ€“Solomon code .  Reedâ€“Muller codes are listed as RM( d , r ), where d is the order of the code, and r determines the length of code, n =Â 2  r . RM codes are related to binary functions on the field GF(2  r ) over the elements {0,Â 1}.  RM(0, r ) codes are repetition codes of length n =Â 2  r , rate    R  =   1  n       R    1  n     {R=\tfrac{1}{n}}   and minimum distance d min = n .  RM(1, r ) codes are parity check codes of length n =Â 2  r , rate    R  =    r  +  1   n       R      r  1   n     R=\tfrac{r+1}{n}   and minimum distance     d  min   =   n  2        subscript  d      n  2     d_{\min}=\tfrac{n}{2}   .  RM( r âˆ’Â 1, r ) codes are parity check codes of length n =Â 2  r .  RM( r âˆ’Â 2, r ) codes are the family of extended Hamming codes of length n =Â 2  r with minimum distance d min =Â 4. 1  Construction  A generator matrix for a Reedâ€“Muller code of length n = 2 d can be constructed as follows. Let us write:       X  =   ğ”½  2  d   =   {   x  1   ,  â€¦  ,   x   2  d    }    .        X   superscript   subscript  ğ”½  2   d          subscript  x  1   normal-â€¦   subscript  x   superscript  2  d        X=\mathbb{F}_{2}^{d}=\{x_{1},\ldots,x_{2^{d}}\}.     Note that each member of the set X is a point in    ğ”½  2  d     superscript   subscript  ğ”½  2   d    \mathbb{F}_{2}^{d}   . We define in n-dimensional space    ğ”½  2  n     superscript   subscript  ğ”½  2   n    \mathbb{F}_{2}^{n}   the indicator vectors       ğ•€  A   âˆˆ   ğ”½  2  n        subscript  ğ•€  A    superscript   subscript  ğ”½  2   n     \mathbb{I}_{A}\in\mathbb{F}_{2}^{n}     on subsets    A  âŠ‚  X      A  X    A\subset X   by:        (   ğ•€  A   )   i   =   {     1      if   x  i    âˆˆ  A       0    otherwise           subscript   subscript  ğ•€  A   i    cases  1      if   subscript  x  i    A   0  otherwise     \left(\mathbb{I}_{A}\right)_{i}=\begin{cases}1&\mbox{ if }x_{i}\in A\\
 0&\mbox{ otherwise}\\
 \end{cases}     together with, also in    ğ”½  2  n     superscript   subscript  ğ”½  2   n    \mathbb{F}_{2}^{n}   , the binary operation        w  âˆ§  z   =   (    w  1   â‹…   z  1    ,  â€¦  ,    w  n   â‹…   z  n    )    ,        w  z     normal-â‹…   subscript  w  1    subscript  z  1    normal-â€¦   normal-â‹…   subscript  w  n    subscript  z  n       w\wedge z=(w_{1}\cdot z_{1},\ldots,w_{n}\cdot z_{n}),     referred to as the wedge product (this wedge product is not to be confused with the wedge product defined in exterior algebra). Here,    w  =   (   w  1   ,   w  2   ,  â€¦  ,   w  n   )       w    subscript  w  1    subscript  w  2   normal-â€¦   subscript  w  n      w=(w_{1},w_{2},\ldots,w_{n})   and    z  =   (   z  1   ,   z  2   ,  â€¦  ,   z  n   )       z    subscript  z  1    subscript  z  2   normal-â€¦   subscript  z  n      z=(z_{1},z_{2},\ldots,z_{n})   are points in    ğ”½  2  n     superscript   subscript  ğ”½  2   n    \mathbb{F}_{2}^{n}   , and the operation   â‹…   normal-â‹…   \cdot   is the usual multiplication in the field    ğ”½  2     subscript  ğ”½  2    \mathbb{F}_{2}   .      ğ”½  2  d     superscript   subscript  ğ”½  2   d    \mathbb{F}_{2}^{d}   is a d -dimensional vector space over the field    ğ”½  2     subscript  ğ”½  2    \mathbb{F}_{2}   , so it is possible to write        (   ğ”½  2   )   d   =   {   (   y  d   ,  â€¦  ,   y  1   )   |    y  i   âˆˆ   ğ”½  2    }        superscript   subscript  ğ”½  2   d    conditional-set    subscript  y  d   normal-â€¦   subscript  y  1       subscript  y  i    subscript  ğ”½  2       (\mathbb{F}_{2})^{d}=\{(y_{d},\ldots,y_{1})|y_{i}\in\mathbb{F}_{2}\}     We define in n -dimensional space    ğ”½  2  n     superscript   subscript  ğ”½  2   n    \mathbb{F}_{2}^{n}   the following vectors with length n : v 0 =Â (1,Â 1,Â 1,Â 1,Â 1,Â 1,Â 1,Â 1) and       v  i   =   ğ•€   H  i         subscript  v  i    subscript  ğ•€   subscript  H  i      v_{i}=\mathbb{I}_{H_{i}}     where the H i are hyperplanes in     (   ğ”½  2   )   d     superscript   subscript  ğ”½  2   d    (\mathbb{F}_{2})^{d}   (with dimension dÂ âˆ’1):       H  i   =   {   y  âˆˆ    (   ğ”½  2   )   d    âˆ£    y  i   =  0   }        subscript  H  i    conditional-set    y   superscript   subscript  ğ”½  2   d       subscript  y  i   0      H_{i}=\{y\in(\mathbb{F}_{2})^{d}\mid y_{i}=0\}     Building a generator matrix  The Reedâ€“Muller RM( d , r ) code of order d and length n =Â 2 r is the code generated by v 0 and the wedge products of up to r of the v i (where by convention a wedge product of fewer than one vector is the identity for the operation). In other words, we can build a generator matrix for RM( d , r ) code, using vectors and their wedge product permutations up to the r at a time     v  0   ,   v  1   ,  â€¦  ,   v  d   ,  â€¦  ,   (    v  i   âˆ§   v  j    )   ,   â€¦   (    v  i   âˆ§    v  j   â€¦   âˆ§   v  r    )        subscript  v  0    subscript  v  1   normal-â€¦   subscript  v  d   normal-â€¦     subscript  v  i    subscript  v  j      normal-â€¦     subscript  v  i      subscript  v  j   normal-â€¦    subscript  v  r       {v_{0},v_{1},\ldots,v_{d},\ldots,(v_{i}\wedge v_{j}),\ldots(v_{i}\wedge v_{j}%
 \ldots\wedge v_{r})}   , as the rows of the generator matrix.  Example 1  Let m = 3. Then n = 8, and       X  =   ğ”½  2  3   =   {   (  0  ,  0  ,  0  )   ,   (  0  ,  0  ,  1  )   ,  â€¦  ,   (  1  ,  1  ,  1  )   }    ,        X   superscript   subscript  ğ”½  2   3          0  0  0    0  0  1   normal-â€¦   1  1  1       X=\mathbb{F}_{2}^{3}=\{(0,0,0),(0,0,1),\ldots,(1,1,1)\},     and         v  0     =     (  1  ,  1  ,  1  ,  1  ,  1  ,  1  ,  1  ,  1  )        v  1     =     (  1  ,  0  ,  1  ,  0  ,  1  ,  0  ,  1  ,  0  )        v  2     =     (  1  ,  1  ,  0  ,  0  ,  1  ,  1  ,  0  ,  0  )        v  3     =      (  1  ,  1  ,  1  ,  1  ,  0  ,  0  ,  0  ,  0  )   .          subscript  v  0     1  1  1  1  1  1  1  1      subscript  v  1     1  0  1  0  1  0  1  0      subscript  v  2     1  1  0  0  1  1  0  0      subscript  v  3     1  1  1  1  0  0  0  0      \begin{matrix}v_{0}&=&(1,1,1,1,1,1,1,1)\\
 v_{1}&=&(1,0,1,0,1,0,1,0)\\
 v_{2}&=&(1,1,0,0,1,1,0,0)\\
 v_{3}&=&(1,1,1,1,0,0,0,0).\\
 \end{matrix}     The RM(1,3) code is generated by the set       {   v  0   ,   v  1   ,   v  2   ,   v  3   }   ,      subscript  v  0    subscript  v  1    subscript  v  2    subscript  v  3     \{v_{0},v_{1},v_{2},v_{3}\},\,     or more explicitly by the rows of the matrix      (     1    1    1    1    1    1    1    1      1    0    1    0    1    0    1    0      1    1    0    0    1    1    0    0      1    1    1    1    0    0    0    0     )      1  1  1  1  1  1  1  1    1  0  1  0  1  0  1  0    1  1  0  0  1  1  0  0    1  1  1  1  0  0  0  0     \begin{pmatrix}1&1&1&1&1&1&1&1\\
 1&0&1&0&1&0&1&0\\
 1&1&0&0&1&1&0&0\\
 1&1&1&1&0&0&0&0\\
 \end{pmatrix}     Example 2  The RM(2,3) code is generated by the set:      {   v  0   ,   v  1   ,   v  2   ,   v  3   ,    v  1   âˆ§   v  2    ,    v  1   âˆ§   v  3    ,    v  2   âˆ§   v  3    }      subscript  v  0    subscript  v  1    subscript  v  2    subscript  v  3      subscript  v  1    subscript  v  2       subscript  v  1    subscript  v  3       subscript  v  2    subscript  v  3      \{v_{0},v_{1},v_{2},v_{3},v_{1}\wedge v_{2},v_{1}\wedge v_{3},v_{2}\wedge v_{3}\}     or more explicitly by the rows of the matrix:      (     1    1    1    1    1    1    1    1      1    0    1    0    1    0    1    0      1    1    0    0    1    1    0    0      1    1    1    1    0    0    0    0      1    0    0    0    1    0    0    0      1    0    1    0    0    0    0    0      1    1    0    0    0    0    0    0     )      1  1  1  1  1  1  1  1    1  0  1  0  1  0  1  0    1  1  0  0  1  1  0  0    1  1  1  1  0  0  0  0    1  0  0  0  1  0  0  0    1  0  1  0  0  0  0  0    1  1  0  0  0  0  0  0     \begin{pmatrix}1&1&1&1&1&1&1&1\\
 1&0&1&0&1&0&1&0\\
 1&1&0&0&1&1&0&0\\
 1&1&1&1&0&0&0&0\\
 1&0&0&0&1&0&0&0\\
 1&0&1&0&0&0&0&0\\
 1&1&0&0&0&0&0&0\\
 \end{pmatrix}     Properties  The following properties hold:  1 The set of all possible wedge products of up to d of the v i form a basis for    ğ”½  2  n     superscript   subscript  ğ”½  2   n    \mathbb{F}_{2}^{n}   .  2 The RMâ€‰( d , r ) code has rank          âˆ‘   s  =  0   r    (      d      s      )    .      superscript   subscript     s  0    r    binomial  d  s     \sum_{s=0}^{r}{d\choose s}.        3 RMâ€‰( d , r ) = RMâ€‰( d âˆ’ 1, ''r ) | RMâ€‰( d'' âˆ’ 1, r âˆ’ 1) where '|' denotes the bar product of two codes.  4 RMâ€‰( d , r ) has minimum Hamming weight 2 r âˆ’ d .  Proof  1   There are           âˆ‘   s  =  0   d    (      d      s      )    =   2  d   =  n          superscript   subscript     s  0    d    binomial  d  s     superscript  2  d        n     \sum_{s=0}^{d}{d\choose s}=2^{d}=n         such vectors and    ğ”½  2  n     superscript   subscript  ğ”½  2   n    \mathbb{F}_{2}^{n}   has dimension n so it is sufficient to check that the n vectors span; equivalently it is sufficient to check that RM(d, d) =    ğ”½  2  n     superscript   subscript  ğ”½  2   n    \mathbb{F}_{2}^{n}   .    Let x be an element of X and define          y  i   =   {      v  i       if   x  i    =  0        1  +   v  i        if   x  i    =  1            subscript  y  i    cases   subscript  v  i       if   subscript  x  i    0     1   subscript  v  i        if   subscript  x  i    1      y_{i}=\begin{cases}v_{i}&\mbox{ if }x_{i}=0\\
 1+v_{i}&\mbox{ if }x_{i}=1\\
 \end{cases}         Then     ğ•€   {  x  }    =    y  i   âˆ§  â€¦  âˆ§   y  d         subscript  ğ•€   x       subscript  y  i   normal-â€¦   subscript  y  d      \mathbb{I}_{\{x\}}=y_{i}\wedge\ldots\wedge y_{d}       Expansion via the distributivity of the wedge product gives     ğ•€   {  x  }    âˆˆ  RM(d,d)       subscript  ğ•€   x    RM(d,d)    \mathbb{I}_{\{x\}}\in\mbox{ RM(d,d)}   . Then since the vectors    {   ğ•€   {  x  }    âˆ£   x  âˆˆ  X   }     conditional-set   subscript  ğ•€   x      x  X     \{\mathbb{I}_{\{x\}}\mid x\in X\}   span    ğ”½  2  n     superscript   subscript  ğ”½  2   n    \mathbb{F}_{2}^{n}   we have RM(d, d) =    ğ”½  2  n     superscript   subscript  ğ”½  2   n    \mathbb{F}_{2}^{n}   .   2   By 1 , all such wedge products must be linearly independent, so the rank of RM(d, r) must simply be the number of such vectors.   3   Omitted.   4   By induction.    The RM( d ,Â 0) code is the repetition code of length n =2 d and weight n = 2 d âˆ’0 = 2 d âˆ’0 . By 1 RM( d , d ) =    ğ”½  2  n     superscript   subscript  ğ”½  2   n    \mathbb{F}_{2}^{n}   and has weight 1 = 2 0 = 2 d âˆ’ d .    The article bar product (coding theory) gives a proof that the weight of the bar product of two codes C 1 , C 2 is given by         min   {   2  w   (   C  1   )    ,   w   (   C  2   )    }         2  w   subscript  C  1      w   subscript  C  2      \min\{2w(C_{1}),w(C_{2})\}         If 0 d âˆ’1âˆ’ r   ii) RM(d-1,r-1) has weight 2 d âˆ’1âˆ’( r âˆ’1) = 2 d âˆ’ r       then the bar product has weight           min   {   2  Ã—   2   d  -  1  -  r     ,   2   d  -  r    }    =   2   d  -  r     .          2   superscript  2    d  1  r      superscript  2    d  r      superscript  2    d  r      \min\{2\times 2^{d-1-r},2^{d-r}\}=2^{d-r}.        Alternative construction  A Reedâ€“Muller code RM(r,m) exists for any integers    m  â‰¥  0      m  0    m\geq 0   and    0  â‰¤  r  â‰¤  m        0  r       m     0\leq r\leq m   . RM( m , m ) is defined as the universe (     2  m   ,   2  m   ,  1      superscript  2  m    superscript  2  m   1    2^{m},2^{m},1   ) code. RM(âˆ’1,m) is defined as the trivial code (     2  m   ,  0  ,  âˆ      superscript  2  m   0     2^{m},0,\infty   ). The remaining RM codes may be constructed from these elementary codes using the length-doubling construction        R  M   (  r  ,  m  )    =   {   (  ğ®  ,   ğ®  +  ğ¯   )   |    ğ®  âˆˆ   R  M   (  r  ,   m  -  1   )     ,   ğ¯  âˆˆ   R  M   (   r  -  1   ,   m  -  1   )      }    .        R  M   r  m     conditional-set   ğ®    ğ®  ğ¯     formulae-sequence    ğ®    R  M   r    m  1        ğ¯    R  M     r  1     m  1          RM(r,m)=\{(\mathbf{u},\mathbf{u}+\mathbf{v})|\mathbf{u}\in RM(r,m-1),\mathbf{v%
 }\in RM(r-1,m-1)\}.     From this construction, RM(r,m) is a binary linear block code ( n , k , d ) with length n =Â 2  m , dimension     k   (  r  ,  m  )    =    k   (  r  ,   m  -  1   )    +   k   (   r  -  1   ,   m  -  1   )           k   r  m        k   r    m  1       k     r  1     m  1        k(r,m)=k(r,m-1)+k(r-1,m-1)   and minimum distance    d  =   2   m  -  r        d   superscript  2    m  r      d=2^{m-r}   for    r  â‰¥  0      r  0    r\geq 0   . The dual code to RM(r,m) is RM(m-r-1,m). This shows that repetition and SPC codes are duals, biorthogonal and extended Hamming codes are duals and that codes with k=n/2 are self-dual.  Construction based on low-degree polynomials over a finite field  There is another, simple way to construct Reedâ€“Muller codes based on low-degree polynomials over a finite field. This construction is particularly suited for their application as locally testable codes and locally decodable codes . 2  Let   ğ”½   ğ”½   \mathbb{F}   be a finite field and let   m   m   m   and   d   d   d   be positive integers, where   m   m   m   should be thought of as larger than   d   d   d   . We are going to encode messages consisting of    (       m  +  d       m      )     binomial    m  d   m    {m+d\choose m}   elements of   ğ”½   ğ”½   \mathbb{F}   as codewords of length     |  ğ”½  |   m     superscript    ğ”½   m    |\mathbb{F}|^{m}   as follows: We interpret the message as an   m   m   m   -variate polynomial   f   f   f   of degree at most   d   d   d   with coefficient from   ğ”½   ğ”½   \mathbb{F}   . Such a polynomial has    (       m  +  d       m      )     binomial    m  d   m    {m+d\choose m}   coefficients. The Reedâ€“Muller encoding of   f   f   f   is the list of the evaluations of   f   f   f   on all    x  âˆˆ   ğ”½  m       x   superscript  ğ”½  m     x\in\mathbb{F}^{m}   ; the codeword at the position indexed by    x  âˆˆ   ğ”½  m       x   superscript  ğ”½  m     x\in\mathbb{F}^{m}   has value    f   (  x  )       f  x    f(x)   .  Table of Reedâ€“Muller codes  The table below lists the RM( r , m ) codes of lengths up to 32.            RM(m,m) (     2  m   ,   2  m   ,  1      superscript  2  m    superscript  2  m   1    2^{m},2^{m},1   )   universe codes          RM(5,5) (32,32,1)         RM(4,4) (16,16,1)    RM( m âˆ’Â 1, m ) (     2  m   ,    2  m   -  1   ,  2      superscript  2  m      superscript  2  m   1   2    2^{m},2^{m}-1,2   )   SPC codes        RM(3,3) (8,8,1)    RM(4,5) (32,31,2)       RM(2,2) (4,4,1)    RM(3,4) (16,15,2)    RM( m âˆ’Â 2, m ) (     2  m   ,    2  m   -  m  -  1   ,  4      superscript  2  m      superscript  2  m   m  1   4    2^{m},2^{m}-m-1,4   )   ext. Hamming codes      RM(1,1) (2,2,1)    RM(2,3) (8,7,2)    RM(3,5) (32,26,4)     RM(0,0) (1,1,1)    RM(1,2) (4,3,2)    RM(2,4) (16,11,4)      RM(0,1) (2,1,2)    RM(1,3) (8,4,4)    RM(2,5) (32,16,8)    self-dual codes     RM(âˆ’1,0) (1,0,   âˆ     \infty   )    RM(0,2) (4,1,4)    RM(1,4) (16,5,8)      RM(-1,1) (2,0,   âˆ     \infty   )    RM(0,3) (8,1,8)    RM(1,5) (32,6,16)       RM(-1,2) (4,0,   âˆ     \infty   )    RM(0,4) (16,1,16)    RM(1,m) (     2  m   ,   m  +  1   ,   2   m  -  1        superscript  2  m     m  1    superscript  2    m  1      2^{m},m+1,2^{m-1}   )   biorthogonal codes        RM(âˆ’1,3) (8,0,   âˆ     \infty   )    RM(0,5) (32,1,32)         RM(âˆ’1,4) (16,0,   âˆ     \infty   )    RM(0,m) (     2  m   ,  1  ,   2  m       superscript  2  m   1   superscript  2  m     2^{m},1,2^{m}   )   repetition codes          RM(âˆ’1,5) (32,0,   âˆ     \infty   )           RM(-1,m) (     2  m   ,  0  ,  âˆ      superscript  2  m   0     2^{m},0,\infty   )   trivial codes     Decoding RM codes  RM( r , m ) codes can be decoded using majority logic decoding . The basic idea of majority logic decoding is to build several checksums for each received code word element. Since each of the different checksums must all have the same value (i.e. the value of the message word element weight), we can use a majority logic decoding to decipher the value of the message word element. Once each order of the polynomial is decoded, the received word is modified accordingly by removing the corresponding codewords weighted by the decoded message contributions, up to the present stage. So for a r th order RM code, we have to decode iteratively r+1, times before we arrive at the final received code-word. Also, the values of the message bits are calculated through this scheme; finally we can calculate the codeword by multiplying the message word (just decoded) with the generator matrix.  One clue if the decoding succeeded, is to have an all-zero modified received word, at the end of ( r +Â 1)-stage decoding through the majority logic decoding. This technique was proposed by Irving S. Reed, and is more general when applied to other finite geometry codes.  Notes  References  Research Articles:   D. E. Muller. Application of boolean algebra to switching circuit design and to error detection. IRE Transactions on Electronic Computers, 3:6â€“12, 1954.  Irving S. Reed. A class of multiple-error-correcting codes and the decoding scheme. Transactions of the IRE Professional Group on Information Theory, 4:38â€“49, 1954.   Textbooks:    Chapter 4.   Chapter 4.5.   External links   MIT OpenCourseWare , 6.451 Principles of Digital Communication II, Lecture Notes section 6.4  GPL Matlab-implementation of RM-codes  [ http://octave.svn.sourceforge.net/viewvc/octave/trunk/octave-forge/main/comm/inst/reedmullergen.m?revision=9852&view; ;=markup Source GPL Matlab-implementation of RM-codes]   "  Category:Error detection and correction  Category:Coding theory     Trellis and Turbo Coding, C. Schlegel & L. Perez, Wiley Interscience, 2004, p149. â†©  Prahladh Harsha et al., Limits of Approximation Algorithms: PCPs and Unique Games (DIMACS Tutorial Lecture Notes) , Section 5.2.1. â†©     