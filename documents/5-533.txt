   Left recursion      Left recursion   In the formal language theory of computer science , left recursion is a special case of recursion where a string is recognized as part of a language by the fact that it decomposes into a string from that same language (on the left) and a suffix (on the right). For instance,    1  +  2  +  3      1  2  3    1+2+3   can be recognized as a sum because it can be broken into    1  +  2      1  2    1+2   , also a sum, and    +  3      3    {}+3   , a suitable suffix.  In terms of context-free grammar , a nonterminal is left-recursive if the leftmost symbol in one of its productions is itself (in the case of direct left recursion) or can be made itself by some sequence of substitutions (in the case of indirect left recursion).  Definition  A grammar is left-recursive if and only if there exists a nonterminal symbol   A   A   A   that can derive to a sentential form with itself as the leftmost symbol. 1 Symbolically,      A   ⇒  +    A  α       superscript  normal-⇒    A    A  α     A\Rightarrow^{+}A\alpha   , where    ⇒  +     superscript  normal-⇒     \Rightarrow^{+}   indicates the operation of making one or more substitutions, and   α   α   \alpha   is any sequence of terminal and nonterminal symbols.  Direct left recursion  Direct left recursion occurs when the definition can be satisfied with only one substitution. It requires a rule of the form      A  →   A  α      normal-→  A    A  α     A\to A\alpha   where   α   α   \alpha   is a sequence of nonterminals and terminals. For example, the rule      𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛  →   𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛  +  𝑇𝑒𝑟𝑚      normal-→  𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛    𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛  𝑇𝑒𝑟𝑚     \mathit{Expression}\to\mathit{Expression}+\mathit{Term}   is directly left-recursive. A left-to-right recursive descent parser for this rule might look like  function Expression()
 {
     Expression();  match('+');  Term();
 }  and such code would fall into infinite recursion when executed.  Indirect left recursion  Indirect left recursion occurs when the definition is satisfied via several substitutions. It entails a set of rules following the pattern       A  0   →    β  0    A  1    α  0       normal-→   subscript  A  0      subscript  β  0    subscript  A  1    subscript  α  0      A_{0}\to\beta_{0}A_{1}\alpha_{0}          A  1   →    β  1    A  2    α  1       normal-→   subscript  A  1      subscript  β  1    subscript  A  2    subscript  α  1      A_{1}\to\beta_{1}A_{2}\alpha_{1}        ⋯   normal-⋯   \cdots          A  n   →    β  n    A  0    α  n       normal-→   subscript  A  n      subscript  β  n    subscript  A  0    subscript  α  n      A_{n}\to\beta_{n}A_{0}\alpha_{n}   where     β  0   ,   β  1   ,  …  ,   β  n       subscript  β  0    subscript  β  1   normal-…   subscript  β  n     \beta_{0},\beta_{1},\ldots,\beta_{n}   are sequences that can each yield the empty string, while     α  0   ,   α  1   ,  …  ,   α  n       subscript  α  0    subscript  α  1   normal-…   subscript  α  n     \alpha_{0},\alpha_{1},\ldots,\alpha_{n}   may be any sequences at all. The derivation       A  0   ⇒    β  0    A  1    α  0     ⇒  +     A  1    α  0    ⇒    β  1    A  2    α  1    α  0     ⇒  +   ⋯   ⇒  +     A  0    α  n   …   α  1    α  0         normal-⇒   subscript  A  0      subscript  β  0    subscript  A  1    subscript  α  0       superscript  normal-⇒         subscript  A  1    subscript  α  0      normal-⇒       subscript  β  1    subscript  A  2    subscript  α  1    subscript  α  0       superscript  normal-⇒      normal-⋯     superscript  normal-⇒         subscript  A  0    subscript  α  n   normal-…   subscript  α  1    subscript  α  0       A_{0}\Rightarrow\beta_{0}A_{1}\alpha_{0}\Rightarrow^{+}A_{1}\alpha_{0}%
 \Rightarrow\beta_{1}A_{2}\alpha_{1}\alpha_{0}\Rightarrow^{+}\cdots\Rightarrow^%
 {+}A_{0}\alpha_{n}\dots\alpha_{1}\alpha_{0}   then gives    A  0     subscript  A  0    A_{0}   as leftmost in its final sentential form.  Removing left recursion  Left recursion often poses problems for parsers, either because it leads them into infinite recursion (as in the case of most top-down parsers ) or because they expect rules in a normal form that forbids it (as in the case of many bottom-up parsers , including the CYK algorithm ). Therefore a grammar is often preprocessed to eliminate the left recursion.  Removing direct left recursion  The general algorithm to remove direct left recursion follows. Several improvements to this method have been made. 2 For a left-recursive nonterminal   A   A   A   , discard any rules of the form    A  →  A     normal-→  A  A    A\rightarrow A   and consider those that remain:      A  →  A   α  1   ∣  …  ∣  A   α  n   ∣   β  1   ∣  …  ∣   β  m      fragments  A  normal-→  A   subscript  α  1   normal-∣  normal-…  normal-∣  A   subscript  α  n   normal-∣   subscript  β  1   normal-∣  normal-…  normal-∣   subscript  β  m     A\rightarrow A\alpha_{1}\mid\ldots\mid A\alpha_{n}\mid\beta_{1}\mid\ldots\mid%
 \beta_{m}   where:   each   α   α   \alpha   is a nonempty sequence of nonterminals and terminals, and  each   β   β   \beta   is a sequence of nonterminals and terminals that does not start with   A   A   A   .   Replace these with two sets of productions, one set for   A   A   A   :      A  →    β  1    A  ′    ∣  …  ∣    β  m    A  ′       normal-→  A     subscript  β  1    superscript  A  normal-′    delimited-∣∣  normal-…    subscript  β  m    superscript  A  normal-′      A\rightarrow\beta_{1}A^{\prime}\mid\ldots\mid\beta_{m}A^{\prime}   and another set for the fresh nonterminal    A  ′     superscript  A  normal-′    A^{\prime}   (often called the "tail" or the "rest"):       A  ′   →   α  1    A  ′   ∣  …  ∣   α  n    A  ′   ∣  ϵ     fragments   superscript  A  normal-′   normal-→   subscript  α  1    superscript  A  normal-′   normal-∣  normal-…  normal-∣   subscript  α  n    superscript  A  normal-′   normal-∣  ϵ    A^{\prime}\rightarrow\alpha_{1}A^{\prime}\mid\ldots\mid\alpha_{n}A^{\prime}\mid\epsilon   Repeat this process until no direct left recursion remains.  As an example, consider the rule set      𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛  →   𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛  +   𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛   ∣  𝐼𝑛𝑡𝑒𝑔𝑒𝑟  ∣   𝑆𝑡𝑟𝑖𝑛𝑔       normal-→  𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛    𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛    𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛   delimited-∣∣  𝐼𝑛𝑡𝑒𝑔𝑒𝑟   𝑆𝑡𝑟𝑖𝑛𝑔      \mathit{Expression}\rightarrow\mathit{Expression}+\mathit{Expression}\mid%
 \mathit{Integer}\mid\mathit{String}   This could be rewritten to avoid left recursion as      𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛  →   𝐼𝑛𝑡𝑒𝑔𝑒𝑟    𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛  ′   ∣   𝑆𝑡𝑟𝑖𝑛𝑔    𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛  ′      fragments  Expression  normal-→  Integer   superscript  𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛  normal-′   normal-∣  String   superscript  𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛  normal-′     \mathit{Expression}\rightarrow\mathit{Integer}\,\mathit{Expression}^{\prime}%
 \mid\mathit{String}\,\mathit{Expression}^{\prime}          𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛  ′   →  +   𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛    𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛  ′   ∣  ϵ     fragments   superscript  𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛  normal-′   normal-→   Expression   superscript  𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛  normal-′   normal-∣  ϵ    \mathit{Expression}^{\prime}\rightarrow{}+\mathit{Expression}\,\mathit{%
 Expression}^{\prime}\mid\epsilon     Removing all left recursion  By establishing a topological ordering on nonterminals, the above process can be extended to also eliminate indirect left recursion:   Inputs  A grammar: a set of nonterminals     A  1   ,  …  ,   A  n       subscript  A  1   normal-…   subscript  A  n     A_{1},\ldots,A_{n}   and their productions   Output  A modified grammar generating the same language but without left recursion   For each nonterminal    A  i     subscript  A  i    A_{i}   :   Repeat until an iteration leaves the grammar unchanged:   For each rule     A  i   →   α  i      normal-→   subscript  A  i    subscript  α  i     A_{i}\rightarrow\alpha_{i}   ,    α  i     subscript  α  i    \alpha_{i}   being a sequence of terminals and nonterminals:   If    α  i     subscript  α  i    \alpha_{i}   begins with a nonterminal    A  j     subscript  A  j    A_{j}   and    α  i     subscript  α  i    \alpha_{i}   be    A  j     subscript  A  j    A_{j}   without its leading     A  i   →   α  i      normal-→   subscript  A  i    subscript  α  i     A_{i}\rightarrow\alpha_{i}   .   Remove the rule     A  j   →   α  j      normal-→   subscript  A  j    subscript  α  j     A_{j}\rightarrow\alpha_{j}   .  For each rule     A  i   →    α  j    β  i       normal-→   subscript  A  i      subscript  α  j    subscript  β  i      A_{i}\rightarrow\alpha_{j}\beta_{i}   :   Add the rule    A  i     subscript  A  i    A_{i}   .      Remove direct left recursion for    𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛  →   𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛   -  𝑇𝑒𝑟𝑚  ∣  𝑇𝑒𝑟𝑚     fragments  Expression  normal-→  Expression   Term  normal-∣  Term    \mathit{Expression}\rightarrow\mathit{Expression}\,-\,\mathit{Term}\mid\mathit%
 {Term}   as described above.      Note that this algorithm is highly sensitive to the nonterminal ordering; optimizations often focus on choosing this ordering well.  Pitfalls  Although the above transformations preserve the language generated by a grammar, they may change the parse trees that witness strings' recognition. With suitable bookkeeping, tree rewriting can recover the originals, but if this step is omitted, the differences may change the semantics of a parse.  Associativity is particularly vulnerable; left-associative operators typically appear in right-associative-like arrangements under the new grammar. For example, starting with this grammar:      𝑇𝑒𝑟𝑚  →   𝑇𝑒𝑟𝑚   *  𝐹𝑎𝑐𝑡𝑜𝑟  ∣  𝐹𝑎𝑐𝑡𝑜𝑟     fragments  Term  normal-→  Term   Factor  normal-∣  Factor    \mathit{Term}\rightarrow\mathit{Term}\,*\,\mathit{Factor}\mid\mathit{Factor}         𝐹𝑎𝑐𝑡𝑜𝑟  →   (  𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛  )   ∣  𝐼𝑛𝑡𝑒𝑔𝑒𝑟     fragments  Factor  normal-→   fragments  normal-(  Expression  normal-)   normal-∣  Integer    \mathit{Factor}\rightarrow(\mathit{Expression})\mid\mathit{Integer}         𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛  →    𝑇𝑒𝑟𝑚    𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛  ′       normal-→  𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛    𝑇𝑒𝑟𝑚   superscript  𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛  normal-′      \mathit{Expression}\rightarrow\mathit{Term}\ \mathit{Expression}^{\prime}   the standard transformations to remove left recursion yield the following:       𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛  ′   →  -   𝑇𝑒𝑟𝑚    𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛  ′   ∣  ϵ     fragments   superscript  𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛  normal-′   normal-→   Term   superscript  𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛  normal-′   normal-∣  ϵ    \mathit{Expression}^{\prime}\rightarrow{}-\mathit{Term}\ \mathit{Expression}^{%
 \prime}\mid\epsilon         𝑇𝑒𝑟𝑚  →    𝐹𝑎𝑐𝑡𝑜𝑟    𝑇𝑒𝑟𝑚  ′       normal-→  𝑇𝑒𝑟𝑚    𝐹𝑎𝑐𝑡𝑜𝑟   superscript  𝑇𝑒𝑟𝑚  normal-′      \mathit{Term}\rightarrow\mathit{Factor}\ \mathit{Term}^{\prime}          𝑇𝑒𝑟𝑚  ′   →  *   𝐹𝑎𝑐𝑡𝑜𝑟    𝑇𝑒𝑟𝑚  ′   ∣  ϵ     fragments   superscript  𝑇𝑒𝑟𝑚  normal-′   normal-→   Factor   superscript  𝑇𝑒𝑟𝑚  normal-′   normal-∣  ϵ    \mathit{Term}^{\prime}\rightarrow{}*\mathit{Factor}\ \mathit{Term}^{\prime}\mid\epsilon         𝐹𝑎𝑐𝑡𝑜𝑟  →   (  𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛  )   ∣  𝐼𝑛𝑡𝑒𝑔𝑒𝑟     fragments  Factor  normal-→   fragments  normal-(  Expression  normal-)   normal-∣  Integer    \mathit{Factor}\rightarrow(\mathit{Expression})\mid\mathit{Integer}     $$\mathit{Factor} \rightarrow (\mathit{Expression}) \mid \mathit{Integer}$$  Parsing the string "1 - 2 - 3" with the first grammar in an LALR parser (which can handle left-recursive grammars) would have resulted in the parse tree:  This parse tree groups the terms on the left, giving the correct semantics (1 - 2) - 3 .  Parsing with the second grammar gives  which, properly interpreted, signifies 1 + (-2 + (-3)) , also correct, but less faithful to the input and much harder to implement for some operators. Notice how terms to the right appear deeper in the tree, much as a right-recursive grammar would arrange them for 1 - (2 - 3) .  Accommodating left recursion in top-down parsing  A formal grammar that contains left recursion cannot be parsed by a LL(k)-parser or other naive recursive descent parser unless it is converted to a weakly equivalent right-recursive form. In contrast, left recursion is preferred for LALR parsers because it results in lower stack usage than right recursion . However, more sophisticated top-down parsers can implement general context-free grammars by use of curtailment . In 2006, Frost and Hafiz described an algorithm which accommodates ambiguous grammars with direct left-recursive production rules . 3 That algorithm was extended to a complete parsing algorithm to accommodate indirect as well as direct left recursion in polynomial time, and to generate compact polynomial-size representations of the potentially exponential number of parse trees for highly ambiguous grammars by Frost, Hafiz and Callaghan in 2007. 4 The authors then implemented the algorithm as a set of parser combinators written in the Haskell programming language. 5  See also   Tail recursion   References    External links   CMU lecture on left recursion  Practical Considerations for LALR(1) Grammars  X-SAIGA - eXecutable SpecificAtIons of GrAmmars   "  Category:Control flow  Category:Formal languages  Category:Parsing  Category:Recursion     [ http://www.cs.may.ie/~jpower/Courses/parsing/parsing.pdf#search ='indirect%20left%20recursion' Notes on Formal Language Theory and Parsing], James Power, Department of Computer Science National University of Ireland, Maynooth Maynooth, Co. Kildare, Ireland. JPR02 ↩  ↩  , available from the author at http://hafiz.myweb.cs.uwindsor.ca/pub/p46-frost.pdf ↩  ↩  ↩     