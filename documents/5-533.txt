


Left recursion




Left recursion

In the formal language theory of computer science, left recursion is a special case of recursion where a string is recognized as part of a language by the fact that it decomposes into a string from that same language (on the left) and a suffix (on the right). For instance, 
 
 
 
  can be recognized as a sum because it can be broken into 
 
 
 
 , also a sum, and 
 
 
 
 , a suitable suffix.
In terms of context-free grammar, a nonterminal is left-recursive if the leftmost symbol in one of its productions is itself (in the case of direct left recursion) or can be made itself by some sequence of substitutions (in the case of indirect left recursion).
Definition
A grammar is left-recursive if and only if there exists a nonterminal symbol 
 
 
 
  that can derive to a sentential form with itself as the leftmost symbol.1 Symbolically,


 
 , where 
 
 
 
  indicates the operation of making one or more substitutions, and 
 
 
 
  is any sequence of terminal and nonterminal symbols.
Direct left recursion
Direct left recursion occurs when the definition can be satisfied with only one substitution. It requires a rule of the form


 
  where 
 
 
 
  is a sequence of nonterminals and terminals. For example, the rule


 
  is directly left-recursive. A left-to-right recursive descent parser for this rule might look like
function Expression()
 {
     Expression();  match('+');  Term();
 }
and such code would fall into infinite recursion when executed.
Indirect left recursion
Indirect left recursion occurs when the definition is satisfied via several substitutions. It entails a set of rules following the pattern











 
  where 
 
 
 
  are sequences that can each yield the empty string, while 
 
 
 
  may be any sequences at all. The derivation


 
  then gives 
 
 
 
  as leftmost in its final sentential form.
Removing left recursion
Left recursion often poses problems for parsers, either because it leads them into infinite recursion (as in the case of most top-down parsers) or because they expect rules in a normal form that forbids it (as in the case of many bottom-up parsers, including the CYK algorithm). Therefore a grammar is often preprocessed to eliminate the left recursion.
Removing direct left recursion
The general algorithm to remove direct left recursion follows. Several improvements to this method have been made.2 For a left-recursive nonterminal 
 
 
 
 , discard any rules of the form 
 
 
 
  and consider those that remain:


 
  where:

each 
 
 
 
  is a nonempty sequence of nonterminals and terminals, and
each 
 
 
 
  is a sequence of nonterminals and terminals that does not start with 
 
 
 
 .

Replace these with two sets of productions, one set for 
 
 
 
 :


 
  and another set for the fresh nonterminal 
 
 
 
  (often called the "tail" or the "rest"):


 
  Repeat this process until no direct left recursion remains.
As an example, consider the rule set


 
  This could be rewritten to avoid left recursion as






Removing all left recursion
By establishing a topological ordering on nonterminals, the above process can be extended to also eliminate indirect left recursion:

Inputs A grammar: a set of nonterminals 
 
 
 
  and their productions

Output A modified grammar generating the same language but without left recursion

For each nonterminal 
 
 
 
 :

Repeat until an iteration leaves the grammar unchanged:

For each rule 
 
 
 
 , 
 
 
 
  being a sequence of terminals and nonterminals:

If 
 
 
 
  begins with a nonterminal 
 
 
 
  and 
 
 
 
  be 
 
 
 
  without its leading 
 
 
 
 .

Remove the rule 
 
 
 
 .
For each rule 
 
 
 
 :

Add the rule 
 
 
 
 .




Remove direct left recursion for 
 
 
 
  as described above.




Note that this algorithm is highly sensitive to the nonterminal ordering; optimizations often focus on choosing this ordering well.
Pitfalls
Although the above transformations preserve the language generated by a grammar, they may change the parse trees that witness strings' recognition. With suitable bookkeeping, tree rewriting can recover the originals, but if this step is omitted, the differences may change the semantics of a parse.
Associativity is particularly vulnerable; left-associative operators typically appear in right-associative-like arrangements under the new grammar. For example, starting with this grammar:








 
  the standard transformations to remove left recursion yield the following:












$$\mathit{Factor} \rightarrow (\mathit{Expression}) \mid \mathit{Integer}$$
Parsing the string "1 - 2 - 3" with the first grammar in an LALR parser (which can handle left-recursive grammars) would have resulted in the parse tree:  This parse tree groups the terms on the left, giving the correct semantics (1 - 2) - 3.
Parsing with the second grammar gives  which, properly interpreted, signifies 1 + (-2 + (-3)), also correct, but less faithful to the input and much harder to implement for some operators. Notice how terms to the right appear deeper in the tree, much as a right-recursive grammar would arrange them for 1 - (2 - 3).
Accommodating left recursion in top-down parsing
A formal grammar that contains left recursion cannot be parsed by a LL(k)-parser or other naive recursive descent parser unless it is converted to a weakly equivalent right-recursive form. In contrast, left recursion is preferred for LALR parsers because it results in lower stack usage than right recursion. However, more sophisticated top-down parsers can implement general context-free grammars by use of curtailment. In 2006, Frost and Hafiz described an algorithm which accommodates ambiguous grammars with direct left-recursive production rules.3 That algorithm was extended to a complete parsing algorithm to accommodate indirect as well as direct left recursion in polynomial time, and to generate compact polynomial-size representations of the potentially exponential number of parse trees for highly ambiguous grammars by Frost, Hafiz and Callaghan in 2007.4 The authors then implemented the algorithm as a set of parser combinators written in the Haskell programming language.5
See also

Tail recursion

References


External links

CMU lecture on left recursion
Practical Considerations for LALR(1) Grammars
X-SAIGA - eXecutable SpecificAtIons of GrAmmars

"
Category:Control flow Category:Formal languages Category:Parsing Category:Recursion



[http://www.cs.may.ie/~jpower/Courses/parsing/parsing.pdf#search='indirect%20left%20recursion' Notes on Formal Language Theory and Parsing], James Power, Department of Computer Science National University of Ireland, Maynooth Maynooth, Co. Kildare, Ireland.JPR02

, available from the author at http://hafiz.myweb.cs.uwindsor.ca/pub/p46-frost.pdf






