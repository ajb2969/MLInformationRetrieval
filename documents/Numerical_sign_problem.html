<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="639">Numerical sign problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Numerical sign problem</h1>
<hr/>

<p>The <strong>numerical sign problem</strong> refers to the difficulty of numerically evaluating the integral of a highly oscillatory function of a large number of variables. Numerical methods fail because of the near-cancellation of the positive and negative contributions to the integral. Each has to be integrated to very high precision in order for their difference to be obtained with useful accuracy.</p>

<p>The sign problem is one of the major unsolved problems in the physics of many-particle systems. It often arises in calculations of the properties of a quantum mechanical system with large number of strongly interacting <a href="fermion" title="wikilink">fermions</a>, or in field theories involving a non-zero density of strongly interacting fermions.</p>
<h2 id="the-sign-problem-in-physics">The sign problem in physics</h2>

<p>In physics, the sign problem is typically (but not exclusively) encountered in calculations of the properties of a quantum mechanical system with large number of strongly interacting <a href="fermion" title="wikilink">fermions</a>, or in field theories involving a non-zero density of strongly interacting fermions. Because the particles are strongly interacting, <a href="perturbation_theory" title="wikilink">perturbation theory</a> is inapplicable, and one is forced to use brute-force numerical methods. Because the particles are fermions, their <a class="uri" href="wavefunction" title="wikilink">wavefunction</a> changes sign when any two fermions are interchanged (due to the symmetry of the wave function, see <a href="Pauli_principle" title="wikilink">Pauli principle</a>). So unless there are cancellations arising from some symmetry of the system, the quantum-mechanical sum over all multi-particle states involves an integral over a function that is highly oscillatory, and hence hard to evaluate numerically, particularly in high dimension. Since the dimension of the integral is given by the number of particles, the sign problem becomes severe in the <a href="thermodynamic_limit" title="wikilink">thermodynamic limit</a>. The field-theoretic manifestation of the sign problem is discussed below.</p>

<p>The sign problem is one of the major unsolved problems in the physics of many-particle systems, impeding progress in many areas:</p>
<ul>
<li>Condensed matter physics. It prevents the numerical solution of systems with a high density of strongly correlated electrons, such as the <a href="Hubbard_model" title="wikilink">Hubbard model</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></li>
<li>Nuclear physics. It prevents the ab-initio calculation of properties of <a href="nuclear_matter" title="wikilink">nuclear matter</a> and hence limits our understanding of <a href="atomic_nucleus" title="wikilink">nuclei</a> and <a href="neutron_star" title="wikilink">neutron stars</a>.</li>
<li>Particle physics. It prevents the use of <a href="Lattice_QCD" title="wikilink">Lattice QCD</a> to predict the phases and properties of <a href="quark_matter" title="wikilink">quark matter</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></li>
</ul>
<h2 id="the-sign-problem-in-field-theory">The sign problem in field theory<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></h2>

<p>In a field theory approach to multi-particle systems, the fermion density is controlled by the value of the fermion <a href="chemical_potential" title="wikilink">chemical potential</a> 

<math display="inline" id="Numerical_sign_problem:0">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

. One evaluates the <a href="Partition_function_(quantum_field_theory)" title="wikilink">partition function</a> 

<math display="inline" id="Numerical_sign_problem:1">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

 by summing over all classical field configurations, weighted by 

<math display="inline" id="Numerical_sign_problem:2">
 <semantics>
  <mrow>
   <mi>exp</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>-</mo>
     <mi>S</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exp></exp>
    <apply>
     <minus></minus>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exp(-S)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Numerical_sign_problem:3">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is the action of the configuration. The sum over fermion fields can be performed analytically, and one is left with a sum over the <a href="boson" title="wikilink">bosonic</a> fields 

<math display="inline" id="Numerical_sign_problem:4">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 (which may have been originally part of the theory, or have been produced by a <a href="Hubbard-Stratonovich_transformation" title="wikilink">Hubbard-Stratonovich transformation</a> to make the fermion action quadratic)</p>

<p>

<math display="block" id="Numerical_sign_problem:5">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mi>D</mi>
     <mpadded width="+2.8pt">
      <mi>σ</mi>
     </mpadded>
     <mi>ρ</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>σ</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Z</ci>
    <apply>
     <int></int>
     <apply>
      <times></times>
      <ci>D</ci>
      <ci>σ</ci>
      <ci>ρ</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>σ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z=\int D\sigma\;\rho[\sigma]
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Numerical_sign_problem:6">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D\sigma
  </annotation>
 </semantics>
</math>

 represents the measure for the sum over all configurations 

<math display="inline" id="Numerical_sign_problem:7">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>σ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(x)
  </annotation>
 </semantics>
</math>

 of the bosonic fields, weighted by</p>

<p>

<math display="block" id="Numerical_sign_problem:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>ρ</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>σ</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo movablelimits="false">det</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>M</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>μ</mi>
        <mo>,</mo>
        <mi>σ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi>exp</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>S</mi>
         <mrow>
          <mo stretchy="false">[</mo>
          <mi>σ</mi>
          <mo stretchy="false">]</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ρ</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>σ</ci>
     </apply>
    </apply>
    <apply>
     <determinant></determinant>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>M</ci>
       <interval closure="open">
        <ci>μ</ci>
        <ci>σ</ci>
       </interval>
      </apply>
      <apply>
       <exp></exp>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>S</ci>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <ci>σ</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho[\sigma]=\det(M(\mu,\sigma))\exp(-S[\sigma])
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Numerical_sign_problem:9">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is now the action of the bosonic fields, and 

<math display="inline" id="Numerical_sign_problem:10">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>μ</mi>
    <mo>,</mo>
    <mi>σ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <interval closure="open">
     <ci>μ</ci>
     <ci>σ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M(\mu,\sigma)
  </annotation>
 </semantics>
</math>

 is a matrix that encodes how the fermions were coupled to the bosons. The expectation value of an observable 

<math display="inline" id="Numerical_sign_problem:11">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>σ</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A[\sigma]
  </annotation>
 </semantics>
</math>

 is therefore an average over all configurations weighted by 

<math display="inline" id="Numerical_sign_problem:12">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>σ</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ρ</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho[\sigma]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Numerical_sign_problem:13">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>A</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi>ρ</mi>
    </msub>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mi>D</mi>
       <mpadded width="+2.8pt">
        <mi>σ</mi>
       </mpadded>
       <mi>A</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>σ</mi>
        <mo rspace="5.3pt" stretchy="false">]</mo>
       </mrow>
       <mi>ρ</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>σ</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </mrow>
     <mrow>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mi>D</mi>
       <mpadded width="+2.8pt">
        <mi>σ</mi>
       </mpadded>
       <mi>ρ</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>σ</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <ci>A</ci>
     </apply>
     <ci>ρ</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <int></int>
      <apply>
       <times></times>
       <ci>D</ci>
       <ci>σ</ci>
       <ci>A</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>σ</ci>
       </apply>
       <ci>ρ</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>σ</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <int></int>
      <apply>
       <times></times>
       <ci>D</ci>
       <ci>σ</ci>
       <ci>ρ</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>σ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle A\rangle_{\rho}=\frac{\int D\sigma\;A[\sigma]\;\rho[\sigma]}{\int D%
\sigma\;\rho[\sigma]}.
  </annotation>
 </semantics>
</math>

</p>

<p>If 

<math display="inline" id="Numerical_sign_problem:14">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>σ</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ρ</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho[\sigma]
  </annotation>
 </semantics>
</math>

 is positive, then it can be interpreted as a probability measure, and 

<math display="inline" id="Numerical_sign_problem:15">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>A</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>ρ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-⟨⟩</csymbol>
     <ci>A</ci>
    </apply>
    <ci>ρ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle A\rangle_{\rho}
  </annotation>
 </semantics>
</math>

 can be calculated by performing the sum over field configurations numerically, using standard techniques such as <a href="Monte_Carlo_integration" title="wikilink">Monte Carlo importance sampling</a>.</p>

<p>The sign problem arises when 

<math display="inline" id="Numerical_sign_problem:16">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>σ</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ρ</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho[\sigma]
  </annotation>
 </semantics>
</math>

 is non-positive. This typically occurs in theories of fermions when the fermion chemical potential 

<math display="inline" id="Numerical_sign_problem:17">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 is nonzero, i.e. when there is a nonzero background density of fermions. If 

<math display="inline" id="Numerical_sign_problem:18">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>μ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu\neq 0
  </annotation>
 </semantics>
</math>

 there is no particle-antiparticle symmetry, and 

<math display="inline" id="Numerical_sign_problem:19">
 <semantics>
  <mrow>
   <mo>det</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>M</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>μ</mi>
      <mo>,</mo>
      <mi>σ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <determinant></determinant>
    <apply>
     <times></times>
     <ci>M</ci>
     <interval closure="open">
      <ci>μ</ci>
      <ci>σ</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \det(M(\mu,\sigma))
  </annotation>
 </semantics>
</math>

, and hence the weight 

<math display="inline" id="Numerical_sign_problem:20">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>σ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ρ</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(\sigma)
  </annotation>
 </semantics>
</math>

, is in general a complex number, so Monte-Carlo importance sampling cannot be used to evaluate the integral.</p>
<h3 id="reweighting-procedure">Reweighting procedure</h3>

<p>A field theory with a non-positive weight can be transformed to one with a positive weight, by incorporating the non-positive part (sign or complex phase) of the weight into the observable. For example, one could decompose the weighting function into its modulus and phase,</p>

<p>

<math display="block" id="Numerical_sign_problem:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>ρ</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>σ</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>σ</mi>
     <mo rspace="4.2pt" stretchy="false">]</mo>
    </mrow>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>i</mi>
       <mi>θ</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>σ</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ρ</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>σ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>p</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>σ</ci>
     </apply>
     <apply>
      <exp></exp>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>θ</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>σ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho[\sigma]=p[\sigma]\,\exp(i\theta[\sigma])
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Numerical_sign_problem:22">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>σ</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p[\sigma]
  </annotation>
 </semantics>
</math>

 is real and positive, so</p>

<p>

<math display="block" id="Numerical_sign_problem:23">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>A</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>ρ</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mi>D</mi>
      <mi>σ</mi>
      <mi>A</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>σ</mi>
       <mo stretchy="false">]</mo>
      </mrow>
      <mrow>
       <mi>exp</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>i</mi>
         <mi>θ</mi>
         <mrow>
          <mo stretchy="false">[</mo>
          <mi>σ</mi>
          <mo stretchy="false">]</mo>
         </mrow>
        </mrow>
        <mo rspace="5.3pt" stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>σ</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mi>D</mi>
      <mi>σ</mi>
      <mrow>
       <mi>exp</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>i</mi>
         <mi>θ</mi>
         <mrow>
          <mo stretchy="false">[</mo>
          <mi>σ</mi>
          <mo stretchy="false">]</mo>
         </mrow>
        </mrow>
        <mo rspace="5.3pt" stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>σ</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <msub>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mrow>
       <mi>A</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>σ</mi>
        <mo stretchy="false">]</mo>
       </mrow>
       <mrow>
        <mi>exp</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>i</mi>
          <mi>θ</mi>
          <mrow>
           <mo stretchy="false">[</mo>
           <mi>σ</mi>
           <mo stretchy="false">]</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi>p</mi>
    </msub>
    <msub>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mrow>
       <mi>exp</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>i</mi>
         <mi>θ</mi>
         <mrow>
          <mo stretchy="false">[</mo>
          <mi>σ</mi>
          <mo stretchy="false">]</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi>p</mi>
    </msub>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-⟨⟩</csymbol>
       <ci>A</ci>
      </apply>
      <ci>ρ</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <int></int>
       <apply>
        <times></times>
        <ci>D</ci>
        <ci>σ</ci>
        <ci>A</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>σ</ci>
        </apply>
        <apply>
         <exp></exp>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>θ</ci>
          <apply>
           <csymbol cd="latexml">delimited-[]</csymbol>
           <ci>σ</ci>
          </apply>
         </apply>
        </apply>
        <ci>p</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>σ</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <int></int>
       <apply>
        <times></times>
        <ci>D</ci>
        <ci>σ</ci>
        <apply>
         <exp></exp>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>θ</ci>
          <apply>
           <csymbol cd="latexml">delimited-[]</csymbol>
           <ci>σ</ci>
          </apply>
         </apply>
        </apply>
        <ci>p</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>σ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-⟨⟩</csymbol>
        <apply>
         <times></times>
         <ci>A</ci>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <ci>σ</ci>
         </apply>
         <apply>
          <exp></exp>
          <apply>
           <times></times>
           <ci>i</ci>
           <ci>θ</ci>
           <apply>
            <csymbol cd="latexml">delimited-[]</csymbol>
            <ci>σ</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-⟨⟩</csymbol>
        <apply>
         <exp></exp>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>θ</ci>
          <apply>
           <csymbol cd="latexml">delimited-[]</csymbol>
           <ci>σ</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle A\rangle_{\rho}=\frac{\int D\sigma A[\sigma]\exp(i\theta[\sigma])\;p[%
\sigma]}{\int D\sigma\exp(i\theta[\sigma])\;p[\sigma]}=\frac{\langle A[\sigma]%
\exp(i\theta[\sigma])\rangle_{p}}{\langle\exp(i\theta[\sigma])\rangle_{p}}
  </annotation>
 </semantics>
</math>

</p>

<p>Note that the desired expectation value is now a ratio where the numerator and denominator are expectation values that both use a positive weighting function, 

<math display="inline" id="Numerical_sign_problem:24">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>σ</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p[\sigma]
  </annotation>
 </semantics>
</math>

. However, the phase 

<math display="inline" id="Numerical_sign_problem:25">
 <semantics>
  <mrow>
   <mi>exp</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>i</mi>
     <mi>θ</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>σ</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exp></exp>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>θ</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>σ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exp(i\theta[\sigma])
  </annotation>
 </semantics>
</math>

 is a highly oscillatory function in the configuration space, so if one uses Monte-Carlo methods to evaluate the numerator and denominator, each of them will evaluate to a very small number, whose exact value is swamped by the noise inherent in the Monte-Carlo sampling process. The "badness" of the sign problem is measured by the smallness of the denominator 

<math display="inline" id="Numerical_sign_problem:26">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>i</mi>
       <mi>θ</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>σ</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-⟨⟩</csymbol>
     <apply>
      <exp></exp>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>θ</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>σ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\exp(i\theta[\sigma])\rangle_{p}
  </annotation>
 </semantics>
</math>

: if it is much less than 1 then the sign problem is severe. It can be shown (e.g.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a>) that</p>

<p>

<math display="block" id="Numerical_sign_problem:27">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>exp</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>i</mi>
        <mi>θ</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mi>σ</mi>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>p</mi>
   </msub>
   <mo>∝</mo>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mrow>
        <mi>f</mi>
        <mi>V</mi>
       </mrow>
       <mo>/</mo>
       <mi>T</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proportional-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <apply>
       <exp></exp>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>θ</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>σ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>p</ci>
    </apply>
    <apply>
     <exp></exp>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>V</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\exp(i\theta[\sigma])\rangle_{p}\propto\exp(-fV/T)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Numerical_sign_problem:28">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 is the volume of the system, 

<math display="inline" id="Numerical_sign_problem:29">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is the temperature, and 

<math display="inline" id="Numerical_sign_problem:30">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is an energy density. The number of Monte-Carlo sampling points needed to obtain an accurate result therefore rises exponentially as the volume of the system becomes large, and as the temperature goes to zero.</p>

<p>The decomposition of the weighting function into modulus and phase is just one example (although it has been advocated as the optimal choice since it minimizes the variance of the denominator <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a>). In general one could write</p>

<p>

<math display="block" id="Numerical_sign_problem:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>ρ</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>σ</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>σ</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mfrac>
     <mrow>
      <mi>ρ</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>σ</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>σ</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ρ</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>σ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>p</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>σ</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>ρ</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>σ</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>p</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>σ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho[\sigma]=p[\sigma]\frac{\rho[\sigma]}{p[\sigma]}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Numerical_sign_problem:32">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>σ</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p[\sigma]
  </annotation>
 </semantics>
</math>

 can be any positive weighting function (for example, the weighting function of the 

<math display="inline" id="Numerical_sign_problem:33">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>μ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu=0
  </annotation>
 </semantics>
</math>

 theory.)<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> The badness of the sign problem is then measured by</p>

<p>

<math display="block" id="Numerical_sign_problem:34">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo>⟨</mo>
     <mfrac>
      <mrow>
       <mi>ρ</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>σ</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>σ</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </mfrac>
     <mo>⟩</mo>
    </mrow>
    <mi>p</mi>
   </msub>
   <mo>∝</mo>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mrow>
        <mi>f</mi>
        <mi>V</mi>
       </mrow>
       <mo>/</mo>
       <mi>T</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proportional-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>ρ</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>σ</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>p</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>σ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>p</ci>
    </apply>
    <apply>
     <exp></exp>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>V</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\langle\frac{\rho[\sigma]}{p[\sigma]}\right\rangle_{p}\propto\exp(-fV/T)
  </annotation>
 </semantics>
</math>

 which again goes to zero exponentially in the large-volume limit.</p>
<h2 id="methods-for-reducing-the-sign-problem">Methods for reducing the sign problem</h2>

<p>The sign problem is <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>, implying that a full and generic solution of the sign problem would also solve all problems in the complexity class NP in polynomial time.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> If (as is generally suspected) there are no polynomial-time solutions to NP-hard problems (see <a href="P_versus_NP_problem" title="wikilink">P versus NP problem</a>), then there is no <em>generic</em> solution to the sign problem. This leaves open the possibility that there may be solutions that work in specific cases, where the oscillations of the integrand have a structure that can be exploited to reduce the numerical errors.</p>

<p>In systems with a moderate sign problem, such as field theories at a sufficiently high temperature or in a sufficiently small volume, the sign problem is not too severe and useful results can be obtained by various methods, such as more carefully tuned reweighting, analytic continuation from imaginary 

<math display="inline" id="Numerical_sign_problem:35">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 to real 

<math display="inline" id="Numerical_sign_problem:36">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

, or Taylor expansion in powers of 

<math display="inline" id="Numerical_sign_problem:37">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>There are various proposals for solving systems with a severe sign problem:</p>
<ul>
<li>Meron-cluster algorithms. These achieve an exponential speed-up by decomposing the fermion world lines into clusters that contribute independently. Cluster algorithms have been developed for certain theories,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> but not for the Hubbard model of electrons, nor for <a href="Quantum_chromodynamics" title="wikilink">QCD</a>, the theory of quarks.</li>
</ul>
<ul>
<li>Stochastic quantization. The sum over configurations is obtained as the equilibrium distribution of states explored by a complex <a href="Langevin_equation" title="wikilink">Langevin equation</a>. So far, the algorithm has been found to evade the sign problem in test models that have a sign problem but do not involve fermions.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></li>
</ul>
<ul>
<li>Fixed node method. One fixes the location of nodes (zeros) of the multiparticle wavefunction, and uses Monte-Carlo methods to obtain an estimate of the energy of the ground state, subject to that constraint.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Statistical_mechanics" title="wikilink">Category:Statistical mechanics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">E. Loh et al., "Sign problem in the numerical simulation of many-electron systems" <a href="http://prb.aps.org/abstract/PRB/v41/i13/p9301_1">Phys. Rev. B 41, 9301–9307 (1990)</a><a href="#fnref1">↩</a></li>
<li id="fn2">O. Philipsen, "Lattice calculations at non-zero chemical potential: The QCD phase diagram", <a href="http://pos.sissa.it//archive/conferences/077/011/Confinement8_011.pdf">PoS Confinement8 011 (2008)</a>, Plenary talk at Quark Confinement and the Hadron Spectrum 8, Mainz, Germany, Sept 2008<a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6">T. D. Kieu and C. J. Griffin, "Monte Carlo simulations with indefinite and complex-valued measures", <a href="http://pre.aps.org/abstract/PRE/v49/i5/p3855_1">Phys. Rev. E 49, 3855–3859 (1994)</a><a href="#fnref6">↩</a></li>
<li id="fn7">I. Barbour et al, "Results on finite density QCD", Nucl. Phys. Proc. Suppl. 60A 220-234 (1998), <a href="http://arxiv.org/abs/hep-lat/9705042">arXiv:hep-lat/9705042</a>, presented at International Workshop on Lattice QCD on Parallel Computers, Tsukuba, Japan<a href="#fnref7">↩</a></li>
<li id="fn8">M. Troyer, U.-J. Wiese, "Computational complexity and fundamental limitations to fermionic quantum Monte Carlo simulations", <a href="http://prl.aps.org/abstract/PRL/v94/i17/e170201">Phys. Rev. Lett. 94, 170201 (2005)</a>, <a href="http://arxiv.org/abs/cond-mat/0408370">arXiv:cond-mat/0408370</a><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10">C. Schmidt, "Lattice QCD at Finite Density", PoS LAT2006 021 (2006) <a href="http://arxiv.org/abs/hep-lat/0610116">arXiv:/hep-lat/0610116</a>, plenary talk at 24th International Symposium on Lattice Field Theory.<a href="#fnref10">↩</a></li>
<li id="fn11">S. Chandrasekharan and U.-J. Wiese, "Meron-Cluster Solution of Fermion Sign Problems", <a href="http://prl.aps.org/abstract/PRL/v83/i16/p3116_1">Phys. Rev. Lett. 83, 3116–3119 (1999)</a> <a href="http://arxiv.org/abs/cond-mat/9902128">arXiv:cond-mat/9902128</a><a href="#fnref11">↩</a></li>
<li id="fn12">G. Aarts, "Can stochastic quantization evade the sign problem? The relativistic Bose gas at finite chemical potential", <a href="http://prl.aps.org/abstract/PRL/v102/i13/e131601">Phys. Rev. Lett. 102, 131601 (2009)</a>, <a href="http://arxiv.org/abs/0810.2089">arXiv:0810.2089</a><a href="#fnref12">↩</a></li>
<li id="fn13">H. J. M. van Bemmel et al, "Fixed-node quantum Monte Carlo method for lattice fermions", <a href="http://prl.aps.org/abstract/PRL/v72/i15/p2442_1">Phys. Rev. Lett. 72, 2442–2445 (1994)</a><a href="#fnref13">↩</a></li>
</ol>
</section>
</body>
</html>
