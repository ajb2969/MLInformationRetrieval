<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="664">Bounding sphere</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Bounding sphere</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, given a non-empty set of objects of finite extension in <em>n</em>-dimensional <a class="uri" href="space" title="wikilink">space</a>, for example a set of points, a <strong>bounding sphere</strong>, <strong>enclosing sphere</strong> or <strong>enclosing ball</strong> for that set is an <em>n</em>-dimensional <a href="solid_sphere" title="wikilink">solid sphere</a> containing all of these objects.</p>

<p>In the plane the terms <strong>bounding or enclosing circle</strong> are used.</p>

<p>Used in <a href="computer_graphics" title="wikilink">computer graphics</a> and <a href="computational_geometry" title="wikilink">computational geometry</a>, a bounding sphere is a special type of <a href="bounding_volume" title="wikilink">bounding volume</a>. There are several fast and simple bounding sphere construction algorithms with a high practical value in real-time computer graphics applications.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>In <a class="uri" href="statistics" title="wikilink">statistics</a> and <a href="operations_research" title="wikilink">operations research</a>, the objects are typically points, and generally the sphere of interest is the <strong>minimal bounding sphere</strong>, that is, the sphere with minimal radius among all bounding spheres. It may be proven that such a sphere is unique: If there are two of them, then the objects in question lie within their intersection. But an intersection of two non-coinciding spheres of equal radius is contained in a sphere of smaller radius.</p>

<p>The problem of computing the center of a minimal bounding sphere is also known as the "unweighted Euclidean <a href="1-center_problem" title="wikilink">1-center problem</a>".</p>
<h2 id="applications">Applications</h2>
<h3 id="clustering">Clustering</h3>

<p>Such spheres are useful in <a href="Cluster_analysis" title="wikilink">clustering</a>, where groups of similar data points are classified together.</p>

<p>In <a href="statistical_analysis" title="wikilink">statistical analysis</a> the <a href="scattering_(statistics)" title="wikilink">scattering</a> of data points within a sphere may be attributed to <a href="measurement_error" title="wikilink">measurement error</a> or natural (usually thermal) processes, in which case the cluster represents a perturbation of an ideal point. In some circumstances this ideal point may be used as a substitute for the points in the cluster, advantageous in reducing calculation time.</p>

<p>In <a href="operations_research" title="wikilink">operations research</a> the clustering of values to an ideal point may also be used to reduce the number of inputs in order to obtain approximate values for <a class="uri" href="NP-hard" title="wikilink">NP-hard</a> problems in a reasonable time. The point chosen is not usually the center of the sphere, as this can be biased by outliers, but instead some form of average location such as a <a href="least_squares" title="wikilink">least squares</a> point is computed to represent the cluster.</p>
<h2 id="algorithms">Algorithms</h2>

<p>There are exact and approximate algorithms for solving bounding sphere problem.</p>
<h3 id="ritters-bounding-sphere">Ritter's bounding sphere</h3>

<p>In 1990, Jack Ritter proposed a simple algorithm to find a bounding sphere.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> It's widely used in various applications for its simplicity. The algorithm works in this way:</p>

<p>1. Pick a point x from P, search a point y in P, which has the largest distance from x;</p>

<p>2. Search a point z in P, which has the largest distance from y. set up an initial ball B, with its centre as the midpoint of y and z, the radius as half of the distance between y and z;</p>

<p>3. If all points in P are within ball B, then we get a bounding sphere. Otherwise, let p be the point outside the ball, construct a new ball covering both point p and previous ball. Repeat this step until all points are covered.</p>

<p>Ritter's algorithm obviously runs in time O(nd), which makes it very efficient. However it gives only a coarse result which is usually 5%~20% larger than the optimum.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h3 id="linear-programming">Linear programming</h3>

<p>In 1983, <a href="Nimrod_Megiddo" title="wikilink">Nimrod Megiddo</a> proposed a "<a href="prune_and_search" title="wikilink">prune and search</a>" algorithm which runs in linear time if the dimension is fixed as a constant. When dimension is taken into account, the execution time complexity is O((d+1)(d+1)!n), thus is impractical for high-dimensional applications. Megiddo used this approach to solve linear programming in linear time when dimension is fixed.</p>

<p>In 1991, <a href="Emo_Welzl" title="wikilink">Emo Welzl</a> proposed a much simpler <a href="randomized_algorithm" title="wikilink">randomized algorithm</a> based in the extension of R. Seidel randomized <a href="linear_programming" title="wikilink">linear programming</a> algorithm. It runs in expected linear time and provided experimental results demonstrating its practicality in higher dimensions.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>The open-source <a href="Computational_Geometry_Algorithms_Library" title="wikilink">Computational Geometry Algorithms Library</a> (CGAL) contains an implementation of this algorithm.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="core-set-based-1ε-approximation">Core-set based 1+ε approximation</h3>

<p>Bădoiu et al. presented a 1+ε approximation on bounding sphere problem.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Where 1+ε approximation means that although a sphere with radius r can not cover the whole point set, the sphere with radius (1+ε)r can cover all points.</p>

<p>"Core set" is a small subset, that a 1+ε expansion of the solution on the subset is a bounding sphere of the whole set. The core set is constructed incrementally by adding the farthest point into the set in iteration.</p>

<p>Kumar et al. improved this approximation algorithm <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> so that it runs in time 

<math display="inline" id="Bounding_sphere:0">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mi>n</mi>
       <mi>d</mi>
      </mrow>
      <mi>ϵ</mi>
     </mfrac>
     <mo>+</mo>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <msup>
        <mi>ϵ</mi>
        <mn>4.5</mn>
       </msup>
      </mfrac>
      <mrow>
       <mi>log</mi>
       <mfrac>
        <mn>1</mn>
        <mi>ϵ</mi>
       </mfrac>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>d</ci>
      </apply>
      <ci>ϵ</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ϵ</ci>
        <cn type="float">4.5</cn>
       </apply>
      </apply>
      <apply>
       <log></log>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>ϵ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\frac{nd}{\epsilon}+\frac{1}{\epsilon^{4.5}}\log{\frac{1}{\epsilon}})
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="fischers-exact-solver">Fischer's Exact Solver</h3>

<p>Fischer et al. proposed an exact solver to this minimal enclosing ball problem.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> The algorithm starts with a big ball that covers all points and gradually shrink it until it can not be shrunk further. In practice, the algorithm is very efficient in low and moderately low (up to 10,000, say) dimensions and is not known to exhibit numerical stability problems. A C++ implementation of the algorithm is available as an <a href="http://github.com/hbf/miniball">open-source project</a>.</p>
<h3 id="bouncing-bubble">Bouncing Bubble</h3>

<p>Bouncing Bubble is an approximation algorithm to the minimal enclosing ball problem.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> It has a few variants for different purpose. The simplest variant runs in time O(nd) with error around 1%~2% is recommended as a substitution of Ritter's algorithm. A simple 1+ε approximation that runs in 

<math display="inline" id="Bounding_sphere:1">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mfrac>
     <mrow>
      <mi>n</mi>
      <mi>d</mi>
     </mrow>
     <msup>
      <mi>ϵ</mi>
      <mn>2</mn>
     </msup>
    </mfrac>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>d</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ϵ</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\frac{nd}{\epsilon^{2}})
  </annotation>
 </semantics>
</math>

 is recommended for lower precision applications (say ε&gt;10<sup>−3</sup>). And another 1+ε approximation that runs in 

<math display="inline" id="Bounding_sphere:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mi>d</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mfrac>
      <mi>d</mi>
      <msup>
       <mi>ϵ</mi>
       <mn>2</mn>
      </msup>
     </mfrac>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>d</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <divide></divide>
      <ci>d</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ϵ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nd)+O(\frac{d}{\epsilon^{2}})
  </annotation>
 </semantics>
</math>

 is recommended for higher precision applications.</p>

<p>The basic idea of this algorithm is simple: each time a point outside the ball is found, the ball will be moved towards it and increase the radius at the same time. The growth in each step is designed so that it will not exceed the optimum radius, thus the radius is getting closer and closer to the optimum.</p>

<p>The following animation demonstrates the process of the first variant:</p>
<figure><b>(Figure)</b>
<figcaption>Animation of Bouncing Bubble algorithm</figcaption>
</figure>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Bounding_volume" title="wikilink">Bounding volume</a></li>
<li><a href="Smallest-circle_problem" title="wikilink">Smallest-circle problem</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.personal.kent.edu/~rmuhamma/Compgeometry/MyCG/CG-Applets/Center/centercli.htm">Smallest Enclosing Circle Problem</a> – describes several algorithms for enclosing a point set, including Megiddo's linear-time algorithm</li>
</ul>

<p>"</p>

<p><a href="Category:Geometric_algorithms" title="wikilink">Category:Geometric algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.ep.liu.se/ecp/034/009/ecp083409.pdf">Fast and Tight Fitting Bounding Spheres</a><a href="#fnref1">↩</a></li>
<li id="fn2">J. Ritter. <a href="http://dl.acm.org/citation.cfm?id=90836">An efficient bounding sphere</a>. In Andrew S. Glassner, editor, Graphics Gems. Academic Press, Boston, MA, 1990.<a href="#fnref2">↩</a></li>
<li id="fn3">Bo Tian, <a href="http://www.grin.com/en/e-book/204869/bouncing-bubble-a-fast-algorithm-for-minimal-enclosing-ball-problem">Bouncing Bubble: A fast algorithm for Minimal Enclosing Ball problem</a> 2012<a href="#fnref3">↩</a></li>
<li id="fn4">Emo Welzl, <a href="http://www.inf.ethz.ch/personal/emo/PublFiles/SmallEnclDisk_LNCS555_91.pdf">Smallest enclosing disks (balls and ellipsoids)</a>, New Results and New Trends in Computer Science, Volume 555, 1991, pp 359–370<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="http://doc.cgal.org/latest/Bounding_volumes/classCGAL_1_1Min__sphere__of__spheres__d.html">CGAL 4.3 - Bounding Volumes - Min_sphere_of_spheres_d</a>, retrieved 2014-03-30.<a href="#fnref5">↩</a></li>
<li id="fn6">M. Bădoiu, S. Har-Peled, and <a href="Piotr_Indyk" title="wikilink">P. Indyk</a>. <a href="http://www.cs.duke.edu/courses/spring07/cps296.2/papers/badoiu02approximate.pdf">Approximate clustering via core-sets</a>. Proc. 34th Annu. ACM Sympos.on Theory of Computing, pages 250–257, 2002.<a href="#fnref6">↩</a></li>
<li id="fn7">P. Kumar, J.S.B. Mitchell and E.A Yıldırım. <a href="http://www.ams.sunysb.edu/~yildirim/meb.pdf">Computing Core-Sets and Approximate Smallest Enclosing HyperSpheres in High Dimensions</a>, 2003<a href="#fnref7">↩</a></li>
<li id="fn8">K. Fischer, B. Gärtner and M. Kutz: <a href="http://people.inf.ethz.ch/gaertner/texts/own_work/seb.pdf">Fast Smallest-Enclosing-Ball Computation in High Dimensions</a>, Proc. 11th European Symposium on Algorithms (ESA), p. 630-641, 2003<a href="#fnref8">↩</a></li>
<li id="fn9"></li>
</ol>
</section>
</body>
</html>
