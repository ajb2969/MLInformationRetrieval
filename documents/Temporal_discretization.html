<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="639">Temporal discretization</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Temporal discretization</h1>
<hr/>

<p>In case of transient problems, the simulations conducted using computer-aided engineering (<a href="Computer-aided_engineering" title="wikilink">CAE</a>) packages require discretizing the governing equations both in space and time. Such problems are unsteady (e.g. flow problems) and therefore provide solution which varies with time for a particular position. Temporal discretization involves the <a href="Integral" title="wikilink">integration</a> of every term in different equations over a time step (Δt). The spatial domain can be discretized to produce a semi-discrete form:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>

<math display="block" id="Temporal_discretization:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <mi>φ</mi>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <mi>t</mi>
      </mrow>
     </mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>φ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <ci>φ</ci>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <ci>t</ci>
      </apply>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>t</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>φ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial\varphi}{\partial t}(x,t)=F(\varphi).~{}
  </annotation>
 </semantics>
</math>

</p>

<p>If the discretization is done using <a href="Backward_differentiation_formula" title="wikilink">backward differences</a>; The first order temporal discretization is given as:<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>

<math display="block" id="Temporal_discretization:1">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <msup>
       <mi>φ</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo>-</mo>
      <msup>
       <mi>φ</mi>
       <mi>n</mi>
      </msup>
     </mrow>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mi>t</mi>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>φ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>φ</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>φ</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>φ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\varphi^{n+1}-\varphi^{n}}{\Delta t}=F(\varphi),
  </annotation>
 </semantics>
</math>

</p>

<p>And the second order <a class="uri" href="discretization" title="wikilink">discretization</a> is given as:</p>

<p>

<math display="block" id="Temporal_discretization:2">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <mrow>
       <mrow>
        <mn>3</mn>
        <msup>
         <mi>φ</mi>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msup>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mn>4</mn>
        <msup>
         <mi>φ</mi>
         <mi>n</mi>
        </msup>
       </mrow>
      </mrow>
      <mo>+</mo>
      <msup>
       <mi>φ</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <mrow>
      <mn>2</mn>
      <mi mathvariant="normal">Δ</mi>
      <mi>t</mi>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>φ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <cn type="integer">3</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>φ</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">4</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>φ</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>φ</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>normal-Δ</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>φ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{3\varphi^{n+1}-4\varphi^{n}+\varphi^{n-1}}{2\Delta t}=F(\varphi),
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p><code>    φ   = a </code><a href="scalar_(physics)" title="wikilink"><code>scalar</code></a><code> quantity.</code></p>

<p><code>    n+1 = value at the next time level,t+Δt.</code></p>

<p><code>    n   = value at the current time level,t.</code></p>

<p><code>    n-1 = value at the previous time level, t-Δt.</code></p>

<p>The function F(

<math display="inline" id="Temporal_discretization:3">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>


) is evaluated using implicit and explicit time integration.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="description">Description</h2>

<p>The temporal discretization is done through <a href="Integral" title="wikilink">integration</a> over time on the general discretized equation. First, values at a given control volume P at time interval t are assumed and then value at time interval t+Δt is found. This method states that the time integral of a given variable is equal to a weighted average between current and future values. The <a class="uri" href="integral" title="wikilink">integral</a> form of the equation can be written as:</p>

<p>

<math display="block" id="Temporal_discretization:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mrow>
       <msup>
        <mi>φ</mi>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mo>-</mo>
       <msup>
        <mi>φ</mi>
        <mi>n</mi>
       </msup>
      </mrow>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>t</mi>
      </mrow>
     </mfrac>
     <mo>=</mo>
     <mi>f</mi>
    </mrow>
    <mo>.</mo>
    <mrow>
     <mrow>
      <mi>F</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>φ</mi>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>.</mo>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>φ</mi>
       <mi>n</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>φ</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>φ</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <ci>f</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>F</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>φ</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>φ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\varphi^{n+1}-\varphi^{n}}{\Delta t}=f.F(\varphi^{n+1})+(1-f).F(\varphi^%
{n}),
  </annotation>
 </semantics>
</math>

</p>

<p>where f is weighing factor ranges between 0 and 1. If</p>

<p><code>  f = 0.0 results in the fully </code><a href="Explicit_and_implicit_methods" title="wikilink"><code>explicit</code> <code>scheme</code></a><code>.</code><br/>
<code>  f = 1.0 results in the fully </code><a href="Explicit_and_implicit_methods" title="wikilink"><code>implicit</code> <code>scheme</code></a><code>.</code><br/>
<code>  f = 0.5 results in the </code><a href="Crank–Nicolson_method" title="wikilink"><code>Crank-Nicolson</code> <code>scheme</code></a><code>.</code><br/>
<code>                                  </code></p>

<p>For any control volume this integration holds true for any discretized variable. The following equation is obtained when applied to the governing equation including full discretized <a class="uri" href="diffusion" title="wikilink">diffusion</a>, <a class="uri" href="convection" title="wikilink">convection</a>, and <a href="Current_source" title="wikilink">source</a> terms.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>

<math display="block" id="Temporal_discretization:5">
 <semantics>
  <mrow>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∫</mo>
    <mi>t</mi>
    <mrow>
     <mi>t</mi>
     <mo>+</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mi>t</mi>
     </mrow>
    </mrow>
   </munderover>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>φ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>d</mi>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>f</mi>
    <mo>.</mo>
    <msubsup>
     <mi>F</mi>
     <mi>φ</mi>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>t</mi>
      </mrow>
     </mrow>
    </msubsup>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo>-</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>.</mo>
    <msubsup>
     <mi>F</mi>
     <mi>φ</mi>
     <mi>t</mi>
    </msubsup>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>t</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <csymbol cd="unknown">F</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">φ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>φ</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <plus></plus>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cn type="integer">1</cn>
      <minus></minus>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-.</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>φ</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">Δ</csymbol>
    <csymbol cd="unknown">t</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int\limits_{t}^{t+\Delta t}F(\varphi)dt=[f.F_{\varphi}^{t+\Delta t}+(1-f).F_{%
\varphi}^{t}]\Delta t
  </annotation>
 </semantics>
</math>

</p>
<h2 id="methods-for-evaluating-function-fvarphi">Methods for evaluating function F(

<math display="inline" id="Temporal_discretization:6">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

)</h2>

<p>After discretizing the time derivative, function F(

<math display="inline" id="Temporal_discretization:7">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

) remains to be evaluated. The function is now evaluated using implicit and explicit time integration.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="implicit-time-integration">Implicit Time Integration</h3>

<p>This methods evaluates the function F(

<math display="inline" id="Temporal_discretization:8">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>


) at a future time.</p>
<h4 id="formulation">Formulation</h4>

<p>The evaluation using Implicit Time Integration is given as:</p>

<p>

<math display="block" id="Temporal_discretization:9">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <msup>
       <mi>φ</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo>-</mo>
      <msup>
       <mi>φ</mi>
       <mi>n</mi>
      </msup>
     </mrow>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mi>t</mi>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>φ</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>φ</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>φ</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>φ</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\varphi^{n+1}-\varphi^{n}}{\Delta t}=F(\varphi^{n+1}),
  </annotation>
 </semantics>
</math>

</p>

<p>This is called implicit integration as φ(n+1) in a given cell is related to φ(n+1) in neighboring cells through F(φ(n+1)):</p>

<p>

<math display="block" id="Temporal_discretization:10">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>φ</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>φ</mi>
      <mi>n</mi>
     </msup>
     <mo>+</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mi>t</mi>
      <mi>F</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>φ</mi>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>φ</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>φ</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>t</ci>
      <ci>F</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>φ</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi^{n+1}=\varphi^{n}+\Delta tF(\varphi^{n+1}),
  </annotation>
 </semantics>
</math>

</p>

<p>In case of Implicit method, the setup is unconditionally stable and can is handle large time step (Δt). But, stability doesn't mean accuracy. Therefore, large Δt affects accuracy and defines time resolution. But, behavior may involve physical timescale that needs to be resolved.</p>
<h3 id="explicit-time-integration">Explicit Time Integration</h3>

<p>This methods evaluates the function F(

<math display="inline" id="Temporal_discretization:11">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

) at a current time.</p>
<h4 id="formulation-1">Formulation</h4>

<p>The evaluation using Explicit Time Integration is given as:</p>

<p>

<math display="block" id="Temporal_discretization:12">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <msup>
       <mi>φ</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo>-</mo>
      <msup>
       <mi>φ</mi>
       <mi>n</mi>
      </msup>
     </mrow>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mi>t</mi>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>φ</mi>
       <mi>n</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>φ</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>φ</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>φ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\varphi^{n+1}-\varphi^{n}}{\Delta t}=F(\varphi^{n}),
  </annotation>
 </semantics>
</math>

</p>

<p>And is referred as explicit integration since φ(n+1) can be expressed explicitly in the existing solution values, φ(n):</p>

<p>

<math display="block" id="Temporal_discretization:13">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>φ</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>φ</mi>
      <mi>n</mi>
     </msup>
     <mo>+</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mi>t</mi>
      <mi>F</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>φ</mi>
        <mi>n</mi>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>φ</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>φ</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>t</ci>
      <ci>F</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>φ</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi^{n+1}=\varphi^{n}+\Delta tF(\varphi^{n}),
  </annotation>
 </semantics>
</math>

</p>

<p>Here, the time step (Δt) is restricted by stability limit of the solver (i.e., time step is limited by the <a href="Courant–Friedrichs–Lewy_condition" title="wikilink">Courant–Friedrichs–Lewy condition</a>. To be accurate w.r.t time, same time step should be used in all the domain and to be stable, the time step must be the minimum of all the local time steps in the domain. This method is also referred to as "global time stepping".</p>
<h4 id="examples">Examples</h4>

<p>Many schemes use Explicit Time Integration. Some of these are as follows :</p>
<ul>
<li><a href="Von_Neumann_stability_analysis" title="wikilink">Von Neumann stability analysis</a>.</li>
<li><a href="Courant–Friedrichs–Lewy_condition" title="wikilink">Courant–Friedrichs–Lewy condition</a>.</li>
<li><a href="Lax–Wendroff_method" title="wikilink">Lax–Wendroff method</a>.</li>
<li><a href="Runge-Kutta_Method" title="wikilink">Runge-Kutta Method</a>.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Finite_element_method" title="wikilink">Finite element method</a></li>
<li><a href="Explicit_and_implicit_methods" title="wikilink">Explicit and implicit methods</a></li>
<li><a href="Chi-Wang_Shu" title="wikilink">Chi-Wang Shu</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Computer-aided_engineering" title="wikilink">Category:Computer-aided engineering</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://gwmftp.jacobs.com/Peer_Review/resolution.pdf">Selection of Spatial and Temporal discretization</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="http://www.pc-progress.com/Documents/Notes_on_Spatial_and_Temporal_Discretization.pdf">Jirka Simunek</a><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
