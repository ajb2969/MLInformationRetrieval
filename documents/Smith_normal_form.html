<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1685">Smith normal form</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Smith normal form</h1>
<hr/>

<p>In mathematics, the <strong>Smith normal form</strong> is a <a href="Canonical_form" title="wikilink">normal form</a> that can be defined for any matrix (not necessarily square) with entries in a <a href="principal_ideal_domain" title="wikilink">principal ideal domain</a> (PID). The Smith normal form of a matrix is <a href="Diagonal_matrix" title="wikilink">diagonal</a>, and can be obtained from the original matrix by multiplying on the left and right by <a class="uri" href="invertible" title="wikilink">invertible</a> square matrices. In particular, the integers are a PID, so one can always calculate the Smith normal form of an integer matrix. The Smith normal form is very useful for working with finitely generated modules over a PID, and in particular for deducing the structure of a quotient of a <a href="free_module" title="wikilink">free module</a>.</p>
<h2 id="definition">Definition</h2>

<p>Let <em>A</em> be a nonzero <em>m</em>×<em>n</em> matrix over a <a href="principal_ideal_domain" title="wikilink">principal ideal domain</a> <em>R</em>. There exist invertible 

<math display="inline" id="Smith_normal_form:0">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>×</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\times m
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Smith_normal_form:1">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times n
  </annotation>
 </semantics>
</math>

-matrices <em>S, T</em> so that the product <em>S A T</em> is</p>

<p>

<math display="block" id="Smith_normal_form:2">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>α</mi>
        <mn>1</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>α</mi>
        <mn>2</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋱</mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>α</mi>
        <mi>r</mi>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋱</mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <csymbol cd="latexml">absent</csymbol>
     <ci>normal-⋯</ci>
     <csymbol cd="latexml">absent</csymbol>
     <cn type="integer">0</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">0</cn>
     <csymbol cd="latexml">absent</csymbol>
     <ci>normal-⋯</ci>
     <csymbol cd="latexml">absent</csymbol>
     <cn type="integer">0</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <ci>normal-⋱</ci>
     <csymbol cd="latexml">absent</csymbol>
     <csymbol cd="latexml">absent</csymbol>
     <csymbol cd="latexml">absent</csymbol>
     <cn type="integer">0</cn>
    </matrixrow>
    <matrixrow>
     <ci>normal-⋮</ci>
     <csymbol cd="latexml">absent</csymbol>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>r</ci>
     </apply>
     <csymbol cd="latexml">absent</csymbol>
     <csymbol cd="latexml">absent</csymbol>
     <ci>normal-⋮</ci>
    </matrixrow>
    <matrixrow>
     <csymbol cd="latexml">absent</csymbol>
     <csymbol cd="latexml">absent</csymbol>
     <csymbol cd="latexml">absent</csymbol>
     <csymbol cd="latexml">absent</csymbol>
     <cn type="integer">0</cn>
     <csymbol cd="latexml">absent</csymbol>
     <csymbol cd="latexml">absent</csymbol>
    </matrixrow>
    <matrixrow>
     <csymbol cd="latexml">absent</csymbol>
     <csymbol cd="latexml">absent</csymbol>
     <csymbol cd="latexml">absent</csymbol>
     <csymbol cd="latexml">absent</csymbol>
     <csymbol cd="latexml">absent</csymbol>
     <ci>normal-⋱</ci>
     <csymbol cd="latexml">absent</csymbol>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <csymbol cd="latexml">absent</csymbol>
     <csymbol cd="latexml">absent</csymbol>
     <ci>normal-⋯</ci>
     <csymbol cd="latexml">absent</csymbol>
     <csymbol cd="latexml">absent</csymbol>
     <cn type="integer">0</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{pmatrix}\alpha_{1}&0&0&&\cdots&&0\\
0&\alpha_{2}&0&&\cdots&&0\\
0&0&\ddots&&&&0\\
\vdots&&&\alpha_{r}&&&\vdots\\
&&&&0&&\\
&&&&&\ddots&\\
0&&&\cdots&&&0\end{pmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>and the diagonal elements 

<math display="inline" id="Smith_normal_form:3">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}
  </annotation>
 </semantics>
</math>

 satisfy 

<math display="inline" id="Smith_normal_form:4">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mi>i</mi>
   </msub>
   <mo>∣</mo>
   <mpadded width="+2.8pt">
    <msub>
     <mi>α</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mpadded>
   <mo>∀</mo>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>i</mi>
   <mo><</mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-∣</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <cn type="float">1</cn>
    <leq></leq>
    <csymbol cd="unknown">i</csymbol>
    <lt></lt>
    <csymbol cd="unknown">r</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}\mid\alpha_{i+1}\;\forall\;1\leq i<r
  </annotation>
 </semantics>
</math>

. This is the Smith normal form of the matrix <em>A</em>. The elements 

<math display="inline" id="Smith_normal_form:5">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}
  </annotation>
 </semantics>
</math>

 are unique <a href="up_to" title="wikilink">up to</a> multiplication by a <a href="Unit_(ring_theory)" title="wikilink">unit</a> and are called the <em>elementary divisors</em>, <em>invariants</em>, or <em>invariant factors</em>. They can be computed (up to multiplication by a unit) as</p>

<p>

<math display="block" id="Smith_normal_form:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>α</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <msub>
       <mi>d</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <msub>
       <mi>d</mi>
       <mrow>
        <mi>i</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <ci>i</ci>
      </apply>
      <ci>A</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}=\frac{d_{i}(A)}{d_{i-1}(A)},
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Smith_normal_form:7">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>i</ci>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{i}(A)
  </annotation>
 </semantics>
</math>

 (called <em>i</em>-th <em>determinant divisor</em>) equals the <a href="greatest_common_divisor" title="wikilink">greatest common divisor</a> of all 

<math display="inline" id="Smith_normal_form:8">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>×</mo>
   <mi>i</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>i</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\times i
  </annotation>
 </semantics>
</math>

 <a href="Minor_(linear_algebra)" title="wikilink">minors</a> of the matrix <em>A</em>.</p>
<h2 id="algorithm">Algorithm</h2>

<p>Our first goal will be to find invertible square matrices <em>S</em> and <em>T</em> such that the product <em>S A T</em> is diagonal. This is the hardest part of the algorithm and once we have achieved diagonality it becomes relatively easy to put the matrix in Smith normal form. Phrased more abstractly, the goal is to show that, thinking of <em>A</em> as a map from 

<math display="inline" id="Smith_normal_form:9">
 <semantics>
  <msup>
   <mi>R</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{n}
  </annotation>
 </semantics>
</math>

 (the free <em>R</em>-<a href="Module_(mathematics)" title="wikilink">module</a> of rank <em>n</em>) to 

<math display="inline" id="Smith_normal_form:10">
 <semantics>
  <msup>
   <mi>R</mi>
   <mi>m</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{m}
  </annotation>
 </semantics>
</math>

 (the free <em>R</em>-<a href="Module_(mathematics)" title="wikilink">module</a> of rank <em>m</em>), there are isomorphisms 

<math display="inline" id="Smith_normal_form:11">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>R</mi>
     <mi>m</mi>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>R</mi>
     <mi>m</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>S</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S:R^{m}\to R^{m}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Smith_normal_form:12">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>R</mi>
     <mi>n</mi>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>R</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>T</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T:R^{n}\to R^{n}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Smith_normal_form:13">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⋅</mo>
   <mi>A</mi>
   <mo>⋅</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>S</ci>
    <ci>A</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\cdot A\cdot T
  </annotation>
 </semantics>
</math>

 has the simple form of a <a href="diagonal_matrix" title="wikilink">diagonal matrix</a>. The matrices <em>S</em> and <em>T</em> can be found by starting out with identity matrices of the appropriate size, and modifying <em>S</em> each time a row operation is performed on <em>A</em> in the algorithm by the same row operation, and similarly modifying <em>T</em> for each column operation performed. Since row operations are left-multiplications and column operations are right-multiplications, this preserves the invariant 

<math display="inline" id="Smith_normal_form:14">
 <semantics>
  <mrow>
   <msup>
    <mi>A</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>S</mi>
     <mo>′</mo>
    </msup>
    <mo>⋅</mo>
    <mi>A</mi>
    <mo>⋅</mo>
    <msup>
     <mi>T</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{\prime}=S^{\prime}\cdot A\cdot T^{\prime}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Smith_normal_form:15">
 <semantics>
  <mrow>
   <msup>
    <mi>A</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>S</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>T</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <ci>normal-′</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{\prime},S^{\prime},T^{\prime}
  </annotation>
 </semantics>
</math>

 denote current values and <em>A</em> denotes the original matrix; eventually the matrices in this invariant become diagonal. Only invertible row and column operations are performed, which ensures that <em>S</em> and <em>T</em> remain invertible matrices.</p>

<p>For <em>a</em> in <em>R</em> \ {0}, write δ(<em>a</em>) for the number of prime factors of <em>a</em> (these exist and are unique since any PID is also a <a href="unique_factorization_domain" title="wikilink">unique factorization domain</a>). In particular, <em>R</em> is also a <a href="Bézout_domain" title="wikilink">Bézout domain</a>, so it is a <a href="gcd_domain" title="wikilink">gcd domain</a> and the gcd of any two elements satisfies a <a href="Bézout's_identity" title="wikilink">Bézout's identity</a>.</p>

<p>To put a matrix into Smith normal form, one can repeatedly apply the following, where <em>t</em> loops from 1 to <em>m</em>.</p>
<h3 id="step-i-choosing-a-pivot">Step I: Choosing a pivot</h3>

<p>Choose <em>j</em><sub><em>t</em></sub> to be the smallest column index of <em>A</em> with a non-zero entry, starting the search at column index <em>j</em><sub><em>t</em>-1</sub>+1 if <em>t</em> &gt; 1.</p>

<p>We wish to have 

<math display="inline" id="Smith_normal_form:16">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>t</mi>
     <mo>,</mo>
     <msub>
      <mi>j</mi>
      <mi>t</mi>
     </msub>
    </mrow>
   </msub>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <list>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>j</ci>
       <ci>t</ci>
      </apply>
     </list>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{t,j_{t}}\neq 0
  </annotation>
 </semantics>
</math>

; if this is the case this step is complete, otherwise there is by assumption some <em>k</em> with 

<math display="inline" id="Smith_normal_form:17">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>k</mi>
     <mo>,</mo>
     <msub>
      <mi>j</mi>
      <mi>t</mi>
     </msub>
    </mrow>
   </msub>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <list>
      <ci>k</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>j</ci>
       <ci>t</ci>
      </apply>
     </list>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{k,j_{t}}\neq 0
  </annotation>
 </semantics>
</math>

, and we can exchange rows 

<math display="inline" id="Smith_normal_form:18">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 and <em>k</em>, thereby obtaining 

<math display="inline" id="Smith_normal_form:19">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>t</mi>
     <mo>,</mo>
     <msub>
      <mi>j</mi>
      <mi>t</mi>
     </msub>
    </mrow>
   </msub>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <list>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>j</ci>
       <ci>t</ci>
      </apply>
     </list>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{t,j_{t}}\neq 0
  </annotation>
 </semantics>
</math>

.</p>

<p>Our chosen pivot is now at position (<em>t</em>, <em>j</em><sub><em>t</em></sub>).</p>
<h3 id="step-ii-improving-the-pivot">Step II: Improving the pivot</h3>

<p>If there is an entry at position (<em>k</em>,<em>j</em><sub><em>t</em></sub>) such that 

<math display="inline" id="Smith_normal_form:20">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>t</mi>
     <mo>,</mo>
     <msub>
      <mi>j</mi>
      <mi>t</mi>
     </msub>
    </mrow>
   </msub>
   <mo>∤</mo>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>k</mi>
     <mo>,</mo>
     <msub>
      <mi>j</mi>
      <mi>t</mi>
     </msub>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-divides</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <list>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>j</ci>
       <ci>t</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <list>
      <ci>k</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>j</ci>
       <ci>t</ci>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{t,j_{t}}\nmid a_{k,j_{t}}
  </annotation>
 </semantics>
</math>

, then, letting 

<math display="inline" id="Smith_normal_form:21">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>=</mo>
   <mrow>
    <mi>gcd</mi>
    <mrow>
     <mo>(</mo>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>t</mi>
       <mo>,</mo>
       <msub>
        <mi>j</mi>
        <mi>t</mi>
       </msub>
      </mrow>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>k</mi>
       <mo>,</mo>
       <msub>
        <mi>j</mi>
        <mi>t</mi>
       </msub>
      </mrow>
     </msub>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>β</ci>
    <apply>
     <gcd></gcd>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <list>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>j</ci>
        <ci>t</ci>
       </apply>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <list>
       <ci>k</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>j</ci>
        <ci>t</ci>
       </apply>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta=\gcd\left(a_{t,j_{t}},a_{k,j_{t}}\right)
  </annotation>
 </semantics>
</math>

, we know by the Bézout property that there exist σ, τ in <em>R</em> such that</p>

<p>

<math display="block" id="Smith_normal_form:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>a</mi>
       <mrow>
        <mi>t</mi>
        <mo>,</mo>
        <msub>
         <mi>j</mi>
         <mi>t</mi>
        </msub>
       </mrow>
      </msub>
      <mo>⋅</mo>
      <mi>σ</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mrow>
        <mi>k</mi>
        <mo>,</mo>
        <msub>
         <mi>j</mi>
         <mi>t</mi>
        </msub>
       </mrow>
      </msub>
      <mo>⋅</mo>
      <mi>τ</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>β</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <list>
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>j</ci>
         <ci>t</ci>
        </apply>
       </list>
      </apply>
      <ci>σ</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <list>
        <ci>k</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>j</ci>
         <ci>t</ci>
        </apply>
       </list>
      </apply>
      <ci>τ</ci>
     </apply>
    </apply>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{t,j_{t}}\cdot\sigma+a_{k,j_{t}}\cdot\tau=\beta.
  </annotation>
 </semantics>
</math>

</p>

<p>By left-multiplication with an appropriate invertible matrix <em>L</em>, it can be achieved that row <em>t</em> of the matrix product is the sum of σ times the original row <em>t</em> and τ times the original row <em>k</em>, that row <em>k</em> of the product is another linear combination of those original rows, and that all other rows are unchanged. Explicitly, if σ and τ satisfy the above equation, then for 

<math display="inline" id="Smith_normal_form:23">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>t</mi>
      <mo>,</mo>
      <msub>
       <mi>j</mi>
       <mi>t</mi>
      </msub>
     </mrow>
    </msub>
    <mo>/</mo>
    <mi>β</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>α</ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <list>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>j</ci>
        <ci>t</ci>
       </apply>
      </list>
     </apply>
     <ci>β</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=a_{t,j_{t}}/\beta
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Smith_normal_form:24">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>k</mi>
      <mo>,</mo>
      <msub>
       <mi>j</mi>
       <mi>t</mi>
      </msub>
     </mrow>
    </msub>
    <mo>/</mo>
    <mi>β</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>γ</ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <list>
       <ci>k</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>j</ci>
        <ci>t</ci>
       </apply>
      </list>
     </apply>
     <ci>β</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma=a_{k,j_{t}}/\beta
  </annotation>
 </semantics>
</math>

 (which divisions are possible by the definition of β) one has</p>

<p>

<math display="block" id="Smith_normal_form:25">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>σ</mi>
      <mo>⋅</mo>
      <mi>α</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>τ</mi>
      <mo>⋅</mo>
      <mi>γ</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-⋅</ci>
      <ci>σ</ci>
      <ci>α</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <ci>τ</ci>
      <ci>γ</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\cdot\alpha+\tau\cdot\gamma=1,
  </annotation>
 </semantics>
</math>

</p>

<p>so that the matrix</p>

<p>

<math display="block" id="Smith_normal_form:26">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mi>σ</mi>
      </mtd>
      <mtd columnalign="center">
       <mi>τ</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mi>γ</mi>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mi>α</mi>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <cn type="integer">0</cn>
    </apply>
    <matrix>
     <matrixrow>
      <ci>σ</ci>
      <ci>τ</ci>
     </matrixrow>
     <matrixrow>
      <apply>
       <minus></minus>
       <ci>γ</ci>
      </apply>
      <ci>α</ci>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{0}=\begin{pmatrix}\sigma&\tau\\
-\gamma&\alpha\\
\end{pmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>is invertible, with inverse</p>

<p>

<math display="block" id="Smith_normal_form:27">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mi>α</mi>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mi>τ</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi>γ</mi>
      </mtd>
      <mtd columnalign="center">
       <mi>σ</mi>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <ci>α</ci>
     <apply>
      <minus></minus>
      <ci>τ</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <ci>γ</ci>
     <ci>σ</ci>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{pmatrix}\alpha&-\tau\\
\gamma&\sigma\\
\end{pmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>Now <em>L</em> can be obtained by fitting 

<math display="inline" id="Smith_normal_form:28">
 <semantics>
  <msub>
   <mi>L</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{0}
  </annotation>
 </semantics>
</math>

 into rows and columns <em>t</em> and <em>k</em> of the identity matrix. By construction the matrix obtained after left-multiplying by <em>L</em> has entry β at position (<em>t</em>,<em>j</em><sub><em>t</em></sub>) (and due to our choice of α and γ it also has an entry 0 at position (<em>k</em>,<em>j</em><sub><em>t</em></sub>), which is useful though not essential for the algorithm). This new entry β divides the entry 

<math display="inline" id="Smith_normal_form:29">
 <semantics>
  <msub>
   <mi>a</mi>
   <mrow>
    <mi>t</mi>
    <mo>,</mo>
    <msub>
     <mi>j</mi>
     <mi>t</mi>
    </msub>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <list>
     <ci>t</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>j</ci>
      <ci>t</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{t,j_{t}}
  </annotation>
 </semantics>
</math>

 that was there before, and so in particular 

<math display="inline" id="Smith_normal_form:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>β</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>t</mi>
       <mo>,</mo>
       <msub>
        <mi>j</mi>
        <mi>t</mi>
       </msub>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>δ</ci>
     <ci>β</ci>
    </apply>
    <apply>
     <times></times>
     <ci>δ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <list>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>j</ci>
        <ci>t</ci>
       </apply>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(\beta)<\delta(a_{t,j_{t}})
  </annotation>
 </semantics>
</math>

; therefore repeating these steps must eventually terminate. One ends up with a matrix having an entry at position (<em>t</em>,<em>j</em><sub><em>t</em></sub>) that divides all entries in column <em>j</em><sub><em>t</em></sub>.</p>
<h3 id="step-iii-eliminating-entries">Step III: Eliminating entries</h3>

<p>Finally, adding appropriate multiples of row <em>t</em>, it can be achieved that all entries in column <em>j</em><sub><em>t</em></sub> except for that at position (<em>t</em>,<em>j</em><sub><em>t</em></sub>) are zero. This can be achieved by left-multiplication with an appropriate matrix. However, to make the matrix fully diagonal we need to eliminate nonzero entries on the row of position (<em>t</em>,<em>j</em><sub><em>t</em></sub>) as well. This can be achieved by repeating the steps in Step II for columns instead of rows, and using multiplication on the right. In general this will result in the zero entries from the prior application of Step III becoming nonzero again.</p>

<p>However, notice that the <a href="ideal_(ring_theory)" title="wikilink">ideals</a> generated by the elements at position (<em>t</em>,<em>j</em><sub><em>t</em></sub>) form an <a href="ascending_chain_condition" title="wikilink">ascending chain</a>, because entries from a later step always divide entries from a previous step. Therefore, since <em>R</em> is a <a href="Noetherian_ring" title="wikilink">Noetherian ring</a> (it is a <a href="principal_ideal_domain" title="wikilink">PID</a>), the ideals eventually become stationary and do not change. This means that at some stage after Step II has been applied, the entry at (<em>t</em>,<em>j</em><sub><em>t</em></sub>) will divide all nonzero row or column entries before applying any more steps in Step II. Then we can eliminate entries in the row or column with nonzero entries while preserving the zeros in the already-zero row or column. At this point, only the block of <em>A</em> to the lower right of (<em>t</em>,<em>j</em><sub><em>t</em></sub>) needs to be diagonalized, and conceptually the algorithm can be applied recursively, treating this block as a separate matrix. In other words, we can increment <em>t</em> by one and go back to Step I.</p>
<h3 id="final-step">Final step</h3>

<p>Applying the steps described above to the remaining non-zero columns of the resulting matrix (if any), we get an 

<math display="inline" id="Smith_normal_form:31">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\times n
  </annotation>
 </semantics>
</math>

-matrix with column indices 

<math display="inline" id="Smith_normal_form:32">
 <semantics>
  <mrow>
   <msub>
    <mi>j</mi>
    <mn>1</mn>
   </msub>
   <mo><</mo>
   <mi mathvariant="normal">…</mi>
   <mo><</mo>
   <msub>
    <mi>j</mi>
    <mi>r</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>j</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>j</ci>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j_{1}<\ldots<j_{r}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Smith_normal_form:33">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>≤</mo>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>r</ci>
    <apply>
     <min></min>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\leq\min(m,n)
  </annotation>
 </semantics>
</math>

. The matrix entries 

<math display="inline" id="Smith_normal_form:34">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>l</mi>
   <mo>,</mo>
   <msub>
    <mi>j</mi>
    <mi>l</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>l</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>j</ci>
     <ci>l</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (l,j_{l})
  </annotation>
 </semantics>
</math>

 are non-zero, and every other entry is zero.</p>

<p>Now we can move the null columns of this matrix to the right, so that the nonzero entries are on positions 

<math display="inline" id="Smith_normal_form:35">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>i</mi>
   <mo>,</mo>
   <mi>i</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>i</ci>
    <ci>i</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i,i)
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Smith_normal_form:36">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>i</mi>
   <mo>≤</mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq i\leq r
  </annotation>
 </semantics>
</math>

. For short, set 

<math display="inline" id="Smith_normal_form:37">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}
  </annotation>
 </semantics>
</math>

 for the element at position 

<math display="inline" id="Smith_normal_form:38">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>i</mi>
   <mo>,</mo>
   <mi>i</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>i</ci>
    <ci>i</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i,i)
  </annotation>
 </semantics>
</math>

.</p>

<p>The condition of divisibility of diagonal entries might not be satisfied. For any index 

<math display="inline" id="Smith_normal_form:39">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, one can repair this shortcoming by operations on rows and columns 

<math display="inline" id="Smith_normal_form:40">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>i</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i+1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Smith_normal_form:41">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>i</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i+1
  </annotation>
 </semantics>
</math>

 only: first add column 

<math display="inline" id="Smith_normal_form:42">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 to column 

<math display="inline" id="Smith_normal_form:43">
 <semantics>
  <msub>
   <mi>α</mi>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i+1}
  </annotation>
 </semantics>
</math>

 to get an entry 

<math display="inline" id="Smith_normal_form:44">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}
  </annotation>
 </semantics>
</math>

 in column <em>i</em> without disturbing the entry 

<math display="inline" id="Smith_normal_form:45">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>i</mi>
   <mo>,</mo>
   <mi>i</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>i</ci>
    <ci>i</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i,i)
  </annotation>
 </semantics>
</math>

 at position 

<math display="inline" id="Smith_normal_form:46">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>i</mi>
   <mo>,</mo>
   <mi>i</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>i</ci>
    <ci>i</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i,i)
  </annotation>
 </semantics>
</math>

, and then apply a row operation to make the entry at position 

<math display="inline" id="Smith_normal_form:47">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>=</mo>
   <mrow>
    <mi>gcd</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>α</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>β</ci>
    <apply>
     <gcd></gcd>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta=\gcd(\alpha_{i},\alpha_{i+1})
  </annotation>
 </semantics>
</math>

 equal to 

<math display="inline" id="Smith_normal_form:48">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <plus></plus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i+1,i+1)
  </annotation>
 </semantics>
</math>

 as in Step II; finally proceed as in Step III to make the matrix diagonal again. Since the new entry at position 

<math display="inline" id="Smith_normal_form:49">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mi>i</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>α</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i},\alpha_{i+1}
  </annotation>
 </semantics>
</math>

 is a linear combination of the original 

<math display="inline" id="Smith_normal_form:50">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>+</mo>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mi>r</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>δ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <times></times>
     <ci>δ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(\alpha_{1})+\cdots+\delta(\alpha_{r})
  </annotation>
 </semantics>
</math>

, it is divisible by β.</p>

<p>The value 

<math display="inline" id="Smith_normal_form:51">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>×</mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\times r
  </annotation>
 </semantics>
</math>

 does not change by the above operation (it is δ of the determinant of the upper 

<math display="block" id="Smith_normal_form:52">
 <semantics>
  <mrow>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>r</mi>
    </munderover>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>r</mi>
       <mo>-</mo>
       <mi>j</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>α</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>r</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>r</ci>
      <ci>j</ci>
     </apply>
     <ci>δ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{j=1}^{r}(r-j)\delta(\alpha_{j}).
  </annotation>
 </semantics>
</math>

 submatrix), whence that operation does diminish (by moving prime factors to the right) the value of</p>

<p>

<math display="inline" id="Smith_normal_form:53">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mn>1</mn>
   </msub>
   <mo>∣</mo>
   <msub>
    <mi>α</mi>
    <mn>2</mn>
   </msub>
   <mo>∣</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>∣</mo>
   <msub>
    <mi>α</mi>
    <mi>r</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-∣</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-∣</ci>
    <ci>normal-⋯</ci>
    <ci>normal-∣</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>r</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{1}\mid\alpha_{2}\mid\cdots\mid\alpha_{r}
  </annotation>
 </semantics>
</math>

 So after finitely many applications of this operation no further application is possible, which means that we have obtained 

<math display="inline" id="Smith_normal_form:54">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>×</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\times m
  </annotation>
 </semantics>
</math>

 as desired.</p>

<p>Since all row and column manipulations involved in the process are invertible, this shows that there exist invertible 

<math display="inline" id="Smith_normal_form:55">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times n
  </annotation>
 </semantics>
</math>

 and 

<math display="block" id="Smith_normal_form:56">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <mn>2</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>4</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>4</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mn>6</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mn>6</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>12</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>10</mn>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mn>4</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mn>16</mn>
      </mrow>
     </mtd>
    </mtr>
   </mtable>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">2</cn>
     <cn type="integer">4</cn>
     <cn type="integer">4</cn>
    </matrixrow>
    <matrixrow>
     <apply>
      <minus></minus>
      <cn type="integer">6</cn>
     </apply>
     <cn type="integer">6</cn>
     <cn type="integer">12</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">10</cn>
     <apply>
      <minus></minus>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">16</cn>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{pmatrix}2&4&4\\
-6&6&12\\
10&-4&-16\end{pmatrix}
  </annotation>
 </semantics>
</math>

-matrices <em>S, T</em> so that the product <em>S A T</em> satisfies the definition of a Smith normal form. In particular, this shows that the Smith normal form exists, which was assumed without proof in the definition.</p>
<h2 id="applications">Applications</h2>

<p>The Smith normal form is useful for computing the <a href="homology_(mathematics)" title="wikilink">homology</a> of a <a href="chain_complex" title="wikilink">chain complex</a> when the chain modules of the chain complex are <a href="Finitely_generated_module" title="wikilink">finitely generated</a>. For instance, in <a class="uri" href="topology" title="wikilink">topology</a>, it can be used to compute the homology of a <a href="simplicial_complex" title="wikilink">simplicial complex</a> or <a href="CW_complex" title="wikilink">CW complex</a> over the integers, because the boundary maps in such a complex are just integer matrices. It can also be used to determine the <a href="invariant_factor" title="wikilink">invariant factors</a> that occur in the <a href="structure_theorem_for_finitely_generated_modules_over_a_principal_ideal_domain" title="wikilink">structure theorem for finitely generated modules over a principal ideal domain</a>.</p>
<h2 id="example">Example</h2>

<p>As an example, we will find the Smith normal form of the following matrix over the integers.</p>

<p>

<math display="block" id="Smith_normal_form:57">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>→</mo>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>2</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>6</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>18</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>24</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>10</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>24</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>36</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>2</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>18</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>24</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>24</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>36</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <csymbol cd="latexml">absent</csymbol>
     <matrix>
      <matrixrow>
       <cn type="integer">2</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <apply>
        <minus></minus>
        <cn type="integer">6</cn>
       </apply>
       <cn type="integer">18</cn>
       <cn type="integer">24</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">10</cn>
       <apply>
        <minus></minus>
        <cn type="integer">24</cn>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">36</cn>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <matrix>
      <matrixrow>
       <cn type="integer">2</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">18</cn>
       <cn type="integer">24</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <apply>
        <minus></minus>
        <cn type="integer">24</cn>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">36</cn>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to\begin{pmatrix}2&0&0\\
-6&18&24\\
10&-24&-36\end{pmatrix}\to\begin{pmatrix}2&0&0\\
0&18&24\\
0&-24&-36\end{pmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>The following matrices are the intermediate steps as the algorithm is applied to the above matrix.</p>

<p>

<math display="block" id="Smith_normal_form:58">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>→</mo>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>2</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>18</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>24</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>6</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>12</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>2</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>6</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>12</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>18</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>24</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <csymbol cd="latexml">absent</csymbol>
     <matrix>
      <matrixrow>
       <cn type="integer">2</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">18</cn>
       <cn type="integer">24</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <apply>
        <minus></minus>
        <cn type="integer">6</cn>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">12</cn>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <matrix>
      <matrixrow>
       <cn type="integer">2</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">6</cn>
       <cn type="integer">12</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">18</cn>
       <cn type="integer">24</cn>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to\begin{pmatrix}2&0&0\\
0&18&24\\
0&-6&-12\end{pmatrix}\to\begin{pmatrix}2&0&0\\
0&6&12\\
0&18&24\end{pmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Smith_normal_form:59">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>→</mo>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>2</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>6</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>12</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>12</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>2</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>6</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>12</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <csymbol cd="latexml">absent</csymbol>
     <matrix>
      <matrixrow>
       <cn type="integer">2</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">6</cn>
       <cn type="integer">12</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <apply>
        <minus></minus>
        <cn type="integer">12</cn>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <matrix>
      <matrixrow>
       <cn type="integer">2</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">6</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">12</cn>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to\begin{pmatrix}2&0&0\\
0&6&12\\
0&0&-12\end{pmatrix}\to\begin{pmatrix}2&0&0\\
0&6&0\\
0&0&12\end{pmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Smith_normal_form:60">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <mn>2</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>6</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>12</mn>
     </mtd>
    </mtr>
   </mtable>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">2</cn>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">6</cn>
     <cn type="integer">0</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <cn type="integer">12</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{pmatrix}2&0&0\\
0&6&0\\
0&0&12\end{pmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>So the Smith normal form is</p>

<p>

<math display="inline" id="Smith_normal_form:61">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mi>I</mi>
   </mrow>
   <mo>-</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>I</ci>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   xI-A
  </annotation>
 </semantics>
</math>

</p>

<p>and the invariant factors are 2, 6 and 12.</p>
<h2 id="similarity">Similarity</h2>

<p>The Smith normal form can be used to determine whether or not matrices with entries over a common field are <a href="similar_(linear_algebra)" title="wikilink">similar</a>. Specifically two matrices <em>A</em> and <em>B</em> are similar if and only if the <a href="characteristic_matrix" title="wikilink">characteristic matrices</a> 

<math display="inline" id="Smith_normal_form:62">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mi>I</mi>
   </mrow>
   <mo>-</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>I</ci>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   xI-B
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Smith_normal_form:63">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle A
  </annotation>
 </semantics>
</math>


 have the same Smith normal form.</p>

<p>For example, with</p>

<p><span class="LaTeX">$$\begin{align}
A &amp; {} =\begin{bmatrix}
 1 &amp; 2 \\
 0 &amp; 1 
\end{bmatrix}, &amp; &amp; \mbox{SNF}(xI-A) =\begin{bmatrix}
 1 &amp; 0 \\
 0 &amp; (x-1)^2
\end{bmatrix} \\
B &amp; {} =\begin{bmatrix}
 3 &amp; -4 \\
 1 &amp; -1 
\end{bmatrix}, &amp; &amp; \mbox{SNF}(xI-B) =\begin{bmatrix}
 1 &amp; 0 \\
 0 &amp; (x-1)^2
\end{bmatrix} \\
C &amp; {} =\begin{bmatrix}
 1 &amp; 0 \\
 1 &amp; 2 
\end{bmatrix}, &amp; &amp; \mbox{SNF}(xI-C) =\begin{bmatrix}
 1 &amp; 0 \\
 0 &amp; (x-1)(x-2)
\end{bmatrix}.
\end{align}$$</span></p>

<p><em>A</em> and <em>B</em> are similar because the Smith normal form of their characteristic matrices match, but are not similar to <em>C</em> because the Smith normal form of the characteristic matrices do not match.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Canonical_form" title="wikilink">Canonical form</a></li>
<li><a href="Elementary_divisors" title="wikilink">Elementary divisors</a></li>
<li><a href="Frobenius_normal_form" title="wikilink">Frobenius normal form</a> (also called Rational canonical form)</li>
<li><a href="Hermite_normal_form" title="wikilink">Hermite normal form</a></li>
<li><a href="Invariant_factor" title="wikilink">Invariant factor</a></li>
<li><a href="Henry_John_Stephen_Smith" title="wikilink">Henry John Stephen Smith</a> (1826–1883), <a class="uri" href="eponym" title="wikilink">eponym</a> of the Smith normal form</li>
<li><a href="Structure_theorem_for_finitely_generated_modules_over_a_principal_ideal_domain" title="wikilink">Structure theorem for finitely generated modules over a principal ideal domain</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>

<p>Reprinted (pp. <a href="http://archive.org/stream/collectedmathema01smituoft#page/366/mode/2up">367–409</a>) in <a href="http://archive.org/details/collectedmathema01smituoft"><em>The Collected Mathematical Papers of Henry John Stephen Smith</em>, Vol. I</a>, edited by <a href="James_Whitbread_Lee_Glaisher" title="wikilink">J. W. L. Glaisher</a>. Oxford: Clarendon Press (1894), <em>xcv</em>+603 pp.</p></li>
<li></li>
<li></li>
<li>K. R. Matthews, <a href="http://www.numbertheory.org/courses/MP274/smith.pdf">Smith normal form</a>. MP274: Linear Algebra, Lecture Notes, University of Queensland, 1991.</li>
<li><a href="http://pageperso.univ-brest.fr/~huisman/ens/coursbrest.html#gea">An animated example</a>.</li>
</ul>

<p>"</p>

<p><a href="Category:Matrix_theory" title="wikilink">Category:Matrix theory</a> <a href="Category:Matrix_normal_forms" title="wikilink">Category:Matrix normal forms</a></p>
</body>
</html>
