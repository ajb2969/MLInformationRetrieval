<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1706">Walk-on-spheres method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Walk-on-spheres method</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the <strong>walk-on-spheres method (WoS)</strong> is a numerical probabilistic <a class="uri" href="algorithm" title="wikilink">algorithm</a>, or <a href="Monte-Carlo_method" title="wikilink">Monte-Carlo method</a>, used mainly in order to approximate the solutions of some specific <a href="boundary_value_problem" title="wikilink">boundary value problem</a> for <a href="partial_differential_equations" title="wikilink">partial differential equations</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The WoS method was first introduced by M. E. Muller in 1956 to solve <a href="Laplace's_equation" title="wikilink">Laplace's equation</a>,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and was since then generalized to other problems.</p>

<p>It relies on probabilistic interpretations of PDEs, by simulating paths of <a href="Brownian_motion" title="wikilink">Brownian motion</a> (or for some more general variants, <a href="diffusion_processes" title="wikilink">diffusion processes</a>), and it is today one of the most widely used "grid-free" algorithms for generating Brownian paths.</p>
<h2 id="informal-description">Informal description</h2>

<p>Let 

<math display="inline" id="Walk-on-spheres_method:0">
 <semantics>
  <mi mathvariant="normal">Œ©</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Œ©</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 be a bounded <a href="Domain_(mathematical_analysis)" title="wikilink">domain</a> in 

<math display="inline" id="Walk-on-spheres_method:1">
 <semantics>
  <msup>
   <mi>‚Ñù</mi>
   <mi>d</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>‚Ñù</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{d}
  </annotation>
 </semantics>
</math>

 with a sufficiently regular boundary 

<math display="inline" id="Walk-on-spheres_method:2">
 <semantics>
  <mi mathvariant="normal">Œì</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Œì</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

, let <em>h</em> be a function on 

<math display="inline" id="Walk-on-spheres_method:3">
 <semantics>
  <mi mathvariant="normal">Œì</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Œì</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

, and let 

<math display="inline" id="Walk-on-spheres_method:4">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 be a point inside 

<math display="inline" id="Walk-on-spheres_method:5">
 <semantics>
  <mi mathvariant="normal">Œ©</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Œ©</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

.</p>

<p>Let us consider the Dirichlet problem:</p>

<p>

<math display="block" id="Walk-on-spheres_method:6">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mi mathvariant="normal">Œî</mi>
        <mi>u</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
     </mtd>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mtext>if</mtext>
        <mi>x</mi>
       </mrow>
       <mo>‚àà</mo>
       <mi mathvariant="normal">Œ©</mi>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mi>u</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mrow>
        <mi>h</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mtd>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>x</mi>
        </mrow>
        <mo>‚àà</mo>
        <mi mathvariant="normal">Œì</mi>
       </mrow>
       <mo>.</mo>
      </mrow>
     </mtd>
    </mtr>
   </mtable>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">cases</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>normal-Œî</ci>
      <ci>u</ci>
      <ci>x</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <mtext>if</mtext>
      <ci>x</ci>
     </apply>
     <ci>normal-Œ©</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>u</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <mtext>if</mtext>
      <ci>x</ci>
     </apply>
     <ci>normal-Œì</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{cases}\Delta u(x)=0&\mbox{if }x\in\Omega\\
u(x)=h(x)&\mbox{if }x\in\Gamma.\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>It can be easily shown<mtpl></mtpl> that when the solution 

<math display="inline" id="Walk-on-spheres_method:7">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>


 exists, for 

<math display="inline" id="Walk-on-spheres_method:8">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>‚àà</mo>
   <mi mathvariant="normal">Œ©</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>normal-Œ©</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\Omega
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Walk-on-spheres_method:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>ùîº</mi>
     <mi>x</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>W</mi>
        <mi>œÑ</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>u</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùîº</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>h</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>W</ci>
        <ci>œÑ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(x)=\mathbb{E}_{x}[h(W_{\tau})]
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Walk-on-spheres_method:10">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 is a 

<math display="inline" id="Walk-on-spheres_method:11">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

-dimensional Wiener process, the expected value is taken conditionally on <mtpl>}</mtpl>, and <mtpl></mtpl> is the first-exit time out of 

<math display="inline" id="Walk-on-spheres_method:12">
 <semantics>
  <mi mathvariant="normal">Œ©</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Œ©</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Œ©
  </annotation>
 </semantics>
</math>


.</p>

<p>To compute a solution using this formula, we only have to simulate the first exit point of independent Brownian paths since with the <a href="law_of_large_numbers" title="wikilink">law of large numbers</a>:</p>

<p>

<math display="block" id="Walk-on-spheres_method:13">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ùîº</mi>
     <mi>x</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>W</mi>
        <mi>œÑ</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>‚àº</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>n</mi>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msubsup>
        <mi>W</mi>
        <mi>œÑ</mi>
        <mi>i</mi>
       </msubsup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùîº</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>h</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>W</ci>
        <ci>œÑ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>h</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>W</ci>
         <ci>i</ci>
        </apply>
        <ci>œÑ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}_{x}[h(W_{\tau})]\sim\frac{1}{n}\sum_{i=1}^{n}h(W^{i}_{\tau})
  </annotation>
 </semantics>
</math>

</p>

<p>The WoS method provides an efficient way of sampling the first exit point of a Brownian motion from the domain, by remarking that for any 

<math display="inline" id="Walk-on-spheres_method:14">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>d</mi>
    <mi mathvariant="normal">‚àí</mi>
    <mi mathvariant="normal"></mi>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>normal-‚àí</ci>
    <ci>normal-</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (d‚àí¬†1)
  </annotation>
 </semantics>
</math>

-sphere centred on 

<math display="inline" id="Walk-on-spheres_method:15">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, the first point of exit of 

<math display="inline" id="Walk-on-spheres_method:16">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 out of the sphere has a uniform distribution over its surface. Rather than simulating in detail the path of the process, it samples only the exit-points out of successive spheres, often making it less costly than "grid-based" algorithms.</p>

<p>The WoS algorithm consists in drawing the largest sphere 

<math display="inline" id="Walk-on-spheres_method:17">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">ùíÆ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ùíÆ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}_{0}
  </annotation>
 </semantics>
</math>


 centered on 

<math display="inline" id="Walk-on-spheres_method:18">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and contained inside the domain. The first point of exit <mtpl></mtpl> from 

<math display="inline" id="Walk-on-spheres_method:19">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">ùíÆ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ùíÆ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}_{0}
  </annotation>
 </semantics>
</math>

 is uniformly distributed on its surface. By repeating this step inductively, the WoS provides a sequence <mtpl></mtpl> of positions of the Brownian Motion.</p>

<p>According to intuition, the process will converge to the first exit point of the domain. However, this algorithm takes almost surely an infinite number of steps to end. For computational implementation, the process is usually stopped when it gets sufficiently close to the border, and returns the projection of the process on the border. This procedure is sometimes called introducing an 

<math display="inline" id="Walk-on-spheres_method:20">
 <semantics>
  <mi>Œµ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œµ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

-shell, or 

<math display="inline" id="Walk-on-spheres_method:21">
 <semantics>
  <mi>Œµ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œµ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

-layer.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="formulation-of-the-method">Formulation of the method</h2>
<figure><b>(Figure)</b>
<figcaption>Illustration of a run of the Walk-on-spheres algorithm on an arbitrary domain 

<math display="inline" id="Walk-on-spheres_method:22">
 <semantics>
  <mi mathvariant="normal">Œ©</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Œ©</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>


 with an 

<math display="inline" id="Walk-on-spheres_method:23">
 <semantics>
  <mi>Œµ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œµ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

-shell</figcaption>
</figure>

<p>Choose 

<math display="inline" id="Walk-on-spheres_method:24">
 <semantics>
  <mrow>
   <mi>Œµ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>Œµ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon>0
  </annotation>
 </semantics>
</math>

. Using the same notations as above, the Walk-on-spheres algorithm is described as follows:</p>
<ol>
<li>Initialize 

<math display="block" id="Walk-on-spheres_method:25">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{(0)}=x
  </annotation>
 </semantics>
</math>

</li>
<li>While 

<math display="inline" id="Walk-on-spheres_method:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mo>,</mo>
     <mi mathvariant="normal">Œì</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mi>Œµ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <ci>normal-Œì</ci>
     </interval>
    </apply>
    <ci>Œµ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(x^{(n)},\Gamma)>\varepsilon
  </annotation>
 </semantics>
</math>

:
<ol>
<li>Set 

<math display="inline" id="Walk-on-spheres_method:27">
 <semantics>
  <mrow>
   <msub>
    <mi>r</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mi>n</mi>
     </msup>
     <mo>,</mo>
     <mi mathvariant="normal">Œì</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <ci>normal-Œì</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{n}=d(x^{n},\Gamma)
  </annotation>
 </semantics>
</math>


.</li>
<li>Sample 

<math display="inline" id="Walk-on-spheres_method:28">
 <semantics>
  <msub>
   <mi>Œ≥</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Œ≥</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma_{n}
  </annotation>
 </semantics>
</math>

 a vector uniformly distributed over the unit sphere, independently from the preceding ones.</li>
<li>Set 

<math display="inline" id="Walk-on-spheres_method:29">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mo>:=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>r</mi>
      <mi>n</mi>
     </msub>
     <msub>
      <mi>Œ≥</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Œ≥</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{(n+1)}:=x^{(n)}+r_{n}\gamma_{n}
  </annotation>
 </semantics>
</math>

</li>
</ol></li>
<li>When 

<math display="inline" id="Walk-on-spheres_method:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mo>,</mo>
     <mi mathvariant="normal">Œì</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚â§</mo>
   <mi>Œµ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <ci>normal-Œì</ci>
     </interval>
    </apply>
    <ci>Œµ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(x^{(n)},\Gamma)\leq\varepsilon
  </annotation>
 </semantics>
</math>

:</li>
<li>

<math display="inline" id="Walk-on-spheres_method:31">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>f</mi>
   </msub>
   <mo>:=</mo>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi mathvariant="normal">Œì</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>normal-Œì</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{f}:=p_{\Gamma}(x^{(n)})
  </annotation>
 </semantics>
</math>

, the orthogonal projection of 

<math display="inline" id="Walk-on-spheres_method:32">
 <semantics>
  <msup>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{(n)}
  </annotation>
 </semantics>
</math>


 on 

<math display="inline" id="Walk-on-spheres_method:33">
 <semantics>
  <mi mathvariant="normal">Œì</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Œì</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

</li>
<li>Return 

<math display="inline" id="Walk-on-spheres_method:34">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{f}
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>The result 

<math display="inline" id="Walk-on-spheres_method:35">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{f}
  </annotation>
 </semantics>
</math>

 is an estimator of the first exit point from 

<math display="inline" id="Walk-on-spheres_method:36">
 <semantics>
  <mi mathvariant="normal">Œ©</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Œ©</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 of a Wiener process starting from 

<math display="inline" id="Walk-on-spheres_method:37">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


, in the sense that they have close probability distributions (see below for comments on the error).</p>
<h2 id="comments-and-practical-considerations">Comments and practical considerations</h2>
<h3 id="radius-of-the-spheres">Radius of the spheres</h3>

<p>In some cases the distance to the border might be difficult to compute, and it is then preferable to replace the radius of the sphere by a lower bound of this distance. One must then ensure that the radius of the spheres stays large enough so that the process reaches the border.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="bias-in-the-method-and-gffp">Bias in the method and GFFP</h3>

<p> As it is a Monte-Carlo method, the error of the estimator can be decomposed into the sum of a <a href="Bias_of_an_estimator" title="wikilink">bias</a>, and a <a href="Errors_and_residuals_in_statistics" title="wikilink">statistical error</a>. The statistical error is reduced by increasing the number of paths sampled, or by using <a href="variance_reduction" title="wikilink">variance reduction</a> methods.</p>

<p>The WoS theoretically provides exact (or unbiased) simulations of the paths of the Brownian motion. However, as it is formulated here, the 

<math display="inline" id="Walk-on-spheres_method:38">
 <semantics>
  <mi>Œµ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œµ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

-shell introduced to ensure that the algorithm terminates also adds an error, usually of order 

<math display="inline" id="Walk-on-spheres_method:39">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ùí™</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Œµ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ùí™</ci>
    <ci>Œµ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(\varepsilon)
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> This error has been studied, and can be avoided in some geometries by using <a href="Green's_function" title="wikilink">Green's Functions</a> First Passage method:<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> one can change the geometry of the "spheres" when close enough to the border, so that the probability of reaching the border in one step becomes positive. This requires the knowledge of Green's functions for the specific domains. (see also <a href="Harmonic_measure" title="wikilink">Harmonic measure</a>)</p>

<p>When it is possible to use it, the GFFP method is usually preferred, as it is both faster and more accurate than the classical WoS.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h3 id="complexity">Complexity</h3>

<p>It can be showed that the number of steps taken for the WoS process to reach the 

<math display="inline" id="Walk-on-spheres_method:40">
 <semantics>
  <mi>Œµ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œµ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

-shell is of order 

<math display="inline" id="Walk-on-spheres_method:41">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ùí™</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Œµ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ùí™</ci>
    <apply>
     <abs></abs>
     <apply>
      <log></log>
      <ci>Œµ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(|\log(\varepsilon)|)
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Therefore, one can increase the precision to a certain extent without making the number of steps grow notably.</p>

<p>As it is commonly the case for Monte-Carlo methods, this algorithm performs particularly well when the dimension is higher than 

<math display="inline" id="Walk-on-spheres_method:42">
 <semantics>
  <mn>3</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">3</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3
  </annotation>
 </semantics>
</math>


, and one only needs a small set of values. Indeed, the computational cost increases linearly with the dimension, whereas the cost of grid dependant methods increase exponentially with the dimension.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="variants-extensions">Variants, extensions</h2>

<p>This method has been largely studied, generalized and improved. For example, it is now extensively used for the computation of physical properties of materials (such as <a class="uri" href="capacitance" title="wikilink">capacitance</a>, electrostatic internal energy of molecules, etc.). Some notable extensions include:</p>
<h3 id="elliptic-equations">Elliptic equations</h3>

<p>The WoS method can be modified to solve more general problems. In particular, the method has been generalized to solve Dirichlet problems for equations of the form 

<math display="inline" id="Walk-on-spheres_method:43">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Œî</mi>
    <mi>u</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>c</mi>
     <mi>u</mi>
    </mrow>
    <mo>+</mo>
    <mi>f</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Œî</ci>
     <ci>u</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>u</ci>
     </apply>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta u=cu+f
  </annotation>
 </semantics>
</math>

 <a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> (which include the <a href="Poisson_equation" title="wikilink">Poisson</a> and linearized <a href="Poisson‚àíBoltzmann_equation" title="wikilink">Poisson‚àíBoltzmann</a> equations) or for any <a href="elliptic_equation" title="wikilink">elliptic equation</a> with constant coefficients.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>More efficient ways of solving the linearized Poisson‚àíBoltzmann equation have also been developed, relying on <a class="uri" href="Feynman‚àíKac" title="wikilink">Feynman‚àíKac</a> representations of the solutions.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h3 id="time-dependency">Time dependency</h3>

<p>Again, within a regular enough border, it possible to use the WoS method to solve the following problem :</p>

<p>

<math display="block" id="Walk-on-spheres_method:44">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mrow>
         <mrow>
          <msub>
           <mo>‚àÇ</mo>
           <mi>t</mi>
          </msub>
          <mi>u</mi>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo>,</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mstyle displaystyle="false">
          <mfrac>
           <mn>1</mn>
           <mn>2</mn>
          </mfrac>
         </mstyle>
         <msub>
          <mi mathvariant="normal">Œî</mi>
          <mi>x</mi>
         </msub>
         <mi>u</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo>,</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
     </mtd>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mtext>if</mtext>
        <mi>x</mi>
       </mrow>
       <mo>‚àà</mo>
       <mrow>
        <mi mathvariant="normal">Œ©</mi>
        <mtext>and</mtext>
        <mi>t</mi>
       </mrow>
       <mo><</mo>
       <mi>T</mi>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mi>u</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>T</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mrow>
        <mi>h</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>T</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mtd>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mtext>if</mtext>
        <mi>x</mi>
       </mrow>
       <mo>‚àà</mo>
       <mover accent="true">
        <mi mathvariant="normal">Œ©</mi>
        <mo stretchy="false">¬Ø</mo>
       </mover>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mi>u</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mrow>
        <mi>h</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mtd>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>x</mi>
        </mrow>
        <mo>‚àà</mo>
        <mi mathvariant="normal">Œì</mi>
       </mrow>
       <mo>.</mo>
      </mrow>
     </mtd>
    </mtr>
   </mtable>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">cases</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <partialdiff></partialdiff>
         <ci>t</ci>
        </apply>
        <ci>u</ci>
       </apply>
       <interval closure="open">
        <ci>x</ci>
        <ci>t</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Œî</ci>
        <ci>x</ci>
       </apply>
       <ci>u</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>t</ci>
       </interval>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <and></and>
     <apply>
      <in></in>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Œ©</ci>
       <mtext>and</mtext>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <lt></lt>
      <share href="#.cmml">
      </share>
      <ci>T</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>u</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>T</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>T</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <mtext>if</mtext>
      <ci>x</ci>
     </apply>
     <apply>
      <ci>normal-¬Ø</ci>
      <ci>normal-Œ©</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>u</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>t</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>t</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <mtext>if</mtext>
      <ci>x</ci>
     </apply>
     <ci>normal-Œì</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{cases}\partial_{t}u(x,t)+\frac{1}{2}\Delta_{x}u(x,t)=0&\mbox{if }x\in%
\Omega\mbox{and }t<T\\
u(x,T)=h(x,T)&\mbox{if }x\in\bar{\Omega}\\
u(x,t)=h(x,t)&\mbox{if }x\in\Gamma.\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>of which the solution can be represented as:<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>

<math display="block" id="Walk-on-spheres_method:45">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>ùîº</mi>
     <mrow>
      <mi>t</mi>
      <mo>,</mo>
      <mi>x</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>X</mi>
        <mrow>
         <mi>T</mi>
         <mo>‚àß</mo>
         <mi>œÑ</mi>
        </mrow>
       </msub>
       <mo>,</mo>
       <mrow>
        <mi>T</mi>
        <mo>‚àß</mo>
        <mi>œÑ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>u</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>t</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùîº</ci>
      <list>
       <ci>t</ci>
       <ci>x</ci>
      </list>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <apply>
         <and></and>
         <ci>T</ci>
         <ci>œÑ</ci>
        </apply>
       </apply>
       <apply>
        <and></and>
        <ci>T</ci>
        <ci>œÑ</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(x,t)=\mathbb{E}_{t,x}(h(X_{T\wedge\tau},T\wedge\tau))
  </annotation>
 </semantics>
</math>

,</p>

<p>where the expectation is taken conditionally on 

<math display="inline" id="Walk-on-spheres_method:46">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>t</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{t}=x
  </annotation>
 </semantics>
</math>

</p>

<p>To use the WoS through this formula, one needs to sample the exit-time from each sphere drawn, which is an independent variable 

<math display="inline" id="Walk-on-spheres_method:47">
 <semantics>
  <msub>
   <mi>œÑ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>œÑ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau_{0}
  </annotation>
 </semantics>
</math>

 with Laplace transform (for a sphere of radius 

<math display="inline" id="Walk-on-spheres_method:48">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

):<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>

<math display="block" id="Walk-on-spheres_method:49">
 <semantics>
  <mrow>
   <mi>ùîº</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>exp</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>-</mo>
     <mi>s</mi>
     <msub>
      <mi>œÑ</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>R</mi>
     <msqrt>
      <mrow>
       <mn>2</mn>
       <mi>s</mi>
      </mrow>
     </msqrt>
    </mrow>
    <mrow>
     <mi>sinh</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>R</mi>
       <msqrt>
        <mrow>
         <mn>2</mn>
         <mi>s</mi>
        </mrow>
       </msqrt>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exp></exp>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <minus></minus>
      <csymbol cd="unknown">s</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>œÑ</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>R</ci>
      <apply>
       <root></root>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>s</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <sinh></sinh>
      <apply>
       <times></times>
       <ci>R</ci>
       <apply>
        <root></root>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}(\exp(-s\tau_{0})))=\frac{R\sqrt{2s}}{\sinh(R\sqrt{2s})}
  </annotation>
 </semantics>
</math>

</p>

<p>The total time of exit from the domain 

<math display="inline" id="Walk-on-spheres_method:50">
 <semantics>
  <mi>œÑ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>œÑ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 can be computed as the sum of the exit-times from the spheres. The process also has to be stopped when it has not exited the domain at time 

<math display="inline" id="Walk-on-spheres_method:51">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="other-extensions">Other extensions</h3>

<p>The WoS method has been generalized to estimate the solution to elliptic partial differential equations everywhere in a domain, rather than at a single point. <a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>The WoS method has also been generalized in order to compute hitting times for processes other than Brownian motions. For example, hitting times of <a href="Bessel_processes" title="wikilink">Bessel processes</a> can be computed via an algorithm called "Walk on moving spheres".<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> This problem has applications in mathematical finance.</p>

<p>Finally, WoS can be adapted to solve the Poisson and Poisson‚àíBoltzmann equation with flux conditions on the boundary.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Feynman‚ÄìKac_formula" title="wikilink">Feynman‚ÄìKac formula</a></li>
<li><a href="Stochastic_processes_and_boundary_value_problems" title="wikilink">Stochastic processes and boundary value problems</a></li>
<li><a href="Euler‚ÄìMaruyama_method" title="wikilink">Euler‚ÄìMaruyama method</a> to sample the paths of general diffusion processes</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cs.fsu.edu/~mascagni/Muller_1956_Annals_Mathematical_Statistics.pdf">Some continuous Monte-Carlo methods for the Dirichlet problem</a> The paper in which Marvin Edgar Muller introduced the method.</li>
<li><a href="http://people.bath.ac.uk/maspm/book.pdf">Brownian Motion</a> by Peter M√∂rters and Yuval Peres. See Chapter 3.3 on harmonic measure, Green's functions and exit-points.</li>
</ul>

<p>"</p>

<p><a href="Category:Variants_of_random_walks" title="wikilink">Category:Variants of random walks</a> <a href="Category:Numerical_differential_equations" title="wikilink">Category:Numerical differential equations</a> <a href="Category:Articles_created_via_the_Article_Wizard" title="wikilink">Category:Articles created via the Article Wizard</a> <a href="Category:Boundary_conditions" title="wikilink">Category:Boundary conditions</a> <a href="Category:Partial_differential_equations" title="wikilink">Category:Partial differential equations</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">‚Ü©</a></li>
<li id="fn2"><a href="#fnref2">‚Ü©</a></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"><a href="#fnref6">‚Ü©</a></li>
<li id="fn7"><a href="#fnref7">‚Ü©</a></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"><a href="#fnref11">‚Ü©</a></li>
<li id="fn12"><a href="#fnref12">‚Ü©</a></li>
<li id="fn13"><a href="#fnref13">‚Ü©</a></li>
<li id="fn14"><a href="#fnref14">‚Ü©</a></li>
<li id="fn15"><a href="#fnref15">‚Ü©</a></li>
<li id="fn16"><a href="#fnref16">‚Ü©</a></li>
<li id="fn17"><a href="#fnref17">‚Ü©</a></li>
<li id="fn18"><a href="#fnref18">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
