   Quantum convolutional code      Quantum convolutional code   Quantum block codes are useful in quantum computing and in quantum communications . The encoding circuit for a large block code typically has a high complexity although those for modern codes do have lower complexity.  Quantum convolutional coding theory offers a different paradigm for coding quantum information. The convolutional structure is useful for a quantum communication scenario where a sender possesses a stream of qubits to send to a receiver. The encoding circuit for a quantum convolutional code has a much lower complexity than an encoding circuit needed for a large block code. It also has a repetitive pattern so that the same physical devices or the same routines can manipulate the stream of quantum information.  Quantum convolutional stabilizer codes borrow heavily from the structure of their classical counterparts . Quantum convolutional codes are similar because some of the qubits feed back into a repeated encoding unitary and give the code a memory structure like that of a classical convolutional code. The quantum codes feature online encoding and decoding of qubits. This feature gives quantum convolutional codes both their low encoding and decoding complexity and their ability to correct a larger set of errors than a block code with similar parameters.  Definition  A quantum convolutional stabilizer code acts on a Hilbert space     ℋ  ,    ℋ   \mathcal{H},   which is a countably infinite  tensor product of two-dimensional qubit  Hilbert spaces indexed over integers ≥ 0     {   ℋ  i   }    i  ∈   ℤ  +       subscript    subscript  ℋ  i      i   superscript  ℤ       \left\{\mathcal{H}_{i}\right\}_{i\in\mathbb{Z}^{+}}   :       ℋ  =     ⊗   i  =  0   ∞     ℋ  i     .      ℋ    superscript   subscript  tensor-product    i  0       subscript  ℋ  i      \mathcal{H}={\displaystyle\bigotimes\limits_{i=0}^{\infty}}\ \mathcal{H}_{i}.   A sequence   𝐀   𝐀   \mathbf{A}   of Pauli matrices      {   A  i   }    i  ∈   ℤ  +       subscript    subscript  A  i      i   superscript  ℤ       \left\{A_{i}\right\}_{i\in\mathbb{Z}^{+}}   , where       𝐀  =     ⊗   i  =  0   ∞     A  i     ,      𝐀    superscript   subscript  tensor-product    i  0       subscript  A  i      \mathbf{A}={\displaystyle\bigotimes\limits_{i=0}^{\infty}}\ A_{i},   can act on states in   ℋ   ℋ   \mathcal{H}   . Let    Π   ℤ  +      superscript  normal-Π   superscript  ℤ      \Pi^{\mathbb{Z}^{+}}   denote the set of all Pauli sequences. The support supp    (  𝐀  )    𝐀   \left(\mathbf{A}\right)   of a Pauli sequence   𝐀   𝐀   \mathbf{A}   is the set of indices of the entries in   𝐀   𝐀   \mathbf{A}   that are not equal to the identity. The weight of a sequence   𝐀   𝐀   \mathbf{A}   is the size    |   supp   (  𝐀  )    |        supp  𝐀     \left|\text{supp}\left(\mathbf{A}\right)\right|   of its support. The delay del    (  𝐀  )    𝐀   \left(\mathbf{A}\right)   of a sequence   𝐀   𝐀   \mathbf{A}   is the smallest index for an entry not equal to the identity. The degree deg    (  𝐀  )    𝐀   \left(\mathbf{A}\right)   of a sequence   𝐀   𝐀   \mathbf{A}   is the largest index for an entry not equal to the identity. E.g., the following Pauli sequence         I    X    I    Y    Z    I    I    ⋯     ,      I  X  I  Y  Z  I  I  normal-⋯     \begin{array}[c]{cccccccc}I&X&I&Y&Z&I&I&\cdots\end{array},   has support    {  1  ,  3  ,  4  }     1  3  4    \left\{1,3,4\right\}   , weight three, delay one, and degree four. A sequence has finite support if its weight is finite. Let    F   (   Π   ℤ  +    )       F   superscript  normal-Π   superscript  ℤ       F(\Pi^{\mathbb{Z}^{+}})   denote the set of Pauli sequences with finite support. The following definition for a quantum convolutional code utilizes the set    F   (   Π   ℤ  +    )       F   superscript  normal-Π   superscript  ℤ       F(\Pi^{\mathbb{Z}^{+}})   in its description.  A rate    k  /  n      k  n    k/n   -convolutional stabilizer code with    0  ≤  k  ≤  n        0  k       n     0\leq k\leq n   is a commuting set   𝒢   𝒢   \mathcal{G}   of all   n   n   n   -qubit shifts of a basic generator set    𝒢  0     subscript  𝒢  0    \mathcal{G}_{0}   . The basic generator set    𝒢  0     subscript  𝒢  0    \mathcal{G}_{0}   has    n  -  k      n  k    n-k   Pauli sequences of finite support:        𝒢  0   =   {    𝐆  i   ∈   F   (   Π   ℤ  +    )     :   1  ≤  i  ≤   n  -  k    }    .       subscript  𝒢  0    conditional-set     subscript  𝐆  i     F   superscript  normal-Π   superscript  ℤ           1  i         n  k        \mathcal{G}_{0}=\left\{\mathbf{G}_{i}\in F(\Pi^{\mathbb{Z}^{+}}):1\leq i\leq n%
 -k\right\}.   The constraint length   ν   ν   \nu   of the code is the maximum degree of the generators in    𝒢  0     subscript  𝒢  0    \mathcal{G}_{0}   . A frame of the code consists of   n   n   n   qubits.  A quantum convolutional code admits an equivalent definition in terms of the delay transform or   D   D   D   -transform. The   D   D   D   -transform captures shifts of the basic generator set    𝒢  0     subscript  𝒢  0    \mathcal{G}_{0}   . Let us define the   n   n   n   -qubit delay operator   D   D   D   acting on any Pauli sequence    𝐀  ∈   Π   ℤ  +        𝐀   superscript  normal-Π   superscript  ℤ       \mathbf{A}\in\Pi^{\mathbb{Z}^{+}}   as follows:        D   (  𝐀  )    =    I    ⊗  n    ⊗  𝐀    .        D  𝐀    tensor-product   superscript  I   tensor-product  absent  n    𝐀     D\left(\mathbf{A}\right)=I^{\otimes n}\otimes\mathbf{A.}   We can write   j   j   j   repeated applications of   D   D   D   as a power of   D   D   D   :         D  j    (  𝐀  )    =    I    ⊗   j  n     ⊗  𝐀    .         superscript  D  j   𝐀    tensor-product   superscript  I   tensor-product  absent    j  n     𝐀     D^{j}\left(\mathbf{A}\right)=I^{\otimes jn}\otimes\mathbf{A.}   Let     D  j    (   𝒢  0   )        superscript  D  j    subscript  𝒢  0     D^{j}\left(\mathcal{G}_{0}\right)   be the set of shifts of elements of    𝒢  0     subscript  𝒢  0    \mathcal{G}_{0}   by   j   j   j   . Then the full stabilizer   𝒢   𝒢   \mathcal{G}   for the convolutional stabilizer code is       𝒢  =     ⋃   j  ∈   ℤ  +        D  j    (   𝒢  0   )      .      𝒢    subscript     j   superscript  ℤ         superscript  D  j    subscript  𝒢  0       \mathcal{G}={\textstyle\bigcup\limits_{j\in\mathbb{Z}^{+}}}D^{j}\left(\mathcal%
 {G}_{0}\right).     Operation  The operation of a convolutional stabilizer code is as follows. The protocol begins with the sender encoding a stream of qubits with an online encoding circuit such as that given in (Grassl and Roetteler 2006). The encoding circuit is online if it acts on a few blocks of qubits at a time. The sender transmits a set of qubits as soon as the first unitary finishes processing them. The receiver measures all the generators in   𝒢   𝒢   \mathcal{G}   and corrects for errors as he receives the online encoded qubits. He finally decodes the encoded qubits with a decoding circuit. The qubits decoded from this convolutional procedure should be error free and ready for quantum computation at the receiving end.  A finite-depth circuit maps a Pauli sequence with finite weight to one with finite weight (Ollivier and Tillich 2004). It does not map a Pauli sequence with finite weight to one with infinite weight. This property is important because we do not want the decoding circuit to propagate uncorrected errors into the information qubit stream (Johannesson and Zigangirov 1999). A finite-depth decoding circuit corresponding to the stabilizer    𝒢   𝒢   \mathcal{G}   exists by the algorithm given in (Grassl and Roetteler 2006).  Example  Forney et al. provided an example of a rate-1/3 quantum convolutional code by importing a particular classical quaternary convolutional code (Forney and Guha 2005). Grassl and Roetteler determined a noncatastrophic encoding circuit for Forney et al.'s rate-1/3 quantum convolutional code (Grassl and Roetteler 2006). The basic stabilizer and its first shift are as follows:      ⋯   |      I  I  I        I  I  I        I  I  I        I  I  I      |       X  X  X        Z  Z  Z        I  I  I        I  I  I       |      X  Z  Y        Z  Y  X        X  X  X        Z  Z  Z      |       I  I  I        I  I  I        X  Z  Y        Z  Y  X       |      I  I  I        I  I  I        I  I  I        I  I  I      |   ⋯      normal-⋯        I  I  I       I  I  I       I  I  I       I  I  I          X  X  X       Z  Z  Z       I  I  I       I  I  I           X  Z  Y       Z  Y  X       X  X  X       Z  Z  Z          I  I  I       I  I  I       X  Z  Y       Z  Y  X           I  I  I       I  I  I       I  I  I       I  I  I      normal-⋯    \cdots\left|\begin{array}[c]{c}III\\
 III\\
 III\\
 III\end{array}\right|\begin{array}[c]{c}XXX\\
 ZZZ\\
 III\\
 III\end{array}\left|\begin{array}[c]{c}XZY\\
 ZYX\\
 XXX\\
 ZZZ\end{array}\right|\begin{array}[c]{c}III\\
 III\\
 XZY\\
 ZYX\end{array}\left|\begin{array}[c]{c}III\\
 III\\
 III\\
 III\end{array}\right|\cdots   The code consists of all three-qubit shifts of the above generators. The vertical bars are a visual aid to illustrate the three-qubit shifts of the basic generators. The code can correct for an arbitrary single-qubit error in every other frame.  Extensions  Wilde and Brun have integrated the theory of entanglement-assisted stabilizer codes and quantum convolutional codes in a series of articles (Wilde and Brun 2007a, 2007b, 2008, 2009) to form a theory of entanglement-assisted quantum convolutional coding. This theory supposes that a sender and receiver share noiseless bipartite entanglement that they can exploit for protecting a stream of quantum information.  (Wilde 2009), building on work of (Ollivier and Tillich 2004) and (Grassl and Roetteler 2006), also showed how to encode these codes with quantum shift register circuits, a natural extension of the theory of classical shift register circuits.  References   H. Ollivier and J.-P. Tillich, “Description of a quantum convolutional code,” Phys. Rev. Lett., vol. 91, no. 17, p. 177902, Oct 2003. Available at http://arxiv.org/abs/quant-ph/0304189  H. Ollivier and J.-P. Tillich, “Quantum convolutional codes: fundamentals.” Available at http://arxiv.org/abs/quant-ph/0401134  J. G. David Forney and S. Guha, “Simple rate-1/3 convolutional and tail-biting quantum error-correcting codes,” in IEEE International Symposium on Information Theory, 2005. Available at http://arxiv.org/abs/quant-ph/0501099  G. D. Forney, M. Grassl, and S. Guha, “Convolutional and tail-biting quantum error-correcting codes,” IEEE Trans. Inf. Theory, vol. 53, pp. 865–880, 2007. Available at http://arxiv.org/abs/quant-ph/0511016  M. Grassl and M. Roetteler, “Quantum convolutional codes: Encoders and structural properties,” in Forty-Fourth Annual Allerton Conference, 2006. Available at http://www.csl.illinois.edu/allerton/archives/allerton06/PDFs/papers/0285.pdf  M. Grassl and M. Roetteler, “Noncatastrophic encoders and encoder inverses for quantum convolutional codes,” in IEEE International Symposium on Information Theory (quant-ph/0602129), 2006. Available at http://arxiv.org/abs/quant-ph/0602129  R. Johannesson and K. S. Zigangirov, Fundamentals of Convolutional Coding. Wiley-IEEE Press, 1999.  Mark M. Wilde, Hari Krovi, and Todd A. Brun. (2007a) Convolutional Entanglement Distillation. Available at http://arxiv.org/abs/0708.3699  Mark M. Wilde and Todd A. Brun. (2007b) Entanglement-assisted quantum convolutional coding. Available at http://arxiv.org/abs/0712.2223  Mark M. Wilde and Todd A. Brun. Quantum Convolutional Coding with Shared Entanglement: General Structure. Available at http://arxiv.org/abs/0807.3803  Mark M. Wilde. Quantum Coding with Entanglement. Ph.D. Dissertation, University of Southern California, August 2008. Available at http://arxiv.org/abs/0806.4214  Mark M. Wilde and Todd A. Brun. "Extra shared entanglement reduces memory demand in quantum convolutional coding." Phys. Rev. A 79, 032313 (2009). Available at http://arxiv.org/abs/0812.4449  Mark M. Wilde. "Quantum-shift-register circuits." Physical Review A 79, 062325 (2009). Available at http://arxiv.org/abs/0903.3894   "  Category:Quantum information science   