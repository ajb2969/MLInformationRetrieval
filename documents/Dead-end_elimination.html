<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="208">Dead-end elimination</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Dead-end elimination</h1>
<hr>The '''de
<p>ad-end elimination''' algorithm <strong>(DEE)</strong> is a method for <a href="optimization_(mathematics)" title="wikilink">minimizing</a> a function over a discrete set of independent variables. The basic idea is to identify "dead ends", i.e., combinations of variables that are not necessary to define a global minimum because there is always a way of replacing such combination by a better or equivalent one. Then we can refrain from searching such combinations further. Hence, dead-end elimination is a mirror image of <a href="dynamic_programming" title="wikilink">dynamic programming</a>, in which "good" combinations are identified and explored further. Although the method itself is general, it has been developed and applied mainly to the problems of <a href="protein_structure_prediction" title="wikilink">predicting</a> and <a href="protein_design" title="wikilink">designing</a> the structures of <a href="protein" title="wikilink">proteins</a>. It closely related to the notion of dominance in optimization also known as substitutability in a <a href="Constraint_Satisfaction_Problem" title="wikilink">Constraint Satisfaction Problem</a>. The original description and proof of the dead-end elimination theorem can be found in .</p>
<h2 id="basic-requirements">Basic requirements</h2>

<p>An effective DEE implementation requires four pieces of information:</p>
<ol>
<li>A well-defined finite set of discrete independent variables</li>
<li>A precomputed numerical value (considered the "energy") associated with each element in the set of variables (and possibly with their pairs, triples, etc.)</li>
<li>A criterion or criteria for determining when an element is a "dead end", that is, when it cannot possibly be a member of the solution set</li>
<li>An <a href="objective_function" title="wikilink">objective function</a> (considered the "energy function") to be minimized</li>
</ol>

<p>Note that the criteria can easily be reversed to identify the maximum of a given function as well.</p>
<h2 id="applications-to-protein-structure-prediction">Applications to protein structure prediction</h2>

<p>Dead-end elimination has been used effectively to predict the structure of side chains on a given <a href="tertiary_structure" title="wikilink">protein backbone structure</a> by minimizing an energy function 

<math display="inline" id="Dead-end_elimination:0">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

. The <a href="dihedral_angle" title="wikilink">dihedral angle</a> search space of the side chains is restricted to a discrete set of <a href="rotamer" title="wikilink">rotamers</a> for each <a href="amino_acid" title="wikilink">amino acid</a> position in the protein (which is, obviously, of fixed length). The original DEE description included criteria for the elimination of single rotamers and of rotamer pairs, although this can be expanded.</p>

<p>In the following discussion, let 

<math display="inline" id="Dead-end_elimination:1">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 be the length of the protein and let 

<math display="inline" id="Dead-end_elimination:2">
 <semantics>
  <msub>
   <mi>r</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{k}
  </annotation>
 </semantics>
</math>

 represent the rotamer of the 

<math display="inline" id="Dead-end_elimination:3">
 <semantics>
  <msup>
   <mi mathvariant="normal">k</mi>
   <mi>th</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-k</ci>
    <ci>th</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{k^{th}}
  </annotation>
 </semantics>
</math>

 side chain. Since atoms in proteins are assumed to interact only by two-body <a href="potential" title="wikilink">potentials</a>, the energy may be written</p>

<p>

<math display="block" id="Dead-end_elimination:4">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mrow>
     <mi>T</mi>
     <mi>O</mi>
     <mi>T</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>k</mi>
     </munder>
     <mrow>
      <msub>
       <mi>E</mi>
       <mi>k</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>r</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>≠</mo>
       <mi>l</mi>
      </mrow>
     </munder>
     <mrow>
      <msub>
       <mi>E</mi>
       <mrow>
        <mi>k</mi>
        <mi>l</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>r</mi>
        <mi>k</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>r</mi>
        <mi>l</mi>
       </msub>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>O</ci>
      <ci>T</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <neq></neq>
        <ci>k</ci>
        <ci>l</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <apply>
         <times></times>
         <ci>k</ci>
         <ci>l</ci>
        </apply>
       </apply>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>l</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{TOT}=\sum_{k}E_{k}(r_{k})+\sum_{k\neq l}E_{kl}(r_{k},r_{l})\,
  </annotation>
 </semantics>
</math>

</p>

<p>Where 

<math display="inline" id="Dead-end_elimination:5">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>r</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{k}(r_{k})
  </annotation>
 </semantics>
</math>

 represents the "self-energy" of a particular rotamer 

<math display="inline" id="Dead-end_elimination:6">
 <semantics>
  <msub>
   <mi>r</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{k}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Dead-end_elimination:7">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mrow>
     <mi>k</mi>
     <mi>l</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>r</mi>
     <mi>k</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>r</mi>
     <mi>l</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <apply>
      <times></times>
      <ci>k</ci>
      <ci>l</ci>
     </apply>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>l</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{kl}(r_{k},r_{l})
  </annotation>
 </semantics>
</math>

 represents the "pair energy" of the rotamers 

<math display="inline" id="Dead-end_elimination:8">
 <semantics>
  <mrow>
   <msub>
    <mi>r</mi>
    <mi>k</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>r</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>j</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{k},r_{j}
  </annotation>
 </semantics>
</math>

.</p>

<p>Also note that 

<math display="inline" id="Dead-end_elimination:9">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mrow>
     <mi>k</mi>
     <mi>k</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>r</mi>
     <mi>k</mi>
     <mi>A</mi>
    </msubsup>
    <mo>,</mo>
    <msubsup>
     <mi>r</mi>
     <mi>k</mi>
     <mi>A</mi>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <apply>
      <times></times>
      <ci>k</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>k</ci>
      </apply>
      <ci>A</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>k</ci>
      </apply>
      <ci>A</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{kk}(r_{k}^{A},r_{k}^{A})
  </annotation>
 </semantics>
</math>

 (that is, the pair energy between a rotamer and itself) is taken to be zero, and thus does not affect the summations. This notation simplifies the description of the pairs criterion below.</p>
<h3 id="singles-elimination-criterion">Singles elimination criterion</h3>

<p>If a particular rotamer 

<math display="inline" id="Dead-end_elimination:10">
 <semantics>
  <msubsup>
   <mi>r</mi>
   <mi>k</mi>
   <mi>A</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>k</ci>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{k}^{A}
  </annotation>
 </semantics>
</math>

 of sidechain 

<math display="inline" id="Dead-end_elimination:11">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 cannot possibly give a better energy than another rotamer 

<math display="inline" id="Dead-end_elimination:12">
 <semantics>
  <msubsup>
   <mi>r</mi>
   <mi>k</mi>
   <mi>B</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>k</ci>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{k}^{B}
  </annotation>
 </semantics>
</math>

 of the same sidechain, then rotamer A can be eliminated from further consideration, which reduces the search space. Mathematically, this condition is expressed by the inequality</p>

<p>

<math display="block" id="Dead-end_elimination:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>E</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msubsup>
       <mi>r</mi>
       <mi>k</mi>
       <mi>A</mi>
      </msubsup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>l</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mrow>
      <mrow>
       <munder>
        <mi>min</mi>
        <mi>X</mi>
       </munder>
       <msub>
        <mi>E</mi>
        <mrow>
         <mi>k</mi>
         <mi>l</mi>
        </mrow>
       </msub>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msubsup>
        <mi>r</mi>
        <mi>k</mi>
        <mi>A</mi>
       </msubsup>
       <mo>,</mo>
       <msubsup>
        <mi>r</mi>
        <mi>l</mi>
        <mi>X</mi>
       </msubsup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>></mo>
   <mrow>
    <mrow>
     <msub>
      <mi>E</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msubsup>
       <mi>r</mi>
       <mi>k</mi>
       <mi>B</mi>
      </msubsup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>l</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mrow>
      <mrow>
       <munder>
        <mi>max</mi>
        <mi>X</mi>
       </munder>
       <msub>
        <mi>E</mi>
        <mrow>
         <mi>k</mi>
         <mi>l</mi>
        </mrow>
       </msub>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msubsup>
        <mi>r</mi>
        <mi>k</mi>
        <mi>B</mi>
       </msubsup>
       <mo>,</mo>
       <msubsup>
        <mi>r</mi>
        <mi>l</mi>
        <mi>X</mi>
       </msubsup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <ci>k</ci>
       </apply>
       <ci>A</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>l</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <min></min>
         <ci>X</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>E</ci>
         <apply>
          <times></times>
          <ci>k</ci>
          <ci>l</ci>
         </apply>
        </apply>
       </apply>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <ci>k</ci>
         </apply>
         <ci>A</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <ci>l</ci>
         </apply>
         <ci>X</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <ci>k</ci>
       </apply>
       <ci>B</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>l</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <max></max>
         <ci>X</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>E</ci>
         <apply>
          <times></times>
          <ci>k</ci>
          <ci>l</ci>
         </apply>
        </apply>
       </apply>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <ci>k</ci>
         </apply>
         <ci>B</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <ci>l</ci>
         </apply>
         <ci>X</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{k}(r_{k}^{A})+\sum_{l=1}^{N}\min_{X}E_{kl}(r_{k}^{A},r_{l}^{X})>E_{k}(r_{k}%
^{B})+\sum_{l=1}^{N}\max_{X}E_{kl}(r_{k}^{B},r_{l}^{X})
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Dead-end_elimination:14">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>min</mi>
     <mi>X</mi>
    </msub>
    <msub>
     <mi>E</mi>
     <mrow>
      <mi>k</mi>
      <mi>l</mi>
     </mrow>
    </msub>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>r</mi>
     <mi>k</mi>
     <mi>A</mi>
    </msubsup>
    <mo>,</mo>
    <msubsup>
     <mi>r</mi>
     <mi>l</mi>
     <mi>X</mi>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <ci>X</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <apply>
       <times></times>
       <ci>k</ci>
       <ci>l</ci>
      </apply>
     </apply>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>k</ci>
      </apply>
      <ci>A</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>l</ci>
      </apply>
      <ci>X</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min_{X}E_{kl}(r_{k}^{A},r_{l}^{X})
  </annotation>
 </semantics>
</math>

 is the minimum (best) energy possible between rotamer 

<math display="inline" id="Dead-end_elimination:15">
 <semantics>
  <msubsup>
   <mi>r</mi>
   <mi>k</mi>
   <mi>A</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>k</ci>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{k}^{A}
  </annotation>
 </semantics>
</math>

 of sidechain 

<math display="inline" id="Dead-end_elimination:16">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 and <em>any</em> rotamer X of side chain 

<math display="inline" id="Dead-end_elimination:17">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

. Similarly, 

<math display="inline" id="Dead-end_elimination:18">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>max</mi>
     <mi>X</mi>
    </msub>
    <msub>
     <mi>E</mi>
     <mrow>
      <mi>k</mi>
      <mi>l</mi>
     </mrow>
    </msub>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>r</mi>
     <mi>k</mi>
     <mi>B</mi>
    </msubsup>
    <mo>,</mo>
    <msubsup>
     <mi>r</mi>
     <mi>l</mi>
     <mi>X</mi>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <ci>X</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <apply>
       <times></times>
       <ci>k</ci>
       <ci>l</ci>
      </apply>
     </apply>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>k</ci>
      </apply>
      <ci>B</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>l</ci>
      </apply>
      <ci>X</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max_{X}E_{kl}(r_{k}^{B},r_{l}^{X})
  </annotation>
 </semantics>
</math>

 is the maximum (worst) energy possible between rotamer 

<math display="inline" id="Dead-end_elimination:19">
 <semantics>
  <msubsup>
   <mi>r</mi>
   <mi>k</mi>
   <mi>B</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>k</ci>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{k}^{B}
  </annotation>
 </semantics>
</math>

 of sidechain 

<math display="inline" id="Dead-end_elimination:20">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 and <em>any</em> rotamer X of side chain 

<math display="inline" id="Dead-end_elimination:21">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="pairs-elimination-criterion">Pairs elimination criterion</h3>

<p>The pairs criterion is more difficult to describe and to implement, but it adds significant eliminating power. For brevity, we define the shorthand variable 

<math display="inline" id="Dead-end_elimination:22">
 <semantics>
  <msubsup>
   <mi>U</mi>
   <mrow>
    <mi>k</mi>
    <mi>l</mi>
   </mrow>
   <mrow>
    <mi>A</mi>
    <mi>B</mi>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <apply>
      <times></times>
      <ci>k</ci>
      <ci>l</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{kl}^{AB}
  </annotation>
 </semantics>
</math>

 that is the <em>intrinsic</em> energy of a pair of rotamers 

<math display="inline" id="Dead-end_elimination:23">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dead-end_elimination:24">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 at positions 

<math display="inline" id="Dead-end_elimination:25">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dead-end_elimination:26">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

, respectively</p>

<p>

<math display="block" id="Dead-end_elimination:27">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <msubsup>
     <mi>U</mi>
     <mrow>
      <mi>k</mi>
      <mi>l</mi>
     </mrow>
     <mrow>
      <mi>A</mi>
      <mi>B</mi>
     </mrow>
    </msubsup>
   </mpadded>
   <mpadded width="+5pt">
    <mover>
     <mo movablelimits="false">=</mo>
     <mi>def</mi>
    </mover>
   </mpadded>
   <mrow>
    <mrow>
     <msub>
      <mi>E</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msubsup>
       <mi>r</mi>
       <mi>k</mi>
       <mi>A</mi>
      </msubsup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>E</mi>
      <mi>l</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msubsup>
       <mi>r</mi>
       <mi>l</mi>
       <mi>B</mi>
      </msubsup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>E</mi>
      <mrow>
       <mi>k</mi>
       <mi>l</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msubsup>
       <mi>r</mi>
       <mi>k</mi>
       <mi>A</mi>
      </msubsup>
      <mo>,</mo>
      <msubsup>
       <mi>r</mi>
       <mi>l</mi>
       <mi>B</mi>
      </msubsup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <ci>def</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <apply>
       <times></times>
       <ci>k</ci>
       <ci>l</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <ci>k</ci>
       </apply>
       <ci>A</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>l</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <ci>l</ci>
       </apply>
       <ci>B</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <apply>
        <times></times>
        <ci>k</ci>
        <ci>l</ci>
       </apply>
      </apply>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>k</ci>
        </apply>
        <ci>A</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>l</ci>
        </apply>
        <ci>B</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{kl}^{AB}\ \stackrel{\mathrm{def}}{=}\ E_{k}(r_{k}^{A})+E_{l}(r_{l}^{B})+E_{%
kl}(r_{k}^{A},r_{l}^{B})
  </annotation>
 </semantics>
</math>

</p>

<p>A given pair of rotamers 

<math display="inline" id="Dead-end_elimination:28">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dead-end_elimination:29">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 at positions 

<math display="inline" id="Dead-end_elimination:30">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dead-end_elimination:31">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

, respectively, cannot <em>both</em> be in the final solution (although one or the other may be) if there is another pair 

<math display="inline" id="Dead-end_elimination:32">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dead-end_elimination:33">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 that always gives a better energy. Expressed mathematically,</p>

<p>

<math display="block" id="Dead-end_elimination:34">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>U</mi>
     <mrow>
      <mi>k</mi>
      <mi>l</mi>
     </mrow>
     <mrow>
      <mi>A</mi>
      <mi>B</mi>
     </mrow>
    </msubsup>
    <mo>+</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mrow>
      <munder>
       <mi>min</mi>
       <mi>X</mi>
      </munder>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mrow>
         <msub>
          <mi>E</mi>
          <mrow>
           <mi>k</mi>
           <mi>i</mi>
          </mrow>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <msubsup>
           <mi>r</mi>
           <mi>k</mi>
           <mi>A</mi>
          </msubsup>
          <mo>,</mo>
          <msubsup>
           <mi>r</mi>
           <mi>i</mi>
           <mi>X</mi>
          </msubsup>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msub>
          <mi>E</mi>
          <mrow>
           <mi>l</mi>
           <mi>j</mi>
          </mrow>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <msubsup>
           <mi>r</mi>
           <mi>l</mi>
           <mi>B</mi>
          </msubsup>
          <mo>,</mo>
          <msubsup>
           <mi>r</mi>
           <mi>j</mi>
           <mi>X</mi>
          </msubsup>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>></mo>
   <mrow>
    <msubsup>
     <mi>U</mi>
     <mrow>
      <mi>k</mi>
      <mi>l</mi>
     </mrow>
     <mrow>
      <mi>C</mi>
      <mi>D</mi>
     </mrow>
    </msubsup>
    <mo>+</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mrow>
      <munder>
       <mi>max</mi>
       <mi>X</mi>
      </munder>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mrow>
         <msub>
          <mi>E</mi>
          <mrow>
           <mi>k</mi>
           <mi>i</mi>
          </mrow>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <msubsup>
           <mi>r</mi>
           <mi>k</mi>
           <mi>C</mi>
          </msubsup>
          <mo>,</mo>
          <msubsup>
           <mi>r</mi>
           <mi>i</mi>
           <mi>X</mi>
          </msubsup>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msub>
          <mi>E</mi>
          <mrow>
           <mi>l</mi>
           <mi>j</mi>
          </mrow>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <msubsup>
           <mi>r</mi>
           <mi>l</mi>
           <mi>D</mi>
          </msubsup>
          <mo>,</mo>
          <msubsup>
           <mi>r</mi>
           <mi>j</mi>
           <mi>X</mi>
          </msubsup>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <apply>
        <times></times>
        <ci>k</ci>
        <ci>l</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <min></min>
        <ci>X</ci>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>E</ci>
          <apply>
           <times></times>
           <ci>k</ci>
           <ci>i</ci>
          </apply>
         </apply>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>r</ci>
            <ci>k</ci>
           </apply>
           <ci>A</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>r</ci>
            <ci>i</ci>
           </apply>
           <ci>X</ci>
          </apply>
         </interval>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>E</ci>
          <apply>
           <times></times>
           <ci>l</ci>
           <ci>j</ci>
          </apply>
         </apply>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>r</ci>
            <ci>l</ci>
           </apply>
           <ci>B</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>r</ci>
            <ci>j</ci>
           </apply>
           <ci>X</ci>
          </apply>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <apply>
        <times></times>
        <ci>k</ci>
        <ci>l</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>C</ci>
       <ci>D</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <max></max>
        <ci>X</ci>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>E</ci>
          <apply>
           <times></times>
           <ci>k</ci>
           <ci>i</ci>
          </apply>
         </apply>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>r</ci>
            <ci>k</ci>
           </apply>
           <ci>C</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>r</ci>
            <ci>i</ci>
           </apply>
           <ci>X</ci>
          </apply>
         </interval>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>E</ci>
          <apply>
           <times></times>
           <ci>l</ci>
           <ci>j</ci>
          </apply>
         </apply>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>r</ci>
            <ci>l</ci>
           </apply>
           <ci>D</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>r</ci>
            <ci>j</ci>
           </apply>
           <ci>X</ci>
          </apply>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{kl}^{AB}+\sum_{i=1}^{N}\min_{X}\left(E_{ki}(r_{k}^{A},r_{i}^{X})+E_{lj}(r_{%
l}^{B},r_{j}^{X})\right)>U_{kl}^{CD}+\sum_{i=1}^{N}\max_{X}\left(E_{ki}(r_{k}^%
{C},r_{i}^{X})+E_{lj}(r_{l}^{D},r_{j}^{X})\right)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Dead-end_elimination:35">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>≠</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>A</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\neq C
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Dead-end_elimination:36">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>≠</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>B</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\neq D
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dead-end_elimination:37">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>≠</mo>
   <mi>l</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>k</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\neq l
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="energy-matrices">Energy matrices</h3>

<p>For large 

<math display="inline" id="Dead-end_elimination:38">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, the matrices of precomputed energies can become costly to store. Let 

<math display="inline" id="Dead-end_elimination:39">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 be the number of amino acid positions, as above, and let 

<math display="inline" id="Dead-end_elimination:40">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 be the number of rotamers at each position (this is usually, but not necessarily, constant over all positions). Each self-energy matrix for a given position requires 

<math display="inline" id="Dead-end_elimination:41">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 entries, so the total number of self-energies to store is 

<math display="inline" id="Dead-end_elimination:42">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Np
  </annotation>
 </semantics>
</math>

. <em>Each</em> pair energy matrix between two positions 

<math display="inline" id="Dead-end_elimination:43">
 <semantics>
  <msub>
   <mi>r</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{k}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dead-end_elimination:44">
 <semantics>
  <msub>
   <mi>r</mi>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{l}
  </annotation>
 </semantics>
</math>

, for 

<math display="inline" id="Dead-end_elimination:45">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 discrete rotamers at each position, requires a 

<math display="inline" id="Dead-end_elimination:46">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>×</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\times p
  </annotation>
 </semantics>
</math>

 matrix. This makes the total number of entries in an unreduced pair matrix 

<math display="inline" id="Dead-end_elimination:47">
 <semantics>
  <mrow>
   <msup>
    <mi>N</mi>
    <mn>2</mn>
   </msup>
   <msup>
    <mi>p</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>N</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>p</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N^{2}p^{2}
  </annotation>
 </semantics>
</math>

. This can be trimmed somewhat, at the cost of additional complexity in implementation, because pair energies are symmetrical and the pair energy between a rotamer and itself is zero.</p>
<h2 id="implementation-and-efficiency">Implementation and efficiency</h2>

<p>The above two criteria are normally applied iteratively until convergence, defined as the point at which no more rotamers or pairs can be eliminated. Since this is normally a reduction in the sample space by many orders of magnitude, simple enumeration will suffice to determine the minimum within this pared-down set.</p>

<p>Given this model, it is clear that the DEE algorithm is guaranteed to find the optimal solution; that is, it is a <a href="global_optimization" title="wikilink">global optimization</a> process. The single-rotamer search scales <a href="quadratic_growth" title="wikilink">quadratically</a> in time with <em>total</em> number of rotamers. The pair search scales cubically and is the slowest part of the algorithm (aside from energy calculations). This is a dramatic improvement over the brute-force enumeration which scales as 

<math display="inline" id="Dead-end_elimination:48">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>p</mi>
     <mi>N</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>p</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(p^{N})
  </annotation>
 </semantics>
</math>

.</p>

<p>A large-scale <a href="benchmark_(computing)" title="wikilink">benchmark</a> of DEE compared with alternative methods of <a href="protein_structure_prediction" title="wikilink">protein structure prediction</a> and design finds that DEE reliably converges to the optimal solution for protein lengths for which it runs in a reasonable amount of time. It significantly outperforms the alternatives under consideration, which involved techniques derived from <a href="mean_field_theory" title="wikilink">mean field theory</a>, <a href="genetic_algorithm" title="wikilink">genetic algorithms</a>, and the <a href="Monte_Carlo_method" title="wikilink">Monte Carlo method</a>. However, the other algorithms are appreciably faster than DEE and thus can be applied to larger and more complex problems; their relative accuracy can be extrapolated from a comparison to the DEE solution within the scope of problems accessible to DEE.</p>
<h2 id="protein-design">Protein design</h2>

<p>The preceding discussion implicitly assumed that the rotamers 

<math display="inline" id="Dead-end_elimination:49">
 <semantics>
  <msub>
   <mi>r</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{k}
  </annotation>
 </semantics>
</math>

 are all different orientations of the same amino acid side chain. That is, the sequence of the protein was assumed to be fixed. It is also possible to allow multiple side chains to "compete" over a position 

<math display="inline" id="Dead-end_elimination:50">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 by including both types of side chains in the set of rotamers for that position. This allows a novel sequence to be designed onto a given protein backbone. A short <a href="zinc_finger" title="wikilink">zinc finger</a> protein fold has been redesigned this way. However, this greatly increases the number of rotamers per position and still requires a fixed protein length.</p>
<h2 id="generalizations">Generalizations</h2>

<p>More powerful and more general criteria have been introduced that improve both the efficiency and the eliminating power of the method for both prediction and design applications. One example is a refinement of the singles elimination criterion known as the Goldstein criterion, which arises from fairly straightforward algebraic manipulation before applying the minimization:</p>

<p>

<math display="block" id="Dead-end_elimination:51">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>E</mi>
       <mi>k</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msubsup>
        <mi>r</mi>
        <mi>k</mi>
        <mi>A</mi>
       </msubsup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>E</mi>
       <mi>k</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msubsup>
        <mi>r</mi>
        <mi>k</mi>
        <mi>B</mi>
       </msubsup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>l</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mrow>
      <munder>
       <mi>min</mi>
       <mi>X</mi>
      </munder>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mrow>
         <msub>
          <mi>E</mi>
          <mrow>
           <mi>k</mi>
           <mi>l</mi>
          </mrow>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <msubsup>
           <mi>r</mi>
           <mi>k</mi>
           <mi>A</mi>
          </msubsup>
          <mo>,</mo>
          <msubsup>
           <mi>r</mi>
           <mi>l</mi>
           <mi>X</mi>
          </msubsup>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <msub>
          <mi>E</mi>
          <mrow>
           <mi>k</mi>
           <mi>l</mi>
          </mrow>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <msubsup>
           <mi>r</mi>
           <mi>k</mi>
           <mi>B</mi>
          </msubsup>
          <mo>,</mo>
          <msubsup>
           <mi>r</mi>
           <mi>l</mi>
           <mi>X</mi>
          </msubsup>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>k</ci>
        </apply>
        <ci>A</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>k</ci>
        </apply>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>l</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <min></min>
        <ci>X</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>E</ci>
          <apply>
           <times></times>
           <ci>k</ci>
           <ci>l</ci>
          </apply>
         </apply>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>r</ci>
            <ci>k</ci>
           </apply>
           <ci>A</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>r</ci>
            <ci>l</ci>
           </apply>
           <ci>X</ci>
          </apply>
         </interval>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>E</ci>
          <apply>
           <times></times>
           <ci>k</ci>
           <ci>l</ci>
          </apply>
         </apply>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>r</ci>
            <ci>k</ci>
           </apply>
           <ci>B</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>r</ci>
            <ci>l</ci>
           </apply>
           <ci>X</ci>
          </apply>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{k}(r_{k}^{A})-E_{k}(r_{k}^{B})+\sum_{l=1}^{N}\min_{X}\left(E_{kl}(r_{k}^{A}%
,r_{l}^{X})-E_{kl}(r_{k}^{B},r_{l}^{X})\right)>0
  </annotation>
 </semantics>
</math>

</p>

<p>Thus rotamer 

<math display="inline" id="Dead-end_elimination:52">
 <semantics>
  <msubsup>
   <mi>r</mi>
   <mi>k</mi>
   <mi>A</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>k</ci>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{k}^{A}
  </annotation>
 </semantics>
</math>

 can be eliminated if any alternative rotamer from the set at 

<math display="inline" id="Dead-end_elimination:53">
 <semantics>
  <msub>
   <mi>r</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{k}
  </annotation>
 </semantics>
</math>

 contributes less to the total energy than 

<math display="inline" id="Dead-end_elimination:54">
 <semantics>
  <msubsup>
   <mi>r</mi>
   <mi>k</mi>
   <mi>A</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>k</ci>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{k}^{A}
  </annotation>
 </semantics>
</math>

. This is an improvement over the original criterion, which requires comparison of the best possible (that is, the smallest) energy contribution from 

<math display="inline" id="Dead-end_elimination:55">
 <semantics>
  <msubsup>
   <mi>r</mi>
   <mi>k</mi>
   <mi>A</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>k</ci>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{k}^{A}
  </annotation>
 </semantics>
</math>

 with the <em>worst</em> possible contribution from an alternative rotamer.</p>

<p>An extended discussion of elaborate DEE criteria and a benchmark of their relative performance can be found in .</p>
<h2 id="references">References</h2>
<ol>
<li>

<p>Desmet J, de Maeyer M, Hazes B, Lasters I. (1992). The dead-end elimination theorem and its use in protein side-chain positioning. <em>Nature</em>, <strong>356</strong>, 539-542. PMID 21488406.</p></li>
<li>

<p>Voigt CA, Gordon DB, Mayo SL. (2000). Trading accuracy for speed: A quantitative comparison of search algorithms in protein sequence design. <em>J Mol Biol</em> 299(3):789-803.</p></li>
<li>

<p>Dahiyat BI, Mayo SL. (1997). De novo protein design: fully automated sequence selection. <em>Science</em> 278(5335):82-7.</p></li>
<li>

<p>Goldstein RF. (1994). Efficient rotamer elimination applied to protein side-chains and related spin glasses. <em>Biophys J</em> 66(5):1335-40.</p></li>
<li>

<p>Pierce NA, Spriet JA, Desmet J, Mayo SL. (2000). Conformational splitting: a more powerful criterion for dead-end elimination. <em>J Comput Chem</em> 21: 999-1009.</p></li>
</ol>

<p>"</p>

<p><a href="Category:Mathematical_optimization" title="wikilink">Category:Mathematical optimization</a> <a href="Category:Protein_methods" title="wikilink">Category:Protein methods</a></p>
</hr></body>
</html>
