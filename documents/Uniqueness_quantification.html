<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1635">Uniqueness quantification</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Uniqueness quantification</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a> and <a class="uri" href="logic" title="wikilink">logic</a>, the phrase "there is <strong>one and only one</strong>" is used to indicate that exactly one object with a certain property exists. In <a href="mathematical_logic" title="wikilink">mathematical logic</a>, this sort of <a href="Quantification_(logic)" title="wikilink">quantification</a> is known as <strong>uniqueness quantification</strong> or <strong>unique existential quantification</strong>.</p>

<p>Uniqueness quantification is often denoted with the symbols "∃!" or ∃<sub>=1</sub>". For example, the formal statement</p>

<p>
<math display="block" id="Uniqueness_quantification:0">
<semantics>
<mrow>
<mo>∃</mo>
<mo lspace="0pt" rspace="3.5pt">!</mo>
<mi>n</mi>
<mo>∈</mo>
<mpadded width="+1.7pt">
<mi>ℕ</mi>
</mpadded>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>-</mo>
<mn>2</mn>
<mo>=</mo>
<mn>4</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<exists></exists>
<factorial></factorial>
<csymbol cd="unknown">n</csymbol>
<in></in>
<csymbol cd="unknown">N</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">n</csymbol>
<minus></minus>
<cn type="integer">2</cn>
<eq></eq>
<cn type="integer">4</cn>
<ci>normal-)</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \exists!n\in\mathbb{N}\,(n-2=4)
  </annotation>
</semantics>
</math>

 may be read aloud as "there is exactly one natural number <em>n</em> such that <em>n</em> - 2 = 4".</p>
<h2 id="proving-uniqueness">Proving uniqueness</h2>

<p>The most common technique to proving uniqueness is to first prove existence of entity with the desired condition; then, to assume there exist two entities (say, a and b) that should both satisfy the condition, and logically deduce their equality, i.e. <em>a</em> = <em>b</em>.</p>

<p>As a simple high school example, to show <em>x</em> + 2 = 5 has only one solution, we assume there are two solutions first, namely, <em>a</em> and <em>b</em>, satisfying <em>x</em> + 2 = 5. Thus</p>

<p>
<math display="block" id="Uniqueness_quantification:1">
<semantics>
<mrow>
<mrow>
<mi>a</mi>
<mo>+</mo>
<mn>2</mn>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mn>5</mn>
<mtext>and</mtext>
<mi>b</mi>
</mrow>
<mo>+</mo>
<mn>2</mn>
</mrow>
<mo>=</mo>
<mpadded width="+1.7pt">
<mn>5.</mn>
</mpadded>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<plus></plus>
<ci>a</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<plus></plus>
<apply>
<times></times>
<cn type="integer">5</cn>
<mtext>and</mtext>
<ci>b</ci>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<cn type="float">5.</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   a+2=5\text{ and }b+2=5.\,
  </annotation>
</semantics>
</math>
</p>

<p>By transitivity of equality,</p>

<p>
<math display="block" id="Uniqueness_quantification:2">
<semantics>
<mrow>
<mrow>
<mi>a</mi>
<mo>+</mo>
<mn>2</mn>
</mrow>
<mo>=</mo>
<mrow>
<mi>b</mi>
<mo>+</mo>
<mpadded width="+1.7pt">
<mn>2.</mn>
</mpadded>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<plus></plus>
<ci>a</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<plus></plus>
<ci>b</ci>
<cn type="float">2.</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   a+2=b+2.\,
  </annotation>
</semantics>
</math>
</p>

<p>By cancellation,</p>

<p>
<math display="block" id="Uniqueness_quantification:3">
<semantics>
<mrow>
<mrow>
<mi>a</mi>
<mo>=</mo>
<mi>b</mi>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>a</ci>
<ci>b</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   a=b.\,
  </annotation>
</semantics>
</math>
</p>

<p>This simple example shows how a proof of uniqueness is done, the end result being the equality of the two quantities that satisfy the condition. However, that existence/expressibility must be proven before uniqueness, or else we cannot even assume the existence of those two quantities to begin with our current knowledge to date.</p>
<h2 id="reduction-to-ordinary-existential-and-universal-quantification">Reduction to ordinary existential and universal quantification</h2>

<p>Uniqueness quantification can be expressed in terms of the <a href="existential_quantifier" title="wikilink">existential</a> and <a href="universal_quantifier" title="wikilink">universal</a> quantifiers of <a href="predicate_logic" title="wikilink">predicate logic</a> by defining the formula ∃!<em>x</em> <em>P(x)</em> to mean literally,</p>

<p>
<math display="block" id="Uniqueness_quantification:4">
<semantics>
<mrow>
<mo>∃</mo>
<mpadded width="+1.7pt">
<mi>x</mi>
</mpadded>
<mrow>
<mo stretchy="false">(</mo>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
<mo>∧</mo>
<mi mathvariant="normal">¬</mi>
<mo>∃</mo>
<mpadded width="+1.7pt">
<mi>y</mi>
</mpadded>
<mrow>
<mo stretchy="false">(</mo>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>∧</mo>
<mi>y</mi>
<mo>≠</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<exists></exists>
<csymbol cd="unknown">x</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">P</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">x</csymbol>
<ci>normal-)</ci>
</cerror>
<and></and>
<not></not>
<exists></exists>
<csymbol cd="unknown">y</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">P</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">y</csymbol>
<ci>normal-)</ci>
</cerror>
<and></and>
<csymbol cd="unknown">y</csymbol>
<neq></neq>
<csymbol cd="unknown">x</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-)</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \exists x\,(P(x)\,\wedge\neg\exists y\,(P(y)\wedge y\neq x))
  </annotation>
</semantics>
</math>

 which is the same as</p>

<p>
<math display="block" id="Uniqueness_quantification:5">
<semantics>
<mrow>
<mo>∃</mo>
<mpadded width="+1.7pt">
<mi>x</mi>
</mpadded>
<mrow>
<mo stretchy="false">(</mo>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>∧</mo>
<mo>∀</mo>
<mpadded width="+1.7pt">
<mi>y</mi>
</mpadded>
<mrow>
<mo stretchy="false">(</mo>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>→</mo>
<mi>y</mi>
<mo>=</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<exists></exists>
<csymbol cd="unknown">x</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">P</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">x</csymbol>
<ci>normal-)</ci>
</cerror>
<and></and>
<csymbol cd="latexml">for-all</csymbol>
<csymbol cd="unknown">y</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">P</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">y</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-→</ci>
<csymbol cd="unknown">y</csymbol>
<eq></eq>
<csymbol cd="unknown">x</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-)</ci>
</cerror>
<ci>normal-.</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \exists x\,(P(x)\wedge\forall y\,(P(y)\to y=x)).
  </annotation>
</semantics>
</math>

 An equivalent definition that has the virtue of separating the notions of existence and uniqueness into two clauses, at the expense of brevity, is</p>

<p>
<math display="block" id="Uniqueness_quantification:6">
<semantics>
<mrow>
<mo>∃</mo>
<mpadded width="+1.7pt">
<mi>x</mi>
</mpadded>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>∧</mo>
<mo>∀</mo>
<mpadded width="+1.7pt">
<mi>y</mi>
</mpadded>
<mo>∀</mo>
<mpadded width="+1.7pt">
<mi>z</mi>
</mpadded>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>∧</mo>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>→</mo>
<mi>y</mi>
<mo>=</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<exists></exists>
<csymbol cd="unknown">x</csymbol>
<csymbol cd="unknown">P</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">x</csymbol>
<ci>normal-)</ci>
</cerror>
<and></and>
<csymbol cd="latexml">for-all</csymbol>
<csymbol cd="unknown">y</csymbol>
<csymbol cd="latexml">for-all</csymbol>
<csymbol cd="unknown">z</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">P</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">y</csymbol>
<ci>normal-)</ci>
</cerror>
<and></and>
<csymbol cd="unknown">P</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">z</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-)</ci>
</cerror>
<ci>normal-→</ci>
<csymbol cd="unknown">y</csymbol>
<eq></eq>
<csymbol cd="unknown">z</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-.</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \exists x\,P(x)\wedge\forall y\,\forall z\,((P(y)\wedge P(z))\to y=z).
  </annotation>
</semantics>
</math>

 Another equivalent definition with the advantage of brevity is</p>

<p>
<math display="block" id="Uniqueness_quantification:7">
<semantics>
<mrow>
<mo>∃</mo>
<mpadded width="+1.7pt">
<mi>x</mi>
</mpadded>
<mo>∀</mo>
<mpadded width="+1.7pt">
<mi>y</mi>
</mpadded>
<mrow>
<mo stretchy="false">(</mo>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>↔</mo>
<mi>y</mi>
<mo>=</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<exists></exists>
<csymbol cd="unknown">x</csymbol>
<csymbol cd="latexml">for-all</csymbol>
<csymbol cd="unknown">y</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">P</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">y</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-↔</ci>
<csymbol cd="unknown">y</csymbol>
<eq></eq>
<csymbol cd="unknown">x</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-.</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \exists x\,\forall y\,(P(y)\leftrightarrow y=x).
  </annotation>
</semantics>
</math>
</p>
<h2 id="generalizations">Generalizations</h2>

<p>One generalization of uniqueness quantification is <a href="counting_quantification" title="wikilink">counting quantification</a>. This includes both quantification of the form "exactly <em>k</em> objects exist such that …" as well as "infinitely many objects exist such that …" and "only finitely many objects exist such that…". The first of these forms is expressible using ordinary quantifiers, but the latter two cannot be expressed in ordinary <a href="first-order_logic" title="wikilink">first-order logic</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="One-hot" title="wikilink">One-hot</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Quantification" title="wikilink">Category:Quantification</a> <a href="Category:1_(number)" title="wikilink">Category:1 (number)</a> <a href="Category:Mathematical_terminology" title="wikilink">Category:Mathematical terminology</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">This is a consequence of the <a href="compactness_theorem" title="wikilink">compactness theorem</a>.<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
