<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1146">Pulse-density modulation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Pulse-density modulation</h1>
&lt;
<p>hr&gt;<strong>Pulse-density modulation</strong>, or <strong>PDM</strong>, is a form of <a class="uri" href="modulation" title="wikilink">modulation</a> used to represent an <a href="analog_signal" title="wikilink">analog signal</a> with <a href="digital_data" title="wikilink">digital data</a>. In a PDM signal, specific <a class="uri" href="amplitude" title="wikilink">amplitude</a> values are not encoded into codewords of pulses of different weight as they would be in <a href="pulse-code_modulation" title="wikilink">pulse-code modulation</a> (PCM). Instead, it is the relative <a class="uri" href="density" title="wikilink">density</a> of the pulses that corresponds to the analog signal's amplitude. The output of a <a href="1-bit_DAC" title="wikilink">1-bit DAC</a> is the same as the PDM encoding of the signal. <a href="Pulse-width_modulation" title="wikilink">Pulse-width modulation</a> (PWM) is a special case of PDM where the switching frequency is fixed and all the pulses corresponding to one sample are contiguous in the digital signal. For a 50% voltage with a resolution of 8-bits, a PWM waveform will turn on for 128 clock cycles and then off for the remaining 128 cycles. With PDM and the same clock rate the signal would alternate between on and off every other cycle. The average is 50% for both waveforms, but the PDM signal switches more often. For 100% or 0% level, they are the same.</p>
<h2 id="description">Description</h2>

<p>In a pulse-density modulation <a class="uri" href="bitstream" title="wikilink">bitstream</a> a <strong>1</strong> corresponds to a pulse of positive polarity (+<em>A</em>) and a <strong>0</strong> corresponds to a pulse of negative polarity (-<em>A</em>). Mathematically, this can be represented as:</p>

<p>

<math display="block" id="Pulse-density_modulation:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>A</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mi>a</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>n</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <times></times>
        <ci>a</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[n]=-A(-1)^{a[n]}
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd>where <em>x</em>[<em>n</em>] is the bipolar bitstream (either -<em>A</em> or +<em>A</em>) and <em>a</em>[<em>n</em>] is the corresponding binary bitstream (either 0 or 1).
</dd>
</dl>

<p>A run consisting of all 1s would correspond to the maximum (positive) amplitude value, all 0s would correspond to the minimum (negative) amplitude value, and alternating 1s and 0s would correspond to a zero amplitude value. The continuous amplitude waveform is recovered by <a href="low-pass_filter" title="wikilink">low-pass filtering</a> the bipolar PDM bitstream.</p>
<h2 id="examples">Examples</h2>

<p>A single <a href="periodic_function" title="wikilink">period</a> of the <a href="trigonometric_function" title="wikilink">trigonometric sine function</a>, <a href="sample_(signal)" title="wikilink">sampled</a> 100 times and represented as a PDM bitstream, is:</p>

<p>0101011011110111111111111111111111011111101101101010100100100000010000000000000000000001000010010101 </p>

<p>Two periods of a higher frequency sine wave would appear as:</p>

<p>0101101111111111111101101010010000000000000100010011011101111111111111011010100100000000000000100101 </p>

<p>In pulse-<em>density</em> modulation, a high <em>density</em> of 1s occurs at the peaks of the sine wave, while a low <em>density</em> of 1s occurs at the troughs of the sine wave.</p>
<h2 id="analog-to-digital-conversion">Analog-to-digital conversion</h2>

<p>A PDM bitstream is <a href="Code" title="wikilink">encoded</a> from an analog signal through the process of <a href="delta-sigma_modulation" title="wikilink">delta-sigma modulation</a>. This process uses a one bit <a href="Quantization_(signal_processing)" title="wikilink">quantizer</a> that produces either a 1 or 0 depending on the amplitude of the analog signal. A 1 or 0 corresponds to a signal that is all the way up or all the way down, respectively. Because in the real world, analog signals are rarely all the way in one direction, there is a quantization error, the difference between the 1 or 0 and the actual amplitude it represents. This error is fed back negatively in the ΔΣ process loop. In this way, every error successively influences every other quantization measurement and its error. This has the effect of <a href="average" title="wikilink">averaging</a> out the quantization error.</p>
<h2 id="digital-to-analog-conversion">Digital-to-analog conversion</h2>

<p>The process of <a href="Digital-to-analog_converter" title="wikilink">decoding</a> a PDM signal into an analog one is simple: one only has to pass the PDM signal through a <a href="low-pass_filter" title="wikilink">low-pass filter</a>. This works because the function of a low-pass filter is essentially to average the signal. The average amplitude of pulses is measured by the density of those pulses over time, thus a low pass filter is the only step required in the decoding process.</p>
<h2 id="relationship-to-biology">Relationship to biology</h2>

<p>Notably, one of the ways animal nervous systems represent sensory and other information is through <a href="rate_coding" title="wikilink">rate coding</a> whereby the magnitude of the signal is related to the rate of firing of the sensory neuron. In direct analogy, each neural event – called an action potential – represents one bit (pulse), with the rate of firing of the neuron representing the pulse density.</p>
<h2 id="algorithm">Algorithm</h2>

<p> A digital model of pulse-density modulation can be obtained from a digital model of the <a href="delta-sigma_modulator" title="wikilink">delta-sigma modulator</a>. Consider a signal 

<math display="inline" id="Pulse-density_modulation:1">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[n]
  </annotation>
 </semantics>
</math>

 in the <a href="discrete_time" title="wikilink">discrete time</a> domain as the input to a first-order delta-sigma modulator, with 

<math display="inline" id="Pulse-density_modulation:2">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y[n]
  </annotation>
 </semantics>
</math>

 the output. In the <a href="discrete_frequency" title="wikilink">discrete frequency</a> domain, the delta-sigma modulator's operation is represented by</p>

<p>

<math display="block" id="Pulse-density_modulation:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>Y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>X</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <msup>
        <mi>z</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Y</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>z</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y(z)=X(z)+E(z)\left(1-z^{-1}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>Rearranging terms, we obtain</p>

<p>

<math display="block" id="Pulse-density_modulation:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mo>[</mo>
       <mrow>
        <mrow>
         <mi>X</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>Y</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <msup>
          <mi>z</mi>
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msup>
        </mrow>
       </mrow>
       <mo>]</mo>
      </mrow>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mn>1</mn>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <msup>
          <mi>z</mi>
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msup>
        </mrow>
       </mfrac>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Y</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>X</ci>
         <ci>z</ci>
        </apply>
        <apply>
         <times></times>
         <ci>Y</ci>
         <ci>z</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>z</ci>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y(z)=E(z)+\left[X(z)-Y(z)z^{-1}\right]\left(\frac{1}{1-z^{-1}}\right).
  </annotation>
 </semantics>
</math>

</p>

<p>Here, 

<math display="inline" id="Pulse-density_modulation:5">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(z)
  </annotation>
 </semantics>
</math>

 is the frequency-domain <a href="quantization_error" title="wikilink">quantization error</a> of the delta-sigma modulator. The factor 

<math display="inline" id="Pulse-density_modulation:6">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <msup>
    <mi>z</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>z</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-z^{-1}
  </annotation>
 </semantics>
</math>

 represents a <a href="high-pass_filter" title="wikilink">high-pass filter</a>, so it is clear that 

<math display="inline" id="Pulse-density_modulation:7">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(z)
  </annotation>
 </semantics>
</math>

 contributes less to the output 

<math display="inline" id="Pulse-density_modulation:8">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Y</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y(z)
  </annotation>
 </semantics>
</math>

 at low frequencies, and more at high frequencies. This demonstrates the <a href="noise_shaping" title="wikilink">noise shaping</a> effect of the delta-sigma modulator: the quantization noise is "pushed" out of the low frequencies up into the high-frequency range.</p>

<p>Using the inverse <a class="uri" href="Z-transform" title="wikilink">Z-transform</a>, we may convert this into a <a href="difference_equation" title="wikilink">difference equation</a> relating the input of the delta-sigma modulator to its output in the <a href="discrete_time" title="wikilink">discrete time</a> domain,</p>

<p>

<math display="block" id="Pulse-density_modulation:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>n</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>e</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>n</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>e</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>x</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>e</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>e</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y[n]=x[n]+e[n]-e[n-1]
  </annotation>
 </semantics>
</math>

</p>

<p>There are two additional constraints to consider: first, at each step the output sample 

<math display="inline" id="Pulse-density_modulation:10">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y[n]
  </annotation>
 </semantics>
</math>

 is chosen so as to <em>minimize</em> the "running" quantization error 

<math display="inline" id="Pulse-density_modulation:11">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>e</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e[n]
  </annotation>
 </semantics>
</math>

. Second, 

<math display="inline" id="Pulse-density_modulation:12">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y[n]
  </annotation>
 </semantics>
</math>

 is represented as a single bit, meaning it can take on only two values. We choose 

<math display="inline" id="Pulse-density_modulation:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>±</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">plus-or-minus</csymbol>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y[n]=\pm 1
  </annotation>
 </semantics>
</math>

 for convenience, allowing us to write</p>

<p>

<math display="inline" id="Pulse-density_modulation:14">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y[n]
  </annotation>
 </semantics>
</math>

</p>

<p>This, finally, gives a formula for the output sample 

<math display="inline" id="Pulse-density_modulation:15">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[n]
  </annotation>
 </semantics>
</math>

 in terms of the input sample <span class="LaTeX">$x[n]$</span>. The quantization error of each sample is <a href="negative_feedback" title="wikilink">fed back</a> into the input for the following sample.</p>

<p>The following pseudo-code implements this algorithm to convert a <a href="pulse-code_modulation" title="wikilink">pulse-code modulation</a> signal into a PDM signal:</p>

<p><em><code>//</code> <code>Encode</code> <code>samples</code> <code>into</code> <code>pulse-density</code> <code>modulation</code></em><br/>
<em><code>//</code> <code>using</code> <code>a</code> <code>first-order</code> <code>sigma-delta</code> <code>modulator</code></em><br/>
<br/>
<strong><code>function</code></strong><code> pdm(</code><em><code>real[0..s]</code></em><code> x)</code><br/>
<code>  </code><strong><code>var</code></strong><code> </code><em><code>int[0..s]</code></em><code> y</code><br/>
<code>  </code><strong><code>var</code></strong><code> </code><em><code>real[-1..s]</code></em><code> qe</code><br/>
<code>  </code><br/>
<code>  qe[-1] := 0                  </code><em><code>//</code> <code>initial</code> <code>running</code> <code>error</code> <code>is</code> <code>zero</code></em><br/>
<code>  </code><br/>
<code>  </code><strong><code>for</code></strong><code> n </code><strong><code>from</code></strong><code> 0 </code><strong><code>to</code></strong><code> s</code><br/>
<code>      </code><strong><code>if</code></strong><code> x[n] &gt;= qe[n-1]</code><br/>
<code>          y[n] := 1</code><br/>
<code>      </code><strong><code>else</code></strong><br/>
<code>          y[n] := -1</code><br/>
<code>      qe[n] := y[n] - x[n] + qe[n-1]</code><br/>
<code>  </code><br/>
<code>  </code><strong><code>return</code></strong><code> y, qe                 </code><em><code>//</code> <code>return</code> <code>output</code> <code>and</code> <code>running</code> <code>error</code></em></p>
<h2 id="applications">Applications</h2>

<p>PDM is the encoding used in Sony's <a href="Super_Audio_CD" title="wikilink">Super Audio CD</a> (SACD) format, under the name <a href="Direct_Stream_Digital" title="wikilink">Direct Stream Digital</a>.</p>

<p>Some systems transmit PDM <a href="stereo_audio" title="wikilink">stereo audio</a> over a single data wire. The rising edge of the master clock indicates a bit from the left channel, while the falling edge of the master clock indicates a bit from the right channel.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Delta_modulation" title="wikilink">Delta modulation</a></li>
<li><a href="Pulse-code_modulation" title="wikilink">Pulse-code modulation</a></li>
<li><a href="Delta-sigma_modulation" title="wikilink">Delta-sigma modulation</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cs.tut.fi/sgn/arg/rosti/1-bit/">1-bit A/D and D/A Converters</a> – Discusses <a href="delta_modulation" title="wikilink">delta modulation</a>, PDM (also known as Sigma-delta modulation or SDM), and relationships to <a href="Pulse-code_modulation" title="wikilink">Pulse-code modulation</a> (PCM)</li>
</ul>

<p><a class="uri" href="de:Pulsdichtemodulation" title="wikilink">de:Pulsdichtemodulation</a>"</p>

<p><a href="Category:Signal_processing" title="wikilink">Category:Signal processing</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Thomas Kite. <a href="http://users.ece.utexas.edu/~bevans/courses/rtdsp/lectures/10_Data_Conversion/AP_Understanding_PDM_Digital_Audio.pdf">"Understanding PDM Digital Audio" (PDF)</a>. 2012. The "PDM Microphones" section on p. 6.<a href="#fnref1">↩</a></li>
<li id="fn2">Maxim Integrated. <a href="http://datasheets.maximintegrated.com/en/ds/MAX98356.pdf">"PDM Input Class D Audio Power Amplifier" (PDF)</a>. 2013. Figure 1 on p. 5; and the "Digital Audio Interface" section on p. 13.<a href="#fnref2">↩</a></li>
<li id="fn3">Akustica. <a href="http://www.akustica.com/Files/Admin/PDFs/Datasheets/DS25-2.1%20AKU230%20Datasheet.pdf">"AKU230 Digital, CMOS MEMS Microphone" (PDF)</a>. 2012. p. 5.<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
