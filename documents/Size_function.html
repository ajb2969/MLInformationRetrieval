<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="230">Size function</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Size function</h1>
<hr/>

<p><strong>Size functions</strong> are shape descriptors, in a geometrical/topological sense. They are functions from the half-plane 

<math display="inline" id="Size_function:0">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi mathvariant="normal">Δ</mi>
    <mo>+</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Δ</ci>
     <plus></plus>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)\in\Delta^{+}
  </annotation>
 </semantics>
</math>

 is defined in the following way. For every 

<math display="inline" id="Size_function:1">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">ℓ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo>,</mo>
     <mi>φ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-ℓ</ci>
     <interval closure="open">
      <ci>M</ci>
      <ci>φ</ci>
     </interval>
    </apply>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell_{(M,\varphi)}(x,y)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Size_function:2">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>p</mi>
    <mo>∈</mo>
    <mi>M</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>p</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mi>y</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <in></in>
     <ci>p</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <ci>φ</ci>
      <ci>p</ci>
     </apply>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{p\in M:\varphi(p)\leq y\}
  </annotation>
 </semantics>
</math>

 is equal to the number of connected components of the set 

<math display="inline" id="Size_function:3">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>


 that contain at least one point at which the <a href="measuring_function" title="wikilink">measuring function</a> (a <a href="continuous_function" title="wikilink">continuous function</a> from a <a href="topological_space" title="wikilink">topological space</a> 

<math display="inline" id="Size_function:4">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{k}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Size_function:5">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a>) 

<math display="inline" id="Size_function:6">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 takes a value smaller than or equal to 

<math display="inline" id="Size_function:7">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mo>:</mo>
   <mrow>
    <mi>M</mi>
    <mo>→</mo>
    <msup>
     <mi>ℝ</mi>
     <mi>k</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>φ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>M</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi:M\to\mathbb{R}^{k}
  </annotation>
 </semantics>
</math>

 .<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The concept of size function can be easily extended to the case of a measuring function 

<math display="inline" id="Size_function:8">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{k}
  </annotation>
 </semantics>
</math>


, where 

<math display="inline" id="Size_function:9">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is endowed with the usual partial order .<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> A survey about size functions (and <a href="size_theory" title="wikilink">size theory</a>) can be found in .<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> </p>
<h2 id="history-and-applications">History and applications</h2>

<p>Size functions were introduced in <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> for the particular case of 

<math display="inline" id="Size_function:10">
 <semantics>
  <msup>
   <mi>C</mi>
   <mn>1</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>C</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{1}
  </annotation>
 </semantics>
</math>

 equal to the topological space of all piecewise 

<math display="inline" id="Size_function:11">
 <semantics>
  <msup>
   <mi>C</mi>
   <mi mathvariant="normal">∞</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>C</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{\infty}
  </annotation>
 </semantics>
</math>

 closed paths in a 

<math display="inline" id="Size_function:12">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 <a href="closed_manifold" title="wikilink">closed manifold</a> embedded in a Euclidean space. Here the topology on 

<math display="inline" id="Size_function:13">
 <semantics>
  <msup>
   <mi>C</mi>
   <mn>0</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>C</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{0}
  </annotation>
 </semantics>
</math>


 is induced by the 

<math display="inline" id="Size_function:14">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

-norm, while the <a href="measuring_function" title="wikilink">measuring function</a> 

<math display="inline" id="Size_function:15">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo>∈</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>γ</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma\in M
  </annotation>
 </semantics>
</math>

 takes each path 

<math display="inline" id="Size_function:16">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 to its length. In <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> the case of 

<math display="inline" id="Size_function:17">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 equal to the topological space of all ordered 

<math display="inline" id="Size_function:18">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>


-tuples of points in a submanifold of a Euclidean space is considered. Here the topology on 

<math display="inline" id="Size_function:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>P</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>P</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>Q</mi>
        <mn>1</mn>
       </msub>
       <mi mathvariant="normal">…</mi>
      </mrow>
      <mo>,</mo>
      <msub>
       <mi>Q</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>max</mi>
     <mrow>
      <mn>1</mn>
      <mo>≤</mo>
      <mi>i</mi>
      <mo>≤</mo>
      <mi>k</mi>
     </mrow>
    </msub>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <msub>
       <mi>P</mi>
       <mi>i</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>Q</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo>∥</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>k</ci>
       </apply>
      </vector>
      <interval closure="open">
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>k</ci>
       </apply>
      </interval>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <apply>
       <and></and>
       <apply>
        <leq></leq>
        <cn type="integer">1</cn>
        <ci>i</ci>
       </apply>
       <apply>
        <leq></leq>
        <share href="#.cmml">
        </share>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d((P_{1},\ldots,P_{k}),(Q_{1}\ldots,Q_{k}))=\max_{1\leq i\leq k}\|P_{i}-Q_{i}\|
  </annotation>
 </semantics>
</math>

 is induced by the metric 

<math display="inline" id="Size_function:20">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{k}
  </annotation>
 </semantics>
</math>

.</p>

<p>An extension of the concept of size function to <a href="algebraic_topology" title="wikilink">algebraic topology</a> was made in <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> where the concept of <a href="size_homotopy_group" title="wikilink">size homotopy group</a> was introduced. Here <a href="measuring_function" title="wikilink">measuring functions</a> taking values in 

<math display="inline" id="Size_function:21">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 are allowed. An extension to <a href="homology_theory" title="wikilink">homology theory</a> (the <a href="size_functor" title="wikilink">size functor</a>) was introduced in .<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> The concepts of <a href="size_homotopy_group" title="wikilink">size homotopy group</a> and <a href="size_functor" title="wikilink">size functor</a> are strictly related to the concept of <a href="persistent_homology_group" title="wikilink">persistent homology group</a> <a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> studied in <a href="persistent_homology" title="wikilink">persistent homology</a>. It is worth to point out that the size function is the rank of the 

<math display="inline" id="Size_function:22">
 <semantics>
  <msup>
   <mi mathvariant="normal">Δ</mi>
   <mo>+</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Δ</ci>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{+}
  </annotation>
 </semantics>
</math>

-th persistent homology group, while the relation between the persistent homology group and the size homotopy group is analogous to the one existing between <a href="homology_group" title="wikilink">homology groups</a> and <a href="homotopy_group" title="wikilink">homotopy groups</a>.</p>

<p>Size functions have been initially introduced as a mathematical tool for shape comparison in <a href="computer_vision" title="wikilink">computer vision</a> and <a href="pattern_recognition" title="wikilink">pattern recognition</a>, and have constituted the seed of <a href="size_theory" title="wikilink">size theory</a> <a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> <a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> <a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> <a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> <a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> <a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> <a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> <a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> .<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> The main point is that size functions are invariant for every transformation preserving the <a href="measuring_function" title="wikilink">measuring function</a>. Hence, they can be adapted to many different applications, by simply changing the <a href="measuring_function" title="wikilink">measuring function</a> in order to get the wanted invariance. Moreover, size functions show properties of relative resistance to noise, depending on the fact that they distribute the information all over the half-plane 

<math display="inline" id="Size_function:23">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>


.</p>
<h2 id="main-properties">Main properties</h2>

<p>Assume that 

<math display="inline" id="Size_function:24">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">ℓ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo>,</mo>
     <mi>φ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-ℓ</ci>
     <interval closure="open">
      <ci>M</ci>
      <ci>φ</ci>
     </interval>
    </apply>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell_{(M,\varphi)}(x,y)
  </annotation>
 </semantics>
</math>

 is a compact locally connected Hausdorff space. The following statements hold:</p>

<p>¤ every size function 

<math display="inline" id="Size_function:25">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is a <a href="non-decreasing_function" title="wikilink">non-decreasing function</a> in the variable 

<math display="inline" id="Size_function:26">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 and a <a href="Nonincreasing_function" title="wikilink">non-increasing function</a> in the variable 

<math display="inline" id="Size_function:27">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">ℓ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo>,</mo>
     <mi>φ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-ℓ</ci>
     <interval closure="open">
      <ci>M</ci>
      <ci>φ</ci>
     </interval>
    </apply>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell_{(M,\varphi)}(x,y)
  </annotation>
 </semantics>
</math>

.</p>

<p>¤ every size function 

<math display="inline" id="Size_function:28">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo><</mo>
   <mrow>
    <mi>min</mi>
    <mi>φ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>x</ci>
    <apply>
     <min></min>
     <ci>φ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x<\min\varphi
  </annotation>
 </semantics>
</math>


 is locally right-constant in both its variables.</p>

<p>¤ for every 

<math display="inline" id="Size_function:29">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>></mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>y</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y>x
  </annotation>
 </semantics>
</math>

 is finite.</p>

<p>¤ for every 

<math display="inline" id="Size_function:30">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">ℓ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo>,</mo>
      <mi>φ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-ℓ</ci>
      <interval closure="open">
       <ci>M</ci>
       <ci>φ</ci>
      </interval>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell_{(M,\varphi)}(x,y)=0
  </annotation>
 </semantics>
</math>

 and every 

<math display="inline" id="Size_function:31">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>≥</mo>
   <mrow>
    <mi>max</mi>
    <mi>φ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>y</ci>
    <apply>
     <max></max>
     <ci>φ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\geq\max\varphi
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Size_function:32">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

.</p>

<p>¤ for every 

<math display="inline" id="Size_function:33">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>


 and every 

<math display="inline" id="Size_function:34">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 equals the number of connected components of 

<math display="inline" id="Size_function:35">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 on which the minimum value of 

<math display="inline" id="Size_function:36">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 is smaller than or equal to 

<math display="inline" id="Size_function:37">
 <semantics>
  <msup>
   <mi>C</mi>
   <mn>1</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>C</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{1}
  </annotation>
 </semantics>
</math>

.</p>

<p>If we also assume that 

<math display="inline" id="Size_function:38">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>


 is a smooth <a href="closed_manifold" title="wikilink">closed manifold</a> and 

<math display="inline" id="Size_function:39">
 <semantics>
  <msub>
   <mi mathvariant="normal">ℓ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo>,</mo>
    <mi>φ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-ℓ</ci>
    <interval closure="open">
     <ci>M</ci>
     <ci>φ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell_{(M,\varphi)}
  </annotation>
 </semantics>
</math>

 is a 

<math display="inline" id="Size_function:40">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

-function, the following useful property holds:</p>

<p>¤ in order that 

<math display="inline" id="Size_function:41">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is a discontinuity point for 

<math display="inline" id="Size_function:42">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 it is necessary that either 

<math display="inline" id="Size_function:43">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo>,</mo>
     <mi>φ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo>,</mo>
     <mi>ψ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <interval closure="open">
     <interval closure="open">
      <ci>M</ci>
      <ci>φ</ci>
     </interval>
     <interval closure="open">
      <ci>N</ci>
      <ci>ψ</ci>
     </interval>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d((M,\varphi),(N,\psi))
  </annotation>
 </semantics>
</math>


 or 

<math display="inline" id="Size_function:44">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo>,</mo>
    <mi>φ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo rspace="7.5pt">,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo>,</mo>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <interval closure="open">
     <ci>M</ci>
     <ci>φ</ci>
    </interval>
    <interval closure="open">
     <ci>N</ci>
     <ci>ψ</ci>
    </interval>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M,\varphi),\ (N,\psi)
  </annotation>
 </semantics>
</math>

 or both are critical values for 

<math display="inline" id="Size_function:45">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">ℓ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>N</mi>
      <mo>,</mo>
      <mi>ψ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">¯</mo>
     </mover>
     <mo>,</mo>
     <mover accent="true">
      <mi>y</mi>
      <mo stretchy="false">¯</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mrow>
    <msub>
     <mi mathvariant="normal">ℓ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo>,</mo>
      <mi>φ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mo>,</mo>
     <mover accent="true">
      <mi>y</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-ℓ</ci>
      <interval closure="open">
       <ci>N</ci>
       <ci>ψ</ci>
      </interval>
     </apply>
     <interval closure="open">
      <apply>
       <ci>normal-¯</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <ci>normal-¯</ci>
       <ci>y</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-ℓ</ci>
      <interval closure="open">
       <ci>M</ci>
       <ci>φ</ci>
      </interval>
     </apply>
     <interval closure="open">
      <apply>
       <ci>normal-~</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <ci>normal-~</ci>
       <ci>y</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell_{(N,\psi)}(\bar{x},\bar{y})>\ell_{(M,\varphi)}(\tilde{x},\tilde{y})
  </annotation>
 </semantics>
</math>

 .<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>

<p>A strong link between the concept of size function and the concept of <a href="natural_pseudodistance" title="wikilink">natural pseudodistance</a> 

<math display="inline" id="Size_function:46">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo>,</mo>
      <mi>φ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>N</mi>
      <mo>,</mo>
      <mi>ψ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mover accent="true">
       <mi>x</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mo>-</mo>
      <mover accent="true">
       <mi>x</mi>
       <mo stretchy="false">¯</mo>
      </mover>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mover accent="true">
       <mi>y</mi>
       <mo stretchy="false">¯</mo>
      </mover>
      <mo>-</mo>
      <mover accent="true">
       <mi>y</mi>
       <mo stretchy="false">~</mo>
      </mover>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <interval closure="open">
       <ci>M</ci>
       <ci>φ</ci>
      </interval>
      <interval closure="open">
       <ci>N</ci>
       <ci>ψ</ci>
      </interval>
     </interval>
    </apply>
    <apply>
     <min></min>
     <apply>
      <minus></minus>
      <apply>
       <ci>normal-~</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <ci>normal-¯</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <ci>normal-¯</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <ci>normal-~</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d((M,\varphi),(N,\psi))\geq\min\{\tilde{x}-\bar{x},\bar{y}-\tilde{y}\}
  </annotation>
 </semantics>
</math>

 between the size pairs 

<math display="inline" id="Size_function:47">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p=(x,y)
  </annotation>
 </semantics>
</math>

 exists <a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> <a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>

<p>¤ if 

<math display="inline" id="Size_function:48">
 <semantics>
  <mrow>
   <mrow>
    <mi>μ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mover>
    <mo movablelimits="false">=</mo>
    <mi>def</mi>
   </mover>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <msub>
        <mi>min</mi>
        <mrow>
         <mrow>
          <mi>α</mi>
          <mo>></mo>
          <mn>0</mn>
         </mrow>
         <mo>,</mo>
         <mrow>
          <mi>β</mi>
          <mo>></mo>
          <mn>0</mn>
         </mrow>
        </mrow>
       </msub>
       <msub>
        <mi mathvariant="normal">ℓ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>M</mi>
         <mo>,</mo>
         <mi>φ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>+</mo>
        <mi>α</mi>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>y</mi>
        <mo>-</mo>
        <mi>β</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi mathvariant="normal">ℓ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>M</mi>
        <mo>,</mo>
        <mi>φ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>+</mo>
        <mi>α</mi>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>y</mi>
        <mo>+</mo>
        <mi>β</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi mathvariant="normal">ℓ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>M</mi>
        <mo>,</mo>
        <mi>φ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <mi>α</mi>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>y</mi>
        <mo>-</mo>
        <mi>β</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi mathvariant="normal">ℓ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>M</mi>
       <mo>,</mo>
       <mi>φ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mi>α</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>y</mi>
       <mo>+</mo>
       <mi>β</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <ci>def</ci>
    </apply>
    <apply>
     <times></times>
     <ci>μ</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <min></min>
         <apply>
          <csymbol cd="ambiguous">formulae-sequence</csymbol>
          <apply>
           <gt></gt>
           <ci>α</ci>
           <cn type="integer">0</cn>
          </apply>
          <apply>
           <gt></gt>
           <ci>β</ci>
           <cn type="integer">0</cn>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-ℓ</ci>
         <interval closure="open">
          <ci>M</ci>
          <ci>φ</ci>
         </interval>
        </apply>
       </apply>
       <interval closure="open">
        <apply>
         <plus></plus>
         <ci>x</ci>
         <ci>α</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>y</ci>
         <ci>β</ci>
        </apply>
       </interval>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-ℓ</ci>
        <interval closure="open">
         <ci>M</ci>
         <ci>φ</ci>
        </interval>
       </apply>
       <interval closure="open">
        <apply>
         <plus></plus>
         <ci>x</ci>
         <ci>α</ci>
        </apply>
        <apply>
         <plus></plus>
         <ci>y</ci>
         <ci>β</ci>
        </apply>
       </interval>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-ℓ</ci>
        <interval closure="open">
         <ci>M</ci>
         <ci>φ</ci>
        </interval>
       </apply>
       <interval closure="open">
        <apply>
         <minus></minus>
         <ci>x</ci>
         <ci>α</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>y</ci>
         <ci>β</ci>
        </apply>
       </interval>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-ℓ</ci>
       <interval closure="open">
        <ci>M</ci>
        <ci>φ</ci>
       </interval>
      </apply>
      <interval closure="open">
       <apply>
        <minus></minus>
        <ci>x</ci>
        <ci>α</ci>
       </apply>
       <apply>
        <plus></plus>
        <ci>y</ci>
        <ci>β</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu(p){\stackrel{{\rm def}}{=}}\min_{\alpha>0,\beta>0}\ell_{({M},\varphi)}(x+%
\alpha,y-\beta)-\ell_{({M},\varphi)}(x+\alpha,y+\beta)-\ell_{({M},\varphi)}(x-%
\alpha,y-\beta)+\ell_{({M},\varphi)}(x-\alpha,y+\beta)
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Size_function:49">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>μ</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu(p)
  </annotation>
 </semantics>
</math>

.</p>

<p>The previous result gives an easy way to get lower bounds for the <a href="natural_pseudodistance" title="wikilink">natural pseudodistance</a> and is one of the main motivation to introduce the concept of size function.</p>
<h2 id="representation-by-formal-series">Representation by formal series</h2>

<p>An algebraic representation of size functions in terms of collections of points and lines in the real plane with multiplicities, i.e. as particular formal series, was furnished in <a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> <a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> .<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> The points (called <em>cornerpoints</em>) and lines (called <em>cornerlines</em>) of such formal series encode the information about discontinuities of the corresponding size functions, while their multiplicities contain the information about the values taken by the size function.</p>

<p>Formally:</p>
<ul>
<li><em>cornerpoints</em> are defined as those points 

<math display="inline" id="Size_function:50">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, with <math>x<y\ ,="" math="" number<="" such="" that="" the=""></y\></math></li>
</ul>

<p>

<math display="inline" id="Size_function:51">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>:</mo>
   <mrow>
    <mi>x</mi>
    <mo>=</mo>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>r</ci>
    <apply>
     <eq></eq>
     <ci>x</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r:x=k
  </annotation>
 </semantics>
</math>

 is positive. The number 

<math display="inline" id="Size_function:52">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>μ</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu(r)
  </annotation>
 </semantics>
</math>

 is said to be the <em>multiplicity</em> of 

<math display="inline" id="Size_function:53">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

.</p>
<ul>
<li><em>cornerlines</em> and are defined as those lines 

<math display="inline" id="Size_function:54">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mo><</mo>
   <mover accent="true">
    <mi>y</mi>
    <mo stretchy="false">¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <ci>normal-¯</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\bar{x}}<{\bar{y}}
  </annotation>
 </semantics>
</math>

 such that</li>
</ul>

<p>

<math display="inline" id="Size_function:55">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">ℓ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo>,</mo>
      <mi>φ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">¯</mo>
     </mover>
     <mo>,</mo>
     <mover accent="true">
      <mi>y</mi>
      <mo stretchy="false">¯</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mstyle scriptlevel="+1">
       <mtable columnspacing="0.4em" rowspacing="0.2ex">
        <mtr>
         <mtd>
          <mrow>
           <mi>p</mi>
           <mo>=</mo>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo>,</mo>
            <mi>y</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mtd>
        </mtr>
        <mtr>
         <mtd>
          <mrow>
           <mrow>
            <mi>x</mi>
            <mo>≤</mo>
            <mover accent="true">
             <mi>x</mi>
             <mo stretchy="false">¯</mo>
            </mover>
           </mrow>
           <mo>,</mo>
           <mrow>
            <mi>y</mi>
            <mo>></mo>
            <mover accent="true">
             <mi>y</mi>
             <mo stretchy="false">¯</mo>
            </mover>
           </mrow>
          </mrow>
         </mtd>
        </mtr>
       </mtable>
      </mstyle>
     </msub>
     <mrow>
      <mi>μ</mi>
      <mrow>
       <mo maxsize="120%" minsize="120%">(</mo>
       <mi>p</mi>
       <mo maxsize="120%" minsize="120%">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mstyle scriptlevel="+1">
       <mtable columnspacing="0.4em" rowspacing="0.2ex">
        <mtr>
         <mtd>
          <mrow>
           <mi>r</mi>
           <mo>:</mo>
           <mrow>
            <mi>x</mi>
            <mo>=</mo>
            <mi>k</mi>
           </mrow>
          </mrow>
         </mtd>
        </mtr>
        <mtr>
         <mtd>
          <mrow>
           <mi>k</mi>
           <mo>≤</mo>
           <mover accent="true">
            <mi>x</mi>
            <mo stretchy="false">¯</mo>
           </mover>
          </mrow>
         </mtd>
        </mtr>
       </mtable>
      </mstyle>
     </msub>
     <mrow>
      <mi>μ</mi>
      <mrow>
       <mo maxsize="120%" minsize="120%">(</mo>
       <mi>r</mi>
       <mo maxsize="120%" minsize="120%">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-ℓ</ci>
      <interval closure="open">
       <ci>M</ci>
       <ci>φ</ci>
      </interval>
     </apply>
     <interval closure="open">
      <apply>
       <ci>normal-¯</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <ci>normal-¯</ci>
       <ci>y</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <ci>STACKED</ci>
        <apply>
         <eq></eq>
         <ci>p</ci>
         <interval closure="open">
          <ci>x</ci>
          <ci>y</ci>
         </interval>
        </apply>
        <apply>
         <csymbol cd="ambiguous">formulae-sequence</csymbol>
         <apply>
          <leq></leq>
          <ci>x</ci>
          <apply>
           <ci>normal-¯</ci>
           <ci>x</ci>
          </apply>
         </apply>
         <apply>
          <gt></gt>
          <ci>y</ci>
          <apply>
           <ci>normal-¯</ci>
           <ci>y</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>μ</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <ci>STACKED</ci>
        <apply>
         <ci>normal-:</ci>
         <ci>r</ci>
         <apply>
          <eq></eq>
          <ci>x</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <apply>
         <leq></leq>
         <ci>k</ci>
         <apply>
          <ci>normal-¯</ci>
          <ci>x</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>μ</ci>
       <ci>r</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell_{({M},\varphi)}({\bar{x}},{\bar{y}})=\sum_{p=(x,y)\atop x\leq{\bar{x}},y>%
\bar{y}}\mu\big(p\big)+\sum_{r:x=k\atop k\leq{\bar{x}}}\mu\big(r\big)
  </annotation>
 </semantics>
</math>

 The number <span class="LaTeX">$\mu (r)\$</span> is sad to be the '' multiplicity'' of <span class="LaTeX">$r\$</span>.</p>
<ul>
<li><em>Representation Theorem</em>: For every <span class="LaTeX">${\bar x}&lt;{\bar y}$</span>, it holds <span class="LaTeX">$\ell _{({M},\varphi )}({\bar x},{\bar y})=\sum _{p=(x,y)\atop x\le {\bar x}, y&gt;\bar y }\mu\big(p\big)+\sum _{r:x=k\atop k\le {\bar x} }\mu\big(r\big)$</span></li>
</ul>

<p>This representation contains the same amount of information about the shape under study as the original size function does, but is much more concise.</p>

<p>This algebraic approach to size functions leads to the definition of new similarity measures between shapes, by translating the problem of comparing size functions into the problem of comparing formal series. The most studied among these metrics between size function is the <a href="matching_distance" title="wikilink">matching distance</a>.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>
<h2 id="references">References</h2>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Size_theory" title="wikilink">Size theory</a></li>
<li><a href="Natural_pseudodistance" title="wikilink">Natural pseudodistance</a></li>
<li><a href="Size_functor" title="wikilink">Size functor</a></li>
<li><a href="Size_homotopy_group" title="wikilink">Size homotopy group</a></li>
<li><a href="Size_pair" title="wikilink">Size pair</a></li>
<li><a href="Matching_distance" title="wikilink">Matching distance</a></li>
<li><a href="Topological_data_analysis" title="wikilink">Topological data analysis</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Topology" title="wikilink">Category:Topology</a> <a href="Category:Algebraic_topology" title="wikilink">Category:Algebraic topology</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Patrizio Frosini, Claudia Landi, <em>Size theory as a topological tool for computer vision</em>, Pattern Recognition And Image Analysis, 9(4):596–603, 1999.<a href="#fnref1">↩</a></li>
<li id="fn2">Patrizio Frosini, Michele Mulazzani, <em>Size homotopy groups for computation of natural size distances</em>, <a href="Bulletin_of_the_Belgian_Mathematical_Society" title="wikilink">Bulletin of the Belgian Mathematical Society</a> 6:455–464 1999.<a href="#fnref2">↩</a></li>
<li id="fn3">Michele d'Amico, Patrizio Frosini, Claudia Landi, <em>Using matching distance in Size Theory: a survey</em>, International Journal of Imaging Systems and Technology, 16(5):154–161, 2006.<a href="#fnref3">↩</a></li>
<li id="fn4">Silvia Biasotti, Andrea Cerri, Patrizio Frosini, Claudia Landi, <em>Multidimensional size functions for shape comparison</em>, Journal of Mathematical Imaging and Vision 32:161–179, 2008.<a href="#fnref4">↩</a></li>
<li id="fn5">Silvia Biasotti, Leila De Floriani, Bianca Falcidieno, Patrizio Frosini, Daniela Giorgi, Claudia Landi, Laura Papaleo, Michela Spagnuolo, <em>Describing shapes by geometrical-topological properties of real functions</em> ACM Computing Surveys, vol. 40 (2008), n. 4, 12:1–12:87.<a href="#fnref5">↩</a></li>
<li id="fn6">Patrizio Frosini, <em>[<a href="http://journals.cambridge.org/download.php?file=%2FBAZ%2FBAZ42_03%2FS0004972700028574a.pdf&amp;code">http://journals.cambridge.org/download.php?file=%2FBAZ%2FBAZ42_03%2FS0004972700028574a.pdf&amp;code;</a>;=eff2726f156a5a8fdb323feb4fadd1e3 A distance for similarity classes of submanifolds of a Euclidean space]</em>, Bulletin of the Australian Mathematical Society, 42(3):407–416, 1990.<a href="#fnref6">↩</a></li>
<li id="fn7">Patrizio Frosini, <em>Measuring shapes by size functions</em>, Proc. of SPIE, Intelligent Robots and Computer Vision X: Algorithms and Techniques, Boston, MA, 1607:122–133, 1991.<a href="#fnref7">↩</a></li>
<li id="fn8">Patrizio Frosini and Michele Mulazzani, <em>Size homotopy groups for computation of natural size distances</em>, <a href="Bulletin_of_the_Belgian_Mathematical_Society" title="wikilink">Bulletin of the Belgian Mathematical Society</a>, 6:455–464 1999.<a href="#fnref8">↩</a></li>
<li id="fn9">Francesca Cagliari, Massimo Ferri and Paola Pozzi, <em>Size functions from a categorical viewpoint</em>, Acta Applicandae Mathematicae, 67(3):225–235, 2001.<a href="#fnref9">↩</a></li>
<li id="fn10">Herbert Edelsbrunner, David Letscher and Afra Zomorodian, <em>Topological Persistence and Simplification</em>, <a href="Discrete_and_Computational_Geometry" title="wikilink">Discrete and Computational Geometry</a>, 28(4):511–533, 2002.<a href="#fnref10">↩</a></li>
<li id="fn11">Michele d'Amico, Patrizio Frosini and Claudia Landi, <em>Using matching distance in Size Theory: a survey</em>, International Journal of Imaging Systems and Technology, 16(5):154–161, 2006.<a href="#fnref11">↩</a></li>
<li id="fn12">Claudio Uras and Alessandro Verri, <em><a href="http://www.icsi.berkeley.edu/pubs/techreports/tr-92-057.pdf">Describing and recognising shape through size functions</a></em> ICSI Technical Report TR-92-057, Berkeley, 1992.<a href="#fnref12">↩</a></li>
<li id="fn13">Alessandro Verri, Claudio Uras, Patrizio Frosini and Massimo Ferri, <em>On the use of size functions for shape analysis</em>, Biological Cybernetics, 70:99–107, 1993.<a href="#fnref13">↩</a></li>
<li id="fn14">Patrizio Frosini and Claudia Landi, <em>Size functions and morphological transformations</em>, Acta Applicandae Mathematicae, 49(1):85–104, 1997.<a href="#fnref14">↩</a></li>
<li id="fn15">Alessandro Verri and Claudio Uras, <em>Metric-topological approach to shape representation and recognition</em>, Image Vision Comput., 14:189–207, 1996.<a href="#fnref15">↩</a></li>
<li id="fn16">Alessandro Verri and Claudio Uras, <em>Computing size functions from edge maps</em>, Internat. J. Comput. Vision, 23(2):169–183, 1997.<a href="#fnref16">↩</a></li>
<li id="fn17">Françoise Dibos, Patrizio Frosini and Denis Pasquignon, <em>The use of size functions for comparison of shapes through differential invariants</em>, Journal of Mathematical Imaging and Vision, 21(2):107–118, 2004.<a href="#fnref17">↩</a></li>
<li id="fn18">Andrea Cerri, Massimo Ferri, Daniela Giorgi, <em>Retrieval of trademark images by means of size functions Graphical Models</em> 68:451–471, 2006.<a href="#fnref18">↩</a></li>
<li id="fn19">Silvia Biasotti, Daniela Giorgi, Michela Spagnuolo, Bianca Falcidieno, <em>Size functions for comparing 3D models</em> Pattern Recognition 41:2855–2873, 2008.<a href="#fnref19">↩</a></li>
<li id="fn20">Patrizio Frosini, <em>Connections between size functions and critical points</em>, Mathematical Methods In The Applied Sciences, 19:555–569, 1996.<a href="#fnref20">↩</a></li>
<li id="fn21">Patrizio Frosini and Claudia Landi, <em>Size Theory as a Topological Tool for Computer Vision</em>, Pattern Recognition And Image Analysis, 9(4):596–603, 1999.<a href="#fnref21">↩</a></li>
<li id="fn22">Pietro Donatini and Patrizio Frosini, <em>Lower bounds for natural pseudodistances via size functions</em>, Archives of Inequalities and Applications, 2(1):1–12, 2004.<a href="#fnref22">↩</a></li>
<li id="fn23">Patrizio Frosini and Claudia Landi, <em>Size Theory as a Topological Tool for Computer Vision</em>, Pattern Recognition And Image Analysis, 9(4):596–603, 1999.<a href="#fnref23">↩</a></li>
<li id="fn24">Claudia Landi and Patrizio Frosini, <em>New pseudodistances for the size function space</em>, Proc. SPIE Vol. 3168, p. 52-60, Vision Geometry VI, Robert A. Melter, Angela Y. Wu, Longin J. Latecki (eds.), 1997.<a href="#fnref24">↩</a></li>
<li id="fn25">Patrizio Frosini and Claudia Landi, <em>Size functions and formal series</em>, Appl. Algebra Engrg. Comm. Comput., 12:327–349, 2001.<a href="#fnref25">↩</a></li>
<li id="fn26">Michele d'Amico, Patrizio Frosini and Claudia Landi, <em>Using matching distance in Size Theory: a survey</em>, International Journal of Imaging Systems and Technology, 16(5):154–161, 2006.<a href="#fnref26">↩</a></li>
</ol>
</section>
</body>
</html>
