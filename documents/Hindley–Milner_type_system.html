<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1280">Hindley–Milner type system</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Hindley–Milner type system</h1>
<hr>In [[type theory]] and [[functional programming]], '''Hindley–Milner''' ('''HM''') (also known as '''Damas–Milner''' or '''Damas–Hindley–Milner''') is a classical [[type system]] for the [[lambda calculus]] with [[parametric polymorphism]], first described by [[J. Roger Hindley]]<ref>{{cite journal | authorlink = J. Roger Hindley | first = J. Roger | last = Hindley | date = 1969 | title = The Principal Type-Scheme of an Object in Combinatory Logic | journal = Transactions of the American Mathematical Society | volume = 146 | pages = 29–60 | jstor = 1
<p>995158 }} and later rediscovered by <a href="Robin_Milner" title="wikilink">Robin Milner</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Luis Damas contributed a close formal analysis and proof of the method in his PhD thesis.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Among HM's more notable properties is completeness and its ability to deduce the <a href="principal_type" title="wikilink">most general type</a> of a given program without the need of any <a href="type_annotation" title="wikilink">type annotations</a> or other hints supplied by the programmer. <strong>Algorithm W</strong> is a fast algorithm, performing <a href="type_inference" title="wikilink">type inference</a> in almost <a href="linear_time" title="wikilink">linear time</a> with respect to the size of the source, making it practically usable to type large programs.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> HM is preferably used for <a href="functional_language" title="wikilink">functional languages</a>. It was first implemented as part of the type system of the programming language <a href="ML_(programming_language)" title="wikilink">ML</a>. Since then, HM has been extended in various ways, most notably by <a href="Bounded_types" title="wikilink">constrained types</a> as used in <a href="Haskell_(programming_language)" title="wikilink">Haskell</a>.</p>
<h2 id="introduction">Introduction</h2>

<p>Organizing their original paper, Damas and Milner<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> clearly separated two very different tasks. One is to describe what types an expression can have and another to present an algorithm actually computing a type. Keeping both aspects apart from each other allows one to focus separately on the logic (i.e. meaning) behind the algorithm, as well as to establish a benchmark for the algorithm's properties.</p>

<p>How expressions and types fit to each other is described by means of a <a href="deductive_system" title="wikilink">deductive system</a>. Like any <a href="proof_system" title="wikilink">proof system</a>, it allows different ways to come to a conclusion and since one and the same expression arguably might have different types, dissimilar conclusions about an expression are possible. Contrary to this, the type inference method itself (<a href="#Algorithm_W" title="wikilink">Algorithm W</a>) is defined as a deterministic step-by-step procedure, leaving no choice what to do next. Thus clearly, decisions not present in the logic might have been made constructing the algorithm, which demand a closer look and justifications but would perhaps remain non-obvious without the above differentiation.</p>
<h2 id="syntax">Syntax</h2>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Expressions</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Hindley–Milner_type_system:0">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="left">
     <mi>e</mi>
    </mtd>
    <mtd columnalign="right">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mi>x</mi>
    </mtd>
    <mtd columnalign="left">
     <mtext>variable</mtext>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="right">
     <mo stretchy="false">|</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mpadded width="+5pt">
       <msub>
        <mi>e</mi>
        <mn>1</mn>
       </msub>
      </mpadded>
      <msub>
       <mi>e</mi>
       <mn>2</mn>
      </msub>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mtext>application</mtext>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="right">
     <mo stretchy="false">|</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mpadded width="+5pt">
        <mi>λ</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>x</mi>
       </mpadded>
      </mrow>
      <mo rspace="7.5pt">.</mo>
      <mi>e</mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mtext>abstraction</mtext>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="right">
     <mo stretchy="false">|</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mpadded width="+5pt">
        <mi>𝚕𝚎𝚝</mi>
       </mpadded>
       <mi>x</mi>
      </mrow>
      <mo>=</mo>
      <mrow>
       <mpadded width="+5pt">
        <msub>
         <mi>e</mi>
         <mn>1</mn>
        </msub>
       </mpadded>
       <mpadded width="+5pt">
        <mi>𝚒𝚗</mi>
       </mpadded>
       <msub>
        <mi>e</mi>
        <mn>2</mn>
       </msub>
      </mrow>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <ci>e</ci>
     <eq></eq>
     <ci>x</ci>
     <mtext>variable</mtext>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <ci>normal-|</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <mtext>application</mtext>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <times></times>
       <ci>λ</ci>
       <ci>x</ci>
      </apply>
      <ci>e</ci>
     </apply>
     <mtext>abstraction</mtext>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <ci>normal-|</ci>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>𝚕𝚎𝚝</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>𝚒𝚗</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{lrll}e&=&x&\textrm{variable}\\
&|&e_{1}\ e_{2}&\textrm{application}\\
&|&\lambda\ x\ .\ e&\textrm{abstraction}\\
&|&\mathtt{let}\ x=e_{1}\ \mathtt{in}\ e_{2}\\
\end{array}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Types</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Hindley–Milner_type_system:1">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="left">
     <mtext>mono</mtext>
    </mtd>
    <mtd columnalign="left">
     <mi>τ</mi>
    </mtd>
    <mtd columnalign="right">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mi>α</mi>
    </mtd>
    <mtd columnalign="left">
     <mpadded lspace="5pt" width="+5pt">
      <mtext>variable</mtext>
     </mpadded>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
    <mtd columnalign="right">
     <mo stretchy="false">|</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mpadded width="+5pt">
       <mi>D</mi>
      </mpadded>
      <mi>τ</mi>
      <mi mathvariant="normal">…</mi>
      <mi>τ</mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mpadded lspace="5pt" width="+5pt">
      <mtext>application</mtext>
     </mpadded>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mtext>poly</mtext>
    </mtd>
    <mtd columnalign="left">
     <mi>σ</mi>
    </mtd>
    <mtd columnalign="right">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mi>τ</mi>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
    <mtd columnalign="right">
     <mo stretchy="false">|</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo rspace="7.5pt">∀</mo>
       <mpadded width="+5pt">
        <mi>α</mi>
       </mpadded>
      </mrow>
      <mo rspace="7.5pt">.</mo>
      <mi>σ</mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mpadded lspace="5pt" width="+5pt">
      <mtext>quantifier</mtext>
     </mpadded>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <mtext>mono</mtext>
     <ci>τ</ci>
     <eq></eq>
     <ci>α</ci>
     <mtext>variable</mtext>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <ci>normal-|</ci>
     <apply>
      <times></times>
      <ci>D</ci>
      <ci>τ</ci>
      <ci>normal-…</ci>
      <ci>τ</ci>
     </apply>
     <mtext>application</mtext>
    </matrixrow>
    <matrixrow>
     <mtext>poly</mtext>
     <ci>σ</ci>
     <eq></eq>
     <ci>τ</ci>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>α</ci>
      </apply>
      <ci>σ</ci>
     </apply>
     <mtext>quantifier</mtext>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{llrll}\textrm{mono}&\tau&=&\alpha&\ \textrm{variable}\\
&&|&D\ \tau\dots\tau&\ \textrm{application}\\
\textrm{poly}&\sigma&=&\tau\\
&&|&\forall\ \alpha\ .\ \sigma&\ \textrm{quantifier}\\
\\
\end{array}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>Logic and algorithm share the notions of "expression" and "type", whose form is made precise by the <a class="uri" href="syntax" title="wikilink">syntax</a>.</p>

<p>The expressions to be typed are exactly those of the <a href="lambda_calculus" title="wikilink">lambda calculus</a>, enhanced by a let-expression. These are shown in the table to the right. For readers unfamiliar with the lambda calculus, here is a brief explanation: The application 

<math display="inline" id="Hindley–Milner_type_system:2">
 <semantics>
  <mrow>
   <msub>
    <mi>e</mi>
    <mn>1</mn>
   </msub>
   <msub>
    <mi>e</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{1}e_{2}
  </annotation>
 </semantics>
</math>


 represents applying the function 

<math display="inline" id="Hindley–Milner_type_system:3">
 <semantics>
  <msub>
   <mi>e</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{1}
  </annotation>
 </semantics>
</math>

 to the argument 

<math display="inline" id="Hindley–Milner_type_system:4">
 <semantics>
  <msub>
   <mi>e</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{2}
  </annotation>
 </semantics>
</math>

, often written 

<math display="inline" id="Hindley–Milner_type_system:5">
 <semantics>
  <mrow>
   <msub>
    <mi>e</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>e</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{1}(e_{2})
  </annotation>
 </semantics>
</math>

. The abstraction 

<math display="inline" id="Hindley–Milner_type_system:6">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>λ</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
   </mrow>
   <mo rspace="7.5pt">.</mo>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\ x\ .\ e
  </annotation>
 </semantics>
</math>

 represents an <a href="anonymous_function" title="wikilink">anonymous function</a> that maps the input 

<math display="inline" id="Hindley–Milner_type_system:7">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


 to the output 

<math display="inline" id="Hindley–Milner_type_system:8">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

. This is also called function literal, common in most contemporary programming languages, and sometimes written as 

<math display="inline" id="Hindley–Milner_type_system:9">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <mi>𝚏𝚞𝚗𝚌𝚝𝚒𝚘𝚗</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mpadded width="+5pt">
    <mi>𝚛𝚎𝚝𝚞𝚛𝚗</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mi>e</mi>
   </mpadded>
   <mi>𝚎𝚗𝚍</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝚏𝚞𝚗𝚌𝚝𝚒𝚘𝚗</ci>
    <ci>x</ci>
    <ci>𝚛𝚎𝚝𝚞𝚛𝚗</ci>
    <ci>e</ci>
    <ci>𝚎𝚗𝚍</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathtt{function}\,(x)\ \mathtt{return}\ e\ \mathtt{end}
  </annotation>
 </semantics>
</math>

. The let expression 

<math display="inline" id="Hindley–Milner_type_system:10">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>𝚕𝚎𝚝</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <msub>
      <mi>e</mi>
      <mn>1</mn>
     </msub>
    </mpadded>
    <mpadded width="+5pt">
     <mi>𝚒𝚗</mi>
    </mpadded>
    <msub>
     <mi>e</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝚕𝚎𝚝</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>𝚒𝚗</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathtt{let}\ x=e_{1}\ \mathtt{in}\ e_{2}
  </annotation>
 </semantics>
</math>

 represents the result of substituting every occurrence of 

<math display="inline" id="Hindley–Milner_type_system:11">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Hindley–Milner_type_system:12">
 <semantics>
  <msub>
   <mi>e</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{2}
  </annotation>
 </semantics>
</math>


 with 

<math display="inline" id="Hindley–Milner_type_system:13">
 <semantics>
  <msub>
   <mi>e</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{1}
  </annotation>
 </semantics>
</math>

.</p>

<p>Types as a whole are split into two groups, called mono- and polytypes.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h3 id="monotypes">Monotypes</h3>

<p>Monotypes 

<math display="inline" id="Hindley–Milner_type_system:14">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 are syntactically represented as <a href="Term_(logic)" title="wikilink">terms</a>. A monotype always designates a particular type, in the sense that it is equal only to itself and different from all others.</p>

<p>Examples of monotypes include type constants like 

<math display="inline" id="Hindley–Milner_type_system:15">
 <semantics>
  <mi>𝚒𝚗𝚝</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚒𝚗𝚝</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathtt{int}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Hindley–Milner_type_system:16">
 <semantics>
  <mi>𝚜𝚝𝚛𝚒𝚗𝚐</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚜𝚝𝚛𝚒𝚗𝚐</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathtt{string}
  </annotation>
 </semantics>
</math>

, and parametric types like 

<math display="inline" id="Hindley–Milner_type_system:17">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>𝙼𝚊𝚙</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>𝚂𝚎𝚝</mi>
     </mpadded>
     <mi>𝚜𝚝𝚛𝚒𝚗𝚐</mi>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>𝚒𝚗𝚝</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝙼𝚊𝚙</ci>
    <apply>
     <times></times>
     <ci>𝚂𝚎𝚝</ci>
     <ci>𝚜𝚝𝚛𝚒𝚗𝚐</ci>
    </apply>
    <ci>𝚒𝚗𝚝</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathtt{Map\ (Set\ string)\ int}
  </annotation>
 </semantics>
</math>


. These types are examples of <em>applications</em> of type functions, for example, from the set 

<math display="inline" id="Hindley–Milner_type_system:18">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msup>
    <mi>𝙼𝚊𝚙</mi>
    <mn>𝟸</mn>
   </msup>
   <mo rspace="7.5pt">,</mo>
   <msup>
    <mi>𝚂𝚎𝚝</mi>
    <mn>𝟷</mn>
   </msup>
   <mo rspace="7.5pt">,</mo>
   <msup>
    <mi>𝚜𝚝𝚛𝚒𝚗𝚐</mi>
    <mn>𝟶</mn>
   </msup>
   <mo rspace="7.5pt">,</mo>
   <msup>
    <mi>𝚒𝚗𝚝</mi>
    <mn>𝟶</mn>
   </msup>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝙼𝚊𝚙</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝚂𝚎𝚝</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝚜𝚝𝚛𝚒𝚗𝚐</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝚒𝚗𝚝</ci>
     <cn type="integer">0</cn>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\mathtt{Map^{2},\ Set^{1},\ string^{0},\ int^{0}}\}
  </annotation>
 </semantics>
</math>

, where the superscript indicates the number of type parameters. The complete set of type functions 

<math display="inline" id="Hindley–Milner_type_system:19">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 is arbitrary in HM, except that it <em>must</em> contain at least 

<math display="inline" id="Hindley–Milner_type_system:20">
 <semantics>
  <msup>
   <mo>→</mo>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-→</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow^{2}
  </annotation>
 </semantics>
</math>

, the type of functions. It is often written in infix notation for convenience. For example, a function mapping integers to strings has type 

<math display="inline" id="Hindley–Milner_type_system:21">
 <semantics>
  <mrow>
   <mi>𝚒𝚗𝚝</mi>
   <mo>→</mo>
   <mi>𝚜𝚝𝚛𝚒𝚗𝚐</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>𝚒𝚗𝚝</ci>
    <ci>𝚜𝚝𝚛𝚒𝚗𝚐</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathtt{int}\rightarrow\mathtt{string}
  </annotation>
 </semantics>
</math>

. <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>Type variables are monotypes. Standing alone, a type variable 

<math display="inline" id="Hindley–Milner_type_system:22">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>


 is meant to be as concrete as 

<math display="inline" id="Hindley–Milner_type_system:23">
 <semantics>
  <mi>𝚒𝚗𝚝</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚒𝚗𝚝</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathtt{int}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Hindley–Milner_type_system:24">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

, and clearly different from both. Type variables occurring as monotypes behave as if they were type constants whose identity is unknown. Correspondingly, a function typed 

<math display="inline" id="Hindley–Milner_type_system:25">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>→</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>α</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\rightarrow\alpha
  </annotation>
 </semantics>
</math>

 only maps values of the particular type 

<math display="inline" id="Hindley–Milner_type_system:26">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 on itself. Such a function can only be applied to values having type 

<math display="inline" id="Hindley–Milner_type_system:27">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>


 and to no others.</p>
<h3 id="polytype">Polytype</h3>

<p><em>Polytypes</em> (or <em>type schemes</em>) are types containing variables bound by one or more for-all quantifiers, e.g. 

<math display="inline" id="Hindley–Milner_type_system:28">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>α</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>α</mi>
    <mo>→</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>α</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>α</ci>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\alpha.\alpha\rightarrow\alpha
  </annotation>
 </semantics>
</math>

.</p>

<p>A function with polytype 

<math display="inline" id="Hindley–Milner_type_system:29">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>α</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>α</mi>
    <mo>→</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>α</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>α</ci>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\alpha.\alpha\rightarrow\alpha
  </annotation>
 </semantics>
</math>

 can map <em>any</em> value of the same type to itself, and the <a href="identity_function" title="wikilink">identity function</a> is a value for this type. As another example 

<math display="inline" id="Hindley–Milner_type_system:30">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>α</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>𝚂𝚎𝚝</mi>
      </mpadded>
      <mi>α</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>𝚒𝚗𝚝</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>α</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>𝚂𝚎𝚝</ci>
      <ci>α</ci>
     </apply>
     <ci>𝚒𝚗𝚝</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\alpha.(\mathtt{Set}\ \alpha)\rightarrow\mathtt{int}
  </annotation>
 </semantics>
</math>

 is the type of a function mapping all finite sets to integers. The count of members is a value for this type. Note that quantifiers can only appear top level, i.e. a type 

<math display="inline" id="Hindley–Milner_type_system:31">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>α</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>α</mi>
    <mo>→</mo>
    <mrow>
     <mo>∀</mo>
     <mi>α</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>α</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>α</ci>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>α</ci>
     </apply>
    </apply>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\alpha.\alpha\rightarrow\forall\alpha.\alpha
  </annotation>
 </semantics>
</math>

 for instance, is excluded by the syntax of types and that monotypes are included in the polytypes, thus a type has the general form 

<math display="inline" id="Hindley–Milner_type_system:32">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <mrow>
      <mo>∀</mo>
      <msub>
       <mi>α</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mi>τ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\alpha_{1}\dots\forall\alpha_{n}.\tau
  </annotation>
 </semantics>
</math>


.</p>
<h3 id="free-type-variables">Free type variables</h3>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Free Type Variables</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Hindley–Milner_type_system:33">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mtext>free</mtext>
      <mrow>
       <mo rspace="7.5pt" stretchy="false">(</mo>
       <mpadded width="+5pt">
        <mi>α</mi>
       </mpadded>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi></mi>
      <mo rspace="7.5pt">=</mo>
      <mrow>
       <mo>{</mo>
       <mi>α</mi>
       <mo>}</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mtext>free</mtext>
      <mrow>
       <mo rspace="7.5pt" stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>D</mi>
        </mpadded>
        <msub>
         <mi>τ</mi>
         <mn>1</mn>
        </msub>
        <mi mathvariant="normal">…</mi>
        <mpadded width="+5pt">
         <msub>
          <mi>τ</mi>
          <mi>n</mi>
         </msub>
        </mpadded>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi></mi>
      <mo rspace="7.5pt">=</mo>
      <mrow>
       <munderover>
        <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋃</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>n</mi>
       </munderover>
       <mrow>
        <mtext>free</mtext>
        <mrow>
         <mo rspace="7.5pt" stretchy="false">(</mo>
         <mpadded width="+5pt">
          <msub>
           <mi>τ</mi>
           <mi>i</mi>
          </msub>
         </mpadded>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mtext>free</mtext>
      <mrow>
       <mo rspace="7.5pt" stretchy="false">(</mo>
       <mo rspace="7.5pt">∀</mo>
       <mpadded width="+5pt">
        <mi>α</mi>
       </mpadded>
       <mo rspace="7.5pt">.</mo>
       <mpadded width="+5pt">
        <mi>σ</mi>
       </mpadded>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi></mi>
      <mo rspace="7.5pt">=</mo>
      <mrow>
       <mrow>
        <mtext>free</mtext>
        <mrow>
         <mo rspace="7.5pt" stretchy="false">(</mo>
         <mpadded width="+5pt">
          <mi>σ</mi>
         </mpadded>
         <mo rspace="7.5pt" stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo rspace="7.5pt">-</mo>
       <mrow>
        <mo>{</mo>
        <mi>α</mi>
        <mo>}</mo>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <times></times>
      <mtext>free</mtext>
      <ci>α</ci>
     </apply>
     <apply>
      <eq></eq>
      <csymbol cd="latexml">absent</csymbol>
      <set>
       <ci>α</ci>
      </set>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <mtext>free</mtext>
      <apply>
       <times></times>
       <ci>D</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>τ</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>τ</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <union></union>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <mtext>free</mtext>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>τ</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <mtext>free</mtext>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="latexml">for-all</csymbol>
       <csymbol cd="unknown">α</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">σ</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <apply>
      <eq></eq>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <mtext>free</mtext>
        <ci>σ</ci>
       </apply>
       <set>
        <ci>α</ci>
       </set>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{ll}\text{free}(\ \alpha\ )&=\ \left\{\alpha\right\}\\
\text{free}(\ D\ \tau_{1}\dots\tau_{n}\ )&=\ \bigcup\limits_{i=1}^{n}{\text{%
free}(\ \tau_{i}\ )}\\
\text{free}(\ \forall\ \alpha\ .\ \sigma\ )&=\ \text{free}(\ \sigma\ )\ -\ %
\left\{\alpha\right\}\\
\end{array}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>In a type 

<math display="inline" id="Hindley–Milner_type_system:34">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <mrow>
      <mo>∀</mo>
      <msub>
       <mi>α</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mi>τ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\alpha_{1}\dots\forall\alpha_{n}.\tau
  </annotation>
 </semantics>
</math>

, the symbol 

<math display="inline" id="Hindley–Milner_type_system:35">
 <semantics>
  <mo>∀</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">for-all</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall
  </annotation>
 </semantics>
</math>

 is the quantifier binding the type variables 

<math display="inline" id="Hindley–Milner_type_system:36">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}
  </annotation>
 </semantics>
</math>

 in the monotype 

<math display="inline" id="Hindley–Milner_type_system:37">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

. The variables 

<math display="inline" id="Hindley–Milner_type_system:38">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}
  </annotation>
 </semantics>
</math>

 are called <em>quantified</em> and any occurrence of a quantified type variable in 

<math display="inline" id="Hindley–Milner_type_system:39">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 is called <em>bound</em> and all unbound type variables in 

<math display="inline" id="Hindley–Milner_type_system:40">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 are called <em>free</em>. Like in the <a href="Lambda_calculus#Free_variables" title="wikilink">lambda calculus</a>, the notion of <a href="Free_variables_and_bound_variables" title="wikilink">free and bound variables</a> is essential for the understanding of the meaning of types.</p>

<p>This is certainly the hardest part of HM, perhaps because polytypes containing free variables are not represented in programming languages like <a href="Haskell_(programming_language)" title="wikilink">Haskell</a>. Likewise, one does not have clauses with free variables in <a class="uri" href="Prolog" title="wikilink">Prolog</a>. In particular developers experienced with both languages and actually knowing all the prerequisites of HM, are likely to slip this point. In Haskell for example, all type variables implicitly occur quantified, i.e. a Haskell type <code>a -&gt; a</code> means 

<math display="inline" id="Hindley–Milner_type_system:41">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>α</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>α</mi>
    <mo>→</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>α</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>α</ci>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\alpha.\alpha\rightarrow\alpha
  </annotation>
 </semantics>
</math>

 here. Because a type like 

<math display="inline" id="Hindley–Milner_type_system:42">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>→</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>α</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\rightarrow\alpha
  </annotation>
 </semantics>
</math>

, though it may practically occur in a Haskell program, cannot be expressed there, it can easily be confused with its quantified version.</p>

<p>So what function can have a type like e.g. 

<math display="inline" id="Hindley–Milner_type_system:43">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>β</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>β</mi>
    <mo>→</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>β</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>β</ci>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\beta.\beta\rightarrow\alpha
  </annotation>
 </semantics>
</math>

, i.e. a mixture of both bound and free type variables and what could the free type variable 

<math display="inline" id="Hindley–Milner_type_system:44">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 therein mean?</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Example 1</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Hindley–Milner_type_system:45">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mpadded width="+5pt">
       <mtext>𝐥𝐞𝐭</mtext>
      </mpadded>
      <mpadded width="+5pt">
       <mi>𝑏𝑎𝑟</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">[</mo>
       <mo>∀</mo>
       <mi>α</mi>
       <mo>.</mo>
       <mo>∀</mo>
       <mi>β</mi>
       <mo>.</mo>
       <mi>α</mi>
       <mo>→</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>β</mi>
        <mo>→</mo>
        <mi>α</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
      <mo>=</mo>
      <mpadded width="+5pt">
       <mi>λ</mi>
      </mpadded>
      <mi>x</mi>
      <mo>.</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mpadded lspace="10pt" width="+15pt">
       <mtext>𝐥𝐞𝐭</mtext>
      </mpadded>
      <mpadded width="+5pt">
       <mi>𝑓𝑜𝑜</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">[</mo>
       <mo>∀</mo>
       <mi>β</mi>
       <mo>.</mo>
       <mi>β</mi>
       <mo>→</mo>
       <mi>α</mi>
       <mo stretchy="false">]</mo>
      </mrow>
      <mo>=</mo>
      <mpadded width="+5pt">
       <mi>λ</mi>
      </mpadded>
      <mi>y</mi>
      <mo>.</mo>
      <mi>x</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mpadded lspace="10pt" width="+15pt">
       <mtext>𝐢𝐧</mtext>
      </mpadded>
      <mi>𝑓𝑜𝑜</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mpadded width="+5pt">
       <mtext>𝐢𝐧</mtext>
      </mpadded>
      <mi>𝑏𝑎𝑟</mi>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <mtext>let</mtext>
      <csymbol cd="unknown">bar</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="latexml">for-all</csymbol>
       <csymbol cd="unknown">α</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="latexml">for-all</csymbol>
       <csymbol cd="unknown">β</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">α</csymbol>
       <ci>normal-→</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">β</csymbol>
        <ci>normal-→</ci>
        <csymbol cd="unknown">α</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-]</ci>
      </cerror>
      <eq></eq>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <mtext>let</mtext>
      <csymbol cd="unknown">foo</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="latexml">for-all</csymbol>
       <csymbol cd="unknown">β</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">β</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">α</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <eq></eq>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">x</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <mtext>in</mtext>
      <ci>𝑓𝑜𝑜</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <mtext>in</mtext>
      <ci>𝑏𝑎𝑟</ci>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{l}\textbf{let}\ \mathit{bar}\ [\forall\alpha.\forall\beta.%
\alpha\rightarrow(\beta\rightarrow\alpha)]=\lambda\ x.\\
\quad\textbf{let}\ \mathit{foo}\ [\forall\beta.\beta\rightarrow\alpha]=\lambda%
\ y.x\\
\quad\textbf{in}\ \mathit{foo}\\
\textbf{in}\ \mathit{bar}\end{array}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>Consider 

<math display="inline" id="Hindley–Milner_type_system:46">
 <semantics>
  <mi>𝑓𝑜𝑜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝑓𝑜𝑜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{foo}
  </annotation>
 </semantics>
</math>

 in Example 1, with type annotations in brackets. Its parameter 

<math display="inline" id="Hindley–Milner_type_system:47">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is not used in the body, but the variable 

<math display="inline" id="Hindley–Milner_type_system:48">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 bound in the outer context of 

<math display="inline" id="Hindley–Milner_type_system:49">
 <semantics>
  <mi>𝑓𝑜𝑜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝑓𝑜𝑜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{foo}
  </annotation>
 </semantics>
</math>

 surely is. As a consequence, 

<math display="inline" id="Hindley–Milner_type_system:50">
 <semantics>
  <mi>𝑓𝑜𝑜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝑓𝑜𝑜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{foo}
  </annotation>
 </semantics>
</math>

 accepts every value as argument, while returning a value bound outside and with it its type. 

<math display="inline" id="Hindley–Milner_type_system:51">
 <semantics>
  <mi>𝑏𝑎𝑟</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝑏𝑎𝑟</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{bar}
  </annotation>
 </semantics>
</math>

 to the contrary has type 

<math display="inline" id="Hindley–Milner_type_system:52">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>α</mi>
   <mo>.</mo>
   <mo>∀</mo>
   <mi>β</mi>
   <mo>.</mo>
   <mi>α</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>β</mi>
    <mo>→</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">α</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">β</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">α</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">β</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">α</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\alpha.\forall\beta.\alpha\rightarrow(\beta\rightarrow\alpha)
  </annotation>
 </semantics>
</math>

, in which all occurring type variables are bound. Evaluating, for instance 

<math display="inline" id="Hindley–Milner_type_system:53">
 <semantics>
  <mrow>
   <mi>𝑏𝑎𝑟</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝑏𝑎𝑟</ci>
    <cn type="float">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{bar}\ 1
  </annotation>
 </semantics>
</math>

, results in a function of type 

<math display="inline" id="Hindley–Milner_type_system:54">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>β</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>β</mi>
    <mo rspace="7.5pt">→</mo>
    <mi>𝑖𝑛𝑡</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>β</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>β</ci>
     <ci>𝑖𝑛𝑡</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\beta.\beta\rightarrow\ \mathit{int}
  </annotation>
 </semantics>
</math>

, perfectly reflecting that foo's monotype 

<math display="inline" id="Hindley–Milner_type_system:55">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Hindley–Milner_type_system:56">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>β</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>β</mi>
    <mo>→</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>β</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>β</ci>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\beta.\beta\rightarrow\alpha
  </annotation>
 </semantics>
</math>

 has been refined by this call.</p>

<p>In this example, the free monotype variable 

<math display="inline" id="Hindley–Milner_type_system:57">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 in foo's type becomes meaningful by being quantified in the outer scope, namely in bar's type. I.e. in context of the example, the same type variable 

<math display="inline" id="Hindley–Milner_type_system:58">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 appears both bound and free in different types. As a consequence, a free type variable cannot be interpreted better than stating it is a monotype without knowing the context. Turning the statement around, in general, a typing is not meaningful without a context.</p>
<h3 id="context-and-typing">Context and typing</h3>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Syntax</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Hindley–Milner_type_system:59">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="left">
     <mtext>Context</mtext>
    </mtd>
    <mtd columnalign="left">
     <mi mathvariant="normal">Γ</mi>
    </mtd>
    <mtd columnalign="right">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mpadded width="+5pt">
       <mi>ϵ</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>𝚎𝚖𝚙𝚝𝚢</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
    <mtd columnalign="right">
     <mo stretchy="false">|</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mo rspace="7.5pt">,</mo>
       <mi>x</mi>
      </mrow>
      <mo>:</mo>
      <mi>σ</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mtext>Typing</mtext>
    </mtd>
    <mtd></mtd>
    <mtd columnalign="right">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mi>e</mi>
      <mo>:</mo>
      <mi>σ</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <mtext>Context</mtext>
     <ci>normal-Γ</ci>
     <eq></eq>
     <apply>
      <times></times>
      <ci>ϵ</ci>
      <ci>𝚎𝚖𝚙𝚝𝚢</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-:</ci>
      <list>
       <ci>normal-Γ</ci>
       <ci>x</ci>
      </list>
      <ci>σ</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <mtext>Typing</mtext>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <eq></eq>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="latexml">proves</csymbol>
       <ci>normal-Γ</ci>
       <ci>e</ci>
      </apply>
      <apply>
       <ci>normal-:</ci>
       <share href="#.cmml">
       </share>
       <ci>σ</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{llrl}\text{Context}&\Gamma&=&\epsilon\ \mathtt{(empty)}\\
&&|&\Gamma,\ x:\sigma\\
\text{Typing}&&=&\Gamma\vdash e:\sigma\\
\\
\end{array}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Free Type Variables</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Hindley–Milner_type_system:60">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mtext>free</mtext>
      <mrow>
       <mo rspace="7.5pt" stretchy="false">(</mo>
       <mpadded width="+5pt">
        <mi mathvariant="normal">Γ</mi>
       </mpadded>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi></mi>
      <mo rspace="7.5pt">=</mo>
      <mrow>
       <munder>
        <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋃</mo>
        <mrow>
         <mi>x</mi>
         <mo>:</mo>
         <mrow>
          <mi>σ</mi>
          <mo>∈</mo>
          <mi mathvariant="normal">Γ</mi>
         </mrow>
        </mrow>
       </munder>
       <mrow>
        <mtext>free</mtext>
        <mrow>
         <mo rspace="7.5pt" stretchy="false">(</mo>
         <mpadded width="+5pt">
          <mi>σ</mi>
         </mpadded>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <times></times>
      <mtext>free</mtext>
      <ci>normal-Γ</ci>
     </apply>
     <apply>
      <eq></eq>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <union></union>
        <apply>
         <ci>normal-:</ci>
         <ci>x</ci>
         <apply>
          <in></in>
          <ci>σ</ci>
          <ci>normal-Γ</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <mtext>free</mtext>
        <ci>σ</ci>
       </apply>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{ll}\text{free}(\ \Gamma\ )&=\ \bigcup\limits_{x:\sigma\in%
\Gamma}\text{free}(\ \sigma\ )\end{array}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>Consequently, to get the yet disjoint parts of the syntax, expressions and types together meaningfully, a third part, the context is needed. Syntactically, it is a list of pairs 

<math display="inline" id="Hindley–Milner_type_system:61">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>:</mo>
   <mi>σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>x</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x:\sigma
  </annotation>
 </semantics>
</math>

, called <a href="Assignment_(mathematical_logic)" title="wikilink">assignments</a> or <a href=":wikt:assumption" title="wikilink">assumptions</a>, stating for each value variable 

<math display="inline" id="Hindley–Milner_type_system:62">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 therein a type 

<math display="inline" id="Hindley–Milner_type_system:63">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{i}
  </annotation>
 </semantics>
</math>

. All three parts combined gives a <em>typing judgment</em> of the form 

<math display="inline" id="Hindley–Milner_type_system:64">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi mathvariant="normal">Γ</mi>
   </mpadded>
   <mo rspace="7.5pt">⊢</mo>
   <mi>e</mi>
   <mo>:</mo>
   <mi>σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <ci>normal-Γ</ci>
     <ci>e</ci>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\ \vdash\ e:\sigma
  </annotation>
 </semantics>
</math>

, stating, that under assumptions 

<math display="inline" id="Hindley–Milner_type_system:65">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

, the expression 

<math display="inline" id="Hindley–Milner_type_system:66">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 has type 

<math display="inline" id="Hindley–Milner_type_system:67">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

.</p>

<p>Now having the complete syntax at hand, one can finally make a meaningful statement about the type of 

<math display="inline" id="Hindley–Milner_type_system:68">
 <semantics>
  <mi>𝑓𝑜𝑜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝑓𝑜𝑜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{foo}
  </annotation>
 </semantics>
</math>

 in example 1, above, namely 

<math display="inline" id="Hindley–Milner_type_system:69">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>:</mo>
   <mi>α</mi>
   <mo>⊢</mo>
   <mpadded width="+5pt">
    <mi>λ</mi>
   </mpadded>
   <mi>y</mi>
   <mo>.</mo>
   <mi>x</mi>
   <mo>:</mo>
   <mo>∀</mo>
   <mi>β</mi>
   <mo>.</mo>
   <mi>β</mi>
   <mo>→</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">α</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">β</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">β</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">α</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x:\alpha\vdash\lambda\ y.x:\forall\beta.\beta\rightarrow\alpha
  </annotation>
 </semantics>
</math>

. Contrary to the above formulations, the monotype variable 

<math display="inline" id="Hindley–Milner_type_system:70">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 no longer appears unbound, i.e. meaningless, but bound in the context as the type of the value variable 

<math display="inline" id="Hindley–Milner_type_system:71">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. The circumstance whether a type variable is bound or free in the context apparently plays a significant role for a type as part of a typing, so 

<math display="inline" id="Hindley–Milner_type_system:72">
 <semantics>
  <mrow>
   <mtext>free</mtext>
   <mrow>
    <mo rspace="7.5pt" stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi mathvariant="normal">Γ</mi>
    </mpadded>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>free</mtext>
    <ci>normal-Γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{free}(\ \Gamma\ )
  </annotation>
 </semantics>
</math>

 it is made precise in the side box.</p>
<h2 id="polymorphic-type-order">Polymorphic type order</h2>

<p>While the equality of monotypes is purely syntactical, polytypes offer a richer structure by being related to other types through a specialization relation 

<math display="inline" id="Hindley–Milner_type_system:73">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>⊑</mo>
   <msup>
    <mi>σ</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">square-image-of-or-equals</csymbol>
    <ci>σ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>σ</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\sqsubseteq\sigma^{\prime}
  </annotation>
 </semantics>
</math>

 expressing that 

<math display="inline" id="Hindley–Milner_type_system:74">
 <semantics>
  <msup>
   <mi>σ</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>σ</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{\prime}
  </annotation>
 </semantics>
</math>

 is more special than 

<math display="inline" id="Hindley–Milner_type_system:75">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

.</p>

<p>When being applied to a value a polymorphic function has to change its shape specializing to deal with this particular type of values. During this process, it also changes its type to match that of the parameter. If for instance the identity function having type 

<math display="inline" id="Hindley–Milner_type_system:76">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>α</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>α</mi>
    <mo>→</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>α</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>α</ci>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\alpha.\alpha\rightarrow\alpha
  </annotation>
 </semantics>
</math>

 is to be applied on a number having type 

<math display="inline" id="Hindley–Milner_type_system:77">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mi>n</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>i</ci>
    <ci>n</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   int
  </annotation>
 </semantics>
</math>

, both simply cannot work together, because all the types are different and nothing fits. What is needed is a function of type 

<math display="inline" id="Hindley–Milner_type_system:78">
 <semantics>
  <mrow>
   <mrow>
    <mi>i</mi>
    <mi>n</mi>
    <mi>t</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>i</mi>
    <mi>n</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>n</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>n</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   int\rightarrow int
  </annotation>
 </semantics>
</math>

. Thus, during application, the polymorphic identity is specialized to a monomorphic version of itself. In terms of the specialization relation, one writes 

<math display="inline" id="Hindley–Milner_type_system:79">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>α</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>α</mi>
    <mo>→</mo>
    <mi>α</mi>
    <mo rspace="7.5pt">⊑</mo>
    <mrow>
     <mi>i</mi>
     <mi>n</mi>
     <mi>t</mi>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>i</mi>
     <mi>n</mi>
     <mi>t</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>α</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <ci>α</ci>
      <ci>α</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">square-image-of-or-equals</csymbol>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>n</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>n</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\alpha.\alpha\rightarrow\alpha\sqsubseteq\ int\rightarrow int
  </annotation>
 </semantics>
</math>

</p>

<p>Now the shape shifting of polymorphic values is not fully arbitrary but rather limited by their pristine polytype. Following what has happened in the example one could paraphrase the rule of specialization, saying, a polymorphic type 

<math display="inline" id="Hindley–Milner_type_system:80">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>α</mi>
   </mrow>
   <mo>.</mo>
   <mi>τ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>α</ci>
    </apply>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\alpha.\tau
  </annotation>
 </semantics>
</math>

 is specialized by consistently replacing each occurrence of 

<math display="inline" id="Hindley–Milner_type_system:81">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Hindley–Milner_type_system:82">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 and dropping the quantifier. While this rule works well for any monotype used as replacement, it fails when a polytype, say 

<math display="inline" id="Hindley–Milner_type_system:83">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>β</mi>
   </mrow>
   <mo>.</mo>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>β</ci>
    </apply>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\beta.\beta
  </annotation>
 </semantics>
</math>

 is tried as a replacement, resulting in the non-syntactical type 

<math display="inline" id="Hindley–Milner_type_system:84">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>β</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>β</mi>
    <mo>→</mo>
    <mrow>
     <mo>∀</mo>
     <mi>β</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>β</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>β</ci>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>β</ci>
     </apply>
    </apply>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\beta.\beta\rightarrow\forall\beta.\beta
  </annotation>
 </semantics>
</math>

. But not only that. Even if a type with nested quantified types would be allowed in the syntax, the result of the substitution would not longer preserve the property of the pristine type, in which both the parameter and the result of the function have the same type, which are now only seemingly equal because both subtypes became independent from each other allowing to specialize the parameter and the result with different types resulting in, e.g. 

<math display="inline" id="Hindley–Milner_type_system:85">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mi>t</mi>
    <mi>r</mi>
    <mi>i</mi>
    <mi>n</mi>
    <mi>g</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>S</mi>
    <mi>e</mi>
    <mpadded width="+5pt">
     <mi>t</mi>
    </mpadded>
    <mi>i</mi>
    <mi>n</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>t</ci>
     <ci>r</ci>
     <ci>i</ci>
     <ci>n</ci>
     <ci>g</ci>
    </apply>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>e</ci>
     <ci>t</ci>
     <ci>i</ci>
     <ci>n</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   string\rightarrow Set\ int
  </annotation>
 </semantics>
</math>

, hardly the right task for an identity function.</p>

<p>The syntactic restriction to allow quantification only top-level is imposed to prevent generalization while specializing. Instead of 

<math display="inline" id="Hindley–Milner_type_system:86">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>β</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>β</mi>
    <mo>→</mo>
    <mrow>
     <mo>∀</mo>
     <mi>β</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>β</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>β</ci>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>β</ci>
     </apply>
    </apply>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\beta.\beta\rightarrow\forall\beta.\beta
  </annotation>
 </semantics>
</math>

, the more special type 

<math display="inline" id="Hindley–Milner_type_system:87">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>β</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>β</mi>
    <mo>→</mo>
    <mi>β</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>β</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>β</ci>
     <ci>β</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\beta.\beta\rightarrow\beta
  </annotation>
 </semantics>
</math>

 must be produced in this case.</p>

<p>One could undo the former specialization by specializing on some value of type 

<math display="inline" id="Hindley–Milner_type_system:88">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>α</mi>
   </mrow>
   <mo>.</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>α</ci>
    </apply>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\alpha.\alpha
  </annotation>
 </semantics>
</math>

 again. In terms of the relation one gains 

<math display="inline" id="Hindley–Milner_type_system:89">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>α</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>α</mi>
    <mo>→</mo>
    <mi>α</mi>
    <mo>⊑</mo>
    <mrow>
     <mo>∀</mo>
     <mi>β</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>β</mi>
    <mo>→</mo>
    <mi>β</mi>
    <mo>⊑</mo>
    <mrow>
     <mo>∀</mo>
     <mi>α</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>α</mi>
    <mo>→</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>α</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <ci>α</ci>
      <ci>α</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">square-image-of-or-equals</csymbol>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>β</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <ci>β</ci>
      <ci>β</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">square-image-of-or-equals</csymbol>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>α</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>α</ci>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\alpha.\alpha\rightarrow\alpha\sqsubseteq\forall\beta.\beta\rightarrow%
\beta\sqsubseteq\forall\alpha.\alpha\rightarrow\alpha
  </annotation>
 </semantics>
</math>

 as a summary, meaning that syntactically different polytypes are equal with respect to renaming their quantified variables.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Specialization Rule</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Hindley–Milner_type_system:90">
 <semantics>
  <mstyle displaystyle="true">
   <mfrac>
    <mrow>
     <msup>
      <mi>τ</mi>
      <mo>′</mo>
     </msup>
     <mo>=</mo>
     <mrow>
      <mo>[</mo>
      <msub>
       <mi>α</mi>
       <mi>i</mi>
      </msub>
      <mo>:=</mo>
      <msub>
       <mi>τ</mi>
       <mi>i</mi>
      </msub>
      <mo>]</mo>
     </mrow>
     <mi>τ</mi>
     <msub>
      <mi>β</mi>
      <mi>i</mi>
     </msub>
     <mo>∉</mo>
     <mtext>free</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>∀</mo>
      <msub>
       <mi>α</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <mo>∀</mo>
      <msub>
       <mi>α</mi>
       <mi>n</mi>
      </msub>
      <mo>.</mo>
      <mi>τ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <msub>
        <mi>α</mi>
        <mn>1</mn>
       </msub>
       <mi mathvariant="normal">…</mi>
       <mrow>
        <mo>∀</mo>
        <msub>
         <mi>α</mi>
         <mi>n</mi>
        </msub>
       </mrow>
      </mrow>
     </mrow>
     <mo>.</mo>
     <mrow>
      <mi>τ</mi>
      <mo>⊑</mo>
      <mrow>
       <mo>∀</mo>
       <mrow>
        <msub>
         <mi>β</mi>
         <mn>1</mn>
        </msub>
        <mi mathvariant="normal">…</mi>
        <mrow>
         <mo>∀</mo>
         <msub>
          <mi>β</mi>
          <mi>m</mi>
         </msub>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
     <mo>.</mo>
     <msup>
      <mi>τ</mi>
      <mo>′</mo>
     </msup>
    </mrow>
   </mfrac>
  </mstyle>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>τ</ci>
      <ci>normal-′</ci>
     </apply>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
      <csymbol cd="latexml">assign</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>τ</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-]</ci>
     </cerror>
     <csymbol cd="unknown">τ</csymbol>
     <ci></ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>i</ci>
     </apply>
     <notin></notin>
     <mtext>free</mtext>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>n</ci>
      </apply>
      <ci>normal-.</ci>
      <csymbol cd="unknown">τ</csymbol>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">square-image-of-or-equals</csymbol>
      <ci>τ</ci>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>β</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="latexml">for-all</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>β</ci>
          <ci>m</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>τ</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\frac{\tau^{\prime}=\left[\alpha_{i}:=\tau_{i}\right]\tau\quad%
\beta_{i}\not\in\textrm{free}(\forall\alpha_{1}...\forall\alpha_{n}.\tau)}{%
\forall\alpha_{1}...\forall\alpha_{n}.\tau\sqsubseteq\forall\beta_{1}...%
\forall\beta_{m}.\tau^{\prime}}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>Now focusing only on the question whether a type is more special than another and no longer what the specialized type is used for, one could summarize the specialization as in the box above. Paraphrasing it clockwise, a type 

<math display="inline" id="Hindley–Milner_type_system:91">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <mrow>
      <mo>∀</mo>
      <msub>
       <mi>α</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mi>τ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\alpha_{1}\dots\forall\alpha_{n}.\tau
  </annotation>
 </semantics>
</math>

 is specialized by consistently replacing any of the quantified variables 

<math display="inline" id="Hindley–Milner_type_system:92">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}
  </annotation>
 </semantics>
</math>

 by arbitrary monotypes 

<math display="inline" id="Hindley–Milner_type_system:93">
 <semantics>
  <msub>
   <mi>τ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>τ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau_{i}
  </annotation>
 </semantics>
</math>

 gaining a monotype 

<math display="inline" id="Hindley–Milner_type_system:94">
 <semantics>
  <msup>
   <mi>τ</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>τ</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau^{\prime}
  </annotation>
 </semantics>
</math>

. Finally, type variables in 

<math display="inline" id="Hindley–Milner_type_system:95">
 <semantics>
  <msup>
   <mi>τ</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>τ</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau^{\prime}
  </annotation>
 </semantics>
</math>

 not occurring free in the pristine type can optionally be quantified.</p>

<p>Thus the specialization rules makes sure that no free variable, i.e. monotype in the pristine type becomes unintentionally bound by a quantifier, but originally quantified variable can be replaced with whatever, even with types introducing new quantified or unquantified type variables.</p>

<p>Starting with a polytype 

<math display="inline" id="Hindley–Milner_type_system:96">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>α</mi>
   </mrow>
   <mo>.</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>α</ci>
    </apply>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\alpha.\alpha
  </annotation>
 </semantics>
</math>

, the specialization could either replace the body by another quantified variable, actually a rename or by some type constant (including the function type) which may or may not have parameters filled either with monotypes or quantified type variables. Once a quantified variable is replaced by a type application, this specialization cannot be undone through another substitution as it was possible for quantified variables. Thus the type application is there to stay. Only if it contains another quantified type variable, the specialization could continue further replacing for it.</p>

<p>So the specialization introduces no further equivalence on polytype beside the already known renaming. Polytypes are syntactically equal up to renaming their quantified variables. The equality of types is a reflexive, antisymmetric and transitive relation and the remaining specializations of polytypes are transitive and with this the relation 

<math display="inline" id="Hindley–Milner_type_system:97">
 <semantics>
  <mo>⊑</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">square-image-of-or-equals</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqsubseteq
  </annotation>
 </semantics>
</math>

 is an <a href="partial_order" title="wikilink">order</a>.</p>
<h2 id="deductive-system">Deductive system</h2>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>The Syntax of Rules</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Hindley–Milner_type_system:98">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="left">
     <mtext>Predicate</mtext>
    </mtd>
    <mtd columnalign="right">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>σ</mi>
      <mo>⊑</mo>
      <msup>
       <mi>σ</mi>
       <mo>′</mo>
      </msup>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="right">
     <mo stretchy="false">|</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>α</mi>
      <mo>∉</mo>
      <mrow>
       <mi>f</mi>
       <mi>r</mi>
       <mi>e</mi>
       <mi>e</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi mathvariant="normal">Γ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="right">
     <mo stretchy="false">|</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>x</mi>
      <mo>;</mo>
      <mo>:</mo>
      <mi>α</mi>
      <mo>∈</mo>
      <mi mathvariant="normal">Γ</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mtext>Judgment</mtext>
    </mtd>
    <mtd columnalign="right">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mtext>Typing</mtext>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mtext>Premise</mtext>
    </mtd>
    <mtd columnalign="right">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mpadded width="+5pt">
       <mtext>Judgment</mtext>
      </mpadded>
      <mo rspace="7.5pt" stretchy="false">|</mo>
      <mtext>Predicate</mtext>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mtext>Conclusion</mtext>
    </mtd>
    <mtd columnalign="right">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mtext>Judgment</mtext>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mtext>Rule</mtext>
    </mtd>
    <mtd columnalign="right">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mstyle displaystyle="true">
       <mfrac>
        <mrow>
         <mpadded width="+5pt">
          <mtext>Premise</mtext>
         </mpadded>
         <mi mathvariant="normal">…</mi>
        </mrow>
        <mtext>Conclusion</mtext>
       </mfrac>
      </mstyle>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>𝙽𝚊𝚖𝚎</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <mtext>Predicate</mtext>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">square-image-of-or-equals</csymbol>
      <ci>σ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>σ</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <ci>normal-|</ci>
     <apply>
      <notin></notin>
      <ci>α</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>r</ci>
       <ci>e</ci>
       <ci>e</ci>
       <ci>normal-Γ</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <ci>normal-|</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-;</ci>
      <ci>normal-:</ci>
      <csymbol cd="unknown">α</csymbol>
      <in></in>
      <csymbol cd="unknown">Γ</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <mtext>Judgment</mtext>
     <eq></eq>
     <mtext>Typing</mtext>
    </matrixrow>
    <matrixrow>
     <mtext>Premise</mtext>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <mtext>Judgment</mtext>
      <ci>normal-|</ci>
      <mtext>Predicate</mtext>
     </cerror>
    </matrixrow>
    <matrixrow>
     <mtext>Conclusion</mtext>
     <eq></eq>
     <mtext>Judgment</mtext>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <mtext>Rule</mtext>
     <eq></eq>
     <list>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <mtext>Premise</mtext>
        <ci>normal-…</ci>
       </apply>
       <mtext>Conclusion</mtext>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>𝙽𝚊𝚖𝚎</ci>
      </apply>
     </list>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{lrl}\text{Predicate}&=&\sigma\sqsubseteq\sigma^{\prime}\\
&|&\alpha\not\in free(\Gamma)\\
&|&x;:\alpha\in\Gamma\\
\\
\text{Judgment}&=&\text{Typing}\\
\text{Premise}&=&\text{Judgment}\ |\ \text{Predicate}\\
\text{Conclusion}&=&\text{Judgment}\\
\\
\text{Rule}&=&\displaystyle\frac{\textrm{Premise}\ \dots}{\textrm{Conclusion}}%
\quad[\mathtt{Name}]\end{array}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>The syntax of HM is carried forward to the syntax of the <a href="Rule_of_inference" title="wikilink">inference rules</a> that form the body of the <a href="formal_system" title="wikilink">formal system</a>, by using the typings as <a href="Judgment_(mathematical_logic)" title="wikilink">judgments</a>. Each of the rules define what conclusion could be drawn from what premises. Additionally to the judgments, some extra conditions introduced above might be used as premises, too.</p>

<p>A proof using the rules is a sequence of judgments such that all premises are listed before a conclusion. Please see the Examples 2 and 3 below for a possible format of proofs. From left to right, each line shows the conclusion, the 

<math display="inline" id="Hindley–Milner_type_system:99">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝙽𝚊𝚖𝚎</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝙽𝚊𝚖𝚎</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Name}]
  </annotation>
 </semantics>
</math>

 of the rule applied and the premises, either by referring to an earlier line (number) if the premise is a judgment or by making the predicate explicit.</p>
<h3 id="typing-rules">Typing rules</h3>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Declarative Rule System</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Hindley–Milner_type_system:100">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="center">
     <mstyle displaystyle="true">
      <mfrac>
       <mrow>
        <mi>x</mi>
        <mo>:</mo>
        <mrow>
         <mi>σ</mi>
         <mo>∈</mo>
         <mi mathvariant="normal">Γ</mi>
        </mrow>
       </mrow>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mo>⊢</mo>
        <mi>x</mi>
        <mo>:</mo>
        <mi>σ</mi>
       </mrow>
      </mfrac>
     </mstyle>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>𝚅𝚊𝚛</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mstyle displaystyle="true">
      <mfrac>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mo>⊢</mo>
        <msub>
         <mi>e</mi>
         <mn>0</mn>
        </msub>
        <mo>:</mo>
        <mrow>
         <mi>τ</mi>
         <mo>→</mo>
         <mrow>
          <msup>
           <mi>τ</mi>
           <mo>′</mo>
          </msup>
          <mi mathvariant="normal">Γ</mi>
         </mrow>
        </mrow>
        <mo>⊢</mo>
        <msub>
         <mi>e</mi>
         <mn>1</mn>
        </msub>
        <mo>:</mo>
        <mi>τ</mi>
       </mrow>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mo>⊢</mo>
        <mrow>
         <mpadded width="+5pt">
          <msub>
           <mi>e</mi>
           <mn>0</mn>
          </msub>
         </mpadded>
         <msub>
          <mi>e</mi>
          <mn>1</mn>
         </msub>
        </mrow>
        <mo>:</mo>
        <msup>
         <mi>τ</mi>
         <mo>′</mo>
        </msup>
       </mrow>
      </mfrac>
     </mstyle>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>𝙰𝚙𝚙</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mstyle displaystyle="true">
      <mfrac>
       <mrow>
        <mrow>
         <mi mathvariant="normal">Γ</mi>
         <mo rspace="5.3pt">,</mo>
         <mi>x</mi>
        </mrow>
        <mo>:</mo>
        <mi>τ</mi>
        <mo>⊢</mo>
        <mi>e</mi>
        <mo>:</mo>
        <msup>
         <mi>τ</mi>
         <mo>′</mo>
        </msup>
       </mrow>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mo>⊢</mo>
        <mpadded width="+5pt">
         <mi>λ</mi>
        </mpadded>
        <mpadded width="+5pt">
         <mi>x</mi>
        </mpadded>
        <mo rspace="7.5pt">.</mo>
        <mi>e</mi>
        <mo>:</mo>
        <mi>τ</mi>
        <mo>→</mo>
        <msup>
         <mi>τ</mi>
         <mo>′</mo>
        </msup>
       </mrow>
      </mfrac>
     </mstyle>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>𝙰𝚋𝚜</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mstyle displaystyle="true">
      <mfrac>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mo>⊢</mo>
        <msub>
         <mi>e</mi>
         <mn>0</mn>
        </msub>
        <mo>:</mo>
        <mrow>
         <mi>σ</mi>
         <mi mathvariant="normal">Γ</mi>
         <mo rspace="4.2pt">,</mo>
         <mi>x</mi>
        </mrow>
        <mo>:</mo>
        <mi>σ</mi>
        <mo>⊢</mo>
        <msub>
         <mi>e</mi>
         <mn>1</mn>
        </msub>
        <mo>:</mo>
        <mi>τ</mi>
       </mrow>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mo>⊢</mo>
        <mrow>
         <mrow>
          <mpadded width="+5pt">
           <mi>𝚕𝚎𝚝</mi>
          </mpadded>
          <mi>x</mi>
         </mrow>
         <mo>=</mo>
         <mrow>
          <mpadded width="+5pt">
           <msub>
            <mi>e</mi>
            <mn>0</mn>
           </msub>
          </mpadded>
          <mpadded width="+5pt">
           <mi>𝚒𝚗</mi>
          </mpadded>
          <msub>
           <mi>e</mi>
           <mn>1</mn>
          </msub>
         </mrow>
        </mrow>
        <mo>:</mo>
        <mi>τ</mi>
       </mrow>
      </mfrac>
     </mstyle>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>𝙻𝚎𝚝</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mstyle displaystyle="true">
      <mfrac>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mo>⊢</mo>
        <mi>e</mi>
        <mo>:</mo>
        <mrow>
         <mrow>
          <msup>
           <mi>σ</mi>
           <mo>′</mo>
          </msup>
          <msup>
           <mi>σ</mi>
           <mo>′</mo>
          </msup>
         </mrow>
         <mo>⊑</mo>
         <mi>σ</mi>
        </mrow>
       </mrow>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mo>⊢</mo>
        <mi>e</mi>
        <mo>:</mo>
        <mi>σ</mi>
       </mrow>
      </mfrac>
     </mstyle>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>𝙸𝚗𝚜𝚝</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mstyle displaystyle="true">
      <mfrac>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mo>⊢</mo>
        <mi>e</mi>
        <mo>:</mo>
        <mrow>
         <mrow>
          <mi>σ</mi>
          <mi>α</mi>
         </mrow>
         <mo>∉</mo>
         <mrow>
          <mtext>free</mtext>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi mathvariant="normal">Γ</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mo>⊢</mo>
        <mi>e</mi>
        <mo>:</mo>
        <mo rspace="7.5pt">∀</mo>
        <mpadded width="+5pt">
         <mi>α</mi>
        </mpadded>
        <mo rspace="7.5pt">.</mo>
        <mi>σ</mi>
       </mrow>
      </mfrac>
     </mstyle>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>𝙶𝚎𝚗</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <divide></divide>
      <apply>
       <ci>normal-:</ci>
       <ci>x</ci>
       <apply>
        <in></in>
        <ci>σ</ci>
        <ci>normal-Γ</ci>
       </apply>
      </apply>
      <apply>
       <and></and>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <ci>normal-Γ</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <ci>σ</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝚅𝚊𝚛</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <divide></divide>
      <apply>
       <and></and>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <ci>normal-Γ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <apply>
         <ci>normal-→</ci>
         <ci>τ</ci>
         <list>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>τ</ci>
           <ci>normal-′</ci>
          </apply>
          <ci>normal-Γ</ci>
         </list>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <share href="#.cmml">
        </share>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <ci>τ</ci>
       </apply>
      </apply>
      <apply>
       <and></and>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <ci>normal-Γ</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>e</ci>
          <cn type="integer">0</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>e</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>τ</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝙰𝚙𝚙</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <divide></divide>
      <apply>
       <and></and>
       <apply>
        <ci>normal-:</ci>
        <list>
         <ci>normal-Γ</ci>
         <ci>x</ci>
        </list>
        <ci>τ</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <share href="#.cmml">
        </share>
        <ci>e</ci>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>τ</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">Γ</csymbol>
       <csymbol cd="latexml">proves</csymbol>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">e</csymbol>
       <ci>normal-:</ci>
       <csymbol cd="unknown">τ</csymbol>
       <ci>normal-→</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>τ</ci>
        <ci>normal-′</ci>
       </apply>
      </cerror>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝙰𝚋𝚜</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <divide></divide>
      <apply>
       <and></and>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <ci>normal-Γ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <list>
         <ci>σ</ci>
         <ci>normal-Γ</ci>
         <ci>x</ci>
        </list>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <ci>σ</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <share href="#.cmml">
        </share>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <ci>τ</ci>
       </apply>
      </apply>
      <apply>
       <and></and>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <ci>normal-Γ</ci>
        <apply>
         <eq></eq>
         <apply>
          <times></times>
          <ci>𝚕𝚎𝚝</ci>
          <ci>x</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>e</ci>
           <cn type="integer">0</cn>
          </apply>
          <ci>𝚒𝚗</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>e</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <ci>τ</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝙻𝚎𝚝</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <divide></divide>
      <apply>
       <and></and>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <ci>normal-Γ</ci>
        <ci>e</ci>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <apply>
         <csymbol cd="latexml">square-image-of-or-equals</csymbol>
         <list>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>σ</ci>
           <ci>normal-′</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>σ</ci>
           <ci>normal-′</ci>
          </apply>
         </list>
         <ci>σ</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <and></and>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <ci>normal-Γ</ci>
        <ci>e</ci>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <ci>σ</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝙸𝚗𝚜𝚝</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <divide></divide>
      <apply>
       <and></and>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <ci>normal-Γ</ci>
        <ci>e</ci>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <apply>
         <notin></notin>
         <list>
          <ci>σ</ci>
          <ci>α</ci>
         </list>
         <apply>
          <times></times>
          <mtext>free</mtext>
          <ci>normal-Γ</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">Γ</csymbol>
       <csymbol cd="latexml">proves</csymbol>
       <csymbol cd="unknown">e</csymbol>
       <ci>normal-:</ci>
       <csymbol cd="latexml">for-all</csymbol>
       <csymbol cd="unknown">α</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">σ</csymbol>
      </cerror>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝙶𝚎𝚗</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{cl}\displaystyle\frac{x:\sigma\in\Gamma}{\Gamma\vdash x:\sigma%
}&[\mathtt{Var}]\\
\\
\displaystyle\frac{\Gamma\vdash e_{0}:\tau\rightarrow\tau^{\prime}\quad\quad%
\Gamma\vdash e_{1}:\tau}{\Gamma\vdash e_{0}\ e_{1}:\tau^{\prime}}&[\mathtt{App%
}]\\
\\
\displaystyle\frac{\Gamma,\;x:\tau\vdash e:\tau^{\prime}}{\Gamma\vdash\lambda%
\ x\ .\ e:\tau\rightarrow\tau^{\prime}}&[\mathtt{Abs}]\\
\\
\displaystyle\frac{\Gamma\vdash e_{0}:\sigma\quad\quad\Gamma,\,x:\sigma\vdash e%
_{1}:\tau}{\Gamma\vdash\mathtt{let}\ x=e_{0}\ \mathtt{in}\ e_{1}:\tau}&[%
\mathtt{Let}]\\
\\
\\
\displaystyle\frac{\Gamma\vdash e:\sigma^{\prime}\quad\sigma^{\prime}%
\sqsubseteq\sigma}{\Gamma\vdash e:\sigma}&[\mathtt{Inst}]\\
\\
\displaystyle\frac{\Gamma\vdash e:\sigma\quad\alpha\notin\text{free}(\Gamma)}{%
\Gamma\vdash e:\forall\ \alpha\ .\ \sigma}&[\mathtt{Gen}]\\
\\
\end{array}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>The side box shows the deduction rules of the HM type system. One can roughly divide them into two groups:</p>

<p>The first four rules 

<math display="inline" id="Hindley–Milner_type_system:101">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝚅𝚊𝚛</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝚅𝚊𝚛</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Var}]
  </annotation>
 </semantics>
</math>

 (variable or function access), 

<math display="inline" id="Hindley–Milner_type_system:102">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝙰𝚙𝚙</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝙰𝚙𝚙</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{App}]
  </annotation>
 </semantics>
</math>

 (<em>application</em>, i.e. function call with one parameter), 

<math display="inline" id="Hindley–Milner_type_system:103">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝙰𝚋𝚜</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝙰𝚋𝚜</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Abs}]
  </annotation>
 </semantics>
</math>

 (<em>abstraction</em>, i.e. function declaration) and 

<math display="inline" id="Hindley–Milner_type_system:104">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝙻𝚎𝚝</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝙻𝚎𝚝</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Let}]
  </annotation>
 </semantics>
</math>

 (variable declaration) are centered around the syntax, presenting one rule for each of the expression forms. Their meaning is pretty obvious at the first glance, as they decompose each expression, prove their sub-expressions and finally combine the individual types found in the premises to the type in the conclusion.</p>

<p>The second group is formed by the remaining two rules 

<math display="inline" id="Hindley–Milner_type_system:105">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝙸𝚗𝚜𝚝</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝙸𝚗𝚜𝚝</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Inst}]
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hindley–Milner_type_system:106">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝙶𝚎𝚗</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝙶𝚎𝚗</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Gen}]
  </annotation>
 </semantics>
</math>

. They handle specialization and generalization of types. While the rule 

<math display="inline" id="Hindley–Milner_type_system:107">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝙸𝚗𝚜𝚝</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝙸𝚗𝚜𝚝</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Inst}]
  </annotation>
 </semantics>
</math>

 should be clear from the section on specialization above, 

<math display="inline" id="Hindley–Milner_type_system:108">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝙶𝚎𝚗</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝙶𝚎𝚗</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Gen}]
  </annotation>
 </semantics>
</math>

 complements the former, working in the opposite direction. It allows generalization, i.e. to quantify monotype variables that are not bound in the context. The necessity of this restriction 

<math display="inline" id="Hindley–Milner_type_system:109">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>∉</mo>
   <mrow>
    <mi>f</mi>
    <mi>r</mi>
    <mi>e</mi>
    <mi>e</mi>
    <mrow>
     <mo rspace="7.5pt" stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi mathvariant="normal">Γ</mi>
     </mpadded>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>α</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>r</ci>
     <ci>e</ci>
     <ci>e</ci>
     <ci>normal-Γ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\not\in free(\ \Gamma\ )
  </annotation>
 </semantics>
</math>

 is introduced in the section on <a href="#Free_type_variables" title="wikilink">free type variables</a>.</p>

<p>The following two examples exercise the rule system in action</p>

<p><strong>Example 2</strong>: A proof for 

<math display="inline" id="Hindley–Milner_type_system:110">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mrow>
    <mi>i</mi>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>i</mi>
    <mi>n</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <ci>normal-Γ</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>d</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>n</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash id(n):int
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Hindley–Milner_type_system:111">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>=</mo>
   <mi>i</mi>
   <mi>d</mi>
   <mo>:</mo>
   <mo>∀</mo>
   <mi>α</mi>
   <mo>.</mo>
   <mi>α</mi>
   <mo>→</mo>
   <mi>α</mi>
   <mo rspace="7.5pt">,</mo>
   <mi>n</mi>
   <mo>:</mo>
   <mi>i</mi>
   <mi>n</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Γ</csymbol>
    <eq></eq>
    <csymbol cd="unknown">i</csymbol>
    <csymbol cd="unknown">d</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">α</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">α</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">α</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">n</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">i</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <csymbol cd="unknown">t</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma=id:\forall\alpha.\alpha\rightarrow\alpha,\ n:int
  </annotation>
 </semantics>
</math>

, could be written</p>

<p>

<math display="block" id="Hindley–Milner_type_system:112">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mn>1</mn>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mi>i</mi>
      <mi>d</mi>
      <mo>:</mo>
      <mo>∀</mo>
      <mi>α</mi>
      <mo>.</mo>
      <mi>α</mi>
      <mo>→</mo>
      <mi>α</mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>𝚅𝚊𝚛</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mi>d</mi>
      <mo>:</mo>
      <mo>∀</mo>
      <mi>α</mi>
      <mo>.</mo>
      <mi>α</mi>
      <mo>→</mo>
      <mi>α</mi>
      <mo>∈</mo>
      <mi mathvariant="normal">Γ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mn>2</mn>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mrow>
       <mi>i</mi>
       <mi>d</mi>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mi>i</mi>
        <mi>n</mi>
        <mi>t</mi>
       </mrow>
       <mo>→</mo>
       <mrow>
        <mi>i</mi>
        <mi>n</mi>
        <mi>t</mi>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>𝙸𝚗𝚜𝚝</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo rspace="7.5pt">,</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mo>∀</mo>
       <mi>α</mi>
       <mo>.</mo>
       <mi>α</mi>
       <mo>→</mo>
       <mi>α</mi>
       <mo>⊑</mo>
       <mi>i</mi>
       <mi>n</mi>
       <mi>t</mi>
       <mo>→</mo>
       <mi>i</mi>
       <mi>n</mi>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mn>3</mn>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mi>n</mi>
      <mo>:</mo>
      <mrow>
       <mi>i</mi>
       <mi>n</mi>
       <mi>t</mi>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>𝚅𝚊𝚛</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>:</mo>
       <mrow>
        <mrow>
         <mi>i</mi>
         <mi>n</mi>
         <mi>t</mi>
        </mrow>
        <mo>∈</mo>
        <mi mathvariant="normal">Γ</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mn>4</mn>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mrow>
       <mi>i</mi>
       <mi>d</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mi>i</mi>
       <mi>n</mi>
       <mi>t</mi>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>𝙰𝚙𝚙</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>2</mn>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo rspace="7.5pt">,</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>3</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <cn type="integer">1</cn>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">Γ</csymbol>
      <csymbol cd="latexml">proves</csymbol>
      <csymbol cd="unknown">i</csymbol>
      <csymbol cd="unknown">d</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">α</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">α</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">α</csymbol>
     </cerror>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝚅𝚊𝚛</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">i</csymbol>
      <csymbol cd="unknown">d</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">α</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">α</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">α</csymbol>
      <in></in>
      <csymbol cd="unknown">Γ</csymbol>
      <ci>normal-)</ci>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <cn type="integer">2</cn>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="latexml">proves</csymbol>
       <ci>normal-Γ</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>d</ci>
       </apply>
      </apply>
      <apply>
       <ci>normal-:</ci>
       <share href="#.cmml">
       </share>
       <apply>
        <ci>normal-→</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>n</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>n</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝙸𝚗𝚜𝚝</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <cn type="integer">1</cn>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-,</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="latexml">for-all</csymbol>
       <csymbol cd="unknown">α</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">α</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">α</csymbol>
       <csymbol cd="latexml">square-image-of-or-equals</csymbol>
       <csymbol cd="unknown">i</csymbol>
       <csymbol cd="unknown">n</csymbol>
       <csymbol cd="unknown">t</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">i</csymbol>
       <csymbol cd="unknown">n</csymbol>
       <csymbol cd="unknown">t</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <cn type="integer">3</cn>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="latexml">proves</csymbol>
       <ci>normal-Γ</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <ci>normal-:</ci>
       <share href="#.cmml">
       </share>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>n</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝚅𝚊𝚛</ci>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <ci>n</ci>
      <apply>
       <in></in>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>n</ci>
        <ci>t</ci>
       </apply>
       <ci>normal-Γ</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <cn type="integer">4</cn>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="latexml">proves</csymbol>
       <ci>normal-Γ</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>d</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <ci>normal-:</ci>
       <share href="#.cmml">
       </share>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>n</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝙰𝚙𝚙</ci>
     </apply>
     <list>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </list>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{llll}1:&\Gamma\vdash id:\forall\alpha.\alpha\rightarrow\alpha&%
[\mathtt{Var}]&(id:\forall\alpha.\alpha\rightarrow\alpha\in\Gamma)\\
2:&\Gamma\vdash id:int\rightarrow int&[\mathtt{Inst}]&(1),\ (\forall\alpha.%
\alpha\rightarrow\alpha\sqsubseteq int\rightarrow int)\\
3:&\Gamma\vdash n:int&[\mathtt{Var}]&(n:int\in\Gamma)\\
4:&\Gamma\vdash id(n):int&[\mathtt{App}]&(2),\ (3)\\
\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p><strong>Example 3</strong>: To demonstrate generalization, 

<math display="inline" id="Hindley–Milner_type_system:113">
 <semantics>
  <mrow>
   <mo rspace="7.5pt">⊢</mo>
   <mpadded width="+1.7pt">
    <mtext>𝐥𝐞𝐭</mtext>
   </mpadded>
   <mi>i</mi>
   <mi>d</mi>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mpadded width="+5pt">
    <mi>x</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mtext>𝐢𝐧</mtext>
   </mpadded>
   <mi>i</mi>
   <mpadded width="+1.7pt">
    <mi>d</mi>
   </mpadded>
   <mo rspace="4.2pt">:</mo>
   <mo>∀</mo>
   <mi>α</mi>
   <mo>.</mo>
   <mi>α</mi>
   <mo>→</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <mtext>let</mtext>
    <csymbol cd="unknown">i</csymbol>
    <csymbol cd="unknown">d</csymbol>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">x</csymbol>
    <mtext>in</mtext>
    <csymbol cd="unknown">i</csymbol>
    <csymbol cd="unknown">d</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">α</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">α</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">α</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash\ \textbf{let}\,id=\lambda x.x\ \textbf{in}\ id\,:\,\forall\alpha.\alpha\rightarrow\alpha
  </annotation>
 </semantics>
</math>

 is shown below:</p>

<p>

<math display="block" id="Hindley–Milner_type_system:114">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mn>1</mn>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>x</mi>
      <mo>:</mo>
      <mi>α</mi>
      <mo>⊢</mo>
      <mi>x</mi>
      <mo>:</mo>
      <mi>α</mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>𝚅𝚊𝚛</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>:</mo>
       <mrow>
        <mi>α</mi>
        <mo>∈</mo>
        <mrow>
         <mo>{</mo>
         <mi>x</mi>
         <mo>:</mo>
         <mi>α</mi>
         <mo>}</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mn>2</mn>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo>⊢</mo>
      <mi>λ</mi>
      <mi>x</mi>
      <mo>.</mo>
      <mi>x</mi>
      <mo>:</mo>
      <mi>α</mi>
      <mo>→</mo>
      <mi>α</mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>𝙰𝚋𝚜</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mn>3</mn>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo>⊢</mo>
      <mi>λ</mi>
      <mi>x</mi>
      <mo>.</mo>
      <mi>x</mi>
      <mo>:</mo>
      <mo>∀</mo>
      <mi>α</mi>
      <mo>.</mo>
      <mi>α</mi>
      <mo>→</mo>
      <mi>α</mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>𝙶𝚎𝚗</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>2</mn>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo rspace="7.5pt">,</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>α</mi>
       <mo>∉</mo>
       <mi>f</mi>
       <mi>r</mi>
       <mi>e</mi>
       <mi>e</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ϵ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mn>4</mn>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>i</mi>
      <mi>d</mi>
      <mo>:</mo>
      <mo>∀</mo>
      <mi>α</mi>
      <mo>.</mo>
      <mi>α</mi>
      <mo>→</mo>
      <mi>α</mi>
      <mo>⊢</mo>
      <mi>i</mi>
      <mi>d</mi>
      <mo>:</mo>
      <mo>∀</mo>
      <mi>α</mi>
      <mo>.</mo>
      <mi>α</mi>
      <mo>→</mo>
      <mi>α</mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>𝚅𝚊𝚛</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mi>d</mi>
      <mo>:</mo>
      <mo>∀</mo>
      <mi>α</mi>
      <mo>.</mo>
      <mi>α</mi>
      <mo>→</mo>
      <mi>α</mi>
      <mo>∈</mo>
      <mrow>
       <mo>{</mo>
       <mi>i</mi>
       <mi>d</mi>
       <mo>:</mo>
       <mo>∀</mo>
       <mi>α</mi>
       <mo>.</mo>
       <mi>α</mi>
       <mo>→</mo>
       <mi>α</mi>
       <mo>}</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mn>5</mn>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo>⊢</mo>
      <mpadded width="+1.7pt">
       <mtext>𝐥𝐞𝐭</mtext>
      </mpadded>
      <mi>i</mi>
      <mi>d</mi>
      <mo>=</mo>
      <mi>λ</mi>
      <mi>x</mi>
      <mo>.</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mtext>𝐢𝐧</mtext>
      </mpadded>
      <mi>i</mi>
      <mpadded width="+1.7pt">
       <mi>d</mi>
      </mpadded>
      <mo rspace="4.2pt">:</mo>
      <mo>∀</mo>
      <mi>α</mi>
      <mo>.</mo>
      <mi>α</mi>
      <mo>→</mo>
      <mi>α</mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>𝙻𝚎𝚝</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>3</mn>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo rspace="7.5pt">,</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>4</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <cn type="integer">1</cn>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <apply>
      <and></and>
      <apply>
       <ci>normal-:</ci>
       <ci>x</ci>
       <ci>α</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">proves</csymbol>
       <share href="#.cmml">
       </share>
       <ci>x</ci>
      </apply>
      <apply>
       <ci>normal-:</ci>
       <share href="#.cmml">
       </share>
       <ci>α</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝚅𝚊𝚛</ci>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <ci>x</ci>
      <apply>
       <in></in>
       <ci>α</ci>
       <apply>
        <csymbol cd="latexml">conditional-set</csymbol>
        <ci>x</ci>
        <ci>α</ci>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <cn type="integer">2</cn>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="latexml">proves</csymbol>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">α</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">α</csymbol>
     </cerror>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝙰𝚋𝚜</ci>
     </apply>
     <cn type="integer">1</cn>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <cn type="integer">3</cn>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="latexml">proves</csymbol>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">α</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">α</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">α</csymbol>
     </cerror>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝙶𝚎𝚗</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <cn type="integer">2</cn>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-,</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">α</csymbol>
       <notin></notin>
       <csymbol cd="unknown">f</csymbol>
       <csymbol cd="unknown">r</csymbol>
       <csymbol cd="unknown">e</csymbol>
       <csymbol cd="unknown">e</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">ϵ</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <cn type="integer">4</cn>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">i</csymbol>
      <csymbol cd="unknown">d</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">α</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">α</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">α</csymbol>
      <csymbol cd="latexml">proves</csymbol>
      <csymbol cd="unknown">i</csymbol>
      <csymbol cd="unknown">d</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">α</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">α</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">α</csymbol>
     </cerror>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝚅𝚊𝚛</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">i</csymbol>
      <csymbol cd="unknown">d</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">α</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">α</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">α</csymbol>
      <in></in>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-{</ci>
       <csymbol cd="unknown">i</csymbol>
       <csymbol cd="unknown">d</csymbol>
       <ci>normal-:</ci>
       <csymbol cd="latexml">for-all</csymbol>
       <csymbol cd="unknown">α</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">α</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">α</csymbol>
       <ci>normal-}</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <cn type="integer">5</cn>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="latexml">proves</csymbol>
      <mtext>let</mtext>
      <csymbol cd="unknown">i</csymbol>
      <csymbol cd="unknown">d</csymbol>
      <eq></eq>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">x</csymbol>
      <mtext>in</mtext>
      <csymbol cd="unknown">i</csymbol>
      <csymbol cd="unknown">d</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">α</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">α</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">α</csymbol>
     </cerror>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝙻𝚎𝚝</ci>
     </apply>
     <list>
      <cn type="integer">3</cn>
      <cn type="integer">4</cn>
     </list>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{llll}1:&x:\alpha\vdash x:\alpha&[\mathtt{Var}]&(x:\alpha\in%
\left\{x:\alpha\right\})\\
2:&\vdash\lambda x.x:\alpha\rightarrow\alpha&[\mathtt{Abs}]&(1)\\
3:&\vdash\lambda x.x:\forall\alpha.\alpha\rightarrow\alpha&[\mathtt{Gen}]&(2),%
\ (\alpha\not\in free(\epsilon))\\
4:&id:\forall\alpha.\alpha\rightarrow\alpha\vdash id:\forall\alpha.\alpha%
\rightarrow\alpha&[\mathtt{Var}]&(id:\forall\alpha.\alpha\rightarrow\alpha\in%
\left\{id:\forall\alpha.\alpha\rightarrow\alpha\right\})\\
5:&\vdash\textbf{let}\,id=\lambda x.x\ \textbf{in}\ id\,:\,\forall\alpha.%
\alpha\rightarrow\alpha&[\mathtt{Let}]&(3),\ (4)\\
\end{array}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="principal-type">Principal type</h3>

<p>As mentioned in the <a href="#Introduction" title="wikilink">introduction</a>, the rules allow one to deduce different types for one and the same expression. See for instance, Example 2, steps 1,2 and Example 3, steps 2,3 for three different typings of the same expression. Clearly, the different results are not fully unrelated, but connected by the <a href="#Polymorphic_type_order" title="wikilink">type order</a>. It is an important property of the rule system and this order that whenever more than one type can be deduced for an expression, among them is (modulo <a class="uri" href="alpha-renaming" title="wikilink">alpha-renaming</a> of the <a href="type_variable" title="wikilink">type variables</a>) a unique most general type in the sense, that all others are specialization of it. Though the rule system must allow to derive specialized types, a type inference algorithm should deliver this most general or principal type as its result.</p>
<h3 id="let-polymorphism">Let-polymorphism</h3>

<p>Not visible immediately, the rule set encodes a regulation under which circumstances a type might be generalized or not by a slightly varying use of mono- and polytypes in the rules 

<math display="inline" id="Hindley–Milner_type_system:115">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝙰𝚋𝚜</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝙰𝚋𝚜</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Abs}]
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hindley–Milner_type_system:116">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝙻𝚎𝚝</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝙻𝚎𝚝</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Let}]
  </annotation>
 </semantics>
</math>

.</p>

<p>In rule 

<math display="inline" id="Hindley–Milner_type_system:117">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝙰𝚋𝚜</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝙰𝚋𝚜</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Abs}]
  </annotation>
 </semantics>
</math>

, the value variable of the parameter of the function 

<math display="inline" id="Hindley–Milner_type_system:118">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.e
  </annotation>
 </semantics>
</math>

 is added to the context with a monomorphic type through the premise 

<math display="inline" id="Hindley–Milner_type_system:119">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo rspace="7.5pt">,</mo>
    <mi>x</mi>
   </mrow>
   <mo>:</mo>
   <mi>τ</mi>
   <mo>⊢</mo>
   <mi>e</mi>
   <mo>:</mo>
   <msup>
    <mi>τ</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <list>
      <ci>normal-Γ</ci>
      <ci>x</ci>
     </list>
     <ci>τ</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <share href="#.cmml">
     </share>
     <ci>e</ci>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>τ</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma,\ x:\tau\vdash e:\tau^{\prime}
  </annotation>
 </semantics>
</math>

, while in the rule 

<math display="inline" id="Hindley–Milner_type_system:120">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝙻𝚎𝚝</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝙻𝚎𝚝</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Let}]
  </annotation>
 </semantics>
</math>

, the variable enters the environment in polymorphic form 

<math display="inline" id="Hindley–Milner_type_system:121">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo rspace="7.5pt">,</mo>
    <mi>x</mi>
   </mrow>
   <mo>:</mo>
   <mi>σ</mi>
   <mo>⊢</mo>
   <msub>
    <mi>e</mi>
    <mn>1</mn>
   </msub>
   <mo>:</mo>
   <mi>τ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <list>
      <ci>normal-Γ</ci>
      <ci>x</ci>
     </list>
     <ci>σ</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma,\ x:\sigma\vdash e_{1}:\tau
  </annotation>
 </semantics>
</math>

. Though in both cases the presence of x in the context prevents the use of the generalisation rule for any monotype variable in the assignment, this regulation forces the parameter x in a 

<math display="inline" id="Hindley–Milner_type_system:122">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

-expression to remain monomorphic, while in a let-expression, the variable could already be introduced polymorphic, making specializations possible.</p>

<p>As a consequence of this regulation, <em>no</em> type can be inferred for 

<math display="inline" id="Hindley–Milner_type_system:123">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>f</mi>
     </mpadded>
     <mtext>true</mtext>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>f</mi>
     </mpadded>
     <mtext>0</mtext>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>f</ci>
      <mtext>true</mtext>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <mtext>0</mtext>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda f.(f\,\textrm{true},f\,\textrm{0})
  </annotation>
 </semantics>
</math>

 since the parameter 

<math display="inline" id="Hindley–Milner_type_system:124">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is in a monomorphic position, while 

<math display="inline" id="Hindley–Milner_type_system:125">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+5pt">
      <mtext>𝐥𝐞𝐭</mtext>
     </mpadded>
     <mi>f</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>x</mi>
    </mpadded>
    <mpadded width="+1.7pt">
     <mtext>𝐢𝐧</mtext>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>f</mi>
      </mpadded>
      <mtext>true</mtext>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>f</mi>
      </mpadded>
      <mtext>0</mtext>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>let</mtext>
      <ci>f</ci>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>x</ci>
     <mtext>in</mtext>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>f</ci>
       <mtext>true</mtext>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <mtext>0</mtext>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{let}\ f=\lambda x.x\,\textbf{in}\,(f\,\textrm{true},f\,\textrm{0})
  </annotation>
 </semantics>
</math>

 yields a type 

<math display="inline" id="Hindley–Milner_type_system:126">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>b</mi>
    <mi>o</mi>
    <mi>o</mi>
    <mi>l</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>i</mi>
    <mi>n</mi>
    <mi>t</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <times></times>
     <ci>b</ci>
     <ci>o</ci>
     <ci>o</ci>
     <ci>l</ci>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>n</ci>
     <ci>t</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (bool,int)
  </annotation>
 </semantics>
</math>

, because 

<math display="inline" id="Hindley–Milner_type_system:127">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 has been introduced in a let-expression and is treated polymorphic therefore. Note that this behaviour is in strong contrast to the usual definition 

<math display="inline" id="Hindley–Milner_type_system:128">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mtext>𝐥𝐞𝐭</mtext>
   </mpadded>
   <mi>x</mi>
   <mo>=</mo>
   <mpadded width="+5pt">
    <msub>
     <mi>e</mi>
     <mn>1</mn>
    </msub>
   </mpadded>
   <mpadded width="+5pt">
    <mtext>𝐢𝐧</mtext>
   </mpadded>
   <mpadded width="+5pt">
    <msub>
     <mi>e</mi>
     <mn>2</mn>
    </msub>
   </mpadded>
   <mo>:</mo>
   <mo>:=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>λ</mi>
    </mpadded>
    <mi>x</mi>
    <mo>.</mo>
    <msub>
     <mi>e</mi>
     <mn>2</mn>
    </msub>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <msub>
    <mi>e</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>let</mtext>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">1</cn>
    </apply>
    <mtext>in</mtext>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-:</ci>
    <csymbol cd="latexml">assign</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">1</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{let}\ x=e_{1}\ \textbf{in}\ e_{2}\ ::=(\lambda\ x.e_{2})\ e_{1}
  </annotation>
 </semantics>
</math>

 and the reason why the let-expression appears in the syntax at all. This distinction is called <strong>let-polymorphism</strong> or <strong>let generalization</strong> and is a conception owed to HM.</p>
<h2 id="towards-an-algorithm">Towards an algorithm</h2>

<p>Now that the deduction system of HM is at hand, one could present an algorithm and validate it with respect to the rules. Alternatively, it might be possible to derive it by taking a closer look on how the rules interact and proof are formed. This is done in the remainder of this article focusing on the possible decisions one can make while proving a typing.</p>
<h3 id="degrees-of-freedom-choosing-the-rules">Degrees of freedom choosing the rules</h3>

<p>Isolating the points in a proof, where no decision is possible at all, the first group of rules centered around the syntax leaves no choice since to each syntactical rule corresponds a unique typing rule, which determines a part of the proof, while between the conclusion and the premises of these fixed parts chains of 

<math display="inline" id="Hindley–Milner_type_system:129">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝙸𝚗𝚜𝚝</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝙸𝚗𝚜𝚝</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Inst}]
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hindley–Milner_type_system:130">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝙶𝚎𝚗</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝙶𝚎𝚗</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Gen}]
  </annotation>
 </semantics>
</math>

 could occur. Such a chain could also exist between the conclusion of the proof and the rule for topmost expression. All proofs must have the so sketched shape.</p>

<p>Because the only choice in a proof with respect of rule selection are the 

<math display="inline" id="Hindley–Milner_type_system:131">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝙸𝚗𝚜𝚝</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝙸𝚗𝚜𝚝</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Inst}]
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hindley–Milner_type_system:132">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝙶𝚎𝚗</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝙶𝚎𝚗</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Gen}]
  </annotation>
 </semantics>
</math>

 chains, the form of the proof suggests the question whether it can be made more precise, where these chains might be needed. This is in fact possible and leads to a variant of the rules system with no such rules.</p>
<h3 id="syntax-directed-rule-system">Syntax-directed rule system</h3>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Syntactical Rule System</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Hindley–Milner_type_system:133">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="center">
     <mstyle displaystyle="true">
      <mfrac>
       <mrow>
        <mi>x</mi>
        <mo>:</mo>
        <mrow>
         <mrow>
          <mi>σ</mi>
          <mo>∈</mo>
          <mi mathvariant="normal">Γ</mi>
         </mrow>
         <mrow>
          <mi>τ</mi>
          <mo>⊑</mo>
          <mi>σ</mi>
         </mrow>
        </mrow>
       </mrow>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mo>⊢</mo>
        <mi>x</mi>
        <mo>:</mo>
        <mi>τ</mi>
       </mrow>
      </mfrac>
     </mstyle>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>𝚅𝚊𝚛</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mstyle displaystyle="true">
      <mfrac>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mo>⊢</mo>
        <msub>
         <mi>e</mi>
         <mn>0</mn>
        </msub>
        <mo>:</mo>
        <mrow>
         <mi>τ</mi>
         <mo>→</mo>
         <mrow>
          <msup>
           <mi>τ</mi>
           <mo>′</mo>
          </msup>
          <mi mathvariant="normal">Γ</mi>
         </mrow>
        </mrow>
        <mo>⊢</mo>
        <msub>
         <mi>e</mi>
         <mn>1</mn>
        </msub>
        <mo>:</mo>
        <mi>τ</mi>
       </mrow>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mo>⊢</mo>
        <mrow>
         <mpadded width="+5pt">
          <msub>
           <mi>e</mi>
           <mn>0</mn>
          </msub>
         </mpadded>
         <msub>
          <mi>e</mi>
          <mn>1</mn>
         </msub>
        </mrow>
        <mo>:</mo>
        <msup>
         <mi>τ</mi>
         <mo>′</mo>
        </msup>
       </mrow>
      </mfrac>
     </mstyle>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>𝙰𝚙𝚙</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mstyle displaystyle="true">
      <mfrac>
       <mrow>
        <mrow>
         <mi mathvariant="normal">Γ</mi>
         <mo rspace="5.3pt">,</mo>
         <mi>x</mi>
        </mrow>
        <mo>:</mo>
        <mi>τ</mi>
        <mo>⊢</mo>
        <mi>e</mi>
        <mo>:</mo>
        <msup>
         <mi>τ</mi>
         <mo>′</mo>
        </msup>
       </mrow>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mo>⊢</mo>
        <mpadded width="+5pt">
         <mi>λ</mi>
        </mpadded>
        <mpadded width="+5pt">
         <mi>x</mi>
        </mpadded>
        <mo rspace="7.5pt">.</mo>
        <mi>e</mi>
        <mo>:</mo>
        <mi>τ</mi>
        <mo>→</mo>
        <msup>
         <mi>τ</mi>
         <mo>′</mo>
        </msup>
       </mrow>
      </mfrac>
     </mstyle>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>𝙰𝚋𝚜</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mstyle displaystyle="true">
      <mfrac>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mo>⊢</mo>
        <msub>
         <mi>e</mi>
         <mn>0</mn>
        </msub>
        <mo>:</mo>
        <mrow>
         <mi>τ</mi>
         <mi mathvariant="normal">Γ</mi>
         <mo rspace="4.2pt">,</mo>
         <mi>x</mi>
        </mrow>
        <mo>:</mo>
        <mrow>
         <mover accent="true">
          <mi mathvariant="normal">Γ</mi>
          <mo stretchy="false">¯</mo>
         </mover>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>τ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>⊢</mo>
        <msub>
         <mi>e</mi>
         <mn>1</mn>
        </msub>
        <mo>:</mo>
        <msup>
         <mi>τ</mi>
         <mo>′</mo>
        </msup>
       </mrow>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mo>⊢</mo>
        <mrow>
         <mrow>
          <mpadded width="+5pt">
           <mi>𝚕𝚎𝚝</mi>
          </mpadded>
          <mi>x</mi>
         </mrow>
         <mo>=</mo>
         <mrow>
          <mpadded width="+5pt">
           <msub>
            <mi>e</mi>
            <mn>0</mn>
           </msub>
          </mpadded>
          <mpadded width="+5pt">
           <mi>𝚒𝚗</mi>
          </mpadded>
          <msub>
           <mi>e</mi>
           <mn>1</mn>
          </msub>
         </mrow>
        </mrow>
        <mo>:</mo>
        <msup>
         <mi>τ</mi>
         <mo>′</mo>
        </msup>
       </mrow>
      </mfrac>
     </mstyle>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>𝙻𝚎𝚝</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <divide></divide>
      <apply>
       <ci>normal-:</ci>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <apply>
         <in></in>
         <ci>σ</ci>
         <ci>normal-Γ</ci>
        </apply>
        <apply>
         <csymbol cd="latexml">square-image-of-or-equals</csymbol>
         <ci>τ</ci>
         <ci>σ</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <and></and>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <ci>normal-Γ</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <ci>τ</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝚅𝚊𝚛</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <divide></divide>
      <apply>
       <and></and>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <ci>normal-Γ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <apply>
         <ci>normal-→</ci>
         <ci>τ</ci>
         <list>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>τ</ci>
           <ci>normal-′</ci>
          </apply>
          <ci>normal-Γ</ci>
         </list>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <share href="#.cmml">
        </share>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <ci>τ</ci>
       </apply>
      </apply>
      <apply>
       <and></and>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <ci>normal-Γ</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>e</ci>
          <cn type="integer">0</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>e</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>τ</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝙰𝚙𝚙</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <divide></divide>
      <apply>
       <and></and>
       <apply>
        <ci>normal-:</ci>
        <list>
         <ci>normal-Γ</ci>
         <ci>x</ci>
        </list>
        <ci>τ</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <share href="#.cmml">
        </share>
        <ci>e</ci>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>τ</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">Γ</csymbol>
       <csymbol cd="latexml">proves</csymbol>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">e</csymbol>
       <ci>normal-:</ci>
       <csymbol cd="unknown">τ</csymbol>
       <ci>normal-→</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>τ</ci>
        <ci>normal-′</ci>
       </apply>
      </cerror>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝙰𝚋𝚜</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <divide></divide>
      <apply>
       <and></and>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <ci>normal-Γ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <list>
         <ci>τ</ci>
         <ci>normal-Γ</ci>
         <ci>x</ci>
        </list>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <apply>
         <times></times>
         <apply>
          <ci>normal-¯</ci>
          <ci>normal-Γ</ci>
         </apply>
         <ci>τ</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <share href="#.cmml">
        </share>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>τ</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <and></and>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <ci>normal-Γ</ci>
        <apply>
         <eq></eq>
         <apply>
          <times></times>
          <ci>𝚕𝚎𝚝</ci>
          <ci>x</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>e</ci>
           <cn type="integer">0</cn>
          </apply>
          <ci>𝚒𝚗</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>e</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>τ</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝙻𝚎𝚝</ci>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{cl}\displaystyle\frac{x:\sigma\in\Gamma\quad\tau\sqsubseteq%
\sigma}{\Gamma\vdash x:\tau}&[\mathtt{Var}]\\
\\
\displaystyle\frac{\Gamma\vdash e_{0}:\tau\rightarrow\tau^{\prime}\quad\quad%
\Gamma\vdash e_{1}:\tau}{\Gamma\vdash e_{0}\ e_{1}:\tau^{\prime}}&[\mathtt{App%
}]\\
\\
\displaystyle\frac{\Gamma,\;x:\tau\vdash e:\tau^{\prime}}{\Gamma\vdash\lambda%
\ x\ .\ e:\tau\rightarrow\tau^{\prime}}&[\mathtt{Abs}]\\
\\
\displaystyle\frac{\Gamma\vdash e_{0}:\tau\quad\quad\Gamma,\,x:\bar{\Gamma}(%
\tau)\vdash e_{1}:\tau^{\prime}}{\Gamma\vdash\mathtt{let}\ x=e_{0}\ \mathtt{in%
}\ e_{1}:\tau^{\prime}}&[\mathtt{Let}]\end{array}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Generalization</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Hindley–Milner_type_system:134">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi mathvariant="normal">Γ</mi>
      <mo stretchy="false">¯</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>τ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo rspace="7.5pt">∀</mo>
     <mpadded width="+5pt">
      <mover accent="true">
       <mi>α</mi>
       <mo stretchy="false">^</mo>
      </mover>
     </mpadded>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">.</mo>
   <mrow>
    <mrow>
     <mi>τ</mi>
     <mover accent="true">
      <mi>α</mi>
      <mo stretchy="false">^</mo>
     </mover>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mtext>free</mtext>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>τ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mtext>free</mtext>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi mathvariant="normal">Γ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-¯</ci>
       <ci>normal-Γ</ci>
      </apply>
      <ci>τ</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>α</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <list>
      <ci>τ</ci>
      <apply>
       <ci>normal-^</ci>
       <ci>α</ci>
      </apply>
     </list>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <mtext>free</mtext>
       <ci>τ</ci>
      </apply>
      <apply>
       <times></times>
       <mtext>free</mtext>
       <ci>normal-Γ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{\Gamma}(\tau)=\forall\ \hat{\alpha}\ .\ \tau\quad\quad\hat{\alpha}=%
\textrm{free}(\tau)-\textrm{free}(\Gamma)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>A contemporary treatment of HM uses a purely <a class="uri" href="syntax-directed" title="wikilink">syntax-directed</a> rule system due to Clement<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> as an intermediate step. In this system, the specialization is located directly after the original 

<math display="inline" id="Hindley–Milner_type_system:135">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝚅𝚊𝚛</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝚅𝚊𝚛</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Var}]
  </annotation>
 </semantics>
</math>

 rule and merged into it, while the generalization becomes part of the 

<math display="inline" id="Hindley–Milner_type_system:136">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝙻𝚎𝚝</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝙻𝚎𝚝</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Let}]
  </annotation>
 </semantics>
</math>

 rule. There the generalization is also determined to always produce the most general type by introducing the function 

<math display="inline" id="Hindley–Milner_type_system:137">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi mathvariant="normal">Γ</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>τ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-¯</ci>
     <ci>normal-Γ</ci>
    </apply>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{\Gamma}(\tau)
  </annotation>
 </semantics>
</math>

, which quantifies all monotype variables not bound in 

<math display="inline" id="Hindley–Milner_type_system:138">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

.</p>

<p>Formally, to validate, that this new rule system 

<math display="inline" id="Hindley–Milner_type_system:139">
 <semantics>
  <msub>
   <mo>⊢</mo>
   <mi>S</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash_{S}
  </annotation>
 </semantics>
</math>

 is equivalent to the original 

<math display="inline" id="Hindley–Milner_type_system:140">
 <semantics>
  <msub>
   <mo>⊢</mo>
   <mi>D</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash_{D}
  </annotation>
 </semantics>
</math>

, one has to show that 

<math display="inline" id="Hindley–Milner_type_system:141">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mpadded width="+5pt">
    <msub>
     <mo>⊢</mo>
     <mi>D</mi>
    </msub>
   </mpadded>
   <mi>e</mi>
   <mo>:</mo>
   <mi>σ</mi>
   <mo>⇔</mo>
   <mi mathvariant="normal">Γ</mi>
   <mpadded width="+5pt">
    <msub>
     <mo>⊢</mo>
     <mi>S</mi>
    </msub>
   </mpadded>
   <mi>e</mi>
   <mo>:</mo>
   <mi>σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Γ</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <ci>D</ci>
    </apply>
    <csymbol cd="unknown">e</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">σ</csymbol>
    <ci>normal-⇔</ci>
    <csymbol cd="unknown">Γ</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <ci>S</ci>
    </apply>
    <csymbol cd="unknown">e</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">σ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash_{D}\ e:\sigma\Leftrightarrow\Gamma\vdash_{S}\ e:\sigma
  </annotation>
 </semantics>
</math>

, which falls apart into two sub-proofs:</p>
<ul>
<li>

<math display="inline" id="Hindley–Milner_type_system:142">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mpadded width="+5pt">
    <msub>
     <mo>⊢</mo>
     <mi>D</mi>
    </msub>
   </mpadded>
   <mi>e</mi>
   <mo>:</mo>
   <mi>σ</mi>
   <mo>⇐</mo>
   <mi mathvariant="normal">Γ</mi>
   <mpadded width="+5pt">
    <msub>
     <mo>⊢</mo>
     <mi>S</mi>
    </msub>
   </mpadded>
   <mi>e</mi>
   <mo>:</mo>
   <mi>σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Γ</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <ci>D</ci>
    </apply>
    <csymbol cd="unknown">e</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">σ</csymbol>
    <ci>normal-⇐</ci>
    <csymbol cd="unknown">Γ</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <ci>S</ci>
    </apply>
    <csymbol cd="unknown">e</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">σ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash_{D}\ e:\sigma\Leftarrow\Gamma\vdash_{S}\ e:\sigma
  </annotation>
 </semantics>
</math>

 (<a class="uri" href="Consistency" title="wikilink">Consistency</a>)</li>
<li>

<math display="inline" id="Hindley–Milner_type_system:143">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mpadded width="+5pt">
    <msub>
     <mo>⊢</mo>
     <mi>D</mi>
    </msub>
   </mpadded>
   <mi>e</mi>
   <mo>:</mo>
   <mi>σ</mi>
   <mo>⇒</mo>
   <mi mathvariant="normal">Γ</mi>
   <mpadded width="+5pt">
    <msub>
     <mo>⊢</mo>
     <mi>S</mi>
    </msub>
   </mpadded>
   <mi>e</mi>
   <mo>:</mo>
   <mi>σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Γ</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <ci>D</ci>
    </apply>
    <csymbol cd="unknown">e</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">σ</csymbol>
    <ci>normal-⇒</ci>
    <csymbol cd="unknown">Γ</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <ci>S</ci>
    </apply>
    <csymbol cd="unknown">e</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">σ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash_{D}\ e:\sigma\Rightarrow\Gamma\vdash_{S}\ e:\sigma
  </annotation>
 </semantics>
</math>

 (<a href="Completeness_(logic)" title="wikilink">Completeness</a>)</li>
</ul>

<p>While consistency can be seen by decomposing the rules 

<math display="inline" id="Hindley–Milner_type_system:144">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝙻𝚎𝚝</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝙻𝚎𝚝</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Let}]
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hindley–Milner_type_system:145">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝚅𝚊𝚛</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝚅𝚊𝚛</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Var}]
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Hindley–Milner_type_system:146">
 <semantics>
  <msub>
   <mo>⊢</mo>
   <mi>S</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash_{S}
  </annotation>
 </semantics>
</math>

 into proofs in 

<math display="inline" id="Hindley–Milner_type_system:147">
 <semantics>
  <msub>
   <mo>⊢</mo>
   <mi>D</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash_{D}
  </annotation>
 </semantics>
</math>

, it is likely visible that 

<math display="inline" id="Hindley–Milner_type_system:148">
 <semantics>
  <msub>
   <mo>⊢</mo>
   <mi>S</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash_{S}
  </annotation>
 </semantics>
</math>

 is incomplete, as one cannot show 

<math display="inline" id="Hindley–Milner_type_system:149">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>λ</mi>
   </mpadded>
   <mi>x</mi>
   <mo>.</mo>
   <mi>x</mi>
   <mo>:</mo>
   <mo>∀</mo>
   <mi>α</mi>
   <mo>.</mo>
   <mi>α</mi>
   <mo>→</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">α</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">α</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">α</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\ x.x:\forall\alpha.\alpha\rightarrow\alpha
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Hindley–Milner_type_system:150">
 <semantics>
  <msub>
   <mo>⊢</mo>
   <mi>S</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash_{S}
  </annotation>
 </semantics>
</math>

, for instance, but only 

<math display="inline" id="Hindley–Milner_type_system:151">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>λ</mi>
   </mpadded>
   <mi>x</mi>
   <mo>.</mo>
   <mi>x</mi>
   <mo>:</mo>
   <mi>α</mi>
   <mo>→</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">α</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">α</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\ x.x:\alpha\rightarrow\alpha
  </annotation>
 </semantics>
</math>

. An only slightly weaker version of completeness is provable <a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> though, namely</p>
<ul>
<li>

<math display="inline" id="Hindley–Milner_type_system:152">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mpadded width="+5pt">
    <msub>
     <mo>⊢</mo>
     <mi>D</mi>
    </msub>
   </mpadded>
   <mi>e</mi>
   <mo>:</mo>
   <mi>σ</mi>
   <mo>⇒</mo>
   <mi mathvariant="normal">Γ</mi>
   <mpadded width="+5pt">
    <msub>
     <mo>⊢</mo>
     <mi>S</mi>
    </msub>
   </mpadded>
   <mi>e</mi>
   <mo>:</mo>
   <mi>τ</mi>
   <mo>∧</mo>
   <mover accent="true">
    <mi mathvariant="normal">Γ</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>τ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊑</mo>
   <mi>σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Γ</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <ci>D</ci>
    </apply>
    <csymbol cd="unknown">e</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">σ</csymbol>
    <ci>normal-⇒</ci>
    <csymbol cd="unknown">Γ</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <ci>S</ci>
    </apply>
    <csymbol cd="unknown">e</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">τ</csymbol>
    <and></and>
    <apply>
     <ci>normal-¯</ci>
     <ci>normal-Γ</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">τ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">square-image-of-or-equals</csymbol>
    <csymbol cd="unknown">σ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash_{D}\ e:\sigma\Rightarrow\Gamma\vdash_{S}\ e:\tau\wedge\bar{\Gamma%
}(\tau)\sqsubseteq\sigma
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>implying, one can derive the principal type for an expression in 

<math display="inline" id="Hindley–Milner_type_system:153">
 <semantics>
  <msub>
   <mo>⊢</mo>
   <mi>S</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash_{S}
  </annotation>
 </semantics>
</math>

 allowing to generalize the proof in the end.</p>

<p>Comparing 

<math display="inline" id="Hindley–Milner_type_system:154">
 <semantics>
  <msub>
   <mo>⊢</mo>
   <mi>D</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash_{D}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hindley–Milner_type_system:155">
 <semantics>
  <msub>
   <mo>⊢</mo>
   <mi>S</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash_{S}
  </annotation>
 </semantics>
</math>

 note that only monotypes appear in the judgments of all rules, now.</p>
<h3 id="degrees-of-freedom-instantiating-the-rules">Degrees of freedom instantiating the rules</h3>

<p>Within the rules themselves, assuming a given expression, one is free to pick the instances for (rule) variables not occurring in this expression. These are the instances for the type variable in the rules. Working towards finding the most general type, this choice can be limited to picking suitable types for 

<math display="inline" id="Hindley–Milner_type_system:156">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Hindley–Milner_type_system:157">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝚅𝚊𝚛</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝚅𝚊𝚛</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Var}]
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hindley–Milner_type_system:158">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝙰𝚋𝚜</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝙰𝚋𝚜</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Abs}]
  </annotation>
 </semantics>
</math>

. The decision of a suitable choice cannot be made locally, but its quality becomes apparent in the premises of 

<math display="inline" id="Hindley–Milner_type_system:159">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝙰𝚙𝚙</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝙰𝚙𝚙</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{App}]
  </annotation>
 </semantics>
</math>

, the only rule, in which two different types, namely the function's formal and actual parameter type have to come together as one.</p>

<p>Therefore, the general strategy for finding a proof would be to make the most general assumption (

<math display="inline" id="Hindley–Milner_type_system:160">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>∉</mo>
   <mrow>
    <mi>f</mi>
    <mi>r</mi>
    <mi>e</mi>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">Γ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>α</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>r</ci>
     <ci>e</ci>
     <ci>e</ci>
     <ci>normal-Γ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\not\in free(\Gamma)
  </annotation>
 </semantics>
</math>

) for 

<math display="inline" id="Hindley–Milner_type_system:161">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Hindley–Milner_type_system:162">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝙰𝚋𝚜</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝙰𝚋𝚜</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Abs}]
  </annotation>
 </semantics>
</math>

 and to refine this and the choice to be made in 

<math display="inline" id="Hindley–Milner_type_system:163">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝚅𝚊𝚛</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝚅𝚊𝚛</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Var}]
  </annotation>
 </semantics>
</math>

 until all side conditions imposed by the 

<math display="inline" id="Hindley–Milner_type_system:164">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝙰𝚙𝚙</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝙰𝚙𝚙</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{App}]
  </annotation>
 </semantics>
</math>

 rules are finally met. Fortunately, no trial and error is needed, since an effective method is known to compute all the choices, <a href="John_Alan_Robinson" title="wikilink">Robinson's</a> <a href="Unification_(computing)" title="wikilink">Unification</a> in combination with the so-called <a href="Disjoint-set_data_structure" title="wikilink">Union-Find</a> algorithm.</p>

<p>To briefly summarize the union-find algorithm, given the set of all types in a proof, it allows one to group them together into <a href="equivalence_class" title="wikilink">equivalence classes</a> by means of a 

<math display="inline" id="Hindley–Milner_type_system:165">
 <semantics>
  <mi>𝚞𝚗𝚒𝚘𝚗</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚞𝚗𝚒𝚘𝚗</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathtt{union}
  </annotation>
 </semantics>
</math>

 procedure and to pick a representative for each such class using a 

<math display="inline" id="Hindley–Milner_type_system:166">
 <semantics>
  <mi>𝚏𝚒𝚗𝚍</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚏𝚒𝚗𝚍</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathtt{find}
  </annotation>
 </semantics>
</math>

 procedure. Emphasizing on the word <a href="Procedure_(computer_science)" title="wikilink">procedure</a> in the sense of <a href="Side_effect_(computer_science)" title="wikilink">side effect</a>, we're clearly leaving the realm of logic to prepare an effective algorithm. The representative of a 

<math display="inline" id="Hindley–Milner_type_system:167">
 <semantics>
  <mrow>
   <mi>𝚞𝚗𝚒𝚘𝚗</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝚞𝚗𝚒𝚘𝚗</ci>
    <interval closure="open">
     <ci>a</ci>
     <ci>b</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathtt{union}(a,b)
  </annotation>
 </semantics>
</math>

 is determined such, that if both 

<math display="inline" id="Hindley–Milner_type_system:168">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hindley–Milner_type_system:169">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 are type variables the representative is arbitrarily one of them, while uniting a variable and a term, the term becomes the representative. Assuming an implementation of union-find at hand, one can formulate the unification of two monotypes as follows:</p>

<p><code>unify(ta,tb):</code><br/>
<code>  ta = find(ta)</code><br/>
<code>  tb = find(tb)</code><br/>
<code>  </code><strong><code>if</code></strong><code> both ta,tb are terms of the form D p1..pn with identical D,n </code><strong><code>then</code></strong><br/>
<code>    unify(ta[i],tb[i]) for each corresponding </code><em><code>i</code></em><code>th parameter</code><br/>
<code>  </code><strong><code>else</code></strong><br/>
<code>  </code><strong><code>if</code></strong><code> at least one of ta,tb is a type variable </code><strong><code>then</code></strong><br/>
<code>    union(ta,tb)</code><br/>
<code>  </code><strong><code>else</code></strong><br/>
<code>    error 'types do not match'</code></p>
<h2 id="algorithm-w">Algorithm W</h2>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Algorithm W</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Hindley–Milner_type_system:170">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="center">
     <mstyle displaystyle="true">
      <mfrac>
       <mrow>
        <mi>x</mi>
        <mo>:</mo>
        <mrow>
         <mrow>
          <mi>σ</mi>
          <mo>∈</mo>
          <mi mathvariant="normal">Γ</mi>
         </mrow>
         <mrow>
          <mi>τ</mi>
          <mo>=</mo>
          <mrow>
           <mi>𝑖𝑛𝑠𝑡</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>σ</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mo>⊢</mo>
        <mi>x</mi>
        <mo>:</mo>
        <mi>τ</mi>
       </mrow>
      </mfrac>
     </mstyle>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>𝚅𝚊𝚛</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mstyle displaystyle="true">
      <mfrac>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mo>⊢</mo>
        <msub>
         <mi>e</mi>
         <mn>0</mn>
        </msub>
        <mo>:</mo>
        <msub>
         <mi>τ</mi>
         <mn>0</mn>
        </msub>
        <mi mathvariant="normal">Γ</mi>
        <mo>⊢</mo>
        <msub>
         <mi>e</mi>
         <mn>1</mn>
        </msub>
        <mo>:</mo>
        <msub>
         <mi>τ</mi>
         <mn>1</mn>
        </msub>
        <msup>
         <mi>τ</mi>
         <mo>′</mo>
        </msup>
        <mo>=</mo>
        <mi>𝑛𝑒𝑤𝑣𝑎𝑟</mi>
        <mi>𝑢𝑛𝑖𝑓𝑦</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>τ</mi>
          <mn>0</mn>
         </msub>
         <mo rspace="7.5pt">,</mo>
         <msub>
          <mi>τ</mi>
          <mn>1</mn>
         </msub>
         <mo>→</mo>
         <msup>
          <mi>τ</mi>
          <mo>′</mo>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mo>⊢</mo>
        <mrow>
         <mpadded width="+5pt">
          <msub>
           <mi>e</mi>
           <mn>0</mn>
          </msub>
         </mpadded>
         <msub>
          <mi>e</mi>
          <mn>1</mn>
         </msub>
        </mrow>
        <mo>:</mo>
        <msup>
         <mi>τ</mi>
         <mo>′</mo>
        </msup>
       </mrow>
      </mfrac>
     </mstyle>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>𝙰𝚙𝚙</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mstyle displaystyle="true">
      <mfrac>
       <mrow>
        <mrow>
         <mi>τ</mi>
         <mo>=</mo>
         <mrow>
          <mi>𝑛𝑒𝑤𝑣𝑎𝑟</mi>
          <mi mathvariant="normal">Γ</mi>
          <mo rspace="5.3pt">,</mo>
          <mi>x</mi>
         </mrow>
        </mrow>
        <mo>:</mo>
        <mi>τ</mi>
        <mo>⊢</mo>
        <mi>e</mi>
        <mo>:</mo>
        <msup>
         <mi>τ</mi>
         <mo>′</mo>
        </msup>
       </mrow>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mo>⊢</mo>
        <mpadded width="+5pt">
         <mi>λ</mi>
        </mpadded>
        <mpadded width="+5pt">
         <mi>x</mi>
        </mpadded>
        <mo rspace="7.5pt">.</mo>
        <mi>e</mi>
        <mo>:</mo>
        <mi>τ</mi>
        <mo>→</mo>
        <msup>
         <mi>τ</mi>
         <mo>′</mo>
        </msup>
       </mrow>
      </mfrac>
     </mstyle>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>𝙰𝚋𝚜</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mstyle displaystyle="true">
      <mfrac>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mo>⊢</mo>
        <msub>
         <mi>e</mi>
         <mn>0</mn>
        </msub>
        <mo>:</mo>
        <mrow>
         <mi>τ</mi>
         <mi mathvariant="normal">Γ</mi>
         <mo rspace="4.2pt">,</mo>
         <mi>x</mi>
        </mrow>
        <mo>:</mo>
        <mrow>
         <mover accent="true">
          <mi mathvariant="normal">Γ</mi>
          <mo stretchy="false">¯</mo>
         </mover>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>τ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>⊢</mo>
        <msub>
         <mi>e</mi>
         <mn>1</mn>
        </msub>
        <mo>:</mo>
        <msup>
         <mi>τ</mi>
         <mo>′</mo>
        </msup>
       </mrow>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mo>⊢</mo>
        <mrow>
         <mrow>
          <mpadded width="+5pt">
           <mi>𝚕𝚎𝚝</mi>
          </mpadded>
          <mi>x</mi>
         </mrow>
         <mo>=</mo>
         <mrow>
          <mpadded width="+5pt">
           <msub>
            <mi>e</mi>
            <mn>0</mn>
           </msub>
          </mpadded>
          <mpadded width="+5pt">
           <mi>𝚒𝚗</mi>
          </mpadded>
          <msub>
           <mi>e</mi>
           <mn>1</mn>
          </msub>
         </mrow>
        </mrow>
        <mo>:</mo>
        <msup>
         <mi>τ</mi>
         <mo>′</mo>
        </msup>
       </mrow>
      </mfrac>
     </mstyle>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>𝙻𝚎𝚝</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <divide></divide>
      <apply>
       <ci>normal-:</ci>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <apply>
         <in></in>
         <ci>σ</ci>
         <ci>normal-Γ</ci>
        </apply>
        <apply>
         <eq></eq>
         <ci>τ</ci>
         <apply>
          <times></times>
          <ci>𝑖𝑛𝑠𝑡</ci>
          <ci>σ</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <and></and>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <ci>normal-Γ</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <ci>τ</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝚅𝚊𝚛</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <divide></divide>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">Γ</csymbol>
       <csymbol cd="latexml">proves</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>normal-:</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>τ</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci></ci>
       <csymbol cd="unknown">Γ</csymbol>
       <csymbol cd="latexml">proves</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-:</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>τ</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci></ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>τ</ci>
        <ci>normal-′</ci>
       </apply>
       <eq></eq>
       <csymbol cd="unknown">newvar</csymbol>
       <ci></ci>
       <csymbol cd="unknown">unify</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>τ</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>normal-,</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>τ</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-→</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>τ</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
      <apply>
       <and></and>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <ci>normal-Γ</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>e</ci>
          <cn type="integer">0</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>e</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>τ</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝙰𝚙𝚙</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <divide></divide>
      <apply>
       <and></and>
       <apply>
        <ci>normal-:</ci>
        <apply>
         <eq></eq>
         <ci>τ</ci>
         <list>
          <ci>𝑛𝑒𝑤𝑣𝑎𝑟</ci>
          <ci>normal-Γ</ci>
          <ci>x</ci>
         </list>
        </apply>
        <ci>τ</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <share href="#.cmml">
        </share>
        <ci>e</ci>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>τ</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">Γ</csymbol>
       <csymbol cd="latexml">proves</csymbol>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">e</csymbol>
       <ci>normal-:</ci>
       <csymbol cd="unknown">τ</csymbol>
       <ci>normal-→</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>τ</ci>
        <ci>normal-′</ci>
       </apply>
      </cerror>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝙰𝚋𝚜</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <divide></divide>
      <apply>
       <and></and>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <ci>normal-Γ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <list>
         <ci>τ</ci>
         <ci>normal-Γ</ci>
         <ci>x</ci>
        </list>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <apply>
         <times></times>
         <apply>
          <ci>normal-¯</ci>
          <ci>normal-Γ</ci>
         </apply>
         <ci>τ</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <share href="#.cmml">
        </share>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>τ</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <and></and>
       <apply>
        <csymbol cd="latexml">proves</csymbol>
        <ci>normal-Γ</ci>
        <apply>
         <eq></eq>
         <apply>
          <times></times>
          <ci>𝚕𝚎𝚝</ci>
          <ci>x</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>e</ci>
           <cn type="integer">0</cn>
          </apply>
          <ci>𝚒𝚗</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>e</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <ci>normal-:</ci>
        <share href="#.cmml">
        </share>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>τ</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝙻𝚎𝚝</ci>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{cl}\displaystyle\frac{x:\sigma\in\Gamma\quad\tau=\mathit{inst}%
(\sigma)}{\Gamma\vdash x:\tau}&[\mathtt{Var}]\\
\\
\displaystyle\frac{\Gamma\vdash e_{0}:\tau_{0}\quad\Gamma\vdash e_{1}:\tau_{1}%
\quad\tau^{\prime}=\mathit{newvar}\quad\mathit{unify}(\tau_{0},\ \tau_{1}%
\rightarrow\tau^{\prime})}{\Gamma\vdash e_{0}\ e_{1}:\tau^{\prime}}&[\mathtt{%
App}]\\
\\
\displaystyle\frac{\tau=\mathit{newvar}\quad\Gamma,\;x:\tau\vdash e:\tau^{%
\prime}}{\Gamma\vdash\lambda\ x\ .\ e:\tau\rightarrow\tau^{\prime}}&[\mathtt{%
Abs}]\\
\\
\displaystyle\frac{\Gamma\vdash e_{0}:\tau\quad\quad\Gamma,\,x:\bar{\Gamma}(%
\tau)\vdash e_{1}:\tau^{\prime}}{\Gamma\vdash\mathtt{let}\ x=e_{0}\ \mathtt{in%
}\ e_{1}:\tau^{\prime}}&[\mathtt{Let}]\end{array}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>The presentation of Algorithm W as shown in the side box does not only deviate significantly from the original<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> but is also a gross abuse of the notation of logical rules, since it includes side effects. It is legitimized here, for allowing a direct comparison with 

<math display="inline" id="Hindley–Milner_type_system:171">
 <semantics>
  <msub>
   <mo>⊢</mo>
   <mi>S</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash_{S}
  </annotation>
 </semantics>
</math>

 while expressing an efficient implementation at the same time. The rules now specify a procedure with parameters 

<math display="inline" id="Hindley–Milner_type_system:172">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>,</mo>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>normal-Γ</ci>
    <ci>e</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma,e
  </annotation>
 </semantics>
</math>

 yielding 

<math display="inline" id="Hindley–Milner_type_system:173">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 in the conclusion where the execution of the premises proceeds from left to right. Alternatively to a procedure, it could be viewed as an <a href="Attribute_grammar" title="wikilink">attributation</a> of the expression.</p>

<p>The procedure 

<math display="inline" id="Hindley–Milner_type_system:174">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mi>n</mi>
   <mi>s</mi>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>σ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>i</ci>
    <ci>n</ci>
    <ci>s</ci>
    <ci>t</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   inst(\sigma)
  </annotation>
 </semantics>
</math>

 specializes the polytype 

<math display="inline" id="Hindley–Milner_type_system:175">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 by copying the term and replacing the bound type variables consistently by new monotype variables. '

<math display="inline" id="Hindley–Milner_type_system:176">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi>e</mi>
   <mi>w</mi>
   <mi>v</mi>
   <mi>a</mi>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>e</ci>
    <ci>w</ci>
    <ci>v</ci>
    <ci>a</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   newvar
  </annotation>
 </semantics>
</math>

' produces a new monotype variable. Likely, 

<math display="inline" id="Hindley–Milner_type_system:177">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi mathvariant="normal">Γ</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>τ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-¯</ci>
     <ci>normal-Γ</ci>
    </apply>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{\Gamma}(\tau)
  </annotation>
 </semantics>
</math>

 has to copy the type introducing new variables for the quantification to avoid unwanted captures. Overall, the algorithm now proceeds by always making the most general choice leaving the specialization to the unification, which by itself produces the most general result. As noted <a href="#Syntax_driven_Rule_System" title="wikilink">above</a>, the final result 

<math display="inline" id="Hindley–Milner_type_system:178">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 has to be generalized to 

<math display="inline" id="Hindley–Milner_type_system:179">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi mathvariant="normal">Γ</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>τ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-¯</ci>
     <ci>normal-Γ</ci>
    </apply>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{\Gamma}(\tau)
  </annotation>
 </semantics>
</math>

 in the end, to gain the most general type for a given expression.</p>

<p>Because the procedures used in the algorithm have nearly O(1) cost, the overall cost of the algorithm is close to linear in the size of the expression for which a type is to be inferred. This is in strong contrast to many other attempts to derive type inference algorithms, which often came out to be <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>, if not <a href="Undecidable_problem" title="wikilink">undecidable</a> with respect to termination. Thus the HM performs as well as the best fully informed type-checking algorithms can. Type-checking here means that an algorithm does not have to find a proof, but only to validate a given one.</p>

<p>Efficiency is slightly reduced because the binding of type variables in the context has to be maintained to allow computation of 

<math display="inline" id="Hindley–Milner_type_system:180">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi mathvariant="normal">Γ</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>τ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-¯</ci>
     <ci>normal-Γ</ci>
    </apply>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{\Gamma}(\tau)
  </annotation>
 </semantics>
</math>

 and enable an <a href="occurs_check" title="wikilink">occurs check</a> to prevent the building of recursive types during 

<math display="inline" id="Hindley–Milner_type_system:181">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mi>n</mi>
   <mi>i</mi>
   <mi>o</mi>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo>,</mo>
    <mi>τ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>u</ci>
    <ci>n</ci>
    <ci>i</ci>
    <ci>o</ci>
    <ci>n</ci>
    <interval closure="open">
     <ci>α</ci>
     <ci>τ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   union(\alpha,\tau)
  </annotation>
 </semantics>
</math>

. An example of such a case is 

<math display="inline" id="Hindley–Milner_type_system:182">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>λ</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\ x.(x\ x)
  </annotation>
 </semantics>
</math>

, for which no type can be derived using HM. Practically, types are only small terms and do not build up expanding structures. Thus, in complexity analysis, one can treat comparing them as a constant, retaining O(1) costs.</p>
<h3 id="original-presentation-of-algorithm-w">Original presentation of Algorithm W</h3>

<p>In the original paper,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> the algorithm is presented more formally using a <a href="Unification_(computer_science)#Substitution" title="wikilink">substitution</a> style instead of side effects in the method above. In the latter form, the side effect invisibly takes care of all places where a type variable is used. Explicitly using substitutions not only makes the algorithm hard to read, because the side effect occurs virtually everywhere, but also gives the false impression that the method might be costly. When implemented using purely functional means or for the purpose of proving the algorithm to be basically equivalent to the deduction system, full explicitness is of course needed and the original formulation a necessary refinement.</p>
<h2 id="further-topics">Further topics</h2>
<h3 id="recursive-definitions">Recursive definitions</h3>

<p>A central property of the lambda calculus is, that recursive definitions are non-elemental, but can instead be expressed by a <a href="fixed_point_combinator" title="wikilink">fixed point combinator</a>. The original paper<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> notes that recursion can realized by this combinator's type 

<math display="inline" id="Hindley–Milner_type_system:183">
 <semantics>
  <mrow>
   <mi>𝑓𝑖𝑥</mi>
   <mo>:</mo>
   <mo>∀</mo>
   <mi>α</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo>→</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">fix</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">α</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">α</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">α</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">α</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{fix}:\forall\alpha.(\alpha\rightarrow\alpha)\rightarrow\alpha
  </annotation>
 </semantics>
</math>

. A possible recursive definitions could thus be formulated as 

<math display="inline" id="Hindley–Milner_type_system:184">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>𝚛𝚎𝚌</mi>
   </mpadded>
   <mi>v</mi>
   <mo>=</mo>
   <mpadded width="+5pt">
    <msub>
     <mi>e</mi>
     <mn>1</mn>
    </msub>
   </mpadded>
   <mpadded width="+5pt">
    <mi>𝚒𝚗</mi>
   </mpadded>
   <mpadded width="+5pt">
    <msub>
     <mi>e</mi>
     <mn>2</mn>
    </msub>
   </mpadded>
   <mo>:</mo>
   <mo>:=</mo>
   <mpadded width="+5pt">
    <mi>𝚕𝚎𝚝</mi>
   </mpadded>
   <mi>v</mi>
   <mo>=</mo>
   <mi>𝑓𝑖𝑥</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>v</mi>
    <mo>.</mo>
    <msub>
     <mi>e</mi>
     <mn>1</mn>
    </msub>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mpadded width="+5pt">
    <mi>𝚒𝚗</mi>
   </mpadded>
   <msub>
    <mi>e</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">rec</csymbol>
    <csymbol cd="unknown">v</csymbol>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">1</cn>
    </apply>
    <csymbol cd="unknown">in</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-:</ci>
    <csymbol cd="latexml">assign</csymbol>
    <csymbol cd="unknown">let</csymbol>
    <csymbol cd="unknown">v</csymbol>
    <eq></eq>
    <csymbol cd="unknown">fix</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-.</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">in</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">2</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathtt{rec}\ v=e_{1}\ \mathtt{in}\ e_{2}\ ::=\mathtt{let}\ v=\mathit{fix}(%
\lambda v.e_{1})\ \mathtt{in}\ e_{2}
  </annotation>
 </semantics>
</math>

.</p>

<p>Alternatively an extension of the expression syntax and an extra typing rule is possible as:</p>

<p>

<math display="block" id="Hindley–Milner_type_system:185">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>,</mo>
      <msup>
       <mi mathvariant="normal">Γ</mi>
       <mo>′</mo>
      </msup>
     </mrow>
     <mo>⊢</mo>
     <msub>
      <mi>e</mi>
      <mn>1</mn>
     </msub>
     <mo>:</mo>
     <mrow>
      <msub>
       <mi>τ</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <mi mathvariant="normal">Γ</mi>
      <mo>,</mo>
      <msup>
       <mi mathvariant="normal">Γ</mi>
       <mo>′</mo>
      </msup>
     </mrow>
     <mo>⊢</mo>
     <msub>
      <mi>e</mi>
      <mi>n</mi>
     </msub>
     <mo>:</mo>
     <mrow>
      <msub>
       <mi>τ</mi>
       <mi>n</mi>
      </msub>
      <mi mathvariant="normal">Γ</mi>
      <mo>,</mo>
      <msup>
       <mi mathvariant="normal">Γ</mi>
       <mi>′′</mi>
      </msup>
     </mrow>
     <mo>⊢</mo>
     <mi>e</mi>
     <mo>:</mo>
     <mi>τ</mi>
    </mrow>
    <mrow>
     <mpadded width="+5pt">
      <mi mathvariant="normal">Γ</mi>
     </mpadded>
     <mo rspace="7.5pt">⊢</mo>
     <mrow>
      <mrow>
       <mpadded width="+5pt">
        <mi>𝚛𝚎𝚌</mi>
       </mpadded>
       <msub>
        <mi>v</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo>=</mo>
      <mrow>
       <mpadded width="+5pt">
        <msub>
         <mi>e</mi>
         <mn>1</mn>
        </msub>
       </mpadded>
       <mpadded width="+5pt">
        <mi>𝚊𝚗𝚍</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi mathvariant="normal">…</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>𝚊𝚗𝚍</mi>
       </mpadded>
       <msub>
        <mi>v</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo>=</mo>
      <mrow>
       <mpadded width="+5pt">
        <msub>
         <mi>e</mi>
         <mi>n</mi>
        </msub>
       </mpadded>
       <mpadded width="+5pt">
        <mi>𝚒𝚗</mi>
       </mpadded>
       <mi>e</mi>
      </mrow>
     </mrow>
     <mo>:</mo>
     <mi>τ</mi>
    </mrow>
   </mfrac>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>𝚁𝚎𝚌</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <divide></divide>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="latexml">proves</csymbol>
       <list>
        <ci>normal-Γ</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-Γ</ci>
         <ci>normal-′</ci>
        </apply>
       </list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <ci>normal-:</ci>
       <share href="#.cmml">
       </share>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>τ</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <ci>normal-Γ</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-Γ</ci>
         <ci>normal-′</ci>
        </apply>
       </list>
      </apply>
      <apply>
       <csymbol cd="latexml">proves</csymbol>
       <share href="#.cmml">
       </share>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <ci>normal-:</ci>
       <share href="#.cmml">
       </share>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>τ</ci>
         <ci>n</ci>
        </apply>
        <ci>normal-Γ</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-Γ</ci>
         <ci>′′</ci>
        </apply>
       </list>
      </apply>
      <apply>
       <csymbol cd="latexml">proves</csymbol>
       <share href="#.cmml">
       </share>
       <ci>e</ci>
      </apply>
      <apply>
       <ci>normal-:</ci>
       <share href="#.cmml">
       </share>
       <ci>τ</ci>
      </apply>
     </apply>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="latexml">proves</csymbol>
       <ci>normal-Γ</ci>
       <apply>
        <and></and>
        <apply>
         <eq></eq>
         <apply>
          <times></times>
          <ci>𝚛𝚎𝚌</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>v</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>e</ci>
           <cn type="integer">1</cn>
          </apply>
          <ci>𝚊𝚗𝚍</ci>
          <ci>normal-…</ci>
          <ci>𝚊𝚗𝚍</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>v</ci>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <eq></eq>
         <share href="#.cmml">
         </share>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>e</ci>
           <ci>n</ci>
          </apply>
          <ci>𝚒𝚗</ci>
          <ci>e</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <ci>normal-:</ci>
       <share href="#.cmml">
       </share>
       <ci>τ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>𝚁𝚎𝚌</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\frac{\Gamma,\Gamma^{\prime}\vdash e_{1}:\tau_{1}\quad\dots\quad%
\Gamma,\Gamma^{\prime}\vdash e_{n}:\tau_{n}\quad\Gamma,\Gamma^{\prime\prime}%
\vdash e:\tau}{\Gamma\ \vdash\ \mathtt{rec}\ v_{1}=e_{1}\ \mathtt{and}\ \dots%
\ \mathtt{and}\ v_{n}=e_{n}\ \mathtt{in}\ e:\tau}\quad[\mathtt{Rec}]
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>
<ul>
<li>

<math display="inline" id="Hindley–Milner_type_system:186">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi mathvariant="normal">Γ</mi>
     <mo>′</mo>
    </msup>
    <mo>=</mo>
    <msub>
     <mi>v</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>τ</mi>
     <mn>1</mn>
    </msub>
    <mo rspace="7.5pt">,</mo>
    <mi mathvariant="normal">…</mi>
    <mo rspace="7.5pt">,</mo>
    <msub>
     <mi>v</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>:</mo>
   <msub>
    <mi>τ</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Γ</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>τ</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>n</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma^{\prime}=v_{1}:\tau_{1},\ \dots,\ v_{n}:\tau_{n}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Hindley–Milner_type_system:187">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi mathvariant="normal">Γ</mi>
     <mi>′′</mi>
    </msup>
    <mo>=</mo>
    <msub>
     <mi>v</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi mathvariant="normal">Γ</mi>
      <mo stretchy="false">¯</mo>
     </mover>
     <mrow>
      <mo rspace="7.5pt" stretchy="false">(</mo>
      <mpadded width="+5pt">
       <msub>
        <mi>τ</mi>
        <mn>1</mn>
       </msub>
      </mpadded>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo rspace="7.5pt">,</mo>
    <mi mathvariant="normal">…</mi>
    <mo rspace="7.5pt">,</mo>
    <msub>
     <mi>v</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mover accent="true">
     <mi mathvariant="normal">Γ</mi>
     <mo stretchy="false">¯</mo>
    </mover>
    <mrow>
     <mo rspace="7.5pt" stretchy="false">(</mo>
     <mpadded width="+5pt">
      <msub>
       <mi>τ</mi>
       <mi>n</mi>
      </msub>
     </mpadded>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Γ</ci>
       <ci>′′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <list>
      <apply>
       <times></times>
       <apply>
        <ci>normal-¯</ci>
        <ci>normal-Γ</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>τ</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>n</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <ci>normal-¯</ci>
       <ci>normal-Γ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>τ</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma^{\prime\prime}=v_{1}:\bar{\Gamma}(\ \tau_{1}\ ),\ \dots,\ v_{n}:\bar{%
\Gamma}(\ \tau_{n}\ )
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>basically merging 

<math display="inline" id="Hindley–Milner_type_system:188">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝙰𝚋𝚜</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝙰𝚋𝚜</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Abs}]
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hindley–Milner_type_system:189">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>𝙻𝚎𝚝</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>𝙻𝚎𝚝</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\mathtt{Let}]
  </annotation>
 </semantics>
</math>

 while including the recursively defined variables in monotype positions where they occur left to the 

<math display="inline" id="Hindley–Milner_type_system:190">
 <semantics>
  <mi>𝚒𝚗</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚒𝚗</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathtt{in}
  </annotation>
 </semantics>
</math>

 but as polytypes right to it. This formulation perhaps best summarizes the essence of <a href="#Let-polymorphism" title="wikilink">let-polymorphism</a>.</p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://catamorph.de/documents/AlgorithmW.pdf">A literate Haskell implementation of Algorithm W</a> along with its <a href="https://github.com/wh5a/Algorithm-W-Step-By-Step">source code on GitHub</a>.</li>
</ul>

<p>"</p>

<p><a href="Category:Type_systems" title="wikilink">Category:Type systems</a> <a href="Category:Type_theory" title="wikilink">Category:Type theory</a> <a href="Category:Type_inference" title="wikilink">Category:Type inference</a> <a href="Category:Lambda_calculus" title="wikilink">Hindley-Milner type system</a> <a href="Category:Theoretical_computer_science" title="wikilink">Category:Theoretical computer science</a> <a href="Category:Formal_methods" title="wikilink">Category:Formal methods</a> <a href="Category:1969_in_computer_science" title="wikilink">Category:1969 in computer science</a> <a href="Category:1978_in_computer_science" title="wikilink">Category:1978 in computer science</a> <a href="Category:1985_in_computer_science" title="wikilink">Category:1985 in computer science</a> <a class="uri" href="Category:Algorithms" title="wikilink">Category:Algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">Hindley–Milner is <a class="uri" href="DEXPTIME" title="wikilink">DEXPTIME</a>-complete. However, non-linear behaviour only manifests itself on pathological inputs, as such the complexity theoretic proofs by  and  came as a surprise to the research community. When the depth of nested let-bindings is bounded—as is the case in realistic programs—Hindley–Milner type inference becomes polynomial.<a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6">Polytypes are called "type schemes" in the original article.<a href="#fnref6">↩</a></li>
<li id="fn7">The parametric types 

<math display="inline" id="Hindley–Milner_type_system:191">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>D</mi>
   </mpadded>
   <mi>τ</mi>
   <mi mathvariant="normal">…</mi>
   <mi>τ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>τ</ci>
    <ci>normal-…</ci>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D\ \tau\dots\tau
  </annotation>
 </semantics>
</math>

 were not present in the original paper on HM and are not needed to present the method. None of the inference rules below will take care or even note them. The same holds for the non-parametric "primitive types" in said paper. All the machinery for polymorphic type inference can be defined without them. They have been included here for sake of examples but also because the nature of HM is all about parametric types. This comes from the function type 

<math display="inline" id="Hindley–Milner_type_system:192">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mo>→</mo>
   <mi>τ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>τ</ci>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau\rightarrow\tau
  </annotation>
 </semantics>
</math>

, hard-wired in the inference rules, below, which already has two parameters and has been presented here as only a special case.<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
</ol>
</section>
</ref></hr></body>
</html>
