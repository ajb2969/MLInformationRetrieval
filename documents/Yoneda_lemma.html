<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1118">Yoneda lemma</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Yoneda lemma</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, specifically in <a href="category_theory" title="wikilink">category theory</a>, the <strong>Yoneda lemma</strong> is an abstract result on <a href="functor" title="wikilink">functors</a> of the type <em>morphisms into a fixed object</em>. It is a vast generalisation of <a href="Cayley's_theorem" title="wikilink">Cayley's theorem</a> from <a href="group_theory" title="wikilink">group theory</a> (viewing a group as a particular kind of category with just one object). It allows the <a href="Subcategory#Embeddings" title="wikilink">embedding</a> of any category into a <a href="category_of_functors" title="wikilink">category of functors</a> (contravariant set-valued functors) defined on that category. It also clarifies how the embedded category, of <a href="representable_functor" title="wikilink">representable functors</a> and their <a href="natural_transformation" title="wikilink">natural transformations</a>, relates to the other objects in the larger functor category. It is an important tool that underlies several modern developments in <a href="algebraic_geometry" title="wikilink">algebraic geometry</a> and <a href="representation_theory" title="wikilink">representation theory</a>. It is named after <a href="Nobuo_Yoneda" title="wikilink">Nobuo Yoneda</a>.</p>
<h2 id="generalities">Generalities</h2>

<p>The Yoneda lemma suggests that instead of studying the (<a href="locally_small" title="wikilink">locally small</a>) category <em>C</em>, one should study the category of all functors of <em>C</em> into <strong>Set</strong> (the <a href="category_of_sets" title="wikilink">category of sets</a> with <a href="function_(mathematics)" title="wikilink">functions</a> as <a href="morphism" title="wikilink">morphisms</a>). <strong>Set</strong> is a category we think we understand well, and a functor of <em>C</em> into <strong>Set</strong> can be seen as a "representation" of <em>C</em> in terms of known structures. The original category <em>C</em> is contained in this functor category, but new objects appear in the functor category, which were absent and "hidden" in <em>C</em>. Treating these new objects just like the old ones often unifies and simplifies the theory.</p>

<p>This approach is akin to (and in fact generalizes) the common method of studying a <a href="ring_(mathematics)" title="wikilink">ring</a> by investigating the <a href="module_(mathematics)" title="wikilink">modules</a> over that ring. The ring takes the place of the category <em>C</em>, and the category of modules over the ring is a category of functors defined on <em>C</em>.</p>
<h2 id="formal-statement">Formal statement</h2>
<h3 id="general-version">General version</h3>

<p>Yoneda's lemma concerns functors from a fixed category <em>C</em> to the <a href="category_of_sets" title="wikilink">category of sets</a>, <strong>Set</strong>. If <em>C</em> is a <a href="locally_small_category" title="wikilink">locally small category</a> (i.e. the <a href="hom-set" title="wikilink">hom-sets</a> are actual sets and not proper classes), then each object <em>A</em> of <em>C</em> gives rise to a natural functor to <strong>Set</strong> called a <a class="uri" href="hom-functor" title="wikilink">hom-functor</a>. This functor is denoted:</p>

<p>

<math display="block" id="Yoneda_lemma:0">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>h</mi>
     <mi>A</mi>
    </msup>
    <mo>=</mo>
    <mrow>
     <mi>Hom</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo>,</mo>
      <mo>-</mo>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>h</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <ci>Hom</ci>
     <interval closure="open">
      <ci>A</ci>
      <minus></minus>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h^{A}=\mathrm{Hom}(A,-).
  </annotation>
 </semantics>
</math>

 The (<a href="Covariance_and_contravariance_of_functors" title="wikilink">covariant</a>) hom-functor <em>h</em><sup><em>A</em></sup> sends <em>X</em> to the set of <a href="morphism" title="wikilink">morphisms</a> Hom(<em>A</em>,<em>X</em>) and sends a morphism <em>f</em> from <em>X</em> to <em>Y</em> to the morphism 

<math display="inline" id="Yoneda_lemma:1">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>∘</mo>
   <mo>-</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <compose></compose>
    <minus></minus>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\circ-
  </annotation>
 </semantics>
</math>

 (composition with <em>f</em> on the left) that sends a morphism <em>g</em> in Hom(<em>A</em>,<em>X</em>) to the morphism <em>f</em> o <em>g</em> in Hom(<em>A</em>,<em>Y</em>). That is,</p>

<p>

<math display="block" id="Yoneda_lemma:2">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>⟼</mo>
   <mi>Hom</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo rspace="0.8pt" stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>Hom</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo>,</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∋</mo>
     <mi>g</mi>
     <mo>↦</mo>
     <mi>f</mi>
     <mo>∘</mo>
     <mi>g</mi>
     <mo>∈</mo>
     <mi>Hom</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo>,</mo>
      <mi>Y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="0.8pt" stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-⟼</ci>
    <csymbol cd="unknown">Hom</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">Hom</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">X</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="latexml">contains</csymbol>
      <csymbol cd="unknown">g</csymbol>
      <csymbol cd="latexml">maps-to</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <compose></compose>
      <csymbol cd="unknown">g</csymbol>
      <in></in>
      <csymbol cd="unknown">Hom</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">Y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\longmapsto\mathrm{Hom}(A,f)=[\![\mathrm{Hom}(A,X)\ni g\mapsto f\circ g\in%
\mathrm{Hom}(A,Y)]\!]
  </annotation>
 </semantics>
</math>

.</p>

<p>Let <em>F</em> be an arbitrary functor from <em>C</em> to <strong>Set</strong>. Then Yoneda's lemma says that:</p>

<p>For each object <em>A</em> of <em>C</em>, the <a href="natural_transformation" title="wikilink">natural transformations</a> from <em>h</em><sup><em>A</em></sup> to <em>F</em> are in one-to-one correspondence with the elements of <em>F</em>(<em>A</em>). That is,</p>

<p>

<math display="block" id="Yoneda_lemma:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Nat</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>h</mi>
       <mi>A</mi>
      </msup>
      <mo>,</mo>
      <mi>F</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≅</mo>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>Nat</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <ci>A</ci>
      </apply>
      <ci>F</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Nat}(h^{A},F)\cong F(A).
  </annotation>
 </semantics>
</math>

</p>

<p>Moreover this isomorphism is natural in <em>A</em> and <em>F</em> when both sides are regarded as functors from <strong>Set</strong><sup><em>C</em></sup> x C to <strong>Set</strong>. (Here the notation <strong>Set</strong><sup><em>C</em></sup> denotes the category of functors from <em>C</em> to <strong>Set</strong>.)</p>

<p>Given a natural transformation Φ from <em>h</em><sup><em>A</em></sup> to <em>F</em>, the corresponding element of <em>F</em>(<em>A</em>) is 

<math display="inline" id="Yoneda_lemma:4">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi mathvariant="normal">Φ</mi>
     <mi>A</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>id</mi>
      <mi>A</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>u</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Φ</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>id</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u=\Phi_{A}(\mathrm{id}_{A})
  </annotation>
 </semantics>
</math>

.</p>

<p>There is a contravariant version of Yoneda's lemma, which concerns <a href="contravariant_functor" title="wikilink">contravariant functors</a> from <em>C</em> to <strong>Set</strong>. This version involves the contravariant hom-functor</p>

<p>

<math display="block" id="Yoneda_lemma:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mi>A</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>Hom</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>-</mo>
      <mo>,</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <ci>Hom</ci>
     <interval closure="open">
      <minus></minus>
      <ci>A</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{A}=\mathrm{Hom}(-,A),
  </annotation>
 </semantics>
</math>

 which sends <em>X</em> to the hom-set Hom(<em>X</em>,<em>A</em>). Given an arbitrary contravariant functor <em>G</em> from <em>C</em> to <strong>Set</strong>, Yoneda's lemma asserts that</p>

<p>

<math display="block" id="Yoneda_lemma:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Nat</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>h</mi>
       <mi>A</mi>
      </msub>
      <mo>,</mo>
      <mi>G</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≅</mo>
    <mrow>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>Nat</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>A</ci>
      </apply>
      <ci>G</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Nat}(h_{A},G)\cong G(A).
  </annotation>
 </semantics>
</math>

</p>
<h3 id="naming-conventions">Naming conventions</h3>

<p>The use of "<em>h</em><sup><em>A</em></sup>" for the covariant hom-functor and "<em>h</em><sub><em>A</em></sub>" for the contravariant hom-functor is not completely standard. Many texts and articles either use the opposite convention or completely unrelated symbols for these two functors. However, most modern algebraic geometry texts starting with <a href="Alexander_Grothendieck" title="wikilink">Alexander Grothendieck's</a> foundational <a href="Éléments_de_géométrie_algébrique" title="wikilink">EGA</a> use the convention in this article.<mtpl></mtpl></p>

<p>The mnemonic "falling into something" can be helpful in remembering that "<em>h</em><sub><em>A</em></sub>" is the contravariant hom-functor. When the letter "<em>A</em>" is <strong>falling</strong> (i.e. a subscript), <em>h</em><sub><em>A</em></sub> assigns to an object <em>X</em> the morphisms from <em>X</em> <strong>into</strong> <em>A</em>.</p>
<h3 id="proof">Proof</h3>

<p>The proof of Yoneda's lemma is indicated by the following <a href="commutative_diagram" title="wikilink">commutative diagram</a>:</p>
<figure><b>(Figure)</b>
<figcaption>Proof of Yoneda's lemma</figcaption>
</figure>

<p>This diagram shows that the natural transformation Φ is completely determined by 

<math display="inline" id="Yoneda_lemma:7">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Φ</mi>
     <mi>A</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>id</mi>
      <mi>A</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>u</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Φ</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>id</ci>
      <ci>A</ci>
     </apply>
    </apply>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi_{A}(\mathrm{id}_{A})=u
  </annotation>
 </semantics>
</math>

 since for each morphism <em>f</em> : <em>A</em> → <em>X</em> one has</p>

<p>

<math display="block" id="Yoneda_lemma:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi mathvariant="normal">Φ</mi>
      <mi>X</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>F</mi>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>u</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Φ</ci>
      <ci>X</ci>
     </apply>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>f</ci>
     </apply>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi_{X}(f)=(Ff)u.\,
  </annotation>
 </semantics>
</math>

 Moreover, any element <em>u</em>∈<em>F</em>(<em>A</em>) defines a natural transformation in this way. The proof in the contravariant case is completely analogous.</p>

<p>In this way, Yoneda's Lemma provides a complete classification of all natural transformations from the functor Hom(A,-) to an arbitrary functor F:C→Set.</p>
<h3 id="the-yoneda-embedding">The Yoneda embedding</h3>

<p>An important special case of Yoneda's lemma is when the functor <em>F</em> from <em>C</em> to <strong>Set</strong> is another hom-functor <em>h</em><sup><em>B</em></sup>. In this case, the covariant version of Yoneda's lemma states that</p>

<p>

<math display="block" id="Yoneda_lemma:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Nat</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>h</mi>
       <mi>A</mi>
      </msup>
      <mo>,</mo>
      <msup>
       <mi>h</mi>
       <mi>B</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≅</mo>
    <mrow>
     <mi>Hom</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo>,</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>Nat</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <ci>A</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <ci>B</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>Hom</ci>
     <interval closure="open">
      <ci>B</ci>
      <ci>A</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Nat}(h^{A},h^{B})\cong\mathrm{Hom}(B,A).
  </annotation>
 </semantics>
</math>

</p>

<p>That is, natural transformations between hom-functors are in one-to-one correspondence with morphisms (in the reverse direction) between the associated objects. Given a morphism <em>f</em> : <em>B</em> → <em>A</em> the associated natural transformation is denoted Hom(<em>f</em>,–).</p>

<p>Mapping each object <em>A</em> in <em>C</em> to its associated hom-functor <em>h</em><sup><em>A</em></sup> = Hom(<em>A</em>,–) and each morphism <em>f</em> : <em>B</em> → <em>A</em> to the corresponding natural transformation Hom(<em>f</em>,–) determines a contravariant functor <em>h</em><sup>–</sup> from <em>C</em> to <strong>Set</strong><sup><em>C</em></sup>, the <a href="functor_category" title="wikilink">functor category</a> of all (covariant) functors from <em>C</em> to <strong>Set</strong>. One can interpret <em>h</em><sup>–</sup> as a <a href="covariant_functor" title="wikilink">covariant functor</a>:</p>

<p>

<math display="block" id="Yoneda_lemma:10">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>h</mi>
     <mo>-</mo>
    </msup>
    <mo>:</mo>
    <mrow>
     <msup>
      <mi class="ltx_font_mathcaligraphic">𝒞</mi>
      <mtext>op</mtext>
     </msup>
     <mo>→</mo>
     <msup>
      <mi>𝐒𝐞𝐭</mi>
      <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>h</ci>
     <minus></minus>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝒞</ci>
      <mtext>op</mtext>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐒𝐞𝐭</ci>
      <ci>𝒞</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h^{-}\colon\mathcal{C}^{\text{op}}\to\mathbf{Set}^{\mathcal{C}}.
  </annotation>
 </semantics>
</math>

 The meaning of Yoneda's lemma in this setting is that the functor <em>h</em><sup>–</sup> is <a href="full_and_faithful_functors" title="wikilink">fully faithful</a>, and therefore gives an embedding of <em>C</em><sup>op</sup> in the category of functors to <strong>Set</strong>. The collection of all functors {<em>h</em><sup>A</sup>, A in C} is a subcategory of <strong>Set</strong><sup><em>C</em></sup>. Therefore, Yoneda embedding implies that the category <strong>C</strong><sup><em>op</em></sup> is isomorphic to the category {<em>h</em><sup>A</sup>, A in C}.</p>

<p>The contravariant version of Yoneda's lemma states that</p>

<p>

<math display="block" id="Yoneda_lemma:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Nat</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>h</mi>
       <mi>A</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>h</mi>
       <mi>B</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≅</mo>
    <mrow>
     <mi>Hom</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo>,</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>Nat</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>A</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>B</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>Hom</ci>
     <interval closure="open">
      <ci>A</ci>
      <ci>B</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Nat}(h_{A},h_{B})\cong\mathrm{Hom}(A,B).
  </annotation>
 </semantics>
</math>

 Therefore, <em>h</em><sub>–</sub> gives rise to a covariant functor from <em>C</em> to the category of contravariant functors to <strong>Set</strong>:</p>

<p>

<math display="block" id="Yoneda_lemma:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mo>-</mo>
    </msub>
    <mo>:</mo>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     <mo>→</mo>
     <msup>
      <mi>𝐒𝐞𝐭</mi>
      <msup>
       <mi class="ltx_font_mathcaligraphic">𝒞</mi>
       <mi>op</mi>
      </msup>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <minus></minus>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>𝒞</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐒𝐞𝐭</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝒞</ci>
       <ci>op</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{-}\colon\mathcal{C}\to\mathbf{Set}^{\mathcal{C}^{\mathrm{op}}}.
  </annotation>
 </semantics>
</math>

 Yoneda's lemma then states that any locally small category <em>C</em> can be embedded in the category of contravariant functors from <em>C</em> to <strong>Set</strong> via <em>h</em><sub>–</sub>. This is called the <em>Yoneda embedding</em>.</p>
<h2 id="preadditive-categories-rings-and-modules">Preadditive categories, rings and modules</h2>

<p>A <em><a href="preadditive_category" title="wikilink">preadditive category</a></em> is a category where the morphism sets form <a href="abelian_group" title="wikilink">abelian groups</a> and the composition of morphisms is <a href="bilinear_operator" title="wikilink">bilinear</a>; examples are categories of abelian groups or modules. In a preadditive category, there is both a "multiplication" and an "addition" of morphisms, which is why preadditive categories are viewed as generalizations of <a href="ring_(mathematics)" title="wikilink">rings</a>. Rings are preadditive categories with one object.</p>

<p>The Yoneda lemma remains true for preadditive categories if we choose as our extension the category of <em><a href="additive_functor" title="wikilink">additive</a></em> contravariant functors from the original category into the category of abelian groups; these are functors which are compatible with the addition of morphisms and should be thought of as forming a <em><a href="module_category" title="wikilink">module category</a></em> over the original category. The Yoneda lemma then yields the natural procedure to enlarge a preadditive category so that the enlarged version remains preadditive — in fact, the enlarged version is an <a href="abelian_category" title="wikilink">abelian category</a>, a much more powerful condition. In the case of a ring <em>R</em>, the extended category is the category of all right <a href="module_(mathematics)" title="wikilink">modules</a> over <em>R</em>, and the statement of the Yoneda lemma reduces to the well-known isomorphism</p>
<dl>
<dd><em>M</em> ≅ Hom<sub><em>R</em></sub>(<em>R</em>,<em>M</em>)   for all right modules <em>M</em> over <em>R</em>.
</dd>
</dl>
<h2 id="history">History</h2>

<p>The Yoneda lemma was introduced but not proved in a 1954 paper by Nobuo Yoneda.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Yoshiki Kinoshita stated in 1996 that the term "Yoneda lemma" was coined by <a href="Saunders_Mac_Lane" title="wikilink">Saunders Mac Lane</a> following an interview he had with Yoneda.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Representation_theorem" title="wikilink">Representation theorem</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li></li>
</ul>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Representable_functors" title="wikilink">Category:Representable functors</a> <a class="uri" href="Category:Lemmas" title="wikilink">Category:Lemmas</a> <a href="Category:Articles_containing_proofs" title="wikilink">Category:Articles containing proofs</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"> <a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
