   Reaching definition      Reaching definition   In compiler theory , a reaching definition for a given instruction is an earlier instruction whose target variable can reach the given one without an intervening assignment. For example, in the following code:  d1 : y := 3  d2 : x := y  d1 is a reaching definition for d2 . In the following, example, however:  d1 : y := 3  d2 : y := 4  d3 : x := y  d1 is no longer a reaching definition for d3 , because d2 kills its reach.  As analysis  The similarly named reaching definitions is a data-flow analysis which statically determines which definitions may reach a given point in the code. Because of its simplicity, it is often used as the canonical example of a data-flow analysis in textbooks. The data-flow confluence operator used is set union, and the analysis is forward flow. Reaching definitions are used to compute use-def chains and def-use chains .  The data-flow equations used for a given basic block   S   S   S   in reaching definitions are:         REACH  in    [  S  ]    =    ⋃   p  ∈   p  r  e  d   [  S  ]        REACH  out    [  p  ]            subscript  REACH  in    delimited-[]  S      subscript     p    p  r  e  d   delimited-[]  S         subscript  REACH  out    delimited-[]  p       {\rm REACH}_{\rm in}[S]=\bigcup_{p\in pred[S]}{\rm REACH}_{\rm out}[p]           REACH  out    [  S  ]    =    GEN   [  S  ]    ∪   (     REACH  in    [  S  ]    -   KILL   [  S  ]     )           subscript  REACH  out    delimited-[]  S        GEN   delimited-[]  S         subscript  REACH  in    delimited-[]  S      KILL   delimited-[]  S        {\rm REACH}_{\rm out}[S]={\rm GEN}[S]\cup({\rm REACH}_{\rm in}[S]-{\rm KILL}[S])      In other words, the set of reaching definitions going into   S   S   S   are all of the reaching definitions from   S   S   S   's predecessors,    p  r  e  d   [  S  ]       p  r  e  d   delimited-[]  S     pred[S]   .    p  r  e  d   [  S  ]       p  r  e  d   delimited-[]  S     pred[S]   consists of all of the basic blocks that come before   S   S   S   in the control flow graph . The reaching definitions coming out of   S   S   S   are all reaching definitions of its predecessors minus those reaching definitions whose variable is killed by   S   S   S   plus any new definitions generated within   S   S   S   .  For a generic instruction, we define the   GEN   GEN   {\rm GEN}   and   KILL   KILL   {\rm KILL}   sets as follows:       GEN   [  d  :  y  ←  f   (   x  1   ,  ⋯  ,   x  n   )   ]   =   {  d  }      fragments  GEN   fragments  normal-[  d  normal-:  y  normal-←  f   fragments  normal-(   subscript  x  1   normal-,  normal-⋯  normal-,   subscript  x  n   normal-)   normal-]     fragments  normal-{  d  normal-}     {\rm GEN}[d:y\leftarrow f(x_{1},\cdots,x_{n})]=\{d\}         KILL   [  d  :  y  ←  f   (   x  1   ,  ⋯  ,   x  n   )   ]   =  DEFS   [  y  ]   -   {  d  }      fragments  KILL   fragments  normal-[  d  normal-:  y  normal-←  f   fragments  normal-(   subscript  x  1   normal-,  normal-⋯  normal-,   subscript  x  n   normal-)   normal-]    DEFS   fragments  normal-[  y  normal-]     fragments  normal-{  d  normal-}     {\rm KILL}[d:y\leftarrow f(x_{1},\cdots,x_{n})]={\rm DEFS}[y]-\{d\}      where    DEFS   [  y  ]       DEFS   delimited-[]  y     {\rm DEFS}[y]   is the set of all definitions that assign to the variable   y   y   y   . Here   d   d   d   is a unique label attached to the assigning instruction; thus, the domain of values in reaching definitions are these instruction labels.  Further reading         See also   Static single assignment form   "  Category:Program analysis  Category:Data-flow analysis   