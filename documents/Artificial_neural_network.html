<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="711">Artificial neural network</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Artificial neural network</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>An artificial neural network is an interconnected group of nodes, akin to the vast network of <a href="neuron" title="wikilink">neurons</a> in a <a class="uri" href="brain" title="wikilink">brain</a>. Here, each circular node represents an artificial neuron and an arrow represents a connection from the output of one neuron to the input of another.</figcaption>
</figure>

<p>In <a href="machine_learning" title="wikilink">machine learning</a> and <a href="cognitive_science" title="wikilink">cognitive science</a>, <strong>artificial neural networks</strong> (<strong>ANNs</strong>) are a family of statistical learning models inspired by <a href="biological_neural_network" title="wikilink">biological neural networks</a> (the <a href="central_nervous_system" title="wikilink">central nervous systems</a> of animals, in particular the <a class="uri" href="brain" title="wikilink">brain</a>) and are used to estimate or <a href="Universal_approximation_theorem" title="wikilink">approximate</a> <a href="Function_(mathematics)" title="wikilink">functions</a> that can depend on a large number of <a href="Argument_of_a_function" title="wikilink">inputs</a> and are generally unknown. Artificial neural networks are generally presented as systems of interconnected "<a href="artificial_neuron" title="wikilink">neurons</a>" which send messages to each other. The connections have numeric weights that can be tuned based on experience, making neural nets adaptive to inputs and capable of learning.</p>

<p>For example, a neural network for <a href="handwriting_recognition" title="wikilink">handwriting recognition</a> is defined by a set of input neurons which may be activated by the pixels of an input image. After being weighted and transformed by a <a href="Function_(mathematics)" title="wikilink">function</a> (determined by the network's designer), the activations of these neurons are then passed on to other neurons. This process is repeated until finally, an output neuron is activated. This determines which character was read.</p>

<p>Like other machine learning methods - systems that learn from data - neural networks have been used to solve a wide variety of tasks that are hard to solve using ordinary <a href="rule-based_programming" title="wikilink">rule-based programming</a>, including <a href="computer_vision" title="wikilink">computer vision</a> and <a href="speech_recognition" title="wikilink">speech recognition</a>.</p>
<h2 id="background">Background</h2>

<p>Examinations of humans' <a href="central_nervous_system" title="wikilink">central nervous systems</a> inspired the concept of artificial neural networks. In an artificial neural network, simple artificial <a href="Node_(neural_networks)" title="wikilink">nodes</a>, known as "<a href="artificial_neuron" title="wikilink">neurons</a>", "neurodes", "processing elements" or "units", are connected together to form a network which mimics a biological neural network.</p>

<p>There is no single formal definition of what an artificial neural network is. However, a class of statistical models may commonly be called "Neural" if it possesses the following characteristics:</p>
<ol>
<li>contains sets of <a href="adaptive_systems" title="wikilink">adaptive</a> weights, i.e. numerical parameters that are tuned by a learning <a class="uri" href="algorithm" title="wikilink">algorithm</a>, and</li>
<li>capability of <a href="approximation_theory" title="wikilink">approximating</a> non-linear functions of their inputs.</li>
</ol>

<p>The adaptive weights can be thought of as connection strengths between neurons, which are activated during training and prediction.</p>

<p>Neural networks are similar to biological neural networks in the performing of functions collectively and in parallel by the units, rather than there being a clear delineation of subtasks to which individual units are assigned. The term "neural network" usually refers to models employed in <a class="uri" href="statistics" title="wikilink">statistics</a>, <a href="cognitive_psychology" title="wikilink">cognitive psychology</a> and <a href="artificial_intelligence" title="wikilink">artificial intelligence</a>. Neural network models which emulate the central nervous system are part of <a href="theoretical_neuroscience" title="wikilink">theoretical neuroscience</a> and <a href="computational_neuroscience" title="wikilink">computational neuroscience</a>.</p>

<p>In modern <a href="Neural_network_software" title="wikilink">software implementations</a> of artificial neural networks, the approach inspired by biology has been largely abandoned for a more practical approach based on statistics and signal processing. In some of these systems, neural networks or parts of neural networks (like artificial neurons) form components in larger systems that combine both adaptive and non-adaptive elements. While the more general approach of such systems is more suitable for real-world problem solving, it has little to do with the traditional, artificial intelligence connectionist models. What they do have in common, however, is the principle of non-linear, distributed, parallel and local processing and adaptation. Historically, the use of neural network models marked a directional shift in the late eighties from high-level (symbolic) AI, characterized by <a href="expert_system" title="wikilink">expert systems</a> with knowledge embodied in <em>if-then</em> rules, to low-level (sub-symbolic) <a href="machine_learning" title="wikilink">machine learning</a>, characterized by knowledge embodied in the parameters of a <a href="Cognitive_Model#Dynamical_systems" title="wikilink">dynamical system</a>.</p>
<h2 id="history">History</h2>

<p><a href="Warren_McCulloch" title="wikilink">Warren McCulloch</a> and <a href="Walter_Pitts" title="wikilink">Walter Pitts</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> (1943) created a computational model for neural networks based on <a class="uri" href="mathematics" title="wikilink">mathematics</a> and algorithms called <a href="threshold_logic" title="wikilink">threshold logic</a>. This model paved the way for neural network research to split into two distinct approaches. One approach focused on biological processes in the brain and the other focused on the application of neural networks to artificial intelligence.</p>

<p>In the late 1940s psychologist <a href="Donald_Hebb" title="wikilink">Donald Hebb</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> created a hypothesis of learning based on the mechanism of neural plasticity that is now known as <a href="Hebbian_learning" title="wikilink">Hebbian learning</a>. Hebbian learning is considered to be a 'typical' <a href="unsupervised_learning" title="wikilink">unsupervised learning</a> rule and its later variants were early models for <a href="long_term_potentiation" title="wikilink">long term potentiation</a>. Researchers started applying these ideas to computational models in 1948 with <a href="unorganized_machine" title="wikilink">Turing's B-type machines</a>.</p>

<p>Farley and <a href="Wesley_A._Clark" title="wikilink">Wesley A. Clark</a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> (1954) first used computational machines, then called "calculators," to simulate a Hebbian network at MIT. Other neural network computational machines were created by Rochester, Holland, Habit, and Duda<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> (1956).</p>

<p><a href="Frank_Rosenblatt" title="wikilink">Frank Rosenblatt</a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> (1958) created the <a class="uri" href="perceptron" title="wikilink">perceptron</a>, an algorithm for pattern recognition based on a two-layer computer learning network using simple addition and subtraction. With mathematical notation, Rosenblatt also described circuitry not in the basic perceptron, such as the <a class="uri" href="exclusive-or" title="wikilink">exclusive-or</a> circuit, a circuit whose mathematical computation could not be processed until after the <a class="uri" href="backpropagation" title="wikilink">backpropagation</a> algorithm was created by <a href="Paul_Werbos" title="wikilink">Paul Werbos</a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> (1975).</p>

<p>Neural network research stagnated after the publication of machine learning research by <a href="Marvin_Minsky" title="wikilink">Marvin Minsky</a> and <a href="Seymour_Papert" title="wikilink">Seymour Papert</a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> (1969), who discovered two key issues with the computational machines that processed neural networks. The first was that single-layer neural networks were incapable of processing the exclusive-or circuit. The second significant issue was that computers didn't have enough processing power to effectively handle the long run time required by large neural networks. Neural network research slowed until computers achieved greater processing power. Another key advance that came later was the <a class="uri" href="backpropagation" title="wikilink">backpropagation</a> algorithm which effectively solved the exclusive-or problem (Werbos 1975).<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>The <a href="connectionism" title="wikilink">parallel distributed processing</a> of the mid-1980s became popular under the name <a class="uri" href="connectionism" title="wikilink">connectionism</a>. The textbook by <a href="David_E._Rumelhart" title="wikilink">David E. Rumelhart</a> and <a href="James_McClelland_(psychologist)" title="wikilink">James McClelland</a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> (1986) provided a full exposition of the use of connectionism in computers to simulate neural processes.</p>

<p>Neural networks, as used in artificial intelligence, have traditionally been viewed as simplified models of <a href="neural_processing" title="wikilink">neural processing</a> in the brain, even though the relation between this model and the biological architecture of the brain is debated; it's not clear to what degree artificial neural networks mirror brain function.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p><a href="Support_vector_machine" title="wikilink">Support vector machines</a> and other, much simpler methods such as <a href="linear_classifier" title="wikilink">linear classifiers</a> gradually overtook neural networks in machine learning popularity. But the advent of <a href="deep_learning" title="wikilink">deep learning</a> in the late 2000s sparked renewed interest in neural nets.</p>
<h3 id="improvements-since-2006">Improvements since 2006</h3>

<p>Computational devices have been created in <a class="uri" href="CMOS" title="wikilink">CMOS</a>, for both biophysical simulation and <a href="neuromorphic_computing" title="wikilink">neuromorphic computing</a>. More recent efforts show promise for creating <a href="nanodevice" title="wikilink">nanodevices</a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> for very large scale <a href="principal_component" title="wikilink">principal components</a> analyses and <a class="uri" href="convolution" title="wikilink">convolution</a>. If successful, these efforts could usher in a new era of neural computing<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> that is a step beyond digital computing, because it depends on <a class="uri" href="learning" title="wikilink">learning</a> rather than <a href="programming_language" title="wikilink">programming</a> and because it is fundamentally <a href="Analog_signal" title="wikilink">analog</a> rather than <a href="Digital_data" title="wikilink">digital</a> even though the first instantiations may in fact be with CMOS digital devices.</p>

<p>Between 2009 and 2012, the <a href="recurrent_neural_network" title="wikilink">recurrent neural networks</a> and deep feedforward neural networks developed in the research group of <a href="Jürgen_Schmidhuber" title="wikilink">Jürgen Schmidhuber</a> at the <a href="IDSIA" title="wikilink">Swiss AI Lab IDSIA</a> have won eight international competitions in <a href="pattern_recognition" title="wikilink">pattern recognition</a> and <a href="machine_learning" title="wikilink">machine learning</a>.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> For example, the bi-directional and <a class="uri" href="multi-dimensional" title="wikilink">multi-dimensional</a> <a href="long_short_term_memory" title="wikilink">long short term memory</a> (LSTM)<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> of Alex Graves et al. won three competitions in connected handwriting recognition at the 2009 International Conference on Document Analysis and Recognition (ICDAR), without any prior knowledge about the three different languages to be learned.</p>

<p>Fast <a class="uri" href="GPU" title="wikilink">GPU</a>-based implementations of this approach by Dan Ciresan and colleagues at <a class="uri" href="IDSIA" title="wikilink">IDSIA</a> have won several pattern recognition contests, including the IJCNN 2011 Traffic Sign Recognition Competition,<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> the ISBI 2012 Segmentation of Neuronal Structures in Electron Microscopy Stacks challenge,<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> and others. Their neural networks also were the first artificial pattern recognizers to achieve human-competitive or even superhuman performance<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> on important benchmarks such as traffic sign recognition (IJCNN 2012), or the <a href="MNIST_database" title="wikilink">MNIST handwritten digits problem</a> of <a href="Yann_LeCun" title="wikilink">Yann LeCun</a> at <a class="uri" href="NYU" title="wikilink">NYU</a>.</p>

<p>Deep, highly nonlinear neural architectures similar to the 1980 <a class="uri" href="neocognitron" title="wikilink">neocognitron</a> by <a href="Kunihiko_Fukushima" title="wikilink">Kunihiko Fukushima</a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> and the "standard architecture of vision",<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> inspired by the simple and complex cells identified by <a href="David_H._Hubel" title="wikilink">David H. Hubel</a> and <a href="Torsten_Wiesel" title="wikilink">Torsten Wiesel</a> in the primary <a href="visual_cortex" title="wikilink">visual cortex</a>, can also be pre-trained by unsupervised methods<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a><a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> of <a href="Geoff_Hinton" title="wikilink">Geoff Hinton</a>'s lab at <a href="University_of_Toronto" title="wikilink">University of Toronto</a>.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a><a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> A team from this lab won a 2012 contest sponsored by <a href="Merck_&amp;_Co." title="wikilink">Merck</a> to design software to help find molecules that might lead to new drugs.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>
<h2 id="models">Models</h2>

<p>Neural network models in artificial intelligence are usually referred to as artificial neural networks (ANNs); these are essentially simple mathematical models defining a function 

<math display="inline" id="Artificial_neural_network:0">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mo>→</mo>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle f:X\rightarrow Y
  </annotation>
 </semantics>
</math>

 or a distribution over 

<math display="inline" id="Artificial_neural_network:1">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle X
  </annotation>
 </semantics>
</math>

 or both 

<math display="inline" id="Artificial_neural_network:2">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Artificial_neural_network:3">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle Y
  </annotation>
 </semantics>
</math>

, but sometimes models are also intimately associated with a particular learning algorithm or learning rule. A common use of the phrase "ANN model" is really the definition of a <em>class</em> of such functions (where members of the class are obtained by varying parameters, connection weights, or specifics of the architecture such as the number of neurons or their connectivity).</p>
<h3 id="network-function">Network function</h3>

<p>The word <em>network</em> in the term 'artificial neural network' refers to the inter–connections between the neurons in the different layers of each system. An example system has three layers. The first layer has input neurons which send data via synapses to the second layer of neurons, and then via more synapses to the third layer of output neurons. More complex systems will have more layers of neurons, some having increased layers of input neurons and output neurons. The synapses store parameters called "weights" that manipulate the data in the calculations.</p>

<p>An ANN is typically defined by three types of parameters:</p>
<ol>
<li>The interconnection pattern between the different layers of neurons</li>
<li>The learning process for updating the weights of the interconnections</li>
<li>The activation function that converts a neuron's weighted input to its output activation.</li>
</ol>

<p>Mathematically, a neuron's network function 

<math display="inline" id="Artificial_neural_network:4">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle f(x)
  </annotation>
 </semantics>
</math>

 is defined as a composition of other functions 

<math display="inline" id="Artificial_neural_network:5">
 <semantics>
  <mrow>
   <msub>
    <mi>g</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <ci>i</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle g_{i}(x)
  </annotation>
 </semantics>
</math>

, which can further be defined as a composition of other functions. This can be conveniently represented as a network structure, with arrows depicting the dependencies between variables. A widely used type of composition is the <em>nonlinear weighted sum</em>, where 

<math display="inline" id="Artificial_neural_network:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mi>i</mi>
      </msub>
      <mrow>
       <msub>
        <mi>w</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>g</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>K</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>i</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle f(x)=K\left(\sum_{i}w_{i}g_{i}(x)\right)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Artificial_neural_network:7">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle K
  </annotation>
 </semantics>
</math>

 (commonly referred to as the <a href="activation_function" title="wikilink">activation function</a><a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a>) is some predefined function, such as the <a href="hyperbolic_tangent" title="wikilink">hyperbolic tangent</a>. It will be convenient for the following to refer to a collection of functions 

<math display="inline" id="Artificial_neural_network:8">
 <semantics>
  <msub>
   <mi>g</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle g_{i}
  </annotation>
 </semantics>
</math>

 as simply a vector 

<math display="inline" id="Artificial_neural_network:9">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>g</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>g</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>g</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>g</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle g=(g_{1},g_{2},\ldots,g_{n})
  </annotation>
 </semantics>
</math>

.</p>
<figure><b>(Figure)</b>
<figcaption>ANN dependency graph</figcaption>
</figure>

<p>This figure depicts such a decomposition of 

<math display="inline" id="Artificial_neural_network:10">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle f
  </annotation>
 </semantics>
</math>

, with dependencies between variables indicated by arrows. These can be interpreted in two ways.</p>

<p>The first view is the functional view: the input 

<math display="inline" id="Artificial_neural_network:11">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle x
  </annotation>
 </semantics>
</math>

 is transformed into a 3-dimensional vector 

<math display="inline" id="Artificial_neural_network:12">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle h
  </annotation>
 </semantics>
</math>

, which is then transformed into a 2-dimensional vector 

<math display="inline" id="Artificial_neural_network:13">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle g
  </annotation>
 </semantics>
</math>

, which is finally transformed into 

<math display="inline" id="Artificial_neural_network:14">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle f
  </annotation>
 </semantics>
</math>

. This view is most commonly encountered in the context of <a href="Mathematical_optimization" title="wikilink">optimization</a>.</p>

<p>The second view is the probabilistic view: the <a href="random_variable" title="wikilink">random variable</a> 

<math display="inline" id="Artificial_neural_network:15">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>F</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle F=f(G)
  </annotation>
 </semantics>
</math>

 depends upon the random variable 

<math display="inline" id="Artificial_neural_network:16">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>H</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>H</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle G=g(H)
  </annotation>
 </semantics>
</math>

, which depends upon 

<math display="inline" id="Artificial_neural_network:17">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle H=h(X)
  </annotation>
 </semantics>
</math>

, which depends upon the random variable 

<math display="inline" id="Artificial_neural_network:18">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle X
  </annotation>
 </semantics>
</math>

. This view is most commonly encountered in the context of <a href="graphical_models" title="wikilink">graphical models</a>.</p>

<p>The two views are largely equivalent. In either case, for this particular network architecture, the components of individual layers are independent of each other (e.g., the components of 

<math display="inline" id="Artificial_neural_network:19">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle g
  </annotation>
 </semantics>
</math>

 are independent of each other given their input 

<math display="inline" id="Artificial_neural_network:20">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle h
  </annotation>
 </semantics>
</math>

). This naturally enables a degree of parallelism in the implementation.</p>
<figure><b>(Figure)</b>
<figcaption> Two separate depictions of the recurrent ANN dependency graph</figcaption>
</figure>

<p>Networks such as the previous one are commonly called <a href="feedforward_neural_network" title="wikilink">feedforward</a>, because their graph is a <a href="directed_acyclic_graph" title="wikilink">directed acyclic graph</a>. Networks with <a href="path_(graph_theory)" title="wikilink">cycles</a> are commonly called <a href="Recurrent_neural_network" title="wikilink">recurrent</a>. Such networks are commonly depicted in the manner shown at the top of the figure, where 

<math display="inline" id="Artificial_neural_network:21">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle f
  </annotation>
 </semantics>
</math>

 is shown as being dependent upon itself. However, an implied temporal dependence is not shown.</p>
<h3 id="learning">Learning</h3>

<p>What has attracted the most interest in neural networks is the possibility of <em>learning</em>. Given a specific <em>task</em> to solve, and a <em>class</em> of functions 

<math display="inline" id="Artificial_neural_network:22">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle F
  </annotation>
 </semantics>
</math>

, learning means using a set of <em>observations</em> to find 

<math display="inline" id="Artificial_neural_network:23">
 <semantics>
  <mrow>
   <msup>
    <mi>f</mi>
    <mo>*</mo>
   </msup>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <times></times>
    </apply>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle f^{*}\in F
  </annotation>
 </semantics>
</math>

 which solves the task in some <em>optimal</em> sense.</p>

<p>This entails defining a cost function 

<math display="inline" id="Artificial_neural_network:24">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>:</mo>
   <mrow>
    <mi>F</mi>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>C</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>F</ci>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle C:F\rightarrow\mathbb{R}
  </annotation>
 </semantics>
</math>

 such that, for the optimal solution 

<math display="inline" id="Artificial_neural_network:25">
 <semantics>
  <msup>
   <mi>f</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>f</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle f^{*}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Artificial_neural_network:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>f</mi>
      <mo>*</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>C</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <times></times>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle C(f^{*})\leq C(f)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Artificial_neural_network:27">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>f</mi>
   </mrow>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>f</ci>
    </apply>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\forall f\in F
  </annotation>
 </semantics>
</math>

 – i.e., no solution has a cost less than the cost of the optimal solution (see <a href="Mathematical_optimization" title="wikilink">Mathematical optimization</a>).</p>

<p>The cost function 

<math display="inline" id="Artificial_neural_network:28">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle C
  </annotation>
 </semantics>
</math>

 is an important concept in learning, as it is a measure of how far away a particular solution is from an optimal solution to the problem to be solved. Learning algorithms search through the solution space to find a function that has the smallest possible cost.</p>

<p>For applications where the solution is dependent on some data, the cost must necessarily be a <em>function of the observations</em>, otherwise we would not be modelling anything related to the data. It is frequently defined as a <a class="uri" href="statistic" title="wikilink">statistic</a> to which only approximations can be made. As a simple example, consider the problem of finding the model 

<math display="inline" id="Artificial_neural_network:29">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle f
  </annotation>
 </semantics>
</math>

, which minimizes 

<math display="inline" id="Artificial_neural_network:30">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo>[</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mi>y</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>x</ci>
        </apply>
        <ci>y</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle C=E\left[(f(x)-y)^{2}\right]
  </annotation>
 </semantics>
</math>

, for data pairs 

<math display="inline" id="Artificial_neural_network:31">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle(x,y)
  </annotation>
 </semantics>
</math>

 drawn from some distribution 

<math display="inline" id="Artificial_neural_network:32">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒟</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒟</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\mathcal{D}
  </annotation>
 </semantics>
</math>

. In practical situations we would only have 

<math display="inline" id="Artificial_neural_network:33">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle N
  </annotation>
 </semantics>
</math>

 samples from 

<math display="inline" id="Artificial_neural_network:34">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒟</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒟</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\mathcal{D}
  </annotation>
 </semantics>
</math>

 and thus, for the above example, we would only minimize 

<math display="inline" id="Artificial_neural_network:35">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>C</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>N</mi>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </msubsup>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mi>i</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <msub>
         <mi>y</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-^</ci>
     <ci>C</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>f</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\hat{C}=\frac{1}{N}\sum_{i=1}^{N}(f(x_{i})-y_{i})^{2}
  </annotation>
 </semantics>
</math>

. Thus, the cost is minimized over a sample of the data rather than the entire distribution generating the data.</p>

<p>When 

<math display="inline" id="Artificial_neural_network:36">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>N</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle N\rightarrow\infty
  </annotation>
 </semantics>
</math>

 some form of <a href="online_machine_learning" title="wikilink">online machine learning</a> must be used, where the cost is partially minimized as each new example is seen. While online machine learning is often used when 

<math display="inline" id="Artificial_neural_network:37">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒟</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒟</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\mathcal{D}
  </annotation>
 </semantics>
</math>

 is fixed, it is most useful in the case where the distribution changes slowly over time. In neural network methods, some form of online machine learning is frequently used for finite datasets.</p>
<h4 id="choosing-a-cost-function">Choosing a cost function</h4>

<p>While it is possible to define some arbitrary <a href="ad_hoc" title="wikilink">ad hoc</a> cost function, frequently a particular cost will be used, either because it has desirable properties (such as <a href="Convex_function" title="wikilink">convexity</a>) or because it arises naturally from a particular formulation of the problem (e.g., in a probabilistic formulation the posterior probability of the model can be used as an inverse cost). Ultimately, the cost function will depend on the desired task. An overview of the three main categories of learning tasks is provided below:</p>
<h3 id="learning-paradigms">Learning paradigms</h3>

<p>There are three major learning paradigms, each corresponding to a particular abstract learning task. These are <a href="supervised_learning" title="wikilink">supervised learning</a>, <a href="unsupervised_learning" title="wikilink">unsupervised learning</a> and <a href="reinforcement_learning" title="wikilink">reinforcement learning</a>.</p>
<h4 id="supervised-learning">Supervised learning</h4>

<p>In <a href="supervised_learning" title="wikilink">supervised learning</a>, we are given a set of example pairs 

<math display="inline" id="Artificial_neural_network:38">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>,</mo>
     <mi>x</mi>
    </mrow>
    <mo>∈</mo>
    <mi>X</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>y</mi>
    <mo>∈</mo>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <list>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
      <ci>x</ci>
     </list>
     <ci>X</ci>
    </apply>
    <apply>
     <in></in>
     <ci>y</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle(x,y),x\in X,y\in Y
  </annotation>
 </semantics>
</math>

 and the aim is to find a function 

<math display="inline" id="Artificial_neural_network:39">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mo>→</mo>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle f:X\rightarrow Y
  </annotation>
 </semantics>
</math>

 in the allowed class of functions that matches the examples. In other words, we wish to <em>infer</em> the mapping implied by the data; the cost function is related to the mismatch between our mapping and the data and it implicitly contains prior knowledge about the problem domain.</p>

<p>A commonly used cost is the <a href="mean-squared_error" title="wikilink">mean-squared error</a>, which tries to minimize the average squared error between the network's output, 

<math display="inline" id="Artificial_neural_network:40">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle f(x)
  </annotation>
 </semantics>
</math>

, and the target value 

<math display="inline" id="Artificial_neural_network:41">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle y
  </annotation>
 </semantics>
</math>

 over all the example pairs. When one tries to minimize this cost using <a href="gradient_descent" title="wikilink">gradient descent</a> for the class of neural networks called <a href="multilayer_perceptron" title="wikilink">multilayer perceptrons</a>, one obtains the common and well-known <a href="Backpropagation" title="wikilink">backpropagation algorithm</a> for training neural networks.</p>

<p>Tasks that fall within the paradigm of supervised learning are <a href="pattern_recognition" title="wikilink">pattern recognition</a> (also known as classification) and <a href="Regression_analysis" title="wikilink">regression</a> (also known as function approximation). The supervised learning paradigm is also applicable to sequential data (e.g., for speech and gesture recognition). This can be thought of as learning with a "teacher", in the form of a function that provides continuous feedback on the quality of solutions obtained thus far.</p>
<h4 id="unsupervised-learning">Unsupervised learning</h4>

<p>In <a href="unsupervised_learning" title="wikilink">unsupervised learning</a>, some data 

<math display="inline" id="Artificial_neural_network:42">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle x
  </annotation>
 </semantics>
</math>

 is given and the cost function to be minimized, that can be any function of the data 

<math display="inline" id="Artificial_neural_network:43">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle x
  </annotation>
 </semantics>
</math>

 and the network's output, 

<math display="inline" id="Artificial_neural_network:44">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle f
  </annotation>
 </semantics>
</math>

.</p>

<p>The cost function is dependent on the task (what we are trying to model) and our <em>a priori</em> assumptions (the implicit properties of our model, its parameters and the observed variables).</p>

<p>As a trivial example, consider the model 

<math display="inline" id="Artificial_neural_network:45">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle f(x)=a
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Artificial_neural_network:46">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle a
  </annotation>
 </semantics>
</math>

 is a constant and the cost 

<math display="inline" id="Artificial_neural_network:47">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle C=E[(x-f(x))^{2}]
  </annotation>
 </semantics>
</math>

. Minimizing this cost will give us a value of 

<math display="inline" id="Artificial_neural_network:48">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle a
  </annotation>
 </semantics>
</math>

 that is equal to the mean of the data. The cost function can be much more complicated. Its form depends on the application: for example, in compression it could be related to the <a href="mutual_information" title="wikilink">mutual information</a> between 

<math display="inline" id="Artificial_neural_network:49">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Artificial_neural_network:50">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle f(x)
  </annotation>
 </semantics>
</math>

, whereas in statistical modeling, it could be related to the <a href="posterior_probability" title="wikilink">posterior probability</a> of the model given the data (note that in both of those examples those quantities would be maximized rather than minimized).</p>

<p>Tasks that fall within the paradigm of unsupervised learning are in general <a href="Approximation" title="wikilink">estimation</a> problems; the applications include <a href="Data_clustering" title="wikilink">clustering</a>, the estimation of <a href="statistical_distributions" title="wikilink">statistical distributions</a>, <a href="Data_compression" title="wikilink">compression</a> and <a href="Bayesian_spam_filtering" title="wikilink">filtering</a>.</p>
<h4 id="reinforcement-learning">Reinforcement learning</h4>

<p>In <a href="reinforcement_learning" title="wikilink">reinforcement learning</a>, data 

<math display="inline" id="Artificial_neural_network:51">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle x
  </annotation>
 </semantics>
</math>

 are usually not given, but generated by an agent's interactions with the environment. At each point in time 

<math display="inline" id="Artificial_neural_network:52">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle t
  </annotation>
 </semantics>
</math>

, the agent performs an action 

<math display="inline" id="Artificial_neural_network:53">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle y_{t}
  </annotation>
 </semantics>
</math>

 and the environment generates an observation 

<math display="inline" id="Artificial_neural_network:54">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle x_{t}
  </annotation>
 </semantics>
</math>

 and an instantaneous cost 

<math display="inline" id="Artificial_neural_network:55">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle c_{t}
  </annotation>
 </semantics>
</math>

, according to some (usually unknown) dynamics. The aim is to discover a <em>policy</em> for selecting actions that minimizes some measure of a long-term cost, e.g., the expected cumulative cost. The environment's dynamics and the long-term cost for each policy are usually unknown, but can be estimated.</p>

<p>More formally the environment is modeled as a <a href="Markov_decision_process" title="wikilink">Markov decision process</a> (MDP) with states 

<math display="inline" id="Artificial_neural_network:56">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>s</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>s</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>n</ci>
     </apply>
    </list>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle{s_{1},...,s_{n}}\in S
  </annotation>
 </semantics>
</math>

 and actions 

<math display="inline" id="Artificial_neural_network:57">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mi>m</mi>
    </msub>
   </mrow>
   <mo>∈</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>m</ci>
     </apply>
    </list>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle{a_{1},...,a_{m}}\in A
  </annotation>
 </semantics>
</math>

 with the following probability distributions: the instantaneous cost distribution 

<math display="inline" id="Artificial_neural_network:58">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>c</mi>
     <mi>t</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>s</mi>
     <mi>t</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle P(c_{t}|s_{t})
  </annotation>
 </semantics>
</math>

, the observation distribution 

<math display="inline" id="Artificial_neural_network:59">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>t</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>s</mi>
     <mi>t</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle P(x_{t}|s_{t})
  </annotation>
 </semantics>
</math>

 and the transition 

<math display="inline" id="Artificial_neural_network:60">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>s</mi>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>s</mi>
     <mi>t</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mi>t</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle P(s_{t+1}|s_{t},a_{t})
  </annotation>
 </semantics>
</math>

, while a policy is defined as the conditional distribution over actions given the observations. Taken together, the two then define a <a href="Markov_chain" title="wikilink">Markov chain</a> (MC). The aim is to discover the policy (i.e., the MC) that minimizes the cost.</p>

<p>ANNs are frequently used in reinforcement learning as part of the overall algorithm.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a><a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> <a href="Dynamic_programming" title="wikilink">Dynamic programming</a> has been coupled with ANNs (Neuro dynamic programming) by <a href="Dimitri_Bertsekas" title="wikilink">Bertsekas</a> and Tsitsiklis<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> and applied to multi-dimensional nonlinear problems such as those involved in <a href="vehicle_routing" title="wikilink">vehicle routing</a>,<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> <a href="natural_resource_management" title="wikilink">natural resources management</a><a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a><a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> or <a class="uri" href="medicine" title="wikilink">medicine</a><a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> because of the ability of ANNs to mitigate losses of accuracy even when reducing the discretization grid density for numerically approximating the solution of the original control problems.</p>

<p>Tasks that fall within the paradigm of reinforcement learning are control problems, <a href="game" title="wikilink">games</a> and other <a href="sequential_decision_making" title="wikilink">sequential decision making</a> tasks.</p>
<h3 id="learning-algorithms">Learning algorithms</h3>

<p>Training a neural network model essentially means selecting one model from the set of allowed models (or, in a <a href="Bayesian_probability" title="wikilink">Bayesian</a> framework, determining a distribution over the set of allowed models) that minimizes the cost criterion. There are numerous algorithms available for training neural network models; most of them can be viewed as a straightforward application of <a href="Mathematical_optimization" title="wikilink">optimization</a> theory and <a href="statistical_estimation" title="wikilink">statistical estimation</a>.</p>

<p>Most of the algorithms used in training artificial neural networks employ some form of <a href="gradient_descent" title="wikilink">gradient descent</a>, using backpropagation to compute the actual gradients. This is done by simply taking the derivative of the cost function with respect to the network parameters and then changing those parameters in a <a class="uri" href="gradient-related" title="wikilink">gradient-related</a> direction. The backpropagation training algorithms are usually classified into three categories: steepest descent (with variable learning rate, with variable learning rate and momentum, resilient backpropagation), quasi-Newton (Broyden-Fletcher-Goldfarb-Shanno, one step secant, Levenberg-Marquardt) and conjugate gradient (Fletcher-Reeves update, Polak-Ribiére update, Powell-Beale restart, scaled conjugate gradient).<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a></p>

<p><a href="Evolutionary_methods" title="wikilink">Evolutionary methods</a>,<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> <a href="gene_expression_programming" title="wikilink">gene expression programming</a>,<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> <a href="simulated_annealing" title="wikilink">simulated annealing</a>,<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> <a class="uri" href="expectation-maximization" title="wikilink">expectation-maximization</a>, <a href="non-parametric_methods" title="wikilink">non-parametric methods</a> and <a href="particle_swarm_optimization" title="wikilink">particle swarm optimization</a><a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> are some commonly used methods for training neural networks. </p>
<h2 id="employing-artificial-neural-networks">Employing artificial neural networks</h2>

<p>Perhaps the greatest advantage of ANNs is their ability to be used as an arbitrary function approximation mechanism that 'learns' from observed data. However, using them is not so straightforward, and a relatively good understanding of the underlying theory is essential.</p>
<ul>
<li>Choice of model: This will depend on the data representation and the application. Overly complex models tend to lead to problems with learning.</li>
<li>Learning algorithm: There are numerous trade-offs between learning algorithms. Almost any algorithm will work well with the <em>correct <a href="hyperparameter" title="wikilink">hyperparameters</a></em> for training on a particular fixed data set. However, selecting and tuning an algorithm for training on unseen data requires a significant amount of experimentation.</li>
<li>Robustness: If the model, cost function and learning algorithm are selected appropriately the resulting ANN can be extremely robust.</li>
</ul>

<p>With the correct implementation, ANNs can be used naturally in <a href="online_algorithm" title="wikilink">online learning</a> and large data set applications. Their simple implementation and the existence of mostly local dependencies exhibited in the structure allows for fast, parallel implementations in hardware.</p>
<h2 id="applications">Applications</h2>

<p>The utility of artificial neural network models lies in the fact that they can be used to infer a function from observations. This is particularly useful in applications where the complexity of the data or task makes the design of such a function by hand impractical.</p>
<h3 id="real-life-applications">Real-life applications</h3>

<p>The tasks artificial neural networks are applied to tend to fall within the following broad categories:</p>
<ul>
<li><a href="Function_approximation" title="wikilink">Function approximation</a>, or <a href="regression_analysis" title="wikilink">regression analysis</a>, including <a href="time_series_prediction" title="wikilink">time series prediction</a>, <a href="fitness_approximation" title="wikilink">fitness approximation</a> and modeling.</li>
<li><a href="Statistical_classification" title="wikilink">Classification</a>, including <a href="Pattern_recognition" title="wikilink">pattern</a> and sequence recognition, <a href="novelty_detection" title="wikilink">novelty detection</a> and sequential decision making.</li>
<li><a href="Data_processing" title="wikilink">Data processing</a>, including filtering, clustering, <a href="blind_source_separation" title="wikilink">blind source separation</a> and compression.</li>
<li><a class="uri" href="Robotics" title="wikilink">Robotics</a>, including directing manipulators, <a class="uri" href="prosthesis" title="wikilink">prosthesis</a>.</li>
<li><a href="Control_engineering" title="wikilink">Control</a>, including <a href="Computer_numerical_control" title="wikilink">Computer numerical control</a>.</li>
</ul>

<p>Application areas include the system identification and control (vehicle control, trajectory prediction,<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> process control, <a href="natural_resource" title="wikilink">natural resources</a> management), quantum chemistry,<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a> game-playing and decision making (backgammon, chess, <a class="uri" href="poker" title="wikilink">poker</a>), pattern recognition (radar systems, face identification, object recognition and more), sequence recognition (gesture, speech, handwritten text recognition), medical diagnosis, financial applications (e.g. <a href="algorithmic_trading" title="wikilink">automated trading systems</a>), <a href="data_mining" title="wikilink">data mining</a> (or knowledge discovery in databases, "KDD"), visualization and <a href="e-mail_spam" title="wikilink">e-mail spam</a> filtering.</p>

<p>Artificial neural networks have also been used to diagnose several cancers. An ANN based hybrid lung cancer detection system named HLND improves the accuracy of diagnosis and the speed of lung cancer radiology.<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a> These networks have also been used to diagnose prostate cancer. The diagnoses can be used to make specific models taken from a large group of patients compared to information of one given patient. The models do not depend on assumptions about correlations of different variables. Colorectal cancer has also been predicted using the neural networks. Neural networks could predict the outcome for a patient with colorectal cancer with more accuracy than the current clinical methods. After training, the networks could predict multiple patient outcomes from unrelated institutions.<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a></p>
<h3 id="neural-networks-and-neuroscience">Neural networks and neuroscience</h3>

<p>Theoretical and <a href="computational_neuroscience" title="wikilink">computational neuroscience</a> is the field concerned with the theoretical analysis and the computational modeling of biological neural systems. Since neural systems are intimately related to cognitive processes and behavior, the field is closely related to cognitive and behavioral modeling.</p>

<p>The aim of the field is to create models of biological neural systems in order to understand how biological systems work. To gain this understanding, neuroscientists strive to make a link between observed biological processes (data), biologically plausible mechanisms for neural processing and learning (<a href="biological_neural_network" title="wikilink">biological neural network</a> models) and theory (statistical learning theory and <a href="information_theory" title="wikilink">information theory</a>).</p>
<h4 id="types-of-models">Types of models</h4>

<p>Many models are used in the field, defined at different levels of abstraction and modeling different aspects of neural systems. They range from models of the short-term behavior of <a href="biological_neuron_models" title="wikilink">individual neurons</a> (e.g.<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a>), models of how the dynamics of neural circuitry arise from interactions between individual neurons and finally to models of how behavior can arise from abstract neural modules that represent complete subsystems. These include models of the long-term, and short-term plasticity, of neural systems and their relations to learning and memory from the individual neuron to the system level.</p>
<h4 id="memory-networks">Memory networks</h4>

<p>Integrating external memory components with artificial neural networks has a long history dating back to early research in <a href="distributed_representations" title="wikilink">distributed representations</a> <a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a> and <a href="self-organizing_map" title="wikilink">self-organizing maps</a>. E.g. in <a href="sparse_distributed_memory" title="wikilink">sparse distributed memory</a> the patterns encoded by neural networks are used as memory addresses for content-addressable memory, with "neurons" essentially serving as address <a href="encoder" title="wikilink">encoders</a> and <a href="decoder" title="wikilink">decoders</a>.</p>

<p>More recently <a href="deep_learning" title="wikilink">deep learning</a> was shown to be useful in <a href="semantic_hashing" title="wikilink">semantic hashing</a><a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a> where a deep <a href="graphical_model" title="wikilink">graphical model</a> the word-count vectors<a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a> obtained from a large set of documents. Documents are mapped to memory addresses in such a way that semantically similar documents are located at nearby addresses. Documents similar to a query document can then be found by simply accessing all the addresses that differ by only a few bits from the address of the query document.</p>

<p><a href="Neural_Turing_Machines" title="wikilink">Neural Turing Machines</a><a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a> developed by <a href="Google_DeepMind" title="wikilink">Google DeepMind</a> extend the capabilities of deep neural networks by coupling them to external memory resources, which they can interact with by attentional processes. The combined system is analogous to a <a href="Turing_Machine" title="wikilink">Turing Machine</a> but is differentiable end-to-end, allowing it to be efficiently trained with <a href="gradient_descent" title="wikilink">gradient descent</a>. Preliminary results demonstrate that Neural Turing Machines can infer simple algorithms such as copying, sorting, and associative recall from input and output examples.</p>

<p><a href="Memory_Networks" title="wikilink">Memory Networks</a><a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a> is another extension to neural networks incorporating <a href="long-term_memory" title="wikilink">long-term memory</a> which was developed by <a class="uri" href="Facebook" title="wikilink">Facebook</a> research. The long-term memory can be read and written to, with the goal of using it for prediction. These models have been applied in the context of <a href="question_answering" title="wikilink">question answering</a> (QA) where the long-term memory effectively acts as a (dynamic) knowledge base, and the output is a textual response.</p>
<h2 id="neural-network-software">Neural network software</h2>

<p><strong>Neural network software</strong> is used to <a href="Simulation" title="wikilink">simulate</a>, <a class="uri" href="research" title="wikilink">research</a>, develop and apply artificial neural networks, <a href="biological_neural_network" title="wikilink">biological neural networks</a> and, in some cases, a wider array of <a href="adaptive_system" title="wikilink">adaptive systems</a>.</p>
<h2 id="types-of-artificial-neural-networks">Types of artificial neural networks</h2>

<p>Artificial neural network types vary from those with only one or two layers of single direction logic, to complicated multi–input many directional feedback loops and layers. On the whole, these systems use algorithms in their programming to determine control and organization of their functions. Most systems use "weights" to change the parameters of the throughput and the varying connections to the neurons. Artificial neural networks can be autonomous and learn by input from outside "teachers" or even self-teaching from written-in rules.</p>
<h2 id="theoretical-properties">Theoretical properties</h2>
<section begin="theory">
</section>
<h3 id="computational-power">Computational power</h3>

<p>The <a href="multi-layer_perceptron" title="wikilink">multi-layer perceptron</a> (MLP) is a universal function approximator, as proven by the <a href="universal_approximation_theorem" title="wikilink">universal approximation theorem</a>. However, the proof is not constructive regarding the number of neurons required or the settings of the weights.</p>

<p>Work by <a href="Hava_Siegelmann" title="wikilink">Hava Siegelmann</a> and <a href="Eduardo_D._Sontag" title="wikilink">Eduardo D. Sontag</a> has provided a proof that a specific recurrent architecture with rational valued weights (as opposed to full precision <a href="real_number" title="wikilink">real number</a>-valued weights) has the full power of a <a href="Universal_Turing_Machine" title="wikilink">Universal Turing Machine</a><a class="footnoteRef" href="#fn53" id="fnref53"><sup>53</sup></a> using a finite number of neurons and standard linear connections. Further, it has been shown that the use of irrational values for weights results in a machine with <a href="Hypercomputation" title="wikilink">super-Turing</a> power.<a class="footnoteRef" href="#fn54" id="fnref54"><sup>54</sup></a></p>
<h3 id="capacity">Capacity</h3>

<p>Artificial neural network models have a property called 'capacity', which roughly corresponds to their ability to model any given function. It is related to the amount of information that can be stored in the network and to the notion of complexity.</p>
<h3 id="convergence">Convergence</h3>

<p>Nothing can be said in general about convergence since it depends on a number of factors. Firstly, there may exist many local minima. This depends on the cost function and the model. Secondly, the optimization method used might not be guaranteed to converge when far away from a local minimum. Thirdly, for a very large amount of data or parameters, some methods become impractical. In general, it has been found that theoretical guarantees regarding convergence are an unreliable guide to practical application. </p>
<h3 id="generalization-and-statistics">Generalization and statistics</h3>

<p>In applications where the goal is to create a system that generalizes well in unseen examples, the problem of over-training has emerged. This arises in convoluted or over-specified systems when the capacity of the network significantly exceeds the needed free parameters. There are two schools of thought for avoiding this problem: The first is to use <a href="cross-validation_(statistics)" title="wikilink">cross-validation</a> and similar techniques to check for the presence of overtraining and optimally select hyperparameters such as to minimize the generalization error. The second is to use some form of <em><a href="regularization_(mathematics)" title="wikilink">regularization</a></em>. This is a concept that emerges naturally in a probabilistic (Bayesian) framework, where the regularization can be performed by selecting a larger prior probability over simpler models; but also in statistical learning theory, where the goal is to minimize over two quantities: the 'empirical risk' and the 'structural risk', which roughly corresponds to the error over the training set and the predicted error in unseen data due to overfitting.</p>

<p> Supervised neural networks that use a <a href="mean_squared_error" title="wikilink">mean squared error</a> (MSE) cost function can use formal statistical methods to determine the confidence of the trained model. The MSE on a validation set can be used as an estimate for variance. This value can then be used to calculate the <a href="confidence_interval" title="wikilink">confidence interval</a> of the output of the network, assuming a <a href="normal_distribution" title="wikilink">normal distribution</a>. A confidence analysis made this way is statistically valid as long as the output <a href="probability_distribution" title="wikilink">probability distribution</a> stays the same and the network is not modified.</p>

<p>By assigning a <a href="softmax_activation_function" title="wikilink">softmax activation function</a>, a generalization of the <a href="logistic_function" title="wikilink">logistic function</a>, on the output layer of the neural network (or a softmax component in a component-based neural network) for categorical target variables, the outputs can be interpreted as posterior probabilities. This is very useful in classification as it gives a certainty measure on classifications.</p>

<p>The softmax activation function is:</p>

<p>

<math display="block" id="Artificial_neural_network:61">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <msup>
     <mi>e</mi>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
    </msup>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>c</mi>
     </msubsup>
     <msup>
      <mi>e</mi>
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
     </msup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>c</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}=\frac{e^{x_{i}}}{\sum_{j=1}^{c}e^{x_{j}}}
  </annotation>
 </semantics>
</math>

</p>
<section end="theory">
</section>
<h2 id="controversies">Controversies</h2>
<h3 id="training-issues">Training issues</h3>

<p>A common criticism of neural networks, particularly in robotics, is that they require a large diversity of training for real-world operation . This is not surprising, since any learning machine needs sufficient representative examples in order to capture the underlying structure that allows it to generalize to new cases. Dean Pomerleau, in his research presented in the paper "Knowledge-based Training of Artificial Neural Networks for Autonomous Robot Driving," uses a neural network to train a robotic vehicle to drive on multiple types of roads (single lane, multi-lane, dirt, etc.). A large amount of his research is devoted to (1) extrapolating multiple training scenarios from a single training experience, and (2) preserving past training diversity so that the system does not become overtrained (if, for example, it is presented with a series of right turns – it should not learn to always turn right). These issues are common in neural networks that must decide from amongst a wide variety of responses, but can be dealt with in several ways, for example by randomly shuffling the training examples, by using a numerical optimization algorithm that does not take too large steps when changing the network connections following an example, or by grouping examples in so-called mini-batches.</p>

<p><a href="A._K._Dewdney" title="wikilink">A. K. Dewdney</a>, a former <em><a href="Scientific_American" title="wikilink">Scientific American</a></em> columnist, wrote in 1997, "Although neural nets do solve a few toy problems, their powers of computation are so limited that I am surprised anyone takes them seriously as a general problem-solving tool." (Dewdney, p. 82)</p>
<h3 id="hardware-issues">Hardware issues</h3>

<p>To implement large and effective software neural networks, considerable processing and storage resources need to be committed . While the brain has hardware tailored to the task of processing signals through a <a href="Graph_(mathematics)" title="wikilink">graph</a> of neurons, simulating even a most simplified form on <a href="Von_Neumann" title="wikilink">Von Neumann</a> technology may compel a neural network designer to fill many millions of <a class="uri" href="database" title="wikilink">database</a> rows for its connections – which can consume vast amounts of computer <a href="Random-access_memory" title="wikilink">memory</a> and <a href="Hard_drive" title="wikilink">hard disk</a> space. Furthermore, the designer of neural network systems will often need to simulate the transmission of signals through many of these connections and their associated neurons – which must often be matched with incredible amounts of <a class="uri" href="CPU" title="wikilink">CPU</a> processing power and time. While neural networks often yield <em>effective</em> programs, they too often do so at the cost of <em>efficiency</em> (they tend to consume considerable amounts of time and money).</p>

<p>Computing power continues to grow roughly according to <a href="Moore's_Law" title="wikilink">Moore's Law</a>, which may provide sufficient resources to accomplish new tasks. <a href="Neuromorphic_engineering" title="wikilink">Neuromorphic engineering</a> addresses the hardware difficulty directly, by constructing non-Von-Neumann chips with circuits designed to implement neural nets from the ground up.</p>
<h3 id="practical-counterexamples-to-criticisms">Practical counterexamples to criticisms</h3>

<p>Arguments against Dewdney's position are that neural networks have been successfully used to solve many complex and diverse tasks, ranging from autonomously flying aircraft<a class="footnoteRef" href="#fn55" id="fnref55"><sup>55</sup></a> to detecting credit card fraud .</p>

<p>Technology writer <a href="Roger_Bridgman" title="wikilink">Roger Bridgman</a> commented on Dewdney's statements about neural nets:</p>
<blockquote>

<p>Neural networks, for instance, are in the dock not only because they have been hyped to high heaven, (what hasn't?) but also because you could create a successful net without understanding how it worked: the bunch of numbers that captures its behaviour would in all probability be "an opaque, unreadable table...valueless as a scientific resource".</p>

<p>In spite of his emphatic declaration that science is not technology, Dewdney seems here to pillory neural nets as bad science when most of those devising them are just trying to be good engineers. An unreadable table that a useful machine could read would still be well worth having.<a class="footnoteRef" href="#fn56" id="fnref56"><sup>56</sup></a></p>
</blockquote>

<p>Although it is true that analyzing what has been learned by an artificial neural network is difficult, it is much easier to do so than to analyze what has been learned by a biological neural network. Furthermore, researchers involved in exploring learning algorithms for neural networks are gradually uncovering generic principles which allow a learning machine to be successful. For example, Bengio and LeCun (2007) wrote an article regarding local vs non-local learning, as well as shallow vs deep architecture.<a class="footnoteRef" href="#fn57" id="fnref57"><sup>57</sup></a></p>
<h3 id="hybrid-approaches">Hybrid approaches</h3>

<p>Some other criticisms come from advocates of hybrid models (combining neural networks and symbolic approaches), who believe that the intermix of these two approaches can better capture the mechanisms of the human mind.<a class="footnoteRef" href="#fn58" id="fnref58"><sup>58</sup></a><a class="footnoteRef" href="#fn59" id="fnref59"><sup>59</sup></a></p>
<h2 id="gallery">Gallery</h2>

<p><a class="uri" href="File:Single_layer_ann.svg|A">File:Single_layer_ann.svg|A</a> single-layer feedforward artificial neural network. Arrows originating from 

<math display="inline" id="Artificial_neural_network:62">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle x_{2}
  </annotation>
 </semantics>
</math>

 are omitted for clarity. There are p inputs to this network and q outputs. In this system, the value of the qth output, 

<math display="inline" id="Artificial_neural_network:63">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle y_{q}
  </annotation>
 </semantics>
</math>

 would be calculated as 

<math display="inline" id="Artificial_neural_network:64">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>q</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo>*</mo>
      <msub>
       <mi>w</mi>
       <mrow>
        <mi>i</mi>
        <mi>q</mi>
       </mrow>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>q</ci>
    </apply>
    <apply>
     <sum></sum>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>q</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle y_{q}=\sum(x_{i}*w_{iq})
  </annotation>
 </semantics>
</math>

 <a class="uri" href="File:Two_layer_ann.svg|A">File:Two_layer_ann.svg|A</a> two-layer feedforward artificial neural network. <a class="uri" href="File:Artificial_neural_network.svg">File:Artificial_neural_network.svg</a> <a class="uri" href="File:Ann_dependency_(graph).svg">File:Ann_dependency_(graph).svg</a> <a class="uri" href="File:Single-layer">File:Single-layer</a> feedforward artificial neural network.png|A single-layer feedforward artificial neural network with 4 inputs, 6 hidden and 2 outputs. Given position state and direction outputs wheel based control values. <a class="uri" href="File:Two-layer">File:Two-layer</a> feedforward artificial neural network.png|A two-layer feedforward artificial neural network with 8 inputs, 2x8 hidden and 2 outputs. Given position state, direction and other environment values outputs thruster based control values.</p>
<h2 id="see-also">See also</h2>
<h2 id="references">References</h2>
<h2 id="bibliography">Bibliography</h2>
<ul>
<li></li>
<li>Bishop, C.M. (1995) <em>Neural Networks for Pattern Recognition</em>, Oxford: Oxford University Press. ISBN 0-19-853849-9 (hardback) or ISBN 0-19-853864-2 (paperback)</li>
<li>Cybenko, G.V. (1989). Approximation by Superpositions of a Sigmoidal function, <em><a href="Mathematics_of_Control,_Signals,_and_Systems" title="wikilink">Mathematics of Control, Signals, and Systems</a></em>, Vol. 2 pp. 303–314. <a href="http://actcomm.dartmouth.edu/gvc/papers/approx_by_superposition.pdf">electronic version</a></li>
<li>Duda, R.O., Hart, P.E., Stork, D.G. (2001) <em>Pattern classification (2nd edition)</em>, Wiley, ISBN 0-471-05669-3</li>
<li></li>
<li>Gurney, K. (1997) <em>An Introduction to Neural Networks</em> London: Routledge. ISBN 1-85728-673-1 (hardback) or ISBN 1-85728-503-4 (paperback)</li>
<li>Haykin, S. (1999) '' Neural Networks: A Comprehensive Foundation'', Prentice Hall, ISBN 0-13-273350-1</li>
<li>Fahlman, S, Lebiere, C (1991). <em>The Cascade-Correlation Learning Architecture</em>, created for <a href="National_Science_Foundation" title="wikilink">National Science Foundation</a>, Contract Number EET-8716324, and <a href="Defense_Advanced_Research_Projects_Agency" title="wikilink">Defense Advanced Research Projects Agency</a> (DOD), ARPA Order No. 4976 under Contract F33615-87-C-1499. <a href="http://www.cs.iastate.edu/~honavar/fahlman.pdf">electronic version</a></li>
<li>Hertz, J., Palmer, R.G., Krogh. A.S. (1990) <em>Introduction to the theory of neural computation</em>, Perseus Books. ISBN 0-201-51560-1</li>
<li>Lawrence, Jeanette (1994) <em>Introduction to Neural Networks</em>, California Scientific Software Press. ISBN 1-883157-00-5</li>
<li>Masters, Timothy (1994) <em>Signal and Image Processing with Neural Networks</em>, John Wiley &amp; Sons, Inc. ISBN 0-471-04963-8</li>
<li><a href="Brian_D._Ripley" title="wikilink">Ripley, Brian D</a>. (1996) <em>Pattern Recognition and Neural Networks</em>, Cambridge</li>
<li>Siegelmann, H.T. and <a href="Eduardo_D._Sontag" title="wikilink">Sontag, E.D.</a> (1994). Analog computation via neural networks, <em>Theoretical Computer Science</em>, v. 131, no. 2, pp. 331–360. <a href="http://www.math.rutgers.edu/~sontag/FTP_DIR/nets-real.pdf">electronic version</a></li>
<li>Sergios Theodoridis, Konstantinos Koutroumbas (2009) "Pattern Recognition", 4th Edition, Academic Press, ISBN 978-1-59749-272-0.</li>
<li>Smith, Murray (1993) <em>Neural Networks for Statistical Modeling</em>, Van Nostrand Reinhold, ISBN 0-442-01310-8</li>
<li>Wasserman, Philip (1993) <em>Advanced Methods in Neural Computing</em>, Van Nostrand Reinhold, ISBN 0-442-00461-3</li>
<li><em>Computational Intelligence: A Methodological Introduction</em> by Kruse, Borgelt, Klawonn, Moewes, Steinbrecher, Held, 2013, Springer, ISBN 9781447150121</li>
<li><em>Neuro-Fuzzy-Systeme</em> (3rd edition) by Borgelt, Klawonn, Kruse, Nauck, 2003, Vieweg, ISBN 9783528252656</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://www.dkriesel.com/en/science/neural_networks">A brief introduction to Neural Networks</a> (PDF), illustrated 250p textbook covering the common kinds of neural networks (CC license).</li>
<li><a href="http://deeplearning4j.org/neuralnet-overview.html">An Introduction to Deep Neural Networks</a>.</li>
</ul>

<p><a href="pl:Sieci_neuronowe" title="wikilink">pl:Sieci neuronowe</a> <a href="ro:Rețea_neurală_artificială" title="wikilink">ro:Rețea neurală artificială</a>"</p>

<p><a href="Category:Computational_statistics" title="wikilink">Category:Computational statistics</a> <a href="Category:Artificial_neural_networks" title="wikilink"> </a> <a href="Category:Classification_algorithms" title="wikilink">Category:Classification algorithms</a> <a href="Category:Computational_neuroscience" title="wikilink">Category:Computational neuroscience</a> <a href="Category:Mathematical_psychology" title="wikilink">Category:Mathematical psychology</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11">Yang, J. J.; Pickett, M. D.; Li, X. M.; Ohlberg, D. A. A.; Stewart, D. R.; Williams, R. S. Nat. Nanotechnol. 2008, 3, 429–433.<a href="#fnref11">↩</a></li>
<li id="fn12">Strukov, D. B.; Snider, G. S.; Stewart, D. R.; Williams, R. S. <em>Nature</em> 2008, 453, 80–83.<a href="#fnref12">↩</a></li>
<li id="fn13"><a href="http://www.kurzweilai.net/how-bio-inspired-deep-learning-keeps-winning-competitions">2012 Kurzweil AI Interview</a> with <a href="Jürgen_Schmidhuber" title="wikilink">Jürgen Schmidhuber</a> on the eight competitions won by his Deep Learning team 2009–2012<a href="#fnref13">↩</a></li>
<li id="fn14"><a class="uri" href="http://www.kurzweilai.net/how-bio-inspired-deep-learning-keeps-winning-competitions">http://www.kurzweilai.net/how-bio-inspired-deep-learning-keeps-winning-competitions</a> 2012 Kurzweil AI Interview with <a href="Jürgen_Schmidhuber" title="wikilink">Jürgen Schmidhuber</a> on the eight competitions won by his Deep Learning team 2009–2012<a href="#fnref14">↩</a></li>
<li id="fn15">Graves, Alex; and Schmidhuber, Jürgen; <em><a href="http://www.idsia.ch/~juergen/nips2009.pdf">Offline Handwriting Recognition with Multidimensional Recurrent Neural Networks</a></em>, in Bengio, Yoshua; Schuurmans, Dale; Lafferty, John; Williams, Chris K. I.; and Culotta, Aron (eds.), <em>Advances in Neural Information Processing Systems 22 (NIPS'22), 7–10 December 2009, Vancouver, BC</em>, Neural Information Processing Systems (NIPS) Foundation, 2009, pp. 545–552.<a href="#fnref15">↩</a></li>
<li id="fn16">A. Graves, M. Liwicki, S. Fernandez, R. Bertolami, H. Bunke, <a href="Jürgen_Schmidhuber" title="wikilink">J. Schmidhuber</a>. <a href="http://www.idsia.ch/~juergen/tpami_2008.pdf">A Novel Connectionist System for Improved Unconstrained Handwriting Recognition</a>. IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 31, no. 5, 2009.<a href="#fnref16">↩</a></li>
<li id="fn17">Graves, Alex; and Schmidhuber, Jürgen; <em>Offline Handwriting Recognition with Multidimensional Recurrent Neural Networks</em>, in Bengio, Yoshua; Schuurmans, Dale; Lafferty, John; Williams, Chris K. I.; and Culotta, Aron (eds.), <em>Advances in Neural Information Processing Systems 22 (NIPS'22), December 7th–10th, 2009, Vancouver, BC</em>, Neural Information Processing Systems (NIPS) Foundation, 2009, pp. 545–552<a href="#fnref17">↩</a></li>
<li id="fn18">A. Graves, M. Liwicki, S. Fernandez, R. Bertolami, H. Bunke, J. Schmidhuber. A Novel Connectionist System for Improved Unconstrained Handwriting Recognition. IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 31, no. 5, 2009.<a href="#fnref18">↩</a></li>
<li id="fn19">D. C. Ciresan, U. Meier, J. Masci, <a href="Jürgen_Schmidhuber" title="wikilink">J. Schmidhuber</a>. Multi-Column Deep Neural Network for Traffic Sign Classification. Neural Networks, 2012.<a href="#fnref19">↩</a></li>
<li id="fn20">D. C. Ciresan, U. Meier, J. Masci, J. Schmidhuber. Multi-Column Deep Neural Network for Traffic Sign Classification. Neural Networks, 2012.<a href="#fnref20">↩</a></li>
<li id="fn21">D. Ciresan, A. Giusti, L. Gambardella, J. Schmidhuber. Deep Neural Networks Segment Neuronal Membranes in Electron Microscopy Images. In Advances in Neural Information Processing Systems (NIPS 2012), Lake Tahoe, 2012.<a href="#fnref21">↩</a></li>
<li id="fn22">D. C. Ciresan, U. Meier, <a href="Jürgen_Schmidhuber" title="wikilink">J. Schmidhuber</a>. Multi-column Deep Neural Networks for Image Classification. IEEE Conf. on Computer Vision and Pattern Recognition CVPR 2012.<a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24">M Riesenhuber, <a href="Tomaso_Poggio" title="wikilink">T Poggio</a>. Hierarchical models of object recognition in cortex. Nature neuroscience, 1999.<a href="#fnref24">↩</a></li>
<li id="fn25"><a href="http://www.scholarpedia.org/article/Deep_belief_networks">Deep belief networks</a> at Scholarpedia.<a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a class="uri" href="http://www.scholarpedia.org/article/Deep_belief_networks">http://www.scholarpedia.org/article/Deep_belief_networks</a> /<a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33"><a href="#fnref33">↩</a></li>
<li id="fn34"><a href="#fnref34">↩</a></li>
<li id="fn35"><a href="#fnref35">↩</a></li>
<li id="fn36"><a href="#fnref36">↩</a></li>
<li id="fn37"><a href="#fnref37">↩</a></li>
<li id="fn38"><a href="#fnref38">↩</a></li>
<li id="fn39"><a href="#fnref39">↩</a></li>
<li id="fn40"><a href="#fnref40">↩</a></li>
<li id="fn41"><a href="#fnref41">↩</a></li>
<li id="fn42"><a href="#fnref42">↩</a></li>
<li id="fn43"><a href="#fnref43">↩</a></li>
<li id="fn44"><a href="#fnref44">↩</a></li>
<li id="fn45"><a href="#fnref45">↩</a></li>
<li id="fn46"><a href="#fnref46">↩</a></li>
<li id="fn47"><a href="#fnref47">↩</a></li>
<li id="fn48">Hinton, Geoffrey E. "Distributed representations." (1984)<a href="#fnref48">↩</a></li>
<li id="fn49">Salakhutdinov, Ruslan, and Geoffrey Hinton. "Semantic hashing." International Journal of Approximate Reasoning 50.7 (2009): 969-978.<a href="#fnref49">↩</a></li>
<li id="fn50">Le, Quoc V., and Tomas Mikolov. "Distributed representations of sentences and documents." arXiv preprint arXiv:1405.4053 (2014).<a href="#fnref50">↩</a></li>
<li id="fn51">Graves, Alex, Greg Wayne, and Ivo Danihelka. "Neural Turing Machines." arXiv preprint arXiv:1410.5401 (2014).<a href="#fnref51">↩</a></li>
<li id="fn52">Weston, Jason, Sumit Chopra, and Antoine Bordes. "Memory networks." arXiv preprint arXiv:1410.3916 (2014).<a href="#fnref52">↩</a></li>
<li id="fn53"><a href="#fnref53">↩</a></li>
<li id="fn54"><a href="#fnref54">↩</a></li>
<li id="fn55"><a href="http://www.nasa.gov/centers/dryden/news/NewsReleases/2003/03-49.html">NASA - Dryden Flight Research Center - News Room: News Releases: NASA NEURAL NETWORK PROJECT PASSES MILESTONE</a>. Nasa.gov. Retrieved on 2013-11-20.<a href="#fnref55">↩</a></li>
<li id="fn56"><a href="http://members.fortunecity.com/templarseries/popper.html">Roger Bridgman's defence of neural networks</a><a href="#fnref56">↩</a></li>
<li id="fn57"><a class="uri" href="http://www.iro.umontreal.ca/~lisa/publications2/index.php/publications/show/4">http://www.iro.umontreal.ca/~lisa/publications2/index.php/publications/show/4</a><a href="#fnref57">↩</a></li>
<li id="fn58">Sun and Bookman (1990)<a href="#fnref58">↩</a></li>
<li id="fn59"><a href="#fnref59">↩</a></li>
</ol>
</section>
</body>
</html>
