<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="390">Formal language</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Formal language</h1>
<hr/>

<p> In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <a href="computer_science" title="wikilink">computer science</a>, and <a class="uri" href="linguistics" title="wikilink">linguistics</a>, a <strong>formal language</strong> is a <a href="set_(mathematics)" title="wikilink">set</a> of <a href="string_(computer_science)" title="wikilink">strings</a> of <a href="symbol_(formal)" title="wikilink">symbols</a> that may be constrained by rules that are specific to it.</p>

<p>The <a href="Alphabet_(computer_science)" title="wikilink">alphabet</a> of a formal language is the set of symbols, letters, or tokens from which the strings of the language may be formed; frequently it is required to be <a href="finite_set" title="wikilink">finite</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The strings formed from this alphabet are called words, and the words that belong to a particular formal language are sometimes called <em>well-formed words</em> or <em><a href="well-formed_formula" title="wikilink">well-formed formulas</a></em>. A formal language is often defined by means of a <a href="formal_grammar" title="wikilink">formal grammar</a> such as a <a href="regular_grammar" title="wikilink">regular grammar</a> or <a href="context-free_grammar" title="wikilink">context-free grammar</a>, also called its <a href="formation_rule" title="wikilink">formation rule</a>.</p>

<p>The field of <strong>formal language theory</strong> studies primarily the purely <a href="syntax" title="wikilink">syntactical</a> aspects of such languages—that is, their internal structural patterns. Formal language theory sprang out of linguistics, as a way of understanding the syntactic regularities of <a href="natural_language" title="wikilink">natural languages</a>. In computer science, formal languages are used among others as the basis for defining the grammar of <a href="programming_language" title="wikilink">programming languages</a> and formalized versions of subsets of natural languages in which the words of the language represent concepts that are associated with particular meanings or <a class="uri" href="semantics" title="wikilink">semantics</a>. In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, <a href="decision_problem" title="wikilink">decision problems</a> are typically defined as formal languages, and <a href="complexity_class" title="wikilink">complexity classes</a> are defined as the sets of the formal languages that can be <a href="parser" title="wikilink">parsed by machines</a> with limited computational power. In <a class="uri" href="logic" title="wikilink">logic</a> and the <a href="foundations_of_mathematics" title="wikilink">foundations of mathematics</a>, formal languages are used to represent the syntax of <a href="axiomatic_system" title="wikilink">axiomatic systems</a>, and <a href="Formalism_(mathematics)" title="wikilink">mathematical formalism</a> is the philosophy that all of mathematics can be reduced to the syntactic manipulation of formal languages in this way.</p>
<h2 id="history">History</h2>

<p>The first formal language is thought be the one used by <a href="Gottlob_Frege" title="wikilink">Gottlob Frege</a> in his <em><a class="uri" href="Begriffsschrift" title="wikilink">Begriffsschrift</a></em> (1879), literally meaning "concept writing", and which Frege described as a "formal language of pure thought."<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p><a href="Axel_Thue" title="wikilink">Axel Thue</a>'s early <a href="Semi-Thue_system" title="wikilink">Semi-Thue system</a> which can be used for rewriting strings was influential on <a href="formal_grammar" title="wikilink">formal grammars</a>.</p>
<h2 id="words-over-an-alphabet">Words over an alphabet</h2>

<p>An <strong>alphabet</strong>, in the context of formal languages, can be any <a href="set_(mathematics)" title="wikilink">set</a>, although it often makes sense to use an <a class="uri" href="alphabet" title="wikilink">alphabet</a> in the usual sense of the word, or more generally a <a href="character_set" title="wikilink">character set</a> such as <a class="uri" href="ASCII" title="wikilink">ASCII</a> or <a class="uri" href="Unicode" title="wikilink">Unicode</a>. Alphabets can also be infinite; e.g. <a href="first-order_logic" title="wikilink">first-order logic</a> is often expressed using an alphabet which, besides symbols such as ∧, ¬, ∀ and parentheses, contains infinitely many elements <em>x</em><sub>0</sub>, <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, … that play the role of variables. The elements of an alphabet are called its <strong>letters</strong>.</p>

<p>A <strong>word</strong> over an alphabet can be any finite sequence, or <a href="string_(computer_science)" title="wikilink">string</a>, of characters or letters, which sometimes may include spaces, and are separated by specified word separation characters. The set of all words over an alphabet Σ is usually denoted by Σ<sup>*</sup> (using the <a href="Kleene_star" title="wikilink">Kleene star</a>). The length of a word is the number of characters or letters it is composed of. For any alphabet there is only one word of length 0, the <em>empty word</em>, which is often denoted by e, ε or λ. By <a class="uri" href="concatenation" title="wikilink">concatenation</a> one can combine two words to form a new word, whose length is the sum of the lengths of the original words. The result of concatenating a word with the empty word is the original word.</p>

<p>In some applications, especially in <a class="uri" href="logic" title="wikilink">logic</a>, the alphabet is also known as the <em>vocabulary</em> and words are known as <em>formulas</em> or <em>sentences</em>; this breaks the letter/word metaphor and replaces it by a word/sentence metaphor.</p>
<h2 id="definition">Definition</h2>

<p>A <strong>formal language</strong> <em>L</em> over an alphabet Σ is a <a class="uri" href="subset" title="wikilink">subset</a> of Σ<sup>*</sup>, that is, a set of <a href="#Words_over_an_alphabet" title="wikilink">words</a> over that alphabet. Sometimes the sets of words are grouped into expressions, whereas rules and constraints may be formulated for the creation of 'well-formed expressions'.</p>

<p>In computer science and mathematics, which do not usually deal with <a href="natural_language" title="wikilink">natural languages</a>, the adjective "formal" is often omitted as redundant.</p>

<p>While formal language theory usually concerns itself with formal languages that are described by some syntactical rules, the actual definition of the concept "formal language" is only as above: a (possibly infinite) set of finite-length strings composed from a given alphabet, no more nor less. In practice, there are many languages that can be described by rules, such as <a href="regular_language" title="wikilink">regular languages</a> or <a href="context-free_language" title="wikilink">context-free languages</a>. The notion of a <a href="formal_grammar" title="wikilink">formal grammar</a> may be closer to the intuitive concept of a "language," one described by syntactic rules. By an abuse of the definition, a particular formal language is often thought of as being equipped with a formal grammar that describes it.</p>
<h2 id="examples">Examples</h2>

<p>The following rules describe a formal language 

<math display="inline" id="Formal_language:0">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 over the alphabet Σ = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, +, = }:</p>
<ul>
<li>Every nonempty string that does not contain "+" or "=" and does not start with "0" is in 

<math display="inline" id="Formal_language:1">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

.</li>
<li>The string "0" is in 

<math display="inline" id="Formal_language:2">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

.</li>
<li>A string containing "=" is in 

<math display="inline" id="Formal_language:3">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>


 if and only if there is exactly one "=", and it separates two valid strings of 

<math display="inline" id="Formal_language:4">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

.</li>
<li>A string containing "+" but not "=" is in 

<math display="inline" id="Formal_language:5">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 if and only if every "+" in the string separates two valid strings of 

<math display="inline" id="Formal_language:6">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

.</li>
<li>No string is in 

<math display="inline" id="Formal_language:7">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 other than those implied by the previous rules.</li>
</ul>

<p>Under these rules, the string "23+4=555" is in 

<math display="inline" id="Formal_language:8">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>


, but the string "=234=+" is not. This formal language expresses <a href="natural_number" title="wikilink">natural numbers</a>, well-formed addition statements, and well-formed addition equalities, but it expresses only what they look like (their <a class="uri" href="syntax" title="wikilink">syntax</a>), not what they mean (<a class="uri" href="semantics" title="wikilink">semantics</a>). For instance, nowhere in these rules is there any indication that "0" means the number zero, or that "+" means addition.</p>
<h3 id="constructions">Constructions</h3>

<p>For finite languages one can explicitly enumerate all well-formed words. For example, we can describe a language 

<math display="inline" id="Formal_language:9">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 as just 

<math display="inline" id="Formal_language:10">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 = {"a", "b", "ab", "cba"}. The <a href="degeneracy_(mathematics)" title="wikilink">degenerate</a> case of this construction is the <strong>empty language</strong>, which contains no words at all (<span class="nounderlines">

<math display="inline" id="Formal_language:11">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 = <a class="uri" href="∅" title="wikilink">∅</a></span>).</p>

<p>However, even over a finite (non-empty) alphabet such as Σ = {a, b} there are infinitely many words: "a", "abb", "ababba", "aaababbbbaab", …. Therefore formal languages are typically infinite, and describing an infinite formal language is not as simple as writing <em>L</em> = {"a", "b", "ab", "cba"}. Here are some examples of formal languages:</p>
<ul>
<li>

<math display="inline" id="Formal_language:12">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 = Σ<sup>*</sup>, the set of <em>all</em> words over Σ;</li>
<li>

<math display="inline" id="Formal_language:13">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>


 = {"a"}<sup>*</sup> = {"a"<sup><em>n</em></sup>}, where <em>n</em> ranges over the natural numbers and "a"<sup><em>n</em></sup> means "a" repeated <em>n</em> times (this is the set of words consisting only of the symbol "a");</li>
<li>the set of syntactically correct programs in a given programming language (the syntax of which is usually defined by a <a href="context-free_grammar" title="wikilink">context-free grammar</a>);</li>
<li>the set of inputs upon which a certain <a href="Turing_machine" title="wikilink">Turing machine</a> halts; or</li>
<li>the set of maximal strings of <a class="uri" href="alphanumeric" title="wikilink">alphanumeric</a> <a class="uri" href="ASCII" title="wikilink">ASCII</a> characters on this line, i.e., the set {"the", "set", "of", "maximal", "strings", "alphanumeric", "ASCII", "characters", "on", "this", "line", "i", "e"}.</li>
</ul>
<h2 id="language-specification-formalisms">Language-specification formalisms</h2>

<p>Formal language theory rarely concerns itself with particular languages (except as examples), but is mainly concerned with the study of various types of formalisms to describe languages. For instance, a language can be given as</p>
<ul>
<li>those strings generated by some <a href="formal_grammar" title="wikilink">formal grammar</a>;</li>
<li>those strings described or matched by a particular <a href="regular_expression" title="wikilink">regular expression</a>;</li>
<li>those strings accepted by some <a href="Automata_theory" title="wikilink">automaton</a>, such as a <a href="Turing_machine" title="wikilink">Turing machine</a> or <a href="Finite_state_machine" title="wikilink">finite state automaton</a>;</li>
<li>those strings for which some <a href="decision_problem" title="wikilink">decision procedure</a> (an <a class="uri" href="algorithm" title="wikilink">algorithm</a> that asks a sequence of related YES/NO questions) produces the answer YES.</li>
</ul>

<p>Typical questions asked about such formalisms include:</p>
<ul>
<li>What is their expressive power? (Can formalism <em>X</em> describe every language that formalism <em>Y</em> can describe? Can it describe other languages?)</li>
<li>What is their recognizability? (How difficult is it to decide whether a given word belongs to a language described by formalism <em>X</em>?)</li>
<li>What is their comparability? (How difficult is it to decide whether two languages, one described in formalism <em>X</em> and one in formalism <em>Y</em>, or in <em>X</em> again, are actually the same language?).</li>
</ul>

<p>Surprisingly often, the answer to these decision problems is "it cannot be done at all", or "it is extremely expensive" (with a characterization of how expensive). Therefore, formal language theory is a major application area of <a href="Computability_theory_(computer_science)" title="wikilink">computability theory</a> and <a href="computational_complexity_theory" title="wikilink">complexity theory</a>. Formal languages may be classified in the <a href="Chomsky_hierarchy" title="wikilink">Chomsky hierarchy</a> based on the expressive power of their generative grammar as well as the complexity of their recognizing <a href="automata_theory" title="wikilink">automaton</a>. <a href="Context-free_grammar" title="wikilink">Context-free grammars</a> and <a href="regular_grammar" title="wikilink">regular grammars</a> provide a good compromise between expressivity and ease of <a class="uri" href="parsing" title="wikilink">parsing</a>, and are widely used in practical applications.</p>
<h2 id="operations-on-languages">Operations on languages</h2>

<p>Certain operations on languages are common. This includes the standard set operations, such as union, intersection, and complement. Another class of operation is the element-wise application of string operations.</p>

<p>Examples: suppose <em>L</em><sub>1</sub> and <em>L</em><sub>2</sub> are languages over some common alphabet.</p>
<ul>
<li>The <em><a class="uri" href="concatenation" title="wikilink">concatenation</a></em> <em>L</em><sub>1</sub><em>L</em><sub>2</sub> consists of all strings of the form <em>vw</em> where <em>v</em> is a string from <em>L</em><sub>1</sub> and <em>w</em> is a string from <em>L</em><sub>2</sub>.</li>
<li>The <em>intersection</em> <em>L</em><sub>1</sub> ∩ <em>L</em><sub>2</sub> of <em>L</em><sub>1</sub> and <em>L</em><sub>2</sub> consists of all strings which are contained in both languages</li>
<li>The <em>complement</em> ¬<em>L</em> of a language with respect to a given alphabet consists of all strings over the alphabet that are not in the language.</li>
<li>The <a href="Kleene_star" title="wikilink">Kleene star</a>: the language consisting of all words that are concatenations of 0 or more words in the original language;</li>
<li><em>Reversal</em>:
<ul>
<li>Let <em>e</em> be the empty word, then <em>e<sup>R</sup></em> = <em>e</em>, and</li>
<li>for each non-empty word <em>w</em> = <em>x</em><sub>1</sub>…<em>x<sub>n</sub></em> over some alphabet, let <em>w<sup>R</sup></em> = <em>x</em><sub>n</sub>…<em>x<sub>1</sub></em>,</li>
<li>then for a formal language <em>L</em>, <em>L<sup>R</sup> = {</em>w<sup>R</sup> | <em>w</em> ∈ <em>L</em>}.</li>
</ul></li>
<li><a href="String_homomorphism" title="wikilink">String homomorphism</a></li>
</ul>

<p>Such <a href="string_operations" title="wikilink">string operations</a> are used to investigate <a href="Closure_(mathematics)" title="wikilink">closure properties</a> of classes of languages. A class of languages is closed under a particular operation when the operation, applied to languages in the class, always produces a language in the same class again. For instance, the <a href="context-free_language" title="wikilink">context-free languages</a> are known to be closed under union, concatenation, and intersection with <a href="regular_language" title="wikilink">regular languages</a>, but not closed under intersection or complement. The theory of <a href="cone_(formal_languages)" title="wikilink">trios</a> and <a href="abstract_family_of_languages" title="wikilink">abstract families of languages</a> studies the most common closure properties of language families in their own right.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Closure properties of language families (

<math display="inline" id="Formal_language:14">
 <semantics>
  <msub>
   <mi>L</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{1}
  </annotation>
 </semantics>
</math>

 Op 

<math display="inline" id="Formal_language:15">
 <semantics>
  <msub>
   <mi>L</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{2}
  </annotation>
 </semantics>
</math>

 where both 

<math display="inline" id="Formal_language:16">
 <semantics>
  <msub>
   <mi>L</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Formal_language:17">
 <semantics>
  <msub>
   <mi>L</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{2}
  </annotation>
 </semantics>
</math>

 are in the language family given by the column). After Hopcroft and Ullman.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Operation</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Union_(set_theory)" title="wikilink">Union</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Intersection_(set_theory)" title="wikilink">Intersection</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Complement_(set_theory)" title="wikilink">Complement</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="Concatenation" title="wikilink">Concatenation</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Kleene star</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Homomorphism</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>e-free Homomorphism</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Substitution</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Inverse Homomorphism</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Reverse</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Intersection with a <a href="regular_language" title="wikilink">regular language</a></p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<h2 id="applications">Applications</h2>
<h3 id="programming-languages">Programming languages</h3>

<p>A compiler usually has two distinct components. A <a href="lexical_analyzer" title="wikilink">lexical analyzer</a>, generated by a tool like <a href="lex_programming_tool" title="wikilink"><code>lex</code></a>, identifies the tokens of the programming language grammar, e.g. <a href="identifier" title="wikilink">identifiers</a> or <a href="Keyword_(computer_programming)" title="wikilink">keywords</a>, which are themselves expressed in a simpler formal language, usually by means of <a href="regular_expressions" title="wikilink">regular expressions</a>. At the most basic conceptual level, a <a class="uri" href="parser" title="wikilink">parser</a>, usually generated by a <a href="parser_generator" title="wikilink">parser generator</a> like <code>[[yacc]]</code>, attempts to decide if the source program is valid, that is if it belongs to the programming language for which the compiler was built. Of course, compilers do more than just parse the source code—they usually translate it into some executable format. Because of this, a parser usually outputs more than a yes/no answer, typically an <a href="abstract_syntax_tree" title="wikilink">abstract syntax tree</a>, which is used by subsequent stages of the compiler to eventually generate an <a class="uri" href="executable" title="wikilink">executable</a> containing <a href="machine_code" title="wikilink">machine code</a> that runs directly on the hardware, or some <a href="intermediate_code" title="wikilink">intermediate code</a> that requires a <a href="virtual_machine" title="wikilink">virtual machine</a> to execute.</p>
<h3 id="formal-theories-systems-and-proofs">Formal theories, systems and proofs</h3>
<figure><b>(Figure)</b>
<figcaption>This diagram shows the <a href="Syntax_(logic)" title="wikilink">syntactic</a> divisions within a <a href="formal_system" title="wikilink">formal system</a>. <a href="string_(computer_science)" title="wikilink">Strings of symbols</a> may be broadly divided into nonsense and <a href="well-formed_formula" title="wikilink">well-formed formulas</a>. The set of well-formed formulas is divided into <a href="theorem" title="wikilink">theorems</a> and non-theorems.</figcaption>
</figure>

<p>In <a href="mathematical_logic" title="wikilink">mathematical logic</a>, a <em>formal theory</em> is a set of <a href="sentence_(mathematical_logic)" title="wikilink">sentences</a> expressed in a formal language.</p>

<p>A <em>formal system</em> (also called a <em>logical calculus</em>, or a <em>logical system</em>) consists of a formal language together with a <a href="deductive_apparatus" title="wikilink">deductive apparatus</a> (also called a <em>deductive system</em>). The deductive apparatus may consist of a set of <a href="transformation_rule" title="wikilink">transformation rules</a> which may be interpreted as valid rules of inference or a set of <a href="axiom" title="wikilink">axioms</a>, or have both. A formal system is used to <a href="Proof_theory" title="wikilink">derive</a> one expression from one or more other expressions. Although a formal language can be identified with its formulas, a formal system cannot be likewise identified by its theorems. Two formal systems 

<math display="inline" id="Formal_language:18">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℱ</mi>
   <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ℱ</ci>
    <ci>𝒮</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{FS}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Formal_language:19">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℱ</mi>
   <msup>
    <mi class="ltx_font_mathcaligraphic">𝒮</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ℱ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝒮</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{FS^{\prime}}
  </annotation>
 </semantics>
</math>

 may have all the same theorems and yet differ in some significant proof-theoretic way (a formula A may be a syntactic consequence of a formula B in one but not another for instance).</p>

<p>A <em>formal proof</em> or <em>derivation</em> is a finite sequence of well-formed formulas (which may be interpreted as <a href="proposition" title="wikilink">propositions</a>) each of which is an axiom or follows from the preceding formulas in the sequence by a <a href="rule_of_inference" title="wikilink">rule of inference</a>. The last sentence in the sequence is a theorem of a formal system. Formal proofs are useful because their theorems can be interpreted as true propositions.</p>
<h4 id="interpretations-and-models">Interpretations and models</h4>

<p>Formal languages are entirely syntactic in nature but may be given <a class="uri" href="semantics" title="wikilink">semantics</a> that give meaning to the elements of the language. For instance, in mathematical <a class="uri" href="logic" title="wikilink">logic</a>, the set of possible formulas of a particular logic is a formal language, and an <a href="interpretation_(logic)" title="wikilink">interpretation</a> assigns a meaning to each of the formulas—usually, a <a href="truth_value" title="wikilink">truth value</a>.</p>

<p>The study of interpretations of formal languages is called <a href="Formal_semantics_(logic)" title="wikilink">formal semantics</a>. In mathematical logic, this is often done in terms of <a href="model_theory" title="wikilink">model theory</a>. In model theory, the terms that occur in a formula are interpreted as <a href="Structure_(mathematical_logic)" title="wikilink">mathematical structures</a>, and fixed compositional interpretation rules determine how the truth value of the formula can be derived from the interpretation of its terms; a <em>model</em> for a formula is an interpretation of terms such that the formula becomes true.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Combinatorics_on_words" title="wikilink">Combinatorics on words</a></li>
<li><a href="Grammar_framework" title="wikilink">Grammar framework</a></li>
<li><a href="Formal_method" title="wikilink">Formal method</a></li>
<li><a href="Mathematical_notation" title="wikilink">Mathematical notation</a></li>
<li><a href="Associative_array" title="wikilink">Associative array</a></li>
<li><a href="String_(computer_science)" title="wikilink">String (computer science)</a></li>
</ul>
<h2 id="references">References</h2>
<h3 id="citation-footnotes">Citation footnotes</h3>
<h3 id="general-references">General references</h3>
<ul>
<li>A. G. Hamilton, <em>Logic for Mathematicians</em>, <a href="Cambridge_University_Press" title="wikilink">Cambridge University Press</a>, 1978, ISBN 0-521-21838-1.</li>
<li><a href="Seymour_Ginsburg" title="wikilink">Seymour Ginsburg</a>, <em>Algebraic and automata theoretic properties of formal languages</em>, North-Holland, 1975, ISBN 0-7204-2506-9.</li>
<li><a href="Michael_A._Harrison" title="wikilink">Michael A. Harrison</a>, <em>Introduction to Formal Language Theory</em>, Addison-Wesley, 1978.</li>
<li><a href="John_Hopcroft" title="wikilink">John E. Hopcroft</a> and <a href="Jeffrey_Ullman" title="wikilink">Jeffrey D. Ullman</a>, <em><a href="Introduction_to_Automata_Theory,_Languages,_and_Computation" title="wikilink">Introduction to Automata Theory, Languages, and Computation</a></em>, Addison-Wesley Publishing, Reading Massachusetts, 1979. ISBN 81-7808-347-7.</li>
<li>

<p>.</p></li>
<li><a href="Grzegorz_Rozenberg" title="wikilink">Grzegorz Rozenberg</a>, <a href="Arto_Salomaa" title="wikilink">Arto Salomaa</a>, <em>Handbook of Formal Languages: Volume I-III</em>, Springer, 1997, ISBN 3-540-61486-9.</li>
<li>Patrick Suppes, <em>Introduction to Logic</em>, D. Van Nostrand, 1957, ISBN 0-442-08072-7.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li><a href="University_of_Maryland,_Baltimore" title="wikilink">University of Maryland</a>, <a href="http://www.csee.umbc.edu/help/theory/lang_def.shtml">Formal Language Definitions</a></li>
<li>James Power, <a href="http://www.cs.nuim.ie/~jpower/Courses/parsing/">"Notes on Formal Language Theory and Parsing"</a>, 29 November 2002.</li>
</ul>
<ul>
<li>Drafts of some chapters in the "Handbook of Formal Language Theory", Vol. 1-3, G. Rozenberg and A. Salomaa (eds.), <a href="Springer_Verlag" title="wikilink">Springer Verlag</a>, (1997):
<ul>
<li>Alexandru Mateescu and Arto Salomaa, <a href="http://www.cs.cmu.edu/~lkontor/noam/Mateescu-Salomaa.pdf">"Preface" in Vol.1, pp. v-viii, and "Formal Languages: An Introduction and a Synopsis", Chapter 1 in Vol. 1, pp.1-39</a></li>
<li>Sheng Yu, <a href="http://www.csd.uwo.ca/~syu/public/draft.ps">"Regular Languages", Chapter 2 in Vol. 1</a></li>
<li>Jean-Michel Autebert, Jean Berstel, Luc Boasson, <a href="http://citeseer.ist.psu.edu/248295.html">"Context-Free Languages and Push-Down Automata", Chapter 3 in Vol. 1</a></li>
<li>Christian Choffrut and Juhani Karhumäki, <a href="http://www.liafa.jussieu.fr/~cc/PUBLICATIONS/CKTUCS.PS.gz">"Combinatorics of Words", Chapter 6 in Vol. 1</a></li>
<li>Tero Harju and Juhani Karhumäki, <a href="http://users.utu.fi/harju/articles/morph.pdf">"Morphisms", Chapter 7 in Vol. 1, pp. 439 - 510</a></li>
<li>Jean-Eric Pin, <a href="http://www.liafa.jussieu.fr/~jep/PDF/HandBook.pdf">"Syntactic semigroups", Chapter 10 in Vol. 1, pp. 679-746</a></li>
<li>M. Crochemore and C. Hancart, <a href="http://www-igm.univ-mlv.fr/~mac/REC/DOC/B4.ps">"Automata for matching patterns", Chapter 9 in Vol. 2</a></li>
<li>Dora Giammarresi, Antonio Restivo, <a href="http://bruno.maitresdumonde.com/optinfo/Spe-MP/dmds1998/2dlang/giammaresi-restivo-paper.ps">"Two-dimensional Languages", Chapter 4 in Vol. 3, pp. 215 - 267</a></li>
</ul></li>
</ul>

<p>"</p>

<p><a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a> <a href="Category:Theoretical_computer_science" title="wikilink">Category:Theoretical computer science</a> <a href="Category:Combinatorics_on_words" title="wikilink">Category:Combinatorics on words</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">See e.g. .<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">, Chapter 11: Closure properties of families of languages.<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
