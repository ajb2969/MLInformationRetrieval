   Pebble automaton      Pebble automaton   In computer science , a pebble automaton is an extension of tree walking automata which allows the automaton to use a finite amount of "pebbles", used for marking tree node. The result is a model stronger than ordinary tree walking automata, but still strictly weaker than branching automata .  Definitions  A pebble automaton is a tree walking automaton with an additional finite set of fixed size containing pebbles, identified with    {  1  ,  2  ,  …  ,  n  }     1  2  normal-…  n    \{1,2,\dots,n\}   . Besides ordinary actions, an automaton can put a pebble at a currently visited node, lift a pebble from the currently visited node and perform a test "is the i-th pebble present at the current node?". There is an important stack restriction on the order in which pebbles can be put or lifted - the i+1-th pebble can be put only if the pebbles from 1st to i-th are already on the tree, and the i+1-th pebble can be lifted only if pebbles from i+2-th to n-th are not on the tree. Without this restriction, the automaton has undecidable emptiness and expressive power beyond regular tree languages.  The class of languages recognized by deterministic (resp. nondeterministic) pebble automata with n pebbles is denoted    D  P   A  n       D  P   subscript  A  n     DPA_{n}   (resp.    P   A  n       P   subscript  A  n     PA_{n}   ). We also define     D  P  A   =    ⋃  n    D  P   A  n           D  P  A     subscript   n     D  P   subscript  A  n       DPA=\bigcup_{n}DPA_{n}   and likewise     P  A   =    ⋃  n    P   A  n           P  A     subscript   n     P   subscript  A  n       PA=\bigcup_{n}PA_{n}   .  Properties   there exists a language recognized by a pebble automaton with 1 pebble, but not by any tree walking automaton; this implies that either     T  W  A   ⊊   D  P  A         T  W  A     D  P  A     TWA\subsetneq DPA   or these classes are incomparable, which is an open problem       P  A   ⊊   R  E  G         P  A     R  E  G     PA\subsetneq REG   , i.e. pebble automata are strictly weaker than branching automata  it is not known whether     D  P  A   =   P  A         D  P  A     P  A     DPA=PA   , i.e. whether pebble automata can be determinized  it is not known whether pebble automata are closed under complementation  the pebble hierarchy is strict, for every n     P   A  n    ⊊   P   A   n  +  1           P   subscript  A  n      P   subscript  A    n  1       PA_{n}\subsetneq PA_{n+1}   and     D  P   A  n    ⊊   D  P   A   n  +  1           D  P   subscript  A  n      D  P   subscript  A    n  1       DPA_{n}\subsetneq DPA_{n+1}      Automata and logic  Pebble automata admit an interesting logical characterization. Let     F  O   +   T  C         F  O     T  C     FO+TC   denote the set of tree properties describable in transitive closure first-order logic , and     F  O   +    pos   T  C         F  O     pos  T  C     FO+\text{pos}\,TC   the same for positive transitive closure logic, i.e. a logic where the transitive closure operator is not used under the scope of negation. Then it can be proved that     P  A   ⊆    F  O   +   T  C          P  A       F  O     T  C      PA\subseteq FO+TC   and, in fact,     P  A   =    F  O   +    pos   T  C          P  A       F  O     pos  T  C      PA=FO+\text{pos}\,TC   - the languages recognized by pebble automata are exactly those expressible in positive transitive closure logic.  See also   Tree walking automata  Branching automata  Transitive closure logic   "  Category:Trees (data structures)  Category:Automata theory   