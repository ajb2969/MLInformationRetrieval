<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1915">Stochastic gradient descent</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Stochastic gradient descent</h1>
<hr/>

<p><strong>Stochastic gradient descent</strong> is a <a href="gradient_descent_optimization" title="wikilink">gradient descent optimization</a> <a href="iterative_method" title="wikilink">method</a> for minimizing an <a href="objective_function" title="wikilink">objective function</a> that is written as a sum of differentiable functions.</p>
<h2 id="background">Background</h2>

<p>Both <a href="statistics" title="wikilink">statistical</a> <a href="M-estimation" title="wikilink">estimation</a> and <a href="machine_learning" title="wikilink">machine learning</a> consider the problem of minimizing an <a href="objective_function" title="wikilink">objective function</a> that has the form of a sum:</p>

<p>

<math display="block" id="Stochastic_gradient_descent:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>w</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>Q</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>w</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>w</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>i</ci>
      </apply>
      <ci>w</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(w)=\sum_{i=1}^{n}Q_{i}(w),
  </annotation>
 </semantics>
</math>

 where the <a href="parametric_statistics" title="wikilink">parameter</a> 

<math display="inline" id="Stochastic_gradient_descent:1">
 <semantics>
  <msup>
   <mi>w</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>w</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{*}
  </annotation>
 </semantics>
</math>

 which minimizes 

<math display="inline" id="Stochastic_gradient_descent:2">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(w)
  </annotation>
 </semantics>
</math>

 is to be <a href="estimator" title="wikilink">estimated</a>. Each summand function 

<math display="inline" id="Stochastic_gradient_descent:3">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{i}
  </annotation>
 </semantics>
</math>

 is typically associated with the 

<math display="inline" id="Stochastic_gradient_descent:4">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th <a class="uri" href="observation" title="wikilink">observation</a> in the <a href="data_set" title="wikilink">data set</a> (used for training).</p>

<p>In classical statistics, sum-minimization problems arise in <a href="least_squares" title="wikilink">least squares</a> and in <a href="maximum-likelihood_estimation" title="wikilink">maximum-likelihood estimation</a> (for independent observations). The general class of estimators that arise as minimizers of sums are called <a href="M-estimator" title="wikilink">M-estimators</a>. However, in statistics, it has been long recognized that requiring even local minimization is too restrictive for some problems of maximum-likelihood estimation, as shown for example by Thomas Ferguson's example.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Therefore, contemporary statistical theorists often consider <a href="stationary_point" title="wikilink">stationary points</a> of the <a href="likelihood_function" title="wikilink">likelihood function</a> (or zeros of its derivative, the <a href="Score_(statistics)" title="wikilink">score function</a>, and other <a href="estimating_equations" title="wikilink">estimating equations</a>).</p>

<p>The sum-minimization problem also arises for <a href="empirical_risk_minimization" title="wikilink">empirical risk minimization</a>: In this case, 

<math display="inline" id="Stochastic_gradient_descent:5">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>i</ci>
    </apply>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{i}(w)
  </annotation>
 </semantics>
</math>

 is the value of the <a href="loss_function" title="wikilink">loss function</a> at 

<math display="inline" id="Stochastic_gradient_descent:6">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th example, and 

<math display="inline" id="Stochastic_gradient_descent:7">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(w)
  </annotation>
 </semantics>
</math>

 is the empirical risk.</p>

<p>When used to minimize the above function, a standard (or "batch") <a href="gradient_descent" title="wikilink">gradient descent</a> method would perform the following iterations :</p>

<p>

<math display="block" id="Stochastic_gradient_descent:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mo>:=</mo>
    <mrow>
     <mi>w</mi>
     <mo>-</mo>
     <mrow>
      <mi>η</mi>
      <mrow>
       <mo>∇</mo>
       <mi>Q</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>w</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>w</mi>
     <mo>-</mo>
     <mrow>
      <mi>η</mi>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>n</mi>
       </munderover>
       <mrow>
        <mrow>
         <mo>∇</mo>
         <msub>
          <mi>Q</mi>
          <mi>i</mi>
         </msub>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>w</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <ci>w</ci>
     <apply>
      <minus></minus>
      <ci>w</ci>
      <apply>
       <times></times>
       <ci>η</ci>
       <apply>
        <ci>normal-∇</ci>
        <ci>Q</ci>
       </apply>
       <ci>w</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <ci>w</ci>
      <apply>
       <times></times>
       <ci>η</ci>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <ci>normal-∇</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>Q</ci>
           <ci>i</ci>
          </apply>
         </apply>
         <ci>w</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w:=w-\eta\nabla Q(w)=w-\eta\sum_{i=1}^{n}\nabla Q_{i}(w),
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Stochastic_gradient_descent:9">
 <semantics>
  <mi>η</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>η</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta
  </annotation>
 </semantics>
</math>

 is a step size (sometimes called the <em>learning rate</em> in machine learning).</p>

<p>In many cases, the summand functions have a simple form that enables inexpensive evaluations of the sum-function and the sum gradient. For example, in statistics, <a href="exponential_families" title="wikilink">one-parameter exponential families</a> allow economical function-evaluations and gradient-evaluations.</p>

<p>However, in other cases, evaluating the sum-gradient may require expensive evaluations of the gradients from all summand functions. When the training set is enormous and no simple formulas exist, evaluating the sums of gradients becomes very expensive, because evaluating the gradient requires evaluating all the summand functions' gradients. To economize on the computational cost at every iteration, stochastic gradient descent <a href="sampling_(statistics)" title="wikilink">samples</a> a subset of summand functions at every step. This is very effective in the case of large-scale machine learning problems.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="iterative-method">Iterative method</h2>
<figure><b>(Figure)</b>
<figcaption>Fluctuations in the total objective function as gradient steps with respect to mini-batches are taken.</figcaption>
</figure>

<p>In stochastic (or "on-line") gradient descent, the true gradient of 

<math display="inline" id="Stochastic_gradient_descent:10">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(w)
  </annotation>
 </semantics>
</math>

 is approximated by a gradient at a single example:</p>

<p>

<math display="block" id="Stochastic_gradient_descent:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mo>:=</mo>
    <mrow>
     <mi>w</mi>
     <mo>-</mo>
     <mrow>
      <mi>η</mi>
      <mrow>
       <mo>∇</mo>
       <msub>
        <mi>Q</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>w</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>w</ci>
    <apply>
     <minus></minus>
     <ci>w</ci>
     <apply>
      <times></times>
      <ci>η</ci>
      <apply>
       <ci>normal-∇</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <ci>w</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w:=w-\eta\nabla Q_{i}(w).
  </annotation>
 </semantics>
</math>

 As the algorithm sweeps through the training set, it performs the above update for each training example. Several passes can be made over the training set until the algorithm converges. If this is done, the data can be shuffled for each pass to prevent cycles. Typical implementations may use an adaptive learning rate so that the algorithm converges.</p>

<p>In pseudocode, stochastic gradient descent can be presented as follows:</p>
<div style="margin-left: 35px; width: 600px">
<ul>
<li>Choose an initial vector of parameters 

<math display="inline" id="Stochastic_gradient_descent:12">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 and learning rate 

<math display="inline" id="Stochastic_gradient_descent:13">
 <semantics>
  <mi>η</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>η</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta
  </annotation>
 </semantics>
</math>

.</li>
<li>Repeat until an approximate minimum is obtained:
<ul>
<li>Randomly shuffle examples in the training set.</li>
<li>For 

<math display="inline" id="Stochastic_gradient_descent:14">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>i</mi>
   </mpadded>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!i=1,2,...,n
  </annotation>
 </semantics>
</math>

, do:
<ul>
<li>

<math display="inline" id="Stochastic_gradient_descent:15">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>w</mi>
    </mpadded>
    <mo>:=</mo>
    <mrow>
     <mi>w</mi>
     <mo>-</mo>
     <mrow>
      <mi>η</mi>
      <mrow>
       <mo>∇</mo>
       <msub>
        <mi>Q</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>w</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>w</ci>
    <apply>
     <minus></minus>
     <ci>w</ci>
     <apply>
      <times></times>
      <ci>η</ci>
      <apply>
       <ci>normal-∇</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <ci>w</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!w:=w-\eta\nabla Q_{i}(w).
  </annotation>
 </semantics>
</math>

</li>
</ul></li>
</ul></li>
</ul>
</div>

<p>A compromise between the two forms called "mini-batches" computes the gradient against more than one training examples at each step. This can perform significantly better than true stochastic gradient descent because the code can make use of vectorization libraries rather than computing each step separately. It may also result in smoother convergence, as the gradient computed at each step uses more training examples.</p>

<p>The convergence of stochastic gradient descent has been analyzed using the theories of <a href="convex_optimization" title="wikilink">convex minimization</a> and of <a href="stochastic_approximation" title="wikilink">stochastic approximation</a>. Briefly, when the learning rates 

<math display="inline" id="Stochastic_gradient_descent:16">
 <semantics>
  <mi>η</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>η</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta
  </annotation>
 </semantics>
</math>

 decrease with an appropriate rate, and subject to relatively mild assumptions, stochastic gradient descent converges almost surely to a global minimum when the objective function is <a href="convex_function" title="wikilink">convex</a> or <a href="pseudoconvex_function" title="wikilink">pseudoconvex</a>, and otherwise converges almost surely to a local minimum.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> This is in fact a consequence of the Robbins-Siegmund theorem.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="example">Example</h2>

<p>Let's suppose we want to fit a straight line 

<math display="inline" id="Stochastic_gradient_descent:17">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo rspace="0.8pt">=</mo>
   <mrow>
    <msub>
     <mi>w</mi>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>w</mi>
      <mn>2</mn>
     </msub>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=\!w_{1}+w_{2}x
  </annotation>
 </semantics>
</math>

 to a training set of two-dimensional points 

<math display="inline" id="Stochastic_gradient_descent:18">
 <semantics>
  <mrow>
   <mrow>
    <mo lspace="0.8pt" stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
    <ci>normal-…</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </interval>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!(x_{1},y_{1}),\ldots,(x_{n},y_{n})
  </annotation>
 </semantics>
</math>

 using <a href="least_squares" title="wikilink">least squares</a>. The objective function to be minimized is:</p>

<p>

<math display="block" id="Stochastic_gradient_descent:19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>w</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>Q</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>w</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <msup>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mrow>
         <msub>
          <mi>w</mi>
          <mn>1</mn>
         </msub>
         <mo>+</mo>
         <mrow>
          <msub>
           <mi>w</mi>
           <mn>2</mn>
          </msub>
          <msub>
           <mi>x</mi>
           <mi>i</mi>
          </msub>
         </mrow>
        </mrow>
        <mo>-</mo>
        <msub>
         <mi>y</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>w</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>i</ci>
       </apply>
       <ci>w</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>w</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>w</ci>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(w)=\sum_{i=1}^{n}Q_{i}(w)=\sum_{i=1}^{n}\left(w_{1}+w_{2}x_{i}-y_{i}\right)^%
{2}.
  </annotation>
 </semantics>
</math>

</p>

<p>The last line in the above pseudocode for this specific problem will become:</p>

<p>

<math display="block" id="Stochastic_gradient_descent:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>w</mi>
         <mn>1</mn>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>w</mi>
         <mn>2</mn>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mo>:=</mo>
    <mrow>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>w</mi>
          <mn>1</mn>
         </msub>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>w</mi>
          <mn>2</mn>
         </msub>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>η</mi>
      <mrow>
       <mo>[</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mrow>
           <mn>2</mn>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mrow>
              <msub>
               <mi>w</mi>
               <mn>1</mn>
              </msub>
              <mo>+</mo>
              <mrow>
               <msub>
                <mi>w</mi>
                <mn>2</mn>
               </msub>
               <msub>
                <mi>x</mi>
                <mi>i</mi>
               </msub>
              </mrow>
             </mrow>
             <mo>-</mo>
             <msub>
              <mi>y</mi>
              <mi>i</mi>
             </msub>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mrow>
           <mn>2</mn>
           <msub>
            <mi>x</mi>
            <mi>i</mi>
           </msub>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mrow>
              <msub>
               <mi>w</mi>
               <mn>1</mn>
              </msub>
              <mo>+</mo>
              <mrow>
               <msub>
                <mi>w</mi>
                <mn>2</mn>
               </msub>
               <msub>
                <mi>x</mi>
                <mi>i</mi>
               </msub>
              </mrow>
             </mrow>
             <mo>-</mo>
             <msub>
              <mi>y</mi>
              <mi>i</mi>
             </msub>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mtd>
        </mtr>
       </mtable>
       <mo>]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <cn type="integer">1</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <cn type="integer">2</cn>
      </apply>
     </matrixrow>
    </matrix>
    <apply>
     <minus></minus>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <cn type="integer">2</cn>
       </apply>
      </matrixrow>
     </matrix>
     <apply>
      <times></times>
      <ci>η</ci>
      <matrix>
       <matrixrow>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <minus></minus>
          <apply>
           <plus></plus>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>w</ci>
            <cn type="integer">1</cn>
           </apply>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>w</ci>
             <cn type="integer">2</cn>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <ci>i</ci>
            </apply>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
       </matrixrow>
       <matrixrow>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <minus></minus>
          <apply>
           <plus></plus>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>w</ci>
            <cn type="integer">1</cn>
           </apply>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>w</ci>
             <cn type="integer">2</cn>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <ci>i</ci>
            </apply>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}w_{1}\\
w_{2}\end{bmatrix}:=\begin{bmatrix}w_{1}\\
w_{2}\end{bmatrix}-\eta\begin{bmatrix}2(w_{1}+w_{2}x_{i}-y_{i})\\
2x_{i}(w_{1}+w_{2}x_{i}-y_{i})\end{bmatrix}.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="applications">Applications</h2>

<p>Stochastic gradient descent is a popular algorithm for training a wide range of models in <a href="machine_learning" title="wikilink">machine learning</a>, including (linear) <a href="support_vector_machine" title="wikilink">support vector machines</a>, <a href="logistic_regression" title="wikilink">logistic regression</a> (see, e.g., <a href="Vowpal_Wabbit" title="wikilink">Vowpal Wabbit</a>) and <a href="graphical_model" title="wikilink">graphical models</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> When combined with the <a class="uri" href="backpropagation" title="wikilink">backpropagation</a> algorithm, it is the <em>de facto</em> standard algorithm for training <a href="artificial_neural_network" title="wikilink">artificial neural networks</a>.</p>

<p>SGD competes with the <a href="limited-memory_BFGS" title="wikilink">L-BFGS</a> algorithm, which is also widely used. SGD has been used since at least 1960 for training <a href="linear_regression" title="wikilink">linear regression</a> models, originally under the name <a class="uri" href="ADALINE" title="wikilink">ADALINE</a>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>Another popular stochastic gradient descent algorithm is the <a href="Least_mean_squares_filter" title="wikilink">least mean squares (LMS)</a> adaptive filter.</p>
<h2 id="extensions-and-variants">Extensions and variants</h2>

<p>Many improvements on the basic SGD algorithm have been proposed and used. In particular, in machine learning, the need to set a learning rate (step size) has been recognized as problematic. Setting this parameter too high can cause the algorithm to diverge; setting it too low makes it slow to converge. A conceptually simple extension of SGD makes the learning rate a decreasing function <mtpl></mtpl> of the iteration number 

<math display="inline" id="Stochastic_gradient_descent:21">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, giving a <em>learning rate schedule</em>, so that the first iterations cause large changes in the parameters, while the later ones do only fine-tuning. Such schedules have been known since the work of MacQueen on <a href="K-means_clustering" title="wikilink">

<math display="inline" id="Stochastic_gradient_descent:22">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-means clustering</a>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h3 id="momentum">Momentum</h3>

<p>Further proposals include the <em>momentum method</em>, which appeared in <a href="David_Rumelhart" title="wikilink">Rumelhart</a>, <a href="Geoffrey_Hinton" title="wikilink">Hinton</a> and <a href="Ronald_J._Williams" title="wikilink">Williams</a>' seminal paper on backpropagation learning.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> SGD with momentum remembers the update 

<math display="inline" id="Stochastic_gradient_descent:23">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Δw
  </annotation>
 </semantics>
</math>

 at each iteration, and determines the next update as a <a href="convex_combination" title="wikilink">convex combination</a> of the gradient and the previous update:</p>

<p>

<math display="block" id="Stochastic_gradient_descent:24">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>w</mi>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mrow>
     <mi>η</mi>
     <mrow>
      <mo>∇</mo>
      <msub>
       <mi>Q</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>w</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>α</mi>
     <mi mathvariant="normal">Δ</mi>
     <mi>w</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>w</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>η</ci>
      <apply>
       <ci>normal-∇</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <ci>w</ci>
     </apply>
     <apply>
      <times></times>
      <ci>α</ci>
      <ci>normal-Δ</ci>
      <ci>w</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta w:=\eta\nabla Q_{i}(w)+\alpha\Delta w
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Stochastic_gradient_descent:25">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>:=</mo>
   <mrow>
    <mi>w</mi>
    <mo>-</mo>
    <mrow>
     <mi>η</mi>
     <mi mathvariant="normal">Δ</mi>
     <mi>w</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>w</ci>
    <apply>
     <minus></minus>
     <ci>w</ci>
     <apply>
      <times></times>
      <ci>η</ci>
      <ci>normal-Δ</ci>
      <ci>w</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w:=w-\eta\Delta w
  </annotation>
 </semantics>
</math>

</p>

<p>The name momentum stems from an analogy to <a class="uri" href="momentum" title="wikilink">momentum</a> in physics: the weight vector, thought of as a particle traveling through parameter space, incurs acceleration from the gradient of the loss ("<a class="uri" href="force" title="wikilink">force</a>"). Unlike in classical SGD, it tends to keep traveling in the same direction, preventing oscillations. Momentum has been used successfully for several decades.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h3 id="averaging">Averaging</h3>

<p><em>Averaged SGD</em>, invented independently by Ruppert and Polyak in the late 1980s, is ordinary SGD that records an average of its parameter vector over time. That is, the update is the same as for ordinary SGD, but the algorithm also keeps track of<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>

<math display="block" id="Stochastic_gradient_descent:26">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>w</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>t</mi>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </munderover>
     <msub>
      <mi>w</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-¯</ci>
     <ci>w</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>t</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{w}=\frac{1}{t}\sum_{i=0}^{t-1}w_{i}
  </annotation>
 </semantics>
</math>

.</p>

<p>When optimization is done, this averaged parameter vector takes the place of 

<math display="inline" id="Stochastic_gradient_descent:27">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="adagrad">AdaGrad</h3>

<p><em>AdaGrad</em> (for adaptive <a href="Gradient_descent" title="wikilink">gradient</a> algorithm) is an enhanced SGD that automatically determines a per-parameter learning rate.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> It still has a base learning rate 

<math display="inline" id="Stochastic_gradient_descent:28">
 <semantics>
  <mi>η</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>η</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   η
  </annotation>
 </semantics>
</math>

, but this is multiplied with the elements of a vector  that is thought of as the diagonal of a matrix</p>

<p>

<math display="block" id="Stochastic_gradient_descent:29">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>τ</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>t</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>g</mi>
      <mi>τ</mi>
     </msub>
     <msubsup>
      <mi>g</mi>
      <mi>τ</mi>
      <mi>𝖳</mi>
     </msubsup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>τ</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <ci>τ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>τ</ci>
       </apply>
       <ci>𝖳</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=\sum_{\tau=1}^{t}g_{\tau}g_{\tau}^{\mathsf{T}}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Stochastic_gradient_descent:30">
 <semantics>
  <mrow>
   <msub>
    <mi>g</mi>
    <mi>τ</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>∇</mo>
     <msub>
      <mi>Q</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <ci>τ</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-∇</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{\tau}=\nabla Q_{i}(w)
  </annotation>
 </semantics>
</math>

, the gradient, at iteration 

<math display="inline" id="Stochastic_gradient_descent:31">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   τ
  </annotation>
 </semantics>
</math>

. The diagonal is given by</p>

<p>

<math display="block" id="Stochastic_gradient_descent:32">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mrow>
     <mi>j</mi>
     <mo>,</mo>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>τ</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>t</mi>
    </munderover>
    <msubsup>
     <mi>g</mi>
     <mrow>
      <mi>τ</mi>
      <mo>,</mo>
      <mi>j</mi>
     </mrow>
     <mn>2</mn>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <list>
      <ci>j</ci>
      <ci>j</ci>
     </list>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>τ</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <list>
        <ci>τ</ci>
        <ci>j</ci>
       </list>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{j,j}=\sum_{\tau=1}^{t}g_{\tau,j}^{2}
  </annotation>
 </semantics>
</math>

.</p>

<p>This vector is updated after every iteration. The formula for an update is now</p>

<p>

<math display="block" id="Stochastic_gradient_descent:33">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>:=</mo>
   <mrow>
    <mi>w</mi>
    <mo>-</mo>
    <mrow>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>η</mi>
      </mpadded>
      <mi>diag</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>G</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mfrac>
         <mn>1</mn>
         <mn>2</mn>
        </mfrac>
       </mrow>
      </msup>
     </mrow>
     <mo>∘</mo>
     <mi>g</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>w</ci>
    <apply>
     <minus></minus>
     <ci>w</ci>
     <apply>
      <compose></compose>
      <apply>
       <times></times>
       <ci>η</ci>
       <ci>diag</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>G</ci>
        <apply>
         <minus></minus>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>g</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w:=w-\eta\,\mathrm{diag}(G)^{-\frac{1}{2}}\circ g
  </annotation>
 </semantics>
</math>

<mtpl></mtpl></p>

<p>or, written as per-parameter updates,</p>

<p>

<math display="block" id="Stochastic_gradient_descent:34">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>w</mi>
     <mi>j</mi>
    </msub>
    <mo>:=</mo>
    <mrow>
     <msub>
      <mi>w</mi>
      <mi>j</mi>
     </msub>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <mi>η</mi>
       <msqrt>
        <mi></mi>
       </msqrt>
      </mfrac>
      <msub>
       <mi>G</mi>
       <mrow>
        <mi>j</mi>
        <mo>,</mo>
        <mi>j</mi>
       </mrow>
      </msub>
      <msub>
       <mi>g</mi>
       <mi>j</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>η</ci>
       <apply>
        <root></root>
        <csymbol cd="latexml">absent</csymbol>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>G</ci>
       <list>
        <ci>j</ci>
        <ci>j</ci>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{j}:=w_{j}-\frac{\eta}{\sqrt{}}{G_{j,j}}g_{j}.
  </annotation>
 </semantics>
</math>

</p>

<p>Each  gives rise to a scaling factor for the learning rate that applies to a single parameter <mtpl></mtpl>. Since the denominator in this factor, 

<math display="inline" id="Stochastic_gradient_descent:35">
 <semantics>
  <mrow>
   <msqrt>
    <msub>
     <mi>G</mi>
     <mi>i</mi>
    </msub>
   </msqrt>
   <mo>=</mo>
   <msqrt>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>τ</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>t</mi>
     </msubsup>
     <msubsup>
      <mi>g</mi>
      <mi>τ</mi>
      <mn>2</mn>
     </msubsup>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <root></root>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <root></root>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>τ</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>τ</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{G_{i}}=\sqrt{\sum_{\tau=1}^{t}g_{\tau}^{2}}
  </annotation>
 </semantics>
</math>

 is the <a href="Norm_(mathematics)#Euclidean_norm" title="wikilink"><em>ℓ</em><sub>2</sub> norm</a> of previous derivatives, extreme parameter updates get dampened, while parameters that get few or small updates receive higher learning rates.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>While designed for <a href="convex_optimization" title="wikilink">convex problems</a>, AdaGrad has been successfully applied to non-convex optimization.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h2 id="notes">Notes</h2>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Linear_classifier" title="wikilink">Linear classifier</a></li>
<li><a href="Online_machine_learning" title="wikilink">Online machine learning</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>. (Extensive list of references)</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<h2 id="software">Software</h2>
<ul>
<li><a href="http://leon.bottou.org/projects/sgd">sgd</a>: an LGPL C++ library which uses stochastic gradient descent to fit <a href="Support_vector_machine" title="wikilink">SVM</a> and <a href="conditional_random_field" title="wikilink">conditional random field</a> models.</li>
<li><a href="http://klcl.pku.edu.cn/member/sunxu/code.htm">CRF-ADF</a> A <a href="C_Sharp_(programming_language)" title="wikilink">C#</a> toolkit of stochastic gradient descent and its feature-frequency-adaptive variation for training <a href="conditional_random_field" title="wikilink">conditional random field</a> models.</li>
<li><a href="Vowpal_Wabbit" title="wikilink">Vowpal Wabbit</a>: BSD licence, fast scalable learning by John Langford and others. Includes several stochastic gradient descent variants. <a href="https://github.com/JohnLangford/vowpal_wabbit">Source repository on github</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://codingplayground.blogspot.it/2013/05/stocastic-gradient-descent.html">Using stochastic gradient descent in C++, Boost, Ublas for linear regression</a></li>
</ul>

<p>"</p>

<p><a href="Category:Stochastic_optimization" title="wikilink">Category:Stochastic optimization</a> <a href="Category:Computational_statistics" title="wikilink">Category:Computational statistics</a> <a class="uri" href="Category:M-estimators" title="wikilink">Category:M-estimators</a> <a href="Category:Machine_learning_algorithms" title="wikilink">Category:Machine learning algorithms</a> <a href="Category:Convex_optimization" title="wikilink">Category:Convex optimization</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6">Jenny Rose Finkel, Alex Kleeman, Christopher D. Manning (2008). Efficient, Feature-based, Conditional Random Field Parsing. Proc. Annual Meeting of the ACL.<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8">Cited by <a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
</ol>
</section>
</body>
</html>
