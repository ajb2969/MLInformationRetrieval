   Hindleyâ€“Milner type system      Hindleyâ€“Milner type system  In [[type theory]] and [[functional programming]], '''Hindleyâ€“Milner''' ('''HM''') (also known as '''Damasâ€“Milner''' or '''Damasâ€“Hindleyâ€“Milner''') is a classical [[type system]] for the [[lambda calculus]] with [[parametric polymorphism]], first described by [[J. Roger Hindley]] {{cite journal | authorlink = J. Roger Hindley | first = J. Roger | last = Hindley | date = 1969 | title = The Principal Type-Scheme of an Object in Combinatory Logic | journal = Transactions of the American Mathematical Society | volume = 146 | pages = 29â€“60 | jstor = 1 995158 }} and later rediscovered by Robin Milner . 1 Luis Damas contributed a close formal analysis and proof of the method in his PhD thesis. 2 3  Among HM's more notable properties is completeness and its ability to deduce the most general type of a given program without the need of any type annotations or other hints supplied by the programmer. Algorithm W is a fast algorithm, performing type inference in almost linear time with respect to the size of the source, making it practically usable to type large programs. 4 HM is preferably used for functional languages . It was first implemented as part of the type system of the programming language ML . Since then, HM has been extended in various ways, most notably by constrained types as used in Haskell .  Introduction  Organizing their original paper, Damas and Milner 5 clearly separated two very different tasks. One is to describe what types an expression can have and another to present an algorithm actually computing a type. Keeping both aspects apart from each other allows one to focus separately on the logic (i.e. meaning) behind the algorithm, as well as to establish a benchmark for the algorithm's properties.  How expressions and types fit to each other is described by means of a deductive system . Like any proof system , it allows different ways to come to a conclusion and since one and the same expression arguably might have different types, dissimilar conclusions about an expression are possible. Contrary to this, the type inference method itself ( Algorithm W ) is defined as a deterministic step-by-step procedure, leaving no choice what to do next. Thus clearly, decisions not present in the logic might have been made constructing the algorithm, which demand a closer look and justifications but would perhaps remain non-obvious without the above differentiation.  Syntax      Expressions           e    =    x    variable       |       e  1     e  2      application       |       Î»    x    .  e     abstraction       |       ğš•ğšğš   x   =     e  1     ğš’ğš—    e  2            e   x  variable     missing-subexpression   normal-|     subscript  e  1    subscript  e  2    application     missing-subexpression   normal-|   formulae-sequence    Î»  x   e   abstraction     missing-subexpression   normal-|      ğš•ğšğš  x      subscript  e  1   ğš’ğš—   subscript  e  2      missing-subexpression      \begin{array}[]{lrll}e&=&x&\textrm{variable}\\
 &|&e_{1}\ e_{2}&\textrm{application}\\
 &|&\lambda\ x\ .\ e&\textrm{abstraction}\\
 &|&\mathtt{let}\ x=e_{1}\ \mathtt{in}\ e_{2}\\
 \end{array}        Types           mono    Ï„    =    Î±     variable         |      D   Ï„  â€¦  Ï„      application       poly    Ïƒ    =    Ï„         |      âˆ€   Î±    .  Ïƒ      quantifier                mono  Ï„   Î±  variable     missing-subexpression    missing-subexpression   normal-|    D  Ï„  normal-â€¦  Ï„   application    poly  Ïƒ   Ï„   missing-subexpression      missing-subexpression    missing-subexpression   normal-|   formulae-sequence   for-all  Î±   Ïƒ   quantifier     missing-subexpression    missing-subexpression    missing-subexpression    missing-subexpression    missing-subexpression      \begin{array}[]{llrll}\textrm{mono}&\tau&=&\alpha&\ \textrm{variable}\\
 &&|&D\ \tau\dots\tau&\ \textrm{application}\\
 \textrm{poly}&\sigma&=&\tau\\
 &&|&\forall\ \alpha\ .\ \sigma&\ \textrm{quantifier}\\
 \\
 \end{array}        Logic and algorithm share the notions of "expression" and "type", whose form is made precise by the syntax .  The expressions to be typed are exactly those of the lambda calculus , enhanced by a let-expression. These are shown in the table to the right. For readers unfamiliar with the lambda calculus, here is a brief explanation: The application     e  1    e  2        subscript  e  1    subscript  e  2     e_{1}e_{2}   represents applying the function    e  1     subscript  e  1    e_{1}   to the argument    e  2     subscript  e  2    e_{2}   , often written     e  1    (   e  2   )        subscript  e  1    subscript  e  2     e_{1}(e_{2})   . The abstraction      Î»    x    .  e     formulae-sequence    Î»  x   e    \lambda\ x\ .\ e   represents an anonymous function that maps the input   x   x   x   to the output   e   e   e   . This is also called function literal, common in most contemporary programming languages, and sometimes written as     ğšğšğš—ğšŒğšğš’ğš˜ğš—    (  x  )    ğš›ğšğšğšğš›ğš—    e   ğšğš—ğš      ğšğšğš—ğšŒğšğš’ğš˜ğš—  x  ğš›ğšğšğšğš›ğš—  e  ğšğš—ğš    \mathtt{function}\,(x)\ \mathtt{return}\ e\ \mathtt{end}   . The let expression      ğš•ğšğš   x   =     e  1     ğš’ğš—    e  2          ğš•ğšğš  x      subscript  e  1   ğš’ğš—   subscript  e  2      \mathtt{let}\ x=e_{1}\ \mathtt{in}\ e_{2}   represents the result of substituting every occurrence of   x   x   x   in    e  2     subscript  e  2    e_{2}   with    e  1     subscript  e  1    e_{1}   .  Types as a whole are split into two groups, called mono- and polytypes. 6  Monotypes  Monotypes   Ï„   Ï„   \tau   are syntactically represented as terms . A monotype always designates a particular type, in the sense that it is equal only to itself and different from all others.  Examples of monotypes include type constants like   ğš’ğš—ğš   ğš’ğš—ğš   \mathtt{int}   or   ğšœğšğš›ğš’ğš—ğš   ğšœğšğš›ğš’ğš—ğš   \mathtt{string}   , and parametric types like     ğ™¼ğšŠğš™    (    ğš‚ğšğš   ğšœğšğš›ğš’ğš—ğš   )   ğš’ğš—ğš      ğ™¼ğšŠğš™    ğš‚ğšğš  ğšœğšğš›ğš’ğš—ğš   ğš’ğš—ğš    \mathtt{Map\ (Set\ string)\ int}   . These types are examples of applications of type functions, for example, from the set    {   ğ™¼ğšŠğš™  ğŸ¸   ,   ğš‚ğšğš  ğŸ·   ,   ğšœğšğš›ğš’ğš—ğš  ğŸ¶   ,   ğš’ğš—ğš  ğŸ¶   }      superscript  ğ™¼ğšŠğš™  2    superscript  ğš‚ğšğš  1    superscript  ğšœğšğš›ğš’ğš—ğš  0    superscript  ğš’ğš—ğš  0     \{\mathtt{Map^{2},\ Set^{1},\ string^{0},\ int^{0}}\}   , where the superscript indicates the number of type parameters. The complete set of type functions   D   D   D   is arbitrary in HM, except that it must contain at least    â†’  2     superscript  normal-â†’  2    \rightarrow^{2}   , the type of functions. It is often written in infix notation for convenience. For example, a function mapping integers to strings has type    ğš’ğš—ğš  â†’  ğšœğšğš›ğš’ğš—ğš     normal-â†’  ğš’ğš—ğš  ğšœğšğš›ğš’ğš—ğš    \mathtt{int}\rightarrow\mathtt{string}   . 7  Type variables are monotypes. Standing alone, a type variable   Î±   Î±   \alpha   is meant to be as concrete as   ğš’ğš—ğš   ğš’ğš—ğš   \mathtt{int}   or   Î²   Î²   \beta   , and clearly different from both. Type variables occurring as monotypes behave as if they were type constants whose identity is unknown. Correspondingly, a function typed    Î±  â†’  Î±     normal-â†’  Î±  Î±    \alpha\rightarrow\alpha   only maps values of the particular type   Î±   Î±   \alpha   on itself. Such a function can only be applied to values having type   Î±   Î±   \alpha   and to no others.  Polytype  Polytypes (or type schemes ) are types containing variables bound by one or more for-all quantifiers, e.g.     âˆ€  Î±   .   Î±  â†’  Î±      formulae-sequence   for-all  Î±    normal-â†’  Î±  Î±     \forall\alpha.\alpha\rightarrow\alpha   .  A function with polytype     âˆ€  Î±   .   Î±  â†’  Î±      formulae-sequence   for-all  Î±    normal-â†’  Î±  Î±     \forall\alpha.\alpha\rightarrow\alpha   can map any value of the same type to itself, and the identity function is a value for this type. As another example     âˆ€  Î±   .    (    ğš‚ğšğš   Î±   )   â†’  ğš’ğš—ğš      formulae-sequence   for-all  Î±    normal-â†’    ğš‚ğšğš  Î±   ğš’ğš—ğš     \forall\alpha.(\mathtt{Set}\ \alpha)\rightarrow\mathtt{int}   is the type of a function mapping all finite sets to integers. The count of members is a value for this type. Note that quantifiers can only appear top level, i.e. a type     âˆ€  Î±   .   Î±  â†’   âˆ€  Î±    .  Î±     formulae-sequence   for-all  Î±    normal-â†’  Î±   for-all  Î±    Î±    \forall\alpha.\alpha\rightarrow\forall\alpha.\alpha   for instance, is excluded by the syntax of types and that monotypes are included in the polytypes, thus a type has the general form     âˆ€    Î±  1   â€¦   âˆ€   Î±  n      .  Ï„     formulae-sequence   for-all     subscript  Î±  1   normal-â€¦   for-all   subscript  Î±  n      Ï„    \forall\alpha_{1}\dots\forall\alpha_{n}.\tau   .  Free type variables      Free Type Variables            free   (   Î±   )        =   {  Î±  }         free   (    D    Ï„  1   â€¦    Ï„  n     )        =    â‹ƒ   i  =  1   n    free   (    Ï„  i    )           free   (  âˆ€   Î±   .   Ïƒ   )        =    free   (   Ïƒ   )    -   {  Î±  }             free  Î±     absent   Î±        free    D   subscript  Ï„  1   normal-â€¦   subscript  Ï„  n       absent    superscript   subscript     i  1    n     free   subscript  Ï„  i         fragments  free   fragments  normal-(  for-all  Î±  normal-.  Ïƒ  normal-)      absent      free  Ïƒ    Î±        \begin{array}[]{ll}\text{free}(\ \alpha\ )&=\ \left\{\alpha\right\}\\
 \text{free}(\ D\ \tau_{1}\dots\tau_{n}\ )&=\ \bigcup\limits_{i=1}^{n}{\text{%
 free}(\ \tau_{i}\ )}\\
 \text{free}(\ \forall\ \alpha\ .\ \sigma\ )&=\ \text{free}(\ \sigma\ )\ -\ %
 \left\{\alpha\right\}\\
 \end{array}        In a type     âˆ€    Î±  1   â€¦   âˆ€   Î±  n      .  Ï„     formulae-sequence   for-all     subscript  Î±  1   normal-â€¦   for-all   subscript  Î±  n      Ï„    \forall\alpha_{1}\dots\forall\alpha_{n}.\tau   , the symbol   âˆ€   for-all   \forall   is the quantifier binding the type variables    Î±  i     subscript  Î±  i    \alpha_{i}   in the monotype   Ï„   Ï„   \tau   . The variables    Î±  i     subscript  Î±  i    \alpha_{i}   are called quantified and any occurrence of a quantified type variable in   Ï„   Ï„   \tau   is called bound and all unbound type variables in   Ï„   Ï„   \tau   are called free . Like in the lambda calculus , the notion of free and bound variables is essential for the understanding of the meaning of types.  This is certainly the hardest part of HM, perhaps because polytypes containing free variables are not represented in programming languages like Haskell . Likewise, one does not have clauses with free variables in Prolog . In particular developers experienced with both languages and actually knowing all the prerequisites of HM, are likely to slip this point. In Haskell for example, all type variables implicitly occur quantified, i.e. a Haskell type a -> a means     âˆ€  Î±   .   Î±  â†’  Î±      formulae-sequence   for-all  Î±    normal-â†’  Î±  Î±     \forall\alpha.\alpha\rightarrow\alpha   here. Because a type like    Î±  â†’  Î±     normal-â†’  Î±  Î±    \alpha\rightarrow\alpha   , though it may practically occur in a Haskell program, cannot be expressed there, it can easily be confused with its quantified version.  So what function can have a type like e.g.     âˆ€  Î²   .   Î²  â†’  Î±      formulae-sequence   for-all  Î²    normal-â†’  Î²  Î±     \forall\beta.\beta\rightarrow\alpha   , i.e. a mixture of both bound and free type variables and what could the free type variable   Î±   Î±   \alpha   therein mean?      Example 1             ğ¥ğğ­    ğ‘ğ‘ğ‘Ÿ    [  âˆ€  Î±  .  âˆ€  Î²  .  Î±  â†’   (  Î²  â†’  Î±  )   ]   =   Î»   x  .         ğ¥ğğ­    ğ‘“ğ‘œğ‘œ    [  âˆ€  Î²  .  Î²  â†’  Î±  ]   =   Î»   y  .  x         ğ¢ğ§   ğ‘“ğ‘œğ‘œ         ğ¢ğ§   ğ‘ğ‘ğ‘Ÿ          fragments  let  bar   fragments  normal-[  for-all  Î±  normal-.  for-all  Î²  normal-.  Î±  normal-â†’   fragments  normal-(  Î²  normal-â†’  Î±  normal-)   normal-]    Î»  x  normal-.      fragments  let  foo   fragments  normal-[  for-all  Î²  normal-.  Î²  normal-â†’  Î±  normal-]    Î»  y  normal-.  x       in  ğ‘“ğ‘œğ‘œ       in  ğ‘ğ‘ğ‘Ÿ      \begin{array}[]{l}\textbf{let}\ \mathit{bar}\ [\forall\alpha.\forall\beta.%
 \alpha\rightarrow(\beta\rightarrow\alpha)]=\lambda\ x.\\
 \quad\textbf{let}\ \mathit{foo}\ [\forall\beta.\beta\rightarrow\alpha]=\lambda%
 \ y.x\\
 \quad\textbf{in}\ \mathit{foo}\\
 \textbf{in}\ \mathit{bar}\end{array}        Consider   ğ‘“ğ‘œğ‘œ   ğ‘“ğ‘œğ‘œ   \mathit{foo}   in Example 1, with type annotations in brackets. Its parameter   y   y   y   is not used in the body, but the variable   x   x   x   bound in the outer context of   ğ‘“ğ‘œğ‘œ   ğ‘“ğ‘œğ‘œ   \mathit{foo}   surely is. As a consequence,   ğ‘“ğ‘œğ‘œ   ğ‘“ğ‘œğ‘œ   \mathit{foo}   accepts every value as argument, while returning a value bound outside and with it its type.   ğ‘ğ‘ğ‘Ÿ   ğ‘ğ‘ğ‘Ÿ   \mathit{bar}   to the contrary has type    âˆ€  Î±  .  âˆ€  Î²  .  Î±  â†’   (  Î²  â†’  Î±  )      fragments  for-all  Î±  normal-.  for-all  Î²  normal-.  Î±  normal-â†’   fragments  normal-(  Î²  normal-â†’  Î±  normal-)     \forall\alpha.\forall\beta.\alpha\rightarrow(\beta\rightarrow\alpha)   , in which all occurring type variables are bound. Evaluating, for instance    ğ‘ğ‘ğ‘Ÿ  1      ğ‘ğ‘ğ‘Ÿ  1    \mathit{bar}\ 1   , results in a function of type     âˆ€  Î²   .   Î²  â†’  ğ‘–ğ‘›ğ‘¡      formulae-sequence   for-all  Î²    normal-â†’  Î²  ğ‘–ğ‘›ğ‘¡     \forall\beta.\beta\rightarrow\ \mathit{int}   , perfectly reflecting that foo's monotype   Î±   Î±   \alpha   in     âˆ€  Î²   .   Î²  â†’  Î±      formulae-sequence   for-all  Î²    normal-â†’  Î²  Î±     \forall\beta.\beta\rightarrow\alpha   has been refined by this call.  In this example, the free monotype variable   Î±   Î±   \alpha   in foo's type becomes meaningful by being quantified in the outer scope, namely in bar's type. I.e. in context of the example, the same type variable   Î±   Î±   \alpha   appears both bound and free in different types. As a consequence, a free type variable cannot be interpreted better than stating it is a monotype without knowing the context. Turning the statement around, in general, a typing is not meaningful without a context.  Context and typing      Syntax           Context    Î“    =      Ïµ    (  ğšğš–ğš™ğšğš¢  )          |      Î“  ,  x   :  Ïƒ       Typing     =     Î“  âŠ¢  e  :  Ïƒ               Context  normal-Î“     Ïµ  ğšğš–ğš™ğšğš¢      missing-subexpression    missing-subexpression   normal-|   normal-:   normal-Î“  x   Ïƒ     Typing   missing-subexpression       proves  normal-Î“  e    normal-:    Ïƒ       missing-subexpression    missing-subexpression    missing-subexpression    missing-subexpression      \begin{array}[]{llrl}\text{Context}&\Gamma&=&\epsilon\ \mathtt{(empty)}\\
 &&|&\Gamma,\ x:\sigma\\
 \text{Typing}&&=&\Gamma\vdash e:\sigma\\
 \\
 \end{array}        Free Type Variables            free   (   Î“   )        =    â‹ƒ   x  :   Ïƒ  âˆˆ  Î“      free   (   Ïƒ   )              free  normal-Î“     absent    subscript    normal-:  x    Ïƒ  normal-Î“       free  Ïƒ        \begin{array}[]{ll}\text{free}(\ \Gamma\ )&=\ \bigcup\limits_{x:\sigma\in%
 \Gamma}\text{free}(\ \sigma\ )\end{array}        Consequently, to get the yet disjoint parts of the syntax, expressions and types together meaningfully, a third part, the context is needed. Syntactically, it is a list of pairs    x  :  Ïƒ     normal-:  x  Ïƒ    x:\sigma   , called assignments or assumptions , stating for each value variable    x  i     subscript  x  i    x_{i}   therein a type    Ïƒ  i     subscript  Ïƒ  i    \sigma_{i}   . All three parts combined gives a typing judgment of the form     Î“   âŠ¢  e  :  Ïƒ       proves  normal-Î“  e    normal-:    Ïƒ     \Gamma\ \vdash\ e:\sigma   , stating, that under assumptions   Î“   normal-Î“   \Gamma   , the expression   e   e   e   has type   Ïƒ   Ïƒ   \sigma   .  Now having the complete syntax at hand, one can finally make a meaningful statement about the type of   ğ‘“ğ‘œğ‘œ   ğ‘“ğ‘œğ‘œ   \mathit{foo}   in example 1, above, namely    x  :  Î±  âŠ¢   Î»   y  .  x  :  âˆ€  Î²  .  Î²  â†’  Î±     fragments  x  normal-:  Î±  proves  Î»  y  normal-.  x  normal-:  for-all  Î²  normal-.  Î²  normal-â†’  Î±    x:\alpha\vdash\lambda\ y.x:\forall\beta.\beta\rightarrow\alpha   . Contrary to the above formulations, the monotype variable   Î±   Î±   \alpha   no longer appears unbound, i.e. meaningless, but bound in the context as the type of the value variable   x   x   x   . The circumstance whether a type variable is bound or free in the context apparently plays a significant role for a type as part of a typing, so    free   (   Î“   )       free  normal-Î“    \text{free}(\ \Gamma\ )   it is made precise in the side box.  Polymorphic type order  While the equality of monotypes is purely syntactical, polytypes offer a richer structure by being related to other types through a specialization relation    Ïƒ  âŠ‘   Ïƒ  â€²      square-image-of-or-equals  Ïƒ   superscript  Ïƒ  normal-â€²     \sigma\sqsubseteq\sigma^{\prime}   expressing that    Ïƒ  â€²     superscript  Ïƒ  normal-â€²    \sigma^{\prime}   is more special than   Ïƒ   Ïƒ   \sigma   .  When being applied to a value a polymorphic function has to change its shape specializing to deal with this particular type of values. During this process, it also changes its type to match that of the parameter. If for instance the identity function having type     âˆ€  Î±   .   Î±  â†’  Î±      formulae-sequence   for-all  Î±    normal-â†’  Î±  Î±     \forall\alpha.\alpha\rightarrow\alpha   is to be applied on a number having type    i  n  t      i  n  t    int   , both simply cannot work together, because all the types are different and nothing fits. What is needed is a function of type     i  n  t   â†’   i  n  t      normal-â†’    i  n  t     i  n  t     int\rightarrow int   . Thus, during application, the polymorphic identity is specialized to a monomorphic version of itself. In terms of the specialization relation, one writes     âˆ€  Î±   .   Î±  â†’  Î±  âŠ‘   i  n  t   â†’   i  n  t       formulae-sequence   for-all  Î±      normal-â†’  Î±  Î±    square-image-of-or-equals      i  n  t     normal-â†’      i  n  t       \forall\alpha.\alpha\rightarrow\alpha\sqsubseteq\ int\rightarrow int     Now the shape shifting of polymorphic values is not fully arbitrary but rather limited by their pristine polytype. Following what has happened in the example one could paraphrase the rule of specialization, saying, a polymorphic type     âˆ€  Î±   .  Ï„     formulae-sequence   for-all  Î±   Ï„    \forall\alpha.\tau   is specialized by consistently replacing each occurrence of   Î±   Î±   \alpha   in   Ï„   Ï„   \tau   and dropping the quantifier. While this rule works well for any monotype used as replacement, it fails when a polytype, say     âˆ€  Î²   .  Î²     formulae-sequence   for-all  Î²   Î²    \forall\beta.\beta   is tried as a replacement, resulting in the non-syntactical type     âˆ€  Î²   .   Î²  â†’   âˆ€  Î²    .  Î²     formulae-sequence   for-all  Î²    normal-â†’  Î²   for-all  Î²    Î²    \forall\beta.\beta\rightarrow\forall\beta.\beta   . But not only that. Even if a type with nested quantified types would be allowed in the syntax, the result of the substitution would not longer preserve the property of the pristine type, in which both the parameter and the result of the function have the same type, which are now only seemingly equal because both subtypes became independent from each other allowing to specialize the parameter and the result with different types resulting in, e.g.     s  t  r  i  n  g   â†’   S  e   t   i  n  t      normal-â†’    s  t  r  i  n  g     S  e  t  i  n  t     string\rightarrow Set\ int   , hardly the right task for an identity function.  The syntactic restriction to allow quantification only top-level is imposed to prevent generalization while specializing. Instead of     âˆ€  Î²   .   Î²  â†’   âˆ€  Î²    .  Î²     formulae-sequence   for-all  Î²    normal-â†’  Î²   for-all  Î²    Î²    \forall\beta.\beta\rightarrow\forall\beta.\beta   , the more special type     âˆ€  Î²   .   Î²  â†’  Î²      formulae-sequence   for-all  Î²    normal-â†’  Î²  Î²     \forall\beta.\beta\rightarrow\beta   must be produced in this case.  One could undo the former specialization by specializing on some value of type     âˆ€  Î±   .  Î±     formulae-sequence   for-all  Î±   Î±    \forall\alpha.\alpha   again. In terms of the relation one gains     âˆ€  Î±   .   Î±  â†’  Î±  âŠ‘   âˆ€  Î²    .   Î²  â†’  Î²  âŠ‘   âˆ€  Î±    .   Î±  â†’  Î±      formulae-sequence   for-all  Î±      normal-â†’  Î±  Î±    square-image-of-or-equals     for-all  Î²        normal-â†’  Î²  Î²    square-image-of-or-equals     for-all  Î±      normal-â†’  Î±  Î±     \forall\alpha.\alpha\rightarrow\alpha\sqsubseteq\forall\beta.\beta\rightarrow%
 \beta\sqsubseteq\forall\alpha.\alpha\rightarrow\alpha   as a summary, meaning that syntactically different polytypes are equal with respect to renaming their quantified variables.      Specialization Rule            Ï„  â€²   =   [   Î±  i   :=   Ï„  i   ]   Ï„   Î²  i   âˆ‰  free   (  âˆ€   Î±  1   â€¦  âˆ€   Î±  n   .  Ï„  )      âˆ€    Î±  1   â€¦   âˆ€   Î±  n      .   Ï„  âŠ‘   âˆ€    Î²  1   â€¦   âˆ€   Î²  m       .   Ï„  â€²          fragments   superscript  Ï„  normal-â€²     fragments  normal-[   subscript  Î±  i   assign   subscript  Ï„  i   normal-]   Ï„    subscript  Î²  i    free   fragments  normal-(  for-all   subscript  Î±  1   normal-â€¦  for-all   subscript  Î±  n   normal-.  Ï„  normal-)     formulae-sequence   for-all     subscript  Î±  1   normal-â€¦   for-all   subscript  Î±  n       square-image-of-or-equals  Ï„   for-all     subscript  Î²  1   normal-â€¦   for-all   subscript  Î²  m        superscript  Ï„  normal-â€²      \displaystyle\frac{\tau^{\prime}=\left[\alpha_{i}:=\tau_{i}\right]\tau\quad%
 \beta_{i}\not\in\textrm{free}(\forall\alpha_{1}...\forall\alpha_{n}.\tau)}{%
 \forall\alpha_{1}...\forall\alpha_{n}.\tau\sqsubseteq\forall\beta_{1}...%
 \forall\beta_{m}.\tau^{\prime}}        Now focusing only on the question whether a type is more special than another and no longer what the specialized type is used for, one could summarize the specialization as in the box above. Paraphrasing it clockwise, a type     âˆ€    Î±  1   â€¦   âˆ€   Î±  n      .  Ï„     formulae-sequence   for-all     subscript  Î±  1   normal-â€¦   for-all   subscript  Î±  n      Ï„    \forall\alpha_{1}\dots\forall\alpha_{n}.\tau   is specialized by consistently replacing any of the quantified variables    Î±  i     subscript  Î±  i    \alpha_{i}   by arbitrary monotypes    Ï„  i     subscript  Ï„  i    \tau_{i}   gaining a monotype    Ï„  â€²     superscript  Ï„  normal-â€²    \tau^{\prime}   . Finally, type variables in    Ï„  â€²     superscript  Ï„  normal-â€²    \tau^{\prime}   not occurring free in the pristine type can optionally be quantified.  Thus the specialization rules makes sure that no free variable, i.e. monotype in the pristine type becomes unintentionally bound by a quantifier, but originally quantified variable can be replaced with whatever, even with types introducing new quantified or unquantified type variables.  Starting with a polytype     âˆ€  Î±   .  Î±     formulae-sequence   for-all  Î±   Î±    \forall\alpha.\alpha   , the specialization could either replace the body by another quantified variable, actually a rename or by some type constant (including the function type) which may or may not have parameters filled either with monotypes or quantified type variables. Once a quantified variable is replaced by a type application, this specialization cannot be undone through another substitution as it was possible for quantified variables. Thus the type application is there to stay. Only if it contains another quantified type variable, the specialization could continue further replacing for it.  So the specialization introduces no further equivalence on polytype beside the already known renaming. Polytypes are syntactically equal up to renaming their quantified variables. The equality of types is a reflexive, antisymmetric and transitive relation and the remaining specializations of polytypes are transitive and with this the relation   âŠ‘   square-image-of-or-equals   \sqsubseteq   is an order .  Deductive system      The Syntax of Rules           Predicate    =     Ïƒ  âŠ‘   Ïƒ  â€²         |     Î±  âˆ‰   f  r  e  e   (  Î“  )          |     x  ;  :  Î±  âˆˆ  Î“            Judgment    =    Typing      Premise    =      Judgment   |  Predicate       Conclusion    =    Judgment           Rule    =         Premise   â€¦   Conclusion     [  ğ™½ğšŠğš–ğš  ]          Predicate    square-image-of-or-equals  Ïƒ   superscript  Ïƒ  normal-â€²       missing-subexpression   normal-|    Î±    f  r  e  e  normal-Î“       missing-subexpression   normal-|   fragments  x  normal-;  normal-:  Î±   Î“      missing-subexpression    missing-subexpression    missing-subexpression     Judgment   Typing    Premise    fragments  Judgment  normal-|  Predicate     Conclusion   Judgment     missing-subexpression    missing-subexpression    missing-subexpression     Rule        Premise  normal-â€¦   Conclusion    delimited-[]  ğ™½ğšŠğš–ğš       \begin{array}[]{lrl}\text{Predicate}&=&\sigma\sqsubseteq\sigma^{\prime}\\
 &|&\alpha\not\in free(\Gamma)\\
 &|&x:\alpha\in\Gamma\\
 \\
 \text{Judgment}&=&\text{Typing}\\
 \text{Premise}&=&\text{Judgment}\ |\ \text{Predicate}\\
 \text{Conclusion}&=&\text{Judgment}\\
 \\
 \text{Rule}&=&\displaystyle\frac{\textrm{Premise}\ \dots}{\textrm{Conclusion}}%
 \quad[\mathtt{Name}]\end{array}        The syntax of HM is carried forward to the syntax of the inference rules that form the body of the formal system , by using the typings as judgments . Each of the rules define what conclusion could be drawn from what premises. Additionally to the judgments, some extra conditions introduced above might be used as premises, too.  A proof using the rules is a sequence of judgments such that all premises are listed before a conclusion. Please see the Examples 2 and 3 below for a possible format of proofs. From left to right, each line shows the conclusion, the    [  ğ™½ğšŠğš–ğš  ]     delimited-[]  ğ™½ğšŠğš–ğš    [\mathtt{Name}]   of the rule applied and the premises, either by referring to an earlier line (number) if the premise is a judgment or by making the predicate explicit.  Typing rules      Declarative Rule System              x  :   Ïƒ  âˆˆ  Î“     Î“  âŠ¢  x  :  Ïƒ        [  ğš…ğšŠğš›  ]              Î“  âŠ¢   e  0   :   Ï„  â†’    Ï„  â€²   Î“    âŠ¢   e  1   :  Ï„    Î“  âŠ¢     e  0     e  1    :   Ï„  â€²         [  ğ™°ğš™ğš™  ]               Î“  ,  x   :  Ï„  âŠ¢  e  :   Ï„  â€²     Î“  âŠ¢   Î»    x   .  e  :  Ï„  â†’   Ï„  â€²         [  ğ™°ğš‹ğšœ  ]              Î“  âŠ¢   e  0   :   Ïƒ  Î“  ,  x   :  Ïƒ  âŠ¢   e  1   :  Ï„    Î“  âŠ¢     ğš•ğšğš   x   =     e  0     ğš’ğš—    e  1     :  Ï„        [  ğ™»ğšğš  ]                  Î“  âŠ¢  e  :     Ïƒ  â€²    Ïƒ  â€²    âŠ‘  Ïƒ     Î“  âŠ¢  e  :  Ïƒ        [  ğ™¸ğš—ğšœğš  ]              Î“  âŠ¢  e  :    Ïƒ  Î±   âˆ‰   free   (  Î“  )       Î“  âŠ¢  e  :  âˆ€   Î±   .  Ïƒ        [  ğ™¶ğšğš—  ]                normal-:  x    Ïƒ  normal-Î“       proves  normal-Î“  x    normal-:    Ïƒ      delimited-[]  ğš…ğšŠğš›      missing-subexpression    missing-subexpression          proves  normal-Î“   subscript  e  0     normal-:     normal-â†’  Ï„    superscript  Ï„  normal-â€²   normal-Î“      proves     subscript  e  1     normal-:    Ï„       proves  normal-Î“     subscript  e  0    subscript  e  1      normal-:     superscript  Ï„  normal-â€²       delimited-[]  ğ™°ğš™ğš™      missing-subexpression    missing-subexpression          normal-:   normal-Î“  x   Ï„    proves    e    normal-:     superscript  Ï„  normal-â€²      fragments  Î“  proves  Î»  x  normal-.  e  normal-:  Ï„  normal-â†’   superscript  Ï„  normal-â€²      delimited-[]  ğ™°ğš‹ğšœ      missing-subexpression    missing-subexpression          proves  normal-Î“   subscript  e  0     normal-:     Ïƒ  normal-Î“  x     normal-:    Ïƒ    proves     subscript  e  1     normal-:    Ï„       proves  normal-Î“      ğš•ğšğš  x      subscript  e  0   ğš’ğš—   subscript  e  1       normal-:    Ï„      delimited-[]  ğ™»ğšğš      missing-subexpression    missing-subexpression      missing-subexpression    missing-subexpression          proves  normal-Î“  e    normal-:     square-image-of-or-equals    superscript  Ïƒ  normal-â€²    superscript  Ïƒ  normal-â€²    Ïƒ        proves  normal-Î“  e    normal-:    Ïƒ      delimited-[]  ğ™¸ğš—ğšœğš      missing-subexpression    missing-subexpression          proves  normal-Î“  e    normal-:       Ïƒ  Î±     free  normal-Î“       fragments  Î“  proves  e  normal-:  for-all  Î±  normal-.  Ïƒ     delimited-[]  ğ™¶ğšğš—      missing-subexpression    missing-subexpression      \begin{array}[]{cl}\displaystyle\frac{x:\sigma\in\Gamma}{\Gamma\vdash x:\sigma%
 }&[\mathtt{Var}]\\
 \\
 \displaystyle\frac{\Gamma\vdash e_{0}:\tau\rightarrow\tau^{\prime}\quad\quad%
 \Gamma\vdash e_{1}:\tau}{\Gamma\vdash e_{0}\ e_{1}:\tau^{\prime}}&[\mathtt{App%
 }]\\
 \\
 \displaystyle\frac{\Gamma,\;x:\tau\vdash e:\tau^{\prime}}{\Gamma\vdash\lambda%
 \ x\ .\ e:\tau\rightarrow\tau^{\prime}}&[\mathtt{Abs}]\\
 \\
 \displaystyle\frac{\Gamma\vdash e_{0}:\sigma\quad\quad\Gamma,\,x:\sigma\vdash e%
 _{1}:\tau}{\Gamma\vdash\mathtt{let}\ x=e_{0}\ \mathtt{in}\ e_{1}:\tau}&[%
 \mathtt{Let}]\\
 \\
 \\
 \displaystyle\frac{\Gamma\vdash e:\sigma^{\prime}\quad\sigma^{\prime}%
 \sqsubseteq\sigma}{\Gamma\vdash e:\sigma}&[\mathtt{Inst}]\\
 \\
 \displaystyle\frac{\Gamma\vdash e:\sigma\quad\alpha\notin\text{free}(\Gamma)}{%
 \Gamma\vdash e:\forall\ \alpha\ .\ \sigma}&[\mathtt{Gen}]\\
 \\
 \end{array}        The side box shows the deduction rules of the HM type system. One can roughly divide them into two groups:  The first four rules    [  ğš…ğšŠğš›  ]     delimited-[]  ğš…ğšŠğš›    [\mathtt{Var}]   (variable or function access),    [  ğ™°ğš™ğš™  ]     delimited-[]  ğ™°ğš™ğš™    [\mathtt{App}]   ( application , i.e. function call with one parameter),    [  ğ™°ğš‹ğšœ  ]     delimited-[]  ğ™°ğš‹ğšœ    [\mathtt{Abs}]   ( abstraction , i.e. function declaration) and    [  ğ™»ğšğš  ]     delimited-[]  ğ™»ğšğš    [\mathtt{Let}]   (variable declaration) are centered around the syntax, presenting one rule for each of the expression forms. Their meaning is pretty obvious at the first glance, as they decompose each expression, prove their sub-expressions and finally combine the individual types found in the premises to the type in the conclusion.  The second group is formed by the remaining two rules    [  ğ™¸ğš—ğšœğš  ]     delimited-[]  ğ™¸ğš—ğšœğš    [\mathtt{Inst}]   and    [  ğ™¶ğšğš—  ]     delimited-[]  ğ™¶ğšğš—    [\mathtt{Gen}]   . They handle specialization and generalization of types. While the rule    [  ğ™¸ğš—ğšœğš  ]     delimited-[]  ğ™¸ğš—ğšœğš    [\mathtt{Inst}]   should be clear from the section on specialization above,    [  ğ™¶ğšğš—  ]     delimited-[]  ğ™¶ğšğš—    [\mathtt{Gen}]   complements the former, working in the opposite direction. It allows generalization, i.e. to quantify monotype variables that are not bound in the context. The necessity of this restriction    Î±  âˆ‰   f  r  e  e   (   Î“   )        Î±    f  r  e  e  normal-Î“     \alpha\not\in free(\ \Gamma\ )   is introduced in the section on free type variables .  The following two examples exercise the rule system in action  Example 2 : A proof for    Î“  âŠ¢   i  d   (  n  )    :   i  n  t        proves  normal-Î“    i  d  n     normal-:      i  n  t      \Gamma\vdash id(n):int   where    Î“  =  i  d  :  âˆ€  Î±  .  Î±  â†’  Î±  ,  n  :  i  n  t     fragments  Î“   i  d  normal-:  for-all  Î±  normal-.  Î±  normal-â†’  Î±  normal-,  n  normal-:  i  n  t    \Gamma=id:\forall\alpha.\alpha\rightarrow\alpha,\ n:int   , could be written         1  :       Î“  âŠ¢  i  d  :  âˆ€  Î±  .  Î±  â†’  Î±      [  ğš…ğšŠğš›  ]      (  i  d  :  âˆ€  Î±  .  Î±  â†’  Î±  âˆˆ  Î“  )        2  :       Î“  âŠ¢   i  d   :    i  n  t   â†’   i  n  t        [  ğ™¸ğš—ğšœğš  ]       (  1  )   ,   (  âˆ€  Î±  .  Î±  â†’  Î±  âŠ‘  i  n  t  â†’  i  n  t  )         3  :       Î“  âŠ¢  n  :   i  n  t       [  ğš…ğšŠğš›  ]      (   n  :    i  n  t   âˆˆ  Î“    )        4  :       Î“  âŠ¢   i  d   (  n  )    :   i  n  t       [  ğ™°ğš™ğš™  ]       (  2  )   ,   (  3  )           normal-:  1  absent    fragments  Î“  proves  i  d  normal-:  for-all  Î±  normal-.  Î±  normal-â†’  Î±    delimited-[]  ğš…ğšŠğš›    fragments  normal-(  i  d  normal-:  for-all  Î±  normal-.  Î±  normal-â†’  Î±   Î“  normal-)      normal-:  2  absent      proves  normal-Î“    i  d     normal-:     normal-â†’    i  n  t     i  n  t       delimited-[]  ğ™¸ğš—ğšœğš    fragments   fragments  normal-(  1  normal-)   normal-,   fragments  normal-(  for-all  Î±  normal-.  Î±  normal-â†’  Î±  square-image-of-or-equals  i  n  t  normal-â†’  i  n  t  normal-)       normal-:  3  absent      proves  normal-Î“  n    normal-:      i  n  t      delimited-[]  ğš…ğšŠğš›    normal-:  n      i  n  t   normal-Î“       normal-:  4  absent      proves  normal-Î“    i  d  n     normal-:      i  n  t      delimited-[]  ğ™°ğš™ğš™    2  3      \begin{array}[]{llll}1:&\Gamma\vdash id:\forall\alpha.\alpha\rightarrow\alpha&%
 [\mathtt{Var}]&(id:\forall\alpha.\alpha\rightarrow\alpha\in\Gamma)\\
 2:&\Gamma\vdash id:int\rightarrow int&[\mathtt{Inst}]&(1),\ (\forall\alpha.%
 \alpha\rightarrow\alpha\sqsubseteq int\rightarrow int)\\
 3:&\Gamma\vdash n:int&[\mathtt{Var}]&(n:int\in\Gamma)\\
 4:&\Gamma\vdash id(n):int&[\mathtt{App}]&(2),\ (3)\\
 \end{array}     Example 3 : To demonstrate generalization,    âŠ¢   ğ¥ğğ­   i  d  =  Î»  x  .   x    ğ¢ğ§   i   d   :  âˆ€  Î±  .  Î±  â†’  Î±     fragments  proves  let  i  d   Î»  x  normal-.  x  in  i  d  normal-:  for-all  Î±  normal-.  Î±  normal-â†’  Î±    \vdash\ \textbf{let}\,id=\lambda x.x\ \textbf{in}\ id\,:\,\forall\alpha.\alpha\rightarrow\alpha   is shown below:         1  :       x  :  Î±  âŠ¢  x  :  Î±      [  ğš…ğšŠğš›  ]      (   x  :   Î±  âˆˆ   {  x  :  Î±  }     )        2  :       âŠ¢  Î»  x  .  x  :  Î±  â†’  Î±      [  ğ™°ğš‹ğšœ  ]      (  1  )        3  :       âŠ¢  Î»  x  .  x  :  âˆ€  Î±  .  Î±  â†’  Î±      [  ğ™¶ğšğš—  ]       (  2  )   ,   (  Î±  âˆ‰  f  r  e  e   (  Ïµ  )   )         4  :       i  d  :  âˆ€  Î±  .  Î±  â†’  Î±  âŠ¢  i  d  :  âˆ€  Î±  .  Î±  â†’  Î±      [  ğš…ğšŠğš›  ]      (  i  d  :  âˆ€  Î±  .  Î±  â†’  Î±  âˆˆ   {  i  d  :  âˆ€  Î±  .  Î±  â†’  Î±  }   )        5  :       âŠ¢   ğ¥ğğ­   i  d  =  Î»  x  .   x    ğ¢ğ§   i   d   :  âˆ€  Î±  .  Î±  â†’  Î±      [  ğ™»ğšğš  ]       (  3  )   ,   (  4  )           normal-:  1  absent      normal-:  x  Î±    proves    x    normal-:    Î±     delimited-[]  ğš…ğšŠğš›    normal-:  x    Î±   conditional-set  x  Î±        normal-:  2  absent    fragments  proves  Î»  x  normal-.  x  normal-:  Î±  normal-â†’  Î±    delimited-[]  ğ™°ğš‹ğšœ   1     normal-:  3  absent    fragments  proves  Î»  x  normal-.  x  normal-:  for-all  Î±  normal-.  Î±  normal-â†’  Î±    delimited-[]  ğ™¶ğšğš—    fragments   fragments  normal-(  2  normal-)   normal-,   fragments  normal-(  Î±   f  r  e  e   fragments  normal-(  Ïµ  normal-)   normal-)       normal-:  4  absent    fragments  i  d  normal-:  for-all  Î±  normal-.  Î±  normal-â†’  Î±  proves  i  d  normal-:  for-all  Î±  normal-.  Î±  normal-â†’  Î±    delimited-[]  ğš…ğšŠğš›    fragments  normal-(  i  d  normal-:  for-all  Î±  normal-.  Î±  normal-â†’  Î±    fragments  normal-{  i  d  normal-:  for-all  Î±  normal-.  Î±  normal-â†’  Î±  normal-}   normal-)      normal-:  5  absent    fragments  proves  let  i  d   Î»  x  normal-.  x  in  i  d  normal-:  for-all  Î±  normal-.  Î±  normal-â†’  Î±    delimited-[]  ğ™»ğšğš    3  4      \begin{array}[]{llll}1:&x:\alpha\vdash x:\alpha&[\mathtt{Var}]&(x:\alpha\in%
 \left\{x:\alpha\right\})\\
 2:&\vdash\lambda x.x:\alpha\rightarrow\alpha&[\mathtt{Abs}]&(1)\\
 3:&\vdash\lambda x.x:\forall\alpha.\alpha\rightarrow\alpha&[\mathtt{Gen}]&(2),%
 \ (\alpha\not\in free(\epsilon))\\
 4:&id:\forall\alpha.\alpha\rightarrow\alpha\vdash id:\forall\alpha.\alpha%
 \rightarrow\alpha&[\mathtt{Var}]&(id:\forall\alpha.\alpha\rightarrow\alpha\in%
 \left\{id:\forall\alpha.\alpha\rightarrow\alpha\right\})\\
 5:&\vdash\textbf{let}\,id=\lambda x.x\ \textbf{in}\ id\,:\,\forall\alpha.%
 \alpha\rightarrow\alpha&[\mathtt{Let}]&(3),\ (4)\\
 \end{array}     Principal type  As mentioned in the introduction , the rules allow one to deduce different types for one and the same expression. See for instance, Example 2, steps 1,2 and Example 3, steps 2,3 for three different typings of the same expression. Clearly, the different results are not fully unrelated, but connected by the type order . It is an important property of the rule system and this order that whenever more than one type can be deduced for an expression, among them is (modulo alpha-renaming of the type variables ) a unique most general type in the sense, that all others are specialization of it. Though the rule system must allow to derive specialized types, a type inference algorithm should deliver this most general or principal type as its result.  Let-polymorphism  Not visible immediately, the rule set encodes a regulation under which circumstances a type might be generalized or not by a slightly varying use of mono- and polytypes in the rules    [  ğ™°ğš‹ğšœ  ]     delimited-[]  ğ™°ğš‹ğšœ    [\mathtt{Abs}]   and    [  ğ™»ğšğš  ]     delimited-[]  ğ™»ğšğš    [\mathtt{Let}]   .  In rule    [  ğ™°ğš‹ğšœ  ]     delimited-[]  ğ™°ğš‹ğšœ    [\mathtt{Abs}]   , the value variable of the parameter of the function     Î»  x   .  e     formulae-sequence    Î»  x   e    \lambda x.e   is added to the context with a monomorphic type through the premise     Î“  ,  x   :  Ï„  âŠ¢  e  :   Ï„  â€²        normal-:   normal-Î“  x   Ï„    proves    e    normal-:     superscript  Ï„  normal-â€²      \Gamma,\ x:\tau\vdash e:\tau^{\prime}   , while in the rule    [  ğ™»ğšğš  ]     delimited-[]  ğ™»ğšğš    [\mathtt{Let}]   , the variable enters the environment in polymorphic form     Î“  ,  x   :  Ïƒ  âŠ¢   e  1   :  Ï„       normal-:   normal-Î“  x   Ïƒ    proves     subscript  e  1     normal-:    Ï„     \Gamma,\ x:\sigma\vdash e_{1}:\tau   . Though in both cases the presence of x in the context prevents the use of the generalisation rule for any monotype variable in the assignment, this regulation forces the parameter x in a   Î»   Î»   \lambda   -expression to remain monomorphic, while in a let-expression, the variable could already be introduced polymorphic, making specializations possible.  As a consequence of this regulation, no type can be inferred for     Î»  f   .   (    f   true   ,    f   0   )      formulae-sequence    Î»  f      f  true     f  0      \lambda f.(f\,\textrm{true},f\,\textrm{0})   since the parameter   f   f   f   is in a monomorphic position, while       ğ¥ğğ­   f   =   Î»  x    .    x    ğ¢ğ§    (    f   true   ,    f   0   )       formulae-sequence      let  f     Î»  x      x  in     f  true     f  0       \textbf{let}\ f=\lambda x.x\,\textbf{in}\,(f\,\textrm{true},f\,\textrm{0})   yields a type    (   b  o  o  l   ,   i  n  t   )       b  o  o  l     i  n  t     (bool,int)   , because   f   f   f   has been introduced in a let-expression and is treated polymorphic therefore. Note that this behaviour is in strong contrast to the usual definition     ğ¥ğğ­   x  =    e  1     ğ¢ğ§     e  2    :  :=   (   Î»   x  .   e  2   )    e  1      fragments  let  x    subscript  e  1   in   subscript  e  2   normal-:  assign   fragments  normal-(  Î»  x  normal-.   subscript  e  2   normal-)    subscript  e  1     \textbf{let}\ x=e_{1}\ \textbf{in}\ e_{2}\ ::=(\lambda\ x.e_{2})\ e_{1}   and the reason why the let-expression appears in the syntax at all. This distinction is called let-polymorphism or let generalization and is a conception owed to HM.  Towards an algorithm  Now that the deduction system of HM is at hand, one could present an algorithm and validate it with respect to the rules. Alternatively, it might be possible to derive it by taking a closer look on how the rules interact and proof are formed. This is done in the remainder of this article focusing on the possible decisions one can make while proving a typing.  Degrees of freedom choosing the rules  Isolating the points in a proof, where no decision is possible at all, the first group of rules centered around the syntax leaves no choice since to each syntactical rule corresponds a unique typing rule, which determines a part of the proof, while between the conclusion and the premises of these fixed parts chains of    [  ğ™¸ğš—ğšœğš  ]     delimited-[]  ğ™¸ğš—ğšœğš    [\mathtt{Inst}]   and    [  ğ™¶ğšğš—  ]     delimited-[]  ğ™¶ğšğš—    [\mathtt{Gen}]   could occur. Such a chain could also exist between the conclusion of the proof and the rule for topmost expression. All proofs must have the so sketched shape.  Because the only choice in a proof with respect of rule selection are the    [  ğ™¸ğš—ğšœğš  ]     delimited-[]  ğ™¸ğš—ğšœğš    [\mathtt{Inst}]   and    [  ğ™¶ğšğš—  ]     delimited-[]  ğ™¶ğšğš—    [\mathtt{Gen}]   chains, the form of the proof suggests the question whether it can be made more precise, where these chains might be needed. This is in fact possible and leads to a variant of the rules system with no such rules.  Syntax-directed rule system      Syntactical Rule System              x  :    Ïƒ  âˆˆ  Î“    Ï„  âŠ‘  Ïƒ      Î“  âŠ¢  x  :  Ï„        [  ğš…ğšŠğš›  ]              Î“  âŠ¢   e  0   :   Ï„  â†’    Ï„  â€²   Î“    âŠ¢   e  1   :  Ï„    Î“  âŠ¢     e  0     e  1    :   Ï„  â€²         [  ğ™°ğš™ğš™  ]               Î“  ,  x   :  Ï„  âŠ¢  e  :   Ï„  â€²     Î“  âŠ¢   Î»    x   .  e  :  Ï„  â†’   Ï„  â€²         [  ğ™°ğš‹ğšœ  ]              Î“  âŠ¢   e  0   :   Ï„  Î“  ,  x   :    Î“  Â¯    (  Ï„  )    âŠ¢   e  1   :   Ï„  â€²     Î“  âŠ¢     ğš•ğšğš   x   =     e  0     ğš’ğš—    e  1     :   Ï„  â€²         [  ğ™»ğšğš  ]            normal-:  x   formulae-sequence    Ïƒ  normal-Î“    square-image-of-or-equals  Ï„  Ïƒ        proves  normal-Î“  x    normal-:    Ï„      delimited-[]  ğš…ğšŠğš›      missing-subexpression    missing-subexpression          proves  normal-Î“   subscript  e  0     normal-:     normal-â†’  Ï„    superscript  Ï„  normal-â€²   normal-Î“      proves     subscript  e  1     normal-:    Ï„       proves  normal-Î“     subscript  e  0    subscript  e  1      normal-:     superscript  Ï„  normal-â€²       delimited-[]  ğ™°ğš™ğš™      missing-subexpression    missing-subexpression          normal-:   normal-Î“  x   Ï„    proves    e    normal-:     superscript  Ï„  normal-â€²      fragments  Î“  proves  Î»  x  normal-.  e  normal-:  Ï„  normal-â†’   superscript  Ï„  normal-â€²      delimited-[]  ğ™°ğš‹ğšœ      missing-subexpression    missing-subexpression          proves  normal-Î“   subscript  e  0     normal-:     Ï„  normal-Î“  x     normal-:       normal-Â¯  normal-Î“   Ï„     proves     subscript  e  1     normal-:     superscript  Ï„  normal-â€²        proves  normal-Î“      ğš•ğšğš  x      subscript  e  0   ğš’ğš—   subscript  e  1       normal-:     superscript  Ï„  normal-â€²       delimited-[]  ğ™»ğšğš      \begin{array}[]{cl}\displaystyle\frac{x:\sigma\in\Gamma\quad\tau\sqsubseteq%
 \sigma}{\Gamma\vdash x:\tau}&[\mathtt{Var}]\\
 \\
 \displaystyle\frac{\Gamma\vdash e_{0}:\tau\rightarrow\tau^{\prime}\quad\quad%
 \Gamma\vdash e_{1}:\tau}{\Gamma\vdash e_{0}\ e_{1}:\tau^{\prime}}&[\mathtt{App%
 }]\\
 \\
 \displaystyle\frac{\Gamma,\;x:\tau\vdash e:\tau^{\prime}}{\Gamma\vdash\lambda%
 \ x\ .\ e:\tau\rightarrow\tau^{\prime}}&[\mathtt{Abs}]\\
 \\
 \displaystyle\frac{\Gamma\vdash e_{0}:\tau\quad\quad\Gamma,\,x:\bar{\Gamma}(%
 \tau)\vdash e_{1}:\tau^{\prime}}{\Gamma\vdash\mathtt{let}\ x=e_{0}\ \mathtt{in%
 }\ e_{1}:\tau^{\prime}}&[\mathtt{Let}]\end{array}        Generalization            Î“  Â¯    (  Ï„  )    =   âˆ€    Î±  ^      .    Ï„   Î±  ^    =    free   (  Ï„  )    -   free   (  Î“  )         formulae-sequence       normal-Â¯  normal-Î“   Ï„    for-all   normal-^  Î±        Ï„   normal-^  Î±        free  Ï„     free  normal-Î“       \bar{\Gamma}(\tau)=\forall\ \hat{\alpha}\ .\ \tau\quad\quad\hat{\alpha}=%
 \textrm{free}(\tau)-\textrm{free}(\Gamma)        A contemporary treatment of HM uses a purely syntax-directed rule system due to Clement 8 as an intermediate step. In this system, the specialization is located directly after the original    [  ğš…ğšŠğš›  ]     delimited-[]  ğš…ğšŠğš›    [\mathtt{Var}]   rule and merged into it, while the generalization becomes part of the    [  ğ™»ğšğš  ]     delimited-[]  ğ™»ğšğš    [\mathtt{Let}]   rule. There the generalization is also determined to always produce the most general type by introducing the function     Î“  Â¯    (  Ï„  )        normal-Â¯  normal-Î“   Ï„    \bar{\Gamma}(\tau)   , which quantifies all monotype variables not bound in   Î“   normal-Î“   \Gamma   .  Formally, to validate, that this new rule system    âŠ¢  S     subscript  proves  S    \vdash_{S}   is equivalent to the original    âŠ¢  D     subscript  proves  D    \vdash_{D}   , one has to show that    Î“    âŠ¢  D    e  :  Ïƒ  â‡”  Î“    âŠ¢  S    e  :  Ïƒ     fragments  Î“   subscript  proves  D   e  normal-:  Ïƒ  normal-â‡”  Î“   subscript  proves  S   e  normal-:  Ïƒ    \Gamma\vdash_{D}\ e:\sigma\Leftrightarrow\Gamma\vdash_{S}\ e:\sigma   , which falls apart into two sub-proofs:       Î“    âŠ¢  D    e  :  Ïƒ  â‡  Î“    âŠ¢  S    e  :  Ïƒ     fragments  Î“   subscript  proves  D   e  normal-:  Ïƒ  normal-â‡  Î“   subscript  proves  S   e  normal-:  Ïƒ    \Gamma\vdash_{D}\ e:\sigma\Leftarrow\Gamma\vdash_{S}\ e:\sigma   ( Consistency )      Î“    âŠ¢  D    e  :  Ïƒ  â‡’  Î“    âŠ¢  S    e  :  Ïƒ     fragments  Î“   subscript  proves  D   e  normal-:  Ïƒ  normal-â‡’  Î“   subscript  proves  S   e  normal-:  Ïƒ    \Gamma\vdash_{D}\ e:\sigma\Rightarrow\Gamma\vdash_{S}\ e:\sigma   ( Completeness )   While consistency can be seen by decomposing the rules    [  ğ™»ğšğš  ]     delimited-[]  ğ™»ğšğš    [\mathtt{Let}]   and    [  ğš…ğšŠğš›  ]     delimited-[]  ğš…ğšŠğš›    [\mathtt{Var}]   of    âŠ¢  S     subscript  proves  S    \vdash_{S}   into proofs in    âŠ¢  D     subscript  proves  D    \vdash_{D}   , it is likely visible that    âŠ¢  S     subscript  proves  S    \vdash_{S}   is incomplete, as one cannot show     Î»   x  .  x  :  âˆ€  Î±  .  Î±  â†’  Î±     fragments  Î»  x  normal-.  x  normal-:  for-all  Î±  normal-.  Î±  normal-â†’  Î±    \lambda\ x.x:\forall\alpha.\alpha\rightarrow\alpha   in    âŠ¢  S     subscript  proves  S    \vdash_{S}   , for instance, but only     Î»   x  .  x  :  Î±  â†’  Î±     fragments  Î»  x  normal-.  x  normal-:  Î±  normal-â†’  Î±    \lambda\ x.x:\alpha\rightarrow\alpha   . An only slightly weaker version of completeness is provable 9 though, namely       Î“    âŠ¢  D    e  :  Ïƒ  â‡’  Î“    âŠ¢  S    e  :  Ï„  âˆ§   Î“  Â¯    (  Ï„  )   âŠ‘  Ïƒ     fragments  Î“   subscript  proves  D   e  normal-:  Ïƒ  normal-â‡’  Î“   subscript  proves  S   e  normal-:  Ï„    normal-Â¯  normal-Î“    fragments  normal-(  Ï„  normal-)   square-image-of-or-equals  Ïƒ    \Gamma\vdash_{D}\ e:\sigma\Rightarrow\Gamma\vdash_{S}\ e:\tau\wedge\bar{\Gamma%
 }(\tau)\sqsubseteq\sigma      implying, one can derive the principal type for an expression in    âŠ¢  S     subscript  proves  S    \vdash_{S}   allowing to generalize the proof in the end.  Comparing    âŠ¢  D     subscript  proves  D    \vdash_{D}   and    âŠ¢  S     subscript  proves  S    \vdash_{S}   note that only monotypes appear in the judgments of all rules, now.  Degrees of freedom instantiating the rules  Within the rules themselves, assuming a given expression, one is free to pick the instances for (rule) variables not occurring in this expression. These are the instances for the type variable in the rules. Working towards finding the most general type, this choice can be limited to picking suitable types for   Ï„   Ï„   \tau   in    [  ğš…ğšŠğš›  ]     delimited-[]  ğš…ğšŠğš›    [\mathtt{Var}]   and    [  ğ™°ğš‹ğšœ  ]     delimited-[]  ğ™°ğš‹ğšœ    [\mathtt{Abs}]   . The decision of a suitable choice cannot be made locally, but its quality becomes apparent in the premises of    [  ğ™°ğš™ğš™  ]     delimited-[]  ğ™°ğš™ğš™    [\mathtt{App}]   , the only rule, in which two different types, namely the function's formal and actual parameter type have to come together as one.  Therefore, the general strategy for finding a proof would be to make the most general assumption (    Î±  âˆ‰   f  r  e  e   (  Î“  )        Î±    f  r  e  e  normal-Î“     \alpha\not\in free(\Gamma)   ) for   Ï„   Ï„   \tau   in    [  ğ™°ğš‹ğšœ  ]     delimited-[]  ğ™°ğš‹ğšœ    [\mathtt{Abs}]   and to refine this and the choice to be made in    [  ğš…ğšŠğš›  ]     delimited-[]  ğš…ğšŠğš›    [\mathtt{Var}]   until all side conditions imposed by the    [  ğ™°ğš™ğš™  ]     delimited-[]  ğ™°ğš™ğš™    [\mathtt{App}]   rules are finally met. Fortunately, no trial and error is needed, since an effective method is known to compute all the choices, Robinson's  Unification in combination with the so-called Union-Find algorithm.  To briefly summarize the union-find algorithm, given the set of all types in a proof, it allows one to group them together into equivalence classes by means of a   ğšğš—ğš’ğš˜ğš—   ğšğš—ğš’ğš˜ğš—   \mathtt{union}   procedure and to pick a representative for each such class using a   ğšğš’ğš—ğš   ğšğš’ğš—ğš   \mathtt{find}   procedure. Emphasizing on the word procedure in the sense of side effect , we're clearly leaving the realm of logic to prepare an effective algorithm. The representative of a    ğšğš—ğš’ğš˜ğš—   (  a  ,  b  )       ğšğš—ğš’ğš˜ğš—   a  b     \mathtt{union}(a,b)   is determined such, that if both   a   a   a   and   b   b   b   are type variables the representative is arbitrarily one of them, while uniting a variable and a term, the term becomes the representative. Assuming an implementation of union-find at hand, one can formulate the unification of two monotypes as follows:  unify(ta,tb):  taÂ =Â find(ta)  tbÂ =Â find(tb)   if bothÂ ta,tbÂ areÂ termsÂ ofÂ theÂ formÂ DÂ p1..pnÂ withÂ identicalÂ D,n then  unify(ta[i],tb[i])Â forÂ eachÂ corresponding i thÂ parameter   else   if atÂ leastÂ oneÂ ofÂ ta,tbÂ isÂ aÂ typeÂ variable then  union(ta,tb)   else  errorÂ 'typesÂ doÂ notÂ match'  Algorithm W      Algorithm W              x  :    Ïƒ  âˆˆ  Î“    Ï„  =   ğ‘–ğ‘›ğ‘ ğ‘¡   (  Ïƒ  )        Î“  âŠ¢  x  :  Ï„        [  ğš…ğšŠğš›  ]              Î“  âŠ¢   e  0   :   Ï„  0   Î“  âŠ¢   e  1   :   Ï„  1    Ï„  â€²   =  ğ‘›ğ‘’ğ‘¤ğ‘£ğ‘ğ‘Ÿ  ğ‘¢ğ‘›ğ‘–ğ‘“ğ‘¦   (   Ï„  0   ,   Ï„  1   â†’   Ï„  â€²   )     Î“  âŠ¢     e  0     e  1    :   Ï„  â€²         [  ğ™°ğš™ğš™  ]               Ï„  =   ğ‘›ğ‘’ğ‘¤ğ‘£ğ‘ğ‘Ÿ  Î“  ,  x    :  Ï„  âŠ¢  e  :   Ï„  â€²     Î“  âŠ¢   Î»    x   .  e  :  Ï„  â†’   Ï„  â€²         [  ğ™°ğš‹ğšœ  ]              Î“  âŠ¢   e  0   :   Ï„  Î“  ,  x   :    Î“  Â¯    (  Ï„  )    âŠ¢   e  1   :   Ï„  â€²     Î“  âŠ¢     ğš•ğšğš   x   =     e  0     ğš’ğš—    e  1     :   Ï„  â€²         [  ğ™»ğšğš  ]            normal-:  x   formulae-sequence    Ïƒ  normal-Î“     Ï„    ğ‘–ğ‘›ğ‘ ğ‘¡  Ïƒ         proves  normal-Î“  x    normal-:    Ï„      delimited-[]  ğš…ğšŠğš›      missing-subexpression    missing-subexpression        fragments  Î“  proves   subscript  e  0   normal-:   subscript  Ï„  0    Î“  proves   subscript  e  1   normal-:   subscript  Ï„  1     superscript  Ï„  normal-â€²    newvar   unify   fragments  normal-(   subscript  Ï„  0   normal-,   subscript  Ï„  1   normal-â†’   superscript  Ï„  normal-â€²   normal-)       proves  normal-Î“     subscript  e  0    subscript  e  1      normal-:     superscript  Ï„  normal-â€²       delimited-[]  ğ™°ğš™ğš™      missing-subexpression    missing-subexpression          normal-:    Ï„   ğ‘›ğ‘’ğ‘¤ğ‘£ğ‘ğ‘Ÿ  normal-Î“  x    Ï„    proves    e    normal-:     superscript  Ï„  normal-â€²      fragments  Î“  proves  Î»  x  normal-.  e  normal-:  Ï„  normal-â†’   superscript  Ï„  normal-â€²      delimited-[]  ğ™°ğš‹ğšœ      missing-subexpression    missing-subexpression          proves  normal-Î“   subscript  e  0     normal-:     Ï„  normal-Î“  x     normal-:       normal-Â¯  normal-Î“   Ï„     proves     subscript  e  1     normal-:     superscript  Ï„  normal-â€²        proves  normal-Î“      ğš•ğšğš  x      subscript  e  0   ğš’ğš—   subscript  e  1       normal-:     superscript  Ï„  normal-â€²       delimited-[]  ğ™»ğšğš      \begin{array}[]{cl}\displaystyle\frac{x:\sigma\in\Gamma\quad\tau=\mathit{inst}%
 (\sigma)}{\Gamma\vdash x:\tau}&[\mathtt{Var}]\\
 \\
 \displaystyle\frac{\Gamma\vdash e_{0}:\tau_{0}\quad\Gamma\vdash e_{1}:\tau_{1}%
 \quad\tau^{\prime}=\mathit{newvar}\quad\mathit{unify}(\tau_{0},\ \tau_{1}%
 \rightarrow\tau^{\prime})}{\Gamma\vdash e_{0}\ e_{1}:\tau^{\prime}}&[\mathtt{%
 App}]\\
 \\
 \displaystyle\frac{\tau=\mathit{newvar}\quad\Gamma,\;x:\tau\vdash e:\tau^{%
 \prime}}{\Gamma\vdash\lambda\ x\ .\ e:\tau\rightarrow\tau^{\prime}}&[\mathtt{%
 Abs}]\\
 \\
 \displaystyle\frac{\Gamma\vdash e_{0}:\tau\quad\quad\Gamma,\,x:\bar{\Gamma}(%
 \tau)\vdash e_{1}:\tau^{\prime}}{\Gamma\vdash\mathtt{let}\ x=e_{0}\ \mathtt{in%
 }\ e_{1}:\tau^{\prime}}&[\mathtt{Let}]\end{array}        The presentation of Algorithm W as shown in the side box does not only deviate significantly from the original 10 but is also a gross abuse of the notation of logical rules, since it includes side effects. It is legitimized here, for allowing a direct comparison with    âŠ¢  S     subscript  proves  S    \vdash_{S}   while expressing an efficient implementation at the same time. The rules now specify a procedure with parameters    Î“  ,  e     normal-Î“  e    \Gamma,e   yielding   Ï„   Ï„   \tau   in the conclusion where the execution of the premises proceeds from left to right. Alternatively to a procedure, it could be viewed as an attributation of the expression.  The procedure    i  n  s  t   (  Ïƒ  )       i  n  s  t  Ïƒ    inst(\sigma)   specializes the polytype   Ïƒ   Ïƒ   \sigma   by copying the term and replacing the bound type variables consistently by new monotype variables. '    n  e  w  v  a  r      n  e  w  v  a  r    newvar   ' produces a new monotype variable. Likely,     Î“  Â¯    (  Ï„  )        normal-Â¯  normal-Î“   Ï„    \bar{\Gamma}(\tau)   has to copy the type introducing new variables for the quantification to avoid unwanted captures. Overall, the algorithm now proceeds by always making the most general choice leaving the specialization to the unification, which by itself produces the most general result. As noted above , the final result   Ï„   Ï„   \tau   has to be generalized to     Î“  Â¯    (  Ï„  )        normal-Â¯  normal-Î“   Ï„    \bar{\Gamma}(\tau)   in the end, to gain the most general type for a given expression.  Because the procedures used in the algorithm have nearly O(1) cost, the overall cost of the algorithm is close to linear in the size of the expression for which a type is to be inferred. This is in strong contrast to many other attempts to derive type inference algorithms, which often came out to be NP-hard , if not undecidable with respect to termination. Thus the HM performs as well as the best fully informed type-checking algorithms can. Type-checking here means that an algorithm does not have to find a proof, but only to validate a given one.  Efficiency is slightly reduced because the binding of type variables in the context has to be maintained to allow computation of     Î“  Â¯    (  Ï„  )        normal-Â¯  normal-Î“   Ï„    \bar{\Gamma}(\tau)   and enable an occurs check to prevent the building of recursive types during    u  n  i  o  n   (  Î±  ,  Ï„  )       u  n  i  o  n   Î±  Ï„     union(\alpha,\tau)   . An example of such a case is      Î»   x   .   (    x   x   )      formulae-sequence    Î»  x     x  x     \lambda\ x.(x\ x)   , for which no type can be derived using HM. Practically, types are only small terms and do not build up expanding structures. Thus, in complexity analysis, one can treat comparing them as a constant, retaining O(1) costs.  Original presentation of Algorithm W  In the original paper, 11 the algorithm is presented more formally using a substitution style instead of side effects in the method above. In the latter form, the side effect invisibly takes care of all places where a type variable is used. Explicitly using substitutions not only makes the algorithm hard to read, because the side effect occurs virtually everywhere, but also gives the false impression that the method might be costly. When implemented using purely functional means or for the purpose of proving the algorithm to be basically equivalent to the deduction system, full explicitness is of course needed and the original formulation a necessary refinement.  Further topics  Recursive definitions  A central property of the lambda calculus is, that recursive definitions are non-elemental, but can instead be expressed by a fixed point combinator . The original paper 12 notes that recursion can realized by this combinator's type    ğ‘“ğ‘–ğ‘¥  :  âˆ€  Î±  .   (  Î±  â†’  Î±  )   â†’  Î±     fragments  fix  normal-:  for-all  Î±  normal-.   fragments  normal-(  Î±  normal-â†’  Î±  normal-)   normal-â†’  Î±    \mathit{fix}:\forall\alpha.(\alpha\rightarrow\alpha)\rightarrow\alpha   . A possible recursive definitions could thus be formulated as     ğš›ğšğšŒ   v  =    e  1     ğš’ğš—     e  2    :  :=   ğš•ğšğš   v  =  ğ‘“ğ‘–ğ‘¥   (  Î»  v  .   e  1   )    ğš’ğš—    e  2      fragments  rec  v    subscript  e  1   in   subscript  e  2   normal-:  assign  let  v   fix   fragments  normal-(  Î»  v  normal-.   subscript  e  1   normal-)   in   subscript  e  2     \mathtt{rec}\ v=e_{1}\ \mathtt{in}\ e_{2}\ ::=\mathtt{let}\ v=\mathit{fix}(%
 \lambda v.e_{1})\ \mathtt{in}\ e_{2}   .  Alternatively an extension of the expression syntax and an extra typing rule is possible as:         Î“  ,   Î“  â€²    âŠ¢   e  1   :    Ï„  1   â€¦  Î“  ,   Î“  â€²    âŠ¢   e  n   :    Ï„  n   Î“  ,   Î“  â€²â€²    âŠ¢  e  :  Ï„     Î“   âŠ¢     ğš›ğšğšŒ    v  1    =     e  1     ğšŠğš—ğš    â€¦    ğšŠğš—ğš    v  n    =     e  n     ğš’ğš—   e    :  Ï„     [  ğšğšğšŒ  ]           proves   normal-Î“   superscript  normal-Î“  normal-â€²     subscript  e  1     normal-:      subscript  Ï„  1   normal-â€¦  normal-Î“   superscript  normal-Î“  normal-â€²      proves     subscript  e  n     normal-:      subscript  Ï„  n   normal-Î“   superscript  normal-Î“  â€²â€²      proves    e    normal-:    Ï„       proves  normal-Î“        ğš›ğšğšŒ   subscript  v  1       subscript  e  1   ğšŠğš—ğš  normal-â€¦  ğšŠğš—ğš   subscript  v  n            subscript  e  n   ğš’ğš—  e       normal-:    Ï„      delimited-[]  ğšğšğšŒ     \displaystyle\frac{\Gamma,\Gamma^{\prime}\vdash e_{1}:\tau_{1}\quad\dots\quad%
 \Gamma,\Gamma^{\prime}\vdash e_{n}:\tau_{n}\quad\Gamma,\Gamma^{\prime\prime}%
 \vdash e:\tau}{\Gamma\ \vdash\ \mathtt{rec}\ v_{1}=e_{1}\ \mathtt{and}\ \dots%
 \ \mathtt{and}\ v_{n}=e_{n}\ \mathtt{in}\ e:\tau}\quad[\mathtt{Rec}]     where         Î“  â€²   =   v  1    :    Ï„  1   ,  â€¦  ,   v  n    :   Ï„  n        normal-:     superscript  normal-Î“  normal-â€²    subscript  v  1      subscript  Ï„  1   normal-â€¦   subscript  v  n      normal-:     subscript  Ï„  n      \Gamma^{\prime}=v_{1}:\tau_{1},\ \dots,\ v_{n}:\tau_{n}           Î“  â€²â€²   =   v  1    :     Î“  Â¯    (    Ï„  1    )    ,  â€¦  ,   v  n    :    Î“  Â¯    (    Ï„  n    )         normal-:     superscript  normal-Î“  â€²â€²    subscript  v  1        normal-Â¯  normal-Î“    subscript  Ï„  1    normal-â€¦   subscript  v  n      normal-:       normal-Â¯  normal-Î“    subscript  Ï„  n       \Gamma^{\prime\prime}=v_{1}:\bar{\Gamma}(\ \tau_{1}\ ),\ \dots,\ v_{n}:\bar{%
 \Gamma}(\ \tau_{n}\ )      basically merging    [  ğ™°ğš‹ğšœ  ]     delimited-[]  ğ™°ğš‹ğšœ    [\mathtt{Abs}]   and    [  ğ™»ğšğš  ]     delimited-[]  ğ™»ğšğš    [\mathtt{Let}]   while including the recursively defined variables in monotype positions where they occur left to the   ğš’ğš—   ğš’ğš—   \mathtt{in}   but as polytypes right to it. This formulation perhaps best summarizes the essence of let-polymorphism .  Notes  References      External links   A literate Haskell implementation of Algorithm W along with its source code on GitHub .   "  Category:Type systems  Category:Type theory  Category:Type inference  Hindley-Milner type system  Category:Theoretical computer science  Category:Formal methods  Category:1969 in computer science  Category:1978 in computer science  Category:1985 in computer science  Category:Algorithms     â†©  â†©  â†©  Hindleyâ€“Milner is DEXPTIME -complete. However, non-linear behaviour only manifests itself on pathological inputs, as such the complexity theoretic proofs by  and  came as a surprise to the research community. When the depth of nested let-bindings is boundedâ€”as is the case in realistic programsâ€”Hindleyâ€“Milner type inference becomes polynomial. â†©   Polytypes are called "type schemes" in the original article. â†©  The parametric types     D   Ï„  â€¦  Ï„      D  Ï„  normal-â€¦  Ï„    D\ \tau\dots\tau   were not present in the original paper on HM and are not needed to present the method. None of the inference rules below will take care or even note them. The same holds for the non-parametric "primitive types" in said paper. All the machinery for polymorphic type inference can be defined without them. They have been included here for sake of examples but also because the nature of HM is all about parametric types. This comes from the function type    Ï„  â†’  Ï„     normal-â†’  Ï„  Ï„    \tau\rightarrow\tau   , hard-wired in the inference rules, below, which already has two parameters and has been presented here as only a special case. â†©  â†©  â†©        