<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1094">Monte Carlo localization</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Monte Carlo localization</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>A robot in a one-dimensional corridor containing doors. The goal of Monte Carlo localization is to let a robot determine its position based on its sensor observations.</figcaption>
</figure>

<p><strong>Monte Carlo localization (MCL)</strong>, also known as <strong>particle filter localization</strong>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> is an algorithm for robots to <a href="robot_localization" title="wikilink">localize</a> using a <a href="particle_filter" title="wikilink">particle filter</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Given a map of the environment, the algorithm estimates the <a href="pose_(computer_vision)" title="wikilink">position and orientation</a> of a robot as it moves and senses the environment.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The algorithm uses a <a href="particle_filter" title="wikilink">particle filter</a> to represent the <a href="probability_density_function" title="wikilink">distribution</a> of likely states, with each particle representing a possible state, i.e. a hypothesis of where the robot is.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> The algorithm typically starts with a uniform random distribution of particles over the <a href="configuration_space" title="wikilink">configuration space</a>, meaning the robot has no information about where it is and assumes it is equally likely to be at any point in space.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Whenever the robot moves, it shifts the particles to predict its new state after the movement. Whenever the robot senses something, the particles are resampled based on <a href="recursive_Bayesian_estimation" title="wikilink">recursive Bayesian estimation</a>, i.e. how well the actual sensed data correlate with the predicted state. Ultimately, the particles should converge towards the actual position of the robot.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="basic-description">Basic description</h2>

<p>Consider a robot which has an internal map of its environment. When the robot moves around, it needs to know where it is within this map. Determining its location and rotation (more generally, the <a href="pose_(computer_vision)" title="wikilink">pose</a>) by using its sensor observations is known as <a href="robot_localization" title="wikilink">robot localization</a>.</p>

<p>Because the robot may not always behave in a perfectly predictable way, it generates many random guesses of where it is going to be next. These guesses are known as particles. Each particle contains a full description of a possible future state. When the robot observes the environment, it discards particles inconsistent with this observation, and generates more particles close to those which appear consistent. In the end, hopefully most particles will converge to where the robot actually is.</p>
<h2 id="state-representation">State representation</h2>

<p>The state of the robot depends on the application and design. For example, the state of a typical 2D robot may consist of a tuple 

<math display="inline" id="Monte_Carlo_localization:0">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo>,</mo>
   <mi>θ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>x</ci>
    <ci>y</ci>
    <ci>θ</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y,\theta)
  </annotation>
 </semantics>
</math>

 for position 

<math display="inline" id="Monte_Carlo_localization:1">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>x</ci>
    <ci>y</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,y
  </annotation>
 </semantics>
</math>

 and orientation 

<math display="inline" id="Monte_Carlo_localization:2">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

. For a robotic arm with 10 joints, it may be a tuple containing the angle at each joint

<math display="block" id="Monte_Carlo_localization:3">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>θ</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>θ</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>θ</mi>
    <mn>10</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <cn type="integer">10</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\theta_{1},\theta_{2},...,\theta_{10})
  </annotation>
 </semantics>
</math>

.</p>

<p>The <em>belief</em>, which is the robot's estimate of its current state, is a <a href="probability_density_function" title="wikilink">probability density function</a> distributed over the state space.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> In the MCL algorithm, the belief at a time 

<math display="inline" id="Monte_Carlo_localization:4">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 is represented by a set of 

<math display="inline" id="Monte_Carlo_localization:5">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 <a href="Particle_filter" title="wikilink">particles</a> 

<math display="inline" id="Monte_Carlo_localization:6">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msubsup>
     <mi>x</mi>
     <mi>t</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mn>1</mn>
      <mo stretchy="false">]</mo>
     </mrow>
    </msubsup>
    <mo>,</mo>
    <msubsup>
     <mi>x</mi>
     <mi>t</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mn>2</mn>
      <mo stretchy="false">]</mo>
     </mrow>
    </msubsup>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msubsup>
     <mi>x</mi>
     <mi>t</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>M</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </msubsup>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>t</ci>
    </apply>
    <set>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>M</ci>
      </apply>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{t}=\{x_{t}^{[1]},x_{t}^{[2]},\ldots,x_{t}^{[M]}\}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Each particle contains a state, and can thus be considered a hypothesis of the robot's state. Regions in the state space with many particles correspond to a greater probability that the robot will be there; and regions with few particles are unlikely to be where the robot is.</p>

<p>The algorithm assumes the <a href="Markov_property" title="wikilink">Markov property</a> that the current state's probability distribution depends only on the previous state (and not any ones before that), i.e. 

<math display="inline" id="Monte_Carlo_localization:7">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{t}
  </annotation>
 </semantics>
</math>

 depends <em>only</em> on 

<math display="inline" id="Monte_Carlo_localization:8">
 <semantics>
  <msub>
   <mi>X</mi>
   <mrow>
    <mi>t</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <apply>
     <minus></minus>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{t-1}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> This only works if the environment is static and <a href="Time-invariant_system" title="wikilink">does not change with time</a>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Typically, on start up, the robot has no information on its current pose so the particles are uniformly distributed over the <a href="configuration_space" title="wikilink">configuration space</a>.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h2 id="overview">Overview</h2>

<p>Given a map of the environment, the goal of the algorithm is for the robot to determine its <a href="Pose_(computer_vision)" title="wikilink">pose</a> within the environment.</p>

<p>At every time 

<math display="inline" id="Monte_Carlo_localization:9">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 the algorithm takes as input the previous belief 

<math display="inline" id="Monte_Carlo_localization:10">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mrow>
     <mi>t</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msubsup>
     <mi>x</mi>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mn>1</mn>
      <mo stretchy="false">]</mo>
     </mrow>
    </msubsup>
    <mo>,</mo>
    <msubsup>
     <mi>x</mi>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mn>2</mn>
      <mo stretchy="false">]</mo>
     </mrow>
    </msubsup>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msubsup>
     <mi>x</mi>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>M</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </msubsup>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <set>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>M</ci>
      </apply>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{t-1}=\{x_{t-1}^{[1]},x_{t-1}^{[2]},\ldots,x_{t-1}^{[M]}\}
  </annotation>
 </semantics>
</math>

, an actuation command 

<math display="inline" id="Monte_Carlo_localization:11">
 <semantics>
  <msub>
   <mi>u</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{t}
  </annotation>
 </semantics>
</math>

, and data received from sensors 

<math display="inline" id="Monte_Carlo_localization:12">
 <semantics>
  <msub>
   <mi>z</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{t}
  </annotation>
 </semantics>
</math>

; and the algorithm outputs the new belief 

<math display="inline" id="Monte_Carlo_localization:13">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{t}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p><code>   </code><strong><code>Algorithm</code> <code>MCL</code></strong>

<math display="inline" id="Monte_Carlo_localization:14">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>X</mi>
    <mrow>
     <mi>t</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>u</mi>
    <mi>t</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>z</mi>
    <mi>t</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <ci>t</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (X_{t-1},u_{t},z_{t})
  </annotation>
 </semantics>
</math>

<code>:</code><br/>
<code>       </code>

<math display="inline" id="Monte_Carlo_localization:15">
 <semantics>
  <mrow>
   <mover accent="true">
    <msub>
     <mi>X</mi>
     <mi>t</mi>
    </msub>
    <mo stretchy="false">¯</mo>
   </mover>
   <mo>=</mo>
   <msub>
    <mi>X</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mi mathvariant="normal">∅</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-¯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <emptyset></emptyset>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{X_{t}}=X_{t}=\emptyset
  </annotation>
 </semantics>
</math>

<br/>
<code>       for </code>

<math display="inline" id="Monte_Carlo_localization:16">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=1
  </annotation>
 </semantics>
</math>

<code> to </code>

<math display="inline" id="Monte_Carlo_localization:17">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

<code>:</code><br/>
<code>           </code>

<math display="inline" id="Monte_Carlo_localization:18">
 <semantics>
  <mrow>
   <msubsup>
    <mi>x</mi>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>m</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>m</ci>
     </apply>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{t}^{[m]}=
  </annotation>
 </semantics>
</math>

<code> </code><strong><code>motion_update</code></strong>

<math display="inline" id="Monte_Carlo_localization:19">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>u</mi>
    <mi>t</mi>
   </msub>
   <mo>,</mo>
   <msubsup>
    <mi>x</mi>
    <mrow>
     <mi>t</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>m</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </msubsup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>m</ci>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u_{t},x_{t-1}^{[m]})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Monte_Carlo_localization:20">
 <semantics>
  <mrow>
   <msubsup>
    <mi>w</mi>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>m</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>m</ci>
     </apply>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{t}^{[m]}=
  </annotation>
 </semantics>
</math>

 <strong>sensor_update</strong>

<math display="inline" id="Monte_Carlo_localization:21">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>z</mi>
    <mi>t</mi>
   </msub>
   <mo>,</mo>
   <msubsup>
    <mi>x</mi>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>m</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </msubsup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>m</ci>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (z_{t},x_{t}^{[m]})
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Monte_Carlo_localization:22">
 <semantics>
  <mrow>
   <mover accent="true">
    <msub>
     <mi>X</mi>
     <mi>t</mi>
    </msub>
    <mo stretchy="false">¯</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mover accent="true">
     <msub>
      <mi>X</mi>
      <mi>t</mi>
     </msub>
     <mo stretchy="false">¯</mo>
    </mover>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <msubsup>
      <mi>x</mi>
      <mi>t</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>m</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </msubsup>
     <mo>,</mo>
     <msubsup>
      <mi>w</mi>
      <mi>t</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>m</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </msubsup>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-¯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>m</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>m</ci>
       </apply>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{X_{t}}=\bar{X_{t}}+\langle x_{t}^{[m]},w_{t}^{[m]}\rangle
  </annotation>
 </semantics>
</math>

</p>

<p><code>       endfor</code><br/>
<code>       for </code>

<math display="inline" id="Monte_Carlo_localization:23">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=1
  </annotation>
 </semantics>
</math>

<code> to </code>

<math display="inline" id="Monte_Carlo_localization:24">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

<code>:</code><br/>
<code>           draw </code>

<math display="inline" id="Monte_Carlo_localization:25">
 <semantics>
  <msubsup>
   <mi>x</mi>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>m</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{t}^{[m]}
  </annotation>
 </semantics>
</math>

<code> from </code>

<math display="inline" id="Monte_Carlo_localization:26">
 <semantics>
  <mover accent="true">
   <msub>
    <mi>X</mi>
    <mi>t</mi>
   </msub>
   <mo stretchy="false">¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{X_{t}}
  </annotation>
 </semantics>
</math>

<code> with probability </code>

<math display="inline" id="Monte_Carlo_localization:27">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>∝</mo>
   <msubsup>
    <mi>w</mi>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>m</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proportional-to</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \propto w_{t}^{[m]}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Monte_Carlo_localization:28">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>X</mi>
     <mi>t</mi>
    </msub>
    <mo>+</mo>
    <msubsup>
     <mi>x</mi>
     <mi>t</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>m</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{t}=X_{t}+x_{t}^{[m]}
  </annotation>
 </semantics>
</math>

</p>

<p><code>       endfor</code><br/>
<code>       return </code>

<math display="inline" id="Monte_Carlo_localization:29">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{t}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="example-for-1d-robot">Example for 1D robot</h3>

<p>Consider a robot in a one-dimensional <a href="periodic_boundary_conditions" title="wikilink">circular</a> corridor with three identical doors, using a sensor that returns <a href="Boolean_value" title="wikilink">either true or false</a> depending on whether there is a door.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>

<math display="inline" id="Monte_Carlo_localization:30">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=0
  </annotation>
 </semantics>
</math>

</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>The algorithm initializes with a uniform distribution of particles. The robot considers itself equally likely to be at any point in space along the corridor, even though it is physically at the first door.</figcaption>
</figure></td>
</tr>
</tbody>
</table>

<p><br/>
{| ! 

<math display="inline" id="Monte_Carlo_localization:31">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=1
  </annotation>
 </semantics>
</math>

 |- | | | |}</p>

<p><br/>
{| ! 

<math display="inline" id="Monte_Carlo_localization:32">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=2
  </annotation>
 </semantics>
</math>

 |- | | | |} At the end of the three iterations, most of the particles are converged on the actual position of the robot as desired.</p>
<h2 id="motion-update">Motion update</h2>

<p> During the motion update, the robot predicts its new location based on the actuation command given, by applying the simulated motion to each of the particles.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> For example, if a robot moves forward, all particles will move forward in their own directions no matter which ways they are pointing. If a robot rotates 90 degrees clockwise, all particles will rotate 90 degrees clockwise regardless of where they are. However, in the real world, no actuator is perfect: they may overshoot or undershoot the desired amount of motion; when a robot tries to drive in a straight line, it will inevitably curve to one side or the other due to minute differences in wheel radius.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> Hence, the motion model must be designed to include noise as necessary. Inevitably, the particles will diverge during the motion update as a consequence. This is expected since a robot becomes less sure of its position if it moves blindly without sensing the environment.</p>
<h2 id="sensor-update">Sensor update</h2>

<p>When the robot senses its environment, it will update its particles to more accurately reflect where it is. For each particle, the robot computes the probability that, had it been at the state of the particle, it would perceive what its sensors have actually sensed. It assigns a weight 

<math display="inline" id="Monte_Carlo_localization:33">
 <semantics>
  <msubsup>
   <mi>w</mi>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>i</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{t}^{[i]}
  </annotation>
 </semantics>
</math>

 for each particle proportional to the said probability. Then, it randomly draws 

<math display="inline" id="Monte_Carlo_localization:34">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 new particles from the previous belief, with probability proportional to 

<math display="inline" id="Monte_Carlo_localization:35">
 <semantics>
  <msubsup>
   <mi>w</mi>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>i</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{t}^{[i]}
  </annotation>
 </semantics>
</math>

. Particles which were consistent with sensor readings are more likely to be chosen (possibly more than once) and particles which are inconsistent with sensor readings are rarely picked. As such, particles converge towards a better estimate of the robot's state. This is expected since a robot becomes increasingly sure of its position as it senses its environment.</p>
<h2 id="properties">Properties</h2>
<h3 id="non-parametricity">Non-parametricity</h3>

<p>The <a href="particle_filter" title="wikilink">particle filter</a> central to MCL can approximate multiple different kinds of <a href="probability_distributions" title="wikilink">probability distributions</a>, since it is a <a href="Non-parametric_statistics" title="wikilink">non-parametric representation</a>.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> Some other Bayesian localization algorithms, such as the <a href="Kalman_filter" title="wikilink">Kalman filter</a> (and variants, the <a href="extended_Kalman_filter" title="wikilink">extended Kalman filter</a> and the <a href="unscented_Kalman_filter" title="wikilink">unscented Kalman filter</a>), assume the belief of the robot is close to being a <a href="Normal_distribution" title="wikilink">Gaussian distribution</a> and do not perform well for situations where the belief is <a href="Multimodal_distribution" title="wikilink">multimodal</a>.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> For example, a robot in a long corridor with many similar-looking doors may arrive at a belief that has a peak for each door, but the robot is unable to distinguish <em>which</em> door it is at. In such situations, the particle filter can give better performance than parametric filters.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>

<p>Another non-parametric approach to Markov localization is the grid-based localization, which uses a <a class="uri" href="histogram" title="wikilink">histogram</a> to represent the belief distribution. Compared with the grid-based approach, the Monte Carlo localization is more accurate because the state represented in samples is not discretized.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>
<h3 id="computational-requirements">Computational requirements</h3>

<p>The particle filter's <a href="time_complexity" title="wikilink">time complexity</a> is <a href="linear_time" title="wikilink">linear</a> with respect to the number of particles. Naturally, the more particles, the better the accuracy, so there is a compromise between speed and accuracy and it is desired to find an optimal value of 

<math display="inline" id="Monte_Carlo_localization:36">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

. One strategy to select 

<math display="inline" id="Monte_Carlo_localization:37">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is to continuously generate additional particles until the next pair of command 

<math display="inline" id="Monte_Carlo_localization:38">
 <semantics>
  <msub>
   <mi>u</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{t}
  </annotation>
 </semantics>
</math>

 and sensor reading 

<math display="inline" id="Monte_Carlo_localization:39">
 <semantics>
  <msub>
   <mi>z</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{t}
  </annotation>
 </semantics>
</math>

 has arrived.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> This way, the greatest possible number of particles is obtained while not impeding the function of the rest of the robot. As such, the implementation is adaptive to available computational resources: the faster the processor, the more particles can be generated and therefore the more accurate the algorithm is.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>

<p>Compared to grid-based Markov localization, Monte Carlo localization has reduced memory usage since memory usage only depends on number of particles and does not scale with size of the map,<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> and can integrate measurements at a much higher frequency.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>

<p>The algorithm can be improved using <a href="#KLD_sampling" title="wikilink">KLD sampling</a>, as described below, which adapts the number of particles to use based on how sure the robot is of its position.</p>
<h3 id="particle-deprivation">Particle deprivation</h3>

<p>A drawback of the naive implementation of Monte Carlo localization occurs in a scenario where a robot sits at one spot and repeatedly senses the environment without moving.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> Suppose that the particles all converge towards an erroneous state, or if <a href="kidnapped_robot_problem" title="wikilink">an occult hand picks up the robot and moves it to a new location</a> after particles have already converged. As particles far away from the converged state are rarely selected for the next iteration, they become scarcer on each iteration until they disappear altogether. At this point, the algorithm is unable to recover.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> This problem is more likely to occur for small number of particles, e.g. 

<math display="inline" id="Monte_Carlo_localization:40">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>≤</mo>
   <mn>50</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>M</ci>
    <cn type="integer">50</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\leq 50
  </annotation>
 </semantics>
</math>

, and when the particles are spread over a large state space.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> In fact, any <a href="particle_filter" title="wikilink">particle filter</a> algorithm may accidentally discard all particles near the correct state during the resampling step.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></p>

<p>One way to mitigate this issue is to randomly add extra particles on every iteration.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> This is equivalent to assuming that, at any point in time, the robot has some small probability of being <a href="kidnapped_robot_problem" title="wikilink">kidnapped</a> to a random position in the map, thus causing a fraction of random states in the motion model.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> By guaranteeing that no area in the map will be totally deprived of particles, the algorithm is now robust against particle deprivation.</p>
<h2 id="variants">Variants</h2>

<p>The original Monte Carlo localization algorithm is fairly simple. Several variants of the algorithm have been proposed, which address its shortcomings or adapt it to be more effective in certain situations.</p>
<h3 id="kld-sampling">KLD sampling</h3>

<p>Monte Carlo localization may be improved by sampling the particles in an adaptive manner based on an error estimate using the <a href="Kullback–Leibler_divergence" title="wikilink">Kullback–Leibler divergence</a> (KLD). Initially, it is necessary to use a large 

<math display="inline" id="Monte_Carlo_localization:41">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 due to the need to cover the entire map with a uniformly random distribution of particles. However, when the particles have converged around the same location, maintaining such a large sample size is computationally wasteful. <a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p>

<p>KLD–sampling is a variant of Monte Carlo Localization where at each iteration, a sample size 

<math display="inline" id="Monte_Carlo_localization:42">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{x}
  </annotation>
 </semantics>
</math>

 is calculated. The sample size 

<math display="inline" id="Monte_Carlo_localization:43">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{x}
  </annotation>
 </semantics>
</math>

 is calculated such that, with probability 

<math display="inline" id="Monte_Carlo_localization:44">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\delta
  </annotation>
 </semantics>
</math>

, the error between the true posterior and the sample-based approximation is less than 

<math display="inline" id="Monte_Carlo_localization:45">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

. The variables 

<math display="inline" id="Monte_Carlo_localization:46">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Monte_Carlo_localization:47">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 are fixed parameters.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></p>

<p>The main idea is to create a grid (a histogram) overlaid on the state space. Each bin in the histogram is initially empty. At each iteration, a new particle is drawn from the previous (weighted) particle set with probability proportional to its weight. Instead of the resampling done in classic MCL, the KLD–sampling algorithm draws particles from the previous, weighted, particle set and applies the motion and sensor updates before placing the particle into its bin. The algorithm keeps track of the number of non-empty bins, 

<math display="inline" id="Monte_Carlo_localization:48">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

. If a particle is inserted in a bin which used to be empty, the value of 

<math display="inline" id="Monte_Carlo_localization:49">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{x}
  </annotation>
 </semantics>
</math>

 is recalculated, which increases mostly linear in 

<math display="inline" id="Monte_Carlo_localization:50">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

. This is repeated until the sample size 

<math display="inline" id="Monte_Carlo_localization:51">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is the same as 

<math display="inline" id="Monte_Carlo_localization:52">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{x}
  </annotation>
 </semantics>
</math>

. <a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></p>

<p>It is easy to see KLD–sampling culls redundant particles from the particle set, by only increasing 

<math display="inline" id="Monte_Carlo_localization:53">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{x}
  </annotation>
 </semantics>
</math>

 when a new location (bin) has been filled. In practice, KLD–sampling consistently outperforms and converges faster than classic MCL.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Robot_navigation" title="wikilink">Category:Robot navigation</a> <a href="Category:Monte_Carlo_methods" title="wikilink">Category:Monte Carlo methods</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Ioannis M. Rekleitis. "A Particle Filter Tutorial for Mobile Robot Localization." <em>Centre for Intelligent Machines, McGill University, Tech. Rep. TR-CIM-04-02</em> (2004).<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="Frank_Dellaert" title="wikilink">Frank Dellaert</a>, Dieter Fox, <a href="Wolfram_Burgard" title="wikilink">Wolfram Burgard</a>, <a href="Sebastian_Thrun" title="wikilink">Sebastian Thrun</a>. "<a href="http://www.ri.cmu.edu/pubs/pub_533.html">Monte Carlo Localization for Mobile Robots</a>." <em>Proc. of the IEEE International Conference on Robotics and Automation</em> Vol. 2. IEEE, 1999.<a href="#fnref2">↩</a></li>
<li id="fn3">Dieter Fox, Wolfram Burgard, Frank Dellaert, and Sebastian Thrun, "<a href="http://www.cs.washington.edu/ai/Mobile_Robotics/abstracts/sampling-aaai-99.abstract.html">Monte Carlo Localization: Efficient Position Estimation for Mobile Robots</a>." <em>Proc. of the Sixteenth National Conference on Artificial Intelligence</em> John Wiley &amp; Sons Ltd, 1999.<a href="#fnref3">↩</a></li>
<li id="fn4">Sebastian Thrun, Wolfram Burgard, Dieter Fox. <a href="http://www.probabilistic-robotics.org/"><em>Probabilistic Robotics</em></a> MIT Press, 2005. Ch. 8.3 ISBN 9780262201629.<a href="#fnref4">↩</a></li>
<li id="fn5">Sebastian Thrun, Dieter Fox, Wolfram Burgard, Frank Dellaert. "<a href="http://robots.stanford.edu/papers/thrun.robust-mcl.html">Robust monte carlo localization for mobile robots</a>." <em>Artificial Intelligence</em> 128.1 (2001): 99–141.<a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24"></li>
<li id="fn25"></li>
<li id="fn26"></li>
<li id="fn27"></li>
<li id="fn28"></li>
<li id="fn29"></li>
<li id="fn30"></li>
<li id="fn31"></li>
<li id="fn32"></li>
<li id="fn33">Dieter Fox. "KLD–Sampling: Adaptive Particle Filters." <em>Department of Computer Science and Engineering, University of Washington.</em> NIPS, 2001.<a href="#fnref33">↩</a></li>
<li id="fn34"></li>
<li id="fn35"></li>
<li id="fn36"></li>
</ol>
</section>
</body>
</html>
