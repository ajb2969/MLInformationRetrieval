<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1605">Circuit complexity</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Circuit complexity</h1>
<hr/>

<p>In <a href="theoretical_computer_science" title="wikilink">theoretical computer science</a>, <strong>circuit complexity</strong> is a branch of <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a> in which <a href="Boolean_function" title="wikilink">Boolean functions</a> are classified according to the size or depth of <a href="Boolean_circuits" title="wikilink">Boolean circuits</a> that compute them. One speaks of the circuit complexity of a Boolean circuit. A related notion is the circuit complexity of a <a href="recursive_language" title="wikilink">recursive language</a> that is <a href="Machine_that_always_halts" title="wikilink">decided</a> by a family of circuits 

<math display="inline" id="Circuit_complexity:0">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>C</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1},C_{2},\ldots
  </annotation>
 </semantics>
</math>

 (see below).</p>

<p>A Boolean circuit with 

<math display="inline" id="Circuit_complexity:1">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 input <a href="bit" title="wikilink">bits</a> is a <a href="directed_acyclic_graph" title="wikilink">directed acyclic graph</a> in which every node (usually called <em>gates</em> in this context) is either an input node of <a class="uri" href="in-degree" title="wikilink">in-degree</a> 0 labeled by one of the 

<math display="inline" id="Circuit_complexity:2">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 input bits, an <a href="AND_gate" title="wikilink">AND gate</a>, an <a href="OR_gate" title="wikilink">OR gate</a>, or a <a href="NOT_gate" title="wikilink">NOT gate</a>. One of these gates is designated as the output gate. Such a circuit naturally computes a function of its 

<math display="inline" id="Circuit_complexity:3">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 inputs. The size of a circuit is the number of gates it contains and its depth is the maximal length of a path from an input gate to the output gate.</p>

<p>There are two major notions of circuit complexity (these are outlined in Sipser (1997)<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>). The <strong>circuit-size complexity</strong> of a Boolean function 

<math display="inline" id="Circuit_complexity:4">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is the minimal size of any circuit computing 

<math display="inline" id="Circuit_complexity:5">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

. The <strong>circuit-depth complexity</strong> of a Boolean function 

<math display="inline" id="Circuit_complexity:6">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is the minimal depth of any circuit computing 

<math display="inline" id="Circuit_complexity:7">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

.</p>

<p>These notions generalize when one considers the circuit complexity of a <a href="recursive_language" title="wikilink">recursive language</a>: A <a href="formal_language" title="wikilink">formal language</a> may contain strings with many different bit lengths. Boolean circuits, however, only allow a fixed number of input bits. Thus no single Boolean circuit is capable of deciding such a language. To account for this possibility, one considers families of circuits 

<math display="inline" id="Circuit_complexity:8">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>C</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1},C_{2},\ldots
  </annotation>
 </semantics>
</math>

 where each 

<math display="inline" id="Circuit_complexity:9">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n}
  </annotation>
 </semantics>
</math>

 accepts inputs of size 

<math display="inline" id="Circuit_complexity:10">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

. Each circuit family will naturally generate a recursive language by outputting 

<math display="inline" id="Circuit_complexity:11">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 when a string is a member of the family, and 

<math display="inline" id="Circuit_complexity:12">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 otherwise. We say that a family of circuits is <strong>size minimal</strong> if there is no other family that decides on inputs of any size, 

<math display="inline" id="Circuit_complexity:13">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, with a circuit of smaller size than 

<math display="inline" id="Circuit_complexity:14">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n}
  </annotation>
 </semantics>
</math>

 (respectively for <strong>depth minimal</strong> families).</p>

<p>Hence, the <strong>circuit-size complexity</strong> of a <a href="recursive_language" title="wikilink">recursive language</a> 

<math display="inline" id="Circuit_complexity:15">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is defined as the function 

<math display="inline" id="Circuit_complexity:16">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>:</mo>
   <mrow>
    <mi>ℕ</mi>
    <mo>→</mo>
    <mi>ℕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>t</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>ℕ</ci>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t:\mathbb{N}\to\mathbb{N}
  </annotation>
 </semantics>
</math>

, that relates a bit length of an input, 

<math display="inline" id="Circuit_complexity:17">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, to the circuit-size complexity of a minimal circuit 

<math display="inline" id="Circuit_complexity:18">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n}
  </annotation>
 </semantics>
</math>

 that decides whether inputs of that length are in 

<math display="inline" id="Circuit_complexity:19">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. The <strong>circuit-depth complexity</strong> is defined similarly.</p>

<p><a href="Complexity_class" title="wikilink">Complexity classes</a> defined in terms of Boolean circuits include <a href="AC0" title="wikilink">AC<sup>0</sup></a>, <a href="AC_(complexity)" title="wikilink">AC</a>, <a href="TC0" title="wikilink">TC<sup>0</sup></a> and <a href="NC_(complexity)" title="wikilink">NC</a>.</p>
<h2 id="uniformity">Uniformity</h2>

<p>Boolean circuits are one of the prime examples of so-called non-uniform <a href="abstract_machine" title="wikilink">models of computation</a> in the sense that inputs of different lengths are processed by different circuits, in contrast with uniform models such as <a href="Turing_machine" title="wikilink">Turing machines</a> where the same computational device is used for all possible input lengths. An individual <a href="computational_problem" title="wikilink">computational problem</a> is thus associated with a particular <em>family</em> of Boolean circuits 

<math display="inline" id="Circuit_complexity:20">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>C</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1},C_{2},\dots
  </annotation>
 </semantics>
</math>

 where each 

<math display="inline" id="Circuit_complexity:21">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n}
  </annotation>
 </semantics>
</math>

 is the circuit handling inputs of <em>n</em> bits. A <em>uniformity</em> condition is often imposed on these families, requiring the existence of some <a href="computational_resource" title="wikilink">resource-bounded</a> Turing machine which, on input <em>n</em>, produces a description of the individual circuit 

<math display="inline" id="Circuit_complexity:22">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n}
  </annotation>
 </semantics>
</math>

. When this Turing machine has a running time polynomial in <em>n</em>, the circuit family is said to be P-uniform. The stricter requirement of <a class="uri" href="DLOGTIME" title="wikilink">DLOGTIME</a>-uniformity is of particular interest in the study of shallow-depth circuit-classes such as AC<sup>0</sup> or TC<sup>0</sup>.</p>
<h3 id="polynomial-time-uniform">Polynomial-time uniform</h3>

<p>A family of Boolean circuits 

<math display="inline" id="Circuit_complexity:23">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>C</mi>
    <mi>n</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi>n</mi>
    <mo>∈</mo>
    <mi>ℕ</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <in></in>
     <ci>n</ci>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{C_{n}:n\in\mathbb{N}\}
  </annotation>
 </semantics>
</math>

 is <em>polynomial-time uniform</em> if there exists a <a href="deterministic_Turing_machine" title="wikilink">deterministic Turing machine</a> <em>M</em>, such that</p>
<ul>
<li><em>M</em> runs in polynomial time</li>
<li>For all 

<math display="inline" id="Circuit_complexity:24">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>∈</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>n</ci>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\in\mathbb{N}
  </annotation>
 </semantics>
</math>

, <em>M</em> outputs a description of 

<math display="inline" id="Circuit_complexity:25">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n}
  </annotation>
 </semantics>
</math>

 on input 

<math display="inline" id="Circuit_complexity:26">
 <semantics>
  <msup>
   <mn>1</mn>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">1</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1^{n}
  </annotation>
 </semantics>
</math>

</li>
</ul>
<h3 id="logspace-uniform">Logspace uniform</h3>

<p>A family of Boolean circuits 

<math display="inline" id="Circuit_complexity:27">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>C</mi>
    <mi>n</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi>n</mi>
    <mo>∈</mo>
    <mi>ℕ</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <in></in>
     <ci>n</ci>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{C_{n}:n\in\mathbb{N}\}
  </annotation>
 </semantics>
</math>

 is <em>logspace uniform</em> if there exists a <a href="deterministic_Turing_machine" title="wikilink">deterministic Turing machine</a> <em>M</em>, such that</p>
<ul>
<li><em>M</em> runs in logarithmic space</li>
<li>For all 

<math display="inline" id="Circuit_complexity:28">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>∈</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>n</ci>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\in\mathbb{N}
  </annotation>
 </semantics>
</math>

, <em>M</em> outputs a description of 

<math display="inline" id="Circuit_complexity:29">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n}
  </annotation>
 </semantics>
</math>

 on input 

<math display="inline" id="Circuit_complexity:30">
 <semantics>
  <msup>
   <mn>1</mn>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">1</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1^{n}
  </annotation>
 </semantics>
</math>

</li>
</ul>
<h2 id="history">History</h2>

<p>Circuit complexity goes back to <a href="Claude_Shannon" title="wikilink">Shannon</a> (1949), who proved that almost all Boolean functions on <em>n</em> variables require circuits of size Θ(2<sup><em>n</em></sup>/<em>n</em>). Despite this fact, complexity theorists have not been able to prove <a href="Time_complexity#Superpolynomial_time" title="wikilink">superpolynomial</a> circuit lower bounds for specific Boolean functions.</p>

<p>On the other hand, superpolynomial lower bounds have been proved under certain restrictions on the family of circuits used. The first function for which superpolynomial circuit lower bounds were shown was the <a href="parity_function" title="wikilink">parity function</a>, which computes the sum of its input bits modulo 2. The fact that parity is not contained in <a href="AC0" title="wikilink">AC<sup>0</sup></a> was first established independently by Ajtai (1983)<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and by Furst, Saxe and Sipser (1984).<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Later improvements by <a href="Johan_Håstad" title="wikilink">Håstad</a> (1987) in fact establish that any family of constant-depth circuits computing the parity function requires exponential size. Smolensky (1987) proved that this is true even if the circuit is augmented with gates computing the sum of its input bits modulo some odd prime p.</p>

<p>The <a href="clique_problem" title="wikilink"><em>k</em>-clique problem</a> is to decide whether a given graph on <em>n</em> vertices has a clique of size <em>k</em>. For any particular choice of the constants <em>n</em> and <em>k</em>, the graph can be encoded in binary using 

<math display="inline" id="Circuit_complexity:31">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mstyle scriptlevel="+1">
    <mtable columnspacing="0.4em" rowspacing="0.2ex">
     <mtr>
      <mtd>
       <mi>n</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd>
       <mn>2</mn>
      </mtd>
     </mtr>
    </mtable>
   </mstyle>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">binomial</csymbol>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {n\choose 2}
  </annotation>
 </semantics>
</math>

 bits which indicate for each possible edge whether it is present. Then the <em>k</em>-clique problem is formalized as a function 

<math display="inline" id="Circuit_complexity:32">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>k</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">}</mo>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mstyle scriptlevel="+1">
       <mtable columnspacing="0.4em" rowspacing="0.2ex">
        <mtr>
         <mtd>
          <mi>n</mi>
         </mtd>
        </mtr>
        <mtr>
         <mtd>
          <mn>2</mn>
         </mtd>
        </mtr>
       </mtable>
      </mstyle>
      <mo>)</mo>
     </mrow>
    </msup>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
      <apply>
       <csymbol cd="latexml">binomial</csymbol>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{k}:\{0,1\}^{{n\choose 2}}\to\{0,1\}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Circuit_complexity:33">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{k}
  </annotation>
 </semantics>
</math>

 outputs <em>1</em> if and only if the graph encoded by the string contains a clique of size <em>k</em>. This family of functions is monotone and can be computed by a family of circuits, but it has been shown that it cannot be computed by a polynomial-size family of monotone circuits (that is, circuits with AND and OR gates but without negation). The original result of <a href="Alexander_Razborov" title="wikilink">Razborov</a> (1985) was later improved to an exponential-size lower bound by Alon and Boppana (1987). Rossman (2008) shows that constant-depth circuits with AND, OR, and NOT gates require size 

<math display="inline" id="Circuit_complexity:34">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mrow>
      <mi>k</mi>
      <mo>/</mo>
      <mn>4</mn>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <divide></divide>
      <ci>k</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(n^{k/4})
  </annotation>
 </semantics>
</math>

 to solve the <em>k</em>-clique problem even in the <a href="average-case_complexity" title="wikilink">average case</a>. Moreover, there is a circuit of size 

<math display="inline" id="Circuit_complexity:35">
 <semantics>
  <msup>
   <mi>n</mi>
   <mrow>
    <mrow>
     <mi>k</mi>
     <mo>/</mo>
     <mn>4</mn>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <ci>k</ci>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{k/4+O(1)}
  </annotation>
 </semantics>
</math>

 which computes 

<math display="inline" id="Circuit_complexity:36">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{k}
  </annotation>
 </semantics>
</math>

.</p>

<p><a href="Ran_Raz" title="wikilink">Raz</a> and <a href="Pierre_McKenzie" title="wikilink">McKenzie</a> later showed that the monotone NC hierarchy is infinite (1999).</p>

<p>The Integer Division Problem lies in uniform <a href="TC0" title="wikilink">TC<sup>0</sup></a> (Hesse 2001).</p>
<h2 id="circuit-lower-bounds">Circuit lower bounds</h2>

<p>Circuit lower bounds are generally difficult. Known results include</p>
<ul>
<li>Parity is not in nonuniform <a href="AC0" title="wikilink">AC<sup>0</sup></a>, proved by Ajtai (1983) and by Furst, Saxe and Sipser.</li>
<li>Uniform <a href="TC0" title="wikilink">TC<sup>0</sup></a> is not contained in <a href="PP_(complexity)" title="wikilink">PP</a>, proved by Allender.</li>
<li>The classes <a href="S2P_(complexity)" title="wikilink">S</a>, PP<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> and <a href="MA_(complexity)" title="wikilink">MA</a>/1<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> (MA with one bit of advice) are not in <strong>SIZE</strong>(n<sup>k</sup>) for any constant k.</li>
<li>While it is suspected that the nonuniform class <a href="ACC0" title="wikilink">ACC<sup>0</sup></a> does not contain the majority function, it was only in 2010 that <a href="Ryan_Williams_(computer_scientist)" title="wikilink">Williams</a> proved that 

<math display="inline" id="Circuit_complexity:37">
 <semantics>
  <mrow>
   <mi>𝖭𝖤𝖷𝖯</mi>
   <mo>⊈</mo>
   <msup>
    <mi>𝖠𝖢𝖢</mi>
    <mn>0</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-subset-of-or-equals</csymbol>
    <ci>𝖭𝖤𝖷𝖯</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝖠𝖢𝖢</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathsf{NEXP}\not\subseteq\mathsf{ACC}^{0}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></li>
</ul>

<p>It is open whether NEXPTIME has nonuniform TC<sup>0</sup> circuits.</p>

<p>Proofs of circuit lower bounds are strongly connected to <a class="uri" href="derandomization" title="wikilink">derandomization</a>. A proof that <strong>P</strong> = <strong>BPP</strong> would imply that either 

<math display="inline" id="Circuit_complexity:38">
 <semantics>
  <mrow>
   <mi>𝖭𝖤𝖷𝖯</mi>
   <mo>⊈</mo>
   <mrow>
    <mi>𝖯</mi>
    <mo>/</mo>
    <mi>𝗉𝗈𝗅𝗒</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-subset-of-or-equals</csymbol>
    <ci>𝖭𝖤𝖷𝖯</ci>
    <apply>
     <divide></divide>
     <ci>𝖯</ci>
     <ci>𝗉𝗈𝗅𝗒</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathsf{NEXP}\not\subseteq\mathsf{P/poly}
  </annotation>
 </semantics>
</math>

 or that permanent cannot be computed by nonuniform arithmetic circuits (polynomials) of polynomial size and polynomial degree.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="complexity-classes">Complexity classes</h2>

<p>Many circuit complexity classes are defined in terms of class hierarchies. For each nonnegative integer <em>i</em>, there is a class <a href="NC_(complexity)" title="wikilink">NC<sup>i</sup></a>, consisting of polynomial-size circuits of depth 

<math display="inline" id="Circuit_complexity:39">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>log</mi>
      <mi>i</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <log></log>
      <ci>i</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log^{i}(n))
  </annotation>
 </semantics>
</math>

, using bounded fan-in AND, OR, and NOT gates. We can talk about the union NC of all of these classes. By considering unbounded fan-in gates, we construct the classes <a href="AC_(complexity)" title="wikilink">AC<sup>i</sup></a> and AC. We construct many other circuit complexity classes with the same size and depth restrictions by allowing different sets of gates.</p>
<h2 id="relation-to-time-complexity">Relation to time complexity<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></h2>

<p>Say that a certain language, 

<math display="inline" id="Circuit_complexity:40">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, belongs to the <a href="Complexity_class" title="wikilink">time-complexity class</a> 

<math display="inline" id="Circuit_complexity:41">
 <semantics>
  <mrow>
   <mtext>TIME</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>t</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>TIME</mtext>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{TIME}(t(n))
  </annotation>
 </semantics>
</math>

 for some function 

<math display="inline" id="Circuit_complexity:42">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>:</mo>
   <mrow>
    <mi>ℕ</mi>
    <mo>→</mo>
    <mi>ℕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>t</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>ℕ</ci>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t:\mathbb{N}\to\mathbb{N}
  </annotation>
 </semantics>
</math>

. Then 

<math display="inline" id="Circuit_complexity:43">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 has circuit complexity 

<math display="inline" id="Circuit_complexity:44">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>t</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(t^{2}(n))
  </annotation>
 </semantics>
</math>

</p>
<h2 id="references">References</h2>
<ul>
<li><mtpl></mtpl></li>
<li></li>
<li></li>
<li></li>
<li><mtpl></mtpl></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>At the time an influential textbook on the subject, commonly known as the "Blue Book". Also available for <a href="http://eccc.hpi-web.de/static/books/The_Complexity_of_Boolean_Functions/">download (PDF)</a> at the <a href="Electronic_Colloquium_on_Computational_Complexity" title="wikilink">Electronic Colloquium on Computational Complexity</a>.</p></li>
<li><a href="http://www.cs.tau.ac.il/~zwick/scribe-boolean.html">Lecture notes for a course of Uri Zwick on circuit complexity</a></li>
<li><a href="http://ftp.cs.rutgers.edu/pub/allender/fsttcs.pdf"><em>Circuit Complexity before the Dawn of the New Millennium</em></a>, a 1997 survey of the field by Eric Allender <a href="http://ftp.cs.rutgers.edu/pub/allender/fsttcs.96.slides.ps">slides</a>.</li>
</ul>

<p>"</p>

<p><a href="Category:Computational_complexity_theory" title="wikilink">Category:Computational complexity theory</a> <a href="Category:Circuit_complexity" title="wikilink"> </a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Sipser, M. (1997). 'Introduction to the theory of computation.' Boston: PWS Pub. Co.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">See <a href="Karp-Lipton_theorem#Application_for_circuit_lower_bounds_-_Kannan's_theorem" title="wikilink">proof</a><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
</ol>
</section>
</body>
</html>
