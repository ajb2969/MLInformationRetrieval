<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1220">Quasi-Monte Carlo method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Quasi-Monte Carlo method</h1>
<hr/>

<p>In <a href="numerical_analysis" title="wikilink">numerical analysis</a>, <strong>quasi-Monte Carlo method</strong> is a method for <a href="numerical_integration" title="wikilink">numerical integration</a> and solving some other problems using <a href="low-discrepancy_sequence" title="wikilink">low-discrepancy sequences</a> (also called quasi-random sequences or sub-random sequences). This is in contrast to the regular <a href="Monte_Carlo_method" title="wikilink">Monte Carlo method</a> or <a href="Monte_Carlo_integration" title="wikilink">Monte Carlo integration</a>, which are based on sequences of <a class="uri" href="pseudorandom" title="wikilink">pseudorandom</a> numbers.</p>

<p>Monte Carlo and quasi-Monte Carlo methods are stated in a similar way. The problem is to approximate the integral of a function <em>f</em> as the average of the function evaluated at a set of points <em>x</em><sub>1</sub>, ..., <em>x</em><sub><em>N</em></sub>:</p>

<p>

<math display="block" id="Quasi-Monte_Carlo_method:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <msup>
       <mrow>
        <mo stretchy="false">[</mo>
        <mn>0</mn>
        <mo>,</mo>
        <mn>1</mn>
        <mo stretchy="false">]</mo>
       </mrow>
       <mi>s</mi>
      </msup>
     </msub>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi mathvariant="normal">d</mi>
      <mi>u</mi>
     </mrow>
    </mrow>
    <mo>≈</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mfrac>
       <mn>1</mn>
       <mi>N</mi>
      </mfrac>
     </mpadded>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>N</mi>
      </munderover>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <interval closure="closed">
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </interval>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>u</ci>
      <ci>normal-d</ci>
      <ci>u</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{[0,1]^{s}}f(u)\,{\rm d}u\approx\frac{1}{N}\,\sum_{i=1}^{N}f(x_{i}).
  </annotation>
 </semantics>
</math>

</p>

<p>Since we are integrating over the <em>s</em>-dimensional unit cube, each <em>x</em><sub><em>i</em></sub> is a vector of <em>s</em> elements. The difference between quasi-Monte Carlo and Monte Carlo is the way the x<sub>i</sub> are chosen. Quasi-Monte Carlo uses a low-discrepancy sequence such as the <a href="Halton_sequence" title="wikilink">Halton sequence</a>, the <a href="Sobol_sequence" title="wikilink">Sobol sequence</a>, or the Faure sequence, whereas Monte Carlo uses a pseudorandom sequence. The advantage of using low-discrepancy sequences is a faster rate of convergence. Quasi-Monte Carlo has a rate of convergence close to O(1/N), whereas the rate for the Monte Carlo method is O(N<sup>−0.5</sup>).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The Quasi-Monte Carlo method recently became popular in the area of <a href="mathematical_finance" title="wikilink">mathematical finance</a> or <a href="computational_finance" title="wikilink">computational finance</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> In these areas, high-dimensional numerical integrals, where the integral should be evaluated within a threshold ε, occur frequently. Hence, the Monte Carlo method and the quasi-Monte Carlo method are beneficial in these situations.</p>
<h2 id="approximation-error-bounds-of-quasi-monte-carlo">Approximation error bounds of quasi-Monte Carlo</h2>

<p>The approximation error of the quasi-Monte Carlo method is bounded by a term proportional to the discrepancy of the set <em>x</em><sub>1</sub>, ..., <em>x</em><sub><em>N</em></sub>. Specifically, the <a href="Low-discrepancy_sequence#The_Koksma.E2.80.93Hlawka_inequality" title="wikilink">Koksma-Hlawka inequality</a> states that the error</p>

<p>

<math display="block" id="Quasi-Monte_Carlo_method:1">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mo>=</mo>
   <mrow>
    <mo>|</mo>
    <mrow>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∫</mo>
       <msup>
        <mrow>
         <mo stretchy="false">[</mo>
         <mn>0</mn>
         <mo>,</mo>
         <mn>1</mn>
         <mo stretchy="false">]</mo>
        </mrow>
        <mi>s</mi>
       </msup>
      </msub>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>u</mi>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <mi mathvariant="normal">d</mi>
       <mi>u</mi>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mfrac>
        <mn>1</mn>
        <mi>N</mi>
       </mfrac>
      </mpadded>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>N</mi>
       </munderover>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ϵ</ci>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <interval closure="closed">
          <cn type="integer">0</cn>
          <cn type="integer">1</cn>
         </interval>
         <ci>s</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>u</ci>
        <ci>normal-d</ci>
        <ci>u</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>N</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>N</ci>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon=\left|\int_{[0,1]^{s}}f(u)\,{\rm d}u-\frac{1}{N}\,\sum_{i=1}^{N}f(x_{%
i})\right|
  </annotation>
 </semantics>
</math>

 is bounded by</p>

<p>

<math display="block" id="Quasi-Monte_Carlo_method:2">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>ϵ</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>D</mi>
     <mi>N</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <ci>ϵ</ci>
    </apply>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\epsilon|\leq V(f)D_{N}
  </annotation>
 </semantics>
</math>

,</p>

<p>where V(f) is the Hardy-Krause variation of the function f (see Morokoff and Caflisch (1995) <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> for the detailed definitions). D<sub>N</sub> is the discrepancy of the set (x<sub>1</sub>,...,x<sub>N</sub>) and is defined as</p>

<p>

<math display="block" id="Quasi-Monte_Carlo_method:3">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mi>N</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo movablelimits="false">sup</mo>
     <mrow>
      <mi>Q</mi>
      <mo>⊂</mo>
      <msup>
       <mrow>
        <mo stretchy="false">[</mo>
        <mn>0</mn>
        <mo>,</mo>
        <mn>1</mn>
        <mo stretchy="false">]</mo>
       </mrow>
       <mi>s</mi>
      </msup>
     </mrow>
    </munder>
    <mrow>
     <mo>|</mo>
     <mrow>
      <mfrac>
       <mrow>
        <mtext>number of points in</mtext>
        <mi>Q</mi>
       </mrow>
       <mi>N</mi>
      </mfrac>
      <mo>-</mo>
      <mrow>
       <mtext>volume</mtext>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>Q</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">supremum</csymbol>
      <apply>
       <subset></subset>
       <ci>Q</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <interval closure="closed">
         <cn type="integer">0</cn>
         <cn type="integer">1</cn>
        </interval>
        <ci>s</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <mtext>number of points in</mtext>
         <ci>Q</ci>
        </apply>
        <ci>N</ci>
       </apply>
       <apply>
        <times></times>
        <mtext>volume</mtext>
        <ci>Q</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{N}=\sup_{Q\subset[0,1]^{s}}\left|\frac{\mbox{number of points in }Q}{N}-%
\mbox{volume}(Q)\right|
  </annotation>
 </semantics>
</math>

,</p>

<p>where Q is a rectangular solid in [0,1]<sup>s</sup> with sides parallel to the coordinate axes.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The inequality 

<math display="inline" id="Quasi-Monte_Carlo_method:4">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>ϵ</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>D</mi>
     <mi>N</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <ci>ϵ</ci>
    </apply>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\epsilon|\leq V(f)D_{N}
  </annotation>
 </semantics>
</math>

 can be used to show that the error of the approximation by the quasi-Monte Carlo method is 

<math display="inline" id="Quasi-Monte_Carlo_method:5">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>log</mi>
        <mi>N</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>s</mi>
     </msup>
     <mi>N</mi>
    </mfrac>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <log></log>
       <ci>N</ci>
      </apply>
      <ci>s</ci>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(\frac{(\log N)^{s}}{N}\right)
  </annotation>
 </semantics>
</math>

, whereas the Monte Carlo method has a probabilistic error of 

<math display="inline" id="Quasi-Monte_Carlo_method:6">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mi>N</mi>
     </msqrt>
    </mfrac>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(\frac{1}{\sqrt{N}}\right)
  </annotation>
 </semantics>
</math>

. Though we can only state the upper bound of the approximation error, the convergence rate of quasi-Monte Carlo method in practice is usually much faster than its theoretical bound.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Hence, in general, the accuracy of the quasi-Monte Carlo method increases faster than that of the Monte Carlo method.</p>
<h2 id="monte-carlo-and-quasi-monte-carlo-for-multidimensional-integrations">Monte Carlo and quasi-Monte Carlo for multidimensional integrations</h2>

<p>For one-dimensional integration, quadrature methods such as the <a href="trapezoidal_rule" title="wikilink">trapezoidal rule</a>, <a href="Simpson's_rule" title="wikilink">Simpson's rule</a>, or <a href="Newton–Cotes_formulas" title="wikilink">Newton–Cotes formulas</a> are known to be efficient if the function is smooth. These approaches can be also used for multidimensional integrations by repeating the one-dimensional integrals over multiple dimensions. <a href="http://ab-initio.mit.edu/wiki/index.php/Cubature">Cubature</a> is one of the well known packages using quadrature methods that work great for low-dimensional integration. However, the number of function evaluations grow exponentially as s, the number of dimensions, increases. Hence, a method that can overcome this <a href="curse_of_dimensionality" title="wikilink">curse of dimensionality</a> should be used for multidimensional integrations. The standard Monte Carlo method is frequently used when the quadrature methods are difficult or expensive to implement.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Monte Carlo and quasi-Monte Carlo methods are accurate and fast when the dimension is high, up to 300 or higher.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>Morokoff and Caflisch <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> studied the performance of Monte Carlo and quasi-Monte Carlo methods for integration. In the paper, Halton, Sobol, and Faure sequences for quasi-Monte Carlo are compared with the standard Monte Carlo method using pseudorandom sequences. They found that the Halton sequence performs best for dimensions up to around 6; the Sobol sequence performs best for higher dimensions; and the Faure sequence, while outperformed by the other two, still performs better than a pseudorandom sequence.</p>

<p>However, Morokoff and Caflisch <a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> gave examples where the advantage of the quasi-Monte Carlo is less than expected theoretically. Still, in the examples studied by Morokoff and Caflisch, the quasi-Monte Carlo method did yield a more accurate result than the Monte Carlo method with the same number of points. Morokoff and Caflisch remark that the advantage of the quasi-Monte Carlo method is greater if the integrand is smooth, and the number of dimensions <em>s</em> of the integral is small.</p>
<h2 id="drawbacks-of-quasi-monte-carlo">Drawbacks of quasi-Monte Carlo</h2>

<p>Lemieux mentioned the drawbacks of quasi-Monte Carlo:<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<ul>
<li>In order for 

<math display="inline" id="Quasi-Monte_Carlo_method:7">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>log</mi>
        <mi>N</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>s</mi>
     </msup>
     <mi>N</mi>
    </mfrac>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <log></log>
       <ci>N</ci>
      </apply>
      <ci>s</ci>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(\frac{(\log N)^{s}}{N}\right)
  </annotation>
 </semantics>
</math>

 to be smaller than 

<math display="inline" id="Quasi-Monte_Carlo_method:8">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mi>N</mi>
     </msqrt>
    </mfrac>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(\frac{1}{\sqrt{N}}\right)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Quasi-Monte_Carlo_method:9">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 needs to be small and 

<math display="inline" id="Quasi-Monte_Carlo_method:10">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 needs to be large.</li>
<li>For many functions arising in practice, 

<math display="inline" id="Quasi-Monte_Carlo_method:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>f</ci>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(f)=\infty
  </annotation>
 </semantics>
</math>

.</li>
<li>We only know an upper bound on the error(i.e., ε ≤ V(f) D<sub>N</sub>) and it is difficult to compute 

<math display="inline" id="Quasi-Monte_Carlo_method:12">
 <semantics>
  <msubsup>
   <mi>D</mi>
   <mi>N</mi>
   <mo>*</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>N</ci>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{N}^{*}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quasi-Monte_Carlo_method:13">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(f)
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>In order to overcome these difficulties, we can use a randomized quasi-Monte Carlo method.</p>
<h2 id="randomization-of-quasi-monte-carlo">Randomization of quasi-Monte Carlo</h2>

<p>Since the low discrepancy sequence are not random, but deterministic, quasi-Monte Carlo method can be seen as a deterministic algorithm or derandomized algorithm. In this case, we only have the bound (e.g., ε ≤ V(f) D<sub>N</sub>) for error, and the error is hard to estimate. In order to recover our ability to analyze and estimate the variance, we can randomize the method (see <a class="uri" href="randomization" title="wikilink">randomization</a> for the general idea). The resulting method is called the randomized quasi-Monte Carlo method and can be also viewed as a variance reduction technique for the standard Monte Carlo method.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> Among several methods, the simplest transformation procedure is through random shifting. Let {x<sub>1</sub>,...,x<sub>N</sub>} be the point set from the low discrepancy sequence. We sample s-dimensional random vector U and mix it with {x<sub>1</sub>,...,x<sub>N</sub>}. In detail, for each x<sub>j</sub>, create</p>

<p>

<math display="inline" id="Quasi-Monte_Carlo_method:14">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>j</mi>
     </msub>
     <mo>+</mo>
     <mi>U</mi>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
      <ci>U</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{j}=x_{j}+U\;\;(\mathop{{\rm mod}}1)
  </annotation>
 </semantics>
</math>

</p>

<p>and use the sequence 

<math display="inline" id="Quasi-Monte_Carlo_method:15">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>y</mi>
    <mi>j</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (y_{j})
  </annotation>
 </semantics>
</math>

 instead of 

<math display="inline" id="Quasi-Monte_Carlo_method:16">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mi>j</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{j})
  </annotation>
 </semantics>
</math>

. If we have R replications for Monte Carlo, sample s-dimensional random vector U for each replication. The drawback of randomization is the sacrifice of computation speed. Since we now use a pseudorandom number generator, the method is slower. Still, randomization is useful since the variance and the computation speed are slightly better than that of standard Monte Carlo, from the experimental results in Tuffin (2008) <a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Monte_Carlo_method" title="wikilink">Monte Carlo method</a></li>
<li><a href="Monte_Carlo_methods_in_finance" title="wikilink">Monte Carlo methods in finance</a></li>
<li><a href="Quasi-Monte_Carlo_methods_in_finance" title="wikilink">Quasi-Monte Carlo methods in finance</a></li>
<li><a href="Biology_Monte_Carlo_method" title="wikilink">Biology Monte Carlo method</a></li>
<li><a href="Computational_physics" title="wikilink">Computational physics</a></li>
<li><a href="Low-discrepancy_sequences" title="wikilink">Low-discrepancy sequences</a></li>
<li><a href="Discrepancy_theory" title="wikilink">Discrepancy theory</a></li>
<li><a href="Markov_chain_Monte_Carlo" title="wikilink">Markov chain Monte Carlo</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<ul>
<li><a href="Russel_E._Caflisch" title="wikilink">R. E. Caflisch</a>, <em>Monte Carlo and quasi-Monte Carlo methods</em>, Acta Numerica vol. 7, Cambridge University Press, 1998, pp. 1–49.</li>
<li>Josef Dick and Friedrich Pillichshammer, <em>Digital Nets and Sequences. Discrepancy Theory and Quasi-Monte Carlo Integration</em>, Cambridge University Press, Cambridge, 2010, ISBN 978-0-521-19159-3</li>
<li>Michael Drmota and Robert F. Tichy, <em>Sequences, discrepancies and applications</em>, Lecture Notes in Math., <strong>1651</strong>, Springer, Berlin, 1997, ISBN 3-540-62606-9</li>
<li>William J. Morokoff and <a href="Russel_E._Caflisch" title="wikilink">Russel E. Caflisch</a>, <em>Quasi-random sequences and their discrepancies</em>, SIAM J. Sci. Comput. <strong>15</strong> (1994), no. 6, 1251–1279 <em>(At <a class="uri" href="CiteSeer" title="wikilink">CiteSeer</a>:<a href="http://citeseer.ist.psu.edu/morokoff94quasirandom.html">2</a>)</em></li>
<li><a href="Harald_Niederreiter" title="wikilink">Harald Niederreiter</a>. <em>Random Number Generation and Quasi-Monte Carlo Methods.</em> Society for Industrial and Applied Mathematics, 1992. ISBN 0-89871-295-5</li>
<li><a href="Harald_Niederreiter" title="wikilink">Harald G. Niederreiter</a>, <em>Quasi-Monte Carlo methods and pseudo-random numbers</em>, Bull. Amer. Math. Soc. <strong>84</strong> (1978), no. 6, 957–1041</li>
<li>Oto Strauch and Štefan Porubský, <em>Distribution of Sequences: A Sampler</em>, Peter Lang Publishing House, Frankfurt am Main 2005, ISBN 3-631-54013-2</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://roth.cs.kuleuven.be/wiki/Main_Page">The MCQMC Wiki page contains a lot of free online material on Monte Carlo and quasi-Monte Carlo methods</a></li>
<li><a href="http://www.puc-rio.br/marco.ind/quasi_mc.html">A very intuitive and comprehensive introduction to Quasi-Monte Carlo methods</a></li>
</ul>

<p>"</p>

<p><a href="Category:Monte_Carlo_methods" title="wikilink">Category:Monte Carlo methods</a> <a class="uri" href="Category:Quasirandomness" title="wikilink">Category:Quasirandomness</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Søren Asmussen and Peter W. Glynn, <em>Stochastic Simulation: Algorithms and Analysis</em>, Springer, 2007, 476 pages<a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6">William J. Morokoff and <a href="Russel_E._Caflisch" title="wikilink">Russel E. Caflisch</a>, <em>Quasi-Monte Carlo integration</em>, J. Comput. Phys. <strong>122</strong> (1995), no. 2, 218--230. <em>(At <a class="uri" href="CiteSeer" title="wikilink">CiteSeer</a>: <a href="http://citeseer.ist.psu.edu/morokoff95quasimonte.html">1</a>)</em><a href="#fnref6">↩</a></li>
<li id="fn7">Rudolf Schürer, <em>A comparison between (quasi-)Monte Carlo and cubature rule based methods for solving high-dimensional integration problems</em>, Mathematics and Computers in Simulation, Volume 62, Issues 3–6, 3 March 2003, 509–517<a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10">Christiane Lemieux, <em>Monte Carlo and Quasi-Monte Carlo Sampling</em>, Springer, 2009, ISBN 978-1441926760<a href="#fnref10">↩</a></li>
<li id="fn11">Moshe Dror, Pierre L’Ecuyer and Ferenc Szidarovszky, <em>Modeling Uncertainty: An Examination of Stochastic Theory, Methods, and Applications</em>, Springer 2002, pp. 419-474<a href="#fnref11">↩</a></li>
<li id="fn12">Bruno Tuffin, <em>Randomization of Quasi-Monte Carlo Methods for Error Estimation: Survey and Normal Approximation</em>, Monte Carlo Methods and Applications mcma. Volume 10, Issue 3-4, Pages 617–628, ISSN (Online) 1569-3961, ISSN (Print) 0929-9629, DOI: 10.1515/mcma.2004.10.3-4.617, May 2008<a href="#fnref12">↩</a></li>
</ol>
</section>
</body>
</html>
