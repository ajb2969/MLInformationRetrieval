<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1185">String operations</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>String operations</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, in the area of <a href="formal_language_theory" title="wikilink">formal language theory</a>, frequent use is made of a variety of <a href="string_functions" title="wikilink">string functions</a>; however, the notation used is different from that used on <a href="computer_programming" title="wikilink">computer programming</a>, and some commonly used functions in the theoretical realm are rarely used when programming. This article defines some of these basic terms.</p>
<h2 id="strings-and-languages">Strings and languages</h2>

<p>A string is a finite sequence of characters. The <a href="empty_string" title="wikilink">empty string</a> is denoted by 

<math display="inline" id="String_operations:0">
 <semantics>
  <mi>ε</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

. The concatenation of two string 

<math display="inline" id="String_operations:1">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="String_operations:2">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 is denoted by 

<math display="inline" id="String_operations:3">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>⋅</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>s</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\cdot t
  </annotation>
 </semantics>
</math>

, or shorter by 

<math display="inline" id="String_operations:4">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   st
  </annotation>
 </semantics>
</math>

. Concatenating with the empty string makes no difference

<math display="block" id="String_operations:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mo>⋅</mo>
    <mi>ε</mi>
   </mrow>
   <mo>=</mo>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mi>ε</mi>
    <mo>⋅</mo>
    <mi>s</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-⋅</ci>
      <ci>s</ci>
      <ci>ε</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-⋅</ci>
      <ci>ε</ci>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\cdot\varepsilon=s=\varepsilon\cdot s
  </annotation>
 </semantics>
</math>

. Concatenation of strings is associative

<math display="block" id="String_operations:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>t</mi>
      <mo>⋅</mo>
      <mi>u</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>s</mi>
      <mo>⋅</mo>
      <mi>t</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⋅</mo>
    <mi>u</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <ci>s</ci>
     <apply>
      <ci>normal-⋅</ci>
      <ci>t</ci>
      <ci>u</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <ci>normal-⋅</ci>
      <ci>s</ci>
      <ci>t</ci>
     </apply>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\cdot(t\cdot u)=(s\cdot t)\cdot u
  </annotation>
 </semantics>
</math>

.</p>

<p>For example, 

<math display="inline" id="String_operations:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>b</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mo>⋅</mo>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>l</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ε</mi>
      <mo>⋅</mo>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mrow>
        <mi>a</mi>
        <mi>h</mi>
       </mrow>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>b</mi>
      <mi>l</mi>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>a</mi>
      <mi>h</mi>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>b</mi>
     <mi>l</mi>
     <mi>a</mi>
     <mi>h</mi>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="latexml">delimited-⟨⟩</csymbol>
        <ci>b</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-⟨⟩</csymbol>
        <ci>l</ci>
       </apply>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <ci>ε</ci>
       <apply>
        <csymbol cd="latexml">delimited-⟨⟩</csymbol>
        <apply>
         <times></times>
         <ci>a</ci>
         <ci>h</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="latexml">delimited-⟨⟩</csymbol>
       <apply>
        <times></times>
        <ci>b</ci>
        <ci>l</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-⟨⟩</csymbol>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>h</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <apply>
       <times></times>
       <ci>b</ci>
       <ci>l</ci>
       <ci>a</ci>
       <ci>h</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\langle b\rangle\cdot\langle l\rangle)\cdot(\varepsilon\cdot\langle ah\rangle%
)=\langle bl\rangle\cdot\langle ah\rangle=\langle blah\rangle
  </annotation>
 </semantics>
</math>

.</p>

<p>A <a href="language_(computer_science)" title="wikilink">language</a> is a finite or infinite set of strings. Besides the usual set operations like union, intersection etc., concatenation can be applied to languages: if both 

<math display="inline" id="String_operations:8">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="String_operations:9">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 are languages, their concatenation 

<math display="inline" id="String_operations:10">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⋅</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>S</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\cdot T
  </annotation>
 </semantics>
</math>

 is defined as the set of concatenations of any string from 

<math display="inline" id="String_operations:11">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 and any string from 

<math display="inline" id="String_operations:12">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

, formally 

<math display="inline" id="String_operations:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mo>⋅</mo>
    <mi>T</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>s</mi>
     <mo>⋅</mo>
     <mi>t</mi>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <mi>s</mi>
     <mo>∈</mo>
     <mrow>
      <mi>S</mi>
      <mo>∧</mo>
      <mi>t</mi>
     </mrow>
     <mo>∈</mo>
     <mi>T</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <ci>S</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <ci>normal-⋅</ci>
      <ci>s</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <and></and>
      <apply>
       <in></in>
       <ci>s</ci>
       <apply>
        <and></and>
        <ci>S</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <in></in>
       <share href="#.cmml">
       </share>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\cdot T=\{s\cdot t\mid s\in S\land t\in T\}
  </annotation>
 </semantics>
</math>

. Again, the concatenation dot 

<math display="inline" id="String_operations:14">
 <semantics>
  <mo>⋅</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⋅</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cdot
  </annotation>
 </semantics>
</math>

 is often omitted for shortness.</p>

<p>The language 

<math display="inline" id="String_operations:15">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>ε</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>ε</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\varepsilon\}
  </annotation>
 </semantics>
</math>

 consisting of just the empty string is to be distinguished from the empty language 

<math display="inline" id="String_operations:16">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list></list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\}
  </annotation>
 </semantics>
</math>

. Concatenating any language with the former doesn't make any change

<math display="block" id="String_operations:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>ε</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>ε</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>⋅</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-⋅</ci>
      <ci>S</ci>
      <set>
       <ci>ε</ci>
      </set>
     </apply>
     <ci>S</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-⋅</ci>
      <set>
       <ci>ε</ci>
      </set>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\cdot\{\varepsilon\}=S=\{\varepsilon\}\cdot S
  </annotation>
 </semantics>
</math>

, while concatenating with the latter always yields the empty language

<math display="block" id="String_operations:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">{</mo>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>⋅</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-⋅</ci>
      <ci>S</ci>
      <list></list>
     </apply>
     <list></list>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-⋅</ci>
      <list></list>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\cdot\{\}=\{\}=\{\}\cdot S
  </annotation>
 </semantics>
</math>

. Concatenation of languages is associative

<math display="block" id="String_operations:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>T</mi>
      <mo>⋅</mo>
      <mi>U</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>S</mi>
      <mo>⋅</mo>
      <mi>T</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⋅</mo>
    <mi>U</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <ci>S</ci>
     <apply>
      <ci>normal-⋅</ci>
      <ci>T</ci>
      <ci>U</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <ci>normal-⋅</ci>
      <ci>S</ci>
      <ci>T</ci>
     </apply>
     <ci>U</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\cdot(T\cdot U)=(S\cdot T)\cdot U
  </annotation>
 </semantics>
</math>

.</p>

<p>For example, abbreviating 

<math display="inline" id="String_operations:20">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mn>0</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mn>1</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mn>2</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mn>3</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mn>4</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mn>5</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mn>6</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mn>7</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mn>8</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mn>9</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <set>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <cn type="integer">5</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <cn type="integer">6</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <cn type="integer">7</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <cn type="integer">8</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <cn type="integer">9</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=\{\langle 0\rangle,\langle 1\rangle,\langle 2\rangle,\langle 3\rangle,%
\langle 4\rangle,\langle 5\rangle,\langle 6\rangle,\langle 7\rangle,\langle 8%
\rangle,\langle 9\rangle\}
  </annotation>
 </semantics>
</math>

, the set of all three-digit decimal numbers is obtained as 

<math display="inline" id="String_operations:21">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>⋅</mo>
   <mi>D</mi>
   <mo>⋅</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>D</ci>
    <ci>D</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D\cdot D\cdot D
  </annotation>
 </semantics>
</math>

. The set of all decimal numbers of arbitrary length is an example for an infinite language.</p>
<h2 id="alphabet-of-a-string">Alphabet of a string</h2>

<p>The <strong>alphabet of a string</strong> is the set of all of the characters that occur in a particular string. If <em>s</em> is a string, its <a href="alphabet_(computer_science)" title="wikilink">alphabet</a> is denoted by</p>

<p>

<math display="block" id="String_operations:22">
 <semantics>
  <mrow>
   <mo>Alph</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>Alph</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Alph}(s)
  </annotation>
 </semantics>
</math>

</p>

<p>The <strong>alphabet of a language</strong> 

<math display="inline" id="String_operations:23">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is the set of all characters that occur in any string of 

<math display="inline" id="String_operations:24">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, formally: 

<math display="inline" id="String_operations:25">
 <semantics>
  <mrow>
   <mrow>
    <mo>Alph</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋃</mo>
     <mrow>
      <mi>s</mi>
      <mo>∈</mo>
      <mi>S</mi>
     </mrow>
    </msub>
    <mrow>
     <mo>Alph</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>Alph</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <union></union>
      <apply>
       <in></in>
       <ci>s</ci>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <ci>Alph</ci>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Alph}(S)=\bigcup_{s\in S}\operatorname{Alph}(s)
  </annotation>
 </semantics>
</math>

.</p>

<p>For example, the set 

<math display="inline" id="String_operations:26">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>a</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>c</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>o</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="latexml">delimited-⟨⟩</csymbol>
     <ci>a</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-⟨⟩</csymbol>
     <ci>c</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-⟨⟩</csymbol>
     <ci>o</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\langle a\rangle,\langle c\rangle,\langle o\rangle\}
  </annotation>
 </semantics>
</math>

 is the alphabet of the string 

<math display="inline" id="String_operations:27">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mrow>
    <mi>c</mi>
    <mi>a</mi>
    <mi>c</mi>
    <mi>a</mi>
    <mi>o</mi>
   </mrow>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-⟨⟩</csymbol>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>a</ci>
     <ci>c</ci>
     <ci>a</ci>
     <ci>o</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle cacao\rangle
  </annotation>
 </semantics>
</math>

, and the <a href="#Strings_and_languages" title="wikilink">above</a> 

<math display="inline" id="String_operations:28">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 is the alphabet of the <a href="#Strings_and_languages" title="wikilink">above</a> language 

<math display="inline" id="String_operations:29">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>⋅</mo>
   <mi>D</mi>
   <mo>⋅</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>D</ci>
    <ci>D</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D\cdot D\cdot D
  </annotation>
 </semantics>
</math>

 as well as of the language of all decimal numbers.</p>
<h2 id="string-substitution">String substitution</h2>

<p>Let <em>L</em> be a <a href="language_(computer_science)" title="wikilink">language</a>, and let Σ be its alphabet. A <strong>string substitution</strong> or simply a <strong>substitution</strong> is a mapping <em>f</em> that maps letters in Σ to languages (possibly in a different alphabet). Thus, for example, given a letter <em>a</em> ∈ Σ, one has <em>f</em>(<em>a</em>)=<em>L</em><sub><em>a</em></sub> where <em>L</em><sub><em>a</em></sub> ⊆ Δ<a href="Kleene_star" title="wikilink"><sup>*</sup></a> is some language whose alphabet is Δ. This mapping may be extended to strings as</p>
<dl>
<dd><em>f</em>(ε)=ε
</dd>
</dl>

<p>for the <a href="empty_string" title="wikilink">empty string</a> ε, and</p>
<dl>
<dd><em>f</em>(<em>sa</em>)=<em>f</em>(<em>s</em>)<em>f</em>(<em>a</em>)
</dd>
</dl>

<p>for string <em>s</em> ∈ <em>L</em>. String substitutions may be extended to entire languages as <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>

<math display="block" id="String_operations:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>L</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋃</mo>
     <mrow>
      <mi>s</mi>
      <mo>∈</mo>
      <mi>L</mi>
     </mrow>
    </munder>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>L</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <union></union>
      <apply>
       <in></in>
       <ci>s</ci>
       <ci>L</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(L)=\bigcup_{s\in L}f(s)
  </annotation>
 </semantics>
</math>

</p>

<p><a href="Regular_language" title="wikilink">Regular languages</a> are closed under string substitution. That is, if each letter of a regular language is substituted by another regular language, the result is still a regular language.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Similarly, <a href="context-free_language" title="wikilink">context-free languages</a> are closed under string substitution.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>A simple example is the conversion <em>f</em><sub>uc</sub>(.) to upper case, which may be defined e.g. as follows:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>letter</p></th>
<th style="text-align: left;">
<p>mapped to language</p></th>
<th style="text-align: left;">
<p>remark</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>x</em></p></td>
<td style="text-align: left;">
<p><em>f</em><sub>uc</sub>(<em>x</em>)</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>‹<em>a</em>›</p></td>
<td style="text-align: left;">
<p>{ ‹<em>A</em>› }</p></td>
<td style="text-align: left;">
<p>map lower-case char to corresponding upper-case char</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>‹<em>A</em>›</p></td>
<td style="text-align: left;">
<p>{ ‹<em>A</em>› }</p></td>
<td style="text-align: left;">
<p>map upper-case char to itself</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>‹<em>ß</em>›</p></td>
<td style="text-align: left;">
<p>{ ‹<em>SS</em>› }</p></td>
<td style="text-align: left;">
<p>no upper-case char available, map to two-char string</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>‹0›</p></td>
<td style="text-align: left;">
<p>{ ε }</p></td>
<td style="text-align: left;">
<p>map digit to empty string</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>‹!›</p></td>
<td style="text-align: left;">
<p>{ }</p></td>
<td style="text-align: left;">
<p>forbid punctuation, map to empty language</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>...</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>similar for other chars</p></td>
</tr>
</tbody>
</table>

<p>For the extension of <em>f</em><sub>uc</sub> to strings, we have e.g.</p>
<ul>
<li><em>f</em><sub>uc</sub>(‹Straße›) = {‹S›} ⋅ {‹T›} ⋅ {‹R›} ⋅ {‹A›} ⋅ {‹SS›} ⋅ {‹E›} = {‹STRASSE›},</li>
<li><em>f</em><sub>uc</sub>(‹u2›) = {‹U›} ⋅ {ε} = {‹U›}, and</li>
<li><em>f</em><sub>uc</sub>(‹Go!›) = {‹G›} ⋅ {‹O›} ⋅ {} = {}.</li>
</ul>

<p>For the extension of <em>f</em><sub>uc</sub> to languages, we have e.g.</p>
<ul>
<li><em>f</em><sub>uc</sub>({ ‹Straße›, ‹u2›, ‹Go!› }) = { ‹STRASSE› } ∪ { ‹U› } ∪ { } = { ‹STRASSE›, ‹U› }.</li>
</ul>

<p>Another example is the conversion of an <a class="uri" href="EBCDIC" title="wikilink">EBCDIC</a>-encoded string to <a class="uri" href="ASCII" title="wikilink">ASCII</a>.</p>
<h2 id="string-homomorphism">String homomorphism</h2>

<p>A <strong>string homomorphism</strong> (often referred to simply as a <a href="Homomorphism#Homomorphisms_and_e-free_homomorphisms_in_formal_language_theory" title="wikilink">homomorphism</a> in <a href="formal_language_theory" title="wikilink">formal language theory</a>) is a string substitution such that each letter is replaced by a single string. That is, <em>f</em>(<em>a</em>)=<em>s</em>, where <em>s</em> is a string, for each letter <em>a</em>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>String homomorphisms are <a href="monoid_morphism" title="wikilink">monoid morphisms</a> on the <a href="free_monoid" title="wikilink">free monoid</a>, preserving the <a href="binary_operation" title="wikilink">binary operation</a> of <a href="string_concatenation" title="wikilink">string concatenation</a>. Given a language <em>L</em>, the set <em>f</em>(<em>L</em>) is called the <strong>homomorphic image</strong> of <em>L</em>. The <strong>inverse homomorphic image</strong> of a string <em>s</em> is defined as</p>
<dl>
<dd><em>f</em><sup>−1</sup>(<em>s</em>) = { <em>w</em> | <em>f</em>(<em>w</em>)=<em>s</em> }
</dd>
</dl>

<p>while the inverse homomorphic image of a language <em>L</em> is defined as</p>
<dl>
<dd><em>f</em><sup>−1</sup>(<em>L</em>) = { <em>s</em> | <em>f</em>(<em>s</em>) ∈ <em>L</em> }
</dd>
</dl>

<p>In general, <em>f</em>(<em>f</em><sup>−1</sup>(<em>L</em>)) ≠ <em>L</em>, while one does have</p>
<dl>
<dd><em>f</em>(<em>f</em><sup>−1</sup>(<em>L</em>)) ⊆ <em>L</em>
</dd>
</dl>

<p>and</p>
<dl>
<dd><em>L</em> ⊆ <em>f</em><sup>−1</sup>(<em>f</em>(<em>L</em>))
</dd>
</dl>

<p>for any language <em>L</em>.</p>

<p>The class of regular languages is closed under homomorphisms and inverse homomorphisms.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Similarly, the context-free languages are closed under homomorphisms<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> and inverse homomorphisms.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>A string homomorphism is said to be ε-free (or e-free) if <em>f</em>(<em>a</em>) ≠ ε for all <em>a</em> in the alphabet Σ. Simple single-letter <a href="substitution_cipher" title="wikilink">substitution ciphers</a> are examples of (ε-free) string homomorphisms.</p>

<p>An example string homomorphism <em>g</em><sub>uc</sub> can also be obtained by defining similar to the <a href="#String_substitution" title="wikilink">above</a> substitution: <em>g</em><sub>uc</sub>(‹a›) = ‹A›, ..., <em>g</em><sub>uc</sub>(‹0›) = ε, but letting <em>g</em><sub>uc</sub> undefined on punctuation chars.</p>

<p>Examples for inverse homomorphic images are</p>
<ul>
<li><em>g</em><sub>uc</sub><sup>−1</sup>({ ‹SSS› }) = { ‹sss›, ‹sß›, ‹ßs› }, since <em>g</em><sub>uc</sub>(‹sss›) = <em>g</em><sub>uc</sub>(‹sß›) = <em>g</em><sub>uc</sub>(‹ßs›) = ‹SSS›, and</li>
<li><em>g</em><sub>uc</sub><sup>−1</sup>({ ‹A›, ‹bb› }) = { ‹a› }, since <em>g</em><sub>uc</sub>(‹a›) = ‹A›, while ‹bb› cannot be reached by <em>g</em><sub>uc</sub>.</li>
</ul>

<p>For the latter language, <em>g</em><sub>uc</sub>(<em>g</em><sub>uc</sub><sup>−1</sup>({ ‹A›, ‹bb› })) = <em>g</em><sub>uc</sub>({ ‹a› }) = { ‹A› } ≠ { ‹A›, ‹bb› }. The homomorphism <em>g</em><sub>uc</sub> is not ε-free, since it maps e.g. ‹0› to ε.</p>
<h2 id="string-projection">String projection</h2>

<p>If <em>s</em> is a string, and 

<math display="inline" id="String_operations:31">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

 is an alphabet, the <strong>string projection</strong> of <em>s</em> is the string that results by removing all letters which are not in 

<math display="inline" id="String_operations:32">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

. It is written as 

<math display="inline" id="String_operations:33">
 <semantics>
  <mrow>
   <msub>
    <mi>π</mi>
    <mi mathvariant="normal">Σ</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <ci>normal-Σ</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{\Sigma}(s)\,
  </annotation>
 </semantics>
</math>

. It is formally defined by removal of letters from the right hand side:</p>

<p>

<math display="block" id="String_operations:34">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>π</mi>
     <mi mathvariant="normal">Σ</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mi>ε</mi>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>s</mi>
        </mrow>
        <mo>=</mo>
        <mrow>
         <mi>ε</mi>
         <mtext>the empty string</mtext>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <msub>
         <mi>π</mi>
         <mi mathvariant="normal">Σ</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>s</mi>
        </mrow>
        <mo>=</mo>
        <mrow>
         <mi>t</mi>
         <mi>a</mi>
         <mtext>and</mtext>
         <mi>a</mi>
        </mrow>
        <mo>∉</mo>
        <mi mathvariant="normal">Σ</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <msub>
         <mi>π</mi>
         <mi mathvariant="normal">Σ</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>a</mi>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>s</mi>
        </mrow>
        <mo>=</mo>
        <mrow>
         <mi>t</mi>
         <mi>a</mi>
         <mtext>and</mtext>
         <mi>a</mi>
        </mrow>
        <mo>∈</mo>
        <mi mathvariant="normal">Σ</mi>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <ci>normal-Σ</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <ci>ε</ci>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>s</ci>
      </apply>
      <apply>
       <times></times>
       <ci>ε</ci>
       <mtext>the empty string</mtext>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <ci>normal-Σ</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <and></and>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <mtext>if</mtext>
        <ci>s</ci>
       </apply>
       <apply>
        <times></times>
        <ci>t</ci>
        <ci>a</ci>
        <mtext>and</mtext>
        <ci>a</ci>
       </apply>
      </apply>
      <apply>
       <notin></notin>
       <share href="#.cmml">
       </share>
       <ci>normal-Σ</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <ci>normal-Σ</ci>
      </apply>
      <ci>t</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <and></and>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <mtext>if</mtext>
        <ci>s</ci>
       </apply>
       <apply>
        <times></times>
        <ci>t</ci>
        <ci>a</ci>
        <mtext>and</mtext>
        <ci>a</ci>
       </apply>
      </apply>
      <apply>
       <in></in>
       <share href="#.cmml">
       </share>
       <ci>normal-Σ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{\Sigma}(s)=\begin{cases}\varepsilon&\mbox{if }s=\varepsilon\mbox{ the %
empty string}\\
\pi_{\Sigma}(t)&\mbox{if }s=ta\mbox{ and }a\notin\Sigma\\
\pi_{\Sigma}(t)a&\mbox{if }s=ta\mbox{ and }a\in\Sigma\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>Here 

<math display="inline" id="String_operations:35">
 <semantics>
  <mi>ε</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

 denotes the <a href="empty_string" title="wikilink">empty string</a>. The projection of a string is essentially the same as a <a href="projection_in_relational_algebra" title="wikilink">projection in relational algebra</a>.</p>

<p>String projection may be promoted to the <strong>projection of a language</strong>. Given a <a href="formal_language" title="wikilink">formal language</a> <em>L</em>, its projection is given by</p>

<p>

<math display="block" id="String_operations:36">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>π</mi>
     <mi mathvariant="normal">Σ</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>L</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <msub>
      <mi>π</mi>
      <mi mathvariant="normal">Σ</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">|</mo>
    <mrow>
     <mi>s</mi>
     <mo>∈</mo>
     <mi>L</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <ci>normal-Σ</ci>
     </apply>
     <ci>L</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <ci>normal-Σ</ci>
      </apply>
      <ci>s</ci>
     </apply>
     <apply>
      <in></in>
      <ci>s</ci>
      <ci>L</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{\Sigma}(L)=\{\pi_{\Sigma}(s)\ |\ s\in L\}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="right-quotient">Right quotient</h2>

<p>The <strong>right quotient</strong> of a letter <em>a</em> from a string <em>s</em> is the truncation of the letter <em>a</em> in the string <em>s</em>, from the right hand side. It is denoted as 

<math display="inline" id="String_operations:37">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>/</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>s</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s/a
  </annotation>
 </semantics>
</math>

. If the string does not have <em>a</em> on the right hand side, the result is the empty string. Thus:</p>

<p>

<math display="block" id="String_operations:38">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>s</mi>
      <mi>a</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mi>b</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mi>s</mi>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>a</mi>
        </mrow>
        <mo>=</mo>
        <mi>b</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mi>ε</mi>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>a</mi>
        </mrow>
        <mo>≠</mo>
        <mi>b</mi>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>a</ci>
     </apply>
     <ci>b</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <ci>s</ci>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>a</ci>
      </apply>
      <ci>b</ci>
     </apply>
     <ci>ε</ci>
     <apply>
      <neq></neq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>a</ci>
      </apply>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (sa)/b=\begin{cases}s&\mbox{if }a=b\\
\varepsilon&\mbox{if }a\neq b\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>The quotient of the empty string may be taken:</p>

<p>

<math display="block" id="String_operations:39">
 <semantics>
  <mrow>
   <mrow>
    <mi>ε</mi>
    <mo>/</mo>
    <mi>a</mi>
   </mrow>
   <mo>=</mo>
   <mi>ε</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>ε</ci>
     <ci>a</ci>
    </apply>
    <ci>ε</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon/a=\varepsilon
  </annotation>
 </semantics>
</math>

</p>

<p>Similarly, given a subset 

<math display="inline" id="String_operations:40">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊂</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subset M
  </annotation>
 </semantics>
</math>

 of a monoid 

<math display="inline" id="String_operations:41">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

, one may define the quotient subset as</p>

<p>

<math display="block" id="String_operations:42">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mo>/</mo>
    <mi>a</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>s</mi>
     <mo>∈</mo>
     <mpadded width="+5pt">
      <mi>M</mi>
     </mpadded>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>s</mi>
      <mi>a</mi>
     </mrow>
     <mo>∈</mo>
     <mi>S</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>S</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>s</ci>
      <ci>M</ci>
     </apply>
     <apply>
      <in></in>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>a</ci>
      </apply>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S/a=\{s\in M\ |\ sa\in S\}
  </annotation>
 </semantics>
</math>

</p>

<p>Left quotients may be defined similarly, with operations taking place on the left of a string.</p>
<h2 id="syntactic-relation">Syntactic relation</h2>

<p>The right quotient of a subset 

<math display="inline" id="String_operations:43">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊂</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subset M
  </annotation>
 </semantics>
</math>

 of a monoid 

<math display="inline" id="String_operations:44">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 defines an <a href="equivalence_relation" title="wikilink">equivalence relation</a>, called the <strong>right <a href="syntactic_relation" title="wikilink">syntactic relation</a></strong> of <em>S</em>. It is given by</p>

<p>

<math display="block" id="String_operations:45">
 <semantics>
  <mrow>
   <mpadded width="+4.5pt">
    <msub>
     <mo>∼</mo>
     <mi>S</mi>
    </msub>
   </mpadded>
   <mo rspace="4.2pt">=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>M</mi>
    <mo>×</mo>
    <mpadded width="+5pt">
     <mi>M</mi>
    </mpadded>
    <mo rspace="7.5pt" stretchy="false">|</mo>
    <mi>S</mi>
    <mo>/</mo>
    <mi>s</mi>
    <mo>=</mo>
    <mi>S</mi>
    <mo>/</mo>
    <mi>t</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">similar-to</csymbol>
     <ci>S</ci>
    </apply>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">M</csymbol>
     <times></times>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">S</csymbol>
     <divide></divide>
     <csymbol cd="unknown">s</csymbol>
     <eq></eq>
     <csymbol cd="unknown">S</csymbol>
     <divide></divide>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sim_{S}\;\,=\,\{(s,t)\in M\times M\ |\ S/s=S/t\}
  </annotation>
 </semantics>
</math>

</p>

<p>The relation is clearly of finite index (has a finite number of equivalence classes) if and only if the family right quotients is finite; that is, if</p>

<p>

<math display="block" id="String_operations:46">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>S</mi>
    <mo>/</mo>
    <mpadded width="+5pt">
     <mi>m</mi>
    </mpadded>
   </mrow>
   <mo rspace="7.5pt" stretchy="false">|</mo>
   <mrow>
    <mi>m</mi>
    <mo>∈</mo>
    <mi>M</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <divide></divide>
     <ci>S</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <in></in>
     <ci>m</ci>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{S/m\ |\ m\in M\}
  </annotation>
 </semantics>
</math>

</p>

<p>is finite. In this case, <em>S</em> is a <a href="recognizable_language" title="wikilink">recognizable language</a>, that is, a language that can be recognized by a <a href="finite_state_automaton" title="wikilink">finite state automaton</a>. This is discussed in greater detail in the article on <a href="syntactic_monoid" title="wikilink">syntactic monoids</a>.</p>
<h2 id="right-cancellation">Right cancellation</h2>

<p>The <strong>right cancellation</strong> of a letter <em>a</em> from a string <em>s</em> is the removal of the first occurrence of the letter <em>a</em> in the string <em>s</em>, starting from the right hand side. It is denoted as 

<math display="inline" id="String_operations:47">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>÷</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>s</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\div a
  </annotation>
 </semantics>
</math>

 and is recursively defined as</p>

<p>

<math display="block" id="String_operations:48">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>s</mi>
      <mi>a</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>÷</mo>
    <mi>b</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mi>s</mi>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>a</mi>
        </mrow>
        <mo>=</mo>
        <mi>b</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>s</mi>
          <mo>÷</mo>
          <mi>b</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>a</mi>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>a</mi>
        </mrow>
        <mo>≠</mo>
        <mi>b</mi>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>a</ci>
     </apply>
     <ci>b</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <ci>s</ci>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>a</ci>
      </apply>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>s</ci>
       <ci>b</ci>
      </apply>
      <ci>a</ci>
     </apply>
     <apply>
      <neq></neq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>a</ci>
      </apply>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (sa)\div b=\begin{cases}s&\mbox{if }a=b\\
(s\div b)a&\mbox{if }a\neq b\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>The empty string is always cancellable:</p>

<p>

<math display="block" id="String_operations:49">
 <semantics>
  <mrow>
   <mrow>
    <mi>ε</mi>
    <mo>÷</mo>
    <mi>a</mi>
   </mrow>
   <mo>=</mo>
   <mi>ε</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>ε</ci>
     <ci>a</ci>
    </apply>
    <ci>ε</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon\div a=\varepsilon
  </annotation>
 </semantics>
</math>

</p>

<p>Clearly, right cancellation and projection <a href="Commutative_property" title="wikilink">commute</a>:</p>

<p>

<math display="block" id="String_operations:50">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>π</mi>
      <mi mathvariant="normal">Σ</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>÷</mo>
    <mi>a</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>π</mi>
     <mi mathvariant="normal">Σ</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>s</mi>
      <mo>÷</mo>
      <mi>a</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <ci>normal-Σ</ci>
      </apply>
      <ci>s</ci>
     </apply>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <ci>normal-Σ</ci>
     </apply>
     <apply>
      <divide></divide>
      <ci>s</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{\Sigma}(s)\div a=\pi_{\Sigma}(s\div a)
  </annotation>
 </semantics>
</math>

</p>
<h2 id="prefixes">Prefixes</h2>

<p>The <strong>prefixes of a string</strong> is the set of all <a href="prefix_(computer_science)" title="wikilink">prefixes</a> to a string, with respect to a given language:</p>

<p>

<math display="block" id="String_operations:51">
 <semantics>
  <mrow>
   <msub>
    <mo>Pref</mo>
    <mi>L</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mpadded width="+5pt">
     <mi>t</mi>
    </mpadded>
    <mo rspace="7.5pt" stretchy="false">|</mo>
    <mi>s</mi>
    <mo>=</mo>
    <mi>t</mi>
    <mi>u</mi>
    <mtext>for</mtext>
    <mi>t</mi>
    <mo>,</mo>
    <mi>u</mi>
    <mo>∈</mo>
    <mo>Alph</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>L</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>*</mo>
    </msup>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Pref</ci>
     <ci>L</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">s</csymbol>
     <eq></eq>
     <csymbol cd="unknown">t</csymbol>
     <csymbol cd="unknown">u</csymbol>
     <mtext>for</mtext>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">u</csymbol>
     <in></in>
     <ci>Alph</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">L</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <times></times>
     </apply>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Pref}_{L}(s)=\{t\ |\ s=tu\mbox{ for }t,u\in\operatorname{Alph}(L%
)^{*}\}
  </annotation>
 </semantics>
</math>

</p>

<p>here 

<math display="inline" id="String_operations:52">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in L
  </annotation>
 </semantics>
</math>

.</p>

<p>The <strong>prefix closure of a language</strong> is</p>

<p>

<math display="block" id="String_operations:53">
 <semantics>
  <mrow>
   <mo>Pref</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>L</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <munder>
    <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋃</mo>
    <mrow>
     <mi>s</mi>
     <mo>∈</mo>
     <mi>L</mi>
    </mrow>
   </munder>
   <msub>
    <mo>Pref</mo>
    <mi>L</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mpadded width="+5pt">
     <mi>t</mi>
    </mpadded>
    <mo rspace="7.5pt" stretchy="false">|</mo>
    <mi>s</mi>
    <mo>=</mo>
    <mi>t</mi>
    <mi>u</mi>
    <mo>;</mo>
    <mi>s</mi>
    <mo>∈</mo>
    <mi>L</mi>
    <mo>;</mo>
    <mi>t</mi>
    <mo>,</mo>
    <mi>u</mi>
    <mo>∈</mo>
    <mo>Alph</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>L</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>*</mo>
    </msup>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>Pref</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">L</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <union></union>
     <apply>
      <in></in>
      <ci>s</ci>
      <ci>L</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Pref</ci>
     <ci>L</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">s</csymbol>
     <eq></eq>
     <csymbol cd="unknown">t</csymbol>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-;</ci>
     <csymbol cd="unknown">s</csymbol>
     <in></in>
     <csymbol cd="unknown">L</csymbol>
     <ci>normal-;</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">u</csymbol>
     <in></in>
     <ci>Alph</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">L</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <times></times>
     </apply>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Pref}(L)=\bigcup_{s\in L}\operatorname{Pref}_{L}(s)=\left\{t\ |%
\ s=tu;s\in L;t,u\in\operatorname{Alph}(L)^{*}\right\}
  </annotation>
 </semantics>
</math>

</p>

<p><strong>Example:</strong><br/>


<math display="inline" id="String_operations:54">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
      <mi>c</mi>
     </mrow>
     <mo>}</mo>
    </mrow>
    <mtext>then</mtext>
    <mrow>
     <mo>Pref</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>L</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mi>ε</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
     <mi>c</mi>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>L</ci>
     <apply>
      <times></times>
      <set>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
        <ci>c</ci>
       </apply>
      </set>
      <mtext>then</mtext>
      <apply>
       <ci>Pref</ci>
       <ci>L</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <set>
      <ci>ε</ci>
      <ci>a</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
       <ci>c</ci>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=\left\{abc\right\}\mbox{ then }\operatorname{Pref}(L)=\left\{\varepsilon,a,%
ab,abc\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>A language is called <strong>prefix closed</strong> if 

<math display="inline" id="String_operations:55">
 <semantics>
  <mrow>
   <mrow>
    <mo>Pref</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>L</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>Pref</ci>
     <ci>L</ci>
    </apply>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Pref}(L)=L
  </annotation>
 </semantics>
</math>

.</p>

<p>The prefix closure operator is <a class="uri" href="idempotent" title="wikilink">idempotent</a>:</p>

<p>

<math display="block" id="String_operations:56">
 <semantics>
  <mrow>
   <mrow>
    <mo>Pref</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>Pref</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>L</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>Pref</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>L</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>Pref</ci>
     <apply>
      <ci>Pref</ci>
      <ci>L</ci>
     </apply>
    </apply>
    <apply>
     <ci>Pref</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Pref}(\operatorname{Pref}(L))=\operatorname{Pref}(L)
  </annotation>
 </semantics>
</math>

</p>

<p>The <strong>prefix relation</strong> is a <a href="binary_relation" title="wikilink">binary relation</a> 

<math display="inline" id="String_operations:57">
 <semantics>
  <mo>⊑</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">square-image-of-or-equals</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqsubseteq
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="String_operations:58">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>⊑</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">square-image-of-or-equals</csymbol>
    <ci>s</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\sqsubseteq t
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="String_operations:59">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <mrow>
    <msub>
     <mo>Pref</mo>
     <mi>L</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Pref</ci>
      <ci>L</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in\operatorname{Pref}_{L}(t)
  </annotation>
 </semantics>
</math>

. This relation is a particular example of a <a href="prefix_order" title="wikilink">prefix order</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Comparison_of_programming_languages_(string_functions)" title="wikilink">Comparison of programming languages (string functions)</a></li>
<li><a href="Levi's_lemma" title="wikilink">Levi's lemma</a></li>
<li><a href="String_(computer_science)#Formal_theory" title="wikilink">String (computer science)</a> — definition and implementation of more basic operations on strings</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p><em>(See chapter 3.)</em></p></li>
</ul>

<p>"</p>

<p><a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a> <a href="Category:Relational_algebra" title="wikilink">Category:Relational algebra</a> <a href="Category:String_(computer_science)" title="wikilink">Operations</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Hopcroft, Ullman (1979), Sect.3.2, p.60<a href="#fnref1">↩</a></li>
<li id="fn2">Hopcroft, Ullman (1979), Sect.3.2, Theorem 3.4, p.60<a href="#fnref2">↩</a></li>
<li id="fn3">Hopcroft, Ullman (1979), Sect.6.2, Theorem 6.2, p.131<a href="#fnref3">↩</a></li>
<li id="fn4">Although every regular language is also context-free, the previous theorem is not implied by the current one, since the former yields a shaper result for regular languages.<a href="#fnref4">↩</a></li>
<li id="fn5">Strictly formally, a homomorphism yields a language consisting of just one string, i.e. <em>f</em>(<em>a</em>) = {<em>s</em>}.<a href="#fnref5">↩</a></li>
<li id="fn6">Hopcroft, Ullman (1979), Sect.3.2, p.60-61<a href="#fnref6">↩</a></li>
<li id="fn7">Hopcroft, Ullman (1979), Sect.3.2, Theorem 3.5, p.61<a href="#fnref7">↩</a></li>
<li id="fn8">This follows from the <a href="#String_substitution" title="wikilink">above-mentioned</a> closure under arbitrary substitutions.<a href="#fnref8">↩</a></li>
<li id="fn9">Hopcroft, Ullman (1979), Sect.6.2, Theorem 6.3, p.132<a href="#fnref9">↩</a></li>
</ol>
</section>
</body>
</html>
