<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1066">Probit model</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Probit model</h1>
<hr/>

<p>In <a class="uri" href="statistics" title="wikilink">statistics</a>, a <strong>probit model</strong> is a type of <a href="regression_analysis" title="wikilink">regression</a> where the <a href="dependent_variable" title="wikilink">dependent variable</a> can only take two values, for example married or not married. The name is from <em><strong>prob</strong>ability</em> + <em>un<strong>it</strong></em>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The purpose of the model is to estimate the probability that an observation with particular characteristics will fall into a specific one of the categories; moreover, if estimated probabilities greater than 1/2 are treated as classifying an observation into a predicted category, the probit model is a type of <a href="binary_classification" title="wikilink">binary classification</a> model.</p>

<p>A <a class="uri" href="probit" title="wikilink">probit</a> model is a popular specification for an ordinal<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> or a <a href="binomial_regression" title="wikilink">binary response model</a>. As such it treats the same set of problems as does <a href="logistic_regression" title="wikilink">logistic regression</a> using similar techniques. The probit model, which employs a <a class="uri" href="probit" title="wikilink">probit</a> <a href="link_function" title="wikilink">link function</a>, is most often estimated using the standard <a href="maximum_likelihood_estimation" title="wikilink">maximum likelihood</a> procedure, such an estimation being called a <strong>probit regression</strong>.</p>

<p>Probit models were introduced by <a href="Chester_Ittner_Bliss" title="wikilink">Chester Bliss</a> in 1934;<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> a fast method for computing <a href="maximum_likelihood" title="wikilink">maximum likelihood</a> estimates for them was proposed by <a href="Ronald_Fisher" title="wikilink">Ronald Fisher</a> as an appendix to Bliss' work in 1935.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="conceptual-framework">Conceptual framework</h2>

<p>Suppose response variable <em>Y</em> is <em>binary</em>, that is it can have only <a href="Limited_dependent_variable" title="wikilink">two possible outcomes</a> which we will denote as 1 and 0. For example <em>Y</em> may represent presence/absence of a certain condition, success/failure of some device, answer yes/no on a survey, etc. We also have a vector of <a href="regressor" title="wikilink">regressors</a> <em>X</em>, which are assumed to influence the outcome <em>Y</em>. Specifically, we assume that the model takes the form</p>

<p>

<math display="block" id="Probit_model:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Pr</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>Y</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mo>∣</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>X</mi>
        <mo>′</mo>
       </msup>
       <mi>β</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>Pr</ci>
     <apply>
      <eq></eq>
      <ci>Y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>X</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>β</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr(Y=1\mid X)=\Phi(X^{\prime}\beta),
  </annotation>
 </semantics>
</math>

 where Pr denotes <a class="uri" href="probability" title="wikilink">probability</a>, and Φ is the Cumulative Distribution Function (<a href="cumulative_distribution_function" title="wikilink">CDF</a>) of the standard <a href="normal_distribution" title="wikilink">normal distribution</a>. The parameters <em>β</em> are typically estimated by <a href="maximum_likelihood" title="wikilink">maximum likelihood</a>.</p>

<p>It is possible to motivate the probit model as a <a href="latent_variable_model" title="wikilink">latent variable model</a>. Suppose there exists an auxiliary random variable</p>

<p>

<math display="block" id="Probit_model:1">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>Y</mi>
     <mo>∗</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>X</mi>
       <mo>′</mo>
      </msup>
      <mi>β</mi>
     </mrow>
     <mo>+</mo>
     <mi>ε</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Y</ci>
     <ci>normal-∗</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>X</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>β</ci>
     </apply>
     <ci>ε</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y^{\ast}=X^{\prime}\beta+\varepsilon,\,
  </annotation>
 </semantics>
</math>

 where <em>ε</em> ~ <em>N</em>(0, 1). Then <em>Y</em> can be viewed as an indicator for whether this latent variable is positive:</p>

<p>

<math display="block" id="Probit_model:2">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <msup>
           <mi>Y</mi>
           <mo>∗</mo>
          </msup>
         </mrow>
         <mo>></mo>
         <mrow>
          <mrow>
           <mpadded width="+5pt">
            <mn>0</mn>
           </mpadded>
           <mtext>i.e.</mtext>
          </mrow>
          <mo>-</mo>
          <mi>ε</mi>
         </mrow>
         <mo><</mo>
         <mrow>
          <msup>
           <mi>X</mi>
           <mo>′</mo>
          </msup>
          <mi>β</mi>
         </mrow>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise.</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Y</ci>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <and></and>
      <apply>
       <gt></gt>
       <apply>
        <times></times>
        <mtext>if</mtext>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>Y</ci>
         <ci>normal-∗</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">0</cn>
         <mtext>i.e.</mtext>
        </apply>
        <ci>ε</ci>
       </apply>
      </apply>
      <apply>
       <lt></lt>
       <share href="#.cmml">
       </share>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>X</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>β</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">0</cn>
     <mtext>otherwise.</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y=\begin{cases}1&\text{if }Y^{\ast}>0\ \text{ i.e. }-\varepsilon<X^{\prime}%
\beta,\\
0&\text{otherwise.}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>The use of the standard normal distribution causes no <a href="loss_of_generality" title="wikilink">loss of generality</a> compared with using an arbitrary mean and standard deviation because adding a fixed amount to the mean can be compensated by subtracting the same amount from the intercept, and multiplying the standard deviation by a fixed amount can be compensated by multiplying the weights by the same amount.</p>

<p>To see that the two models are equivalent, note that</p>

<p>

<math display="inline" id="Probit_model:3">
 <semantics>
  <mrow>
   <mi>Pr</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>Y</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mo>∣</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>Pr</ci>
    <apply>
     <eq></eq>
     <ci>Y</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\Pr(Y=1\mid X)
  </annotation>
 </semantics>
</math>


</p>
<h2 id="model-estimation">Model estimation</h2>
<h3 id="maximum-likelihood-estimation">Maximum likelihood estimation</h3>

<p>Suppose data set 

<math display="inline" id="Probit_model:4">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{y_{i},x_{i}\}_{i=1}^{n}
  </annotation>
 </semantics>
</math>

 contains <em>n</em> independent <a href="statistical_unit" title="wikilink">statistical units</a> corresponding to the model above. Then their joint log-likelihood function is</p>

<p>

<math display="block" id="Probit_model:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ln</mi>
     <mi class="ltx_font_mathcaligraphic">ℒ</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>β</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <mrow>
     <mo maxsize="210%" minsize="210%">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mi>ln</mi>
        <mi mathvariant="normal">Φ</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msubsup>
          <mi>x</mi>
          <mi>i</mi>
          <mo>′</mo>
         </msubsup>
         <mi>β</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <msub>
          <mi>y</mi>
          <mi>i</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mpadded width="-1.7pt">
         <mi>ln</mi>
        </mpadded>
        <mrow>
         <mo maxsize="120%" minsize="120%">(</mo>
         <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mrow>
           <mi mathvariant="normal">Φ</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <msubsup>
              <mi>x</mi>
              <mi>i</mi>
              <mo>′</mo>
             </msubsup>
             <mi>β</mi>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo maxsize="120%" minsize="120%">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
     <mo maxsize="210%" minsize="210%">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ln></ln>
      <ci>ℒ</ci>
     </apply>
     <ci>β</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <ln></ln>
        <ci>normal-Φ</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
         <ci>normal-′</ci>
        </apply>
        <ci>β</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <ln></ln>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <apply>
          <times></times>
          <ci>normal-Φ</ci>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <ci>i</ci>
            </apply>
            <ci>normal-′</ci>
           </apply>
           <ci>β</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ln\mathcal{L}(\beta)=\sum_{i=1}^{n}\bigg(y_{i}\ln\Phi(x_{i}^{\prime}\beta)+(1%
-y_{i})\ln\!\big(1-\Phi(x_{i}^{\prime}\beta)\big)\bigg)
  </annotation>
 </semantics>
</math>

 The estimator 

<math display="inline" id="Probit_model:6">
 <semantics>
  <mover accent="true">
   <mi>β</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\beta}
  </annotation>
 </semantics>
</math>

 which maximizes this function will be <a href="consistent_estimator" title="wikilink">consistent</a>, asymptotically normal and <a href="Efficiency_(statistics)" title="wikilink">efficient</a> provided that E[<em>XX</em>'] exists and is not singular. It can be shown that this log-likelihood function is globally <a href="concave_function" title="wikilink">concave</a> in <em>β</em>, and therefore standard numerical algorithms for optimization will converge rapidly to the unique maximum.</p>

<p>Asymptotic distribution for 

<math display="inline" id="Probit_model:7">
 <semantics>
  <mover accent="true">
   <mi>β</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\beta}
  </annotation>
 </semantics>
</math>

 is given by</p>

<p>

<math display="block" id="Probit_model:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msqrt>
      <mi>n</mi>
     </msqrt>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mover accent="true">
        <mi>β</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mo>-</mo>
       <mi>β</mi>
      </mrow>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mpadded width="+5pt">
     <mover accent="true">
      <mo>→</mo>
      <mo>𝑑</mo>
     </mover>
    </mpadded>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">𝒩</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo rspace="4.2pt">,</mo>
      <msup>
       <mi mathvariant="normal">Ω</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <ci>d</ci>
     <ci>normal-→</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <root></root>
      <ci>n</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <ci>normal-^</ci>
       <ci>β</ci>
      </apply>
      <ci>β</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>𝒩</ci>
     <interval closure="open">
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Ω</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{n}(\hat{\beta}-\beta)\ \xrightarrow{d}\ \mathcal{N}(0,\,\Omega^{-1}),
  </annotation>
 </semantics>
</math>

 where</p>

<p>

<math display="block" id="Probit_model:9">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Ω</mi>
    <mo>=</mo>
    <mrow>
     <mo>E</mo>
     <mrow>
      <mo maxsize="210%" minsize="210%">[</mo>
      <mrow>
       <mfrac>
        <mrow>
         <msup>
          <mi>φ</mi>
          <mn>2</mn>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msup>
            <mi>X</mi>
            <mo>′</mo>
           </msup>
           <mi>β</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mi mathvariant="normal">Φ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msup>
            <mi>X</mi>
            <mo>′</mo>
           </msup>
           <mi>β</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mn>1</mn>
           <mo>-</mo>
           <mrow>
            <mi mathvariant="normal">Φ</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <msup>
               <mi>X</mi>
               <mo>′</mo>
              </msup>
              <mi>β</mi>
             </mrow>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mfrac>
       <mi>X</mi>
       <msup>
        <mi>X</mi>
        <mo>′</mo>
       </msup>
      </mrow>
      <mo maxsize="210%" minsize="210%">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mover accent="true">
     <mi mathvariant="normal">Ω</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>n</mi>
     </mfrac>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <mfrac>
        <mrow>
         <msup>
          <mi>φ</mi>
          <mn>2</mn>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msubsup>
            <mi>x</mi>
            <mi>i</mi>
            <mo>′</mo>
           </msubsup>
           <mover accent="true">
            <mi>β</mi>
            <mo stretchy="false">^</mo>
           </mover>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mi mathvariant="normal">Φ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msubsup>
            <mi>x</mi>
            <mi>i</mi>
            <mo>′</mo>
           </msubsup>
           <mover accent="true">
            <mi>β</mi>
            <mo stretchy="false">^</mo>
           </mover>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mn>1</mn>
           <mo>-</mo>
           <mrow>
            <mi mathvariant="normal">Φ</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <msubsup>
               <mi>x</mi>
               <mi>i</mi>
               <mo>′</mo>
              </msubsup>
              <mover accent="true">
               <mi>β</mi>
               <mo stretchy="false">^</mo>
              </mover>
             </mrow>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mfrac>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <msubsup>
        <mi>x</mi>
        <mi>i</mi>
        <mo>′</mo>
       </msubsup>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>normal-Ω</ci>
     <apply>
      <ci>normal-E</ci>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>φ</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>X</ci>
           <ci>normal-′</ci>
          </apply>
          <ci>β</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>normal-Φ</ci>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>X</ci>
           <ci>normal-′</ci>
          </apply>
          <ci>β</ci>
         </apply>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
          <apply>
           <times></times>
           <ci>normal-Φ</ci>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>X</ci>
             <ci>normal-′</ci>
            </apply>
            <ci>β</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>X</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-^</ci>
      <ci>normal-Ω</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>n</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>φ</ci>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>x</ci>
             <ci>normal-′</ci>
            </apply>
            <ci>i</ci>
           </apply>
           <apply>
            <ci>normal-^</ci>
            <ci>β</ci>
           </apply>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>normal-Φ</ci>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>x</ci>
             <ci>normal-′</ci>
            </apply>
            <ci>i</ci>
           </apply>
           <apply>
            <ci>normal-^</ci>
            <ci>β</ci>
           </apply>
          </apply>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
           <apply>
            <times></times>
            <ci>normal-Φ</ci>
            <apply>
             <times></times>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <apply>
               <csymbol cd="ambiguous">superscript</csymbol>
               <ci>x</ci>
               <ci>normal-′</ci>
              </apply>
              <ci>i</ci>
             </apply>
             <apply>
              <ci>normal-^</ci>
              <ci>β</ci>
             </apply>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <ci>normal-′</ci>
         </apply>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega=\operatorname{E}\bigg[\frac{\varphi^{2}(X^{\prime}\beta)}{\Phi(X^{%
\prime}\beta)(1-\Phi(X^{\prime}\beta))}XX^{\prime}\bigg],\qquad\hat{\Omega}=%
\frac{1}{n}\sum_{i=1}^{n}\frac{\varphi^{2}(x^{\prime}_{i}\hat{\beta})}{\Phi(x^%
{\prime}_{i}\hat{\beta})(1-\Phi(x^{\prime}_{i}\hat{\beta}))}x_{i}x^{\prime}_{i}
  </annotation>
 </semantics>
</math>

 and <em>φ = Φ</em>' is the Probability Density Function (<a href="probability_density_function" title="wikilink">PDF</a>) of standard normal distribution.</p>
<h3 id="berksons-minimum-chi-square-method">Berkson's minimum chi-square method</h3>

<p>This method can be applied only when there are many observations of response variable 

<math display="inline" id="Probit_model:10">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}
  </annotation>
 </semantics>
</math>

 having the same value of the vector of regressors 

<math display="inline" id="Probit_model:11">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 (such situation may be referred to as "many observations per cell"). More specifically, the model can be formulated as follows.</p>

<p>Suppose among <em>n</em> observations 

<math display="inline" id="Probit_model:12">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{y_{i},x_{i}\}_{i=1}^{n}
  </annotation>
 </semantics>
</math>

 there are only <em>T</em> distinct values of the regressors, which can be denoted as 

<math display="inline" id="Probit_model:13">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>T</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x_{(1)},\ldots,x_{(T)}\}
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Probit_model:14">
 <semantics>
  <msub>
   <mi>n</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{t}
  </annotation>
 </semantics>
</math>

 be the number of observations with 

<math display="inline" id="Probit_model:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}=x_{(t)},
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Probit_model:16">
 <semantics>
  <msub>
   <mi>r</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{t}
  </annotation>
 </semantics>
</math>

 the number of such observations with 

<math display="inline" id="Probit_model:17">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}=1
  </annotation>
 </semantics>
</math>

. We assume that there are indeed "many" observations per each "cell": for each 

<math display="inline" id="Probit_model:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mo>,</mo>
    <mrow>
     <msub>
      <mo>lim</mo>
      <mrow>
       <mi>n</mi>
       <mo>→</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
     </msub>
     <mrow>
      <msub>
       <mi>n</mi>
       <mi>t</mi>
      </msub>
      <mo>/</mo>
      <mi>n</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>c</mi>
    <mi>t</mi>
   </msub>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <list>
      <ci>t</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <limit></limit>
        <apply>
         <ci>normal-→</ci>
         <ci>n</ci>
         <infinity></infinity>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>n</ci>
         <ci>t</ci>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
     </list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t,\lim_{n\rightarrow\infty}n_{t}/n=c_{t}>0
  </annotation>
 </semantics>
</math>

.</p>

<p>Denote</p>

<p>

<math display="block" id="Probit_model:19">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>p</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>r</mi>
     <mi>t</mi>
    </msub>
    <mo>/</mo>
    <msub>
     <mi>n</mi>
     <mi>t</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>p</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{p}_{t}=r_{t}/n_{t}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Probit_model:20">
 <semantics>
  <mrow>
   <msubsup>
    <mover accent="true">
     <mi>σ</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>t</mi>
    <mn>2</mn>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msub>
      <mi>n</mi>
      <mi>t</mi>
     </msub>
    </mfrac>
    <mfrac>
     <mrow>
      <msub>
       <mover accent="true">
        <mi>p</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mi>t</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <msub>
         <mover accent="true">
          <mi>p</mi>
          <mo stretchy="false">^</mo>
         </mover>
         <mi>t</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <msup>
       <mi>φ</mi>
       <mn>2</mn>
      </msup>
      <mrow>
       <mo maxsize="120%" minsize="120%">(</mo>
       <mrow>
        <msup>
         <mi mathvariant="normal">Φ</mi>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mover accent="true">
           <mi>p</mi>
           <mo stretchy="false">^</mo>
          </mover>
          <mi>t</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo maxsize="120%" minsize="120%">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>σ</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>p</ci>
        </apply>
        <ci>t</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-^</ci>
          <ci>p</ci>
         </apply>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>φ</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-Φ</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-^</ci>
          <ci>p</ci>
         </apply>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\sigma}_{t}^{2}=\frac{1}{n_{t}}\frac{\hat{p}_{t}(1-\hat{p}_{t})}{\varphi^%
{2}\big(\Phi^{-1}(\hat{p}_{t})\big)}
  </annotation>
 </semantics>
</math>

</p>

<p>Then <strong>Berkson's minimum chi-square</strong> estimator is a <a href="generalized_least_squares" title="wikilink">generalized least squares</a> estimator in a regression of 

<math display="inline" id="Probit_model:21">
 <semantics>
  <mrow>
   <msup>
    <mi mathvariant="normal">Φ</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mover accent="true">
      <mi>p</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>t</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Φ</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>p</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi^{-1}(\hat{p}_{t})
  </annotation>
 </semantics>
</math>

 on 

<math display="inline" id="Probit_model:22">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{(t)}
  </annotation>
 </semantics>
</math>

 with weights 

<math display="inline" id="Probit_model:23">
 <semantics>
  <msubsup>
   <mover accent="true">
    <mi>σ</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>t</mi>
   <mrow>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>σ</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\sigma}_{t}^{-2}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Probit_model:24">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>β</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo maxsize="260%" minsize="260%">(</mo>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>t</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>T</mi>
       </munderover>
       <mrow>
        <msubsup>
         <mover accent="true">
          <mi>σ</mi>
          <mo stretchy="false">^</mo>
         </mover>
         <mi>t</mi>
         <mrow>
          <mo>-</mo>
          <mn>2</mn>
         </mrow>
        </msubsup>
        <msub>
         <mi>x</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </msub>
        <msubsup>
         <mi>x</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>′</mo>
        </msubsup>
       </mrow>
      </mrow>
      <mo maxsize="260%" minsize="260%">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>t</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>T</mi>
     </munderover>
     <mrow>
      <msubsup>
       <mover accent="true">
        <mi>σ</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mi>t</mi>
       <mrow>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
      </msubsup>
      <msub>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msub>
      <msup>
       <mi mathvariant="normal">Φ</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mover accent="true">
         <mi>p</mi>
         <mo stretchy="false">^</mo>
        </mover>
        <mi>t</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-^</ci>
     <ci>β</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>T</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <ci>normal-^</ci>
           <ci>σ</ci>
          </apply>
          <ci>t</ci>
         </apply>
         <apply>
          <minus></minus>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <ci>normal-′</ci>
         </apply>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-^</ci>
          <ci>σ</ci>
         </apply>
         <ci>t</ci>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-Φ</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>p</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\beta}=\Bigg(\sum_{t=1}^{T}\hat{\sigma}_{t}^{-2}x_{(t)}x^{\prime}_{(t)}%
\Bigg)^{-1}\sum_{t=1}^{T}\hat{\sigma}_{t}^{-2}x_{(t)}\Phi^{-1}(\hat{p}_{t})
  </annotation>
 </semantics>
</math>

</p>

<p>It can be shown that this estimator is consistent (as <em>n</em>→∞ and <em>T</em> fixed), asymptotically normal and efficient. Its advantage is the presence of a closed-form formula for the estimator. However, it is only meaningful to carry out this analysis when individual observations are not available, only their aggregated counts 

<math display="inline" id="Probit_model:25">
 <semantics>
  <msub>
   <mi>r</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{t}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Probit_model:26">
 <semantics>
  <msub>
   <mi>n</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{t}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Probit_model:27">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{(t)}
  </annotation>
 </semantics>
</math>

 (for example in the analysis of voting behavior).</p>
<h3 id="gibbs-sampling">Gibbs sampling</h3>

<p><a href="Gibbs_sampling" title="wikilink">Gibbs sampling</a> of a probit model is possible because regression models typically use normal <a href="prior_distribution" title="wikilink">prior distributions</a> over the weights, and this distribution is conjugate with the normal distribution of the errors (and hence of the latent variables<em>Y</em><sup>*</sup>). The model can be described as</p>

<p>

<math display="inline" id="Probit_model:28">
 <semantics>
  <mi>𝜷</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝜷</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\boldsymbol{\beta}
  </annotation>
 </semantics>
</math>


</p>

<p>From this, we can determine the full conditional densities needed:</p>

<p>

<math display="inline" id="Probit_model:29">
 <semantics>
  <mi>𝐁</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐁</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\mathbf{B}
  </annotation>
 </semantics>
</math>


</p>

<p>The result for <strong>β</strong> is given in the article on <a href="Bayesian_linear_regression" title="wikilink">Bayesian linear regression</a>, although specified with different notation.</p>

<p>The only trickiness is in the last two equations. The notation 

<math display="inline" id="Probit_model:30">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <msubsup>
     <mi>y</mi>
     <mi>i</mi>
     <mo>∗</mo>
    </msubsup>
    <mo><</mo>
    <mn>0</mn>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <apply>
     <lt></lt>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-∗</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [y_{i}^{\ast}<0]
  </annotation>
 </semantics>
</math>

 is the <a href="Iverson_bracket" title="wikilink">Iverson bracket</a>, sometimes written 

<math display="inline" id="Probit_model:31">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℐ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>y</mi>
     <mi>i</mi>
     <mo>∗</mo>
    </msubsup>
    <mo><</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">I</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-∗</ci>
     </apply>
     <lt></lt>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{I}(y_{i}^{\ast}<0)
  </annotation>
 </semantics>
</math>

 or similar. It indicates that the distribution must be <a href="truncated_distribution" title="wikilink">truncated</a> within the given range, and rescaled appropriately. In this particular case, a <a href="truncated_normal_distribution" title="wikilink">truncated normal distribution</a> arises. Sampling from this distribution depends on how much is truncated. If a large fraction of the original mass remains, sampling can be easily done with <a href="rejection_sampling" title="wikilink">rejection sampling</a> — simply sample a number from the non-truncated distribution, and reject it if it falls outside the restriction imposed by the truncation. If sampling from only a small fraction of the original mass, however (e.g. if sampling from one of the tails of the normal distribution — for example if 

<math display="inline" id="Probit_model:32">
 <semantics>
  <mrow>
   <msubsup>
    <mi>𝐱</mi>
    <mi>i</mi>
    <mo>′</mo>
   </msubsup>
   <mi>𝜷</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐱</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <ci>𝜷</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}^{\prime}_{i}\boldsymbol{\beta}
  </annotation>
 </semantics>
</math>

 is around 3 or more, and a negative sample is desired), then this will be inefficient and it becomes necessary to fall back on other sampling algorithms. General sampling from the truncated normal can be achieved using approximations to the normal <a href="cumulative_distribution_function" title="wikilink">CDF</a> and the <a href="probit_function" title="wikilink">probit function</a>, and <a href="R_(programming_language)" title="wikilink">R</a> has a function <code>rtnorm()</code> for generating truncated-normal samples.</p>
<h2 id="model-evaluation">Model evaluation</h2>

<p>The suitability of an estimated binary model can be evaluated by counting the number of true observations equaling 1, and the number equaling zero, for which the model assigns a correct predicted classification by treating any estimated probability above 1/2 (or, below 1/2), as an assignment of a prediction of 1 (or, of 0). See <a href="Logistic_regression#Model_suitability" title="wikilink">here</a> for details.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Generalized_linear_model" title="wikilink">Generalized linear model</a></li>
<li><a href="Limited_dependent_variable" title="wikilink">Limited dependent variable</a></li>
<li><a href="Multivariate_probit" title="wikilink">Multivariate probit</a> models</li>
<li><a href="Ordered_probit" title="wikilink">Ordered probit</a> and <a href="Ordered_logit" title="wikilink">Ordered logit</a> model</li>
<li><a href="Separation_(statistics)" title="wikilink">Separation (statistics)</a></li>
<li><a href="Multinomial_probit" title="wikilink">Multinomial probit</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>

<p>by <a href="Mark_Thoma" title="wikilink">Mark Thoma</a></p></li>
</ul>

<p>"</p>

<p><a href="Category:Regression_analysis" title="wikilink">Category:Regression analysis</a> <a href="Category:Classification_algorithms" title="wikilink">Category:Classification algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><em>Oxford English Dictionary</em>, 3rd ed. s.v. <em>probit</em> (article dated June 2007): <a href="#fnref1">↩</a></li>
<li id="fn2">Ordinal probit regression model UCLA Academic Technology Services <a class="uri" href="http://www.ats.ucla.edu/stat/stata/dae/ologit.htm">http://www.ats.ucla.edu/stat/stata/dae/ologit.htm</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
