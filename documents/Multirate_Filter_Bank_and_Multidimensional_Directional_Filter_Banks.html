<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1430">Multirate Filter Bank and Multidimensional Directional Filter Banks</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Multirate Filter Bank and Multidimensional Directional Filter Banks</h1>
<hr/>

<p>Signal Processing is one of the important research fields that is used widely these days in different aspects of our lives. It is a wide area of research that extends from the simplest form of one-dimensional (1-D) signal processing (e.g., 1-D filters) to the complex form of multi-dimensional (M-D) (e.g. M-D filters). In signal processing, a filter is used to remove or modify some components or features of a signal. A filter bank is an array of filters that separates the input signal into multiple components, each one carrying a single frequency sub-band of the original signal. Filter banks have a lot of applications these days. In filter banks the process of decomposition performed by the filter bank is called analysis and the reconstruction process is called synthesis. This article provides a short survey of the concepts, principles and applications of <a href="Multidimensional_Multirate_Systems" title="wikilink">Multirate Filter Banks</a> and Multidimensional Directional Filter Banks.</p>
<h2 id="multirate-systems">Multirate systems</h2>

<p>Linear time-invariant systems typically operate at a single sampling rate, which means that we have the same sampling rate at input and output. In other words, in an <a href="LTI_system" title="wikilink">LTI system</a>, the sampling rate would not change in the system.</p>

<p>Systems that use different sampling rates at different stages are called multirate systems. The multirate system can have different sampling rates based on desire. Also multirate systems can provide different sampling rates without destroy the signal components. In Figure 1, you can see a block diagram of a two channel multirate system.</p>
<h2 id="multirate-filter-bank">Multirate Filter Bank</h2>

<p>Multirate <a href="filter_bank" title="wikilink">filter bank</a> divides a signal into a number of subbands, which can be analysed at different rates corresponding to the bandwidth of the frequency bands.<br/>
One important fact in multirate filtering is that the signal should be filtered before decimation, otherwise aliasing and frequency folding would occur. </p>
<h2 id="multirate-filter-designs">Multirate Filter Designs</h2>

<p>Multirate filter design makes use of properties of decimation and interpolation (or expansion) in the design implementation of the filter. Decimation or downsampling by a factor of 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:0">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 essentially means keeping every 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:1">
 <semantics>
  <msup>
   <mi>M</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>M</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M^{th}
  </annotation>
 </semantics>
</math>

 sample of a given sequence.</p>
<h3 id="decimation-interpolation-and-modulation">Decimation, Interpolation, and Modulation</h3>

<p>Generally speaking, using decimation is very common in multirate filter designs. In the second step, after using decimation, interpolation will be used to restore the sampling rate. The advantage of using decimators and interpolator is that they can reduce the computations when resulting in a lower sampling rate.</p>

<p>Decimation by a factor of 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:2">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 can be mathematically defined as:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:3">
 <semantics>
  <mrow>
   <mi>x</mi>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi></mi>
     <mo>↓</mo>
     <mi>M</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo>.</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <ci>normal-↓</ci>
      <csymbol cd="latexml">absent</csymbol>
      <ci>M</ci>
     </apply>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x(n)}_{\downarrow{}M}=x(M.n)
  </annotation>
 </semantics>
</math>

 or equivalently, 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>↓</mo>
      <mi>M</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>M</mi>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>m</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>M</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>z</mi>
        <mfrac>
         <mn>1</mn>
         <mi>M</mi>
        </mfrac>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>X</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <apply>
       <ci>normal-↓</ci>
       <csymbol cd="latexml">absent</csymbol>
       <ci>M</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>M</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>m</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>M</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <ci>M</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(z)_{\downarrow M}=\frac{1}{M}\sum_{m=0}^{M-1}X(z^{\frac{1}{M}})
  </annotation>
 </semantics>
</math>

.</p>

<p>Expansion or upsampling by a factor of M means that we insert M-1 zeros between each sample of a given signal or a sequence. The expansion by a factor of M can be mathematically explained as: 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>↑</mo>
      <mi>M</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="left">
       <mtable>
        <mtr>
         <mtd columnalign="center">
          <mrow>
           <mi>x</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mfrac>
             <mi>n</mi>
             <mi>M</mi>
            </mfrac>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mi></mi>
         </mtd>
        </mtr>
       </mtable>
      </mtd>
      <mtd columnalign="left">
       <mtable>
        <mtr>
         <mtd columnalign="center">
          <mfrac>
           <mi>n</mi>
           <mi>M</mi>
          </mfrac>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mrow>
           <mi>o</mi>
           <mi>t</mi>
           <mi>h</mi>
           <mi>e</mi>
           <mi>r</mi>
           <mi>w</mi>
           <mi>i</mi>
           <mi>s</mi>
           <mi>e</mi>
          </mrow>
         </mtd>
        </mtr>
       </mtable>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <apply>
       <ci>normal-↑</ci>
       <csymbol cd="latexml">absent</csymbol>
       <ci>M</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <matrix>
      <matrixrow>
       <apply>
        <times></times>
        <ci>x</ci>
        <apply>
         <divide></divide>
         <ci>n</ci>
         <ci>M</ci>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <csymbol cd="latexml">absent</csymbol>
      </matrixrow>
     </matrix>
     <matrix>
      <matrixrow>
       <apply>
        <divide></divide>
        <ci>n</ci>
        <ci>M</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <ci>o</ci>
        <ci>t</ci>
        <ci>h</ci>
        <ci>e</ci>
        <ci>r</ci>
        <ci>w</ci>
        <ci>i</ci>
        <ci>s</ci>
        <ci>e</ci>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(n)_{\uparrow M}=\begin{cases}\begin{array}[]{c}x(\frac{n}{M})\\
\par
\end{array}&\begin{array}[]{c}\frac{n}{M}\\
otherwise\end{array}\end{cases}
  </annotation>
 </semantics>
</math>

<br/>
 or equivalently, 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>↑</mo>
      <mi>M</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>X</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>z</mi>
      <mi>M</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>X</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <apply>
       <ci>normal-↑</ci>
       <csymbol cd="latexml">absent</csymbol>
       <ci>M</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>X</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {X(z)}_{\uparrow{}M}=X(z^{M})
  </annotation>
 </semantics>
</math>

.</p>

<p>Modulation is needed for different kinds of filter designs. For instance, in many communication applications we need to modulate the signal to baseband. After using lowpass filtering for the baseband signal, we use modulation and change the baseband signal to the center frequency of the bandpass filter. Here we provide two examples of designing multirate narrow lowpass and narrow bandpass filters.</p>
<h3 id="narrow-lowpass-filter">Narrow lowpass filter</h3>

<p>We can define a narrow lowpass filter as a <a href="lowpass_filter" title="wikilink">lowpass filter</a> with a narrow passband. In order to create a multirate narrow lowpass FIR filter, we need to replace the time invariant FIR filter with a lowpass antialiasing filter and use a decimator along with an interpolator and lowpass anti-imaging filter.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> In this the resulting way multirate system would be a time varying linear phase filter via the decimator and interpolator. This process explained in block diagram form where Figure 2 (a) is replaced by Figure 2(b). </p>

<p>The lowpass filter consists of two polyphase filters, one for the decimator and one for the interpolator.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="multirate-filter-bank-1">Multirate Filter Bank</h2>

<p><a href="Filter_bank" title="wikilink">Filter banks</a> has different usage in many areas, such as signal and image compression, and processing. The main usage of using <a href="filter_banks" title="wikilink">filter banks</a> is that in this way we can divide the signal or system to several separate frequency domains.</p>

<p>A <a href="filter_bank" title="wikilink">filter bank</a> divides the input signal 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:7">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo>(</mo>
    <mi>n</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\left(n\right)
  </annotation>
 </semantics>
</math>

 into a set of signals 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>3</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}(n),x_{2}(n),x_{3}(n),...
  </annotation>
 </semantics>
</math>

. In this way each of the generated signals corresponds to a different region in the spectrum of 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:9">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo>(</mo>
    <mi>n</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\left(n\right)
  </annotation>
 </semantics>
</math>

. In this process it can be possible for the regions overlap (or not, based on application). Figure 4 shows an example of a three-band filter bank. The generated signals 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:10">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>3</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}(n),x_{2}(n),x_{3}(n),...
  </annotation>
 </semantics>
</math>

 can be generated via a collection of set of bandpass filters with bandwidths 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>B</mi>
    <msub>
     <mi>W</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>B</mi>
    <msub>
     <mi>W</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>B</mi>
    <msub>
     <mi>W</mi>
     <mn>3</mn>
    </msub>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>B</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>B</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>B</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   BW_{1},BW_{2},BW_{3},...
  </annotation>
 </semantics>
</math>

 and center frequencies 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:12">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mrow>
     <mi>c</mi>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>f</mi>
    <mrow>
     <mi>c</mi>
     <mn>2</mn>
    </mrow>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>f</mi>
    <mrow>
     <mi>c</mi>
     <mn>3</mn>
    </mrow>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>c</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>c</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{c1},f_{c2},f_{c3},...
  </annotation>
 </semantics>
</math>

(respectively). </p>

<p>A multirate filter bank use a single input signal and then produces multiple outputs of the signal by filtering and subsampling. In order to split the input signal into two or more signals (see Figure 5) an analysis-synthesis system can be used . In figure 5, only 4 sub-signals are used.</p>

<p>The signal would split with the help of four filters 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:13">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>k</ci>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{k}(z)
  </annotation>
 </semantics>
</math>

 for k =0,1,2,3 into 4 bands of the same bandwidths (In the analysis bank) and then each sub-signal is decimated by a factor of 4. In each band by dividing the signal in each band, we would have different signal characteristics.</p>
<figure><b>(Figure)</b>
<figcaption>Analysis/Synthesis Filter Bank</figcaption>
</figure>

<p>In synthesis section the filter will reconstruct the original signal: First, upsampling the 4 sub-signals at the output of the processing unit by a factor of 4 and then filtere by 4 synthesis filters 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:14">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>k</ci>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{k}(z)
  </annotation>
 </semantics>
</math>

 for k = 0,1,2,3. Finally, the outputs of these four filters are added.</p>
<h2 id="multidimensional-filter-banks">Multidimensional Filter Banks</h2>

<p><a href="Multidimensional_Filter_Design" title="wikilink">Multidimensional Filtering</a>, <a class="uri" href="downsampling" title="wikilink">downsampling</a>, and <a class="uri" href="upsampling" title="wikilink">upsampling</a> are the main parts of <a href="multirate_systems" title="wikilink">multirate systems</a> and <a href="filter_bank" title="wikilink">filter banks</a>.</p>

<p>A complete filter bank consist of the analysis and synthesis side<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>The analysis filter bank divides an input signal to different subbands with different frequency spectrums. The synthesis part reassembles the different subband signals and generates a reconstruction signal. For example, in Figure 6, the input divides into four directional sub bands that each of them covers one of the wedge-shaped frequency regions. The synthesis part is dual to the analysis part. </p>

<p>It is important to analyze filter banks from a frequency domain perspective in terms of subband decomposition and reconstruction. However, equally important is <a href="Hilbert_Spaces_and_Fourier_analysis" title="wikilink">hilbert space</a> interpretation of filter banks, which plays a key role in geometrical signal representations. For generic K-channel filter bank, with analysis filters 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:15">
 <semantics>
  <msubsup>
   <mrow>
    <mo>{</mo>
    <mrow>
     <msub>
      <mi>h</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>K</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>n</ci>
       </apply>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{h_{k}[n]\right\}_{k=1}^{K}
  </annotation>
 </semantics>
</math>

, synthesis filters 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:16">
 <semantics>
  <msubsup>
   <mrow>
    <mo>{</mo>
    <mrow>
     <msub>
      <mi>g</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>K</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>n</ci>
       </apply>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{g_{k}[n]\right\}_{k=1}^{K}
  </annotation>
 </semantics>
</math>

, and sampling matrices 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:17">
 <semantics>
  <msubsup>
   <mrow>
    <mo>{</mo>
    <mrow>
     <msub>
      <mi>M</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>K</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>n</ci>
       </apply>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{M_{k}[n]\right\}_{k=1}^{K}
  </annotation>
 </semantics>
</math>

. In the analysis side, we can define vectors in <em>

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:18">
 <semantics>
  <mrow>
   <msup>
    <mi>l</mi>
    <mn>2</mn>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>Z</mi>
     <mi>d</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>l</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Z</ci>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l^{2}(Z^{d})
  </annotation>
 </semantics>
</math>

</em> as<br/>


<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:19">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>φ</mi>
     <mrow>
      <mi>k</mi>
      <mo>,</mo>
      <mi>m</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mover>
    <mo movablelimits="false">=</mo>
    <mrow>
     <mi>d</mi>
     <mi>e</mi>
     <mi>f</mi>
    </mrow>
   </mover>
   <mrow>
    <msubsup>
     <mi>h</mi>
     <mi>k</mi>
     <mo>*</mo>
    </msubsup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>M</mi>
        <mi>k</mi>
       </msub>
       <mi>m</mi>
      </mrow>
      <mo>-</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>φ</ci>
      <list>
       <ci>k</ci>
       <ci>m</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>k</ci>
      </apply>
      <times></times>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>M</ci>
         <ci>k</ci>
        </apply>
        <ci>m</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{k,m}[n]\stackrel{def}{=}h_{k}^{*}[M_{k}m-n]
  </annotation>
 </semantics>
</math>

, each index by two parameters

<math display="block" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:20">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>k</mi>
   <mo>≤</mo>
   <mi>K</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>k</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq k\leq K
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:21">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>∈</mo>
   <msup>
    <mi>Z</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>m</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Z</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\in Z^{2}
  </annotation>
 </semantics>
</math>

.<br/>
Similarly, for the synthesis filters 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:22">
 <semantics>
  <mrow>
   <msub>
    <mi>g</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{k}[n]
  </annotation>
 </semantics>
</math>

 we can define 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:23">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ψ</mi>
     <mrow>
      <mi>k</mi>
      <mo>,</mo>
      <mi>m</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mover>
    <mo movablelimits="false">=</mo>
    <mrow>
     <mi>d</mi>
     <mi>e</mi>
     <mi>f</mi>
    </mrow>
   </mover>
   <mrow>
    <msubsup>
     <mi>h</mi>
     <mi>k</mi>
     <mo>*</mo>
    </msubsup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>M</mi>
        <mi>k</mi>
       </msub>
       <mi>m</mi>
      </mrow>
      <mo>-</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ψ</ci>
      <list>
       <ci>k</ci>
       <ci>m</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>k</ci>
      </apply>
      <times></times>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>M</ci>
         <ci>k</ci>
        </apply>
        <ci>m</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi_{k,m}[n]\stackrel{def}{=}h_{k}^{*}[M_{k}m-n]
  </annotation>
 </semantics>
</math>

.</p>

<p>Considering the definition of analysis/synthesis sides we can verify that <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:24">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mrow>
       <mn>1</mn>
       <mo>≤</mo>
       <mi>k</mi>
       <mo>≤</mo>
       <mi>K</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>m</mi>
       <mo>∈</mo>
       <msup>
        <mi>Z</mi>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
    </msub>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>m</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <msub>
      <mi>ψ</mi>
      <mrow>
       <mi>k</mi>
       <mo>,</mo>
       <mi>m</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <and></and>
        <apply>
         <leq></leq>
         <cn type="integer">1</cn>
         <ci>k</ci>
        </apply>
        <apply>
         <leq></leq>
         <share href="#.cmml">
         </share>
         <ci>K</ci>
        </apply>
       </apply>
       <apply>
        <in></in>
        <ci>m</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>Z</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ψ</ci>
       <list>
        <ci>k</ci>
        <ci>m</ci>
       </list>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{x}[n]=\sum_{1\leq k\leq K,m\in Z^{2}}c_{k}[m]\psi_{k,m}[n]
  </annotation>
 </semantics>
</math>

<br/>
and for reconstruction part 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:25">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mover accent="true">
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">^</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-^</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[n]=\hat{x[n]}
  </annotation>
 </semantics>
</math>

.<br/>
In other words, the analysis filter bank calculate the inner product of the input signal and the vector from analysis set. Moreover, the reconstructed signal in the combination of the vectors from the synthesis set, and the combination coefficients of the computed inner products, meaning that 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:26">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[n]
  </annotation>
 </semantics>
</math>

</p>

<p>If there is no loss in the decomposition and the subsequent reconstruction, the filter bank is called <em>perfect reconstruction</em>. (in that case we would have 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:27">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>j</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{j}[n],
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>Figure 7 shows a general multidimensional filter bank with N channels and a common sampling matrix M. The analysis part transforms the input signal 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:28">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>j</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j=0,1,...,N-1
  </annotation>
 </semantics>
</math>

 into N filtered and downsampled outputs 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:29">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>j</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{j}[n]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:30">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(z)
  </annotation>
 </semantics>
</math>

. The synthesis part recovers the original signal from 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:31">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(z)
  </annotation>
 </semantics>
</math>

 by upsampling and filtering. This kind of set up is used in many applications such as <a href="subband_coding" title="wikilink">subband coding</a>, multichannel acquisition, and <a href="wavelet_transforms" title="wikilink">discrete wavelet transforms</a>.</p>
<h2 id="multidimensional-filter-banks-design">Multidimensional Filter Banks Design</h2>
<h3 id="multidimensional-filter-banks-using-grobner-bases">Multidimensional Filter Banks Using Grobner Bases</h3>

<p>The general multidimensional filter bank (Figure 7) can be represented by a pair of analysis and synthesis polyphase matrices 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:32">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>×</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\times M
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:33">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>×</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\times N
  </annotation>
 </semantics>
</math>

 of size 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:34">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mover>
    <mo movablelimits="false">=</mo>
    <mrow>
     <mi>d</mi>
     <mi>e</mi>
     <mi>f</mi>
    </mrow>
   </mover>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>M</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <ci>M</ci>
    <apply>
     <abs></abs>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\stackrel{def}{=}|M|
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:35">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(z)
  </annotation>
 </semantics>
</math>

, where N is the number of channels and 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:36">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(z)
  </annotation>
 </semantics>
</math>

 is the absolute value of the determinant of the sampling matrix. Also 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>∈</mo>
      <msup>
       <mi>Z</mi>
       <mi>d</mi>
      </msup>
     </mrow>
    </msub>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>k</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <msup>
      <mi>z</mi>
      <mi>k</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>∈</mo>
      <msup>
       <mi>Z</mi>
       <mi>d</mi>
      </msup>
     </mrow>
    </msub>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>k</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>k</mi>
       <mi>d</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
     <msubsup>
      <mi>z</mi>
      <mn>1</mn>
      <msub>
       <mi>k</mi>
       <mn>1</mn>
      </msub>
     </msubsup>
     <mi mathvariant="normal">…</mi>
     <msubsup>
      <mi>z</mi>
      <mi>d</mi>
      <msub>
       <mi>k</mi>
       <mi>d</mi>
      </msub>
     </msubsup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>k</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>Z</ci>
         <ci>d</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>k</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>Z</ci>
         <ci>d</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>k</ci>
         <ci>d</ci>
        </apply>
       </list>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <ci>d</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>k</ci>
         <ci>d</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(z)=\sum_{k\in Z^{d}}f[k]z^{k}=\sum_{k\in Z^{d}}f[k_{1},...,k_{d}]z_{1}^{k_{1%
}}...z_{d}^{k_{d}}
  </annotation>
 </semantics>
</math>

 and 

<math display="block" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>I</mi>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>M</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>z</ci>
     <ci>H</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <apply>
      <abs></abs>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(z)H(z)=I_{|M|}
  </annotation>
 </semantics>
</math>

 are the z-transform of the polyphase components of the analysis and synthesis filters. Therefore, they are <em>multivariate Laurent polynomials</em>, which have the general form:<br/>


<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:39">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>I</mi>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>M</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>z</ci>
     <ci>H</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <apply>
      <abs></abs>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(z)H(z)=I_{|M|}
  </annotation>
 </semantics>
</math>

. Laurent polynomial matrix equation need to be solve to design perfect reconstruction filter banks

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:40">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mi>o</mi>
    <mi>d</mi>
    <mi>u</mi>
    <mi>l</mi>
    <mi>e</mi>
    <mrow>
     <mo>{</mo>
     <mrow>
      <msub>
       <mi>h</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>h</mi>
       <mi>N</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
   <mover>
    <mo movablelimits="false">=</mo>
    <mrow>
     <mi>d</mi>
     <mi>e</mi>
     <mi>f</mi>
    </mrow>
   </mover>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>c</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>h</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">…</mi>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>c</mi>
       <mi>N</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>h</mi>
       <mi>N</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>M</ci>
     <ci>o</ci>
     <ci>d</ci>
     <ci>u</ci>
     <ci>l</ci>
     <ci>e</ci>
     <set>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>z</ci>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>N</ci>
       </apply>
       <ci>z</ci>
      </apply>
     </set>
    </apply>
    <set>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>z</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>z</ci>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>N</ci>
       </apply>
       <ci>z</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>N</ci>
       </apply>
       <ci>z</ci>
      </apply>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Module\left\{h_{1}(z),...,h_{N}(z)\right\}\stackrel{def}{=}\{c_{1}(z)h_{1}(z)+%
...+c_{N}(z)h_{N}(z)\}
  </annotation>
 </semantics>
</math>

.<br/>
In the multidimentonal case with multivariate polynomials we need to use the theory and algorithms of <em>Grobner bases</em>(developed by Buchberger)<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>"Grobner bases" can be used to characterizing perfect reconstruction multidimensional filter banks, but it first need to extend from polynomial matrices to <a href="Laurent_polynomial" title="wikilink">Laurent polynomial</a> matrices.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>The Grobner basis computation can be considered equivalently as Gaussian elimination for solving the polynomial matrix equation 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:41">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>c</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>N</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <csymbol cd="latexml">absent</csymbol>
    <list>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>z</ci>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>N</ci>
      </apply>
      <ci>z</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   :c_{1}(z),...,c_{N}(z)
  </annotation>
 </semantics>
</math>

. If we have set of polynomial vectors 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:42">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mrow>
    <msub>
     <mi>b</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>b</mi>
     <mi>N</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>z</ci>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>N</ci>
     </apply>
     <ci>z</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{b_{1}(z),...,b_{N}(z)\right\}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:43">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mrow>
    <msub>
     <mi>h</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>h</mi>
     <mi>N</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>z</ci>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>N</ci>
     </apply>
     <ci>z</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{h_{1}(z),...,h_{N}(z)\right\}
  </annotation>
 </semantics>
</math>

 are polynomials.<br/>
The Module is analogous to the <em>span</em> of a set of vectors in linear algebra. The theory of Grobner bases implies that the Module has a unique reduced Grobner basis for a given order of power products in polynomials.</p>

<p>If we define the Grobner basis as 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:44">
 <semantics>
  <mrow>
   <msub>
    <mi>b</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <ci>i</ci>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{i}(z)
  </annotation>
 </semantics>
</math>

, it can be obtained from 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:45">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>j</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>j</ci>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{j}(z)
  </annotation>
 </semantics>
</math>

 by a finite sequence of reduction (division) steps.</p>

<p>Using reverse engineering, we can compute the basis vectors 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:46">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>×</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\times N
  </annotation>
 </semantics>
</math>

 in terms of the original vectors 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:47">
 <semantics>
  <mrow>
   <msub>
    <mi>W</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{ij}(z)
  </annotation>
 </semantics>
</math>

 through a 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:48">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>b</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>W</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>h</mi>
       <mi>j</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>K</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>i</ci>
      </apply>
      <ci>z</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>W</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>z</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>j</ci>
       </apply>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>i</ci>
     <list>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>K</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{i}(z)=\sum_{j=1}^{N}W_{ij}(z)h_{j}(z),i=1,...,K
  </annotation>
 </semantics>
</math>

 transformation matrix 

<math display="inline" id="Multirate_Filter_Bank_and_Multidimensional_Directional_Filter_Banks:49">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>l</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{l}
  </annotation>
 </semantics>
</math>

 as<br/>
<span class="LaTeX">$b_{i}(z)=\sum_{j=1}^{N}W_{ij}(z)h_{j}(z),i=1,...,K$</span></p>
<h3 id="mapping-based-multidimensional-filter-banks">Mapping-Based Multidimensional Filter Banks</h3>

<p>Designing filters with good frequency responses is challenging via Grobner bases approach.<br/>
Mapping based design in popularly used to design nonseparable multidimensional filter banks with good frequency responses.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><br/>
The mapping approaches have certain restrictions on the kind of filters; However, It brings many important advantages, such as efficient implementation via lifting/ladder structures.</p>
<h3 id="filter-banks-design-in-the-frequency-domain">Filter Banks Design in the Frequency Domain</h3>

<p>If we do not want perfect reconstruction filter banks using FIR filters, the design problem can be simplified by working in frequency domain instead of using FIR filters.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><br/>
Note that the frequency domain method is not limited to the design of nonsubsampled filter banks (read <a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a>).</p>
<h2 id="directional-filter-banks">Directional Filter Banks</h2>

<p>Bamberger and Smith proposed a 2D directional filter bank (DFB).<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> The DFB is efficiently implemented via an <em>l</em>-level tree-structured decomposition that leads to <span class="LaTeX">$2^{l}$</span> subbands with wedge-shaped frequency partition (see Figure ). The original construction of the DFB involves modulating the input signal and using diamond-shaped filters. Moreover, in order to obtain the desired frequency partition, a complicated tree expanding rule has to be followed.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> As a result, the frequency regions for the resulting subbands do not follow a simple ordering as shown in Figure 9 based on the channel indices.</p>

<p>The first advantage of DFB is that not only it is not a redundant transform but also it offers perfect reconstruction. Another advantage of DFB is its directional-selectivity and efficient structure. This advantage makes DFB an appropriate approach for many signal and image processing usage.</p>

<p>Directional Filter Banks can be develope to higher dimensions. It can be use in 3-D to achieve the frequency sectioning.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> This kinds of filters can be used in selective filtering purposes to record and save signals information and features. Some other advantages of NDFB can be addressed as follow: <strong>Directional decomposition</strong>, <strong>Construction</strong>, <strong>Angular resolution</strong>, <strong>Perfect reconstruction</strong>, and <strong>Small redundancy</strong>.</p>
<h2 id="multidimensional-directional-filter-banks">Multidimensional Directional Filter Banks</h2>

<p>N-dimensional directional filter banks (NDFB) <a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> can be used in capturing signals features and information. There are a number of studies regarding capturing signals informations is 2-D(e.g., steerable pyramid, the directional filter bank, 2-D directional <a class="uri" href="wavelets" title="wikilink">wavelets</a>, <a class="uri" href="curvelets" title="wikilink">curvelets</a>, complex wavelets, <a href="contourlet" title="wikilink">contourlets</a>, and bandelets).</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Filter_theory" title="wikilink">Category:Filter theory</a> <a href="Category:Multidimensional_signal_processing" title="wikilink">Category:Multidimensional signal processing</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Mitra, Sanjit Kumar, and Yonghong Kuo. Digital signal processing: a computer-based approach. New York: McGraw-Hill, 2006.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13">Tay, David BH, and Nick G. Kingsbury. "Flexible design of multidimensional perfect reconstruction FIR 2-band filters using transformations of variables." Image Processing, IEEE Transactions on 2.4 (1993): 466-480.<a href="#fnref13">↩</a></li>
<li id="fn14">Laligant, Olivier, and Frederic Truchetet. "Discrete wavelet transform implementation in Fourier domain for multidimensional signal." Journal of Electronic Imaging 11.3 (2002): 338-346.<a href="#fnref14">↩</a></li>
<li id="fn15">Woiselle, Arnaud, J-L. Starck, and J. Fadili. "3D curvelet transforms and astronomical data restoration." Applied and Computational Harmonic Analysis 28.2 (2010): 171-188.<a href="#fnref15">↩</a></li>
<li id="fn16">Feilner, Manuela, Dimitri Van De Ville, and Michael Unser. "An orthogonal family of quincunx wavelets with continuously adjustable order." Image Processing, IEEE Transactions on 14.4 (2005): 499-510.<a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19">Bamberger, Roberto H., and Mark JT Smith. "A filter bank for the directional decomposition of images: Theory and design." Signal Processing, IEEE Transactions on 40.4 (1992): 882-893.<a href="#fnref19">↩</a></li>
<li id="fn20">Lu, Yue M., and Minh N. Do. "Multidimensional directional filter banks and surfacelets." Image Processing, IEEE Transactions on 16.4 (2007): 918-931.<a href="#fnref20">↩</a></li>
</ol>
</section>
</body>
</html>
