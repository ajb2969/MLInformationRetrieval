<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1155">Holographic algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Holographic algorithm</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, a <strong>holographic algorithm</strong> is an algorithm that uses a holographic reduction. A holographic reduction is a constant-time <a href="Reduction_(complexity)" title="wikilink">reduction</a> that maps solution fragments many-to-many such that the sum of the solution fragments remains unchanged. These concepts were introduced by <a href="Leslie_Valiant" title="wikilink">Leslie Valiant</a>, who called them <em>holographic</em> because "their effect can be viewed as that of producing interference patterns among the solution fragments".<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The algorithms are unrelated to laser <a class="uri" href="holography" title="wikilink">holography</a>, except metaphorically. Their power comes from the mutual cancellation of many contributions to a sum, analogous to the interference patterns in a hologram.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Holographic algorithms have been used to find <a href="P_(complexity)" title="wikilink">polynomial-time</a> solutions to problems without such previously known solutions for special cases of <a href="Boolean_satisfiability_problem" title="wikilink">satisfiability</a>, <a href="vertex_cover" title="wikilink">vertex cover</a>, and other <a href="graph_theory" title="wikilink">graph problems</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> They have received notable coverage due to speculation that they are relevant to the <a href="P_versus_NP_problem" title="wikilink">P versus NP problem</a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> and their impact on <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>. Although some of the general problems are <a href="Sharp-P" title="wikilink">#P-hard</a> problems, the special cases solved are not themselves #P-hard, and thus do not prove FP = #P.</p>

<p>Holographic algorithms have some similarities with <a href="quantum_computation" title="wikilink">quantum computation</a>, but are completely classical.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="holant-problems">Holant problems</h2>

<p>Holographic algorithms exist in the context of Holant problems, which generalize counting <a href="constraint_satisfaction_problem" title="wikilink">constraint satisfaction problems</a> (#CSP). A #CSP instance is a <a class="uri" href="hypergraph" title="wikilink">hypergraph</a> <em>G</em>=(<em>V</em>,<em>E</em>) called the <a href="constraint_graph" title="wikilink">constraint graph</a>. Each hyperedge represents a variable and each vertex 

<math display="inline" id="Holographic_algorithm:0">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 is assigned a constraint 

<math display="inline" id="Holographic_algorithm:1">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>v</mi>
   </msub>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{v}.
  </annotation>
 </semantics>
</math>

 A vertex is connected to an hyperedge if the constraint on the vertex involves the variable on the hyperedge. The counting problem is to compute</p>

<p>

<math display="block" id="Holographic_algorithm:2">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>σ</mi>
      <mo>:</mo>
      <mrow>
       <mi>E</mi>
       <mo>→</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <mn>0</mn>
        <mo>,</mo>
        <mn>1</mn>
        <mo stretchy="false">}</mo>
       </mrow>
      </mrow>
     </mrow>
    </munder>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mrow>
       <mi>v</mi>
       <mo>∈</mo>
       <mi>V</mi>
      </mrow>
     </munder>
     <mrow>
      <msub>
       <mi>f</mi>
       <mi>v</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mrow>
         <mi>σ</mi>
         <mo fence="true">|</mo>
        </mrow>
        <mrow>
         <mi>E</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>v</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="35.5pt">,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <ci>normal-:</ci>
       <ci>σ</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>E</ci>
        <set>
         <cn type="integer">0</cn>
         <cn type="integer">1</cn>
        </set>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <in></in>
        <ci>v</ci>
        <ci>V</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>v</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">evaluated-at</csymbol>
        <ci>σ</ci>
        <apply>
         <times></times>
         <ci>E</ci>
         <ci>v</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{\sigma:E\to\{0,1\}}\prod_{v\in V}f_{v}(\sigma|_{E(v)}),~{}~{}~{}~{}~{}~{%
}~{}~{}~{}~{}(1)
  </annotation>
 </semantics>
</math>

 which is a sum over all variable assignments, the product of every constraint, where the inputs to the constrain 

<math display="inline" id="Holographic_algorithm:3">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>v</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{v}
  </annotation>
 </semantics>
</math>

 are the variables on the incident hyperedges of 

<math display="inline" id="Holographic_algorithm:4">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

.</p>

<p>A Holant problem is like a #CSP except the input must be a graph, not a hypergraph. Restricting the class of input graphs in this way is indeed a generalization. Given a #CSP instance, replace each hyperedge <em>e</em> of size <em>s</em> with a vertex <em>v</em> of degree <em>s</em> with edges incident to the vertices contained in <em>e</em>. The constraint on <em>v</em> is the equality function of arity <em>s</em>. This identifies all of the variables on the edges incident to <em>v</em>, which is the same effect as the single variable on the hyperedge <em>e</em>.</p>

<p>In the context of Holant problems, the expression in (1) is called the Holant after a related exponential sum introduced by Valiant.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="holographic-reduction">Holographic reduction</h2>

<p>A standard technique in complexity theory is a <a href="many-one_reduction" title="wikilink">many-one reduction</a>, where an instance of one problem is reduced to an instance of another (hopefully simpler) problem. However, holographic reductions between two computational problems preserve the sum of solutions without necessarily preserving correspondences between solutions.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> For instance, the total number of solutions in both sets can be preserved, even though individual problems do not have matching solutions. The sum can also be weighted, rather than simply counting the number of solutions, using <a href="Basis_(linear_algebra)" title="wikilink">linear basis vectors</a>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h3 id="general-example">General example</h3>

<p>It is convenient to consider holographic reductions on bipartite graphs. A general graph can always be transformed it into a bipartite graph while preserving the Holant value. This is done by replacing each edge in the graph by a path of length 2, which is also known as the 2-stretch of the graph. To keep the same Holant value, each new vertex is assigned the binary equality constraint.</p>

<p>Consider a bipartite graph <em>G</em>=(<em>U</em>,<em>V</em>,<em>E</em>) where the constraint assigned to every vertex 

<math display="inline" id="Holographic_algorithm:5">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>∈</mo>
   <mi>U</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>u</ci>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\in U
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Holographic_algorithm:6">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>u</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{u}
  </annotation>
 </semantics>
</math>

 and the constraint assigned to every vertex 

<math display="inline" id="Holographic_algorithm:7">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in V
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Holographic_algorithm:8">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>v</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{v}
  </annotation>
 </semantics>
</math>

. Denote this counting problem by 

<math display="inline" id="Holographic_algorithm:9">
 <semantics>
  <mrow>
   <mrow>
    <mtext>Holant</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo>,</mo>
     <msub>
      <mi>f</mi>
      <mi>u</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>f</mi>
      <mi>v</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>Holant</mtext>
    <vector>
     <ci>G</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>u</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>v</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Holant}(G,f_{u},f_{v}).
  </annotation>
 </semantics>
</math>

 If the vertices in <em>U</em> are viewed as one large vertex of degree |<em>E</em>|, then the constraint of this vertex is the <a href="tensor_product" title="wikilink">tensor product</a> of 

<math display="inline" id="Holographic_algorithm:10">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>u</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{u}
  </annotation>
 </semantics>
</math>

 with itself |<em>U</em>| times, which is denoted by 

<math display="inline" id="Holographic_algorithm:11">
 <semantics>
  <mrow>
   <msubsup>
    <mi>f</mi>
    <mi>u</mi>
    <mrow>
     <mi></mi>
     <mo>⊗</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>U</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </msubsup>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>u</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <abs></abs>
      <ci>U</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{u}^{\otimes|U|}.
  </annotation>
 </semantics>
</math>

 Likewise, if the vertices in <em>V</em> are viewed as one large vertex of degree |<em>E</em>|, then the constraint of this vertex is 

<math display="inline" id="Holographic_algorithm:12">
 <semantics>
  <mrow>
   <msubsup>
    <mi>f</mi>
    <mi>v</mi>
    <mrow>
     <mi></mi>
     <mo>⊗</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>V</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </msubsup>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <abs></abs>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{v}^{\otimes|V|}.
  </annotation>
 </semantics>
</math>

 Let the constraint 

<math display="inline" id="Holographic_algorithm:13">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>u</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{u}
  </annotation>
 </semantics>
</math>

 be represented by its weighted <a href="truth_table" title="wikilink">truth table</a> as a row vector and the constraint 

<math display="inline" id="Holographic_algorithm:14">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>v</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{v}
  </annotation>
 </semantics>
</math>

 be represented by its weighted truth table as a column vector. Then the Holant of this constraint graph is simply 

<math display="inline" id="Holographic_algorithm:15">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>f</mi>
     <mi>u</mi>
     <mrow>
      <mi></mi>
      <mo>⊗</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>U</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </msubsup>
    <msubsup>
     <mi>f</mi>
     <mi>v</mi>
     <mrow>
      <mi></mi>
      <mo>⊗</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>V</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </msubsup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>u</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <abs></abs>
       <ci>U</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>v</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <abs></abs>
       <ci>V</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{u}^{\otimes|U|}f_{v}^{\otimes|V|}.
  </annotation>
 </semantics>
</math>

</p>

<p>Now for any complex 2-by-2 <a href="invertible_matrix" title="wikilink">invertible matrix</a> <em>T</em> (the columns of which are the linear basis vectors mentioned above), there is a holographic reduction between 

<math display="inline" id="Holographic_algorithm:16">
 <semantics>
  <mrow>
   <mtext>Holant</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo>,</mo>
    <msub>
     <mi>f</mi>
     <mi>u</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>f</mi>
     <mi>v</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>Holant</mtext>
    <vector>
     <ci>G</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>u</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>v</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Holant}(G,f_{u},f_{v})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Holographic_algorithm:17">
 <semantics>
  <mrow>
   <mrow>
    <mtext>Holant</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>f</mi>
       <mi>u</mi>
      </msub>
      <msup>
       <mi>T</mi>
       <mrow>
        <mi></mi>
        <mo>⊗</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>deg</mi>
          <mi>u</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </msup>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>T</mi>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mi></mi>
        <mo>⊗</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>deg</mi>
          <mi>v</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </msup>
      <msub>
       <mi>f</mi>
       <mi>v</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>Holant</mtext>
    <vector>
     <ci>G</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>u</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>T</ci>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <csymbol cd="latexml">absent</csymbol>
        <apply>
         <csymbol cd="latexml">degree</csymbol>
         <ci>u</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>T</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <csymbol cd="latexml">absent</csymbol>
        <apply>
         <csymbol cd="latexml">degree</csymbol>
         <ci>v</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Holant}(G,f_{u}T^{\otimes(\deg u)},(T^{-1})^{\otimes(\deg v)}f_{v}).
  </annotation>
 </semantics>
</math>

 To see this, insert the identity matrix 

<math display="inline" id="Holographic_algorithm:18">
 <semantics>
  <mrow>
   <msup>
    <mi>T</mi>
    <mrow>
     <mi></mi>
     <mo>⊗</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>E</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </msup>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>T</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi></mi>
     <mo>⊗</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>E</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <abs></abs>
       <ci>E</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <abs></abs>
       <ci>E</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{\otimes|E|}(T^{-1})^{\otimes|E|}
  </annotation>
 </semantics>
</math>

 in between 

<math display="inline" id="Holographic_algorithm:19">
 <semantics>
  <mrow>
   <msubsup>
    <mi>f</mi>
    <mi>u</mi>
    <mrow>
     <mi></mi>
     <mo>⊗</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>U</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </msubsup>
   <msubsup>
    <mi>f</mi>
    <mi>v</mi>
    <mrow>
     <mi></mi>
     <mo>⊗</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>V</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>u</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <abs></abs>
       <ci>U</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>v</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <abs></abs>
       <ci>V</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{u}^{\otimes|U|}f_{v}^{\otimes|V|}
  </annotation>
 </semantics>
</math>

 to get</p>

<p>

<math display="block" id="Holographic_algorithm:20">
 <semantics>
  <mrow>
   <msubsup>
    <mi>f</mi>
    <mi>u</mi>
    <mrow>
     <mi></mi>
     <mo>⊗</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>U</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </msubsup>
   <msubsup>
    <mi>f</mi>
    <mi>v</mi>
    <mrow>
     <mi></mi>
     <mo>⊗</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>V</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>u</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <abs></abs>
       <ci>U</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>v</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <abs></abs>
       <ci>V</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{u}^{\otimes|U|}f_{v}^{\otimes|V|}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Holographic_algorithm:21">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>f</mi>
     <mi>u</mi>
     <mrow>
      <mi></mi>
      <mo>⊗</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>U</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </msubsup>
    <msup>
     <mi>T</mi>
     <mrow>
      <mi></mi>
      <mo>⊗</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>E</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </msup>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>T</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>⊗</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>E</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </msup>
    <msubsup>
     <mi>f</mi>
     <mi>v</mi>
     <mrow>
      <mi></mi>
      <mo>⊗</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>V</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>u</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <abs></abs>
        <ci>U</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <abs></abs>
        <ci>E</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>T</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <abs></abs>
        <ci>E</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>v</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <abs></abs>
        <ci>V</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =f_{u}^{\otimes|U|}T^{\otimes|E|}(T^{-1})^{\otimes|E|}f_{v}^{\otimes|V|}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Holographic_algorithm:22">
 <semantics>
  <mrow>
   <mrow>
    <mi></mi>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo>(</mo>
       <mrow>
        <msub>
         <mi>f</mi>
         <mi>u</mi>
        </msub>
        <msup>
         <mi>T</mi>
         <mrow>
          <mi></mi>
          <mo>⊗</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>deg</mi>
            <mi>u</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </msup>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mrow>
       <mi></mi>
       <mo>⊗</mo>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>U</mi>
        <mo stretchy="false">|</mo>
       </mrow>
      </mrow>
     </msup>
     <msup>
      <mrow>
       <mo>(</mo>
       <mrow>
        <msub>
         <mi>f</mi>
         <mi>v</mi>
        </msub>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <msup>
           <mi>T</mi>
           <mrow>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msup>
          <mo stretchy="false">)</mo>
         </mrow>
         <mrow>
          <mi></mi>
          <mo>⊗</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>deg</mi>
            <mi>v</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </msup>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mrow>
       <mi></mi>
       <mo>⊗</mo>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>V</mi>
        <mo stretchy="false">|</mo>
       </mrow>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>u</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>T</ci>
        <apply>
         <csymbol cd="latexml">tensor-product</csymbol>
         <csymbol cd="latexml">absent</csymbol>
         <apply>
          <csymbol cd="latexml">degree</csymbol>
          <ci>u</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <abs></abs>
        <ci>U</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>v</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>T</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="latexml">tensor-product</csymbol>
         <csymbol cd="latexml">absent</csymbol>
         <apply>
          <csymbol cd="latexml">degree</csymbol>
          <ci>v</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <abs></abs>
        <ci>V</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\left(f_{u}T^{\otimes(\deg u)}\right)^{\otimes|U|}\left(f_{v}(T^{-1})^{%
\otimes(\deg v)}\right)^{\otimes|V|}.
  </annotation>
 </semantics>
</math>

 Thus, 

<math display="inline" id="Holographic_algorithm:23">
 <semantics>
  <mrow>
   <mtext>Holant</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo>,</mo>
    <msub>
     <mi>f</mi>
     <mi>u</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>f</mi>
     <mi>v</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>Holant</mtext>
    <vector>
     <ci>G</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>u</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>v</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Holant}(G,f_{u},f_{v})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Holographic_algorithm:24">
 <semantics>
  <mrow>
   <mtext>Holant</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>u</mi>
     </msub>
     <msup>
      <mi>T</mi>
      <mrow>
       <mi></mi>
       <mo>⊗</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>deg</mi>
         <mi>u</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msup>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>T</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mi></mi>
       <mo>⊗</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>deg</mi>
         <mi>v</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msup>
     <msub>
      <mi>f</mi>
      <mi>v</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>Holant</mtext>
    <vector>
     <ci>G</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>u</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>T</ci>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <csymbol cd="latexml">absent</csymbol>
        <apply>
         <csymbol cd="latexml">degree</csymbol>
         <ci>u</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>T</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <csymbol cd="latexml">absent</csymbol>
        <apply>
         <csymbol cd="latexml">degree</csymbol>
         <ci>v</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Holant}(G,f_{u}T^{\otimes(\deg u)},(T^{-1})^{\otimes(\deg v)}f_{v})
  </annotation>
 </semantics>
</math>

 have exactly the same Holant value for every constraint graph. They essentially define the same counting problem.</p>
<h3 id="specific-examples">Specific examples</h3>
<h4 id="vertex-covers-and-independent-sets">Vertex covers and independent sets</h4>

<p>Let <em>G</em> be a graph. There is a 1-to-1 correspondence between the <a href="vertex_cover" title="wikilink">vertex covers</a> of <em>G</em> and the <a href="Independent_set_(graph_theory)" title="wikilink">independent sets</a> of <em>G</em>. For any set <em>S</em> of vertices of <em>G</em>, <em>S</em> is a vertex cover in <em>G</em> if and only if the <a href="Complement_(set_theory)" title="wikilink">complement</a> of <em>S</em> is an independent set in <em>G</em>. Thus, the number of vertex covers in <em>G</em> is exactly the same as the number of independent sets in <em>G</em>.</p>

<p>The equivalence of these two counting problems can also be proved using a holographic reduction. For simplicity, let <em>G</em> be a 3-<a href="regular_graph" title="wikilink">regular graph</a>. The 2-stretch of <em>G</em> gives a bipartite graph <em>H</em>=(<em>U</em>,<em>V</em>,<em>E</em>), where <em>U</em> corresponds to the edges in <em>G</em> and <em>V</em> corresponds to the vertices in <em>G</em>. The Holant problem that naturally corresponds to counting the number of vertex covers in <em>G</em> is 

<math display="inline" id="Holographic_algorithm:25">
 <semantics>
  <mrow>
   <mrow>
    <mtext>Holant</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>H</mi>
     <mo>,</mo>
     <msub>
      <mtext>OR</mtext>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mtext>EQUAL</mtext>
      <mn>3</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>Holant</mtext>
    <vector>
     <ci>H</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>OR</mtext>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>EQUAL</mtext>
      <cn type="integer">3</cn>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Holant}(H,\text{OR}_{2},\text{EQUAL}_{3}).
  </annotation>
 </semantics>
</math>

 The truth table of OR<sub>2</sub> as a row vector is (0,1,1,1). The truth table of EQUAL<sub>3</sub> as a column vector is 

<math display="inline" id="Holographic_algorithm:26">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>T</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo>[</mo>
      <mtable>
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>⊗</mo>
      <mn>3</mn>
     </mrow>
    </msup>
    <mo>+</mo>
    <msup>
     <mrow>
      <mo>[</mo>
      <mtable>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>⊗</mo>
      <mn>3</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <vector>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </vector>
     <ci>T</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <matrix>
       <matrixrow>
        <cn type="integer">1</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <matrix>
       <matrixrow>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">1</cn>
       </matrixrow>
      </matrix>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1,0,0,0,0,0,0,1)^{T}=\begin{bmatrix}1\\
0\end{bmatrix}^{\otimes 3}+\begin{bmatrix}0\\
1\end{bmatrix}^{\otimes 3}
  </annotation>
 </semantics>
</math>

. Then under a holographic transformation by 

<math display="inline" id="Holographic_algorithm:27">
 <semantics>
  <mrow>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">1</cn>
     <cn type="integer">0</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}0&1\\
1&0\end{bmatrix},
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Holographic_algorithm:28">
 <semantics>
  <mrow>
   <msubsup>
    <mtext>OR</mtext>
    <mn>2</mn>
    <mrow>
     <mi></mi>
     <mo>⊗</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>U</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </msubsup>
   <msubsup>
    <mtext>EQUAL</mtext>
    <mn>3</mn>
    <mrow>
     <mi></mi>
     <mo>⊗</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>V</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>OR</mtext>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <abs></abs>
       <ci>U</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>EQUAL</mtext>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <abs></abs>
       <ci>V</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{OR}_{2}^{\otimes|U|}\text{EQUAL}_{3}^{\otimes|V|}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Holographic_algorithm:29">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>⊗</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>U</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </msup>
    <msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mrow>
         <mo>[</mo>
         <mtable displaystyle="true">
          <mtr>
           <mtd columnalign="center">
            <mn>1</mn>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mn>0</mn>
           </mtd>
          </mtr>
         </mtable>
         <mo>]</mo>
        </mrow>
        <mrow>
         <mi></mi>
         <mo>⊗</mo>
         <mn>3</mn>
        </mrow>
       </msup>
       <mo>+</mo>
       <msup>
        <mrow>
         <mo>[</mo>
         <mtable displaystyle="true">
          <mtr>
           <mtd columnalign="center">
            <mn>0</mn>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mn>1</mn>
           </mtd>
          </mtr>
         </mtable>
         <mo>]</mo>
        </mrow>
        <mrow>
         <mi></mi>
         <mo>⊗</mo>
         <mn>3</mn>
        </mrow>
       </msup>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>⊗</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>V</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <vector>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
      </vector>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <abs></abs>
        <ci>U</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <matrix>
         <matrixrow>
          <cn type="integer">1</cn>
         </matrixrow>
         <matrixrow>
          <cn type="integer">0</cn>
         </matrixrow>
        </matrix>
        <apply>
         <csymbol cd="latexml">tensor-product</csymbol>
         <csymbol cd="latexml">absent</csymbol>
         <cn type="integer">3</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <matrix>
         <matrixrow>
          <cn type="integer">0</cn>
         </matrixrow>
         <matrixrow>
          <cn type="integer">1</cn>
         </matrixrow>
        </matrix>
        <apply>
         <csymbol cd="latexml">tensor-product</csymbol>
         <csymbol cd="latexml">absent</csymbol>
         <cn type="integer">3</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <abs></abs>
        <ci>V</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =(0,1,1,1)^{\otimes|U|}\left(\begin{bmatrix}1\\
0\end{bmatrix}^{\otimes 3}+\begin{bmatrix}0\\
1\end{bmatrix}^{\otimes 3}\right)^{\otimes|V|}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Holographic_algorithm:30">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>⊗</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>U</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </msup>
    <msup>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>⊗</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>E</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </msup>
    <msup>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>⊗</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>E</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </msup>
    <msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mrow>
         <mo>[</mo>
         <mtable displaystyle="true">
          <mtr>
           <mtd columnalign="center">
            <mn>1</mn>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mn>0</mn>
           </mtd>
          </mtr>
         </mtable>
         <mo>]</mo>
        </mrow>
        <mrow>
         <mi></mi>
         <mo>⊗</mo>
         <mn>3</mn>
        </mrow>
       </msup>
       <mo>+</mo>
       <msup>
        <mrow>
         <mo>[</mo>
         <mtable displaystyle="true">
          <mtr>
           <mtd columnalign="center">
            <mn>0</mn>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mn>1</mn>
           </mtd>
          </mtr>
         </mtable>
         <mo>]</mo>
        </mrow>
        <mrow>
         <mi></mi>
         <mo>⊗</mo>
         <mn>3</mn>
        </mrow>
       </msup>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>⊗</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>V</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <vector>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
      </vector>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <abs></abs>
        <ci>U</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <matrix>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <abs></abs>
        <ci>E</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <matrix>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <abs></abs>
        <ci>E</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <matrix>
         <matrixrow>
          <cn type="integer">1</cn>
         </matrixrow>
         <matrixrow>
          <cn type="integer">0</cn>
         </matrixrow>
        </matrix>
        <apply>
         <csymbol cd="latexml">tensor-product</csymbol>
         <csymbol cd="latexml">absent</csymbol>
         <cn type="integer">3</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <matrix>
         <matrixrow>
          <cn type="integer">0</cn>
         </matrixrow>
         <matrixrow>
          <cn type="integer">1</cn>
         </matrixrow>
        </matrix>
        <apply>
         <csymbol cd="latexml">tensor-product</csymbol>
         <csymbol cd="latexml">absent</csymbol>
         <cn type="integer">3</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <abs></abs>
        <ci>V</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =(0,1,1,1)^{\otimes|U|}\begin{bmatrix}0&1\\
1&0\end{bmatrix}^{\otimes|E|}\begin{bmatrix}0&1\\
1&0\end{bmatrix}^{\otimes|E|}\left(\begin{bmatrix}1\\
0\end{bmatrix}^{\otimes 3}+\begin{bmatrix}0\\
1\end{bmatrix}^{\otimes 3}\right)^{\otimes|V|}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Holographic_algorithm:31">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo>,</mo>
        <mn>1</mn>
        <mo>,</mo>
        <mn>1</mn>
        <mo>,</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
       </mrow>
       <msup>
        <mrow>
         <mo>[</mo>
         <mtable displaystyle="true">
          <mtr>
           <mtd columnalign="center">
            <mn>0</mn>
           </mtd>
           <mtd columnalign="center">
            <mn>1</mn>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mn>1</mn>
           </mtd>
           <mtd columnalign="center">
            <mn>0</mn>
           </mtd>
          </mtr>
         </mtable>
         <mo>]</mo>
        </mrow>
        <mrow>
         <mi></mi>
         <mo>⊗</mo>
         <mn>2</mn>
        </mrow>
       </msup>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>⊗</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>U</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </msup>
    <msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mrow>
           <mo>[</mo>
           <mtable displaystyle="true">
            <mtr>
             <mtd columnalign="center">
              <mn>0</mn>
             </mtd>
             <mtd columnalign="center">
              <mn>1</mn>
             </mtd>
            </mtr>
            <mtr>
             <mtd columnalign="center">
              <mn>1</mn>
             </mtd>
             <mtd columnalign="center">
              <mn>0</mn>
             </mtd>
            </mtr>
           </mtable>
           <mo>]</mo>
          </mrow>
          <mrow>
           <mo>[</mo>
           <mtable displaystyle="true">
            <mtr>
             <mtd columnalign="center">
              <mn>1</mn>
             </mtd>
            </mtr>
            <mtr>
             <mtd columnalign="center">
              <mn>0</mn>
             </mtd>
            </mtr>
           </mtable>
           <mo>]</mo>
          </mrow>
         </mrow>
         <mo>)</mo>
        </mrow>
        <mrow>
         <mi></mi>
         <mo>⊗</mo>
         <mn>3</mn>
        </mrow>
       </msup>
       <mo>+</mo>
       <msup>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mrow>
           <mo>[</mo>
           <mtable displaystyle="true">
            <mtr>
             <mtd columnalign="center">
              <mn>0</mn>
             </mtd>
             <mtd columnalign="center">
              <mn>1</mn>
             </mtd>
            </mtr>
            <mtr>
             <mtd columnalign="center">
              <mn>1</mn>
             </mtd>
             <mtd columnalign="center">
              <mn>0</mn>
             </mtd>
            </mtr>
           </mtable>
           <mo>]</mo>
          </mrow>
          <mrow>
           <mo>[</mo>
           <mtable displaystyle="true">
            <mtr>
             <mtd columnalign="center">
              <mn>0</mn>
             </mtd>
            </mtr>
            <mtr>
             <mtd columnalign="center">
              <mn>1</mn>
             </mtd>
            </mtr>
           </mtable>
           <mo>]</mo>
          </mrow>
         </mrow>
         <mo>)</mo>
        </mrow>
        <mrow>
         <mi></mi>
         <mo>⊗</mo>
         <mn>3</mn>
        </mrow>
       </msup>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>⊗</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>V</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <vector>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
       </vector>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <matrix>
         <matrixrow>
          <cn type="integer">0</cn>
          <cn type="integer">1</cn>
         </matrixrow>
         <matrixrow>
          <cn type="integer">1</cn>
          <cn type="integer">0</cn>
         </matrixrow>
        </matrix>
        <apply>
         <csymbol cd="latexml">tensor-product</csymbol>
         <csymbol cd="latexml">absent</csymbol>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <abs></abs>
        <ci>U</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <times></times>
         <matrix>
          <matrixrow>
           <cn type="integer">0</cn>
           <cn type="integer">1</cn>
          </matrixrow>
          <matrixrow>
           <cn type="integer">1</cn>
           <cn type="integer">0</cn>
          </matrixrow>
         </matrix>
         <matrix>
          <matrixrow>
           <cn type="integer">1</cn>
          </matrixrow>
          <matrixrow>
           <cn type="integer">0</cn>
          </matrixrow>
         </matrix>
        </apply>
        <apply>
         <csymbol cd="latexml">tensor-product</csymbol>
         <csymbol cd="latexml">absent</csymbol>
         <cn type="integer">3</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <times></times>
         <matrix>
          <matrixrow>
           <cn type="integer">0</cn>
           <cn type="integer">1</cn>
          </matrixrow>
          <matrixrow>
           <cn type="integer">1</cn>
           <cn type="integer">0</cn>
          </matrixrow>
         </matrix>
         <matrix>
          <matrixrow>
           <cn type="integer">0</cn>
          </matrixrow>
          <matrixrow>
           <cn type="integer">1</cn>
          </matrixrow>
         </matrix>
        </apply>
        <apply>
         <csymbol cd="latexml">tensor-product</csymbol>
         <csymbol cd="latexml">absent</csymbol>
         <cn type="integer">3</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <abs></abs>
        <ci>V</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\left((0,1,1,1)\begin{bmatrix}0&1\\
1&0\end{bmatrix}^{\otimes 2}\right)^{\otimes|U|}\left(\left(\begin{bmatrix}0&1%
\\
1&0\end{bmatrix}\begin{bmatrix}1\\
0\end{bmatrix}\right)^{\otimes 3}+\left(\begin{bmatrix}0&1\\
1&0\end{bmatrix}\begin{bmatrix}0\\
1\end{bmatrix}\right)^{\otimes 3}\right)^{\otimes|V|}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Holographic_algorithm:32">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>⊗</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>U</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </msup>
    <msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mrow>
         <mo>[</mo>
         <mtable displaystyle="true">
          <mtr>
           <mtd columnalign="center">
            <mn>0</mn>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mn>1</mn>
           </mtd>
          </mtr>
         </mtable>
         <mo>]</mo>
        </mrow>
        <mrow>
         <mi></mi>
         <mo>⊗</mo>
         <mn>3</mn>
        </mrow>
       </msup>
       <mo>+</mo>
       <msup>
        <mrow>
         <mo>[</mo>
         <mtable displaystyle="true">
          <mtr>
           <mtd columnalign="center">
            <mn>1</mn>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mn>0</mn>
           </mtd>
          </mtr>
         </mtable>
         <mo>]</mo>
        </mrow>
        <mrow>
         <mi></mi>
         <mo>⊗</mo>
         <mn>3</mn>
        </mrow>
       </msup>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>⊗</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>V</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <vector>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
      </vector>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <abs></abs>
        <ci>U</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <matrix>
         <matrixrow>
          <cn type="integer">0</cn>
         </matrixrow>
         <matrixrow>
          <cn type="integer">1</cn>
         </matrixrow>
        </matrix>
        <apply>
         <csymbol cd="latexml">tensor-product</csymbol>
         <csymbol cd="latexml">absent</csymbol>
         <cn type="integer">3</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <matrix>
         <matrixrow>
          <cn type="integer">1</cn>
         </matrixrow>
         <matrixrow>
          <cn type="integer">0</cn>
         </matrixrow>
        </matrix>
        <apply>
         <csymbol cd="latexml">tensor-product</csymbol>
         <csymbol cd="latexml">absent</csymbol>
         <cn type="integer">3</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <abs></abs>
        <ci>V</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =(1,1,1,0)^{\otimes|U|}\left(\begin{bmatrix}0\\
1\end{bmatrix}^{\otimes 3}+\begin{bmatrix}1\\
0\end{bmatrix}^{\otimes 3}\right)^{\otimes|V|}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Holographic_algorithm:33">
 <semantics>
  <mrow>
   <mrow>
    <mi></mi>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mtext>NAND</mtext>
      <mn>2</mn>
      <mrow>
       <mi></mi>
       <mo>⊗</mo>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>U</mi>
        <mo stretchy="false">|</mo>
       </mrow>
      </mrow>
     </msubsup>
     <msubsup>
      <mtext>EQUAL</mtext>
      <mn>3</mn>
      <mrow>
       <mi></mi>
       <mo>⊗</mo>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>V</mi>
        <mo stretchy="false">|</mo>
       </mrow>
      </mrow>
     </msubsup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>NAND</mtext>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <abs></abs>
        <ci>U</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>EQUAL</mtext>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <abs></abs>
        <ci>V</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\text{NAND}_{2}^{\otimes|U|}\text{EQUAL}_{3}^{\otimes|V|},
  </annotation>
 </semantics>
</math>

 which is 

<math display="inline" id="Holographic_algorithm:34">
 <semantics>
  <mrow>
   <mrow>
    <mtext>Holant</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>H</mi>
     <mo>,</mo>
     <msub>
      <mtext>NAND</mtext>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mtext>EQUAL</mtext>
      <mn>3</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>Holant</mtext>
    <vector>
     <ci>H</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>NAND</mtext>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>EQUAL</mtext>
      <cn type="integer">3</cn>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Holant}(H,\text{NAND}_{2},\text{EQUAL}_{3}),
  </annotation>
 </semantics>
</math>

 the Holant problem that naturally corresponds to counting the number of independent sets in <em>G</em>.</p>
<h2 id="history">History</h2>

<p>As with any type of reduction, a holographic reduction does not, by itself, yield a polynomial time algorithm. In order to get a polynomial time algorithm, the problem being reduced to must also have a polynomial time algorithm. Valiant's original application of holographic algorithms used a holographic reduction to a problem where every constraint is realizable by <a class="uri" href="matchgates" title="wikilink">matchgates</a>,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> which he had just proved is tractable by a further reduction to counting the number of <a href="perfect_matching" title="wikilink">perfect matchings</a> in a <a href="planar_graph" title="wikilink">planar graph</a>.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> The latter problem is tractable by the <a href="FKT_algorithm" title="wikilink">FKT algorithm</a>, which dates to the 1960s.</p>

<p>Soon after, Valiant found holographic algorithms with reductions to matchgates for #<a href="modulo_operation" title="wikilink"><sub>7</sub></a><a href="Planar_graph" title="wikilink">Pl</a>-Rtw-<a href="Monotonic_function#Boolean_functions" title="wikilink">Mon</a>-3<a href="Conjunctive_normal_form" title="wikilink">CNF</a> and #<sub>7</sub>Pl-3/2<a href="bipartite_graph" title="wikilink">Bip</a>-<a href="vertex_cover" title="wikilink">VC</a>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> These problems may appear somewhat contrived, especially with respect to the <a href="Modular_arithmetic" title="wikilink">modulus</a>. Both problems were already known to be #P-hard when ignoring the modulus and Valiant supplied proofs of #P-hardness modulo 2, which also used holographic reductions. Valiant found these two problems by a computer search that looked for problems with holographic reductions to matchgates. He called their algorithms <em>accidental algorithms</em>, saying "when applying the term accidental to an algorithm we intend to point out that the algorithm arises from satisfying an apparently onerous set of constraints." The "onerous" set of constraints in question are polynomial equations that, if satisfied, imply the existence of a holographic reduction to matchgate realizable constraints.</p>

<p>After several years of developing (what is known as) matchgate signature theory, Jin-Yi Cai and Pinyan Lu were able to explain the existence of Valiant's two accidental algorithms.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> These two problem are just special cases of two much larger families of problems: #<sub>2<sup>k</sup>-1</sub>Pl-Rtw-Mon-kCNF and #<sub>2<sup>k</sup>-1</sub>Pl-k/2Bip-VC for any positive integer <em>k</em>. The modulus 7 is just the third <a href="Mersenne_number" title="wikilink">Mersenne number</a> and Cai and Lu showed that these types of problems with parameter <em>k</em> can be solved in polynomial time exactly when the modulus is the <em>k</em>th Mersenne number by using holographic reductions to matchgates and the <a href="Chinese_remainder_theorem" title="wikilink">Chinese remainder theorem</a>.</p>

<p>Around the same time, Jin-Yi Cai, Pinyan Lu and Mingji Xia gave the first holographic algorithm that did not reduce to a problem that is tractable by matchgates.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> Instead, they reduced to a problem that is tractable by Fibonacci gates, which are <a href="symmetric_function" title="wikilink">symmetric</a> constraints whose truth tables satisfy a <a href="recurrence_relation" title="wikilink">recurrence relation</a> similar to one that defines the <a href="Fibonacci_number" title="wikilink">Fibonacci numbers</a>. They also used holographic reductions to prove that certain counting problems are #P-hard. Since then, holographic reductions have been used extensively as ingredients in both polynomial time algorithms and proofs of #P-hardness.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a class="uri" href="Category:Algorithms" title="wikilink">Category:Algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"></li>
<li id="fn13"></li>
</ol>
</section>
</body>
</html>
