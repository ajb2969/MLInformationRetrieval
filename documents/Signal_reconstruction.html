<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1597">Signal reconstruction</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Signal reconstruction</h1>
<hr/>

<p>In <a href="signal_processing" title="wikilink">signal processing</a>, <strong>reconstruction</strong> usually means the determination of an original continuous signal from a sequence of equally spaced samples.</p>

<p>This article takes a generalized abstract mathematical approach to signal sampling and reconstruction. For a more practical approach based on band-limited signals, see <a href="Whittaker–Shannon_interpolation_formula" title="wikilink">Whittaker–Shannon interpolation formula</a>.</p>
<h2 id="general-principle">General principle</h2>

<p>Let <em>F</em> be any sampling method, i.e. a linear map from the <a href="Hilbert_space" title="wikilink">Hilbert space</a> of square-integrable functions 

<math display="inline" id="Signal_reconstruction:0">
 <semantics>
  <msup>
   <mi>L</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>L</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{2}
  </annotation>
 </semantics>
</math>


 to <a href="complex_number" title="wikilink">complex</a> space 

<math display="inline" id="Signal_reconstruction:1">
 <semantics>
  <msup>
   <mi>ℂ</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℂ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}^{n}
  </annotation>
 </semantics>
</math>

.</p>

<p>In our example, the vector space of sampled signals 

<math display="inline" id="Signal_reconstruction:2">
 <semantics>
  <msup>
   <mi>ℂ</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℂ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}^{n}
  </annotation>
 </semantics>
</math>

 is <em>n</em>-dimensional complex space. Any proposed inverse <em>R</em> of <em>F</em> (<em>reconstruction formula</em>, in the lingo) would have to map 

<math display="inline" id="Signal_reconstruction:3">
 <semantics>
  <msup>
   <mi>ℂ</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℂ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}^{n}
  </annotation>
 </semantics>
</math>

 to some subset of 

<math display="inline" id="Signal_reconstruction:4">
 <semantics>
  <msup>
   <mi>L</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>L</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{2}
  </annotation>
 </semantics>
</math>

. We could choose this subset arbitrarily, but if we're going to want a reconstruction formula <em>R</em> that is also a linear map, then we have to choose an <em>n</em>-dimensional linear subspace of 

<math display="inline" id="Signal_reconstruction:5">
 <semantics>
  <msup>
   <mi>L</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>L</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{2}
  </annotation>
 </semantics>
</math>


.</p>

<p>This fact that the dimensions have to agree is related to the <a href="Nyquist–Shannon_sampling_theorem" title="wikilink">Nyquist–Shannon sampling theorem</a>.</p>

<p>The elementary linear algebra approach works here. Let 

<math display="inline" id="Signal_reconstruction:6">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mi>k</mi>
   </msub>
   <mo>:=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>k</ci>
    </apply>
    <vector>
     <cn type="integer">0</cn>
     <ci>normal-…</ci>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">0</cn>
     <ci>normal-…</ci>
     <cn type="integer">0</cn>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{k}:=(0,...,0,1,0,...,0)
  </annotation>
 </semantics>
</math>

 (all entries zero, except for the <em>k</em>th entry, which is a one) or some other basis of 

<math display="inline" id="Signal_reconstruction:7">
 <semantics>
  <msup>
   <mi>ℂ</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℂ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}^{n}
  </annotation>
 </semantics>
</math>

. To define an inverse for <em>F</em>, simply choose, for each <em>k</em>, an 

<math display="inline" id="Signal_reconstruction:8">
 <semantics>
  <mrow>
   <msub>
    <mi>e</mi>
    <mi>k</mi>
   </msub>
   <mo>∈</mo>
   <msup>
    <mi>L</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>L</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{k}\in L^{2}
  </annotation>
 </semantics>
</math>

 so that 

<math display="inline" id="Signal_reconstruction:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>e</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>d</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(e_{k})=d_{k}
  </annotation>
 </semantics>
</math>

. This uniquely defines the (pseudo-)inverse of <em>F</em>.</p>

<p>Of course, one can choose some reconstruction formula first, then either compute some sampling algorithm from the reconstruction formula, or analyze the behavior of a given sampling algorithm with respect to the given formula.</p>

<p>Ideally, the reconstruction formula is derived by minimizing the expected error variance. This requires that either the signal statistics is known or a prior probability for the signal can be specified. <a href="Information_field_theory" title="wikilink">Information field theory</a> is then an appropriate mathematical formalism to derive an optimal reconstruction formula.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="popular-reconstruction-formulae">Popular reconstruction formulae</h2>

<p>Perhaps the most widely used reconstruction formula is as follows. Let 

<math display="inline" id="Signal_reconstruction:10">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>e</mi>
    <mi>k</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <ci>k</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{e_{k}\}
  </annotation>
 </semantics>
</math>


 be a basis of 

<math display="inline" id="Signal_reconstruction:11">
 <semantics>
  <msup>
   <mi>L</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>L</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{2}
  </annotation>
 </semantics>
</math>

 in the Hilbert space sense; for instance, one could use the eikonal</p>

<p>

<math display="block" id="Signal_reconstruction:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>e</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mpadded width="+1.7pt">
    <msup>
     <mi>e</mi>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
      <mi>i</mi>
      <mi>k</mi>
      <mi>t</mi>
     </mrow>
    </msup>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>k</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>π</ci>
      <ci>i</ci>
      <ci>k</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{k}(t):=e^{2\pi ikt}\,
  </annotation>
 </semantics>
</math>

,</p>

<p>although other choices are certainly possible. Note that here the index <em>k</em> can be any integer, even negative.</p>

<p>Then we can define a linear map <em>R</em> by</p>

<p>

<math display="block" id="Signal_reconstruction:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>d</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <msub>
     <mi>e</mi>
     <mi>k</mi>
    </msub>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(d_{k})=e_{k}\,
  </annotation>
 </semantics>
</math>

</p>

<p>for each 

<math display="inline" id="Signal_reconstruction:14">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">⌊</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>n</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </mrow>
     <mo stretchy="false">⌋</mo>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">⌊</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">⌋</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <list>
     <apply>
      <floor></floor>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <floor></floor>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=\lfloor-n/2\rfloor,...,\lfloor(n-1)/2\rfloor
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Signal_reconstruction:15">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>d</mi>
    <mi>k</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (d_{k})
  </annotation>
 </semantics>
</math>


 is the basis of 

<math display="inline" id="Signal_reconstruction:16">
 <semantics>
  <msup>
   <mi>ℂ</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℂ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}^{n}
  </annotation>
 </semantics>
</math>

 given by</p>

<p>

<math display="block" id="Signal_reconstruction:17">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>d</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mfrac>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
      <mi>i</mi>
      <mi>j</mi>
      <mi>k</mi>
     </mrow>
     <mi>n</mi>
    </mfrac>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>k</ci>
     </apply>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>i</ci>
       <ci>j</ci>
       <ci>k</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{k}(j)=e^{2\pi ijk\over n}
  </annotation>
 </semantics>
</math>

</p>

<p>(This is the usual discrete Fourier basis.)</p>

<p>The choice of range 

<math display="inline" id="Signal_reconstruction:18">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">⌊</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>n</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </mrow>
     <mo stretchy="false">⌋</mo>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">⌊</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">⌋</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <list>
     <apply>
      <floor></floor>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <floor></floor>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=\lfloor-n/2\rfloor,...,\lfloor(n-1)/2\rfloor
  </annotation>
 </semantics>
</math>

 is somewhat arbitrary, although it satisfies the dimensionality requirement and reflects the usual notion that the most important information is contained in the low frequencies. In some cases, this is incorrect, so a different reconstruction formula needs to be chosen.</p>

<p>A similar approach can be obtained by using <a href="wavelet" title="wikilink">wavelets</a> instead of Hilbert bases. For many applications, the best approach is still not clear today.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Nyquist–Shannon_sampling_theorem" title="wikilink">Nyquist–Shannon sampling theorem</a></li>
<li><a href="Whittaker–Shannon_interpolation_formula" title="wikilink">Whittaker–Shannon interpolation formula</a></li>
<li><a class="uri" href="Aliasing" title="wikilink">Aliasing</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Signal_processing" title="wikilink">Reconstruction</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
