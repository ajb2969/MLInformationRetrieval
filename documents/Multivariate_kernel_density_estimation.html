<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="315">Multivariate kernel density estimation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Multivariate kernel density estimation</h1>
<hr>[[Kernel density estimation]] is a [[nonparametric]] technique for  [[density estimation]] i.e., estimation of [[probability density function]]s, which is one of the fundamental questions in [[statistics]]. It can be viewed as a generalisation of [[histogram]] density estimation with improved statistical properties. Apart from histograms, other types of density estimators include [[parametric statistics|parametric]], [[spline interpolation|spline]], [[wavelet]] and [[Fourier series]]. Kernel density estimators were first introduced in the scientific literature <style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</hr></body></html>
<body>

<p>for <a class="uri" href="univariate" title="wikilink">univariate</a> data in the 1950s and 1960s<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and subsequently have been widely adopted. It was soon recognised that analogous estimators for multivariate data would be an important addition to <a href="multivariate_statistics" title="wikilink">multivariate statistics</a>. Based on research carried out in the 1990s and 2000s, multivariate kernel density estimation has reached a level of maturity comparable to its univariate counterparts.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="motivation">Motivation</h2>

<p>We take an illustrative <a href="Synthetic_data" title="wikilink">synthetic</a> <a href="bivariate_data" title="wikilink">bivariate</a> data set of 50 points to illustrate the construction of histograms. This requires the choice of an anchor point (the lower left corner of the histogram grid). For the histogram on the left, we choose (‚àí1.5,¬†‚àí1.5): for the one on the right, we shift the anchor point by 0.125 in both directions to (‚àí1.625,¬†‚àí1.625). Both histograms have a binwidth of 0.25, so any differences are due to the change in the anchor point only. The colour-coding indicates the number of data points which fall into a bin: 0=white, 1=pale yellow, 2=bright yellow, 3=orange, 4=red. The left histogram appears to indicate that the upper half has a higher density than the lower half, whereas it is the reverse is the case for the right-hand histogram, confirming that histograms are highly sensitive to the placement of the anchor point.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<figure><b>(Figure)</b>
<figcaption>Comparison of 2D histograms. Left. Histogram with anchor point at (‚àí1.5,¬†-1.5). Right. Histogram with anchor point at (‚àí1.625,¬†‚àí1.625). Both histograms have a bin width of 0.5, so differences in appearances of the two histograms are due to the placement of the anchor point.</figcaption>
</figure>

<p>One possible solution to this anchor point placement problem is to remove the histogram binning grid completely. In the left figure below, a kernel (represented by the grey lines) is centred at each of the 50 data points above. The result of summing these kernels is given on the right figure, which is a kernel density estimate. The most striking difference between kernel density estimates and histograms is that the former are easier to interpret since they do not contain artifices induced by a binning grid. The coloured contours correspond to the smallest region which contains the respective probability mass: red = 25%, orange + red = 50%, yellow + orange + red = 75%, thus indicating that a single central region contains the highest density.</p>
<figure><b>(Figure)</b>
<figcaption>Construction of 2D kernel density estimate. Left. Individual kernels. Right. Kernel density estimate.</figcaption>
</figure>

<p>The goal of density estimation is to take a finite sample of data and to make inferences about the underlying probability density function everywhere, including where no data are observed. In kernel density estimation, the contribution of each data point is smoothed out from a single point into a region of space surrounding it. Aggregating the individually smoothed contributions gives an overall picture of the structure of the data and its density function. In the details to follow, we show that this approach leads to a reasonable estimate of the underlying density function.</p>
<h2 id="definition">Definition</h2>

<p>The previous figure is a graphical representation of kernel density estimate, which we now define in an exact manner. Let <strong>x</strong><sub>1</sub>, <strong>x</strong><sub>2</sub>, ‚Ä¶, <strong>x</strong><sub><em>n</em></sub> be a <a href="random_sample" title="wikilink">sample</a> of <em>d</em>-variate <a href="random_vector" title="wikilink">random vectors</a> drawn from a common distribution described by the <a href="probability_density_function" title="wikilink">density function</a> <em>∆í</em>. The kernel density estimate is defined to be</p>

<p>

<math display="block" id="Multivariate_kernel_density_estimation:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>f</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>‚Ñç</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ùï©</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>n</mi>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>K</mi>
       <mi>‚Ñç</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>ùï©</mi>
        <mo>-</mo>
        <msub>
         <mi>ùï©</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>f</ci>
      </apply>
      <ci>‚Ñç</ci>
     </apply>
     <ci>ùï©</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <ci>‚Ñç</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>ùï©</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ùï©</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{f}_{\mathbb{H}}(\mathbb{x})=\frac{1}{n}\sum_{i=1}^{n}K_{\mathbb{H}}(%
\mathbb{x}-\mathbb{x}_{i})
  </annotation>
 </semantics>
</math>

 where</p>
<ul>
<li><mtpl> (<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ‚Ä¶, <em>x<sub>d</sub></em>)<sup><em>T</em></sup>}}</mtpl>, <mtpl> (<em>x</em><sub><em>i</em>1</sub>, <em>x</em><sub><em>i</em>2</sub>, ‚Ä¶, <em>x<sub>id</sub></em>)<sup><em>T</em></sup>, <em>i</em> {{=}} 1, 2, ‚Ä¶, <em>n</em>}}</mtpl> are <em>d</em>-vectors;</li>
<li><strong>H</strong> is the bandwidth (or smoothing) <em>d√ód</em> matrix which is <a href="symmetric_matrix" title="wikilink">symmetric</a> and <a href="positive_definite_matrix" title="wikilink">positive definite</a>;</li>
<li><em>K</em> is the <a href="kernel_(statistics)" title="wikilink">kernel</a> function which is a symmetric multivariate density;</li>
<li><mtpl> {{!}}<strong>H</strong>{{!}}<sup>‚àí1/2</sup>‚Äâ<em>K</em>(<strong>H</strong><sup>‚àí1/2</sup><strong>x</strong>)}}</mtpl>.</li>
</ul>

<p>The choice of the kernel function <em>K</em> is not crucial to the accuracy of kernel density estimators, so we use the standard <a href="multivariate_normal_distribution" title="wikilink">multivariate normal</a> kernel throughout: <mtpl> (2<em>œÄ</em>)<sup>‚àí<em>d</em>/2</sup>‚Äâexp(‚àí<strong>x</strong><sup><em>T</em></sup><strong>x</strong>)}}</mtpl>. On the other hand, the choice of the bandwidth matrix <strong>H</strong> is the single most important factor affecting its accuracy since it controls the amount and orientation of smoothing induced.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> That the bandwidth matrix also induces an orientation is a basic difference between multivariate kernel density estimation from its univariate analogue since orientation is not defined for 1D kernels. This leads to the choice of the parametrisation of this bandwidth matrix. The three main parametrisation classes (in increasing order of complexity) are <em>S</em>, the class of positive scalars times the identity matrix; <em>D</em>, diagonal matrices with positive entries on the main diagonal; and <em>F</em>, symmetric positive definite matrices. The <em>S</em> class kernels have the same amount of smoothing applied in all coordinate directions, <em>D</em> kernels allow different amounts of smoothing in each of the coordinates, and <em>F</em> kernels allow arbitrary amounts and orientation of the smoothing. Historically <em>S</em> and <em>D</em> kernels are the most widespread due to computational reasons, but research indicates that important gains in accuracy can be obtained using the more general <em>F</em> class kernels.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<figure><b>(Figure)</b>
<figcaption>Comparison of the three main bandwidth matrix parametrisation classes. Left. <em>S</em> positive scalar times the identity matrix. Centre. <em>D</em> diagonal matrix with positive entries on the main diagonal. Right. <em>F</em> symmetric positive definite matrix.</figcaption>
</figure>
<h2 id="optimal-bandwidth-matrix-selection">Optimal bandwidth matrix selection</h2>

<p>The most commonly used optimality criterion for selecting a bandwidth matrix is the MISE or <a href="mean_integrated_squared_error" title="wikilink">mean integrated squared error</a></p>

<p>

<math display="block" id="Multivariate_kernel_density_estimation:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>MISE</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>‚Ñç</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo rspace="0.8pt">E</mo>
     <mrow>
      <mo rspace="4.2pt">[</mo>
      <mrow>
       <mo largeop="true" symmetric="true">‚à´</mo>
       <mrow>
        <mpadded width="+1.7pt">
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mrow>
             <msub>
              <mover accent="true">
               <mi>f</mi>
               <mo stretchy="false">^</mo>
              </mover>
              <mi>‚Ñç</mi>
             </msub>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>ùï©</mi>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
            <mo>-</mo>
            <mrow>
             <mi>f</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>ùï©</mi>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mn>2</mn>
         </msup>
        </mpadded>
        <mi>d</mi>
        <mpadded width="+2.8pt">
         <mi>ùï©</mi>
        </mpadded>
       </mrow>
      </mrow>
      <mo>]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>MISE</ci>
     <ci>‚Ñç</ci>
    </apply>
    <apply>
     <ci>normal-E</ci>
     <apply>
      <int></int>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <apply>
            <ci>normal-^</ci>
            <ci>f</ci>
           </apply>
           <ci>‚Ñç</ci>
          </apply>
          <ci>ùï©</ci>
         </apply>
         <apply>
          <times></times>
          <ci>f</ci>
          <ci>ùï©</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>d</ci>
       <ci>ùï©</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{MISE}(\mathbb{H})=\operatorname{E}\!\left[\,\int(\hat{f}_{%
\mathbb{H}}(\mathbb{x})-f(\mathbb{x}))^{2}\,d\mathbb{x}\;\right].
  </annotation>
 </semantics>
</math>

</p>

<p>This in general does not possess a <a href="closed-form_expression" title="wikilink">closed-form expression</a>, so it is usual to use its asymptotic approximation (AMISE) as a proxy</p>

<p>

<math display="block" id="Multivariate_kernel_density_estimation:2">
 <semantics>
  <mrow>
   <mrow>
    <mo>AMISE</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>‚Ñç</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>n</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>‚Ñç</mi>
       <mo stretchy="false">|</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
     </msup>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>K</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mstyle displaystyle="false">
      <mfrac>
       <mn>1</mn>
       <mn>4</mn>
      </mfrac>
     </mstyle>
     <msub>
      <mi>m</mi>
      <mn>2</mn>
     </msub>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>K</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mo>vec</mo>
        <mi>T</mi>
       </msup>
       <mi>‚Ñç</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi mathvariant="double-struck">Œ®</mi>
      <mn>4</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>vec</mo>
       <mi>‚Ñç</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>AMISE</ci>
     <ci>‚Ñç</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <ci>‚Ñç</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <ci>R</ci>
      <ci>K</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">4</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>K</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>vec</ci>
        <ci>T</ci>
       </apply>
       <ci>‚Ñç</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>double-struck-Œ®</ci>
       <cn type="integer">4</cn>
      </apply>
      <apply>
       <ci>vec</ci>
       <ci>‚Ñç</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{AMISE}(\mathbb{H})=n^{-1}|\mathbb{H}|^{-1/2}R(K)+\tfrac{1}{4}m_{%
2}(K)^{2}(\operatorname{vec}^{T}\mathbb{H})\mathbb{\Psi}_{4}(\operatorname{vec%
}\mathbb{H})
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>
<ul>
<li>

<math display="inline" id="Multivariate_kernel_density_estimation:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>K</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" symmetric="true">‚à´</mo>
    <mrow>
     <mi>K</mi>
     <mpadded width="+1.7pt">
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ùï©</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mpadded>
     <mi>d</mi>
     <mi>ùï©</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>K</ci>
    </apply>
    <apply>
     <int></int>
     <apply>
      <times></times>
      <ci>K</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ùï©</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>d</ci>
      <ci>ùï©</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(K)=\int K(\mathbb{x})^{2}\,d\mathbb{x}
  </annotation>
 </semantics>
</math>

, with <mtpl> (4<em>œÄ</em>)<sup><em>‚àíd</em>/2</sup>}}</mtpl> when <em>K</em> is a normal kernel</li>
<li>

<math display="inline" id="Multivariate_kernel_density_estimation:4">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" symmetric="true">‚à´</mo>
    <mrow>
     <mi>ùï©</mi>
     <msup>
      <mi>ùï©</mi>
      <mi>T</mi>
     </msup>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ùï©</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>ùï©</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>m</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>K</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>ùïÄ</mi>
     <mi>d</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <int></int>
     <apply>
      <times></times>
      <ci>ùï©</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ùï©</ci>
       <ci>T</ci>
      </apply>
      <ci>K</ci>
      <ci>ùï©</ci>
      <ci>d</ci>
      <ci>ùï©</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>K</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùïÄ</ci>
      <ci>d</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int\mathbb{x}\mathbb{x}^{T}K(\mathbb{x})\,d\mathbb{x}=m_{2}(K)\mathbb{I}_{d}
  </annotation>
 </semantics>
</math>

,</li>
</ul>
<dl>
<dd>with <strong>I</strong><sub>d</sub> being the <em>d √ó d</em> <a href="identity_matrix" title="wikilink">identity matrix</a>, with <em>m</em><sub>2</sub> = 1 for the normal kernel
</dd>
</dl>
<ul>
<li>D<sup>2</sup><em>∆í</em> is the <em>d √ó d</em> Hessian matrix of second order partial derivatives of <em>∆í</em></li>
<li>

<math display="inline" id="Multivariate_kernel_density_estimation:5">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="double-struck">Œ®</mi>
    <mn>4</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" symmetric="true">‚à´</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mrow>
         <mo rspace="4.2pt">vec</mo>
         <msup>
          <mo>D</mo>
          <mn>2</mn>
         </msup>
        </mrow>
        <mi>f</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ùï©</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mrow>
         <msup>
          <mo>vec</mo>
          <mi>T</mi>
         </msup>
         <msup>
          <mo>D</mo>
          <mn>2</mn>
         </msup>
        </mrow>
        <mi>f</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ùï©</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>ùï©</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>double-struck-Œ®</ci>
     <cn type="integer">4</cn>
    </apply>
    <apply>
     <int></int>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <apply>
         <ci>vec</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>normal-D</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <ci>f</ci>
       </apply>
       <ci>ùï©</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>vec</ci>
          <ci>T</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>normal-D</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <ci>f</ci>
       </apply>
       <ci>ùï©</ci>
      </apply>
      <ci>d</ci>
      <ci>ùï©</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{\Psi}_{4}=\int(\operatorname{vec}\,\operatorname{D}^{2}f(\mathbb{x}))(%
\operatorname{vec}^{T}\operatorname{D}^{2}f(\mathbb{x}))\,d\mathbb{x}
  </annotation>
 </semantics>
</math>

 is a <em>d</em><sup>2</sup> √ó <em>d</em><sup>2</sup> matrix of integrated fourth order partial derivatives of <em>∆í</em></li>
<li>vec is the vector operator which stacks the columns of a matrix into a single vector e.g. 

<math display="inline" id="Multivariate_kernel_density_estimation:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>vec</mo>
     <mrow>
      <mo>[</mo>
      <mtable>
       <mtr>
        <mtd columnalign="center">
         <mi>a</mi>
        </mtd>
        <mtd columnalign="center">
         <mi>c</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi>b</mi>
        </mtd>
        <mtd columnalign="center">
         <mi>d</mi>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo>[</mo>
      <mtable>
       <mtr>
        <mtd columnalign="center">
         <mi>a</mi>
        </mtd>
        <mtd columnalign="center">
         <mi>b</mi>
        </mtd>
        <mtd columnalign="center">
         <mi>c</mi>
        </mtd>
        <mtd columnalign="center">
         <mi>d</mi>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
     <mi>T</mi>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>vec</ci>
     <matrix>
      <matrixrow>
       <ci>a</ci>
       <ci>c</ci>
      </matrixrow>
      <matrixrow>
       <ci>b</ci>
       <ci>d</ci>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <matrix>
      <matrixrow>
       <ci>a</ci>
       <ci>b</ci>
       <ci>c</ci>
       <ci>d</ci>
      </matrixrow>
     </matrix>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{vec}\begin{bmatrix}a&c\\
b&d\end{bmatrix}=\begin{bmatrix}a&b&c&d\end{bmatrix}^{T}.
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>The quality of the AMISE approximation to the MISE<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> is given by</p>

<p>

<math display="block" id="Multivariate_kernel_density_estimation:7">
 <semantics>
  <mrow>
   <mrow>
    <mo>MISE</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>‚Ñç</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>AMISE</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>‚Ñç</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>o</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msup>
         <mi>n</mi>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
        <msup>
         <mrow>
          <mo stretchy="false">|</mo>
          <mi>‚Ñç</mi>
          <mo stretchy="false">|</mo>
         </mrow>
         <mrow>
          <mo>-</mo>
          <mrow>
           <mn>1</mn>
           <mo>/</mo>
           <mn>2</mn>
          </mrow>
         </mrow>
        </msup>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mo rspace="4.2pt">tr</mo>
        <msup>
         <mi>‚Ñç</mi>
         <mn>2</mn>
        </msup>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>MISE</ci>
     <ci>‚Ñç</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <ci>AMISE</ci>
      <ci>‚Ñç</ci>
     </apply>
     <apply>
      <times></times>
      <ci>o</ci>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>n</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <abs></abs>
          <ci>‚Ñç</ci>
         </apply>
         <apply>
          <minus></minus>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <ci>tr</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>‚Ñç</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{MISE}(\mathbb{H})=\operatorname{AMISE}(\mathbb{H})+o(n^{-1}|%
\mathbb{H}|^{-1/2}+\operatorname{tr}\,\mathbb{H}^{2})
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>o</em> indicates the usual <a href="big_O_notation" title="wikilink">small o notation</a>. Heuristically this statement implies that the AMISE is a 'good' approximation of the MISE as the sample size <em>n ‚Üí ‚àû<em>.</em></em></p>

<p>It can be shown that any reasonable bandwidth selector <strong>H</strong> has <strong>H</strong> = <em>O(n<sup>‚àí2/(d+4)</sup>)</em> where the <a href="big_O_notation" title="wikilink">big O notation</a> is applied elementwise. Substituting this into the MISE formula yields that the optimal MISE is <em>O(n<sup>‚àí4/(d+4)</sup>).</em><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Thus as <em>n ‚Üí ‚àû</em>, the MISE ‚Üí 0, i.e. the kernel density estimate <a href="convergence_in_mean" title="wikilink">converges in mean square</a> and thus also in probability to the true density <em>f</em>. These modes of convergence are confirmation of the statement in the motivation section that kernel methods lead to reasonable density estimators. An ideal optimal bandwidth selector is</p>

<p>

<math display="block" id="Multivariate_kernel_density_estimation:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>‚Ñç</mi>
     <mo>AMISE</mo>
    </msub>
    <mo>=</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <msub>
       <mo>argmin</mo>
       <mrow>
        <mi>‚Ñç</mi>
        <mo>‚àà</mo>
        <mi>F</mi>
       </mrow>
      </msub>
     </mpadded>
     <mrow>
      <mo>AMISE</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>‚Ñç</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>‚Ñç</ci>
     <ci>AMISE</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>argmin</ci>
      <apply>
       <in></in>
       <ci>‚Ñç</ci>
       <ci>F</ci>
      </apply>
     </apply>
     <apply>
      <ci>AMISE</ci>
      <ci>‚Ñç</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{H}_{\operatorname{AMISE}}=\operatorname{argmin}_{\mathbb{H}\in F}\,%
\operatorname{AMISE}(\mathbb{H}).
  </annotation>
 </semantics>
</math>

</p>

<p>Since this ideal selector contains the unknown density function <em>∆í</em>, it cannot be used directly. The many different varieties of data-based bandwidth selectors arise from the different estimators of the AMISE. We concentrate on two classes of selectors which have been shown to be the most widely applicable in practise: smoothed cross validation and plug-in selectors.</p>
<h3 id="plug-in">Plug-in</h3>

<p>The plug-in (PI) estimate of the AMISE is formed by replacing <strong>Œ®</strong><sub>4</sub> by its estimator 

<math display="inline" id="Multivariate_kernel_density_estimation:9">
 <semantics>
  <msub>
   <mover accent="true">
    <mi mathvariant="double-struck">Œ®</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mn>4</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>double-struck-Œ®</ci>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbb{\Psi}}_{4}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Multivariate_kernel_density_estimation:10">
 <semantics>
  <mrow>
   <mrow>
    <mo>PI</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>‚Ñç</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>n</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>‚Ñç</mi>
       <mo stretchy="false">|</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
     </msup>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>K</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mstyle displaystyle="false">
      <mfrac>
       <mn>1</mn>
       <mn>4</mn>
      </mfrac>
     </mstyle>
     <msub>
      <mi>m</mi>
      <mn>2</mn>
     </msub>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>K</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mo>vec</mo>
        <mi>T</mi>
       </msup>
       <mi>‚Ñç</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mover accent="true">
       <mi mathvariant="double-struck">Œ®</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mn>4</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ùîæ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo rspace="4.2pt">vec</mo>
       <mi>‚Ñç</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>PI</ci>
     <ci>‚Ñç</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <ci>‚Ñç</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <ci>R</ci>
      <ci>K</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">4</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>K</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>vec</ci>
        <ci>T</ci>
       </apply>
       <ci>‚Ñç</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>double-struck-Œ®</ci>
       </apply>
       <cn type="integer">4</cn>
      </apply>
      <ci>ùîæ</ci>
      <apply>
       <ci>vec</ci>
       <ci>‚Ñç</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{PI}(\mathbb{H})=n^{-1}|\mathbb{H}|^{-1/2}R(K)+\tfrac{1}{4}m_{2}(%
K)^{2}(\operatorname{vec}^{T}\mathbb{H})\hat{\mathbb{\Psi}}_{4}(\mathbb{G})(%
\operatorname{vec}\,\mathbb{H})
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Multivariate_kernel_density_estimation:11">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mi mathvariant="double-struck">Œ®</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mn>4</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ùîæ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>n</mi>
     <mrow>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
    </msup>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">‚àë</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </msubsup>
      <mrow>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mo rspace="4.2pt">vec</mo>
           <msup>
            <mo>D</mo>
            <mn>2</mn>
           </msup>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msup>
            <mo>vec</mo>
            <mi>T</mi>
           </msup>
           <msup>
            <mo>D</mo>
            <mn>2</mn>
           </msup>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
       <msub>
        <mi>K</mi>
        <mi>ùîæ</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>ùïè</mi>
          <mi>i</mi>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>ùïè</mi>
          <mi>j</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>double-struck-Œ®</ci>
      </apply>
      <cn type="integer">4</cn>
     </apply>
     <ci>ùîæ</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <times></times>
          <apply>
           <ci>vec</ci>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>normal-D</ci>
            <cn type="integer">2</cn>
           </apply>
          </apply>
          <apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>vec</ci>
            <ci>T</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>normal-D</ci>
            <cn type="integer">2</cn>
           </apply>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>K</ci>
         <ci>ùîæ</ci>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ùïè</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ùïè</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbb{\Psi}}_{4}(\mathbb{G})=n^{-2}\sum_{i=1}^{n}\sum_{j=1}^{n}[(%
\operatorname{vec}\,\operatorname{D}^{2})(\operatorname{vec}^{T}\operatorname{%
D}^{2})]K_{\mathbb{G}}(\mathbb{X}_{i}-\mathbb{X}_{j})
  </annotation>
 </semantics>
</math>

. Thus 

<math display="inline" id="Multivariate_kernel_density_estimation:12">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>‚Ñç</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo>PI</mo>
   </msub>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <msub>
      <mo>argmin</mo>
      <mrow>
       <mi>‚Ñç</mi>
       <mo>‚àà</mo>
       <mi>F</mi>
      </mrow>
     </msub>
    </mpadded>
    <mrow>
     <mo>PI</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>‚Ñç</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>‚Ñç</ci>
     </apply>
     <ci>PI</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>argmin</ci>
      <apply>
       <in></in>
       <ci>‚Ñç</ci>
       <ci>F</ci>
      </apply>
     </apply>
     <apply>
      <ci>PI</ci>
      <ci>‚Ñç</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbb{H}}_{\operatorname{PI}}=\operatorname{argmin}_{\mathbb{H}\in F}\,%
\operatorname{PI}(\mathbb{H})
  </annotation>
 </semantics>
</math>

 is the plug-in selector.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> These references also contain algorithms on optimal estimation of the pilot bandwidth matrix <strong>G</strong> and establish that 

<math display="inline" id="Multivariate_kernel_density_estimation:13">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>‚Ñç</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>PI</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>‚Ñç</ci>
    </apply>
    <ci>PI</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbb{H}}_{\operatorname{PI}}
  </annotation>
 </semantics>
</math>

 <a href="convergence_in_probability" title="wikilink">converges in probability</a> to <strong>H</strong><sub>AMISE</sub>.</p>
<h3 id="smoothed-cross-validation">Smoothed cross validation</h3>

<p>Smoothed cross validation (SCV) is a subset of a larger class of <a href="cross-validation_(statistics)" title="wikilink">cross validation</a> techniques. The SCV estimator differs from the plug-in estimator in the second term</p>

<p>

<math display="block" id="Multivariate_kernel_density_estimation:14">
 <semantics>
  <mrow>
   <mrow>
    <mo>SCV</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>‚Ñç</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>n</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>‚Ñç</mi>
       <mo stretchy="false">|</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
     </msup>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>K</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msup>
      <mi>n</mi>
      <mrow>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
        <mrow>
         <mi>j</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>n</mi>
       </munderover>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <msub>
            <mi>K</mi>
            <mrow>
             <mrow>
              <mn>2</mn>
              <mi>‚Ñç</mi>
             </mrow>
             <mo>+</mo>
             <mrow>
              <mn>2</mn>
              <mi>ùîæ</mi>
             </mrow>
            </mrow>
           </msub>
           <mo>-</mo>
           <mrow>
            <mn>2</mn>
            <msub>
             <mi>K</mi>
             <mrow>
              <mi>‚Ñç</mi>
              <mo>+</mo>
              <mrow>
               <mn>2</mn>
               <mi>ùîæ</mi>
              </mrow>
             </mrow>
            </msub>
           </mrow>
          </mrow>
          <mo>+</mo>
          <msub>
           <mi>K</mi>
           <mrow>
            <mn>2</mn>
            <mi>ùîæ</mi>
           </mrow>
          </msub>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msub>
           <mi>ùïè</mi>
           <mi>i</mi>
          </msub>
          <mo>-</mo>
          <msub>
           <mi>ùïè</mi>
           <mi>j</mi>
          </msub>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>SCV</ci>
     <ci>‚Ñç</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <ci>‚Ñç</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <ci>R</ci>
      <ci>K</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <apply>
        <minus></minus>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>j</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <plus></plus>
          <apply>
           <minus></minus>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>K</ci>
            <apply>
             <plus></plus>
             <apply>
              <times></times>
              <cn type="integer">2</cn>
              <ci>‚Ñç</ci>
             </apply>
             <apply>
              <times></times>
              <cn type="integer">2</cn>
              <ci>ùîæ</ci>
             </apply>
            </apply>
           </apply>
           <apply>
            <times></times>
            <cn type="integer">2</cn>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>K</ci>
             <apply>
              <plus></plus>
              <ci>‚Ñç</ci>
              <apply>
               <times></times>
               <cn type="integer">2</cn>
               <ci>ùîæ</ci>
              </apply>
             </apply>
            </apply>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>K</ci>
           <apply>
            <times></times>
            <cn type="integer">2</cn>
            <ci>ùîæ</ci>
           </apply>
          </apply>
         </apply>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ùïè</ci>
           <ci>i</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ùïè</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{SCV}(\mathbb{H})=n^{-1}|\mathbb{H}|^{-1/2}R(K)+n^{-2}\sum_{i=1}^%
{n}\sum_{j=1}^{n}(K_{2\mathbb{H}+2\mathbb{G}}-2K_{\mathbb{H}+2\mathbb{G}}+K_{2%
\mathbb{G}})(\mathbb{X}_{i}-\mathbb{X}_{j})
  </annotation>
 </semantics>
</math>

</p>

<p>Thus 

<math display="inline" id="Multivariate_kernel_density_estimation:15">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>‚Ñç</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo>SCV</mo>
   </msub>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <msub>
      <mo>argmin</mo>
      <mrow>
       <mi>‚Ñç</mi>
       <mo>‚àà</mo>
       <mi>F</mi>
      </mrow>
     </msub>
    </mpadded>
    <mrow>
     <mo>SCV</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>‚Ñç</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>‚Ñç</ci>
     </apply>
     <ci>SCV</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>argmin</ci>
      <apply>
       <in></in>
       <ci>‚Ñç</ci>
       <ci>F</ci>
      </apply>
     </apply>
     <apply>
      <ci>SCV</ci>
      <ci>‚Ñç</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbb{H}}_{\operatorname{SCV}}=\operatorname{argmin}_{\mathbb{H}\in F}%
\,\operatorname{SCV}(\mathbb{H})
  </annotation>
 </semantics>
</math>

 is the SCV selector.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> These references also contain algorithms on optimal estimation of the pilot bandwidth matrix <strong>G</strong> and establish that 

<math display="inline" id="Multivariate_kernel_density_estimation:16">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>‚Ñç</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>SCV</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>‚Ñç</ci>
    </apply>
    <ci>SCV</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbb{H}}_{\operatorname{SCV}}
  </annotation>
 </semantics>
</math>

 converges in probability to <strong>H</strong><sub>AMISE</sub>.</p>
<h3 id="rule-of-thumb">Rule of thumb</h3>

<p>Silverman's rule of thumb suggests using 

<math display="inline" id="Multivariate_kernel_density_estimation:17">
 <semantics>
  <mrow>
   <msqrt>
    <msub>
     <mi>ùêá</mi>
     <mrow>
      <mi>i</mi>
      <mi>i</mi>
     </mrow>
    </msub>
   </msqrt>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mn>4</mn>
       <mrow>
        <mi>d</mi>
        <mo>+</mo>
        <mn>2</mn>
       </mrow>
      </mfrac>
      <mo>)</mo>
     </mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mi>d</mi>
       <mo>+</mo>
       <mn>4</mn>
      </mrow>
     </mfrac>
    </msup>
    <msup>
     <mi>n</mi>
     <mfrac>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mrow>
       <mi>d</mi>
       <mo>+</mo>
       <mn>4</mn>
      </mrow>
     </mfrac>
    </msup>
    <msub>
     <mi>œÉ</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <root></root>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùêá</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <divide></divide>
       <cn type="integer">4</cn>
       <apply>
        <plus></plus>
        <ci>d</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <plus></plus>
        <ci>d</ci>
        <cn type="integer">4</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <plus></plus>
        <ci>d</ci>
        <cn type="integer">4</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>œÉ</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{\mathbf{H}_{ii}}=\left(\frac{4}{d+2}\right)^{\frac{1}{d+4}}n^{\frac{-1}{%
d+4}}\sigma_{i}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Multivariate_kernel_density_estimation:18">
 <semantics>
  <msub>
   <mi>œÉ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>œÉ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{i}
  </annotation>
 </semantics>
</math>

 is the standard deviation of the ith variable and 

<math display="inline" id="Multivariate_kernel_density_estimation:19">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ùêá</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>i</mi>
    <mo>‚â†</mo>
    <mi>j</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùêá</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <neq></neq>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{H}_{ij}=0,i\neq j
  </annotation>
 </semantics>
</math>

. Scott's rule is 

<math display="inline" id="Multivariate_kernel_density_estimation:20">
 <semantics>
  <mrow>
   <msqrt>
    <msub>
     <mi>ùêá</mi>
     <mrow>
      <mi>i</mi>
      <mi>i</mi>
     </mrow>
    </msub>
   </msqrt>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>n</mi>
     <mfrac>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mrow>
       <mi>d</mi>
       <mo>+</mo>
       <mn>4</mn>
      </mrow>
     </mfrac>
    </msup>
    <msub>
     <mi>œÉ</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <root></root>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùêá</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <plus></plus>
        <ci>d</ci>
        <cn type="integer">4</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>œÉ</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{\mathbf{H}_{ii}}=n^{\frac{-1}{d+4}}\sigma_{i}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="asymptotic-analysis">Asymptotic analysis</h2>

<p>In the optimal bandwidth selection section, we introduced the MISE. Its construction relies on the <a href="expected_value" title="wikilink">expected value</a> and the <a class="uri" href="variance" title="wikilink">variance</a> of the density estimator<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>

<math display="block" id="Multivariate_kernel_density_estimation:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>E</mo>
     <mover accent="true">
      <mi>f</mi>
      <mo stretchy="false">^</mo>
     </mover>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ùï©</mi>
     <mo>;</mo>
     <mi>‚Ñç</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>K</mi>
      <mi>‚Ñç</mi>
     </msub>
     <mo>*</mo>
     <mi>f</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ùï©</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ùï©</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <msub>
      <mi>m</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>K</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo largeop="true" symmetric="true">‚à´</mo>
      <mrow>
       <mrow>
        <mo>tr</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>‚Ñç</mi>
          <mrow>
           <msup>
            <mo>D</mo>
            <mn>2</mn>
           </msup>
           <mi>f</mi>
          </mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>ùï©</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo rspace="4.2pt" stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mi>d</mi>
        <mi>ùï©</mi>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo rspace="4.2pt">tr</mo>
       <msup>
        <mi>‚Ñç</mi>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-E</ci>
       <apply>
        <ci>normal-^</ci>
        <ci>f</ci>
       </apply>
      </apply>
      <list>
       <ci>ùï©</ci>
       <ci>‚Ñç</ci>
      </list>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <ci>‚Ñç</ci>
       </apply>
       <ci>f</ci>
      </apply>
      <ci>ùï©</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>ùï©</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>K</ci>
       <apply>
        <int></int>
        <apply>
         <apply>
          <ci>tr</ci>
          <apply>
           <times></times>
           <ci>‚Ñç</ci>
           <apply>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>normal-D</ci>
             <cn type="integer">2</cn>
            </apply>
            <ci>f</ci>
           </apply>
           <ci>ùï©</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>d</ci>
          <ci>ùï©</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>O</ci>
       <apply>
        <ci>tr</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>‚Ñç</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{E}\hat{f}(\mathbb{x};\mathbb{H})=K_{\mathbb{H}}*f(\mathbb{x})=f(%
\mathbb{x})+\frac{1}{2}m_{2}(K)\int\operatorname{tr}(\mathbb{H}\operatorname{D%
}^{2}f(\mathbb{x}))\,d\mathbb{x}+O(\operatorname{tr}\,\mathbb{H}^{2})
  </annotation>
 </semantics>
</math>

</p>

<p>where * is the <a class="uri" href="convolution" title="wikilink">convolution</a> operator between two functions, and</p>

<p>

<math display="block" id="Multivariate_kernel_density_estimation:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>Var</mo>
      <mover accent="true">
       <mi>f</mi>
       <mo stretchy="false">^</mo>
      </mover>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ùï©</mi>
      <mo>;</mo>
      <mi>‚Ñç</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>n</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <msup>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>‚Ñç</mi>
        <mo stretchy="false">|</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mn>1</mn>
         <mo>/</mo>
         <mn>2</mn>
        </mrow>
       </mrow>
      </msup>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>K</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>o</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>n</mi>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
        <msup>
         <mrow>
          <mo stretchy="false">|</mo>
          <mi>‚Ñç</mi>
          <mo stretchy="false">|</mo>
         </mrow>
         <mrow>
          <mo>-</mo>
          <mrow>
           <mn>1</mn>
           <mo>/</mo>
           <mn>2</mn>
          </mrow>
         </mrow>
        </msup>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>Var</ci>
      <apply>
       <ci>normal-^</ci>
       <ci>f</ci>
      </apply>
     </apply>
     <list>
      <ci>ùï©</ci>
      <ci>‚Ñç</ci>
     </list>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <ci>‚Ñç</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <ci>R</ci>
      <ci>K</ci>
     </apply>
     <apply>
      <times></times>
      <ci>o</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <abs></abs>
         <ci>‚Ñç</ci>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Var}\hat{f}(\mathbb{x};\mathbb{H})=n^{-1}|\mathbb{H}|^{-1/2}R(K)%
+o(n^{-1}|\mathbb{H}|^{-1/2}).
  </annotation>
 </semantics>
</math>

</p>

<p>For these two expressions to be well-defined, we require that all elements of <strong>H</strong> tend to 0 and that <em>n<sup>‚àí1</sup></em> |<strong>H</strong>|<sup>‚àí1/2</sup> tends to 0 as <em>n</em> tends to infinity. Assuming these two conditions, we see that the expected value tends to the true density <em>f</em> i.e. the kernel density estimator is asymptotically <a href="Bias_of_an_estimator" title="wikilink">unbiased</a>; and that the variance tends to zero. Using the standard mean squared value decomposition</p>

<p>

<math display="block" id="Multivariate_kernel_density_estimation:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo rspace="4.2pt">MSE</mo>
     <mover accent="true">
      <mi>f</mi>
      <mo stretchy="false">^</mo>
     </mover>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ùï©</mi>
     <mo>;</mo>
     <mi>‚Ñç</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo>Var</mo>
      <mover accent="true">
       <mi>f</mi>
       <mo stretchy="false">^</mo>
      </mover>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ùï©</mi>
      <mo>;</mo>
      <mi>‚Ñç</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <msup>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mrow>
        <mrow>
         <mo>E</mo>
         <mover accent="true">
          <mi>f</mi>
          <mo stretchy="false">^</mo>
         </mover>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>ùï©</mi>
         <mo>;</mo>
         <mi>‚Ñç</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>ùï©</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>MSE</ci>
      <apply>
       <ci>normal-^</ci>
       <ci>f</ci>
      </apply>
     </apply>
     <list>
      <ci>ùï©</ci>
      <ci>‚Ñç</ci>
     </list>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <ci>Var</ci>
       <apply>
        <ci>normal-^</ci>
        <ci>f</ci>
       </apply>
      </apply>
      <list>
       <ci>ùï©</ci>
       <ci>‚Ñç</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <ci>normal-E</ci>
          <apply>
           <ci>normal-^</ci>
           <ci>f</ci>
          </apply>
         </apply>
         <list>
          <ci>ùï©</ci>
          <ci>‚Ñç</ci>
         </list>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>ùï©</ci>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{MSE}\,\hat{f}(\mathbb{x};\mathbb{H})=\operatorname{Var}\hat{f}(%
\mathbb{x};\mathbb{H})+[\operatorname{E}\hat{f}(\mathbb{x};\mathbb{H})-f(%
\mathbb{x})]^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>we have that the MSE tends to 0, implying that the kernel density estimator is (mean square) consistent and hence converges in probability to the true density <em>f</em>. The rate of convergence of the MSE to 0 is the necessarily the same as the MISE rate noted previously <em>O(n<sup>‚àí4/(d+4)</sup>)</em>, hence the covergence rate of the density estimator to <em>f</em> is <em>O<sub>p</sub>(n<sup>‚àí2/(d+4)</sup>)</em> where <em>O<sub>p</sub></em> denotes <a href="Big_O_in_probability_notation" title="wikilink">order in probability</a>. This establishes pointwise convergence. The functional covergence is established similarly by considering the behaviour of the MISE, and noting that under sufficient regularity, integration does not affect the convergence rates.</p>

<p>For the data-based bandwidth selectors considered, the target is the AMISE bandwidth matrix. We say that a data-based selector converges to the AMISE selector at relative rate <em>O<sub>p</sub>(n<sup>‚àíŒ±</sup>), Œ± &gt; 0</em> if</p>

<p>

<math display="block" id="Multivariate_kernel_density_estimation:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>vec</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mover accent="true">
        <mi>‚Ñç</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mo>-</mo>
       <msub>
        <mi>‚Ñç</mi>
        <mo>AMISE</mo>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>n</mi>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mn>2</mn>
         <mi>Œ±</mi>
        </mrow>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>vec</mo>
      <msub>
       <mi>‚Ñç</mi>
       <mo>AMISE</mo>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>vec</ci>
     <apply>
      <minus></minus>
      <apply>
       <ci>normal-^</ci>
       <ci>‚Ñç</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>‚Ñç</ci>
       <ci>AMISE</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>Œ±</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>vec</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>‚Ñç</ci>
       <ci>AMISE</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{vec}(\hat{\mathbb{H}}-\mathbb{H}_{\operatorname{AMISE}})=O(n^{-2%
\alpha})\operatorname{vec}\mathbb{H}_{\operatorname{AMISE}}.
  </annotation>
 </semantics>
</math>

</p>

<p>It has been established that the plug-in and smoothed cross validation selectors (given a single pilot bandwidth <strong>G</strong>) both converge at a relative rate of <em>O<sub>p</sub>(n<sup>‚àí2/(d+6)</sup>)</em> <a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> i.e., both these data-based selectors are consistent estimators.</p>
<h2 id="density-estimation-in-r-with-a-full-bandwidth-matrix">Density estimation in R with a full bandwidth matrix</h2>
<figure><b>(Figure)</b>
<figcaption>Old Faithful Geyser data kernel density estimate with plug-in bandwidth matrix.</figcaption>
</figure>

<p>The <a href="http://cran.r-project.org/web/packages/ks/index.html">ks package</a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> in <a href="R_programming_language" title="wikilink">R</a> implements the plug-in and smoothed cross validation selectors (amongst others). This dataset (included in the base distribution of R) contains 272 records with two measurements each: the duration time of an eruption (minutes) and the waiting time until the next eruption (minutes) of the <a href="Old_Faithful_Geyser" title="wikilink">Old Faithful Geyser</a> in Yellowstone National Park, USA.</p>

<p>The code fragment computes the kernel density estimate with the plug-in bandwidth matrix 

<math display="inline" id="Multivariate_kernel_density_estimation:25">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>‚Ñç</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mo>PI</mo>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable>
      <mtr>
       <mtd columnalign="center">
        <mn>0.052</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0.510</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0.510</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>8.882</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>‚Ñç</ci>
     </apply>
     <ci>PI</ci>
    </apply>
    <matrix>
     <matrixrow>
      <cn type="float">0.052</cn>
      <cn type="float">0.510</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0.510</cn>
      <cn type="float">8.882</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbb{H}}_{\operatorname{PI}}=\begin{bmatrix}0.052&0.510\\
0.510&8.882\end{bmatrix}.
  </annotation>
 </semantics>
</math>

 Again, the coloured contours correspond to the smallest region which contains the respective probability mass: red = 25%, orange + red = 50%, yellow + orange + red = 75%. To compute the SCV selector, <code>Hpi</code> is replaced with <code>Hscv</code>. This is not displayed here since it is mostly similar to the plug-in estimate for this example.</p>
<pre class="rsplus"><code>library(ks)
data(faithful)
H &lt;- Hpi(x=faithful)
fhat &lt;- kde(x=faithful, H=H)
plot(fhat, display="filled.contour2")
points(faithful, cex=0.5, pch=16)</code></pre>
<h2 id="density-estimation-in-r-with-a-diagonal-bandwidth-matrix">Density estimation in R with a diagonal bandwidth matrix</h2>
<figure><b>(Figure)</b>
<figcaption>Old Faithful Geyser data kernel density estimate with diagonal bandwidth matrix.</figcaption>
</figure>

<p>This example is again based on the Old Faithful Geyser, but this time we use the <a href="http://cran.r-project.org/web/packages/np/index.html">R np package</a> that employs automatic (data-driven) bandwidth selection for a diagonal bandwidth matrix; see the <a href="http://cran.r-project.org/web/packages/np/vignettes/np.pdf">np vignette</a> for an introduction to the np package. The figure below shows the joint density estimate using a second order Gaussian kernel.</p>

<p><strong>R script for the example</strong></p>

<p>The following commands of the R programming language use the  function to deliver optimal smoothing and to create the figure given above. These commands can be entered at the command prompt by using copy and paste.</p>
<pre class="rsplus"><code> library(np)
 library(datasets)
 data(faithful)
 f &lt;- npudens(~eruptions+waiting,data=faithful)
 plot(f,view="fixed",neval=100,phi=30,main="",xtrim=-0.2)</code></pre>

<p>Computing kernel density estimates with diagonal bandwidth selectors is also available in the  library, using the  function. To produce a 3D plot similar to that from , the option  is added.</p>
<pre class="rsplus"><code> library(ks)
 data(faithful)
 H &lt;- Hpi.diag(x=faithful)
 fhat &lt;- kde(x=faithful, H=H)
 plot(fhat, display="persp")</code></pre>
<h2 id="density-estimation-in-matlab-with-a-diagonal-bandwidth-matrix">Density estimation in Matlab with a diagonal bandwidth matrix</h2>
<figure><b>(Figure)</b>
<figcaption>Kernel density estimate with diagonal bandwidth for synthetic normal mixture data.</figcaption>
</figure>

<p>We consider estimating the density of the Gaussian mixture , from 500 randomly generated points. We employ the Matlab routine for <a href="http://www.mathworks.com/matlabcentral/fileexchange/17204">2-dimensional data</a>. The routine is an automatic bandwidth selection method specifically designed for a second order Gaussian kernel.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> The figure shows the joint density estimate that results from using the automatically selected bandwidth.</p>

<p><strong>Matlab script for the example</strong></p>

<p>Type the following commands in Matlab after <a href="http://www.mathworks.com/matlabcentral/fileexchange/17204">downloading</a> and saving the function kde2d.m in the current directory.</p>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab"> clear all  
 <span class="co">% generate synthetic data</span>
data=[randn(<span class="fl">500</span>,<span class="fl">2</span>);
      randn(<span class="fl">500</span>,<span class="fl">1</span>)+<span class="fl">3.5</span>, randn(<span class="fl">500</span>,<span class="fl">1</span>);];
  <span class="co">% call the routine, which has been saved in the current directory </span>
    [bandwidth,density,X,Y]=kde2d(data);
  <span class="co">% plot the data and the density estimate</span>
    contour3(X,Y,density,<span class="fl">50</span>), hold on
    plot(data(:,<span class="fl">1</span>),data(:,<span class="fl">2</span>),<span class="st">'r.'</span>,<span class="st">'MarkerSize'</span>,<span class="fl">5</span>)</code></pre></div>
<h3 id="alternative-optimality-criteria">Alternative optimality criteria</h3>

<p>The MISE is the expected integrated <em>L<sub>2</sub></em> distance between the density estimate and the true density function <em>f</em>. It is the most widely used, mostly due to its tractability and most software implement MISE-based bandwidth selectors. There are alternative optimality criteria, which attempt to cover cases where MISE is not an appropriate measure.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> The equivalent <em>L<sub>1</sub></em> measure, Mean Integrated Absolute Error, is</p>

<p>

<math display="block" id="Multivariate_kernel_density_estimation:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>MIAE</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>‚Ñç</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo rspace="4.2pt">E</mo>
     <mrow>
      <mo largeop="true" symmetric="true">‚à´</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <mrow>
          <msub>
           <mover accent="true">
            <mi>f</mi>
            <mo stretchy="false">^</mo>
           </mover>
           <mi>‚Ñç</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>ùï©</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>-</mo>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>ùï©</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo rspace="4.2pt" stretchy="false">|</mo>
       </mrow>
       <mi>d</mi>
       <mi>ùï©</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>MIAE</ci>
     <ci>‚Ñç</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-E</ci>
     <apply>
      <int></int>
      <apply>
       <times></times>
       <apply>
        <abs></abs>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <apply>
            <ci>normal-^</ci>
            <ci>f</ci>
           </apply>
           <ci>‚Ñç</ci>
          </apply>
          <ci>ùï©</ci>
         </apply>
         <apply>
          <times></times>
          <ci>f</ci>
          <ci>ùï©</ci>
         </apply>
        </apply>
       </apply>
       <ci>d</ci>
       <ci>ùï©</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{MIAE}(\mathbb{H})=\operatorname{E}\,\int|\hat{f}_{\mathbb{H}}(%
\mathbb{x})-f(\mathbb{x})|\,d\mathbb{x}.
  </annotation>
 </semantics>
</math>

</p>

<p>Its mathematical analysis is considerably more difficult than the MISE ones. In practise, the gain appears not to be significant.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> The <em>L<sub>‚àû</sub></em> norm is the Mean Uniform Absolute Error</p>

<p>

<math display="block" id="Multivariate_kernel_density_estimation:27">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>MUAE</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>‚Ñç</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo rspace="4.2pt">E</mo>
      <msub>
       <mo>sup</mo>
       <mi>ùï©</mi>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mrow>
        <msub>
         <mover accent="true">
          <mi>f</mi>
          <mo stretchy="false">^</mo>
         </mover>
         <mi>‚Ñç</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>ùï©</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>ùï©</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>MUAE</ci>
     <ci>‚Ñç</ci>
    </apply>
    <apply>
     <apply>
      <ci>normal-E</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>sup</ci>
       <ci>ùï©</ci>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-^</ci>
          <ci>f</ci>
         </apply>
         <ci>‚Ñç</ci>
        </apply>
        <ci>ùï©</ci>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>ùï©</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{MUAE}(\mathbb{H})=\operatorname{E}\,\operatorname{sup}_{\mathbb{%
x}}|\hat{f}_{\mathbb{H}}(\mathbb{x})-f(\mathbb{x})|.
  </annotation>
 </semantics>
</math>

</p>

<p>which has been investigated only briefly.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> Likelihood error criteria include those based on the Mean <a href="Kullback-Leibler_distance" title="wikilink">Kullback-Leibler distance</a></p>

<p>

<math display="block" id="Multivariate_kernel_density_estimation:28">
 <semantics>
  <mrow>
   <mrow>
    <mo>MKL</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>‚Ñç</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo largeop="true" symmetric="true">‚à´</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ùï©</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mrow>
        <mo>log</mo>
        <mrow>
         <mo stretchy="false">[</mo>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>ùï©</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo rspace="4.2pt" stretchy="false">]</mo>
        </mrow>
       </mrow>
       <mrow>
        <mi>d</mi>
        <mi>ùï©</mi>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mo>E</mo>
     <mrow>
      <mo largeop="true" symmetric="true">‚à´</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ùï©</mi>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mrow>
         <mo>log</mo>
         <mrow>
          <mo stretchy="false">[</mo>
          <mrow>
           <mover accent="true">
            <mi>f</mi>
            <mo stretchy="false">^</mo>
           </mover>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>ùï©</mi>
            <mo>;</mo>
            <mi>‚Ñç</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo rspace="4.2pt" stretchy="false">]</mo>
         </mrow>
        </mrow>
        <mrow>
         <mi>d</mi>
         <mi>ùï©</mi>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>MKL</ci>
     <ci>‚Ñç</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <int></int>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>ùï©</ci>
       <apply>
        <apply>
         <ci>log</ci>
         <apply>
          <times></times>
          <ci>f</ci>
          <ci>ùï©</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>d</ci>
         <ci>ùï©</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>normal-E</ci>
      <apply>
       <int></int>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>ùï©</ci>
        <apply>
         <apply>
          <ci>log</ci>
          <apply>
           <times></times>
           <apply>
            <ci>normal-^</ci>
            <ci>f</ci>
           </apply>
           <list>
            <ci>ùï©</ci>
            <ci>‚Ñç</ci>
           </list>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>d</ci>
          <ci>ùï©</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{MKL}(\mathbb{H})=\int f(\mathbb{x})\,\operatorname{log}[f(%
\mathbb{x})]\,d\mathbb{x}-\operatorname{E}\int f(\mathbb{x})\,\operatorname{%
log}[\hat{f}(\mathbb{x};\mathbb{H})]\,d\mathbb{x}
  </annotation>
 </semantics>
</math>

</p>

<p>and the Mean <a href="Hellinger_distance" title="wikilink">Hellinger distance</a></p>

<p>

<math display="block" id="Multivariate_kernel_density_estimation:29">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>MH</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>‚Ñç</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>E</mo>
     <mrow>
      <mo largeop="true" symmetric="true">‚à´</mo>
      <mrow>
       <mpadded width="+1.7pt">
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mrow>
            <msub>
             <mover accent="true">
              <mi>f</mi>
              <mo stretchy="false">^</mo>
             </mover>
             <mi>‚Ñç</mi>
            </msub>
            <msup>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>ùï©</mi>
              <mo stretchy="false">)</mo>
             </mrow>
             <mrow>
              <mn>1</mn>
              <mo>/</mo>
              <mn>2</mn>
             </mrow>
            </msup>
           </mrow>
           <mo>-</mo>
           <mrow>
            <mi>f</mi>
            <msup>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>ùï©</mi>
              <mo stretchy="false">)</mo>
             </mrow>
             <mrow>
              <mn>1</mn>
              <mo>/</mo>
              <mn>2</mn>
             </mrow>
            </msup>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mpadded>
       <mi>d</mi>
       <mi>ùï©</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>MH</ci>
     <ci>‚Ñç</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-E</ci>
     <apply>
      <int></int>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <apply>
            <ci>normal-^</ci>
            <ci>f</ci>
           </apply>
           <ci>‚Ñç</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>ùï©</ci>
           <apply>
            <divide></divide>
            <cn type="integer">1</cn>
            <cn type="integer">2</cn>
           </apply>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>f</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>ùï©</ci>
           <apply>
            <divide></divide>
            <cn type="integer">1</cn>
            <cn type="integer">2</cn>
           </apply>
          </apply>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>d</ci>
       <ci>ùï©</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{MH}(\mathbb{H})=\operatorname{E}\int(\hat{f}_{\mathbb{H}}(%
\mathbb{x})^{1/2}-f(\mathbb{x})^{1/2})^{2}\,d\mathbb{x}.
  </annotation>
 </semantics>
</math>

</p>

<p>The KL can be estimated using a cross-validation method, although KL cross-validation selectors can be sub-optimal even if it remains <a href="Consistent_estimator" title="wikilink">consistent</a> for bounded density functions.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> MH selectors have been briefly examined in the literature.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>

<p>All these optimality criteria are distance based measures, and do not always correspond to more intuitive notions of closeness, so more visual criteria have been developed in response to this concern.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Kernel_density_estimation" title="wikilink">Kernel density estimation</a>¬†‚Äì univariate kernel density estimation.</li>
<li><a href="Variable_kernel_density_estimation" title="wikilink">Variable kernel density estimation</a>¬†‚Äì estimation of multivariate densities using the kernel with variable bandwidth</li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.mvstat.net/tduong/research">mvstat.net</a> A collection of peer-reviewed articles of the mathematical details of multivariate kernel density estimation and their bandwidth selectors on an  web page.</li>
<li><a href="http://libagf.sf.net">libagf</a> A <a class="uri" href="C++" title="wikilink">C++</a> library for multivariate, <a href="variable_bandwidth_kernel_density_estimation" title="wikilink">variable bandwidth kernel density estimation</a>.</li>
</ul>

<p>"</p>

<p><a href="Category:Estimation_of_densities" title="wikilink">Category:Estimation of densities</a> <a href="Category:Non-parametric_statistics" title="wikilink">Category:Non-parametric statistics</a> <a href="Category:Computational_statistics" title="wikilink">Category:Computational statistics</a> <a href="Category:Multivariate_statistics" title="wikilink">Category:Multivariate statistics</a> <a href="Category:Articles_with_example_MATLAB/Octave_code" title="wikilink">Category:Articles with example MATLAB/Octave code</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">‚Ü©</a></li>
<li id="fn2"><a href="#fnref2">‚Ü©</a></li>
<li id="fn3"><a href="#fnref3">‚Ü©</a></li>
<li id="fn4"><a href="#fnref4">‚Ü©</a></li>
<li id="fn5"><a href="#fnref5">‚Ü©</a></li>
<li id="fn6"><a href="#fnref6">‚Ü©</a></li>
<li id="fn7"><a href="#fnref7">‚Ü©</a></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"><a href="#fnref10">‚Ü©</a></li>
<li id="fn11"></li>
<li id="fn12"><a href="#fnref12">‚Ü©</a></li>
<li id="fn13"><a href="#fnref13">‚Ü©</a></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"><a href="#fnref16">‚Ü©</a></li>
<li id="fn17"><a href="#fnref17">‚Ü©</a></li>
<li id="fn18"><a href="#fnref18">‚Ü©</a></li>
<li id="fn19"></li>
<li id="fn20"><mtpl></mtpl><a href="#fnref20">‚Ü©</a></li>
<li id="fn21"><a href="#fnref21">‚Ü©</a></li>
<li id="fn22"><a href="#fnref22">‚Ü©</a></li>
<li id="fn23"><a href="#fnref23">‚Ü©</a></li>
<li id="fn24"><a href="#fnref24">‚Ü©</a></li>
</ol>
</section>
</body>

