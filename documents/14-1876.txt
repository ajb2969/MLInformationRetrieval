   Tseitin transformation      Tseitin transformation   The Tseitin transformation takes as input an arbitrary combinatorial logic circuit and produces a boolean formula in conjunctive normal form (CNF) , which can be solved by a CNF-SAT solver. The length of the formula is linear in the size of the circuit. Input vectors that make the circuit output "true" are in 1-to-1 correspondence with assignments that satisfy the formula. This reduces the problem of circuit satisfiability on any circuit (including any formula) to the satisfiability problem on 3-CNF formulas.  Motivation  The naive approach is to write the circuit as a Boolean expression, and use De Morgan's law and the distributive property to convert it to CNF. However, this can result in an exponential increase in equation size. The Tseitin transformation outputs a formula whose size has grown linearly relative to the input circuit's.  Approach  The output equation is the constant 1 set equal to an expression. This expression is a conjunction of sub-expressions, where the satisfaction of each sub-expression enforces the proper operation of a single gate in the input circuit. The satisfaction of the entire output expression thus enforces that the entire input circuit is operating properly.  For each gate, a new variable representing its output is introduced. A small pre-calculated CNF expression that relates the inputs and outputs is appended (via the "and" operation) to the output expression. Note that inputs to these gates can be either the original literals or the introduced variables representing outputs of sub-gates.  Though the output expression contains more variables than the input, it remains equisatisfiable , meaning that it is satisfiable if, and only if, the original input equation is satisfiable. When a satisfying assignment of variables is found, those assignments for the introduced variables can simply be discarded.  A final clause is appended with a single literal: the final gate's output variable. If this literal is complemented, then the satisfaction of this clause enforces the output expression's to false; otherwise the expression is forced true.  Gate Sub-expressions  Listed is some of the possible sub-expressions that can be created for various logic gates.      Type   Operation   CNF Sub-expression        AND       C  =   A  ⋅  B       C   normal-⋅  A  B     C=A\cdot B           (    A  ¯   ∨   B  ¯   ∨  C   )   ∧   (   A  ∨   C  ¯    )   ∧   (   B  ∨   C  ¯    )          normal-¯  A    normal-¯  B   C     A   normal-¯  C      B   normal-¯  C      (\overline{A}\vee\overline{B}\vee C)\wedge(A\vee\overline{C})\wedge(B\vee%
 \overline{C})          NAND       C  =    A  ⋅  B   ¯       C   normal-¯   normal-⋅  A  B      C=\overline{A\cdot B}           (    A  ¯   ∨   B  ¯   ∨   C  ¯    )   ∧   (   A  ∨  C   )   ∧   (   B  ∨  C   )          normal-¯  A    normal-¯  B    normal-¯  C      A  C     B  C     (\overline{A}\vee\overline{B}\vee\overline{C})\wedge(A\vee C)\wedge(B\vee C)          OR       C  =   A  +  B       C    A  B     C=A+B           (   A  ∨  B  ∨   C  ¯    )   ∧   (    A  ¯   ∨  C   )   ∧   (    B  ¯   ∨  C   )         A  B   normal-¯  C       normal-¯  A   C      normal-¯  B   C     (A\vee B\vee\overline{C})\wedge(\overline{A}\vee C)\wedge(\overline{B}\vee C)          NOR       C  =    A  +  B   ¯       C   normal-¯    A  B      C=\overline{A+B}           (   A  ∨  B  ∨  C   )   ∧   (    A  ¯   ∨   C  ¯    )   ∧   (    B  ¯   ∨   C  ¯    )         A  B  C      normal-¯  A    normal-¯  C       normal-¯  B    normal-¯  C      (A\vee B\vee C)\wedge(\overline{A}\vee\overline{C})\wedge(\overline{B}\vee%
 \overline{C})          NOT       C  =   A  ¯       C   normal-¯  A     C=\overline{A}           (    A  ¯   ∨   C  ¯    )   ∧   (   A  ∨  C   )          normal-¯  A    normal-¯  C      A  C     (\overline{A}\vee\overline{C})\wedge(A\vee C)          XOR       C  =   A  ⊕  B       C   direct-sum  A  B     C=A\oplus B           (    A  ¯   ∨   B  ¯   ∨   C  ¯    )   ∧   (   A  ∨  B  ∨   C  ¯    )   ∧   (   A  ∨   B  ¯   ∨  C   )   ∧   (    A  ¯   ∨  B  ∨  C   )          normal-¯  A    normal-¯  B    normal-¯  C      A  B   normal-¯  C      A   normal-¯  B   C      normal-¯  A   B  C     (\overline{A}\vee\overline{B}\vee\overline{C})\wedge(A\vee B\vee\overline{C})%
 \wedge(A\vee\overline{B}\vee C)\wedge(\overline{A}\vee B\vee C)           Examples  Simple combinatorial logic  The following circuit returns true when at least some of its inputs are true, but not more than two at a time. It implements the equation    y  =       x  1   ¯   ⋅  x   2   +    x  1   ⋅    x  2   ¯    +      x  2   ¯   ⋅  x   3        y       normal-⋅   normal-¯    x  1    x   2    normal-⋅    x  1    normal-¯    x  2        normal-⋅   normal-¯    x  2    x   3      y=\overline{x1}\cdot x2+x1\cdot\overline{x2}+\overline{x2}\cdot x3   . A variable is introduced for each gates' output; here each is marked in red:   Notice that the output of the inverter with    x  2     subscript  x  2    x_{2}   as an input has two variables introduced. While this is redundant, it does not affect the equisatisfiability of the resulting equation. Now substitute each gate with its appropriate CNF sub-expression: {| !gate ! CNF sub-expression |- |    g  a  t  e  1      g  a  t  e  1    gate1   |     (    g  a  t  e  1   ∨   x  1    )   ∧   (     g  a  t  e  1   ¯   ∨    x  1   ¯    )           g  a  t  e  1     x  1       normal-¯    g  a  t  e  1     normal-¯    x  1       (gate1\vee x1)\wedge(\overline{gate1}\vee\overline{x1})   |- |    g  a  t  e  2      g  a  t  e  2    gate2   |     (     g  a  t  e  2   ¯   ∨   g  a  t  e  1    )   ∧   (     g  a  t  e  2   ¯   ∨   x  2    )   ∧   (     x  2   ¯   ∨   g  a  t  e  2   ∨    g  a  t  e  1   ¯    )          normal-¯    g  a  t  e  2      g  a  t  e  1       normal-¯    g  a  t  e  2      x  2       normal-¯    x  2      g  a  t  e  2    normal-¯    g  a  t  e  1       (\overline{gate2}\vee gate1)\wedge(\overline{gate2}\vee x2)\wedge(\overline{x2%
 }\vee gate2\vee\overline{gate1})   |- |    g  a  t  e  3      g  a  t  e  3    gate3   |     (    g  a  t  e  3   ∨   x  2    )   ∧   (     g  a  t  e  3   ¯   ∨    x  2   ¯    )           g  a  t  e  3     x  2       normal-¯    g  a  t  e  3     normal-¯    x  2       (gate3\vee x2)\wedge(\overline{gate3}\vee\overline{x2})   |- |    g  a  t  e  4      g  a  t  e  4    gate4   |     (     g  a  t  e  4   ¯   ∨   x  1    )   ∧   (     g  a  t  e  4   ¯   ∨   g  a  t  e  3    )   ∧   (     g  a  t  e  3   ¯   ∨   g  a  t  e  4   ∨    x  1   ¯    )          normal-¯    g  a  t  e  4      x  1       normal-¯    g  a  t  e  4      g  a  t  e  3       normal-¯    g  a  t  e  3      g  a  t  e  4    normal-¯    x  1       (\overline{gate4}\vee x1)\wedge(\overline{gate4}\vee gate3)\wedge(\overline{%
 gate3}\vee gate4\vee\overline{x1})   |- |    g  a  t  e  5      g  a  t  e  5    gate5   |     (    g  a  t  e  5   ∨   x  2    )   ∧   (     g  a  t  e  5   ¯   ∨    x  2   ¯    )           g  a  t  e  5     x  2       normal-¯    g  a  t  e  5     normal-¯    x  2       (gate5\vee x2)\wedge(\overline{gate5}\vee\overline{x2})   |- |    g  a  t  e  6      g  a  t  e  6    gate6   |     (     g  a  t  e  6   ¯   ∨   g  a  t  e  5    )   ∧   (     g  a  t  e  6   ¯   ∨   x  3    )   ∧   (     x  3   ¯   ∨   g  a  t  e  6   ∨    g  a  t  e  5   ¯    )          normal-¯    g  a  t  e  6      g  a  t  e  5       normal-¯    g  a  t  e  6      x  3       normal-¯    x  3      g  a  t  e  6    normal-¯    g  a  t  e  5       (\overline{gate6}\vee gate5)\wedge(\overline{gate6}\vee x3)\wedge(\overline{x3%
 }\vee gate6\vee\overline{gate5})   |- |    g  a  t  e  7      g  a  t  e  7    gate7   |     (    g  a  t  e  7   ∨    g  a  t  e  2   ¯    )   ∧   (    g  a  t  e  7   ∨    g  a  t  e  4   ¯    )   ∧   (    g  a  t  e  2   ∨    g  a  t  e  7   ¯   ∨   g  a  t  e  4    )           g  a  t  e  7    normal-¯    g  a  t  e  2         g  a  t  e  7    normal-¯    g  a  t  e  4         g  a  t  e  2    normal-¯    g  a  t  e  7      g  a  t  e  4      (gate7\vee\overline{gate2})\wedge(gate7\vee\overline{gate4})\wedge(gate2\vee%
 \overline{gate7}\vee gate4)   |- |    g  a  t  e  8      g  a  t  e  8    gate8   |     (    g  a  t  e  8   ∨    g  a  t  e  6   ¯    )   ∧   (    g  a  t  e  8   ∨    g  a  t  e  7   ¯    )   ∧   (    g  a  t  e  6   ∨    g  a  t  e  8   ¯   ∨   g  a  t  e  7    )           g  a  t  e  8    normal-¯    g  a  t  e  6         g  a  t  e  8    normal-¯    g  a  t  e  7         g  a  t  e  6    normal-¯    g  a  t  e  8      g  a  t  e  7      (gate8\vee\overline{gate6})\wedge(gate8\vee\overline{gate7})\wedge(gate6\vee%
 \overline{gate8}\vee gate7)   |}  The final output variable is    g  a  t  e  8      g  a  t  e  8    gate8   so to enforce that the output of this circuit be true, one final simple clause is appended:    (   g  a  t  e  8   )      g  a  t  e  8    (gate8)   . Combining these equations results in the final instance of SAT: {| |     (    g  a  t  e  1   ∨   x  1    )   ∧   (     g  a  t  e  1   ¯   ∨    x  1   ¯    )   ∧   (     g  a  t  e  2   ¯   ∨   g  a  t  e  1    )   ∧    (     g  a  t  e  2   ¯   ∨   x  2    )   ∧           g  a  t  e  1     x  1       normal-¯    g  a  t  e  1     normal-¯    x  1        normal-¯    g  a  t  e  2      g  a  t  e  1     limit-from     normal-¯    g  a  t  e  2      x  2        (gate1\vee x1)\wedge(\overline{gate1}\vee\overline{x1})\wedge(\overline{gate2}%
 \vee gate1)\wedge(\overline{gate2}\vee x2)\wedge         (     x  2   ¯   ∨   g  a  t  e  2   ∨    g  a  t  e  1   ¯    )   ∧   (    g  a  t  e  3   ∨   x  2    )   ∧   (     g  a  t  e  3   ¯   ∨    x  2   ¯    )   ∧    (     g  a  t  e  4   ¯   ∨   x  1    )   ∧          normal-¯    x  2      g  a  t  e  2    normal-¯    g  a  t  e  1         g  a  t  e  3     x  2       normal-¯    g  a  t  e  3     normal-¯    x  2      limit-from     normal-¯    g  a  t  e  4      x  1        (\overline{x2}\vee gate2\vee\overline{gate1})\wedge(gate3\vee x2)\wedge(%
 \overline{gate3}\vee\overline{x2})\wedge(\overline{gate4}\vee x1)\wedge         (     g  a  t  e  4   ¯   ∨   g  a  t  e  3    )   ∧   (     g  a  t  e  3   ¯   ∨   g  a  t  e  4   ∨    x  1   ¯    )   ∧    (    g  a  t  e  5   ∨   x  2    )   ∧          normal-¯    g  a  t  e  4      g  a  t  e  3       normal-¯    g  a  t  e  3      g  a  t  e  4    normal-¯    x  1      limit-from      g  a  t  e  5     x  2        (\overline{gate4}\vee gate3)\wedge(\overline{gate3}\vee gate4\vee\overline{x1}%
 )\wedge(gate5\vee x2)\wedge         (     g  a  t  e  5   ¯   ∨    x  2   ¯    )   ∧   (     g  a  t  e  6   ¯   ∨   g  a  t  e  5    )   ∧    (     g  a  t  e  6   ¯   ∨   x  3    )   ∧          normal-¯    g  a  t  e  5     normal-¯    x  2        normal-¯    g  a  t  e  6      g  a  t  e  5     limit-from     normal-¯    g  a  t  e  6      x  3        (\overline{gate5}\vee\overline{x2})\wedge(\overline{gate6}\vee gate5)\wedge(%
 \overline{gate6}\vee x3)\wedge         (     x  3   ¯   ∨   g  a  t  e  6   ∨    g  a  t  e  5   ¯    )   ∧   (    g  a  t  e  7   ∨    g  a  t  e  2   ¯    )   ∧    (    g  a  t  e  7   ∨    g  a  t  e  4   ¯    )   ∧          normal-¯    x  3      g  a  t  e  6    normal-¯    g  a  t  e  5         g  a  t  e  7    normal-¯    g  a  t  e  2      limit-from      g  a  t  e  7    normal-¯    g  a  t  e  4         (\overline{x3}\vee gate6\vee\overline{gate5})\wedge(gate7\vee\overline{gate2})%
 \wedge(gate7\vee\overline{gate4})\wedge         (    g  a  t  e  2   ∨    g  a  t  e  7   ¯   ∨   g  a  t  e  4    )   ∧   (    g  a  t  e  8   ∨    g  a  t  e  6   ¯    )   ∧    (    g  a  t  e  8   ∨    g  a  t  e  7   ¯    )   ∧           g  a  t  e  2    normal-¯    g  a  t  e  7      g  a  t  e  4        g  a  t  e  8    normal-¯    g  a  t  e  6      limit-from      g  a  t  e  8    normal-¯    g  a  t  e  7         (gate2\vee\overline{gate7}\vee gate4)\wedge(gate8\vee\overline{gate6})\wedge(%
 gate8\vee\overline{gate7})\wedge          (    g  a  t  e  6   ∨    g  a  t  e  8   ¯   ∨   g  a  t  e  7    )   ∧   (   g  a  t  e  8   )    =  1            g  a  t  e  6    normal-¯    g  a  t  e  8      g  a  t  e  7      g  a  t  e  8    1    (gate6\vee\overline{gate8}\vee gate7)\wedge(gate8)=1   |}  One possible satisfying assignment of these variables is:      variable   value       gate2   0     gate3   1     gate1   1     gate6   1     gate7   0     gate4   0     gate5   1     gate8   1     x2   0     x3   1     x1   0     The values of the introduced values are usually discarded, but they can be used to trace the logic path in the original circuit. Here,     (   x  1   ,   x  2   ,   x  3   )   =   (  0  ,  0  ,  1  )          x  1     x  2     x  3     0  0  1     (x1,x2,x3)=(0,0,1)   indeed meets the criteria for the original circuit to output true. To find a different answer, the clause    (    x  1   ∨   x  2   ∨    x  3   ¯    )        x  1     x  2    normal-¯    x  3      (x1\vee x2\vee\overline{x3})   can be appended and the SAT solver executed again.  Derivation  Presented is one possible derivation of the CNF sub-expression for some chosen gates:  OR Gate  The OR gate is operating properly when the following conditions hold:   if the output C is true, then one (or both) of its inputs A, B is true  if the output C is false, then both its inputs A, B are false   express these conditions as an expression that must be satisfied:      (  C  →   (  A  ∨  B  )   )   ∧   (   C  ¯   →   (   A  ¯   ∧   B  ¯   )   )      fragments   fragments  normal-(  C  normal-→   fragments  normal-(  A   B  normal-)   normal-)     fragments  normal-(   normal-¯  C   normal-→   fragments  normal-(   normal-¯  A     normal-¯  B   normal-)   normal-)     (C\rightarrow(A\vee B))\wedge(\overline{C}\rightarrow(\overline{A}\wedge%
 \overline{B}))    convert the implications to AND's and OR's      (    C  ¯   ∨   (   A  ∨  B   )    )   ∧   (   C  ∨   (    A  ¯   ∧   B  ¯    )    )          normal-¯  C     A  B      C     normal-¯  A    normal-¯  B       (\overline{C}\vee(A\vee B))\wedge(C\vee(\overline{A}\wedge\overline{B}))    it's nearly CNF already; distribute the rightmost clause twice      (    C  ¯   ∨  A  ∨  B   )   ∧   (    (   C  ∨   A  ¯    )   ∧   (   C  ∨   B  ¯    )    )          normal-¯  C   A  B       C   normal-¯  A      C   normal-¯  B       (\overline{C}\vee A\vee B)\wedge((C\vee\overline{A})\wedge(C\vee\overline{B}))    associativity of conjunction      (    C  ¯   ∨  A  ∨  B   )   ∧   (   C  ∨   A  ¯    )   ∧   (   C  ∨   B  ¯    )          normal-¯  C   A  B     C   normal-¯  A      C   normal-¯  B      (\overline{C}\vee A\vee B)\wedge(C\vee\overline{A})\wedge(C\vee\overline{B})     NOT Gate  The NOT gate is operating properly when its input and output oppose each other. That is:   if the output C is true, the input A is false  if the output C is false, the input A is true   express these conditions as an expression that must be satisfied:      (  C  →   A  ¯   )   ∧   (   C  ¯   →  A  )      fragments   fragments  normal-(  C  normal-→   normal-¯  A   normal-)     fragments  normal-(   normal-¯  C   normal-→  A  normal-)     (C\rightarrow\overline{A})\wedge(\overline{C}\rightarrow A)         (    C  ¯   ∨   A  ¯    )   ∧   (   C  ∨  A   )          normal-¯  C    normal-¯  A      C  A     (\overline{C}\vee\overline{A})\wedge(C\vee A)     NOR Gate  The NOR gate is operating properly when the following conditions hold:   if the output C is true, then neither A or B are true  if the output C is false, then at least one of A and B were true   express these conditions as an expression that must be satisfied:      (  C  →    (   A  ∨  B   )   ¯   )   ∧   (   C  ¯   →   (  A  ∨  B  )   )      fragments   fragments  normal-(  C  normal-→   normal-¯    A  B    normal-)     fragments  normal-(   normal-¯  C   normal-→   fragments  normal-(  A   B  normal-)   normal-)     (C\rightarrow\overline{(A\vee B)})\wedge(\overline{C}\rightarrow(A\vee B))           (    C  ¯   ∨   (    A  ¯   ∧   B  ¯    )    )   ¯   ¯   ∧   (  C  ∨  A  ∨  B  )   )     fragments   normal-¯   normal-¯     normal-¯  C      normal-¯  A    normal-¯  B         fragments  normal-(  C   A   B  normal-)   normal-)    \overline{\overline{(\overline{C}\vee(\overline{A}\wedge\overline{B}))}}\wedge%
 (C\vee A\vee B))          (   C  ∧   (   A  ∨  B   )    )   ¯   ∧   (  C  ∨  A  ∨  B  )   )     fragments   normal-¯    C    A  B       fragments  normal-(  C   A   B  normal-)   normal-)    \overline{(C\wedge(A\vee B))}\wedge(C\vee A\vee B))           (   A  ∧  C   )   ∨   (   A  ∨  B   )    ¯   ∧   (  C  ∨  A  ∨  B  )   )     fragments   normal-¯      A  C     A  B       fragments  normal-(  C   A   B  normal-)   normal-)    \overline{(A\wedge C)\vee(A\vee B)}\wedge(C\vee A\vee B))         (   A  ¯   ∨   C  ¯   )   ∧   (   A  ¯   ∧   B  ¯   )   ∧   (  C  ∨  A  ∨  B  )   )     fragments   fragments  normal-(   normal-¯  A     normal-¯  C   normal-)     fragments  normal-(   normal-¯  A     normal-¯  B   normal-)     fragments  normal-(  C   A   B  normal-)   normal-)    (\overline{A}\vee\overline{C})\wedge(\overline{A}\wedge\overline{B})\wedge(C%
 \vee A\vee B))     References   G.S. Tseitin: On the complexity of derivation in propositional calculus. In: Slisenko, A.O. (ed.) Studies in Constructive Mathematics and Mathematical Logic, Part II, Seminars in Mathematics, pp. 115–125. Steklov Mathematical Institute (1970). Translated from Russian: Zapiski Nauchnykh Seminarov LOMI 8 (1968), pp. 234–259.   "  Category:Logic gates  Category:Logic in computer science   