<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1670">Minimalist grammar</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Minimalist grammar</h1>
<hr/>

<p>Minimalist grammars are a class of formal grammars that aim to provide a more rigorous, usually proof-theoretic, formalization of Chomskyan <a href="Minimalist_program" title="wikilink">Minimalist program</a> than is normally provided in the mainstream Minimalist literature. A variety of particular formalizations exist, often developed by Edward Stabler, Alain Lecomte, Christian Retoré, or combinations thereof.</p>
<h2 id="lecomte-and-retorés-extensions-of-the-lambek-calculus">Lecomte and Retoré's extensions of the Lambek Calculus</h2>

<p>Lecomte and Retoré (2001) <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> introduces a formalism that modifies that core of the Lambek Calculus to allow for movement-like processes to be described without resort to the combinatorics of <a href="Combinatory_categorial_grammar" title="wikilink">Combinatory categorial grammar</a>. The formalism is presented in proof-theoretic terms. Differing only slightly in notation from Lecomte and Retoré (2001), we can define a minimalist grammar as a 3-tuple 

<math display="inline" id="Minimalist_grammar:0">
<semantics>
<mrow>
<mi>G</mi>
<mo>=</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>C</mi>
<mo>,</mo>
<mi>F</mi>
<mo>,</mo>
<mi>L</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>G</ci>
<vector>
<ci>C</ci>
<ci>F</ci>
<ci>L</ci>
</vector>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   G=(C,F,L)
  </annotation>
</semantics>
</math>

, where <em>C</em> is a set of "categorial" features, <em>F</em> is a set of "functional" features (which come in two flavors, "weak", denoted simply <em>f</em>, and "strong", denoted <em>f*</em>), and L is a set of lexical atoms, denoted as pairs 

<math display="inline" id="Minimalist_grammar:1">
<semantics>
<mrow>
<mi>w</mi>
<mo>:</mo>
<mi>t</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<ci>w</ci>
<ci>t</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   w:t
  </annotation>
</semantics>
</math>

, where <em>w</em> is some phonological/orthographic content, and <em>t</em> is a syntactic type defined recursively as follows:</p>
<dl>
<dd>all features in <em>C</em> and <em>F</em> are (atomic) types, and
</dd>
</dl>
<dl>
<dd>if <em>X</em> and <em>Y</em> are types, so are <em>X/Y</em>, <em>X\Y</em>, and 

<math display="inline" id="Minimalist_grammar:2">
<semantics>
<mrow>
<mi>X</mi>
<mo>∘</mo>
<mi>Y</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<compose></compose>
<ci>X</ci>
<ci>Y</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   X\circ Y
  </annotation>
</semantics>
</math>

.
</dd>
</dl>

<p>We can now define 6 inferences rules:</p>

<p>
<math display="block" id="Minimalist_grammar:3">
<semantics>
<mrow>
<mo>⊢</mo>
<mi>w</mi>
<mo>:</mo>
<mi>X</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="latexml">proves</csymbol>
<csymbol cd="unknown">w</csymbol>
<ci>normal-:</ci>
<csymbol cd="unknown">X</csymbol>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \vdash w:X
  </annotation>
</semantics>
</math>

, for all 

<math display="inline" id="Minimalist_grammar:4">
<semantics>
<mrow>
<mi>w</mi>
<mo>:</mo>
<mrow>
<mi>X</mi>
<mo>∈</mo>
<mi>L</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<ci>w</ci>
<apply>
<in></in>
<ci>X</ci>
<ci>L</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   w:X\in L
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Minimalist_grammar:5">
<semantics>
<mrow>
<mi>w</mi>
<mo>:</mo>
<mi>X</mi>
<mo>⊢</mo>
<mi>w</mi>
<mo>:</mo>
<mi>X</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<ci>normal-:</ci>
<ci>w</ci>
<ci>X</ci>
</apply>
<apply>
<csymbol cd="latexml">proves</csymbol>
<share href="#.cmml">
</share>
<ci>w</ci>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<ci>X</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   w:X\vdash w:X
  </annotation>
</semantics>
</math>

, for all 

<math display="inline" id="Minimalist_grammar:6">
<semantics>
<mrow>
<mi>w</mi>
<mo>:</mo>
<mrow>
<mi>X</mi>
<mo>∉</mo>
<mi>L</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<ci>w</ci>
<apply>
<notin></notin>
<ci>X</ci>
<ci>L</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   w:X\notin L
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Minimalist_grammar:7">
<semantics>
<mrow>
<mfrac>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mo>⊢</mo>
<mi>a</mi>
<mo>:</mo>
<mrow>
<mrow>
<mi>X</mi>
<mo>/</mo>
<mi>Y</mi>
</mrow>
<msup>
<mi mathvariant="normal">Γ</mi>
<mo>′</mo>
</msup>
</mrow>
<mo>⊢</mo>
<mi>b</mi>
<mo>:</mo>
<mi>Y</mi>
</mrow>
<mrow>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mo>;</mo>
<msup>
<mi mathvariant="normal">Γ</mi>
<mo>′</mo>
</msup>
</mrow>
<mo>⊢</mo>
<mrow>
<mi>a</mi>
<mi>b</mi>
</mrow>
<mo>:</mo>
<mi>X</mi>
</mrow>
</mfrac>
<mrow>
<mo stretchy="false">[</mo>
<mo>/</mo>
<mi>E</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<divide></divide>
<apply>
<and></and>
<apply>
<csymbol cd="latexml">proves</csymbol>
<ci>normal-Γ</ci>
<ci>a</ci>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<list>
<apply>
<divide></divide>
<ci>X</ci>
<ci>Y</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>normal-Γ</ci>
<ci>normal-′</ci>
</apply>
</list>
</apply>
<apply>
<csymbol cd="latexml">proves</csymbol>
<share href="#.cmml">
</share>
<ci>b</ci>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<ci>Y</ci>
</apply>
</apply>
<apply>
<and></and>
<apply>
<csymbol cd="latexml">proves</csymbol>
<list>
<ci>normal-Γ</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>normal-Γ</ci>
<ci>normal-′</ci>
</apply>
</list>
<apply>
<times></times>
<ci>a</ci>
<ci>b</ci>
</apply>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<ci>X</ci>
</apply>
</apply>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-[</ci>
<divide></divide>
<csymbol cd="unknown">E</csymbol>
<ci>normal-]</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \frac{\Gamma\vdash a:X/Y\qquad\Gamma^{\prime}\vdash b:Y}{\Gamma;\Gamma^{\prime%
}\vdash ab:X}[/E]
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Minimalist_grammar:8">
<semantics>
<mrow>
<mfrac>
<mrow>
<msup>
<mi mathvariant="normal">Γ</mi>
<mo>′</mo>
</msup>
<mo>⊢</mo>
<mi>b</mi>
<mo>:</mo>
<mrow>
<mi>Y</mi>
<mi mathvariant="normal">Γ</mi>
</mrow>
<mo>⊢</mo>
<mi>a</mi>
<mo>:</mo>
<mrow>
<mi>X</mi>
<mo>\</mo>
<mi>Y</mi>
</mrow>
</mrow>
<mrow>
<mrow>
<msup>
<mi mathvariant="normal">Γ</mi>
<mo>′</mo>
</msup>
<mo>;</mo>
<mi mathvariant="normal">Γ</mi>
</mrow>
<mo>⊢</mo>
<mrow>
<mi>b</mi>
<mi>a</mi>
</mrow>
<mo>:</mo>
<mi>X</mi>
</mrow>
</mfrac>
<mrow>
<mo stretchy="false">[</mo>
<mo>\</mo>
<mi>E</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<divide></divide>
<apply>
<and></and>
<apply>
<csymbol cd="latexml">proves</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>normal-Γ</ci>
<ci>normal-′</ci>
</apply>
<ci>b</ci>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<list>
<ci>Y</ci>
<ci>normal-Γ</ci>
</list>
</apply>
<apply>
<csymbol cd="latexml">proves</csymbol>
<share href="#.cmml">
</share>
<ci>a</ci>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<apply>
<ci>normal-\</ci>
<ci>X</ci>
<ci>Y</ci>
</apply>
</apply>
</apply>
<apply>
<and></and>
<apply>
<csymbol cd="latexml">proves</csymbol>
<list>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>normal-Γ</ci>
<ci>normal-′</ci>
</apply>
<ci>normal-Γ</ci>
</list>
<apply>
<times></times>
<ci>b</ci>
<ci>a</ci>
</apply>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<ci>X</ci>
</apply>
</apply>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-[</ci>
<ci>normal-\</ci>
<csymbol cd="unknown">E</csymbol>
<ci>normal-]</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \frac{\Gamma^{\prime}\vdash b:Y\qquad\Gamma\vdash a:X\backslash Y}{\Gamma^{%
\prime};\Gamma\vdash ba:X}[\backslash E]
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Minimalist_grammar:9">
<semantics>
<mrow>
<mfrac>
<mrow>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mo>;</mo>
<msup>
<mi mathvariant="normal">Γ</mi>
<mo>′</mo>
</msup>
</mrow>
<mo>⊢</mo>
<mi>α</mi>
</mrow>
<mrow>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mo>,</mo>
<msup>
<mi mathvariant="normal">Γ</mi>
<mo>′</mo>
</msup>
</mrow>
<mo>⊢</mo>
<mi>α</mi>
</mrow>
</mfrac>
<mi>e</mi>
<mi>n</mi>
<mi>t</mi>
<mi>r</mi>
<mi>o</mi>
<mi>p</mi>
<mi>y</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<csymbol cd="latexml">proves</csymbol>
<list>
<ci>normal-Γ</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>normal-Γ</ci>
<ci>normal-′</ci>
</apply>
</list>
<ci>α</ci>
</apply>
<apply>
<csymbol cd="latexml">proves</csymbol>
<list>
<ci>normal-Γ</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>normal-Γ</ci>
<ci>normal-′</ci>
</apply>
</list>
<ci>α</ci>
</apply>
</apply>
<ci>e</ci>
<ci>n</ci>
<ci>t</ci>
<ci>r</ci>
<ci>o</ci>
<ci>p</ci>
<ci>y</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \frac{\Gamma;\Gamma^{\prime}\vdash\alpha}{\Gamma,\Gamma^{\prime}\vdash\alpha}entropy
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Minimalist_grammar:10">
<semantics>
<mrow>
<mfrac>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mo>⊢</mo>
<mi>a</mi>
<mo>:</mo>
<mrow>
<mrow>
<mi>X</mi>
<mo>∘</mo>
<mi>Y</mi>
</mrow>
<mi mathvariant="normal">Δ</mi>
<mo>,</mo>
<mi>b</mi>
</mrow>
<mo>:</mo>
<mrow>
<mi>X</mi>
<mo>,</mo>
<mi>c</mi>
</mrow>
<mo>:</mo>
<mrow>
<mi>Y</mi>
<mo>,</mo>
<msup>
<mi mathvariant="normal">Δ</mi>
<mo>′</mo>
</msup>
</mrow>
<mo>⊢</mo>
<mi>d</mi>
<mo>:</mo>
<mi>Z</mi>
</mrow>
<mrow>
<mi mathvariant="normal">Δ</mi>
<mo>,</mo>
<mi mathvariant="normal">Γ</mi>
<mo>,</mo>
<msup>
<mi mathvariant="normal">Δ</mi>
<mo>′</mo>
</msup>
<mo>⊢</mo>
<mi>d</mi>
<mrow>
<mo stretchy="false">[</mo>
<mi>b</mi>
<mo>:=</mo>
<mi>a</mi>
<mo>,</mo>
<mi>c</mi>
<mo>:=</mo>
<mi>a</mi>
<mo stretchy="false">]</mo>
</mrow>
<mo>:</mo>
<mi>Z</mi>
</mrow>
</mfrac>
<mrow>
<mo stretchy="false">[</mo>
<mo>∘</mo>
<mi>E</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<divide></divide>
<apply>
<and></and>
<apply>
<csymbol cd="latexml">proves</csymbol>
<ci>normal-Γ</ci>
<ci>a</ci>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<list>
<apply>
<compose></compose>
<ci>X</ci>
<ci>Y</ci>
</apply>
<ci>normal-Δ</ci>
<ci>b</ci>
</list>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<list>
<ci>X</ci>
<ci>c</ci>
</list>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<list>
<ci>Y</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>normal-Δ</ci>
<ci>normal-′</ci>
</apply>
</list>
</apply>
<apply>
<csymbol cd="latexml">proves</csymbol>
<share href="#.cmml">
</share>
<ci>d</ci>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<ci>Z</ci>
</apply>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">Δ</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">Γ</csymbol>
<ci>normal-,</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>normal-Δ</ci>
<ci>normal-′</ci>
</apply>
<csymbol cd="latexml">proves</csymbol>
<csymbol cd="unknown">d</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-[</ci>
<csymbol cd="unknown">b</csymbol>
<csymbol cd="latexml">assign</csymbol>
<csymbol cd="unknown">a</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">c</csymbol>
<csymbol cd="latexml">assign</csymbol>
<csymbol cd="unknown">a</csymbol>
<ci>normal-]</ci>
</cerror>
<ci>normal-:</ci>
<csymbol cd="unknown">Z</csymbol>
</cerror>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-[</ci>
<compose></compose>
<csymbol cd="unknown">E</csymbol>
<ci>normal-]</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \frac{\Gamma\vdash a:X\circ Y\qquad\Delta,b:X,c:Y,\Delta^{\prime}\vdash d:Z}{%
\Delta,\Gamma,\Delta^{\prime}\vdash d[b:=a,c:=a]:Z}[\circ E]
  </annotation>
</semantics>
</math>
</p>

<p>The first rule merely makes it possible to use lexical items with no extra assumptions. The second rule is just a means of introducing assumptions into the derivation. The third and fourth rules just perform directional feature checking, combining the assumptions required to build the subparts that are being combined. The entropy rule presumably allows the ordered sequents to be broken up into unordered sequents. And finally, the last rule implements "movement" by means of assumption elimination.</p>

<p>The last rule can be given a number of different interpretations in order to fully mimic movement of the normal sort found in the Minimalist Program. The account given by Lecomte and Retoré (2001) is that if one of the product types is a strong functional feature, then the phonological/orthographic content associated with that type on the right is substituted with the content of the <em>a</em>, and the other is substituted with the empty string; whereas if neither is strong, then the phonological/orthographic content is substituted for the category feature, and the empty string is substituted for the weak functional feature. That is, we can rephrase the rule as two sub-rules as follows:</p>

<p>
<math display="block" id="Minimalist_grammar:11">
<semantics>
<mrow>
<mfrac>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mo>⊢</mo>
<mi>a</mi>
<mo>:</mo>
<mrow>
<mrow>
<mi>X</mi>
<mo>∘</mo>
<msup>
<mi>Y</mi>
<mo>*</mo>
</msup>
</mrow>
<mi mathvariant="normal">Δ</mi>
<mo>,</mo>
<mi>b</mi>
</mrow>
<mo>:</mo>
<mrow>
<mi>X</mi>
<mo>,</mo>
<mi>c</mi>
</mrow>
<mo>:</mo>
<mrow>
<msup>
<mi>Y</mi>
<mo>*</mo>
</msup>
<mo>,</mo>
<msup>
<mi mathvariant="normal">Δ</mi>
<mo>′</mo>
</msup>
</mrow>
<mo>⊢</mo>
<mi>d</mi>
<mo>:</mo>
<mi>Z</mi>
</mrow>
<mrow>
<mi mathvariant="normal">Δ</mi>
<mo>,</mo>
<mi mathvariant="normal">Γ</mi>
<mo>,</mo>
<msup>
<mi mathvariant="normal">Δ</mi>
<mo>′</mo>
</msup>
<mo>⊢</mo>
<mi>d</mi>
<mrow>
<mo stretchy="false">[</mo>
<mi>b</mi>
<mo>:=</mo>
<mi>ϵ</mi>
<mo>,</mo>
<mi>c</mi>
<mo>:=</mo>
<mi>a</mi>
<mo stretchy="false">]</mo>
</mrow>
<mo>:</mo>
<mi>Z</mi>
</mrow>
</mfrac>
<mrow>
<mo stretchy="false">[</mo>
<mo>∘</mo>
<msub>
<mi>E</mi>
<mrow>
<mi>s</mi>
<mi>t</mi>
<mi>r</mi>
<mi>o</mi>
<mi>n</mi>
<mi>g</mi>
</mrow>
</msub>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<divide></divide>
<apply>
<and></and>
<apply>
<csymbol cd="latexml">proves</csymbol>
<ci>normal-Γ</ci>
<ci>a</ci>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<list>
<apply>
<compose></compose>
<ci>X</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>Y</ci>
<times></times>
</apply>
</apply>
<ci>normal-Δ</ci>
<ci>b</ci>
</list>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<list>
<ci>X</ci>
<ci>c</ci>
</list>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<list>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>Y</ci>
<times></times>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>normal-Δ</ci>
<ci>normal-′</ci>
</apply>
</list>
</apply>
<apply>
<csymbol cd="latexml">proves</csymbol>
<share href="#.cmml">
</share>
<ci>d</ci>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<ci>Z</ci>
</apply>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">Δ</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">Γ</csymbol>
<ci>normal-,</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>normal-Δ</ci>
<ci>normal-′</ci>
</apply>
<csymbol cd="latexml">proves</csymbol>
<csymbol cd="unknown">d</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-[</ci>
<csymbol cd="unknown">b</csymbol>
<csymbol cd="latexml">assign</csymbol>
<csymbol cd="unknown">ϵ</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">c</csymbol>
<csymbol cd="latexml">assign</csymbol>
<csymbol cd="unknown">a</csymbol>
<ci>normal-]</ci>
</cerror>
<ci>normal-:</ci>
<csymbol cd="unknown">Z</csymbol>
</cerror>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-[</ci>
<compose></compose>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>E</ci>
<apply>
<times></times>
<ci>s</ci>
<ci>t</ci>
<ci>r</ci>
<ci>o</ci>
<ci>n</ci>
<ci>g</ci>
</apply>
</apply>
<ci>normal-]</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \frac{\Gamma\vdash a:X\circ Y^{*}\qquad\Delta,b:X,c:Y^{*},\Delta^{\prime}%
\vdash d:Z}{\Delta,\Gamma,\Delta^{\prime}\vdash d[b:=\epsilon,c:=a]:Z}[\circ E%
_{strong}]
  </annotation>
</semantics>
</math>

 where 

<math display="inline" id="Minimalist_grammar:12">
<semantics>
<mrow>
<mrow>
<mi>X</mi>
<mo>∈</mo>
<mi>C</mi>
</mrow>
<mo>,</mo>
<mrow>
<msup>
<mi>Y</mi>
<mo>*</mo>
</msup>
<mo>∈</mo>
<mi>F</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<in></in>
<ci>X</ci>
<ci>C</ci>
</apply>
<apply>
<in></in>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>Y</ci>
<times></times>
</apply>
<ci>F</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   X\in C,Y^{*}\in F
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Minimalist_grammar:13">
<semantics>
<mrow>
<mfrac>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mo>⊢</mo>
<mi>a</mi>
<mo>:</mo>
<mrow>
<mrow>
<mi>X</mi>
<mo>∘</mo>
<mi>Y</mi>
</mrow>
<mi mathvariant="normal">Δ</mi>
<mo>,</mo>
<mi>b</mi>
</mrow>
<mo>:</mo>
<mrow>
<mi>X</mi>
<mo>,</mo>
<mi>c</mi>
</mrow>
<mo>:</mo>
<mrow>
<mi>Y</mi>
<mo>,</mo>
<msup>
<mi mathvariant="normal">Δ</mi>
<mo>′</mo>
</msup>
</mrow>
<mo>⊢</mo>
<mi>d</mi>
<mo>:</mo>
<mi>Z</mi>
</mrow>
<mrow>
<mi mathvariant="normal">Δ</mi>
<mo>,</mo>
<mi mathvariant="normal">Γ</mi>
<mo>,</mo>
<msup>
<mi mathvariant="normal">Δ</mi>
<mo>′</mo>
</msup>
<mo>⊢</mo>
<mi>d</mi>
<mrow>
<mo stretchy="false">[</mo>
<mi>b</mi>
<mo>:=</mo>
<mi>a</mi>
<mo>,</mo>
<mi>c</mi>
<mo>:=</mo>
<mi>ϵ</mi>
<mo stretchy="false">]</mo>
</mrow>
<mo>:</mo>
<mi>Z</mi>
</mrow>
</mfrac>
<mrow>
<mo stretchy="false">[</mo>
<mo>∘</mo>
<msub>
<mi>E</mi>
<mrow>
<mi>w</mi>
<mi>e</mi>
<mi>a</mi>
<mi>k</mi>
</mrow>
</msub>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<divide></divide>
<apply>
<and></and>
<apply>
<csymbol cd="latexml">proves</csymbol>
<ci>normal-Γ</ci>
<ci>a</ci>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<list>
<apply>
<compose></compose>
<ci>X</ci>
<ci>Y</ci>
</apply>
<ci>normal-Δ</ci>
<ci>b</ci>
</list>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<list>
<ci>X</ci>
<ci>c</ci>
</list>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<list>
<ci>Y</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>normal-Δ</ci>
<ci>normal-′</ci>
</apply>
</list>
</apply>
<apply>
<csymbol cd="latexml">proves</csymbol>
<share href="#.cmml">
</share>
<ci>d</ci>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<ci>Z</ci>
</apply>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">Δ</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">Γ</csymbol>
<ci>normal-,</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>normal-Δ</ci>
<ci>normal-′</ci>
</apply>
<csymbol cd="latexml">proves</csymbol>
<csymbol cd="unknown">d</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-[</ci>
<csymbol cd="unknown">b</csymbol>
<csymbol cd="latexml">assign</csymbol>
<csymbol cd="unknown">a</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">c</csymbol>
<csymbol cd="latexml">assign</csymbol>
<csymbol cd="unknown">ϵ</csymbol>
<ci>normal-]</ci>
</cerror>
<ci>normal-:</ci>
<csymbol cd="unknown">Z</csymbol>
</cerror>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-[</ci>
<compose></compose>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>E</ci>
<apply>
<times></times>
<ci>w</ci>
<ci>e</ci>
<ci>a</ci>
<ci>k</ci>
</apply>
</apply>
<ci>normal-]</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \frac{\Gamma\vdash a:X\circ Y\qquad\Delta,b:X,c:Y,\Delta^{\prime}\vdash d:Z}{%
\Delta,\Gamma,\Delta^{\prime}\vdash d[b:=a,c:=\epsilon]:Z}[\circ E_{weak}]
  </annotation>
</semantics>
</math>

 where 

<math display="inline" id="Minimalist_grammar:14">
<semantics>
<mrow>
<mrow>
<mi>X</mi>
<mo>∈</mo>
<mi>C</mi>
</mrow>
<mo>,</mo>
<mrow>
<mi>Y</mi>
<mo>∈</mo>
<mi>F</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<in></in>
<ci>X</ci>
<ci>C</ci>
</apply>
<apply>
<in></in>
<ci>Y</ci>
<ci>F</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   X\in C,Y\in F
  </annotation>
</semantics>
</math>
</p>

<p>Another alternative would be to construct pairs in the <em>/E</em> and <em>\E</em> steps, and use the 

<math display="inline" id="Minimalist_grammar:15">
<semantics>
<mrow>
<mi></mi>
<mo>∘</mo>
<mi>E</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<compose></compose>
<csymbol cd="latexml">absent</csymbol>
<ci>E</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \circ E
  </annotation>
</semantics>
</math>

 rule as given, substituting the phonological/orthographic content <em>a</em> into the highest of the substitution positions, and the empty string in the rest of the positions. This would be more in line with the Minimalist Program, given that multiple movements of an item are possible, where only the highest position is "spelled out".</p>
<h2 id="example">Example</h2>

<p>As a simple example of this system, we can show how to generate the sentence <em>who did John see</em> with the following toy grammar:</p>

<p>Let 

<math display="inline" id="Minimalist_grammar:16">
<semantics>
<mrow>
<mi>G</mi>
<mo>=</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo stretchy="false">{</mo>
<mi>N</mi>
<mo>,</mo>
<mi>S</mi>
<mo stretchy="false">}</mo>
</mrow>
<mo>,</mo>
<mrow>
<mo stretchy="false">{</mo>
<mi>W</mi>
<mo stretchy="false">}</mo>
</mrow>
<mo>,</mo>
<mi>L</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>G</ci>
<vector>
<set>
<ci>N</ci>
<ci>S</ci>
</set>
<set>
<ci>W</ci>
</set>
<ci>L</ci>
</vector>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   G=(\{N,S\},\{W\},L)
  </annotation>
</semantics>
</math>

, where <em>L</em> contains the following words:</p>

<p>
<math display="block" id="Minimalist_grammar:17">
<semantics>
<mrow>
<mtext>John</mtext>
<mo>:</mo>
<mi>N</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<mtext>John</mtext>
<ci>N</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \text{John}:N
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Minimalist_grammar:18">
<semantics>
<mrow>
<mtext>see</mtext>
<mo>:</mo>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>S</mi>
<mo>\</mo>
<mi>N</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>/</mo>
<mi>N</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<mtext>see</mtext>
<apply>
<divide></divide>
<apply>
<ci>normal-\</ci>
<ci>S</ci>
<ci>N</ci>
</apply>
<ci>N</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \text{see}:(S\backslash N)/N
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Minimalist_grammar:19">
<semantics>
<mrow>
<mtext>did</mtext>
<mo>:</mo>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>S</mi>
<mo>\</mo>
<mi>W</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>/</mo>
<mi>S</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<mtext>did</mtext>
<apply>
<divide></divide>
<apply>
<ci>normal-\</ci>
<ci>S</ci>
<ci>W</ci>
</apply>
<ci>S</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \text{did}:(S\backslash W)/S
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Minimalist_grammar:20">
<semantics>
<mrow>
<mtext>who</mtext>
<mo>:</mo>
<mrow>
<mi>N</mi>
<mo>∘</mo>
<mi>W</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<mtext>who</mtext>
<apply>
<compose></compose>
<ci>N</ci>
<ci>W</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \text{who}:N\circ W
  </annotation>
</semantics>
</math>
</p>

<p>The proof for the sentence <em>who did John see</em> is therefore:</p>

<p>
<math display="block" id="Minimalist_grammar:21">
<semantics>
<mrow>
<mfrac>
<mrow>
<mo>⊢</mo>
<mtext>who</mtext>
<mo>:</mo>
<mi>N</mi>
<mo>∘</mo>
<mi>W</mi>
<mstyle displaystyle="true">
<mfrac>
<mrow>
<mtext>x</mtext>
<mo>:</mo>
<mi>W</mi>
<mo>⊢</mo>
<mtext>x</mtext>
<mo>:</mo>
<mi>W</mi>
<mstyle displaystyle="true">
<mfrac>
<mrow>
<mo>⊢</mo>
<mtext>did</mtext>
<mo>:</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>S</mi>
<mo>\</mo>
<mi>W</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>/</mo>
<mi>S</mi>
<mstyle displaystyle="true">
<mfrac>
<mrow>
<mo>⊢</mo>
<mtext>John</mtext>
<mo>:</mo>
<mi>N</mi>
<mstyle displaystyle="true">
<mfrac>
<mrow>
<mtext>y</mtext>
<mo>:</mo>
<mi>N</mi>
<mo>⊢</mo>
<mtext>y</mtext>
<mo>:</mo>
<mi>N</mi>
<mo>⊢</mo>
<mtext>see</mtext>
<mo>:</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>S</mi>
<mo>\</mo>
<mi>N</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>/</mo>
<mi>N</mi>
</mrow>
<mrow>
<mtext>y</mtext>
<mo>:</mo>
<mi>N</mi>
<mo>⊢</mo>
<mtext>see y</mtext>
<mo>:</mo>
<mrow>
<mi>S</mi>
<mo>\</mo>
<mi>N</mi>
</mrow>
</mrow>
</mfrac>
</mstyle>
<mrow>
<mo stretchy="false">[</mo>
<mo>/</mo>
<mi>E</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<mrow>
<mtext>y</mtext>
<mo>:</mo>
<mi>N</mi>
<mo>⊢</mo>
<mtext>John see y</mtext>
<mo>:</mo>
<mi>S</mi>
</mrow>
</mfrac>
</mstyle>
<mrow>
<mo stretchy="false">[</mo>
<mo>\</mo>
<mi>E</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<mrow>
<mtext>y</mtext>
<mo>:</mo>
<mi>N</mi>
<mo>⊢</mo>
<mtext>did John see y</mtext>
<mo>:</mo>
<mrow>
<mi>S</mi>
<mo>\</mo>
<mi>W</mi>
</mrow>
</mrow>
</mfrac>
</mstyle>
<mrow>
<mo stretchy="false">[</mo>
<mo>/</mo>
<mi>E</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<mrow>
<mtext>x</mtext>
<mo>:</mo>
<mrow>
<mi>W</mi>
<mo>,</mo>
<mtext>y</mtext>
</mrow>
<mo>:</mo>
<mi>N</mi>
<mo>⊢</mo>
<mtext>x did John see y</mtext>
<mo>:</mo>
<mi>S</mi>
</mrow>
</mfrac>
</mstyle>
<mrow>
<mo stretchy="false">[</mo>
<mo>\</mo>
<mi>E</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<mrow>
<mo>⊢</mo>
<mtext>who did John see</mtext>
<mo>:</mo>
<mi>S</mi>
</mrow>
</mfrac>
<mrow>
<mo stretchy="false">[</mo>
<mo>∘</mo>
<mi>E</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<divide></divide>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="latexml">proves</csymbol>
<mtext>who</mtext>
<ci>normal-:</ci>
<csymbol cd="unknown">N</csymbol>
<compose></compose>
<csymbol cd="unknown">W</csymbol>
<ci></ci>
<apply>
<divide></divide>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<mtext>x</mtext>
<ci>normal-:</ci>
<csymbol cd="unknown">W</csymbol>
<csymbol cd="latexml">proves</csymbol>
<mtext>x</mtext>
<ci>normal-:</ci>
<csymbol cd="unknown">W</csymbol>
<ci></ci>
<apply>
<divide></divide>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="latexml">proves</csymbol>
<mtext>did</mtext>
<ci>normal-:</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">S</csymbol>
<ci>normal-\</ci>
<csymbol cd="unknown">W</csymbol>
<ci>normal-)</ci>
</cerror>
<divide></divide>
<csymbol cd="unknown">S</csymbol>
<ci></ci>
<apply>
<divide></divide>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="latexml">proves</csymbol>
<mtext>John</mtext>
<ci>normal-:</ci>
<csymbol cd="unknown">N</csymbol>
<ci></ci>
<apply>
<divide></divide>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<mtext>y</mtext>
<ci>normal-:</ci>
<csymbol cd="unknown">N</csymbol>
<csymbol cd="latexml">proves</csymbol>
<mtext>y</mtext>
<ci>normal-:</ci>
<csymbol cd="unknown">N</csymbol>
<ci></ci>
<csymbol cd="latexml">proves</csymbol>
<mtext>see</mtext>
<ci>normal-:</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">S</csymbol>
<ci>normal-\</ci>
<csymbol cd="unknown">N</csymbol>
<ci>normal-)</ci>
</cerror>
<divide></divide>
<csymbol cd="unknown">N</csymbol>
</cerror>
<apply>
<and></and>
<apply>
<ci>normal-:</ci>
<mtext>y</mtext>
<ci>N</ci>
</apply>
<apply>
<csymbol cd="latexml">proves</csymbol>
<share href="#.cmml">
</share>
<mtext>see y</mtext>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<apply>
<ci>normal-\</ci>
<ci>S</ci>
<ci>N</ci>
</apply>
</apply>
</apply>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-[</ci>
<divide></divide>
<csymbol cd="unknown">E</csymbol>
<ci>normal-]</ci>
</cerror>
</cerror>
<apply>
<and></and>
<apply>
<ci>normal-:</ci>
<mtext>y</mtext>
<ci>N</ci>
</apply>
<apply>
<csymbol cd="latexml">proves</csymbol>
<share href="#.cmml">
</share>
<mtext>John see y</mtext>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<ci>S</ci>
</apply>
</apply>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-[</ci>
<ci>normal-\</ci>
<csymbol cd="unknown">E</csymbol>
<ci>normal-]</ci>
</cerror>
</cerror>
<apply>
<and></and>
<apply>
<ci>normal-:</ci>
<mtext>y</mtext>
<ci>N</ci>
</apply>
<apply>
<csymbol cd="latexml">proves</csymbol>
<share href="#.cmml">
</share>
<mtext>did John see y</mtext>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<apply>
<ci>normal-\</ci>
<ci>S</ci>
<ci>W</ci>
</apply>
</apply>
</apply>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-[</ci>
<divide></divide>
<csymbol cd="unknown">E</csymbol>
<ci>normal-]</ci>
</cerror>
</cerror>
<apply>
<and></and>
<apply>
<ci>normal-:</ci>
<mtext>x</mtext>
<list>
<ci>W</ci>
<mtext>y</mtext>
</list>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<ci>N</ci>
</apply>
<apply>
<csymbol cd="latexml">proves</csymbol>
<share href="#.cmml">
</share>
<mtext>x did John see y</mtext>
</apply>
<apply>
<ci>normal-:</ci>
<share href="#.cmml">
</share>
<ci>S</ci>
</apply>
</apply>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-[</ci>
<ci>normal-\</ci>
<csymbol cd="unknown">E</csymbol>
<ci>normal-]</ci>
</cerror>
</cerror>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="latexml">proves</csymbol>
<mtext>who did John see</mtext>
<ci>normal-:</ci>
<csymbol cd="unknown">S</csymbol>
</cerror>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-[</ci>
<compose></compose>
<csymbol cd="unknown">E</csymbol>
<ci>normal-]</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \dfrac{\vdash\text{who}:N\circ W\quad\dfrac{\text{x}:W\vdash\text{x}:W\quad%
\dfrac{\vdash\text{did}:(S\backslash W)/S\quad\dfrac{\vdash\text{John}:N\quad%
\dfrac{\text{y}:N\vdash\text{y}:N\quad\vdash\text{see}:(S\backslash N)/N}{%
\text{y}:N\vdash\text{see y}:S\backslash N}[/E]}{\text{y}:N\vdash\text{John %
see y}:S}[\backslash E]}{\text{y}:N\vdash\text{did John see y}:S\backslash W}[%
/E]}{\text{x}:W,\text{y}:N\vdash\text{x did John see y}:S}[\backslash E]}{%
\vdash\text{who did John see}:S}[\circ E]
  </annotation>
</semantics>
</math>
</p>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Harkema, H., 2001. "A characterization of minimalist languages", in: de Groote, P., Morrill, G., Retoré, C. (Eds.), Logical Aspects of Computational Linguistics (Lecture Notes in Artificial Intelligence, No. 2099). Springer, New York, pp. 193–211, </li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a> <a href="Category:Grammar_frameworks" title="wikilink">Category:Grammar frameworks</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
