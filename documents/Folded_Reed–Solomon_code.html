<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title offset="122">Folded Reed–Solomon code</title>
   <script type="text/javascript"
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js">
    </script>
</head>
<body>
<h1>Folded Reed–Solomon code</h1>
<hr/>
<p>In <a href="coding_theory" title="wikilink">coding theory</a>, <strong>folded Reed–Solomon codes</strong> are like <a href="Reed–Solomon_code" title="wikilink">Reed–Solomon codes</a>, which are obtained by mapping <span class="LaTeX">$m$</span> Reed–Solomon codewords over a larger alphabet by careful bundling of codeword symbols. They are also a special case of <a href="Parvaresh–Vardy_code" title="wikilink">Parvaresh–Vardy codes</a>. Using optimal parameters one can decode with a <a href="code_rate" title="wikilink">rate</a> of <em>R</em>, and achieve a decoding radius of 1 − <em>R</em>. The term "folded Reed–Solomon codes" was coined in a paper by V.Y. Krachkovsky with an algorithm that presented Reed–Solomon codes with many random "phased burst" errors [<a class="uri" href="http://ieeexplore.ieee.org/xpl/login.jsp?tp">http://ieeexplore.ieee.org/xpl/login.jsp?tp</a>=&arnumber;=1246020&url;=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D1246020 ]. The list-decoding algorithm for folded RS codes corrects beyond the <span class="LaTeX">$1-\sqrt{R}$</span> bound for Reed–Solomon codes achieved by the <a href="Venkatesan_Guruswami" title="wikilink">Guruswami</a>–<a href="Madhu_Sudan" title="wikilink">Sudan</a> algorithm for such phased burst errors.</p>
<h2 id="history">History</h2>
<p>One of the challenges in coding theory is to have error correcting codes achieve an optimal trade-off between rate and error-correction radius. Though this may not be possible to achieve practically, it can be achieved theoretically. Prior to Folded Reed–Solomon codes, the best error-correction radius achieved was <span class="LaTeX">$1- \sqrt{R}$</span>, by <a href="Reed–Solomon_code" title="wikilink">Reed–Solomon codes</a> for all rates <span class="LaTeX">$R$</span>. An improvement upon this <span class="LaTeX">$1- \sqrt{R}$</span> bound was achieved by Parvaresh and Vardy for rates <span class="LaTeX">$R <1/16$</span>. For <span class="LaTeX">$R\to 0$</span>, the Parvaresh–Vardy algorithm can decode a fraction <span class="LaTeX">$1- O(R \log(1/R))$</span> of errors. Folded Reed–Solomon Codes improve on these previous constructions, and can be list decoded in polynomial time for a fraction <span class="LaTeX">$(1-R-\epsilon)$</span> of errors for any constant <span class="LaTeX">$\epsilon > 0$</span>.</p>
<h2 id="definition">Definition</h2>
<p><span class="LaTeX">$$f(X)\mapsto\begin{bmatrix}f(1)\\f(\gamma)\\\vdots\\f(\gamma^{m-1})\end{bmatrix},\begin{bmatrix}f(\gamma^m)\\f(\gamma^{m+1})\\\vdots\\f(\gamma^{2m-1})\end{bmatrix},\ldots,\begin{bmatrix}f(\gamma^{n-m})\\f(\gamma^{n-m+1})\\\vdots\\f(\gamma^{n-1})\end{bmatrix}$$</span></p>
<p>Consider a Reed–Solomon <span class="LaTeX">$[n=q-1,k]_q$</span> code of length <span class="LaTeX">$n$</span> and <a href="Dimension_(linear_algebra)" title="wikilink">dimension</a> <span class="LaTeX">$k$</span> and a folding parameter <span class="LaTeX">$m \ge 1$</span>. Assume that <span class="LaTeX">$m$</span> divides <span class="LaTeX">$n$</span>.</p>
<p>Mapping for Reed–Solomon codes like this<span class="LaTeX">$$f \mapsto \langle  f\left(\gamma^0\right), f(\gamma^1), f(\gamma^2), \ldots , f(\gamma^{n-1}) \rangle$$</span> where <span class="LaTeX">$\gamma \in  \mathbb{F}_q$</span> is a <a href="Primitive_element_(finite_field)" title="wikilink">primitive element</a> in <span class="LaTeX">$\mathbb{F}_q = \left\{ 0,1, \gamma, \gamma^2, \ldots ,\gamma^{n-1}\right\}$</span>.</p>
<p>The <span class="LaTeX">$m$</span> folded version of Reed Solomon code <span class="LaTeX">$C$</span>, denoted <span class="LaTeX">$FRS_{\mathbb{F},\gamma,m,k }$</span> is a code of block length <span class="LaTeX">$N = n/m$</span> over <span class="LaTeX">$\mathbb{F}^m$</span>. <span class="LaTeX">$FRS_{\mathbb{F},\gamma,m,k }$</span> are just <span class="LaTeX">$[q-1,k]$</span> Reed Solomon codes with <span class="LaTeX">$m$</span> consecutive symbols from RS codewords grouped together.</p>
<h3 id="graphic-description">Graphic description</h3>
<p> The above definition is made more clear by means of the diagram with <span class="LaTeX">$m=3$</span>, where <span class="LaTeX">$m$</span> is the folding parameter. The message is denoted by <span class="LaTeX">$f(X)$</span>, which when encoded using Reed–Solomon encoding, consists of values of <span class="LaTeX">$f$</span> at <span class="LaTeX">$x_0, x_1, x_2, \ldots,x_{n-1}$</span>, where <span class="LaTeX">$x_i =\gamma^i$</span>. Then bundling is performed in groups of 3 elements, to give a codeword of length <span class="LaTeX">$n/3$</span> over the alphabet <span class="LaTeX">$\mathbb{F}_q^3$</span>. Something to be observed here is that the folding operation demonstrated does not change the rate <span class="LaTeX">$R$</span> of the original Reed–Solomon code. To prove this, consider a linear <span class="LaTeX">$[n, k, d]_q$</span> code, of length <span class="LaTeX">$n$</span>, <a href="Dimension_(linear_algebra)" title="wikilink">dimension</a> <span class="LaTeX">$k$</span> and <a href="Block_code#The_distance_d" title="wikilink">distance</a> <span class="LaTeX">$d$</span>. The <span class="LaTeX">$m$</span> folding operation will make it a <span class="LaTeX">$\left[\dfrac{n}{m}, \dfrac{k}{m},\dfrac{d}{m}\right]_{q^m}$</span> code. By this, the <a href="Code_rate" title="wikilink">rate</a> <span class="LaTeX">$R = \dfrac{n}{k}$</span> will be the same.</p>
<h2 id="folded-reedsolomon-codes-and-the-singleton-bound">Folded Reed–Solomon codes and the singleton bound</h2>
<p>According to the asymptotic version of the <a href="singleton_bound" title="wikilink">singleton bound</a>, it is known that the <a href="Block_code#The_distance_d" title="wikilink">relative distance</a> <span class="LaTeX">$\delta$</span>, of a code must satisfy <span class="LaTeX">$R \leq$</span> <span class="LaTeX">$1-\delta + o(1)$</span> where <span class="LaTeX">$R$</span>is the rate of the code. As proved earlier, since the rate <span class="LaTeX">$R$</span> is maintained, the relative distance <span class="LaTeX">$\delta \ge 1-R$</span> also meets the Singleton bound.</p>
<h3 id="why-folding-might-help">Why folding might help?</h3>
<figure><b>(Figure)</b>
<figcaption>Decoding a folded Reed–Solomon code</figcaption>
</figure>
<p>Folded Reed–Solomon codes are basically the same as Reed Solomon codes, just viewed over a larger alphabet. To show how this might help, consider a folded Reed–Solomon code with <span class="LaTeX">$m=3$</span>. Decoding a Reed–Solomon code and folded Reed–Solomon code from the same fraction of errors <span class="LaTeX">$\rho$</span> are tasks of almost of the same computational intensity: one can <strong>unfold</strong> the received word of the folded Reed–Solomon code, treat it as an received word of the original Reed–Solomon code, and run the Reed–Solomon list decoding algorithm on it. Obviously, this list will contain all the folded Reed–Solomon codewords within distance <span class="LaTeX">$\rho$</span> of the received word, along with some extras, which we can expurgate.</p>
<p>Also, decoding a folded Reed–Solomon code is an easier task. Suppose we want to correct a fraction <span class="LaTeX">$1/3$</span> of errors. The decoding algorithm chosen must correct an error pattern that corrects every 3rd symbol in the Reed–Solomon encoding. But after folding, this error pattern will corrupt all symbols over <span class="LaTeX">$\mathbb{F}_q^3$</span> and will eliminate the need for error correction. This propagation of errors is indicated by the blue color in the graphical description. This proves that the for a fixed fraction of errors <span class="LaTeX">$\rho$</span>, the folding operation reduces the channel's flexibility to distribute errors, which in turn leads to a reduction in the number of error patterns that need to be corrected. <span class="LaTeX">$$</span></p>
<h2 id="how-folded-reedsolomon-frs-codes-and-parvaresh-vardy-pv-codes-are-related">How folded Reed–Solomon (FRS) codes and Parvaresh Vardy (PV) codes are related</h2>
<p>We can relate Folded Reed Solomon codes with <a href="https://wiki.cse.buffalo.edu/cse545/content/parvaresh-vardy-codes-and-list-decoder">Parvaresh Vardy</a> codes which encodes a polynomial <span class="LaTeX">$f$</span> of degree <span class="LaTeX">$k$</span> with <span class="LaTeX">$s$</span>(order)<span class="LaTeX">$\geq$</span>2 polynomials <span class="LaTeX">$f_0=f, f_1 , \ldots, f_{s-1}$</span> where <span class="LaTeX">$f_i(X)=f_{i-1}(X)^d \mod E(X)$</span> where <span class="LaTeX">$E(X)$</span> is an <a href="irreducible_polynomial" title="wikilink">irreducible polynomial</a>. While choosing irreducible polynomial <span class="LaTeX">$E(X)=X^q -\gamma$</span> and parameter <span class="LaTeX">$d$</span> we should check if every polynomial <span class="LaTeX">$f$</span> of degree at most <span class="LaTeX">$k$</span> satisfies <span class="LaTeX">$f(\gamma X)=f(X)^d \mod E(X)$</span> since <span class="LaTeX">$f(\gamma X)$</span> is just the shifted counterpart of <span class="LaTeX">$f(X)$</span> where <span class="LaTeX">$\gamma$</span> is the <a href="Primitive_element_(finite_field)" title="wikilink">primitive element</a> in <span class="LaTeX">$F_q$</span> . Thus folded RS code with bundling together code symbols is PV code of order <span class="LaTeX">$s=m$</span> for the set of evaluation points <span class="LaTeX">$\{1, \gamma, \gamma ^ {2m},\ldots,\gamma^{(n/m-1)m}\}$</span>. If we compare the folded RS code to a PV code of order 2 for the set of evaluation points <span class="LaTeX">$\{1, \gamma,\ldots, \gamma^{m-2},\gamma^m,\gamma^{m+1},\ldots,\gamma^{2m-2},\ldots,\gamma^{n-m},\gamma^{n-m+1},\ldots,\gamma^{n-2}\}$</span> we can see that in PV encoding of <span class="LaTeX">$f$</span>, for every <span class="LaTeX">$0 \leq i \leq n/m-1$</span> and every <span class="LaTeX">$0<j<m-1, f(\gamma^{mi+j})<="" math=""> appears at<math>  f(\gamma^{mi+j})$</span> and <span class="LaTeX">$f_1(\gamma^{-1}\gamma^{mi+j})$</span>,</p>
<figure><b>(Figure)</b>
<figcaption>Relation between PV codes and FRS codes</figcaption>
</figure>
<p>unlike in the folded FRS encoding in which it appears only once. Thus, the PV and folded RS codes have same information but only the rate of FRS is bigger by a factor of <span class="LaTeX">$2(m-1)/m$</span> and hence the <a href="list_decoding" title="wikilink">list decoding</a> radius trade-off is better for folded RS code by just using the list decodability of the PV codes. The plus point is in choosing FRS code in a way that they are compressed forms of suitable PV code with similar error correction performance with better rate than corresponding PV code. One can use this idea to construct a folded RS codes of rate <span class="LaTeX">$R$</span> that are list decodable up to radius approximately <span class="LaTeX">$1-R^{s/[s+1]}$</span> for <span class="LaTeX">$s\geq 1$</span>. <a href="http://www.cse.buffalo.edu/~atri/papers/coding/folded-RS.pdf"></a></p>
<h2 id="brief-overview-of-list-decoding-folded-reedsolomon-codes">Brief overview of list-decoding folded Reed–Solomon codes</h2>
<p>A <a href="list_decoding" title="wikilink">list decoding</a> algorithm which runs in quadratic time to decode FRS code up to radius <span class="LaTeX">$1-R-\epsilon$</span> is presented by Guruswami. The algorithm essentially has three steps namely the interpolation step in which welch berlekamp style interpolation is used to interpolate the non-zero polynomial <span class="LaTeX">$Q(X,Y_1,Y_2,\ldots,Y_s)=A_0(X) + A_1(X)Y_1 + A_2(X)Y_2 + \cdots + A_s(X)Y_s$</span>, after which all the polynomials <span class="LaTeX">$f\in{\mathbb{F}_q[X]}$</span> with degree <span class="LaTeX">$k-1$</span> satisfying the equation derived in interpolation are found. In the third step the actual list of close-by codewords are known by pruning the solution subspace which takes <span class="LaTeX">$q^s$</span>time.</p>
<h2 id="linear-algebraic-list-decoding-algorithm">Linear-algebraic list decoding algorithm</h2>
<p>Guruswami presents a <span class="LaTeX">$n^{\Omega (1/\varepsilon^2)}$</span> time list decoding algorithm based on linear-algebra, which can decode folded Reed–Solomon code up to radius <span class="LaTeX">$1-R-\varepsilon$</span> with a list-size of <span class="LaTeX">${n^{O(1/\varepsilon^2)}}$</span>. There are three steps in this algorithm: Interpolation Step, Root Finding Step and Prune Step. In the Interpolation step it will try to find the candidate message polynomial <span class="LaTeX">$f(x)$</span> by solving a linear system. In the Root Finding step, it will try to find the solution subspace by solving another linear system. The last step will try to prune the solution subspace gained in the second step. We will introduce each step in details in the following.</p>
<h3 id="step-1-the-interpolation-step">Step 1: The interpolation step</h3>
<p>It is a <a href="Berlekamp–Welch_algorithm" title="wikilink">Welch–Berlekamp-style</a> interpolation (because it can be viewed as the higher-dimensional generalization of the Welch–Berlekamp algorithm). Suppose we received a codeword <span class="LaTeX">$y$</span> of the <span class="LaTeX">$m$</span>-folded Reed–Solomon code as shown below</p>
<p><span class="LaTeX">$$\left(\begin{bmatrix}y_0\\y_1\\y_2\\\cdots\\y_{m-1}\end{bmatrix},\begin{bmatrix}y_m\\y_{m+1}\\y_{m+2}\\\cdots\\y_{2m-1}\end{bmatrix},\cdots,\begin{bmatrix}y_{n-m}\\y_{n-m+1}\\y_{n-m+2}\\\cdots\\y_{n-1}\end{bmatrix}\right)$$</span></p>
<p>We interpolate the nonzero polynomial</p>
<p><span class="LaTeX">$$Q(X,Y_1,Y_2,\ldots,Y_s)=A_0(X) + A_1(X)Y_1 + A_2(X)Y_2 + \cdots + A_s(X)Y_s$$</span></p>
<p>with the degree restrictions</p>
<p><span class="LaTeX">$$\deg(A_i) \leq D\text{ for }i = 1,2,\ldots,s\text{ and }\deg(A_0) \leq D + k -1$$</span></p>
<p>by using a carefully chosen degree parameter <span class="LaTeX">$D$</span>.</p>
<p><span class="LaTeX">$$D=\lfloor{{N(m-s+1)-k+1}\over{s+1}}\rfloor$$</span></p>
<p>So the interpolation requirements will be</p>
<p><span class="LaTeX">$$Q(\gamma^{im+j},y_{im+j},y_{im+j+1},\cdots,y_{im+j+s-1})=0$$</span></p>
<p>for</p>
<p><span class="LaTeX">$$i=0,1,\ldots,n/m - 1\text{ and }j=0,1,\ldots,m-s$$</span></p>
<p>Then the number of monomials in <span class="LaTeX">$Q(X,Y_1,Y_2,\ldots,Y_s)$</span> is</p>
<p><span class="LaTeX">$$(D + 1)s + D + k = (D+1)(s+1) + k -1 > N(m - s + 1)$$</span></p>
<p>Because the number of monomials in <span class="LaTeX">$Q(X,Y_1,Y_2,\ldots,Y_s)$</span> is greater than the number of interpolation conditions. We have below lemma</p>
<p><strong>Lemma 1:</strong> A nonzero <span class="LaTeX">$Q \in \mathbb{F}_q[X,Y_1,\cdots,Y_s]$</span> of the above form <span class="LaTeX">$Q(X,Y_1,Y_2,\ldots,Y_s)$</span> satisfying the above interpolation condition can be found by solving a homogeneous linear system over <span class="LaTeX">$\mathbb{F}_q$</span> with at most <span class="LaTeX">$Nm$</span> constraints and variables. And this interpolation can be performed in <span class="LaTeX">$O(Nmlog^2(Nm)loglog(Nm))$</span> operations over <span class="LaTeX">$\mathbb{F}_q$</span>.</p>
<p>The proof for this lemma can be found in Brander's thesis (Proposition 5.11 in Chapter 5), which is listed in the reference.</p>
<p>This lemma shows us that the interpolation step can be done in near-linear time.</p>
<p>For now, we have talked about everything we need for the multivariate polynomial <span class="LaTeX">$Q(X,Y_1,Y_2,\ldots,Y_s)$</span>. The remaining task is to focus on the message polynomials <span class="LaTeX">$f(X)$</span>.</p>
<p><strong>Lemma 2:</strong> If a candidate message polynomial <span class="LaTeX">$f(X) \in \mathbb{F}[X]$</span> is a polynomial of degree at most <span class="LaTeX">$k-1$</span> whose Folded Reed-Solomon encoding agrees with the received word <span class="LaTeX">$y$</span> in at least <span class="LaTeX">$t$</span> columns with <span class="LaTeX">$t>{{D+k-1}\over{m-s+1}}$</span>, then <span class="LaTeX">$Q(X,f(X),f(\gamma X),\cdots,f(\gamma_{s-1}X))=0$</span></p>
<p>Here "agree" means that all the <span class="LaTeX">$m$</span> values in a column should match the corresponding values in codeword <span class="LaTeX">$y$</span>. The details of the proof for this Lemma can be found in Guruswami's paper.</p>
<p>This lemma shows us that any such polynomial <span class="LaTeX">$Q(X,Y_1,Y_2,\ldots,Y_s)$</span> presents an algebraic condition that must be satisfied for those message polynomials <span class="LaTeX">$f(x)$</span> that we are interested in list decoding.</p>
<p>Combining Lemma 2 and parameter <span class="LaTeX">$D$</span>, we have<br/>
<span class="LaTeX">$t(m-s+1)>\dfrac{N(m-s+1)+s(k-1)}{s+1}$</span></p>
<p>Further we can get the decoding bound</p>
<p><span class="LaTeX">$$t\ge\frac{N}{s+1}+\frac{s}{s+1}\cdot\frac{k}{m-s+1}=N\left(\frac{1}{s+1}+\frac{s}{s+1}\cdot\frac{mR}{m-s+1}\right)$$</span></p>
<p>We notice that the fractional agreement is <span class="LaTeX">$\dfrac{1}{s+1} + \dfrac{s}{s+1} \cdot \dfrac{mR}{m-s+1}$</span></p>
<h3 id="step-2-the-root-finding-step">Step 2: The root-finding step</h3>
<p>During this step, our task focus on how to find all polynomials <span class="LaTeX">$f\in{\mathbb{F}_q[X]}$</span> with degree no more than <span class="LaTeX">$k-1$</span> and satisfy the equation we get from Step 1, namely</p>
<p><span class="LaTeX">$A_0(X) + A_1(X)f(X) + A_2(X)f(\gamma X) + \cdots + A_s(X)f(\gamma^{s-1}X)=0$</span></p>
<p>Since the above equation forms a linear system equations over <span class="LaTeX">$\mathbb{F}_q$</span> in the coefficients <span class="LaTeX">$f_0,f_1,\cdots,f_{k-1}$</span> of the polynomial <span class="LaTeX">$f(X) = f_0 + f_1X + \cdots + f_{k-1}X^{k-1}$</span>, the solutions to the above equation is an <a href="affine_subspace" title="wikilink">affine subspace</a> of <span class="LaTeX">$\mathbb{F}^k_q$</span>. This fact is the key point that gives rise to an efficient algorithm - we can solve the linear system.</p>
<p>It is natural to ask how large is the dimension of the solution? Is there any upper bound on the dimension? Having an upper bound is very important in constructing an efficient list decoding algorithm because one can simply output all the codewords for any given decoding problem.</p>
<p>Actually it indeed has an upper bound as below lemma argues.</p>
<p><strong>Lemma 3:</strong> If the order of <span class="LaTeX">$\gamma$</span> is at least <span class="LaTeX">$k$</span> (in particular when <span class="LaTeX">$\gamma$</span> is primitive), then the dimension of the solution is at most <span class="LaTeX">$s-1$</span>. (For the details of the proof, please refer to Guruswami's paper.)</p>
<p>This lemma shows us the upper bound of the dimension for the solution space.</p>
<p>Finally, based on the above analysis, we have below theorem</p>
<p><strong>Theorem 1:</strong> For the folded Reed–Solomon code <span class="LaTeX">$FRS^{(m)}_q[n,k]$</span> of block length <span class="LaTeX">$N=n/m$</span> and rate <span class="LaTeX">$R=k/n$</span>, the following holds for all integers <span class="LaTeX">$s$</span>, <span class="LaTeX">$1 \leq s \leq m$</span>. Given a received word <span class="LaTeX">$y \in (\mathbb{F}_q^m)^N$</span>, in <span class="LaTeX">$O((Nmlogq)^2)$</span> time, one can find a basis for a subspace of dimension at most <span class="LaTeX">$s-1$</span> that contains all message polynomials <span class="LaTeX">$f \in \mathbb{F}_q[X]$</span> of degree less than <span class="LaTeX">$k$</span> whose FRS encoding differs from <span class="LaTeX">$y$</span> in at most a fraction <span class="LaTeX">$\frac{s}{s+1}\left(1-\frac{mR}{m-s+1}\right)$</span> of the <span class="LaTeX">$N$</span> codeword positions.</p>
<p>When <span class="LaTeX">$s = m = 1$</span>, we notice that this reduces to a unique decoding algorithm with up to a fraction <span class="LaTeX">$(1-R)/2$</span> of errors. In other words, we can treat unique decoding algorithm as a specialty of list decoding algorithm. The quantity is about <span class="LaTeX">$n^{O(1/\varepsilon)}$</span> for the parameter choices that achieve a list decoding radius of <span class="LaTeX">$1-R-\varepsilon$</span>.</p>
<p>Theorem 1 tells us exactly how large the error radius would be.</p>
<p>Now we finally get the solution subspace. However, there is still one problem standing. The list size in the worst case is <span class="LaTeX">$n^{\Omega(1/\varepsilon)}$</span>. But the actual list of close-by codewords is only a small set within that subspace. So we need some process to prune the subspace to narrow it down. This prune process takes <span class="LaTeX">$q^s$</span> time in the worst case. Unfortunately it is not known how to improve the running time because we do not know how to improve the bound of the list size for folded Reed-Solomon code.</p>
<p>Things get better if we change the code by carefully choosing a subset of all possible degree <span class="LaTeX">$k -1$</span> polynomials as messages, the list size shows to be much smaller while only losing a little bit in the rate. We will talk about this briefly in next step.</p>
<h3 id="step-3-the-prune-step">Step 3: The prune step</h3>
<p>By converting the problem of decoding a folded Reed–Solomon code into two linear systems, one linear system that is used for the interpolation step and another linear system to find the candidate solution subspace, the complexity of the decoding problem is successfully reduced to quadratic. However, in the worst case, the bound of list size of the output is pretty bad.</p>
<p>It was mentioned in Step 2 that if one carefully chooses only a subset of all possible degree <span class="LaTeX">$k -1$</span> polynomials as messages, the list size can be much reduced. Here we will expand our discussion.</p>
<p>To achieve this goal, the idea is to limit the coefficient vector <span class="LaTeX">$(f_0,f_1,\ldots,f_{k-1})$</span> to a special subset <span class="LaTeX">$\nu \subseteq \mathbb{F}_q^k$</span>, which satisfies below two conditions:</p>
<p>'''Condition 1: ''' The set <span class="LaTeX">$\nu$</span> must be large enough (<span class="LaTeX">$|\nu| \geq q^{(1-\varepsilon)k}$</span>). This is to make sure that the rate will be at most reduced by factor of <span class="LaTeX">$(1-\varepsilon)$</span>.</p>
<p>'''Condition 2: ''' The set <span class="LaTeX">$\nu$</span> should have low intersection with any subspace of dimension <span class="LaTeX">$s$</span> satisfying that <span class="LaTeX">${S \subset \mathbb{F}_q^k}$</span> and <span class="LaTeX">${|S \cap \nu| \leq L}$</span>. Such a subset is called subspace-evasive subset.</p>
<p>The bound for the list size at worst case is <span class="LaTeX">$n^{\Omega(1/\varepsilon)}$</span>, and it can be reduced to a relative small bound <span class="LaTeX">$O(1/\varepsilon^2)$</span> by using subspace-evasive subsets.</p>
<p>During this step, as it has to check each element of the solution subspace that we get from Step 2, it takes <span class="LaTeX">$q^s$</span> time in the worst case (<span class="LaTeX">$s$</span> is the dimension of the solution subspace).</p>
<p>Dvir and Lovett improved the result based on the work of Guruswami, which can reduce the list size to a constant.</p>
<p>Here is only presented the idea that is used to prune the solution subspace. For the details of the prune process, please refer to papers by Guruswami, Dvir and Lovett, which are listed in the reference.</p>
<h3 id="summary">Summary</h3>
<p>If we don't consider the Step 3, this algorithm can run in quadratic time. A summary for this algorithm is listed below.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><p>Overview of Linear-algebraic list decoding algorithm for FRS code</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Steps</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Runtime</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>Error Radius</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>List Size</p></td>
</tr>
</tbody>
</table>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Reed–Solomon_error_correction" title="wikilink">Reed–Solomon error correction</a></li>
<li><a href="Singleton_bound" title="wikilink">Singleton bound</a></li>
<li><a href="Coding_theory" title="wikilink">Coding theory</a></li>
<li><a href="List_decoding" title="wikilink">List decoding</a></li>
</ul>
<h2 id="references">References</h2>
<ol>
<li><a href="http://www.cse.buffalo.edu/people/?u=atri">Atri Rudra</a>'s Lecture Notes: <a href="http://www.cse.buffalo.edu/~atri/courses/coding-theory/lectures/lect40.pdf">Folded Reed–Solomon Codes</a></li>
<li>Atri Rudra's Lecture Notes: <a href="http://www.cse.buffalo.edu/~atri/courses/coding-theory/book/chapters/chap4.pdf">Bounds</a></li>
<li>A paper by <a href="http://www.cse.buffalo.edu/people/?u=atri">Atri Rudra</a> and <a href="http://www.cs.cmu.edu/~venkatg/">Venkatesan Guruswami</a>: <a href="http://www.cse.buffalo.edu/~atri/papers/coding/folded-RS.pdf">Decoding Folded Reed–Solomon Codes</a></li>
<li>A chapter on List Decoding of folded Reed–Solomon codes: <a href="http://www.cse.buffalo.edu/~atri/papers/coding/thesis-chaps/chap3.pdf">List Decoding of Folded Reed–Solomon Codes</a></li>
<li>Venkatesan Guruswami's lecture notes: <a href="http://www.cs.cmu.edu/~venkatg/teaching/codingtheory/notes/notes4.pdf">Elementary bounds on codes</a></li>
<li>Venkatesan Guruswami's lecture notes: <a href="http://www.cs.cmu.edu/~venkatg/teaching/codingtheory/notes/notes11.pdf">List Decoding Folded Reed–Solomon Code</a></li>
<li></li>
<li></li>
<li>PHD Thesis by <a href="http://genealogy.math.ndsu.nodak.edu/id.php?id=152946">Kristian Brander</a>: <a href="http://orbit.dtu.dk/fedora/objects/orbit:82772/datastreams/file_5099076/content">Interpolation and List Decoding of Algebraic Codes</a></li>
<li></li>
</ol>
<p>"</p>
<p><a href="Category:Coding_theory" title="wikilink">Category:Coding theory</a> <a href="Category:Error_detection_and_correction" title="wikilink">Category:Error detection and correction</a> <a href="Category:Computational_complexity_theory" title="wikilink">Category:Computational complexity theory</a></p>
</body>
</html>
