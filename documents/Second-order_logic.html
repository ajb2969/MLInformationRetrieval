<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="186">Second-order logic</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Second-order logic</h1>
<hr/>

<p>In <a class="uri" href="logic" title="wikilink">logic</a> and <a class="uri" href="mathematics" title="wikilink">mathematics</a> <strong>second-order logic</strong> is an extension of <a href="first-order_logic" title="wikilink">first-order logic</a>, which itself is an extension of <a href="propositional_logic" title="wikilink">propositional logic</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Second-order logic is in turn extended by <a href="higher-order_logic" title="wikilink">higher-order logic</a> and <a href="type_theory" title="wikilink">type theory</a>.</p>

<p>First-order logic <a href="Quantification_(logic)" title="wikilink">quantifies</a> only variables that range over individuals (elements of the <a href="domain_of_discourse" title="wikilink">domain of discourse</a>); second-order logic, in addition, also quantifies over relations. For example, the second-order sentence 

<math display="inline" id="Second-order_logic:0">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mpadded width="+1.7pt">
    <mi>P</mi>
   </mpadded>
   <mo>∀</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>P</mi>
    <mo>∨</mo>
    <mi>x</mi>
    <mo>∉</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">P</csymbol>
     <or></or>
     <csymbol cd="unknown">x</csymbol>
     <notin></notin>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall P\,\forall x(x\in P\lor x\notin P)
  </annotation>
 </semantics>
</math>

 says that for every unary relation (or <a href="Set_(mathematics)" title="wikilink">set</a>) <em>P</em> of individuals and every individual <em>x</em>, either <em>x</em> is in <em>P</em> or it is not (this is the <a href="principle_of_bivalence" title="wikilink">principle of bivalence</a>). Second-order logic also includes quantification over functions, and other variables as explained in the section <em><a href="#Syntax_and_fragments" title="wikilink">Syntax and fragments</a></em> below. Both first-order and second-order logic use the idea of a <a href="domain_of_discourse" title="wikilink">domain of discourse</a> (often called simply the "domain" or the "universe"). The domain is a set of individual elements which can be quantified over.</p>
<h2 id="syntax-and-fragments">Syntax and fragments</h2>

<p>The syntax of second-order logic tells which expressions are well formed <a href="formula_(mathematical_logic)" title="wikilink">formulas</a>. In addition to the <a href="First-order_logic#Formation_rules" title="wikilink">syntax of first-order logic</a>, second-order logic includes many new <strong>sorts</strong> (sometimes called <strong>types</strong>) of variables. These are:</p>
<ul>
<li>A sort of variables that range over sets of individuals. If <em>S</em> is a variable of this sort and <em>t</em> is a first-order term then the expression <em>t</em> ∈ <em>S</em> (also written <em>S</em>(<em>t</em>), or <em>St</em> to save parentheses) is an <a href="atomic_formula" title="wikilink">atomic formula</a>. Sets of individuals can also be viewed as <a href="unary_relation" title="wikilink">unary relations</a> on the domain.</li>
<li>For each natural number <em>k</em> there is a sort of variables that ranges over all <em>k</em>-ary relations on the individuals. If <em>R</em> is such a <em>k</em>-ary relation variable and <em>t</em><sub>1</sub>,..., <em>t</em><sub><em>k</em></sub> are first-order terms then the expression <em>R</em>(<em>t</em><sub>1</sub>,...,<em>t</em><sub><em>k</em></sub>) is an atomic formula.</li>
<li>For each natural number <em>k</em> there is a sort of variables that ranges over all functions taking <em>k</em> elements of the domain and returning a single element of the domain. If <em>f</em> is such a <em>k</em>-ary function variable and <em>t</em><sub>1</sub>,...,<em>t</em><sub><em>k</em></sub> are first-order terms then the expression <em>f</em>(<em>t</em><sub>1</sub>,...,<em>t</em><sub><em>k</em></sub>) is a first-order term.</li>
</ul>

<p>Each of the variables just defined may be universally and/or existentially quantified over, to build up formulas. Thus there are many kinds of quantifiers, two for each sort of variables. A <strong>sentence</strong> in second-order logic, as in first-order logic, is a well-formed formula with no free variables (of any sort).</p>

<p>It's possible to forgo the introduction of function variables in the definition given above (and some authors do this) because an <em>n</em>-ary function variable can be represented by a relation variable of arity <em>n</em>+1 and an appropriate formula for the uniqueness of the "result" in the <em>n</em>+1 argument of the relation. (Shapiro 2000, p. 63)</p>

<p><strong>Monadic second-order logic</strong> (MSOL) is a restriction of second-order logic in which only quantification over unary relations (i.e.: sets) are allowed. Quantification over functions, owing to the equivalence to relations as described above, is thus also not allowed. The second-order logic without these restrictions is sometimes called <strong>full second-order logic</strong> to distinguish it from the monadic version.</p>

<p>Just as in first-order logic, second-order logic may include <a href="non-logical_symbols" title="wikilink">non-logical symbols</a> in a particular second-order language. These are restricted, however, in that all terms that they form must be either first-order terms (which can be substituted for a first-order variable) or second-order terms (which can be substituted for a second-order variable of an appropriate sort).</p>

<p>A formula in second-order logic is said to be of first-order (and sometimes denoted 

<math display="inline" id="Second-order_logic:1">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mn>0</mn>
   <mn>1</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{1}_{0}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Second-order_logic:2">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Π</mi>
   <mn>0</mn>
   <mn>1</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Π</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi^{1}_{0}
  </annotation>
 </semantics>
</math>

) if its quantifiers (which may be of either type) range only over variables of first order, although it may have free variables of second order. A 

<math display="inline" id="Second-order_logic:3">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mn>1</mn>
   <mn>1</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{1}_{1}
  </annotation>
 </semantics>
</math>

 (existential second-order) formula is one additionally having some existential quantifiers over second order variables, i.e. 

<math display="inline" id="Second-order_logic:4">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mrow>
    <msub>
     <mi>R</mi>
     <mn>0</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <msub>
       <mi>R</mi>
       <mi>m</mi>
      </msub>
      <mi>ϕ</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>m</ci>
       </apply>
       <ci>ϕ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists R_{0}\ldots\exists R_{m}\phi
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Second-order_logic:5">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 is a first-order formula. The fragment of second order logic consisting only of existential second-order formulas is called <strong>existential second-order logic</strong> and abbreviated as ESO, as 

<math display="inline" id="Second-order_logic:6">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mn>1</mn>
   <mn>1</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{1}_{1}
  </annotation>
 </semantics>
</math>

, or even as ∃SO. The fragment of 

<math display="inline" id="Second-order_logic:7">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Π</mi>
   <mn>1</mn>
   <mn>1</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Π</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi^{1}_{1}
  </annotation>
 </semantics>
</math>

 formulas is defined dually, it is called universal second-order logic. More expressive fragments are defined for any <em>k</em> &gt; 0 by mutual recursion

<math display="block" id="Second-order_logic:8">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mn>1</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{1}_{k+1}
  </annotation>
 </semantics>
</math>

 has the form 

<math display="inline" id="Second-order_logic:9">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mrow>
    <msub>
     <mi>R</mi>
     <mn>0</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <msub>
       <mi>R</mi>
       <mi>m</mi>
      </msub>
      <mi>ϕ</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>m</ci>
       </apply>
       <ci>ϕ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists R_{0}\ldots\exists R_{m}\phi
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Second-order_logic:10">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 is a 

<math display="inline" id="Second-order_logic:11">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Π</mi>
   <mi>k</mi>
   <mn>1</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Π</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi^{1}_{k}
  </annotation>
 </semantics>
</math>

 formula, and similar, 

<math display="inline" id="Second-order_logic:12">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Π</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mn>1</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Π</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi^{1}_{k+1}
  </annotation>
 </semantics>
</math>

 has the form 

<math display="inline" id="Second-order_logic:13">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mrow>
    <msub>
     <mi>R</mi>
     <mn>0</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <msub>
       <mi>R</mi>
       <mi>m</mi>
      </msub>
      <mi>ϕ</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>m</ci>
       </apply>
       <ci>ϕ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall R_{0}\ldots\forall R_{m}\phi
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Second-order_logic:14">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 is a 

<math display="inline" id="Second-order_logic:15">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mi>k</mi>
   <mn>1</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{1}_{k}
  </annotation>
 </semantics>
</math>

 formula. (See <a href="analytical_hierarchy" title="wikilink">analytical hierarchy</a> for the analogous construction of <a href="second-order_arithmetic" title="wikilink">second-order arithmetic</a>.)</p>
<h2 id="semantics">Semantics</h2>

<p>The semantics of second-order logic establish the meaning of each sentence. Unlike first-order logic, which has only one standard semantics, there are two different semantics that are commonly used for second-order logic: <strong>standard semantics</strong> and <strong>Henkin semantics</strong>. In each of these semantics, the interpretations of the first-order quantifiers and the logical connectives are the same as in first-order logic. Only the ranges of quantifiers over second-order variables differ in the two types of semantics <a href="#Vaananen2001" title="wikilink">(Väänänen 2001)</a>.</p>

<p>In standard semantics, also called full semantics, the quantifiers range over <em>all</em> sets or functions of the appropriate sort. Thus once the domain of the first-order variables is established, the meaning of the remaining quantifiers is fixed. It is these semantics that give second-order logic its expressive power, and they will be assumed for the remainder of this article.</p>

<p>In Henkin semantics, each sort of second-order variable has a particular domain of its own to range over, which may be a proper subset of all sets or functions of that sort. <a href="Leon_Henkin" title="wikilink">Leon Henkin</a> (1950) defined these semantics and proved that <a href="Gödel's_completeness_theorem" title="wikilink">Gödel's completeness theorem</a> and <a href="compactness_theorem" title="wikilink">compactness theorem</a>, which hold for first-order logic, carry over to second-order logic with Henkin semantics. This is because Henkin semantics are almost identical to many-sorted first-order semantics, where additional sorts of variables are added to simulate the new variables of second-order logic. Second-order logic with Henkin semantics is not more expressive than first-order logic. Henkin semantics are commonly used in the study of <a href="second-order_arithmetic" title="wikilink">second-order arithmetic</a>.</p>

<p>Väänänen <a href="#Vaananen2001" title="wikilink">(2001)</a> argued that the choice between Henkin models and full models for second-order logic is analogous to the choice between <a class="uri" href="ZFC" title="wikilink">ZFC</a> and <em><a href="Von_Neumann_universe" title="wikilink">V</a></em> as a basis for set theory: "As with second-order logic, we cannot really choose whether we axiomatize mathematics using <em>V</em> or ZFC. The result is the same in both cases, as ZFC <em>is</em> the best attempt so far to use <em>V</em> as an axiomatization of mathematics."</p>
<h2 id="expressive-power">Expressive power</h2>

<p>Second-order logic is more expressive than first-order logic. For example, if the domain is the set of all <a href="real_number" title="wikilink">real numbers</a>, one can assert in first-order logic the existence of an additive inverse of each real number by writing ∀<em>x</em> ∃<em>y</em> (<em>x</em> + <em>y</em> = 0) but one needs second-order logic to assert the <a href="Supremum" title="wikilink">least-upper-bound</a> property for sets of real numbers, which states that every bounded, nonempty set of real numbers has a <a class="uri" href="supremum" title="wikilink">supremum</a>. If the domain is the set of all real numbers, the following second-order sentence (split over two lines) expresses the least upper bound property:</p>
<dl>
<dd>(∀ A) ([ ∧ ]
<dl>
<dd>→ )
</dd>
</dl>
</dd>
</dl>

<p>This formula is a direct formalization of "every ,  set A ." It can be shown that any ordered field that satisfies this property is isomorphic to the real number field. On the other hand, the set of first-order sentences valid in the reals has arbitrarily large models due to the compactness theorem. Thus the least-upper-bound property cannot be expressed by any set of sentences in first-order logic. (In fact, every <a href="real-closed_field" title="wikilink">real-closed field</a> satisfies the same first-order sentences in the signature 

<math display="inline" id="Second-order_logic:16">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mo>+</mo>
   <mo>,</mo>
   <mo>⋅</mo>
   <mo>,</mo>
   <mo>≤</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <plus></plus>
    <ci>normal-⋅</ci>
    <leq></leq>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle+,\cdot,\leq\rangle
  </annotation>
 </semantics>
</math>

 as the real numbers.)</p>

<p>In second-order logic, it is possible to write formal sentences which say "the domain is <a href="finite_set" title="wikilink">finite</a>" or "the domain is of <a href="countable_set" title="wikilink">countable</a> <a class="uri" href="cardinality" title="wikilink">cardinality</a>." To say that the domain is finite, use the sentence that says that every <a class="uri" href="surjective" title="wikilink">surjective</a> function from the domain to itself is <a class="uri" href="injective" title="wikilink">injective</a>. To say that the domain has countable cardinality, use the sentence that says that there is a <a class="uri" href="bijection" title="wikilink">bijection</a> between every two infinite subsets of the domain. It follows from the <a href="compactness_theorem" title="wikilink">compactness theorem</a> and the <a href="upward_Löwenheim–Skolem_theorem" title="wikilink">upward Löwenheim–Skolem theorem</a> that it is not possible to characterize finiteness or countability, respectively, in first-order logic.</p>

<p>Certain fragments of second order logic like ESO are also more expressive than first-order logic even though they are strictly less expressive than the full second-order logic. ESO also enjoys translation equivalence with some extensions of first-order logic which allow non-linear ordering of quantifier dependencies, like first-order logic extended with <a href="Henkin_quantifier" title="wikilink">Henkin quantifiers</a>, <a class="uri" href="Hintikka" title="wikilink">Hintikka</a> and Sandu's <a href="independence-friendly_logic" title="wikilink">independence-friendly logic</a>, and Väänänen's <a href="dependence_logic" title="wikilink">dependence logic</a>.</p>
<h2 id="deductive-systems">Deductive systems</h2>

<p>A <a href="deductive_system" title="wikilink">deductive system</a> for a logic is a set of <a href="inference_rules" title="wikilink">inference rules</a> and logical axioms that determine which sequences of formulas constitute valid proofs. Several deductive systems can be used for second-order logic, although none can be complete for the standard semantics (see below). Each of these systems is <a href="soundness" title="wikilink">sound</a>, which means any sentence they can be used to prove is logically valid in the appropriate semantics.</p>

<p>The weakest deductive system that can be used consists of a standard deductive system for first-order logic (such as <a href="natural_deduction" title="wikilink">natural deduction</a>) augmented with substitution rules for second-order terms.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> This deductive system is commonly used in the study of <a href="second-order_arithmetic" title="wikilink">second-order arithmetic</a>.</p>

<p>The deductive systems considered by Shapiro (1991) and Henkin (1950) add to the augmented first-order deductive scheme both comprehension axioms and choice axioms. These axioms are sound for standard second-order semantics. They are sound for Henkin semantics if only Henkin models that satisfy the comprehension and choice axioms are considered.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="non-reducibility-to-first-order-logic">Non-reducibility to first-order logic</h2>

<p>One might attempt to reduce the second-order theory of the real numbers, with full second-order semantics, to the first-order theory in the following way. First expand the domain from the set of all real numbers to a two-sorted domain, with the second sort containing all <em>sets of</em> real numbers. Add a new binary predicate to the language: the membership relation. Then sentences that were second-order become first-order, with the formerly second-order quantifiers ranging over the second sort instead. This reduction can be attempted in a one-sorted theory by adding unary predicates that tell whether an element is a number or a set, and taking the domain to be the union of the set of real numbers and the <a href="power_set" title="wikilink">power set</a> of the real numbers.</p>

<p>But notice that the domain was asserted to include <strong><em>all</em></strong> sets of real numbers. That requirement cannot be reduced to a first-order sentence, as the <a href="Löwenheim–Skolem_theorem" title="wikilink">Löwenheim–Skolem theorem</a> shows. That theorem implies that there is some <a href="countably_infinite" title="wikilink">countably infinite</a> subset of the real numbers, whose members we will call <em>internal numbers</em>, and some countably infinite collection of sets of internal numbers, whose members we will call "internal sets", such that the domain consisting of internal numbers and internal sets satisfies exactly the same first-order sentences as are satisfied by the domain of real numbers and sets of real numbers. In particular, it satisfies a sort of least-upper-bound axiom that says, in effect:</p>
<dl>
<dd>Every nonempty <em>internal</em> set that has an <em>internal</em> upper bound has a least <em>internal</em> upper bound.
</dd>
</dl>

<p>Countability of the set of all internal numbers (in conjunction with the fact that those form a densely ordered set) implies that that set does not satisfy the full least-upper-bound axiom. Countability of the set of all <em>internal</em> sets implies that it is not the set of <em>all</em> subsets of the set of all <em>internal</em> numbers (since <a href="Cantor's_theorem" title="wikilink">Cantor's theorem</a> implies that the set of all subsets of a countably infinite set is an uncountably infinite set). This construction is closely related to <a href="Skolem's_paradox" title="wikilink">Skolem's paradox</a>.</p>

<p>Thus the first-order theory of real numbers and sets of real numbers has many models, some of which are countable. The second-order theory of the real numbers has only one model, however. This follows from the classical theorem that there is only one <a href="Archimedean_property" title="wikilink">Archimedean</a> <a href="real_number" title="wikilink">complete ordered field</a>, along with the fact that all the axioms of an Archimedean complete ordered field are expressible in second-order logic. This shows that the second-order theory of the real numbers cannot be reduced to a first-order theory, in the sense that the second-order theory of the real numbers has only one model but the corresponding first-order theory has many models.</p>

<p>There are more extreme examples showing that second-order logic with standard semantics is more expressive than first-order logic. There is a finite second-order theory whose only model is the real numbers if the <a href="continuum_hypothesis" title="wikilink">continuum hypothesis</a> holds and which has no model if the continuum hypothesis does not hold (cf. Shapiro 2000, p. 105). This theory consists of a finite theory characterizing the real numbers as a complete Archimedean ordered field plus an axiom saying that the domain is of the first uncountable cardinality. This example illustrates that the question of whether a sentence in second-order logic is consistent is extremely subtle.</p>

<p>Additional limitations of second order logic are described in the next section.</p>
<h2 id="metalogical-results">Metalogical results</h2>

<p>It is a corollary of <a href="Gödel's_incompleteness_theorem" title="wikilink">Gödel's incompleteness theorem</a> that there is no deductive system (that is, no notion of <em>provability</em>) for second-order formulas that simultaneously satisfies these three desired attributes:<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<ul>
<li>(<a class="uri" href="Soundness" title="wikilink">Soundness</a>) Every provable second-order sentence is universally valid, i.e., true in all domains under standard semantics.</li>
<li>(<a href="Completeness_(logic)" title="wikilink">Completeness</a>) Every universally valid second-order formula, under standard semantics, is provable.</li>
<li>(<a href="Decidability_(logic)" title="wikilink">Effectiveness</a>) There is a proof-checking algorithm that can correctly decide whether a given sequence of symbols is a proof or not.</li>
</ul>

<p>This corollary is sometimes expressed by saying that second-order logic does not admit a complete <a href="proof_theory" title="wikilink">proof theory</a>. In this respect second-order logic with standard semantics differs from first-order logic; <a href="W._V._Quine" title="wikilink">Quine</a> (1970, pp. 90–91) pointed to the lack of a complete proof system as a reason for thinking of second-order logic as not <em>logic</em>, properly speaking.</p>

<p>As mentioned above, Henkin proved that the standard deductive system for first-order logic is sound, complete, and effective for second-order logic with <a href="Higher-order_logic" title="wikilink"> Henkin semantics</a>, and the deductive system with comprehension and choice principles is sound, complete, and effective for Henkin semantics using only models that satisfy these principles.</p>

<p>The <a href="compactness_theorem" title="wikilink">compactness theorem</a> and the <a href="Löwenheim-Skolem_theorem" title="wikilink">Löwenheim-Skolem theorem</a> do not hold for full models of second-order logic. They do hold however for Henkin models. <a href="#Vaananen2001" title="wikilink">(Väänänen 2001)</a></p>
<h2 id="history-and-disputed-value">History and disputed value</h2>

<p>Predicate logic was primarily introduced to the mathematical community by <a href="Charles_Sanders_Peirce" title="wikilink">C. S. Peirce</a>, who coined the term <em>second-order logic</em> and whose notation is most similar to the modern form (Putnam 1982). However, today most students of logic are more familiar with the works of <a class="uri" href="Frege" title="wikilink">Frege</a>, who actually published his work several years prior to Peirce but whose works remained in obscurity until <a href="Bertrand_Russell" title="wikilink">Bertrand Russell</a> and <a href="Alfred_North_Whitehead" title="wikilink">Alfred North Whitehead</a> made them famous. Frege used different variables to distinguish quantification over objects from quantification over properties and sets; but he did not see himself as doing two different kinds of logic. After the discovery of <a href="Russell's_paradox" title="wikilink">Russell's paradox</a> it was realized that something was wrong with his system. Eventually logicians found that restricting Frege's logic in various ways—to what is now called <a href="First-order_predicate_calculus" title="wikilink">first-order logic</a>—eliminated this problem: sets and properties cannot be quantified over in first-order-logic alone. The now-standard hierarchy of orders of logics dates from this time.</p>

<p>It was found that <a href="set_theory" title="wikilink">set theory</a> could be formulated as an axiomatized system within the apparatus of first-order logic (at the cost of several kinds of <a href="completeness_(logic)" title="wikilink">completeness</a>, but nothing so bad as Russell's paradox), and this was done (see <a href="Zermelo-Fraenkel_set_theory" title="wikilink">Zermelo-Fraenkel set theory</a>), as sets are vital for <a class="uri" href="mathematics" title="wikilink">mathematics</a>. <a class="uri" href="Arithmetic" title="wikilink">Arithmetic</a>, <a class="uri" href="mereology" title="wikilink">mereology</a>, and a variety of other powerful logical theories could be formulated axiomatically without appeal to any more logical apparatus than first-order quantification, and this, along with Gödel and Skolem's adherence to first-order logic, led to a general decline in work in second (or any higher) order logic.</p>

<p>This rejection was actively advanced by some logicians, most notably <a href="W._V._Quine" title="wikilink">W. V. Quine</a>. Quine advanced the view that in predicate-language sentences like <em>Fx</em> the "<em>x</em>" is to be thought of as a variable or name denoting an object and hence can be quantified over, as in "For all things, it is the case that . . ." but the "<em>F</em>" is to be thought of as an <em>abbreviation</em> for an incomplete sentence, not the name of an object (not even of an <a href="abstract_object" title="wikilink">abstract object</a> like a property). For example, it might mean " . . . is a dog." But it makes no sense to think we can quantify over something like this. (Such a position is quite consistent with Frege's own arguments on the concept-object distinction). So to use a predicate as a variable is to have it occupy the place of a name which only individual variables should occupy. This reasoning has been rejected by Boolos.</p>

<p>In recent years second-order logic has made something of a recovery, buoyed by <a href="George_Boolos" title="wikilink">George Boolos</a>' interpretation of second-order quantification as <a href="plural_quantification" title="wikilink">plural quantification</a> over the same domain of objects as first-order quantification (Boolos 1984). Boolos furthermore points to the claimed <a class="uri" href="nonfirstorderizability" title="wikilink">nonfirstorderizability</a> of sentences such as "Some critics admire only each other" and "Some of Fianchetto's men went into the warehouse unaccompanied by anyone else" which he argues can only be expressed by the full force of second-order quantification. However, <a href="generalized_quantifier" title="wikilink">generalized quantification</a> and partially ordered, or branching, quantification may suffice to express a certain class of purportedly nonfirstorderizable sentences as well and it does not appeal to second-order quantification.</p>
<h2 id="relation-to-computational-complexity">Relation to computational complexity</h2>
<dl>
<dd>
</dd>
</dl>

<p>The expressive power of various forms of second-order logic on finite structures is intimately tied to <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>. The field of <a href="descriptive_complexity" title="wikilink">descriptive complexity</a> studies which computational <a href="complexity_class" title="wikilink">complexity classes</a> can be characterized by the power of the logic needed to express languages (sets of finite strings) in them. A string <em>w</em> = <em>w</em><sub>1</sub>···<em>w<sub>n</sub></em> in a finite alphabet <em>A</em> can be represented by a finite structure with domain <em>D</em> = {1,...,<em>n</em>}, unary predicates <em>P<sub>a</sub></em> for each <em>a</em> ∈ <em>A</em>, satisfied by those indices <em>i</em> such that <em>w<sub>i</sub></em> = <em>a</em>, and additional predicates which serve to uniquely identify which index is which (typically, one takes the graph of the successor function on <em>D</em> or the order relation </p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>

<p>. Reprinted in Boolos, <em>Logic, Logic and Logic</em>, 1998.</p></li>
<li></li>
<li></li>
<li>

<p>. Reprinted in Putnam, Hilary (1990), <em>Realism with a Human Face</em>, Harvard University Press, pp. 252–260.</p></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
</ul>

<p><a href="fr:Logique_d'ordre_supérieur#Logique_du_second_ordre" title="wikilink">fr:Logique d'ordre supérieur#Logique du second ordre</a>"</p>

<p><a href="Category:Systems_of_formal_logic" title="wikilink">Category:Systems of formal logic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Shapiro (1991) and Hinman (2005) give complete introductions to the subject, with full definitions.<a href="#fnref1">↩</a></li>
<li id="fn2">Such a system is used without comment by Hinman (2005).<a href="#fnref2">↩</a></li>
<li id="fn3">These are the models originally studied by Henkin (1950).<a href="#fnref3">↩</a></li>
<li id="fn4">The proof of this corollary is that a sound, complete, and effective deduction system for standard semantics could be used to produce a <a href="recursively_enumerable" title="wikilink">recursively enumerable</a> completion of <a href="Peano_arithmetic" title="wikilink">Peano arithmetic</a>, which Gödel's theorem shows cannot exist.<a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
