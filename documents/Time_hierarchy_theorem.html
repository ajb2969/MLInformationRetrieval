<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="777">Time hierarchy theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Time hierarchy theorem</h1>
<hr/>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, the <strong>time hierarchy theorems</strong> are important statements about time-bounded computation on <a href="Turing_machine" title="wikilink">Turing machines</a>. Informally, these theorems say that given more time, a Turing machine can solve more problems. For example, there are problems that can be solved with <em>n</em><sup>2</sup> time but not <em>n</em> time.</p>

<p>The time hierarchy theorem for <a href="Turing_machine" title="wikilink">deterministic multi-tape Turing machines</a> was first proven by <a href="Richard_E._Stearns" title="wikilink">Richard E. Stearns</a> and <a href="Juris_Hartmanis" title="wikilink">Juris Hartmanis</a> in 1965.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> It was improved a year later when F. C. Hennie and Richard E. Stearns improved the efficiency of the <a href="Universal_Turing_machine#Efficiency" title="wikilink">Universal Turing machine</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Consequent to the theorem, for every deterministic time-bounded <a href="complexity_class" title="wikilink">complexity class</a>, there is a strictly larger time-bounded complexity class, and so the time-bounded hierarchy of complexity classes does not completely collapse. More precisely, the time hierarchy theorem for deterministic Turing machines states that for all <a href="constructible_function" title="wikilink">time-constructible functions</a> <em>f</em>(<em>n</em>),</p>

<p>

<math display="block" id="Time_hierarchy_theorem:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐃𝐓𝐈𝐌𝐄</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>o</mi>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mrow>
          <mi>log</mi>
          <mi>f</mi>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mfrac>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>⊊</mo>
   <mrow>
    <mi>𝐃𝐓𝐈𝐌𝐄</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <prsubset></prsubset>
    <apply>
     <times></times>
     <ci>𝐃𝐓𝐈𝐌𝐄</ci>
     <apply>
      <times></times>
      <ci>o</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <log></log>
         <ci>f</ci>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>𝐃𝐓𝐈𝐌𝐄</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{DTIME}\left(o\left(\frac{f(n)}{\log f(n)}\right)\right)\subsetneq%
\mathbf{DTIME}(f(n))
  </annotation>
 </semantics>
</math>

.</p>

<p>The time hierarchy theorem for <a href="nondeterministic_Turing_machine" title="wikilink">nondeterministic Turing machines</a> was originally proven by <a href="Stephen_Cook" title="wikilink">Stephen Cook</a> in 1972.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> It was improved to its current form via a complex proof by Joel Seiferas, <a href="Michael_J._Fischer" title="wikilink">Michael Fischer</a>, and <a href="Albert_R._Meyer" title="wikilink">Albert Meyer</a> in 1978.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Finally in 1983, Stanislav Žák achieved the same result with the simple proof taught today.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The time hierarchy theorem for nondeterministic Turing machines states that if <em>g</em>(<em>n</em>) is a time-constructible function, and <em>f</em>(<em>n</em>) = <a href="Little_O_notation" title="wikilink">o</a>(<em>g</em>(<em>n</em>)), then</p>

<p>

<math display="block" id="Time_hierarchy_theorem:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐍𝐓𝐈𝐌𝐄</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⊊</mo>
   <mrow>
    <mi>𝐍𝐓𝐈𝐌𝐄</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <prsubset></prsubset>
    <apply>
     <times></times>
     <ci>𝐍𝐓𝐈𝐌𝐄</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>𝐍𝐓𝐈𝐌𝐄</ci>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{NTIME}(f(n))\subsetneq\mathbf{NTIME}(g(n))
  </annotation>
 </semantics>
</math>

.</p>

<p>The analogous theorems for space are the <a href="space_hierarchy_theorem" title="wikilink">space hierarchy theorems</a>. A similar theorem is not known for time-bounded probabilistic complexity classes, unless the class also has <a href="advice_(complexity)" title="wikilink">advice</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="background">Background</h2>

<p>Both theorems use the notion of a <a href="constructible_function" title="wikilink">time-constructible function</a>. A <a href="function_(mathematics)" title="wikilink">function</a> 

<math display="inline" id="Time_hierarchy_theorem:2">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>ℕ</mi>
    <mo>→</mo>
    <mi>ℕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>ℕ</ci>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\mathbb{N}\rightarrow\mathbb{N}
  </annotation>
 </semantics>
</math>

 is time-constructible if there exists a deterministic <a href="Turing_machine" title="wikilink">Turing machine</a> such that for every 

<math display="inline" id="Time_hierarchy_theorem:3">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>∈</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>n</ci>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\in\mathbb{N}
  </annotation>
 </semantics>
</math>

, if the machine is started with an input of <em>n</em> ones, it will halt after precisely <em>f</em>(<em>n</em>) steps. All <a href="polynomial" title="wikilink">polynomials</a> with non-negative integral coefficients are time-constructible, as are exponential functions such as 2<sup><em>n</em></sup>.</p>
<h2 id="proof-overview">Proof overview</h2>

<p>We need to prove that some time class <strong>TIME</strong>(<em>g</em>(<em>n</em>)) is strictly larger than some time class <strong>TIME</strong>(<em>f</em>(<em>n</em>)). We do this by constructing a machine which cannot be in <strong>TIME</strong>(<em>f</em>(<em>n</em>)), by <a href="Cantor's_diagonal_argument" title="wikilink">diagonalization</a>. We then show that the machine is in <strong>TIME</strong>(<em>g</em>(<em>n</em>)), using a <a href="Simulation#Computer_science" title="wikilink">simulator machine</a>.</p>
<h2 id="deterministic-time-hierarchy-theorem">Deterministic time hierarchy theorem</h2>
<h3 id="statement">Statement</h3>
<blockquote>

<p><strong>Time Hierarchy Theorem.</strong> If <em>f</em>(<em>n</em>) is a time-constructible function, then there exists a <a href="decision_problem" title="wikilink">decision problem</a> which cannot be solved in worst-case deterministic time <em>f</em>(<em>n</em>) but can be solved in worst-case deterministic time <em>f</em>(<em>n</em>)<sup>2</sup>. In other words,</p>

<p>

<math display="block" id="Time_hierarchy_theorem:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝐃𝐓𝐈𝐌𝐄</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊊</mo>
    <mrow>
     <mi>𝐃𝐓𝐈𝐌𝐄</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mi>f</mi>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <prsubset></prsubset>
    <apply>
     <times></times>
     <ci>𝐃𝐓𝐈𝐌𝐄</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>𝐃𝐓𝐈𝐌𝐄</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{DTIME}(f(n))\subsetneq\mathbf{DTIME}\left(f(n)^{2}\right).
  </annotation>
 </semantics>
</math>

</p>
</blockquote>

<p><strong>Note 1.</strong> <em>f</em>(<em>n</em>) is at least <em>n</em>, since smaller functions are never time-constructible.<br/>
<strong>Note 2.</strong> Even more generally, it can be shown that if <em>f</em>(<em>n</em>) is time-constructible, then</p>

<p>

<math display="block" id="Time_hierarchy_theorem:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝐃𝐓𝐈𝐌𝐄</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mi>o</mi>
       <mrow>
        <mo>(</mo>
        <mfrac>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>n</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mrow>
          <mrow>
           <mi>log</mi>
           <mi>f</mi>
          </mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>n</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mfrac>
        <mo>)</mo>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>⊊</mo>
    <mrow>
     <mi>𝐃𝐓𝐈𝐌𝐄</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <prsubset></prsubset>
    <apply>
     <times></times>
     <ci>𝐃𝐓𝐈𝐌𝐄</ci>
     <apply>
      <times></times>
      <ci>o</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <log></log>
         <ci>f</ci>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>𝐃𝐓𝐈𝐌𝐄</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{DTIME}\left(o\left(\frac{f(n)}{\log f(n)}\right)\right)\subsetneq%
\mathbf{DTIME}\left(f(n)\right).
  </annotation>
 </semantics>
</math>

 For example, there are problems solvable in time <em>n</em><sup>2</sup> but not time <em>n</em>, since <em>n</em> is in</p>

<p>

<math display="block" id="Time_hierarchy_theorem:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>o</mi>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <msup>
       <mi>n</mi>
       <mn>2</mn>
      </msup>
      <mrow>
       <mi>log</mi>
       <msup>
        <mi>n</mi>
        <mn>2</mn>
       </msup>
      </mrow>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <log></log>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o\left(\frac{n^{2}}{\log{n^{2}}}\right).
  </annotation>
 </semantics>
</math>

</p>
<h3 id="proof">Proof</h3>

<p>We include here a proof that <strong>DTIME</strong>(<em>f</em>(<em>n</em>)) is a strict subset of <strong>DTIME</strong>(<em>f</em>(2<em>n</em> + 1)<sup>3</sup>) as it is simpler. See the bottom of this section for information on how to extend the proof to <em>f</em>(<em>n</em>)<sup>2</sup>.</p>

<p>To prove this, we first define a language as follows:</p>

<p>

<math display="block" id="Time_hierarchy_theorem:7">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>f</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>M</mi>
       <mo stretchy="false">]</mo>
      </mrow>
      <mo>,</mo>
      <mi>x</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">|</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>M</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mtext>accepts</mtext>
      </mpadded>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mtext>in</mtext>
      </mpadded>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>x</mi>
        <mo stretchy="false">|</mo>
       </mrow>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
      <mtext>steps</mtext>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <interval closure="open">
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>M</ci>
      </apply>
      <ci>x</ci>
     </interval>
     <apply>
      <times></times>
      <ci>M</ci>
      <mtext>accepts</mtext>
      <ci>x</ci>
      <mtext>in</mtext>
      <ci>f</ci>
      <apply>
       <abs></abs>
       <ci>x</ci>
      </apply>
      <mtext>steps</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{f}=\left\{([M],x)\ |\ M\ \mbox{accepts}\ x\ \mbox{in}\ f(|x|)\ \mbox{steps}%
\right\}.
  </annotation>
 </semantics>
</math>

</p>

<p>Here, <em>M</em> is a deterministic Turing machine, and <em>x</em> is its input (the initial contents of its tape). [<em>M</em>] denotes an input that encodes the Turing machine <em>M</em>. Let <em>m</em> be the size of the tuple ([<em>M</em>], <em>x</em>).</p>

<p>We know that we can decide membership of <em>H<sub>f</sub></em> by way of a deterministic Turing machine that first calculates <em>f</em>(|<em>x</em>|), then writes out a row of 0s of that length, and then uses this row of 0s as a "clock" or "counter" to simulate <em>M</em> for at most that many steps. At each step, the simulating machine needs to look through the definition of <em>M</em> to decide what the next action would be. It is safe to say that this takes at most <em>f</em>(<em>m</em>)<sup>3</sup> operations, so</p>

<p>

<math display="block" id="Time_hierarchy_theorem:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>f</mi>
    </msub>
    <mo>∈</mo>
    <mrow>
     <mi>𝐓𝐈𝐌𝐄</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>m</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>3</mn>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>𝐓𝐈𝐌𝐄</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>m</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{f}\in\mathbf{TIME}(f(m)^{3}).
  </annotation>
 </semantics>
</math>

</p>

<p>The rest of the proof will show that</p>

<p>

<math display="block" id="Time_hierarchy_theorem:9">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>f</mi>
   </msub>
   <mo>∉</mo>
   <mrow>
    <mi>𝐓𝐈𝐌𝐄</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>⌊</mo>
        <mstyle displaystyle="false">
         <mfrac>
          <mi>m</mi>
          <mn>2</mn>
         </mfrac>
        </mstyle>
        <mo>⌋</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>𝐓𝐈𝐌𝐄</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <floor></floor>
       <apply>
        <divide></divide>
        <ci>m</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{f}\notin\mathbf{TIME}(f(\left\lfloor\tfrac{m}{2}\right\rfloor))
  </annotation>
 </semantics>
</math>

</p>

<p>so that if we substitute 2<em>n</em> + 1 for <em>m</em>, we get the desired result. Let us assume that <em>H<sub>f</sub></em> is in this time complexity class, and we will attempt to reach a contradiction.</p>

<p>If <em>H<sub>f</sub></em> is in this time complexity class, it means we can construct some machine <em>K</em> which, given some machine description [<em>M</em>] and input <em>x</em>, decides whether the tuple ([<em>M</em>], <em>x</em>) is in <em>H<sub>f</sub></em> within</p>

<p>

<math display="block" id="Time_hierarchy_theorem:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐓𝐈𝐌𝐄</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>⌊</mo>
        <mstyle displaystyle="false">
         <mfrac>
          <mi>m</mi>
          <mn>2</mn>
         </mfrac>
        </mstyle>
        <mo>⌋</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐓𝐈𝐌𝐄</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <floor></floor>
      <apply>
       <divide></divide>
       <ci>m</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{TIME}(f(\left\lfloor\tfrac{m}{2}\right\rfloor)).
  </annotation>
 </semantics>
</math>

</p>

<p>Therefore we can use this <em>K</em> to construct another machine, <em>N</em>, which takes a machine description [<em>M</em>] and runs <em>K</em> on the tuple ([<em>M</em>], [<em>M</em>]), and then accepts only if <em>K</em> rejects, and rejects if <em>K</em> accepts. If now <em>n</em> is the length of the input to <em>N</em>, then <em>m</em> (the length of the input to <em>K</em>) is twice <em>n</em> plus some delimiter symbol, so <em>m</em> = 2<em>n</em> + 1. <em>N</em>'s running time is thus</p>

<p>

<math display="block" id="Time_hierarchy_theorem:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝐓𝐈𝐌𝐄</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>⌊</mo>
         <mstyle displaystyle="false">
          <mfrac>
           <mi>m</mi>
           <mn>2</mn>
          </mfrac>
         </mstyle>
         <mo>⌋</mo>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>𝐓𝐈𝐌𝐄</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>⌊</mo>
         <mstyle displaystyle="false">
          <mfrac>
           <mrow>
            <mrow>
             <mn>2</mn>
             <mi>n</mi>
            </mrow>
            <mo>+</mo>
            <mn>1</mn>
           </mrow>
           <mn>2</mn>
          </mfrac>
         </mstyle>
         <mo>⌋</mo>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>𝐓𝐈𝐌𝐄</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>𝐓𝐈𝐌𝐄</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <floor></floor>
        <apply>
         <divide></divide>
         <ci>m</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>𝐓𝐈𝐌𝐄</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <floor></floor>
        <apply>
         <divide></divide>
         <apply>
          <plus></plus>
          <apply>
           <times></times>
           <cn type="integer">2</cn>
           <ci>n</ci>
          </apply>
          <cn type="integer">1</cn>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>𝐓𝐈𝐌𝐄</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{TIME}(f(\left\lfloor\tfrac{m}{2}\right\rfloor))=\mathbf{TIME}(f(\left%
\lfloor\tfrac{2n+1}{2}\right\rfloor))=\mathbf{TIME}(f(n)).
  </annotation>
 </semantics>
</math>

</p>

<p>Now if we feed [<em>N</em>] as input into <em>N</em> itself (which makes <em>n</em> the length of [<em>N</em>]) and ask the question whether <em>N</em> accepts its own description as input, we get:</p>
<ul>
<li>If <em>N</em> <strong>accepts</strong> [<em>N</em>] (which we know it does in at most <em>f</em>(<em>n</em>) operations), this means that <em>K</em> <strong>rejects</strong> ([<em>N</em>], [<em>N</em>]), so ([<em>N</em>], [<em>N</em>]) is not in <em>H<sub>f</sub></em>, and thus <em>N</em> does not accept [<em>N</em>] in <em>f</em>(<em>n</em>) steps. Contradiction!</li>
<li>If <em>N</em> <strong>rejects</strong> [<em>N</em>] (which we know it does in at most <em>f</em>(<em>n</em>) operations), this means that <em>K</em> <strong>accepts</strong> ([<em>N</em>], [<em>N</em>]), so ([<em>N</em>], [<em>N</em>]) <strong>is</strong> in <em>H<sub>f</sub></em>, and thus <em>N</em> <strong>does</strong> accept [<em>N</em>] in <em>f</em>(<em>n</em>) steps. Contradiction!</li>
</ul>

<p>We thus conclude that the machine <em>K</em> does not exist, and so</p>

<p>

<math display="block" id="Time_hierarchy_theorem:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>f</mi>
    </msub>
    <mo>∉</mo>
    <mrow>
     <mi>𝐓𝐈𝐌𝐄</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>⌊</mo>
         <mstyle displaystyle="false">
          <mfrac>
           <mi>m</mi>
           <mn>2</mn>
          </mfrac>
         </mstyle>
         <mo>⌋</mo>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>𝐓𝐈𝐌𝐄</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <floor></floor>
       <apply>
        <divide></divide>
        <ci>m</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{f}\notin\mathbf{TIME}(f(\left\lfloor\tfrac{m}{2}\right\rfloor)).
  </annotation>
 </semantics>
</math>

</p>
<h3 id="extension">Extension</h3>

<p>The reader may have realised that the proof is simpler because we have chosen a simple Turing machine simulation for which we can be certain that</p>

<p>

<math display="block" id="Time_hierarchy_theorem:13">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>f</mi>
    </msub>
    <mo>∈</mo>
    <mrow>
     <mi>𝐓𝐈𝐌𝐄</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>m</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>3</mn>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>𝐓𝐈𝐌𝐄</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>m</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{f}\in\mathbf{TIME}(f(m)^{3}).
  </annotation>
 </semantics>
</math>

</p>

<p>It has been shown<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> that a more efficient model of simulation exists which establishes that</p>

<p>

<math display="block" id="Time_hierarchy_theorem:14">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>f</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mi>𝐓𝐈𝐌𝐄</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>m</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mi>log</mi>
       <mi>f</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>m</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>𝐓𝐈𝐌𝐄</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>m</ci>
      <apply>
       <log></log>
       <ci>f</ci>
      </apply>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{f}\in\mathbf{TIME}(f(m)\log f(m))
  </annotation>
 </semantics>
</math>

</p>

<p>but since this model of simulation is rather involved, it is not included here.</p>
<h2 id="non-deterministic-time-hierarchy-theorem">Non-deterministic time hierarchy theorem</h2>

<p>If <em>g</em>(<em>n</em>) is a time-constructible function, and <em>f</em>(<em>n</em>+1) = <a href="Big_O_notation" title="wikilink">o</a>(<em>g</em>(<em>n</em>)), then there exists a decision problem which cannot be solved in non-deterministic time <em>f</em>(<em>n</em>) but can be solved in non-deterministic time <em>g</em>(<em>n</em>). In other words, the complexity class <strong><a class="uri" href="NTIME" title="wikilink">NTIME</a></strong>(<em>f</em>(<em>n</em>)) is a strict subset of <strong>NTIME</strong>(<em>g</em>(<em>n</em>)).</p>
<h2 id="consequences">Consequences</h2>

<p>The time hierarchy theorems guarantee that the deterministic and non-deterministic versions of the <a href="exponential_hierarchy" title="wikilink">exponential hierarchy</a> are genuine hierarchies: in other words <strong><a href="P_(complexity)" title="wikilink">P</a></strong> 

<math display="inline" id="Time_hierarchy_theorem:15">
 <semantics>
  <mo>⊊</mo>
  <annotation-xml encoding="MathML-Content">
   <prsubset></prsubset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subsetneq
  </annotation>
 </semantics>
</math>

 <strong><a class="uri" href="EXPTIME" title="wikilink">EXPTIME</a></strong> 

<math display="inline" id="Time_hierarchy_theorem:16">
 <semantics>
  <mo>⊊</mo>
  <annotation-xml encoding="MathML-Content">
   <prsubset></prsubset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subsetneq
  </annotation>
 </semantics>
</math>

 <strong><a class="uri" href="2-EXP" title="wikilink">2-EXP</a></strong> 

<math display="inline" id="Time_hierarchy_theorem:17">
 <semantics>
  <mo>⊊</mo>
  <annotation-xml encoding="MathML-Content">
   <prsubset></prsubset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subsetneq
  </annotation>
 </semantics>
</math>

 ... and <strong><a href="NP_(complexity)" title="wikilink">NP</a></strong> 

<math display="inline" id="Time_hierarchy_theorem:18">
 <semantics>
  <mo>⊊</mo>
  <annotation-xml encoding="MathML-Content">
   <prsubset></prsubset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subsetneq
  </annotation>
 </semantics>
</math>

 <strong><a class="uri" href="NEXPTIME" title="wikilink">NEXPTIME</a></strong> 

<math display="inline" id="Time_hierarchy_theorem:19">
 <semantics>
  <mo>⊊</mo>
  <annotation-xml encoding="MathML-Content">
   <prsubset></prsubset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subsetneq
  </annotation>
 </semantics>
</math>

 <strong>2-NEXP</strong> 

<math display="inline" id="Time_hierarchy_theorem:20">
 <semantics>
  <mo>⊊</mo>
  <annotation-xml encoding="MathML-Content">
   <prsubset></prsubset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subsetneq
  </annotation>
 </semantics>
</math>

 ....</p>

<p>For example, 

<math display="inline" id="Time_hierarchy_theorem:21">
 <semantics>
  <mrow>
   <mi>𝐏</mi>
   <mo>⊊</mo>
   <mi>𝐄𝐗𝐏𝐓𝐈𝐌𝐄</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <prsubset></prsubset>
    <ci>𝐏</ci>
    <ci>𝐄𝐗𝐏𝐓𝐈𝐌𝐄</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{P}\subsetneq\mathbf{EXPTIME}
  </annotation>
 </semantics>
</math>

 since 

<math display="inline" id="Time_hierarchy_theorem:22">
 <semantics>
  <mrow>
   <mi>𝐏</mi>
   <mo>⊆</mo>
   <mrow>
    <mi>𝐃𝐓𝐈𝐌𝐄</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mn>2</mn>
      <mi>n</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⊊</mo>
   <mrow>
    <mi>𝐃𝐓𝐈𝐌𝐄</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mn>2</mn>
      <mrow>
       <mn>2</mn>
       <mi>n</mi>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⊆</mo>
   <mi>𝐄𝐗𝐏𝐓𝐈𝐌𝐄</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <subset></subset>
     <ci>𝐏</ci>
     <apply>
      <times></times>
      <ci>𝐃𝐓𝐈𝐌𝐄</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <prsubset></prsubset>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>𝐃𝐓𝐈𝐌𝐄</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <ci>𝐄𝐗𝐏𝐓𝐈𝐌𝐄</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{P}\subseteq\mathbf{DTIME}(2^{n})\subsetneq\mathbf{DTIME}(2^{2n})%
\subseteq\mathbf{EXPTIME}
  </annotation>
 </semantics>
</math>

. Indeed 

<math display="inline" id="Time_hierarchy_theorem:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐃𝐓𝐈𝐌𝐄</mi>
    <mrow>
     <mo>(</mo>
     <msup>
      <mn>2</mn>
      <mi>n</mi>
     </msup>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>⊆</mo>
   <mrow>
    <mi>𝐃𝐓𝐈𝐌𝐄</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>o</mi>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <msup>
         <mn>2</mn>
         <mrow>
          <mn>2</mn>
          <mi>n</mi>
         </mrow>
        </msup>
        <mrow>
         <mn>2</mn>
         <mi>n</mi>
        </mrow>
       </mfrac>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>⊊</mo>
   <mrow>
    <mi>𝐃𝐓𝐈𝐌𝐄</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mn>2</mn>
      <mrow>
       <mn>2</mn>
       <mi>n</mi>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <subset></subset>
     <apply>
      <times></times>
      <ci>𝐃𝐓𝐈𝐌𝐄</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>𝐃𝐓𝐈𝐌𝐄</ci>
      <apply>
       <times></times>
       <ci>o</ci>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">2</cn>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>n</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <prsubset></prsubset>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>𝐃𝐓𝐈𝐌𝐄</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{DTIME}\left(2^{n}\right)\subseteq\mathbf{DTIME}\left(o\left(\frac{2^{2%
n}}{2n}\right)\right)\subsetneq\mathbf{DTIME}(2^{2n})
  </annotation>
 </semantics>
</math>

 form the time hierarchy theorem.</p>

<p>The theorem also guarantees that there are problems in <strong>P</strong> requiring arbitrary large exponents to solve; in other words, <strong>P</strong> does not collapse to <strong>DTIME</strong>(<em>n</em><sup><em>k</em></sup>) for any fixed <em>k</em>. For example, there are problems solvable in <em>n</em><sup>5000</sup> time but not <em>n</em><sup>4999</sup> time. This is one argument against <a href="Cobham's_thesis" title="wikilink">Cobham's thesis</a>, the convention that <strong>P</strong> is a practical class of algorithms. If such a collapse did occur, we could deduce that <strong>P</strong> ≠ <strong>PSPACE</strong>, since it is a well-known theorem that <strong>DTIME</strong>(<em>f</em>(<em>n</em>)) is strictly contained in <strong>DSPACE</strong>(<em>f</em>(<em>n</em>)).</p>

<p>However, the time hierarchy theorems provide no means to relate deterministic and non-deterministic complexity, or time and space complexity, so they cast no light on the great unsolved questions of <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>: whether <a href="P_=_NP_problem" title="wikilink"><strong>P</strong> and <strong>NP</strong></a>, <strong>NP</strong> and <strong><a class="uri" href="PSPACE" title="wikilink">PSPACE</a></strong>, <strong>PSPACE</strong> and <strong>EXPTIME</strong>, or <strong>EXPTIME</strong> and <strong>NEXPTIME</strong> are equal or not.</p>
<h2 id="see-also">See Also</h2>
<ul>
<li><a href="Space_hierarchy_theorem" title="wikilink">Space hierarchy theorem</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>

<p>Pages 310–313 of section 9.1: Hierarchy theorems.</p></li>
<li>

<p>Section 7.2: The Hierarchy Theorem, pp. 143–146.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Structural_complexity_theory" title="wikilink">Category:Structural complexity theory</a> <a href="Category:Theorems_in_computational_complexity_theory" title="wikilink">Category:Theorems in computational complexity theory</a> <a href="Category:Articles_containing_proofs" title="wikilink">Category:Articles containing proofs</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7">Luca Trevisan, <a href="http://www.cs.berkeley.edu/~luca/cs172/noteh.pdf">Notes on Hierarchy Theorems</a>, U.C. Berkeley<a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
