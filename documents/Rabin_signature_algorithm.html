<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="696">Rabin signature algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Rabin signature algorithm</h1>
<hr/>

<p>In <a class="uri" href="cryptography" title="wikilink">cryptography</a> the <strong>Rabin Signature Scheme</strong> is a method of <a href="Digital_signature" title="wikilink">Digital signature</a> originally proposed by <a href="Michael_O._Rabin" title="wikilink">Michael O. Rabin</a> in 1979. The Rabin Signature Scheme was one of the first digital signature schemes proposed, and it was the first to relate the hardness of forgery directly to the problem of integer factorization. Because of its simplicity and prominent role in early public key cryptography, the Rabin Signature Scheme is covered in most introductory courses on cryptography. The Rabin Signature Scheme is <a href="Existential_forgery" title="wikilink">existentially unforgeable</a> in the <a href="random_oracle" title="wikilink">random oracle</a> model assuming the <a href="integer_factorization" title="wikilink">integer factorization</a> problem is intractable. The Rabin Signature Scheme is also closely related to the <a href="Rabin_cryptosystem" title="wikilink">Rabin cryptosystem</a>.</p>
<h2 id="original-algorithm">Original Algorithm</h2>

<p>The algorithm relies on a collision-resistant hash function 

<math display="inline" id="Rabin_signature_algorithm:0">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo>*</mo>
    </msup>
    <mo>→</mo>
    <msup>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">}</mo>
     </mrow>
     <mi>k</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>H</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
      <times></times>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H:\{0,1\}^{*}\rightarrow\{0,1\}^{k}
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li><strong>Key Generation</strong>
<ul>
<li>The signer <em>S</em> chooses primes <em>p</em>,<em>q</em> each of size approximately <em>k/2</em> bits, and computes the product 

<math display="inline" id="Rabin_signature_algorithm:1">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mi>p</mi>
    <mi>q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=pq
  </annotation>
 </semantics>
</math>

</li>
<li><em>S</em> then chooses a random <em>b</em> in 

<math display="inline" id="Rabin_signature_algorithm:2">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mi>n</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">1</cn>
    <ci>normal-…</ci>
    <ci>n</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{1,\ldots,n\}
  </annotation>
 </semantics>
</math>

.</li>
<li>The public key is <em>(n,b)</em></li>
<li>The private key is <em>(p,q)</em></li>
</ul></li>
</ul>
<ul>
<li><strong>Signing</strong>
<ul>
<li>To sign a message <em>m</em> the signer <em>S</em> picks random padding <em>U</em> and calculates <em>H(mU)</em></li>
<li><em>S</em> then solves 

<math display="inline" id="Rabin_signature_algorithm:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>+</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>H</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>m</mi>
       <mi>U</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <times></times>
      <ci>H</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>U</ci>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(x+b)=H(mU)\mod n
  </annotation>
 </semantics>
</math>

</li>
<li>If there is no solution <em>S</em> picks a new pad <em>U</em> and tries again. If <em>H</em> is truly random the expected number of tries is 4.</li>
<li>The signature on <em>m</em> is the pair <em>(U,x)</em></li>
</ul></li>
</ul>
<ul>
<li><strong>Verification</strong>
<ul>
<li>Given a message <em>m</em> and a signature <em>(U,x)</em> the verifier <em>V</em> calculates <em>x(x+b)</em> and <em>H(mU)</em> and verifies that they are equal</li>
</ul></li>
</ul>
<h2 id="modern-terminology">Modern Terminology</h2>

<p>In modern presentations, the algorithm is often simplified as follows</p>

<p>The hash function <em>H</em> is assumed to be a <a href="random_oracle" title="wikilink">random oracle</a> and the algorithm works as follows</p>
<ul>
<li><strong>Key Generation</strong>
<ul>
<li>The signer <em>S</em> chooses primes <em>p</em>,<em>q</em> each of size approximately <em>k/2</em> bits, and computes the product 

<math display="inline" id="Rabin_signature_algorithm:4">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mi>p</mi>
    <mi>q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=pq
  </annotation>
 </semantics>
</math>

</li>
<li>The public key is <em>n</em></li>
<li>The private key is <em>(p,q)</em></li>
</ul></li>
</ul>
<ul>
<li><strong>Signing</strong>
<ul>
<li>To sign a message <em>m</em> the signer <em>S</em> picks random padding <em>U</em> and calculates <em>H(mU)</em></li>
<li>If <em>H(mU)</em> is not a square modulo <em>n</em>, <em>S</em> picks a new pad <em>U</em></li>
<li><em>S</em> solves the equation 

<math display="inline" id="Rabin_signature_algorithm:5">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>H</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>m</mi>
       <mi>U</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <times></times>
      <ci>H</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>U</ci>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}=H(mU)\mod n
  </annotation>
 </semantics>
</math>

</li>
<li>The signature on <em>m</em> is the pair <em>(U,x)</em></li>
</ul></li>
</ul>
<ul>
<li><strong>Verification</strong>
<ul>
<li>Given a message <em>m</em> and a signature <em>(U,x)</em> the verifier <em>V</em> calculates <em>x</em><sup>2</sup> and <em>H(mU)</em> and verifies that they are equal</li>
</ul></li>
</ul>

<p>In some treatments, the random pad <em>U</em> is eliminated and instead we add two numbers <em>a</em> and <em>b</em> to the public key with 

<math display="inline" id="Rabin_signature_algorithm:6">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mfrac>
     <mi>a</mi>
     <mi>p</mi>
    </mfrac>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mfrac>
      <mi>a</mi>
      <mi>q</mi>
     </mfrac>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <ci>a</ci>
      <ci>p</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <ci>a</ci>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\tfrac{a}{p})=-(\tfrac{a}{q})=1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Rabin_signature_algorithm:7">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mfrac>
     <mi>b</mi>
     <mi>q</mi>
    </mfrac>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mfrac>
      <mi>b</mi>
      <mi>p</mi>
     </mfrac>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <ci>b</ci>
      <ci>q</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <ci>b</ci>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\tfrac{b}{q})=-(\tfrac{b}{p})=1
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Rabin_signature_algorithm:8">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mo>⋅</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⋅</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\cdot)
  </annotation>
 </semantics>
</math>

 denotes the <a href="legendre_symbol" title="wikilink">legendre symbol</a>. Then for any <em>r</em> modulo <em>n</em> exactly one of the four numbers 

<math display="inline" id="Rabin_signature_algorithm:9">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>,</mo>
   <mrow>
    <mi>a</mi>
    <mi>r</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>b</mi>
    <mi>r</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>a</mi>
    <mi>b</mi>
    <mi>r</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>r</ci>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <times></times>
     <ci>b</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>b</ci>
     <ci>r</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r,ar,br,abr
  </annotation>
 </semantics>
</math>

 will be a square, and the signer chooses that one for his signature.</p>
<h2 id="security">Security</h2>

<p>If <em>H</em> is a random oracle, i.e. its output is truly random in 

<math display="inline" id="Rabin_signature_algorithm:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <ci>n</ci>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/n\mathbb{Z}
  </annotation>
 </semantics>
</math>

 then, forging a signature on any message <em>m</em> is as hard as calculating the square root of a random element in 

<math display="inline" id="Rabin_signature_algorithm:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <ci>n</ci>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/n\mathbb{Z}
  </annotation>
 </semantics>
</math>

. To see that taking a random square root is as hard as factoring, we first note that any square modulo <em>n</em> has four square roots since <em>n</em> has two square roots modulo <em>p</em> and two square roots modulo <em>q</em>, and each pair gives a unique square root modulo <em>n</em> by the <a href="chinese_remainder_theorem" title="wikilink">chinese remainder theorem</a>. Now, if we have two different square roots, <em>x</em>,<em>y</em> such that 

<math display="inline" id="Rabin_signature_algorithm:12">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>y</mi>
     <mn>2</mn>
    </msup>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}=y^{2}\mod n
  </annotation>
 </semantics>
</math>

 but 

<math display="inline" id="Rabin_signature_algorithm:13">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≠</mo>
   <mrow>
    <mrow>
     <mo>±</mo>
     <mi>y</mi>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <csymbol cd="latexml">plus-or-minus</csymbol>
      <ci>y</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\neq\pm y\mod n
  </annotation>
 </semantics>
</math>

, then this immediately leads to a factorization of <em>n</em> since <em>n</em> divides 

<math display="inline" id="Rabin_signature_algorithm:14">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <msup>
     <mi>y</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>+</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}-y^{2}=(x-y)(x+y)
  </annotation>
 </semantics>
</math>

 but it does not divide either factor. Thus taking 

<math display="inline" id="Rabin_signature_algorithm:15">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mi>c</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>x</mi>
     <mo>±</mo>
     <mi>y</mi>
    </mrow>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>c</ci>
    <ci>d</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="latexml">plus-or-minus</csymbol>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   gcd(x\pm y,n)
  </annotation>
 </semantics>
</math>

 will lead to a nontrivial factorization of <em>n</em>. Now, there exists an algorithm to take square roots, we pick a random <em>r</em> modulo <em>n</em> and square it 

<math display="inline" id="Rabin_signature_algorithm:16">
 <semantics>
  <mrow>
   <msup>
    <mi>r</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>R</mi>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>r</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <ci>R</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{2}=R\mod n
  </annotation>
 </semantics>
</math>

, then, using the algorithm to take the square root of <em>R</em> modulo <em>n</em>, we will get a new square root 

<math display="inline" id="Rabin_signature_algorithm:17">
 <semantics>
  <msup>
   <mi>r</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>r</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{\prime}
  </annotation>
 </semantics>
</math>

, and with probability half 

<math display="inline" id="Rabin_signature_algorithm:18">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>≠</mo>
   <mrow>
    <mrow>
     <mo>±</mo>
     <msup>
      <mi>r</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>r</ci>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <csymbol cd="latexml">plus-or-minus</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>r</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\neq\pm r^{\prime}\mod n
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="http://publications.csail.mit.edu/lcs/pubs/pdf/MIT-LCS-TR-212.pdf">Original Paper</a></li>
</ul>

<p>"</p>

<p><a href="Category:Digital_signature_schemes" title="wikilink">Category:Digital signature schemes</a></p>
</body>
</html>
