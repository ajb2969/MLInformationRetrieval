   Controlled grammar      Controlled grammar   Controlled grammars 1 are a class of grammars that extend, usually, the context-free grammars with additional controls on the derivations of a sentence in the language. A number of different kinds of controlled grammars exist, the four main divisions being Indexed grammars , grammars with prescribed derivation sequences, grammars with contextual conditions on rule application, and grammars with parallelism in rule application. Because indexed grammars are so well established in the field, this article will address only the latter three kinds of controlled grammars.  Control by prescribed sequences  Grammars with prescribed sequences are grammars in which the sequence of rule application is constrained in some way. There are four different versions of prescribed sequence grammars: language controlled grammars (often called just controlled grammars), matrix grammars, vector grammars, and programmed grammars.  In the standard context-free grammar formalism, a grammar itself is viewed as a 4-tuple,    G  =   (  N  ,  T  ,  S  ,  P  )       G   N  T  S  P     G=(N,T,S,P)   , where N is a set of non-terminal/phrasal symbols, T is a disjoint set of terminal/word symbols, S is a specially designated start symbol chosen from N , and P is a set of production rules like    X  →  α     normal-→  X  α    X\to\alpha   , where X is some member of N , and   α   α   \alpha   is some member of     (   N  ∪  T   )   *     superscript    N  T      (N\cup T)^{*}   .  Productions over such a grammar are sequences of rules in P that, when applied in order of the sequence, lead to a terminal string. That is, one can view the set of imaginable derivations in G as the set    {    p  1    p  2   …   p  n    :   n  ≥  0   }     conditional-set     subscript  p  1    subscript  p  2   normal-…   subscript  p  n      n  0     \{p_{1}p_{2}...p_{n}:n\geq 0\}   , and the language of G as being the set of terminal strings     L   (  G  )    =   {   w  ∈   T  *    :   S   ⇒   p  1    …   ⇒   p  n    w   }         L  G    conditional-set    w   superscript  T         subscript  normal-⇒   subscript  p  1    S  normal-…     subscript  normal-⇒   subscript  p  n      w       L(G)=\{w\in T^{*}:S\Rightarrow_{p_{1}}...\Rightarrow_{p_{n}}w\}   . Control grammars take seriously this definition of the language generated by a grammar, concretizing the set-of-derivations as an aspect of the grammar. Thus, a prescribed sequence controlled grammar is at least approximately a 5-tuple    G  =   (  N  ,  T  ,  S  ,  P  ,  R  )       G   N  T  S  P  R     G=(N,T,S,P,R)   where everything except R is the same as in a CFG, and R is an infinite set of valid derivation sequences     p  1    p  2   …   p  n        subscript  p  1    subscript  p  2   normal-…   subscript  p  n     p_{1}p_{2}...p_{n}   .  The set R , due to its infinitude, is almost always (though not necessarily) described via some more convenient mechanism, such as a grammar (as in language controlled grammars), or a set of matrices or vectors (as in matrix and vector grammars). The different variations of prescribed sequence grammars thus differ by how the sequence of derivations is defined on top of the context-free base. Because matrix grammars and vector grammars are essentially special cases of language controlled grammars, examples of the former two will not be provided below.  Language controlled grammars  Language controlled grammars are grammars in which the production sequences constitute a well-defined language of arbitrary nature, usually though not necessarily regular, over a set of (again usually though not necessarily) context-free production rules. They also often have a sixth set in the grammar tuple, making it    G  =   (  N  ,  T  ,  S  ,  P  ,  R  ,  F  )       G   N  T  S  P  R  F     G=(N,T,S,P,R,F)   , where F is a set of productions that are allowed to apply vacuously. This version of language controlled grammars, ones with what is called "appearance checking", is the one henceforth.  Proof-theoretic description  We let a regularly controlled context-free grammar with appearance checking be a 6-tuple    G  =   (  N  ,  T  ,  S  ,  P  ,  R  ,  F  )       G   N  T  S  P  R  F     G=(N,T,S,P,R,F)   where N , T , S , and P are defined as in CFGs, R is a subset of P* constituting a regular language over P , and F is some subset of P . We then define the immediately derives relation    ⇒   p  i      subscript  normal-⇒   subscript  p  i     \Rightarrow_{p_{i}}   as follows:  Given some strings x and y , both in     (   N  ∪  T   )   *     superscript    N  T      (N\cup T)^{*}   , and some rule    p  =  A  →  w  ∈  P        p  A    normal-→    w       P     p=A\to w\in P   ,      x   ⇒  p   a  c    y      subscript   superscript  normal-⇒    a  c    p   x  y    x\Rightarrow^{ac}_{p}y     holds if either      x  =    x  1   A   x  2        x     subscript  x  1   A   subscript  x  2      x=x_{1}Ax_{2}   and    y  =    y  1   w   y  2        y     subscript  y  1   w   subscript  y  2      y=y_{1}wy_{2}   , or      x  =  y      x  y    x=y   and    p  ∈  F      p  F    p\in F     Intuitively, this simply spells out that a rule can apply to a string if the rule's left-hand-side appears in that string, or if the rule is in the set of "vacuously applicable" rules which can "apply" to a string without changing anything. This requirement that the non-vacuously applicable rules must apply is the appearance checking aspect of such a grammar. The language for this kind of grammar is then simply set of terminal strings     L   (  G  )    =   {   w  ∈   T  *    :    S   ⇒   p  1    a  c     w  1    ⇒   p  2    a  c     w  2    ⇒   p  3    a  c    …   ⇒   p  n    a  c    w   ,    f  o   r   s  o  m   e    p  1    p  2   …   p  n    ∈  R    }         L  G    conditional-set    w   superscript  T      formulae-sequence      subscript   superscript  normal-⇒    a  c     subscript  p  1    S   subscript  w  1      subscript   superscript  normal-⇒    a  c     subscript  p  2       subscript  w  2      subscript   superscript  normal-⇒    a  c     subscript  p  3      normal-…     subscript   superscript  normal-⇒    a  c     subscript  p  n      w        f  o  r  s  o  m  e   subscript  p  1    subscript  p  2   normal-…   subscript  p  n    R       L(G)=\{w\in T^{*}:S\Rightarrow^{ac}_{p_{1}}w_{1}\Rightarrow^{ac}_{p_{2}}w_{2}%
 \Rightarrow^{ac}_{p_{3}}...\Rightarrow^{ac}_{p_{n}}w,\ for\ some\ p_{1}p_{2}..%
 .p_{n}\in R\}   .  Example  Let's consider a simple (though not the simplest) context-free grammar that generates the language    {   a  n   :   n  ≥  1   }     conditional-set   superscript  a  n     n  1     \{a^{n}:n\geq 1\}   :  Let    G  =   (   {  S  ,  A  ,  X  }   ,   {  a  }   ,  S  ,   {  f  ,  g  ,  h  ,  k  ,  l  }   )       G    S  A  X    a   S   f  g  h  k  l      G=(\{S,A,X\},\{a\},S,\{f,g,h,k,l\})   , where      f  :   S  →   A  A       normal-:  f   normal-→  S    A  A      f:S\to AA         g  :   S  →  X      normal-:  g   normal-→  S  X     g:S\to X         h  :   A  →  S      normal-:  h   normal-→  A  S     h:A\to S         k  :   A  →  X      normal-:  k   normal-→  A  X     k:A\to X         l  :   S  →  a      normal-:  l   normal-→  S  a     l:S\to a     In language controlled form, this grammar is simply     G  ′   =   (   {  S  ,  A  ,  X  }   ,   {  a  }   ,  S  ,   {  f  ,  g  ,  h  ,  k  ,  l  }   ,    (   f   |  g  |   h   |  k  |   l   )   *   ,   {  f  ,  g  ,  h  ,  k  ,  l  }   )        superscript  G  normal-′     S  A  X    a   S   f  g  h  k  l    superscript    f    g   h    k   l      f  g  h  k  l      G^{\prime}=(\{S,A,X\},\{a\},S,\{f,g,h,k,l\},(f|g|h|k|l)^{*},\{f,g,h,k,l\})   (where     (   f   |  g  |   h   |  k  |   l   )   *     superscript    f    g   h    k   l      (f|g|h|k|l)^{*}   is a regular expression denoting the set of all sequences of production rules). A simple modification to this grammar, changing is control sequence set R into the set      (    f  *   g   h  *   k   )   *    l  *        superscript     superscript  f    g   superscript  h    k      superscript  l      (f^{*}gh^{*}k)^{*}l^{*}   , and changing its vacuous rule set F to    {  g  ,  k  }     g  k    \{g,k\}   , yields a grammar which generates the non-CF language    {   a   2  n    :   n  ≥  0   }     conditional-set   superscript  a   superscript  2  n      n  0     \{a^{2^{n}}:n\geq 0\}   . To see how, let's consider the general case of some string with n instances of S in it, i.e.    S  n     superscript  S  n    S^{n}   (the special case    S  1     superscript  S  1    S^{1}   trivially derives the string a which is    a   2  0      superscript  a   superscript  2  0     a^{2^{0}}   , an uninteresting fact).  If we chose some arbitrary production sequence     f  u   g   h  v   k  …       superscript  f  u   g   superscript  h  v   k  normal-…    f^{u}gh^{v}k...   , we can consider three possibilities    n  =  u      n  u    n=u   ,    n  <  u      n  u    n   , and    n  >  u      n  u    n>u   When    n  =  u      n  u    n=u   we rewrite all n instances of S as AA , by applying rule f to the string u times, and proceed to apply g , which applies vacuously (by virtue of being in F ) . When    n  <  u      n  u    n   , we rewrite all n instances of S as AA , and then try to perform the n+1 rewrite using rule f , but this fails because there are no more S s to rewrite, and f is not in F and so cannot apply vacuously, thus when    n  <  u      n  u    n   , the derivation fails. Lastly, then    n  >  u      n  u    n>u   , we rewrite u instances of S , leaving at least one instance of S to be rewritten by the subsequent application of g , rewriting S as X . Given that no rule of this grammar ever rewrites X , such a derivation is destined to never produce a terminal string. Thus only derivations with    n  =  u      n  u    n=u   will ever successfully rewrite the string    S  n     superscript  S  n    S^{n}   . Similar reasoning holds of the number of A s and v . In general, then, we can say that the only valid derivations have the structure     S  n    ⇒  f   …   ⇒  f    A   2  n    ⇒   g   A   2  n     ⇒   h  …   ⇒   h   S   2  n     ⇒   k   S   2  n           subscript  normal-⇒  f    superscript  S  n   normal-…     subscript  normal-⇒  f      superscript  A    2  n      normal-⇒      g   superscript  A    2  n       normal-⇒      h  normal-…     normal-⇒      h   superscript  S    2  n       normal-⇒      k   superscript  S    2  n        S^{n}\Rightarrow_{f}...\Rightarrow_{f}A^{2n}\Rightarrow{g}A^{2n}\Rightarrow{h}%
 ...\Rightarrow{h}S^{2n}\Rightarrow{k}S^{2n}   will produce terminal strings of the grammar. The X rules, combined with the structure of the control, essentially force all S s to be rewritten as AA s prior to any A s being rewritten as S s, which again is forced to happen prior to all still later iterations over the S-to-AA cycle. Finally, the S s are rewritten as a s. In this way, the number of S s doubles each for each instantiation of     f  8   g   h  *   k       superscript  f  8   g   superscript  h    k    f^{8}gh^{*}k   that appears in a terminal-deriving sequence.  Choosing two random non-terminal deriving sequences, and one terminal-deriving one, we can see this in work:  Let     s  1   =   f  f  g  h  k  l  l        subscript  s  1     f  f  g  h  k  l  l     s_{1}=ffghkll   , then we get the failed derivation:      S   ⇒  f   a  c     A  A    ⇒  f   a  c    failure: f cannot apply, no S to rewrite        subscript   superscript  normal-⇒    a  c    f   S    A  A      subscript   superscript  normal-⇒    a  c    f     failure: f cannot apply, no S to rewrite     S\Rightarrow^{ac}_{f}AA\Rightarrow^{ac}_{f}\text{failure: f cannot apply, no S%
  to rewrite}     Let     s  2   =   f  g  h  h  h  k  l  l        subscript  s  2     f  g  h  h  h  k  l  l     s_{2}=fghhhkll   , then we get the failed derivation:      S   ⇒  f   a  c     A  A    ⇒  g   a  c     A  A    ⇒  h   a  c     S  A    ⇒  h   a  c     S  S    ⇒  h   a  c    failure: h cannot apply, no A to rewrite        subscript   superscript  normal-⇒    a  c    f   S    A  A      subscript   superscript  normal-⇒    a  c    g       A  A      subscript   superscript  normal-⇒    a  c    h       S  A      subscript   superscript  normal-⇒    a  c    h       S  S      subscript   superscript  normal-⇒    a  c    h     failure: h cannot apply, no A to rewrite     S\Rightarrow^{ac}_{f}AA\Rightarrow^{ac}_{g}AA\Rightarrow^{ac}_{h}SA\Rightarrow%
 ^{ac}_{h}SS\Rightarrow^{ac}_{h}\text{failure: h cannot apply, no A to rewrite}     Let     s  3   =   f  g  h  h  k  l  l        subscript  s  3     f  g  h  h  k  l  l     s_{3}=fghhkll   , then we get the successful derivation:      S   ⇒  f   a  c     A  A    ⇒  g   a  c     A  A    ⇒  h   a  c     S  A    ⇒  h   a  c     S  S    ⇒  k   a  c     S  S    ⇒  l   a  c     a  S    ⇒  l   a  c     a  a         subscript   superscript  normal-⇒    a  c    f   S    A  A      subscript   superscript  normal-⇒    a  c    g       A  A      subscript   superscript  normal-⇒    a  c    h       S  A      subscript   superscript  normal-⇒    a  c    h       S  S      subscript   superscript  normal-⇒    a  c    k       S  S      subscript   superscript  normal-⇒    a  c    l       a  S      subscript   superscript  normal-⇒    a  c    l       a  a      S\Rightarrow^{ac}_{f}AA\Rightarrow^{ac}_{g}AA\Rightarrow^{ac}_{h}SA\Rightarrow%
 ^{ac}_{h}SS\Rightarrow^{ac}_{k}SS\Rightarrow^{ac}_{l}aS\Rightarrow^{ac}_{l}aa     Similar derivations with a second cycle of     f  *   g   h  *   k       superscript  f    g   superscript  h    k    f^{*}gh^{*}k   produce only SSSS . Showing only the (continued) successful derivation:      …  ⇒   S  S    ⇒  f   a  c     A  A  S    ⇒  f   a  c     A  A  A  A    ⇒  g   a  c     A  A  A  A        normal-⇒  normal-…    S  S      subscript   superscript  normal-⇒    a  c    f       A  A  S      subscript   superscript  normal-⇒    a  c    f       A  A  A  A      subscript   superscript  normal-⇒    a  c    g       A  A  A  A      ...\Rightarrow SS\Rightarrow^{ac}_{f}AAS\Rightarrow^{ac}_{f}AAAA\Rightarrow^{%
 ac}_{g}AAAA             ⇒  h   a  c     S  A  A  A    ⇒  h   a  c     S  S  A  A    ⇒  h   a  c     S  S  S  A    ⇒  h   a  c     S  S  S  S    ⇒  k   a  c     S  S  S  S         subscript   superscript  normal-⇒    a  c    h   absent    S  A  A  A      subscript   superscript  normal-⇒    a  c    h       S  S  A  A      subscript   superscript  normal-⇒    a  c    h       S  S  S  A      subscript   superscript  normal-⇒    a  c    h       S  S  S  S      subscript   superscript  normal-⇒    a  c    k       S  S  S  S      \Rightarrow^{ac}_{h}SAAA\Rightarrow^{ac}_{h}SSAA\Rightarrow^{ac}_{h}SSSA%
 \Rightarrow^{ac}_{h}SSSS\Rightarrow^{ac}_{k}SSSS                ⇒  l   a  c     a  S  S  S    ⇒  l   a  c     a  a  S  S    ⇒  l   a  c     a  a  a  S    ⇒  l   a  c     a  a  a  a         subscript   superscript  normal-⇒    a  c    l   absent    a  S  S  S      subscript   superscript  normal-⇒    a  c    l       a  a  S  S      subscript   superscript  normal-⇒    a  c    l       a  a  a  S      subscript   superscript  normal-⇒    a  c    l       a  a  a  a      \Rightarrow^{ac}_{l}aSSS\Rightarrow^{ac}_{l}aaSS\Rightarrow^{ac}_{l}aaaS%
 \Rightarrow^{ac}_{l}aaaa        Matrix grammars  Matrix grammars (expanded on in their own article ) are a special case of regular controlled context-free grammars, in which the production sequence language is of the form     (   m  1   |   m  2   |  …  |   m  n   )   *     superscript   fragments  normal-(   subscript  m  1   normal-|   subscript  m  2   normal-|  normal-…  normal-|   subscript  m  n   normal-)      (m_{1}|m_{2}|...|m_{n})^{*}   , where each "matrix"    m  i     subscript  m  i    m_{i}   is a single sequence. For convenience, such a grammar is not represented with a grammar over P , but rather with just a set of the matrices in place of both the language and the production rules. Thus, a matrix grammar is the 5-tuple    G  =   (  N  ,  T  ,  M  ,  S  ,  F  )       G   N  T  M  S  F     G=(N,T,M,S,F)   , where N , T , S , and F are defined essentially as previously done (with F a subset of M this time), and M is a set of matrices     m  i   =    p   i  ,  1     p   i  ,  2    …   p   i  ,   n  i           subscript  m  i      subscript  p   i  1     subscript  p   i  2    normal-…   subscript  p   i   subscript  n  i        m_{i}=p_{i,1}p_{i,2}...p_{i,n_{i}}   where each    p   i  ,  j      subscript  p   i  j     p_{i,j}   is a context-free production rule.  The derives relation in a matrix grammar is thus defined simply as:  Given some strings x and y , both in     (   N  ∪  T   )   *     superscript    N  T      (N\cup T)^{*}   , and some matrix    m  =    p  1    p  2   …   p  n    ∈  M        m     subscript  p  1    subscript  p  2   normal-…   subscript  p  n         M     m=p_{1}p_{2}...p_{n}\in M   ,      x   ⇒  m   a  c    y      subscript   superscript  normal-⇒    a  c    m   x  y    x\Rightarrow^{ac}_{m}y     holds if either      x  =    x  1   A   x  2        x     subscript  x  1   A   subscript  x  2      x=x_{1}Ax_{2}   ,    y  =    y  1   w   y  2        y     subscript  y  1   w   subscript  y  2      y=y_{1}wy_{2}   , and    A   ⇒   p  1    a  c     w  1    ⇒   p  2    a  c     w  2    ⇒   p  3    a  c    …   ⇒   p  n    a  c    w        subscript   superscript  normal-⇒    a  c     subscript  p  1    A   subscript  w  1      subscript   superscript  normal-⇒    a  c     subscript  p  2       subscript  w  2      subscript   superscript  normal-⇒    a  c     subscript  p  3      normal-…     subscript   superscript  normal-⇒    a  c     subscript  p  n      w     A\Rightarrow^{ac}_{p_{1}}w_{1}\Rightarrow^{ac}_{p_{2}}w_{2}\Rightarrow^{ac}_{p%
 _{3}}...\Rightarrow^{ac}_{p_{n}}w   , or      x  =  y      x  y    x=y   and    m  ∈  F      m  F    m\in F     Informally, a matrix grammar is simply a grammar in which during each rewriting cycle, a particular sequence of rewrite operations must be performed, rather than just a single rewrite operation, i.e. one rule "triggers" a cascade of other rules. Similar phenomena can be performed in the standard context-sensitive idiom, as done in rule-based phonology and earlier Transformational grammar , by what are known as "feeding" rules, which alter a derivation in such a way as to provide the environment for a non-optional rule that immediately follows it.  Vector grammars  Vector grammars are closely related to matrix grammars, and in fact can be seen as a special class of matrix grammars, in which if    m  ∈  M      m  M    m\in M   , then so are all of its permutations    p   (  m  )       p  m    p(m)   . For convenience, however, we will define vector grammars as follows: a vector grammar is a 5-tuple    G  =   (  N  ,  T  ,  M  ,  S  ,  F  )       G   N  T  M  S  F     G=(N,T,M,S,F)   , where N , T , and F are defined previously ( F being a subset of M again), and where M is a set of vectors     m  i   =   {   p  1   ,   p  2   ,  …  ,   p  n   }        subscript  m  i     subscript  p  1    subscript  p  2   normal-…   subscript  p  n      m_{i}=\{p_{1},p_{2},...,p_{n}\}   , each vector being a set of context free rules.  The derives relation in a vector grammar is then:  Given some strings x and y , both in     (   N  ∪  T   )   *     superscript    N  T      (N\cup T)^{*}   , and some matrix    m  =   {   p  1   ,   p  2   ,  …  ,   p  n   }   ∈  M        m    subscript  p  1    subscript  p  2   normal-…   subscript  p  n         M     m=\{p_{1},p_{2},...,p_{n}\}\in M   ,      x   ⇒  m   a  c    y      subscript   superscript  normal-⇒    a  c    m   x  y    x\Rightarrow^{ac}_{m}y     holds if either      x  =    x  1   A   x  2        x     subscript  x  1   A   subscript  x  2      x=x_{1}Ax_{2}   ,    y  =    y  1   w   y  2        y     subscript  y  1   w   subscript  y  2      y=y_{1}wy_{2}   , and    A   ⇒   p   i  1     a  c     w  1    ⇒   p   i  2     a  c     w  2    ⇒   p   i  3     a  c    …   ⇒   p   i  n     a  c    w        subscript   superscript  normal-⇒    a  c     subscript  p   subscript  i  1     A   subscript  w  1      subscript   superscript  normal-⇒    a  c     subscript  p   subscript  i  2        subscript  w  2      subscript   superscript  normal-⇒    a  c     subscript  p   subscript  i  3       normal-…     subscript   superscript  normal-⇒    a  c     subscript  p   subscript  i  n       w     A\Rightarrow^{ac}_{p_{i_{1}}}w_{1}\Rightarrow^{ac}_{p_{i_{2}}}w_{2}\Rightarrow%
 ^{ac}_{p_{i_{3}}}...\Rightarrow^{ac}_{p_{i_{n}}}w   , where    m  =   {   p   i  1    ,   p   i  2    ,  …  ,   p   i  n    }       m    subscript  p   subscript  i  1     subscript  p   subscript  i  2    normal-…   subscript  p   subscript  i  n       m=\{p_{i_{1}},p_{i_{2}},...,p_{i_{n}}\}   , or      x  =  y      x  y    x=y   and    m  ∈  F      m  F    m\in F     Notice that the number of production rules used in the derivation sequence, n , is the same as the number of production rules in the vector. Informally, then, a vector grammar is one in which a set of productions is applied, each production applied exactly once, in arbitrary order, to derive one string from another. Thus vector grammars are almost identical to matrix grammars, minus the restriction on the order in which the productions must occur during each cycle of rule application.  Programmed grammars  Programmed grammars are relatively simple extensions to context-free grammars with rule-by-rule control of the derivation. A programmed grammar is a 4-tuple    G  =   (  N  ,  T  ,  S  ,  P  )       G   N  T  S  P     G=(N,T,S,P)   , where N , T , and S are as in a context-free grammar, and P is a set of tuples    (  p  ,  σ  ,  ϕ  )     p  σ  ϕ    (p,\sigma,\phi)   , where p is a context-free production rule,   σ   σ   \sigma   is a subset of N (called the success field), and   ϕ   ϕ   \phi   is a subset of N (called the failure field). If the failure field of every rule in P is empty, the grammar is lacks appearance checking, and if at least one failure field is not empty, the grammar has appearance checking. The derivation relation on a programmed grammar is defined as follows:  Given two strings     x  ,  y   ∈    (   N  ∪  T   )   *        x  y    superscript    N  T       x,y\in(N\cup T)^{*}   , and some rule    p  =   (  A  →  w  ,  σ  ,  ϕ  )   ∈  P     fragments  p    fragments  normal-(  A  normal-→  w  normal-,  σ  normal-,  ϕ  normal-)    P    p=(A\to w,\sigma,\phi)\in P   ,      x   ⇒  p   y      subscript  normal-⇒  p   x  y    x\Rightarrow_{p}y   and     x  =    x  ′   A   x  ′′     ,   y  =    x  ′   w   x  ′′        formulae-sequence    x     superscript  x  normal-′   A   superscript  x  ′′       y     superscript  x  normal-′   w   superscript  x  ′′       x=x^{\prime}Ax^{\prime\prime},y=x^{\prime}wx^{\prime\prime}   , or      x  =  y      x  y    x=y   and A does not appear in x.  The language of a programmed grammar G is defined by constraining the derivation rule-wise, as     L   (  G  )    =   {   w  ∈    (   N  ∪  T   )   *    :   S   ⇒   p  1     w  1    ⇒   p  2    …   ⇒   p  n    w   }         L  G    conditional-set    w   superscript    N  T          subscript  normal-⇒   subscript  p  1    S   subscript  w  1      subscript  normal-⇒   subscript  p  2      normal-…     subscript  normal-⇒   subscript  p  n      w       L(G)=\{w\in(N\cup T)^{*}:S\Rightarrow_{p_{1}}w_{1}\Rightarrow_{p_{2}}...%
 \Rightarrow_{p_{n}}w\}   , where for each     p  i   =   (   A  i   →   v  i   ,   σ  i   ,   ϕ  i   )      fragments   subscript  p  i     fragments  normal-(   subscript  A  i   normal-→   subscript  v  i   normal-,   subscript  σ  i   normal-,   subscript  ϕ  i   normal-)     p_{i}=(A_{i}\to v_{i},\sigma_{i},\phi_{i})   , either      w   i  -  1    =    x   i  -  1    A   x   i  -  1   ′     ,     w  i   =    x   i  -  1     v  i    x   i  -  1   ′     ,    a  n   d    p   i  +  1     ∈   σ  i        formulae-sequence     subscript  w    i  1       subscript  x    i  1    A   subscript   superscript  x  normal-′     i  1       formulae-sequence     subscript  w  i      subscript  x    i  1     subscript  v  i    subscript   superscript  x  normal-′     i  1          a  n  d   subscript  p    i  1      subscript  σ  i       w_{i-1}=x_{i-1}Ax^{\prime}_{i-1},w_{i}=x_{i-1}v_{i}x^{\prime}_{i-1},\ and\ p_{%
 i+1}\in\sigma_{i}   or      w   i  -  1    =   w  i    ,    p   i  +  1    ∈   ϕ  i       formulae-sequence     subscript  w    i  1     subscript  w  i       subscript  p    i  1     subscript  ϕ  i      w_{i-1}=w_{i},p_{i+1}\in\phi_{i}   .  Intuitively, when applying a rule p in a programmed grammar, the rule can either succeed at rewriting a symbol in the string, in which case the subsequent rule must be in p s success field, or the rule can fail to rewrite a symbol (thus applying vacuously), in which case the subsequent rule must be in p s failure field. The choice of which rule to apply to the start string is arbitrary, unlike in a language controlled grammar, but once a choice is made the rules that can be applied after it constrain the sequence of rules from that point on.  Example  As with so many controlled grammars, programmed grammars can generate the language    {   a   2  n    :   n  ≥  0   }     conditional-set   superscript  a   superscript  2  n      n  0     \{a^{2^{n}}:n\geq 0\}   :  Let    G  =   (   {  S  ,  A  }   ,   {  a  }   ,  S  ,   {   r  1   ,   r  2   ,   r  3   }   )       G    S  A    a   S    subscript  r  1    subscript  r  2    subscript  r  3       G=(\{S,A\},\{a\},S,\{r_{1},r_{2},r_{3}\})   , where       r  1   =   (  S  →  A  A  ,   {   r  1   }   ,   {   r  2   }   )      fragments   subscript  r  1     fragments  normal-(  S  normal-→  A  A  normal-,   fragments  normal-{   subscript  r  1   normal-}   normal-,   fragments  normal-{   subscript  r  2   normal-}   normal-)     r_{1}=(S\to AA,\{r_{1}\},\{r_{2}\})          r  2   =   (  A  →  S  ,   {   r  2   }   ,   {   r  1   ,   r  3   }   )      fragments   subscript  r  2     fragments  normal-(  A  normal-→  S  normal-,   fragments  normal-{   subscript  r  2   normal-}   normal-,   fragments  normal-{   subscript  r  1   normal-,   subscript  r  3   normal-}   normal-)     r_{2}=(A\to S,\{r_{2}\},\{r_{1},r_{3}\})          r  3   =   (  S  →  a  ,   {   r  3   }   ,  ∅  )      fragments   subscript  r  3     fragments  normal-(  S  normal-→  a  normal-,   fragments  normal-{   subscript  r  3   normal-}   normal-,   normal-)     r_{3}=(S\to a,\{r_{3}\},\emptyset)     The derivation for the string aaaa is as follows:      S   ⇒   r  1     A  A    ⇒   r  1     A  A    ⇒   r  2     S  A    ⇒   r  2     S  S    ⇒   r  2     S  S         subscript  normal-⇒   subscript  r  1    S    A  A      subscript  normal-⇒   subscript  r  1        A  A      subscript  normal-⇒   subscript  r  2        S  A      subscript  normal-⇒   subscript  r  2        S  S      subscript  normal-⇒   subscript  r  2        S  S      S\Rightarrow_{r_{1}}AA\Rightarrow_{r_{1}}AA\Rightarrow_{r_{2}}SA\Rightarrow_{r%
 _{2}}SS\Rightarrow_{r_{2}}SS             ⇒   r  1     A  A  S    ⇒   r  1     A  A  A  A    ⇒   r  1     A  A  A  A         subscript  normal-⇒   subscript  r  1    absent    A  A  S      subscript  normal-⇒   subscript  r  1        A  A  A  A      subscript  normal-⇒   subscript  r  1        A  A  A  A      \Rightarrow_{r_{1}}AAS\Rightarrow_{r_{1}}AAAA\Rightarrow_{r_{1}}AAAA           ⇒   r  2     S  A  A  A    ⇒   r  2     S  S  A  A    ⇒   r  2     S  S  S  A    ⇒   r  2     S  S  S  S    ⇒   r  2     S  S  S  S         subscript  normal-⇒   subscript  r  2    absent    S  A  A  A      subscript  normal-⇒   subscript  r  2        S  S  A  A      subscript  normal-⇒   subscript  r  2        S  S  S  A      subscript  normal-⇒   subscript  r  2        S  S  S  S      subscript  normal-⇒   subscript  r  2        S  S  S  S      \Rightarrow_{r_{2}}SAAA\Rightarrow_{r_{2}}SSAA\Rightarrow_{r_{2}}SSSA%
 \Rightarrow_{r_{2}}SSSS\Rightarrow_{r_{2}}SSSS           ⇒   r  3     a  S  S  S    ⇒   r  3     a  a  S  S    ⇒   r  3     a  a  a  S    ⇒   r  3     a  a  a  a    ⇒   r  3     a  a  a  a         subscript  normal-⇒   subscript  r  3    absent    a  S  S  S      subscript  normal-⇒   subscript  r  3        a  a  S  S      subscript  normal-⇒   subscript  r  3        a  a  a  S      subscript  normal-⇒   subscript  r  3        a  a  a  a      subscript  normal-⇒   subscript  r  3        a  a  a  a      \Rightarrow_{r_{3}}aSSS\Rightarrow_{r_{3}}aaSS\Rightarrow_{r_{3}}aaaS%
 \Rightarrow_{r_{3}}aaaa\Rightarrow_{r_{3}}aaaa        As can be seen from the derivation and the rules, each time    r  1     subscript  r  1    r_{1}   and    r  2     subscript  r  2    r_{2}   succeed, they feed back to themselves, which forces each rule to continue to rewrite the string over and over until it can do so no more. Upon failing, the derivation can switch to a different rule. In the case of    r  1     subscript  r  1    r_{1}   , that means rewriting all S s as AA s, then switching to    r  2     subscript  r  2    r_{2}   . In the case of    r  2     subscript  r  2    r_{2}   , it means rewriting all A s as S s, then switching either to    r  1     subscript  r  1    r_{1}   , which will lead to doubling the number of S s produced, or to    r  3     subscript  r  3    r_{3}   which converts the S s to a s then halts the derivation. Each cycle through    r  1     subscript  r  1    r_{1}   then    r  2     subscript  r  2    r_{2}   therefore either doubles the initial number of S s, or converts the S s to a s. The trivial case of generating a , in case it is difficult to see, simply involves vacuously applying    r  1     subscript  r  1    r_{1}   , thus jumping straight to    r  2     subscript  r  2    r_{2}   which also vacuously applies, then jumping to    r  3     subscript  r  3    r_{3}   which produces a .  Control by context conditions  Unlike grammars controlled by prescribed sequences of production rules, which constrain the space of valid derivations but do not constrain the sorts of sentences that a production rule can apply to, grammars controlled by context conditions have no sequence constraints, but permit constraints of varying complexity on the sentences to which a production rule applies. Similar to grammars controlled by prescribed sequences, there are multiple different kinds of grammars controlled by context conditions: conditional grammars, semi-conditional grammars, random context grammars, and ordered grammars.  Conditional grammars  Conditional grammars are the simplest version of grammars controlled by context conditions. The structure of a conditional grammar is very similar to that of a normal rewrite grammar    G  =   (  N  ,  T  ,  S  ,  P  )       G   N  T  S  P     G=(N,T,S,P)   , where N , T , and S are as defined in a context-free grammar, and P is a set of pairs of the form    (  p  ,  R  )     p  R    (p,R)   where p is a production rule (usually context-free), and R is a language (usually regular) over    N  ∪  T      N  T    N\cup T   . When R is regular, R can just be expressed as a regular expression.  Proof-theoretic definition  With this definition of a conditional grammar, we can define the derives relation as follows:  Given two strings     x  ,  y   ∈    (   N  ∪  T   )   *        x  y    superscript    N  T       x,y\in(N\cup T)^{*}   , and some production rule    p  =   (  A  →  w  ,  R  )   ∈  P     fragments  p    fragments  normal-(  A  normal-→  w  normal-,  R  normal-)    P    p=(A\to w,R)\in P   ,      x   ⇒  p   y      subscript  normal-⇒  p   x  y    x\Rightarrow_{p}y   if and only if    x  =    x  ′   A   x  ′′        x     superscript  x  normal-′   A   superscript  x  ′′      x=x^{\prime}Ax^{\prime\prime}   ,    y  =    x  ′   w   x  ′′        y     superscript  x  normal-′   w   superscript  x  ′′      y=x^{\prime}wx^{\prime\prime}   , and    x  ∈  R      x  R    x\in R     Informally then, the production rule for some pair in P can apply only to strings that are in its context language. Thus, for example, if we had some pair    (   S  →   x  ,    a  *   S   b  *      )     normal-→  S   x     superscript  a    S   superscript  b        (S\to x,a^{*}Sb^{*})   , we can only apply this to strings consisting of any number of a s followed by exactly only S followed by any number of b s, i.e. to sentences in    {    a  m   A   b  n    :    m  ,  n   ≥  0   }     conditional-set     superscript  a  m   A   superscript  b  n       m  n   0     \{a^{m}Ab^{n}:m,n\geq 0\}   , such as the strings S , aSb , aaaS , aSbbbbbb , etc. It cannot apply to strings like xSy , aaaSxbbb , etc.  Example  Conditional grammars can generate the context-sensitive language    {   a   2  n    :   n  ≥  0   }     conditional-set   superscript  a   superscript  2  n      n  0     \{a^{2^{n}}:n\geq 0\}   .  Let    G  =   (   {  S  ,   S  ′   }   ,   {  a  }   ,   {  f  ,  g  ,  h  }   ,  S  )       G    S   superscript  S  normal-′     a    f  g  h   S     G=(\{S,S^{\prime}\},\{a\},\{f,g,h\},S)   , where      f  =   (  S  →  A  A  ,   A  *    S  +   )      fragments  f    fragments  normal-(  S  normal-→  A  A  normal-,   superscript  A     superscript  S    normal-)     f=(S\to AA,A^{*}S^{+})         g  =   (  A  →  B  ,   B  *    A  +   )      fragments  g    fragments  normal-(  A  normal-→  B  normal-,   superscript  B     superscript  A    normal-)     g=(A\to B,B^{*}A^{+})         h  =   (  B  →  S  ,   S  *    B  +   )      fragments  h    fragments  normal-(  B  normal-→  S  normal-,   superscript  S     superscript  B    normal-)     h=(B\to S,S^{*}B^{+})         k  =   (  S  →  a  ,   a  *    S  +   )      fragments  k    fragments  normal-(  S  normal-→  a  normal-,   superscript  a     superscript  S    normal-)     k=(S\to a,a^{*}S^{+})     We can then generate the sentence aaaa with the following derivation:      S   ⇒  f    A  A    ⇒  g    B  A    ⇒  g    B  B         subscript  normal-⇒  f   S    A  A      subscript  normal-⇒  g       B  A      subscript  normal-⇒  g       B  B      S\Rightarrow_{f}AA\Rightarrow_{g}BA\Rightarrow_{g}BB             ⇒  h    S  B    ⇒  h    S  S    ⇒  f    A  A  S    ⇒  f    A  A  A  A         subscript  normal-⇒  h   absent    S  B      subscript  normal-⇒  h       S  S      subscript  normal-⇒  f       A  A  S      subscript  normal-⇒  f       A  A  A  A      \Rightarrow_{h}SB\Rightarrow_{h}SS\Rightarrow_{f}AAS\Rightarrow_{f}AAAA           ⇒  g    B  A  A  A    ⇒  g    B  B  A  A    ⇒  g    B  B  B  A    ⇒  g    B  B  B  B         subscript  normal-⇒  g   absent    B  A  A  A      subscript  normal-⇒  g       B  B  A  A      subscript  normal-⇒  g       B  B  B  A      subscript  normal-⇒  g       B  B  B  B      \Rightarrow_{g}BAAA\Rightarrow_{g}BBAA\Rightarrow_{g}BBBA\Rightarrow_{g}BBBB           ⇒  h    S  B  B  B    ⇒  h    S  S  B  B    ⇒  h    S  S  S  B    ⇒  h    S  S  S  S         subscript  normal-⇒  h   absent    S  B  B  B      subscript  normal-⇒  h       S  S  B  B      subscript  normal-⇒  h       S  S  S  B      subscript  normal-⇒  h       S  S  S  S      \Rightarrow_{h}SBBB\Rightarrow_{h}SSBB\Rightarrow_{h}SSSB\Rightarrow_{h}SSSS           ⇒  k    a  S  S  S    ⇒  k    a  a  S  S    ⇒  k    a  a  a  S    ⇒  k    a  a  a  a         subscript  normal-⇒  k   absent    a  S  S  S      subscript  normal-⇒  k       a  a  S  S      subscript  normal-⇒  k       a  a  a  S      subscript  normal-⇒  k       a  a  a  a      \Rightarrow_{k}aSSS\Rightarrow_{k}aaSS\Rightarrow_{k}aaaS\Rightarrow_{k}aaaa        Semi-conditional grammars  A semi-conditional grammar is very similar to a conditional grammar, and technically the class of semi-conditional grammars are a subset of the conditional grammars. Rather than specifying what the whole of the string must look like for a rule to apply, semi-conditional grammars specify that a string must have as substrings all of some set of strings, and none of another set, in order for a rule to apply. Formally, then, a semi-conditional grammar is a tuple    G  =   (  N  ,  T  ,  S  ,  P  )       G   N  T  S  P     G=(N,T,S,P)   , where, N , T , and S are defined as in a CFG, and P is a set of rules like    (  p  ,  R  ,  Q  )     p  R  Q    (p,R,Q)   where p is a (usually context-free) production rule, and R and Q are finite sets of strings. The derives relation can then be defined as follows.  For two strings      x  A   x  ′    ,   x  w   x  ′     ∈    (   N  ∪  T   )   *          x  A   superscript  x  normal-′      x  w   superscript  x  normal-′      superscript    N  T       xAx^{\prime},xwx^{\prime}\in(N\cup T)^{*}   , and some rule    p  =   (  A  →  w  ,  R  ,  Q  )   ∈  P     fragments  p    fragments  normal-(  A  normal-→  w  normal-,  R  normal-,  Q  normal-)    P    p=(A\to w,R,Q)\in P   ,       x  A   x  ′     ⇒  p    x  w   x  ′        subscript  normal-⇒  p     x  A   superscript  x  normal-′      x  w   superscript  x  normal-′      xAx^{\prime}\Rightarrow_{p}xwx^{\prime}   if and only if every string in R is a substring of    x  A   x  ′       x  A   superscript  x  normal-′     xAx^{\prime}   , and no string in Q is a substring of    x  A   x  ′       x  A   superscript  x  normal-′     xAx^{\prime}     The language of a semi-conditional grammar is then trivially the set of terminal strings     L   (  G  )    =   {   w  ∈   T  *    :   S   ⇒  *   w   }         L  G    conditional-set    w   superscript  T       superscript  normal-⇒    S  w      L(G)=\{w\in T^{*}:S\Rightarrow^{*}w\}   .  An example of a semi-conditional grammar is given below also as an example of random context grammars.  Random context grammars  A random context grammar is a semi-conditional grammar in which the R and Q sets are all subsets of N . Because subsets of N are finite sets over     (   N  ∪  T   )   *     superscript    N  T      (N\cup T)^{*}   , it is clear that that random context grammars are indeed kinds of semi-conditional grammars.  Example  Like conditional grammars, random context grammars (and thus semi-conditional grammars) can generate the language    {   a   2  n    :   n  ≥  0   }     conditional-set   superscript  a   superscript  2  n      n  0     \{a^{2^{n}}:n\geq 0\}   . One grammar which can do this is:  Let    G  =   (   {  S  ,  X  ,  Y  ,  A  }   ,   {  a  }   ,  S  ,   {   r  1   ,   r  2   ,   r  3   ,   r  4   ,   r  5   }   )       G    S  X  Y  A    a   S    subscript  r  1    subscript  r  2    subscript  r  3    subscript  r  4    subscript  r  5       G=(\{S,X,Y,A\},\{a\},S,\{r_{1},r_{2},r_{3},r_{4},r_{5}\})   , where       r  1   =   (  S  →  X  X  ,  ∅  ,   {  Y  ,  A  }   )      fragments   subscript  r  1     fragments  normal-(  S  normal-→  X  X  normal-,   normal-,   fragments  normal-{  Y  normal-,  A  normal-}   normal-)     r_{1}=(S\to XX,\emptyset,\{Y,A\})          r  2   =   (  X  →  Y  ,  ∅  ,   {  S  }   )      fragments   subscript  r  2     fragments  normal-(  X  normal-→  Y  normal-,   normal-,   fragments  normal-{  S  normal-}   normal-)     r_{2}=(X\to Y,\emptyset,\{S\})          r  3   =   (  Y  →  S  ,  ∅  ,   {  X  }   )      fragments   subscript  r  3     fragments  normal-(  Y  normal-→  S  normal-,   normal-,   fragments  normal-{  X  normal-}   normal-)     r_{3}=(Y\to S,\emptyset,\{X\})          r  4   =   (  S  →  A  ,  ∅  ,   {  X  }   )      fragments   subscript  r  4     fragments  normal-(  S  normal-→  A  normal-,   normal-,   fragments  normal-{  X  normal-}   normal-)     r_{4}=(S\to A,\emptyset,\{X\})          r  5   =   (  A  →  a  ,  ∅  ,   {  S  }   )      fragments   subscript  r  5     fragments  normal-(  A  normal-→  a  normal-,   normal-,   fragments  normal-{  S  normal-}   normal-)     r_{5}=(A\to a,\emptyset,\{S\})     Consider now the production for aaaa :      S   ⇒   r  1     X  X    ⇒   r  2     Y  X    ⇒   r  2     Y  Y    ⇒   r  3     S  Y    ⇒   r  3     S  S         subscript  normal-⇒   subscript  r  1    S    X  X      subscript  normal-⇒   subscript  r  2        Y  X      subscript  normal-⇒   subscript  r  2        Y  Y      subscript  normal-⇒   subscript  r  3        S  Y      subscript  normal-⇒   subscript  r  3        S  S      S\Rightarrow_{r_{1}}XX\Rightarrow_{r_{2}}YX\Rightarrow_{r_{2}}YY\Rightarrow_{r%
 _{3}}SY\Rightarrow_{r_{3}}SS             ⇒   r  1     X  X  S    ⇒   r  1     X  X  X  X    ⇒   r  2     Y  X  X  X    ⇒   r  2     Y  Y  X  X    ⇒   r  2     Y  Y  Y  X    ⇒   r  2     Y  Y  Y  Y         subscript  normal-⇒   subscript  r  1    absent    X  X  S      subscript  normal-⇒   subscript  r  1        X  X  X  X      subscript  normal-⇒   subscript  r  2        Y  X  X  X      subscript  normal-⇒   subscript  r  2        Y  Y  X  X      subscript  normal-⇒   subscript  r  2        Y  Y  Y  X      subscript  normal-⇒   subscript  r  2        Y  Y  Y  Y      \Rightarrow_{r_{1}}XXS\Rightarrow_{r_{1}}XXXX\Rightarrow_{r_{2}}YXXX%
 \Rightarrow_{r_{2}}YYXX\Rightarrow_{r_{2}}YYYX\Rightarrow_{r_{2}}YYYY           ⇒   r  3     S  Y  Y  Y    ⇒   r  3     S  S  Y  Y    ⇒   r  3     S  S  S  Y    ⇒   r  3     S  S  S  S         subscript  normal-⇒   subscript  r  3    absent    S  Y  Y  Y      subscript  normal-⇒   subscript  r  3        S  S  Y  Y      subscript  normal-⇒   subscript  r  3        S  S  S  Y      subscript  normal-⇒   subscript  r  3        S  S  S  S      \Rightarrow_{r_{3}}SYYY\Rightarrow_{r_{3}}SSYY\Rightarrow_{r_{3}}SSSY%
 \Rightarrow_{r_{3}}SSSS           ⇒   r  4     A  S  S  S    ⇒   r  4     A  A  S  S    ⇒   r  4     A  A  A  S    ⇒   r  4     A  A  A  A         subscript  normal-⇒   subscript  r  4    absent    A  S  S  S      subscript  normal-⇒   subscript  r  4        A  A  S  S      subscript  normal-⇒   subscript  r  4        A  A  A  S      subscript  normal-⇒   subscript  r  4        A  A  A  A      \Rightarrow_{r_{4}}ASSS\Rightarrow_{r_{4}}AASS\Rightarrow_{r_{4}}AAAS%
 \Rightarrow_{r_{4}}AAAA           ⇒   r  5     a  A  A  A    ⇒   r  5     a  a  A  A    ⇒   r  5     a  a  a  A    ⇒   r  5     a  a  a  a         subscript  normal-⇒   subscript  r  5    absent    a  A  A  A      subscript  normal-⇒   subscript  r  5        a  a  A  A      subscript  normal-⇒   subscript  r  5        a  a  a  A      subscript  normal-⇒   subscript  r  5        a  a  a  a      \Rightarrow_{r_{5}}aAAA\Rightarrow_{r_{5}}aaAA\Rightarrow_{r_{5}}aaaA%
 \Rightarrow_{r_{5}}aaaa        The behavior of the R sets here is trivial: any string can be rewritten according to them, because they do not require any substrings to be present. The behavior of the Q sets, however, are more interesting. In    r  1     subscript  r  1    r_{1}   , we are forced by the Q set to rewrite an S , thus beginning an S -doubling process, only when no Y s or A s are present in the string, which means only when a prior S -doubling process has been fully initiated, eliminating the possibility of only doubling some of the S s. In    r  2     subscript  r  2    r_{2}   , which moves the S -doubling process into its second stage, we cannot begin this process until the first stage is complete and there are no more S s to try to double, because the Q set prevents the rule from applying if there is an S symbol still in the string. In    r  3     subscript  r  3    r_{3}   , we complete the doubling stage by introducing the S s back only when there are no more X s to rewrite, thus when the second stage is complete. We can cycle through these stages as many times as we want, rewriting all S s to XX s before then rewriting each X to a Y, and then each Y to an S , finally ending by replacing each S with an A and then an a . Because the rule for replacing S with A prohibits application to a string with an X in it, we cannot apply this in the middle of the first stage of the S -doubling process, thus again preventing us from only doubling some S s.  Ordered grammars  Ordered grammars are perhaps one of the simpler extensions of grammars into the controlled grammar domain. An ordered grammar is simply a tuple    G  =   (  N  ,  T  ,  S  ,  P  )       G   N  T  S  P     G=(N,T,S,P)   where N , T , and S are identical to those in a CFG, and P is a set of context-free rewrite rules with a partial ordering . The partial ordering is then used to determine which rule to apply to a string, when multiple rules are applicable. The derives relation is then:  Given some strings      x  A   x  ′    ,   x  w   x  ′     ∈    (   N  ∪  T   )   *          x  A   superscript  x  normal-′      x  w   superscript  x  normal-′      superscript    N  T       xAx^{\prime},xwx^{\prime}\in(N\cup T)^{*}   and some rule    p  =  A  →  w  ∈  P        p  A    normal-→    w       P     p=A\to w\in P   ,       x  A   x  ′     ⇒  p    x  w   x  ′        subscript  normal-⇒  p     x  A   superscript  x  normal-′      x  w   superscript  x  normal-′      xAx^{\prime}\Rightarrow_{p}xwx^{\prime}   if and only if there is no rule     p  ′   =  A  →   w  ′   ∈  P         superscript  p  normal-′   A    normal-→     superscript  w  normal-′        P     p^{\prime}=A\to w^{\prime}\in P   such that    p  <   p  ′       p   superscript  p  normal-′     p   .  Example  Like many other contextually controlled grammars, ordered grammars can enforce the application of rules in a particular order. Since this is the essential property of previous grammars that could generate the language    {   a   2  n    :   n  ≥  0   }     conditional-set   superscript  a   superscript  2  n      n  0     \{a^{2^{n}}:n\geq 0\}   , it should be no surprise that a grammar that explicitly uses rule ordering, rather than encoding it via string contexts, should similarly be able to capture that language. And as it turns out, just such an ordered grammar exists:  Let    G  =   (   {  S  ,  X  ,  Y  ,  Z  ,  A  }   ,   {  a  }   ,  S  ,  P  )       G    S  X  Y  Z  A    a   S  P     G=(\{S,X,Y,Z,A\},\{a\},S,P)   , where P is the partially ordered set described by the Hasse diagram      The derivation for the string aaaa is simply:      S    ⇒   S  →   X  X       X   X      ⇒   X  →  Y      Y   X      ⇒   X  →  Y      Y   Y      ⇒   Y  →  S      S   Y      ⇒   Y  →  S      Y  Y         subscript  normal-⇒   normal-→  S    X  X     S    X  X      subscript  normal-⇒   normal-→  X  Y        Y  X      subscript  normal-⇒   normal-→  X  Y        Y  Y      subscript  normal-⇒   normal-→  Y  S        S  Y      subscript  normal-⇒   normal-→  Y  S        Y  Y      S\Rightarrow_{S\to XX}\ XX\ \Rightarrow_{X\to Y}\ YX\ \Rightarrow_{X\to Y}\ YY%
 \ \Rightarrow_{Y\to S}\ SY\ \Rightarrow_{Y\to S}\ YY              ⇒   S  →   X  X       X  X   S      ⇒   S  →   X  X       X  X  X  X         subscript  normal-⇒   normal-→  S    X  X     absent    X  X  S      subscript  normal-⇒   normal-→  S    X  X         X  X  X  X      \Rightarrow_{S\to XX}\ XXS\ \Rightarrow_{S\to XX}\ XXXX            ⇒   X  →  Y      Y  X  X   X      ⇒   X  →  Y      Y  Y  X   X      ⇒   X  →  Y      Y  Y  Y   X      ⇒   X  →  Y      Y  Y  Y  Y         subscript  normal-⇒   normal-→  X  Y    absent    Y  X  X  X      subscript  normal-⇒   normal-→  X  Y        Y  Y  X  X      subscript  normal-⇒   normal-→  X  Y        Y  Y  Y  X      subscript  normal-⇒   normal-→  X  Y        Y  Y  Y  Y      \Rightarrow_{X\to Y}\ YXXX\ \Rightarrow_{X\to Y}\ YYXX\ \Rightarrow_{X\to Y}\ %
 YYYX\ \Rightarrow_{X\to Y}\ YYYY            ⇒   Y  →  S      S  Y  Y   Y      ⇒   Y  →  S      S  S  Y   Y      ⇒   Y  →  S      S  S  S   Y      ⇒   Y  →  S      S  S  S  S         subscript  normal-⇒   normal-→  Y  S    absent    S  Y  Y  Y      subscript  normal-⇒   normal-→  Y  S        S  S  Y  Y      subscript  normal-⇒   normal-→  Y  S        S  S  S  Y      subscript  normal-⇒   normal-→  Y  S        S  S  S  S      \Rightarrow_{Y\to S}\ SYYY\ \Rightarrow_{Y\to S}\ SSYY\ \Rightarrow_{Y\to S}\ %
 SSSY\ \Rightarrow_{Y\to S}\ SSSS            ⇒   S  →  A      A  S  S   S      ⇒   S  →  A      A  A  S   S      ⇒   S  →  A      A  A  A   S      ⇒   S  →  A      A  A  A  A         subscript  normal-⇒   normal-→  S  A    absent    A  S  S  S      subscript  normal-⇒   normal-→  S  A        A  A  S  S      subscript  normal-⇒   normal-→  S  A        A  A  A  S      subscript  normal-⇒   normal-→  S  A        A  A  A  A      \Rightarrow_{S\to A}\ ASSS\ \Rightarrow_{S\to A}\ AASS\ \Rightarrow_{S\to A}\ %
 AAAS\ \Rightarrow_{S\to A}\ AAAA            ⇒   A  →  a      a  A  A   A      ⇒   A  →  a      a  a  A   A      ⇒   A  →  a      a  a  a   A      ⇒   A  →  a      a  a  a  a         subscript  normal-⇒   normal-→  A  a    absent    a  A  A  A      subscript  normal-⇒   normal-→  A  a        a  a  A  A      subscript  normal-⇒   normal-→  A  a        a  a  a  A      subscript  normal-⇒   normal-→  A  a        a  a  a  a      \Rightarrow_{A\to a}\ aAAA\ \Rightarrow_{A\to a}\ aaAA\ \Rightarrow_{A\to a}\ %
 aaaA\ \Rightarrow_{A\to a}\ aaaa        At each step of the way, the derivation proceeds by rewriting in cycles. Notice that if at the fifth step SY , we had four options     Y  →  Z   ,    S  →  Z   ,    Y  →  S   ,   S  →  A        formulae-sequence   normal-→  Y  Z    formulae-sequence   normal-→  S  Z    formulae-sequence   normal-→  Y  S    normal-→  S  A       Y\to Z,S\to Z,Y\to S,S\to A   , the first two of which halt the derivation, as Z cannot be rewritten. In the example, we used    Y  →  S     normal-→  Y  S    Y\to S   to derive SS , but consider if we had chosen    S  →  A     normal-→  S  A    S\to A   instead. We would have produced the string AS , the options for which are    Y  →  Z     normal-→  Y  Z    Y\to Z   and    A  →  Z     normal-→  A  Z    A\to Z   , both of which halt the derivation. Thus with the string SY , and conversely with YS , we must rewrite the Y to produce SS . The same hold for other combinations, so that overall, the ordering forces the derivation to halt, or else proceed by rewriting all S s to XX s, then all X s to Y s, then all Y s to S s, and so on, then finally all S s to A s then all A s to a s. In this way, a string    S  n     superscript  S  n    S^{n}   can only ever be rewritten as    A  n     superscript  A  n    A^{n}   which produces a s, or as    S   2  n      superscript  S    2  n     S^{2n}   . Starting with n = 0 , it should be clear that this grammar only generates the language    {   a   2  n    :   n  ≥  0   }     conditional-set   superscript  a   superscript  2  n      n  0     \{a^{2^{n}}:n\geq 0\}   .  Grammars with parallelism  A still further class of controlled grammars is the class of grammars with parallelism in the application of a rewrite operation, in which each rewrite step can (or must) rewrite more than one non-terminal simultaneously. These, too, come in several flavors: Indian parallel grammars, k-grammars, scattered context grammars, unordered scattered context grammars, and k-simple matrix grammars. Again, the variants differ in how the parallelism is defined.  Indian parallel grammars  An Indian parallel grammar is simply a CFG in which to use a rewrite rule, all instances of the rules non-terminal symbol must be rewritten simultaneously. Thus, for example, given the string aXbYcXd , with two instances of X , and some rule    X  →  w     normal-→  X  w    X\to w   , the only way to rewrite this string with this rule is to rewrite it as awbYcwd ; neither awbYcXd nor aXbYcwd are valid rewrites in an Indian parallel grammar, because they did not rewrite all instances of X .  Indian parallel grammars can easily produce the language    {   w  w   :   w  ∈    {  a  ,  b  }   *    }     conditional-set    w  w     w   superscript   a  b        \{ww:w\in\{a,b\}^{*}\}   :  Let    G  =   (   {  S  ,  A  }   ,   {  a  ,  b  }   ,  S  ,   {  f  ,  g  ,  h  ,  k  }   )       G    S  A    a  b   S   f  g  h  k      G=(\{S,A\},\{a,b\},S,\{f,g,h,k\})   , where      f  =  S  →   A  A         f  S    normal-→      A  A      f=S\to AA         g  =  A  →   a  A         g  A    normal-→      a  A      g=A\to aA         h  =  A  →   b  A         h  A    normal-→      b  A      h=A\to bA         k  =  A  →  ϵ        k  A    normal-→    ϵ     k=A\to\epsilon     Generating aabaab then is quite simple:      S   ⇒  f    A  A    ⇒  g    a  A  a  A    ⇒  g    a  a  A  a  a  A    ⇒  h    a  a  b  A  a  a  b  A    ⇒  k    a  a  b  a  a  b         subscript  normal-⇒  f   S    A  A      subscript  normal-⇒  g       a  A  a  A      subscript  normal-⇒  g       a  a  A  a  a  A      subscript  normal-⇒  h       a  a  b  A  a  a  b  A      subscript  normal-⇒  k       a  a  b  a  a  b      S\Rightarrow_{f}AA\Rightarrow_{g}aAaA\Rightarrow_{g}aaAaaA\Rightarrow_{h}%
 aabAaabA\Rightarrow_{k}aabaab     The language    {   a   2  n    :   n  ≥  0   }     conditional-set   superscript  a   superscript  2  n      n  0     \{a^{2^{n}}:n\geq 0\}   is even simpler:  Let    G  =   (   {  S  }   ,   {  a  }   ,  S  ,  P  )       G    S    a   S  P     G=(\{S\},\{a\},S,P)   , where P consists of      S  →   S  S      normal-→  S    S  S     S\to SS         S  →  a     normal-→  S  a    S\to a     It should be obvious, just from the first rule, and the requirement that all instances of a non-terminal are rewritten simultaneously with the same rule, that the number of S s doubles on each rewrite step using the first rule, giving the derivation steps    S  ⇒   S  2   ⇒   S  4   ⇒   S  8   ⇒  …       normal-⇒  S   superscript  S  2     normal-⇒     superscript  S  4     normal-⇒     superscript  S  8     normal-⇒    normal-…     S\Rightarrow S^{2}\Rightarrow S^{4}\Rightarrow S^{8}\Rightarrow...   . Final application of the second rule replaces all the S s with a s, thus showing how this simple language can produce the language    {   a   2  n    :   n  ≥  0   }     conditional-set   superscript  a   superscript  2  n      n  0     \{a^{2^{n}}:n\geq 0\}   .  K-grammars  A k-grammar is yet another kind of parallel grammar, very different from an Indian parallel grammar, but still with a level of parallelism. In a k-grammar, for some number k , exactly k non-terminal symbols must be rewritten at every step (except the first step, where the only symbol in the string is the start symbol). If the string has less than k non-terminals, the derivation fails.  A 3-grammar can produce the language    {    a  n    b  n    c  n    :   n  ≥  0   }     conditional-set     superscript  a  n    superscript  b  n    superscript  c  n      n  0     \{a^{n}b^{n}c^{n}:n\geq 0\}   , as can be seen below:  Let    G  =   (   {  S  ,  A  ,  B  ,  C  }   ,   {  a  ,  b  ,  c  }   ,  S  ,  P  )       G    S  A  B  C    a  b  c   S  P     G=(\{S,A,B,C\},\{a,b,c\},S,P)   , where P consists of:      S  →   A  B  C      normal-→  S    A  B  C     S\to ABC         A  →   a  A      normal-→  A    a  A     A\to aA         A  →  a     normal-→  A  a    A\to a         B  →   b  B      normal-→  B    b  B     B\to bB         B  →  b     normal-→  B  b    B\to b         C  →   c  C      normal-→  C    c  C     C\to cC         C  →  c     normal-→  C  c    C\to c     With the following derivation for aaabbbccc :      S  ⇒   A  B  C   ⇒   a  A  b  B  c  C   ⇒   a  a  A  b  b  B  c  c  C   ⇒   a  a  a  b  b  b  c  c  c        normal-⇒  S    A  B  C     normal-⇒      a  A  b  B  c  C     normal-⇒      a  a  A  b  b  B  c  c  C     normal-⇒      a  a  a  b  b  b  c  c  c      S\Rightarrow ABC\Rightarrow aAbBcC\Rightarrow aaAbbBccC\Rightarrow aaabbbccc     At each step in the derivation except the first and last, we used the self-recursive rules     A  →   a  A    ,    B  →   b  B    ,   C  →   c  C        formulae-sequence   normal-→  A    a  A     formulae-sequence   normal-→  B    b  B     normal-→  C    c  C       A\to aA,B\to bB,C\to cC   . If we had not use the recursive rules, instead using, say,     A  →  a   ,    B  →   b  B    ,   C  →   c  C        formulae-sequence   normal-→  A  a    formulae-sequence   normal-→  B    b  B     normal-→  C    c  C       A\to a,B\to bB,C\to cC   , where one of the rules is not self-recursive, the number of non-terminals would have decreased to 2, thus making the string unable to be derived further because it would have too few non-terminals to be rewritten.  Russian parallel grammars  Russian parallel grammars 2 are somewhere between Indian parallel grammars and k-grammars, defined as    G  =   (  N  ,  T  ,  S  ,  P  )       G   N  T  S  P     G=(N,T,S,P)   , where N , T , and S are as in a context-free grammar, and P is a set of pairs    (   A  →   w  ,  k    )     normal-→  A   w  k     (A\to w,k)   , where    A  →  w     normal-→  A  w    A\to w   is a context-free production rule, and k is either 1 or 2. Application of a rule    p  =   (  A  →  w  ,  k  )      fragments  p    fragments  normal-(  A  normal-→  w  normal-,  k  normal-)     p=(A\to w,k)   involves rewriting k occurrences of A to w simultaneously.  Scattered context grammars  A scattered context grammar is a 4-tuple    G  =   (  N  ,  T  ,  S  ,  P  )       G   N  T  S  P     G=(N,T,S,P)   where N , T , and S are defined as in a context-free grammar, and P is a set of tuples called matrixes    p  =   (   A  1   →   w  1   ,  …  ,   A  n   →   w  n   )      fragments  p    fragments  normal-(   subscript  A  1   normal-→   subscript  w  1   normal-,  normal-…  normal-,   subscript  A  n   normal-→   subscript  w  n   normal-)     p=(A_{1}\to w_{1},...,A_{n}\to w_{n})   , where    n  >  0      n  0    n>0   can vary according to the matrix. The derives relation for such a grammar is      x   ⇒  p   y      subscript  normal-⇒  p   x  y    x\Rightarrow_{p}y   if and only if        p  =   (   A  1   →   w  1   ,  …  ,   A  n   →   w  n   )   ∈  P     fragments  p    fragments  normal-(   subscript  A  1   normal-→   subscript  w  1   normal-,  normal-…  normal-,   subscript  A  n   normal-→   subscript  w  n   normal-)    P    p=(A_{1}\to w_{1},...,A_{n}\to w_{n})\in P   , and       x  =    x  1    A  1    x  2   …   x  n    A  n    x   n  +  1      ,   y  =    x  1    w  1    x  2   …   x  n    w  n    x   n  +  1         formulae-sequence    x     subscript  x  1    subscript  A  1    subscript  x  2   normal-…   subscript  x  n    subscript  A  n    subscript  x    n  1        y     subscript  x  1    subscript  w  1    subscript  x  2   normal-…   subscript  x  n    subscript  w  n    subscript  x    n  1        x=x_{1}A_{1}x_{2}...x_{n}A_{n}x_{n+1},y=x_{1}w_{1}x_{2}...x_{n}w_{n}x_{n+1}   , for     x  i   ∈    (   N  ∪  T   )   *        subscript  x  i    superscript    N  T       x_{i}\in(N\cup T)^{*}        Intuitively, then, the matrixes in a scattered context grammar provide a list of rules which must each be applied to non-terminals in a string, where those non-terminals appear in the same linear order as the rules that rewrite them.  An unordered scattered context grammar is a scattered context grammar in which, for every rule in P , each of its permutations is also in P . As such, a rule and its permutations can instead be represented as a set rather than as tuples.  Example  Scattered context grammars are capable of describing the language    {    a  n    b  n    c  n    :   n  ≥  0   }     conditional-set     superscript  a  n    superscript  b  n    superscript  c  n      n  0     \{a^{n}b^{n}c^{n}:n\geq 0\}   quite easily.  Let    G  =   (   {  S  }   ,   {  a  ,  b  ,  c  }   ,  S  ,   {   r  1   ,   r  2   ,   r  3   }   )       G    S    a  b  c   S    subscript  r  1    subscript  r  2    subscript  r  3       G=(\{S\},\{a,b,c\},S,\{r_{1},r_{2},r_{3}\})   , where       r  1   =   (  S  →  S  S  S  )      fragments   subscript  r  1     fragments  normal-(  S  normal-→  S  S  S  normal-)     r_{1}=(S\to SSS)          r  2   =   (  S  →  a  S  ,  S  →  b  S  ,  S  →  c  S  )      fragments   subscript  r  2     fragments  normal-(  S  normal-→  a  S  normal-,  S  normal-→  b  S  normal-,  S  normal-→  c  S  normal-)     r_{2}=(S\to aS,S\to bS,S\to cS)          r  3   =   (  S  →  ϵ  ,  S  →  ϵ  ,  S  →  ϵ  )      fragments   subscript  r  3     fragments  normal-(  S  normal-→  ϵ  normal-,  S  normal-→  ϵ  normal-,  S  normal-→  ϵ  normal-)     r_{3}=(S\to\epsilon,S\to\epsilon,S\to\epsilon)     Deriving aaabbbccc then is trivial:      S   ⇒   r  1     S  S  S    ⇒   r  2     a  S  b  S  c  S    ⇒   r  2     a  a  S  b  b  S  c  c  S    ⇒   r  2     a  a  a  S  b  b  b  S  c  c  c  S    ⇒   r  3     a  a  a  b  b  b  c  c  c         subscript  normal-⇒   subscript  r  1    S    S  S  S      subscript  normal-⇒   subscript  r  2        a  S  b  S  c  S      subscript  normal-⇒   subscript  r  2        a  a  S  b  b  S  c  c  S      subscript  normal-⇒   subscript  r  2        a  a  a  S  b  b  b  S  c  c  c  S      subscript  normal-⇒   subscript  r  3        a  a  a  b  b  b  c  c  c      S\Rightarrow_{r_{1}}SSS\Rightarrow_{r_{2}}aSbScS\Rightarrow_{r_{2}}aaSbbSccS%
 \Rightarrow_{r_{2}}aaaSbbbScccS\Rightarrow_{r_{3}}aaabbbccc     References  "  Category:Formal languages  Category:Grammar frameworks     Dassow, J., Pǎun, Gh., and Salomaa, A. Grammars with Controlled Derivations. In G. Rozenberg and A. Salomaa (Eds.) Handbook of Formal Languages , Vol. 2, Ch. 3. ↩  Dassow, J. 1984. On some extensions of russian parallel context free grammars . Acta Cybernetica 6, pp. 355-360. ↩     