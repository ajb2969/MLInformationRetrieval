<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="299">Planarity</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Planarity</h1>
<hr/>
<dl>
<dd><em>This article is about the game; for the graph theory property, see <a href="Planar_graph" title="wikilink">Planar graph</a>.</em>
</dd>
</dl>

<p><strong>Planarity</strong> is a <a href="puzzle_computer_game" title="wikilink">puzzle computer game</a> by John Tantalo, based on a concept by Mary Radcliffe at <a href="Western_Michigan_University" title="wikilink">Western Michigan University</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The name comes from the concept of <a href="planar_graph" title="wikilink">planar graphs</a> in graph theory; these are graphs that can be embedded in the <a href="Euclidean_plane" title="wikilink">Euclidean plane</a> so that no edges intersect. By <a href="Fáry's_theorem" title="wikilink">Fáry's theorem</a>, if a graph is planar, it can be drawn without crossings so that all of its edges are straight line segments. In the planarity game, the player is presented with a <a href="circular_layout" title="wikilink">circular layout</a> of a planar graph, with all the vertices placed on a single circle and with many crossings. The goal for the player is to eliminate all of the crossings and construct a straight-line embedding of the graph by moving the vertices one by one into better positions.</p>
<h2 id="history-and-versions">History and versions</h2>

<p>The game was written in <a href="Adobe_Flash" title="wikilink">Flash</a> by John Tantalo at <a href="Case_Western_Reserve_University" title="wikilink">Case Western Reserve University</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Online popularity and the local notoriety he gained placed Tantalo as one of Cleveland's most interesting people for 2006.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> It in turn has inspired the creation of a <a class="uri" href="GTK+" title="wikilink">GTK+</a> version by <a class="uri" href="Xiph.org" title="wikilink">Xiph.org</a>'s <a href="Chris_Montgomery" title="wikilink">Chris Montgomery</a>, which possesses additional level generation algorithms and the ability to manipulate multiple nodes at once.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="puzzle-generation-algorithm">Puzzle generation algorithm</h2>

<p>The definition of the planarity puzzle does not depend on how the planar graphs in the puzzle are generated, but the original implementation uses the following algorithm:</p>
<ol>
<li>Generate a set of random lines in a plane such that no two lines are parallel and no three lines meet in a single point.</li>
<li>Calculate the intersections of every line pair.</li>
<li>Create a graph with a vertex for each intersection and an edge for each line segment connecting two intersections (the <a href="Arrangement_of_lines" title="wikilink">arrangement</a> of the lines).</li>
</ol>

<p>If a graph is generated from 

<math display="inline" id="Planarity:0">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 lines, then the graph will have exactly 

<math display="inline" id="Planarity:1">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mstyle scriptlevel="+1">
     <mtable columnspacing="0.4em" rowspacing="0.2ex">
      <mtr>
       <mtd>
        <mi>L</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mn>2</mn>
       </mtd>
      </mtr>
     </mtable>
    </mstyle>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>L</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">binomial</csymbol>
     <ci>L</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <minus></minus>
       <ci>L</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\textstyle\left({{L}\atop{2}}\right)}=\tfrac{L(L-1)}{2}
  </annotation>
 </semantics>
</math>

 vertices (each line has 

<math display="inline" id="Planarity:2">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>L</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L-1
  </annotation>
 </semantics>
</math>

 vertices, and each vertex is shared with one other line) and 

<math display="inline" id="Planarity:3">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>L</mi>
     <mo>-</mo>
     <mn>2</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <apply>
     <minus></minus>
     <ci>L</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(L-2)
  </annotation>
 </semantics>
</math>

 edges (each line contains 

<math display="inline" id="Planarity:4">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>-</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>L</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L-2
  </annotation>
 </semantics>
</math>

 edges). The first level of Planarity is built with 

<math display="inline" id="Planarity:5">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=4
  </annotation>
 </semantics>
</math>

 lines, so it has 

<math display="inline" id="Planarity:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>L</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mo>=</mo>
   <mn>6</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <minus></minus>
       <ci>L</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">6</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(L-1)/2=6
  </annotation>
 </semantics>
</math>

 vertices and 

<math display="inline" id="Planarity:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>L</mi>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>8</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <apply>
      <minus></minus>
      <ci>L</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="integer">8</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(L-2)=8
  </annotation>
 </semantics>
</math>

 edges. Each level after is generated by one more line than the last. If a level was generated with 

<math display="inline" id="Planarity:8">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 lines, then the next level has 

<math display="inline" id="Planarity:9">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 more vertices and 

<math display="inline" id="Planarity:10">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>L</mi>
   </mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>L</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2L-1
  </annotation>
 </semantics>
</math>

 more edges.</p>

<p>The best known algorithms from <a href="computational_geometry" title="wikilink">computational geometry</a> for constructing the graphs of line arrangements solve the problem in 

<math display="inline" id="Planarity:11">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>L</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>L</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(L^{2})
  </annotation>
 </semantics>
</math>

 time,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> linear in the size of the graph to be constructed, but they are somewhat complex. Alternatively and more simply, it is possible to index each crossing point by the pair of lines that cross at that point, sort the crossings along each line by their 

<math display="inline" id="Planarity:12">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

-coordinates, and use this sorted ordering to generate the edges of the planar graph, in near-optimal 

<math display="inline" id="Planarity:13">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>L</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mi>log</mi>
      <mi>L</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <log></log>
      <ci>L</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(L^{2}\log L)
  </annotation>
 </semantics>
</math>

 time. Once the vertices and edges of the graph have been generated, they may be placed evenly around a circle using a <a href="random_permutation" title="wikilink">random permutation</a>.</p>
<h2 id="related-theoretical-research">Related theoretical research</h2>

<p>The problem of <a href="Planarity_testing" title="wikilink">determining whether a graph is planar</a> can be solved in <a href="linear_time" title="wikilink">linear time</a>,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> and any such graph is guaranteed to have a straight-line embedding by <a href="Fáry's_theorem" title="wikilink">Fáry's theorem</a>, that can also be found from the planar embedding in linear time.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Therefore, any puzzle could be solved in linear time by a computer. However, these puzzles are not as straightforward for human players to solve.</p>

<p>In the field of <a href="computational_geometry" title="wikilink">computational geometry</a>, the process of moving a subset of the vertices in a graph embedding to eliminate edge crossings has been studied by Pach and Tardos (2002),<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> and others, inspired by the planarity puzzle.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> The results of these researchers shows that (in theory, assuming that the field of play is the infinite plane rather than a bounded rectangle) it is always possible to solve the puzzle while leaving 

<math display="inline" id="Planarity:14">
 <semantics>
  <msup>
   <mi>n</mi>
   <mi>ϵ</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{\epsilon}
  </annotation>
 </semantics>
</math>

 of the 

<math display="inline" id="Planarity:15">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 input vertices fixed in place at their original positions, for a constant 

<math display="inline" id="Planarity:16">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 that has not been determined precisely but lies between 1/4 and slightly less than 1/2. When the planar graph to be untangled is a <a href="cycle_graph" title="wikilink">cycle graph</a>, a larger number of vertices may be fixed in place. However, determining the largest number of vertices that may be left in place for a particular input puzzle (or equivalently, the smallest number of moves needed to solve the puzzle) is <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>.</p>

<p>has shown that the randomized <a href="circular_layout" title="wikilink">circular layout</a> used for the initial state of Planarity is nearly the worst possible in terms of its <a href="crossing_number_(graph_theory)" title="wikilink">number of crossings</a>: regardless of what planar graph is to be tangled, the <a href="expected_value" title="wikilink">expected value</a> of the number of crossings for this layout is within a factor of three of the largest number of crossings among all layouts.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>In 2014, mathematician <a href="David_Eppstein" title="wikilink">David Eppstein</a> published a paper<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> providing an effective algorithm for solving planar graphs generated by the original Planarity game, based on the specifics of the puzzle generation algorithm.</p>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.planarity.net">Planarity.net</a> — the original Flash game</li>
<li><a href="http://ccl.northwestern.edu/netlogo/">NetLogo System</a> — Included as sample program (game) in NetLogo system</li>
<li><a href="http://www.jasondavies.com/planarity/">Planarity</a> — Version using <a class="uri" href="SVG" title="wikilink">SVG</a> and the <a href="http://mbostock.github.com/d3/">d3</a> <a class="uri" href="JavaScript" title="wikilink">JavaScript</a> library</li>
<li><a href="http://www.libavg.de/site/projects/libavg/wiki/Planarity">Multitouch Planarity</a> — Multiplayer- and multitouch-enabled version written in <a href="Python_(programming_language)" title="wikilink">Python</a> using libavg.</li>
</ul>

<p>"</p>

<p><a href="Category:Puzzle_video_games" title="wikilink">Category:Puzzle video games</a> <a href="Category:Mathematical_games" title="wikilink">Category:Mathematical games</a> <a href="Category:Planar_graphs" title="wikilink">Category:Planar graphs</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"> <a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
</ol>
</section>
</body>
</html>
