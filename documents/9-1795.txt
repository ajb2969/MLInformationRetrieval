   Jenkins–Traub algorithm      Jenkins–Traub algorithm   The Jenkins–Traub algorithm for polynomial zeros is a fast globally convergent iterative method published in 1970 by Michael A. Jenkins and Joseph F. Traub . They gave two variants, one for general polynomials with complex coefficients, commonly known as the "CPOLY" algorithm, and a more complicated variant for the special case of polynomials with real coefficients, commonly known as the "RPOLY" algorithm. The latter is "practically a standard in black-box polynomial root-finders". 1  This article describes the complex variant. Given a polynomial P ,        P   (  z  )    =    ∑   i  =  0   n     a  i    z   n  -  i       ,     a  0   =  1   ,    a  n   ≠  0       formulae-sequence      P  z     superscript   subscript     i  0    n      subscript  a  i    superscript  z    n  i        formulae-sequence     subscript  a  0   1      subscript  a  n   0      P(z)=\sum_{i=0}^{n}a_{i}z^{n-i},\quad a_{0}=1,\quad a_{n}\neq 0     with complex coefficients it computes approximations to the n zeros     α  1   ,   α  2   ,  …  ,   α  n       subscript  α  1    subscript  α  2   normal-…   subscript  α  n     \alpha_{1},\alpha_{2},\dots,\alpha_{n}   of P ( z ), one at a time in roughly increasing order of magnitude. After each root is computed, its linear factor is removed from the polynomial. Using this deflation guarantees that each root is computed only once and that all roots are found.  The real variant follows the same pattern, but computes two roots at a time, either two real roots or a pair of conjugate complex roots. By avoiding complex arithmetic, the real variant can be faster (by a factor of 4) than the complex variant. The Jenkins–Traub algorithm has stimulated considerable research on theory and software for methods of this type.  Overview  The Jenkins–Traub algorithm calculates all of the roots of a polynomial with complex coefficients. The algorithm starts by checking the polynomial for the occurrence of very large or very small roots. If necessary, the coefficients are rescaled by a rescaling of the variable. In the algorithm proper, roots are found one by one and generally in increasing size. After each root is found, the polynomial is deflated by dividing off the corresponding linear factor. Indeed, the factorization of the polynomial into the linear factor and the remaining deflated polynomial is already a result of the root-finding procedure. The root-finding procedure has three stages that correspond to different variants of the inverse power iteration . See Jenkins and Traub . 2 A description can also be found in Ralston and Rabinowitz 3 p. 383. The algorithm is similar in spirit to the two-stage algorithm studied by Traub. 4  Root-finding procedure  Starting with the current polynomial P ( X ) of degree n , the smallest root of P(x) is computed. To that end, a sequence of so-called H polynomials is constructed. These polynomials are all of degree n − 1 and are supposed to converge to the factor of P ( X ) containing all the remaining roots. The sequence of H polynomials occurs in two variants, an unnormalized variant that allows easy theoretical insights and a normalized variant of    H  ¯     normal-¯  H    \bar{H}   polynomials that keeps the coefficients in a numerically sensible range.  The construction of the H polynomials     (    H   (  λ  )     (  z  )    )    λ  =   0  ,  1  ,  2  ,  …       subscript     superscript  H  λ   z     λ   0  1  2  normal-…      \left(H^{(\lambda)}(z)\right)_{\lambda=0,1,2,\dots}   depends on a sequence of complex numbers     (   s  λ   )    λ  =   0  ,  1  ,  2  ,  …       subscript   subscript  s  λ     λ   0  1  2  normal-…      (s_{\lambda})_{\lambda=0,1,2,\dots}   called shifts. These shifts themselves depend, at least in the third stage, on the previous H polynomials. The H polynomials are defined as the solution to the implicit recursion        H   (  0  )     (  z  )    =    P  ′    (  z  )           superscript  H  0   z      superscript  P  normal-′   z     H^{(0)}(z)=P^{\prime}(z)   and        (   X  -   s  λ    )   ⋅   H   (   λ  +  1   )      (  X  )    ≡     H   (  λ  )     (  X  )        (   mod   P   (  X  )     )      .         normal-⋅    X   subscript  s  λ     superscript  H    λ  1     X    annotated     superscript  H  λ   X    pmod    P  X       (X-s_{\lambda})\cdot H^{(\lambda+1)}(X)\equiv H^{(\lambda)}(X)\;\;(\mathop{{%
 \rm mod}}P(X))\ .   A direct solution to this implicit equation is         H   (   λ  +  1   )     (  X  )    =    1   X  -   s  λ     ⋅   (     H   (  λ  )     (  X  )    -      H   (  λ  )     (   s  λ   )     P   (   s  λ   )     P   (  X  )     )     ,         superscript  H    λ  1    X    normal-⋅    1    X   subscript  s  λ          superscript  H  λ   X          superscript  H  λ    subscript  s  λ      P   subscript  s  λ     P  X       H^{(\lambda+1)}(X)=\frac{1}{X-s_{\lambda}}\cdot\left(H^{(\lambda)}(X)-\frac{H^%
 {(\lambda)}(s_{\lambda})}{P(s_{\lambda})}P(X)\right)\,,   where the polynomial division is exact.  Algorithmically, one would use for instance the Horner scheme or Ruffini rule to evaluate the polynomials at    s  λ     subscript  s  λ    s_{\lambda}   and obtain the quotients at the same time. With the resulting quotients p ( X ) and h ( X ) as intermediate results the next H polynomial is obtained as          P   (  X  )        =     p   (  X  )    ⋅   (   X  -   s  λ    )    +   P   (   s  λ   )            H   (  λ  )     (  X  )        =     h   (  X  )    ⋅   (   X  -   s  λ    )    +    H   (  λ  )     (   s  λ   )         }  ⟹  H     (   λ  +  1   )    (  z  )  =  h  (  z  )  -     H   (  λ  )     (   s  λ   )     P   (   s  λ   )     p  (  z  )  .     fragments      P  X     absent     normal-⋅    p  X     X   subscript  s  λ       P   subscript  s  λ           superscript  H  λ   X     absent     normal-⋅    h  X     X   subscript  s  λ        superscript  H  λ    subscript  s  λ        normal-}   H     λ  1    normal-(  z  normal-)   h  normal-(  z  normal-)        superscript  H  λ    subscript  s  λ      P   subscript  s  λ     p  normal-(  z  normal-)  normal-.    \left.\begin{aligned}\displaystyle P(X)&\displaystyle=p(X)\cdot(X-s_{\lambda})%
 +P(s_{\lambda})\\
 \displaystyle H^{(\lambda)}(X)&\displaystyle=h(X)\cdot(X-s_{\lambda})+H^{(%
 \lambda)}(s_{\lambda})\\
 \end{aligned}\right\}\implies H^{(\lambda+1)}(z)=h(z)-\frac{H^{(\lambda)}(s_{%
 \lambda})}{P(s_{\lambda})}p(z).   Since the highest degree coefficient is obtained from P(X) , the leading coefficient of     H   (   λ  +  1   )     (  X  )        superscript  H    λ  1    X    H^{(\lambda+1)}(X)   is    -     H   (  λ  )     (   s  λ   )     P   (   s  λ   )              superscript  H  λ    subscript  s  λ      P   subscript  s  λ       -\tfrac{H^{(\lambda)}(s_{\lambda})}{P(s_{\lambda})}   . If this is divided out the normalized H polynomial is        H  ¯    (   λ  +  1   )     (  X  )        superscript   normal-¯  H     λ  1    X    \displaystyle\bar{H}^{(\lambda+1)}(X)     Stage one: no-shift process  For    λ  =   0  ,  1  ,  …  ,   M  -  1        λ   0  1  normal-…    M  1      \lambda=0,1,\dots,M-1   set     s  λ   =  0       subscript  s  λ   0    s_{\lambda}=0   . Usually M=5 is chosen for polynomials of moderate degrees up to n = 50. This stage is not necessary from theoretical considerations alone, but is useful in practice. It emphasizes in the H polynomials the cofactor (of the linear factor) of the smallest root.  Stage two: fixed-shift process  The shift for this stage is determined as some point close to the smallest root of the polynomial. It is quasi-randomly located on the circle with the inner root radius, which in turn is estimated as the positive solution of the equation         R  n   +    |   a   n  -  1    |    R   n  -  1     +  …  +    |   a  1   |   R    =   |   a  0   |    .         superscript  R  n        subscript  a    n  1      superscript  R    n  1     normal-…       subscript  a  1    R       subscript  a  0      R^{n}+|a_{n-1}|\,R^{n-1}+\dots+|a_{1}|\,R=|a_{0}|\,.   Since the left side is a convex function and increases monotonically from zero to infinity, this equation is easy to solve, for instance by Newton's method .  Now choose    s  =   R  ⋅   exp   (    i    ϕ  random    )         s   normal-⋅  R      i   subscript  ϕ  random        s=R\cdot\exp(i\,\phi_{\text{random}})   on the circle of this radius. The sequence of polynomials     H   (   λ  +  1   )     (  z  )        superscript  H    λ  1    z    H^{(\lambda+1)}(z)   ,    λ  =   M  ,   M  +  1   ,  …  ,   L  -  1        λ   M    M  1   normal-…    L  1      \lambda=M,M+1,\dots,L-1   , is generated with the fixed shift value     s  λ   =  s       subscript  s  λ   s    s_{\lambda}=s   . During this iteration, the current approximation for the root       t  λ   =   s  -    P   (  s  )       H  ¯    (  λ  )     (  s  )           subscript  t  λ     s      P  s      superscript   normal-¯  H   λ   s       t_{\lambda}=s-\frac{P(s)}{\bar{H}^{(\lambda)}(s)}   is traced. The second stage is finished successfully if the conditions       |    t   λ  +  1    -   t  λ    |   <      1  2      |   t  λ   |             subscript  t    λ  1     subscript  t  λ         1  2      subscript  t  λ       |t_{\lambda+1}-t_{\lambda}|<\tfrac{1}{2}\,|t_{\lambda}|   and     |    t  λ   -   t   λ  -  1     |   <     1  2     |   t   λ  -  1    |             subscript  t  λ    subscript  t    λ  1          1  2      subscript  t    λ  1        |t_{\lambda}-t_{\lambda-1}|<\tfrac{1}{2}\,|t_{\lambda-1}|   are simultaneously met. If there was no success after some number of iterations, a different random point on the circle is tried. Typically one uses a number of 9 iterations for polynomials of moderate degree, with a doubling strategy for the case of multiple failures.  Stage three: variable-shift process  The     H   (   λ  +  1   )     (  X  )        superscript  H    λ  1    X    H^{(\lambda+1)}(X)   are now generated using the variable shifts       s  λ   ,  λ   =  L   ,    L  +  1   ,  …      formulae-sequence      subscript  s  λ   λ   L      L  1   normal-…     s_{\lambda},\quad\lambda=L,L+1,\dots   which are generated by       s  L   =   t  L   =   s  -    P   (  s  )       H  ¯    (  λ  )     (  s  )             subscript  s  L    subscript  t  L          s      P  s      superscript   normal-¯  H   λ   s        s_{L}=t_{L}=s-\frac{P(s)}{\bar{H}^{(\lambda)}(s)}   being the last root estimate of the second stage and         s   λ  +  1    =    s  λ   -    P   (   s  λ   )       H  ¯    (   λ  +  1   )     (   s  λ   )       ,   λ  =   L  ,   L  +  1   ,  …     ,     formulae-sequence     subscript  s    λ  1       subscript  s  λ       P   subscript  s  λ       superscript   normal-¯  H     λ  1     subscript  s  λ         λ   L    L  1   normal-…      s_{\lambda+1}=s_{\lambda}-\frac{P(s_{\lambda})}{\bar{H}^{(\lambda+1)}(s_{%
 \lambda})},\quad\lambda=L,L+1,\dots,      where      H  ¯    (   λ  +  1   )     (  z  )        superscript   normal-¯  H     λ  1    z    \bar{H}^{(\lambda+1)}(z)   is the normalized H polynomial, that is     H   (  λ  )     (  z  )        superscript  H  λ   z    H^{(\lambda)}(z)   divided by its leading coefficient.   If the step size in stage three does not fall fast enough to zero, then stage two is restarted using a different random point. If this does not succeed after a small number of restarts, the number of steps in stage two is doubled.  Convergence  It can be shown that, provided L is chosen sufficiently large, s λ always converges to a root of P .  The algorithm converges for any distribution of roots, but may fail to find all roots of the polynomial. Furthermore, the convergence is slightly faster than the quadratic convergence of Newton–Raphson iteration, however, it uses at least twice as many operations per step.  What gives the algorithm its power?  Compare with the Newton–Raphson iteration        z   i  +  1    =    z  i   -    P   (   z  i   )      P  ′    (   z  i   )       .       subscript  z    i  1       subscript  z  i       P   subscript  z  i       superscript  P  normal-′    subscript  z  i        z_{i+1}=z_{i}-\frac{P(z_{i})}{P^{\prime}(z_{i})}.     The iteration uses the given P and    P  ′     superscript  P  normal-′    \scriptstyle P^{\prime}   . In contrast the third-stage of Jenkins–Traub       s   λ  +  1    =    s  λ   -    P   (   s  λ   )       H  ¯    λ  +  1     (   s  λ   )      =    s  λ   -     W  λ    (   s  λ   )       (   W  λ   )   ′    (   s  λ   )             subscript  s    λ  1       subscript  s  λ       P   subscript  s  λ       superscript   normal-¯  H     λ  1     subscript  s  λ              subscript  s  λ        superscript  W  λ    subscript  s  λ       superscript   superscript  W  λ   normal-′    subscript  s  λ         s_{\lambda+1}=s_{\lambda}-\frac{P(s_{\lambda})}{\bar{H}^{\lambda+1}(s_{\lambda%
 })}=s_{\lambda}-\frac{W^{\lambda}(s_{\lambda})}{(W^{\lambda})^{\prime}(s_{%
 \lambda})}     is precisely a Newton–Raphson iteration performed on certain rational functions . More precisely, Newton–Raphson is being performed on a sequence of rational functions         W  λ    (  z  )    =    P   (  z  )      H  λ    (  z  )      .         superscript  W  λ   z       P  z      superscript  H  λ   z      W^{\lambda}(z)=\frac{P(z)}{H^{\lambda}(z)}.     For   λ   λ   \lambda   sufficiently large,        P   (  z  )       H  ¯   λ    (  z  )     =    W  λ    (  z  )   L  C   (   H  λ   )            P  z      superscript   normal-¯  H   λ   z       superscript  W  λ   z  L  C   superscript  H  λ      \frac{P(z)}{\bar{H}^{\lambda}(z)}=W^{\lambda}(z)\,LC(H^{\lambda})     is as close as desired to a first degree polynomial       z  -   α  1    ,      z   subscript  α  1     z-\alpha_{1},\,     where    α  1     subscript  α  1    \alpha_{1}   is one of the zeros of   P   P   P   . Even though Stage 3 is precisely a Newton–Raphson iteration, differentiation is not performed.  Analysis of the H polynomials  Let     α  1   ,  …  ,   α  n       subscript  α  1   normal-…   subscript  α  n     \alpha_{1},\dots,\alpha_{n}   be the roots of P ( X ). The so-called Lagrange factors of P(X) are the cofactors of these roots,         P  m    (  X  )    =     P   (  X  )    -   P   (   α  m   )      X  -   α  m      .         subscript  P  m   X         P  X     P   subscript  α  m       X   subscript  α  m       P_{m}(X)=\frac{P(X)-P(\alpha_{m})}{X-\alpha_{m}}.   If all roots are different, then the Lagrange factors form a basis of the space of polynomials of degree at most n − 1. By analysis of the recursion procedure one finds that the H polynomials have the coordinate representation         H   (  λ  )     (  X  )    =    ∑   m  =  1   n       [    ∏   κ  =  0    λ  -  1     (    α  m   -   s  κ    )    ]    -  1      P  m    (  X  )      .         superscript  H  λ   X     superscript   subscript     m  1    n      superscript   delimited-[]    superscript   subscript  product    κ  0      λ  1       subscript  α  m    subscript  s  κ        1     subscript  P  m   X      H^{(\lambda)}(X)=\sum_{m=1}^{n}\left[\prod_{\kappa=0}^{\lambda-1}(\alpha_{m}-s%
 _{\kappa})\right]^{-1}\,P_{m}(X)\ .   Each Lagrange factor has leading coefficient 1, so that the leading coefficient of the H polynomials is the sum of the coefficients. The normalized H polynomials are thus          H  ¯    (  λ  )     (  X  )    =     ∑   m  =  1   n       [    ∏   κ  =  0    λ  -  1     (    α  m   -   s  κ    )    ]    -  1      P  m    (  X  )       ∑   m  =  1   n     [    ∏   κ  =  0    λ  -  1     (    α  m   -   s  κ    )    ]    -  1      =       P  1    (  X  )    +    ∑   m  =  2   n     [    ∏   κ  =  0    λ  -  1       α  1   -   s  κ      α  m   -   s  κ      ]    P  m    (  X  )       1  +    ∑   m  =  1   n    [    ∏   κ  =  0    λ  -  1       α  1   -   s  κ      α  m   -   s  κ      ]        .           superscript   normal-¯  H   λ   X       superscript   subscript     m  1    n      superscript   delimited-[]    superscript   subscript  product    κ  0      λ  1       subscript  α  m    subscript  s  κ        1     subscript  P  m   X      superscript   subscript     m  1    n    superscript   delimited-[]    superscript   subscript  product    κ  0      λ  1       subscript  α  m    subscript  s  κ        1                  subscript  P  1   X     superscript   subscript     m  2    n      delimited-[]    superscript   subscript  product    κ  0      λ  1         subscript  α  1    subscript  s  κ       subscript  α  m    subscript  s  κ        subscript  P  m   X       1    superscript   subscript     m  1    n    delimited-[]    superscript   subscript  product    κ  0      λ  1         subscript  α  1    subscript  s  κ       subscript  α  m    subscript  s  κ             \bar{H}^{(\lambda)}(X)=\frac{\sum_{m=1}^{n}\left[\prod_{\kappa=0}^{\lambda-1}(%
 \alpha_{m}-s_{\kappa})\right]^{-1}\,P_{m}(X)}{\sum_{m=1}^{n}\left[\prod_{%
 \kappa=0}^{\lambda-1}(\alpha_{m}-s_{\kappa})\right]^{-1}}=\frac{P_{1}(X)+\sum_%
 {m=2}^{n}\left[\prod_{\kappa=0}^{\lambda-1}\frac{\alpha_{1}-s_{\kappa}}{\alpha%
 _{m}-s_{\kappa}}\right]\,P_{m}(X)}{1+\sum_{m=1}^{n}\left[\prod_{\kappa=0}^{%
 \lambda-1}\frac{\alpha_{1}-s_{\kappa}}{\alpha_{m}-s_{\kappa}}\right]}\ .     Convergence orders  If the condition    |   α  1   -   s  κ   |  <  min   |    m  =   2  ,  3  ,  …  ,  n       α  m   -   s  κ   |     fragments  normal-|   subscript  α  1     subscript  s  κ   normal-|     subscript  normal-|    m   2  3  normal-…  n      subscript  α  m     subscript  s  κ   normal-|    |\alpha_{1}-s_{\kappa}|<\min{}_{m=2,3,\dots,n}|\alpha_{m}-s_{\kappa}|   holds for almost all iterates, the normalized H polynomials will converge at least geometrically towards     P  1    (  X  )        subscript  P  1   X    P_{1}(X)   .  Under the condition that      |   α  1   |  <  |   α  2   |  =  min   |    m  =   2  ,  3  ,  …  ,  n       α  m   |     fragments  normal-|   subscript  α  1   normal-|   normal-|   subscript  α  2   normal-|     subscript  normal-|    m   2  3  normal-…  n      subscript  α  m   normal-|    |\alpha_{1}|<|\alpha_{2}|=\min{}_{m=2,3,\dots,n}|\alpha_{m}|   one gets the aymptotic estimates for   stage 1: :   H^{(\lambda)}(X)  =P_1(X)+O\left(\left|\frac{\alpha_1}{\alpha_2}\right|^\lambda\right).    for stage 2, if s is close enough to    α  1     subscript  α  1    \alpha_{1}   : :   H^{(\lambda)}(X)  =P_1(X)  +O\left(  \left|\frac{\alpha_1}{\alpha_2}\right|^M  \cdot  \left|\frac{\alpha_1-s}{\alpha_2-s}\right|^{\lambda-M}\right)   *:and  *      s  -    P   (  s  )       H  ¯    (  λ  )     (  s  )      =    α  1   +   O   (   …  ⋅   |    α  1   -  s   |    )      .        s      P  s      superscript   normal-¯  H   λ   s        subscript  α  1     O   normal-⋅  normal-…       subscript  α  1   s         s-\frac{P(s)}{\bar{H}^{(\lambda)}(s)}=\alpha_{1}+O\left(\ldots\cdot|\alpha_{1}%
 -s|\right).      and for stage 3: :   H^{(\lambda)}(X)  =P_1(X)  +O\left(\prod_{\kappa=0}^{\lambda-1}  \left|\frac{\alpha_1-s_\kappa}{\alpha_2-s_\kappa}\right|  \right)   *:and  *     s   λ  +  1    =    s  λ   -    P   (  s  )       H  ¯    (   λ  +  1   )     (   s  λ   )      =    α  1   +   O   (    ∏   κ  =  0    λ  -  1      |     α  1   -   s  κ      α  2   -   s  κ     |   ⋅     |    α  1   -   s  λ    |   2    |    α  2   -   s  λ    |      )            subscript  s    λ  1       subscript  s  λ       P  s      superscript   normal-¯  H     λ  1     subscript  s  λ              subscript  α  1     O    superscript   subscript  product    κ  0      λ  1     normal-⋅         subscript  α  1    subscript  s  κ       subscript  α  2    subscript  s  κ         superscript       subscript  α  1    subscript  s  λ     2        subscript  α  2    subscript  s  λ             s_{\lambda+1}=s_{\lambda}-\frac{P(s)}{\bar{H}^{(\lambda+1)}(s_{\lambda})}=%
 \alpha_{1}+O\left(\prod_{\kappa=0}^{\lambda-1}\left|\frac{\alpha_{1}-s_{\kappa%
 }}{\alpha_{2}-s_{\kappa}}\right|\cdot\frac{|\alpha_{1}-s_{\lambda}|^{2}}{|%
 \alpha_{2}-s_{\lambda}|}\right)      giving rise to a higher than quadratic convergence order of     ϕ  2   =   1  +  ϕ   ≈  2.61         superscript  ϕ  2     1  ϕ        2.61     \phi^{2}=1+\phi\approx 2.61   , where    ϕ  =    1  2    (   1  +   5    )        ϕ      1  2     1    5       \phi=\tfrac{1}{2}(1+\sqrt{5})   is the golden ratio .   Interpretation as inverse power iteration  All stages of the Jenkins–Traub complex algorithm may be represented as the linear algebra problem of determining the eigenvalues of a special matrix. This matrix is the coordinate representation of a linear map in the n -dimensional space of polynomials of degree n − 1 or less. The principal idea of this map is to interpret the factorization       P   (  X  )    =     (   X  -   α  1    )   ⋅   P  1     (  X  )          P  X      normal-⋅    X   subscript  α  1     subscript  P  1    X     P(X)=(X-\alpha_{1})\cdot P_{1}(X)   with a root     α  1   ∈   \C        subscript  α  1   \C    \alpha_{1}\in\C   and      P  1    (  X  )    =    P   (  X  )    /   (   X  -   α  1    )           subscript  P  1   X       P  X     X   subscript  α  1       P_{1}(X)=P(X)/(X-\alpha_{1})   the remaining factor of degree n − 1 as the eigenvector equation for the multiplication with the variable X , followed by remainder computation with divisor P ( X ),         M  X    (  H  )    =    (    X  ⋅  H    (  X  )    )   mod   P   (  X  )      .         subscript  M  X   H    modulo     normal-⋅  X  H   X     P  X      M_{X}(H)=(X\cdot H(X))\bmod P(X)\,.   This maps polynomials of degree at most n − 1 to polynomials of degree at most n − 1. The eigenvalues of this map are the roots of P ( X ), since the eigenvector equation reads       0  =    (    M  X   -    α  ⋅  i   d    )    (  H  )    =    (    (   X  -  α   )   ⋅  H   )   mod   P     ,        0       subscript  M  X      normal-⋅  α  i   d    H         modulo   normal-⋅    X  α   H   P      0=(M_{X}-\alpha\cdot id)(H)=((X-\alpha)\cdot H)\bmod P\,,   which implies that     (  X  -  α  )   ⋅  H  )  =  C  ⋅  P  (  X  )     fragments   fragments  normal-(  X   α  normal-)   normal-⋅  H  normal-)   C  normal-⋅  P  normal-(  X  normal-)    (X-\alpha)\cdot H)=C\cdot P(X)   , that is,    (   X  -  α   )      X  α    (X-\alpha)   is a linear factor of P ( X ). In the monomial basis the linear map    M  X     subscript  M  X    M_{X}   is represented by a companion matrix of the polynomial P , as         M  X    (  H  )    =     ∑   m  =  1    n  -  1      (    H   m  -  1    -    P  m    H   n  -  1      )    X  m     -    P  0     H   n  -  1        ,         subscript  M  X   H       superscript   subscript     m  1      n  1         subscript  H    m  1       subscript  P  m    subscript  H    n  1       superscript  X  m        subscript  P  0    subscript  H    n  1        M_{X}(H)=\sum_{m=1}^{n-1}(H_{m-1}-P_{m}H_{n-1})X^{m}-P_{0}H_{n-1}\,,   the resulting coefficient matrix is       A  =    (     0    0    …    0     -   P  0        1    0    …    0     -   P  1        0    1    …    0     -   P  2        ⋮    ⋮    ⋱    ⋮    ⋮      0    0    …    1     -   P   n  -  1        )     .      A    0  0  normal-…  0     subscript  P  0      1  0  normal-…  0     subscript  P  1      0  1  normal-…  0     subscript  P  2      normal-⋮  normal-⋮  normal-⋱  normal-⋮  normal-⋮    0  0  normal-…  1     subscript  P    n  1         A=\begin{pmatrix}0&0&\dots&0&-P_{0}\\
 1&0&\dots&0&-P_{1}\\
 0&1&\dots&0&-P_{2}\\
 \vdots&\vdots&\ddots&\vdots&\vdots\\
 0&0&\dots&1&-P_{n-1}\end{pmatrix}\,.   To this matrix the inverse power iteration is applied in the three variants of no shift, constant shift and generalized Rayleigh shift in the three stages of the algorithm. It is more efficient to perform the linear algebra operations in polynomial arithmetic and not by matrix operations, however, the properties of the inverse power iteration remain the same.  Real coefficients  The Jenkins–Traub algorithm described earlier works for polynomials with complex coefficients. The same authors also created a three-stage algorithm for polynomials with real coefficients. See Jenkins and Traub A Three-Stage Algorithm for Real Polynomials Using Quadratic Iteration . 5 The algorithm finds either a linear or quadratic factor working completely in real arithmetic. If the complex and real algorithms are applied to the same real polynomial, the real algorithm is about four times as fast. The real algorithm always converges and the rate of convergence is greater than second order.  A connection with the shifted QR algorithm  There is a surprising connection with the shifted QR algorithm for computing matrix eigenvalues. See Dekker and Traub The shifted QR algorithm for Hermitian matrices . 6 Again the shifts may be viewed as Newton-Raphson iteration on a sequence of rational functions converging to a first degree polynomial.  Software and testing  The software for the Jenkins–Traub algorithm was published as Jenkins and Traub [ http://portal.acm.org/citation.cfm?id=361262&coll; ;=portal&dl;=ACM Algorithm 419: Zeros of a Complex Polynomial]. 7 The software for the real algorithm was published as Jenkins [ http://portal.acm.org/citation.cfm?id=355643&coll; ;=ACM&dl;=ACM Algorithm 493: Zeros of a Real Polynomial]. 8  The methods have been extensively tested by many people. As predicted they enjoy faster than quadratic convergence for all distributions of zeros.  However there are polynomials which can cause loss of precision as illustrated by the following example. The polynomial has all its zeros lying on two half-circles of different radii. Wilkinson recommends that it is desirable for stable deflation that smaller zeros be computed first. The second-stage shifts are chosen so that the zeros on the smaller half circle are found first. After deflation the polynomial with the zeros on the half circle is known to be ill-conditioned if the degree is large; see Wilkinson, 9 p. 64. The original polynomial was of degree 60 and suffered severe deflation instability.  References  External links   Additional Bibliography for the Jenkins–Traub Method  Internet Resources for the Jenkins–Traub Method  A free downloadable Windows application using the Jenkins–Traub Method for polynomials with real and complex coefficients  Online Calculator Online Polynomial Calculator using the Jenkins Traub procedure   "  Category:Numerical analysis  Category:Root-finding algorithms     Press, W. H., Teukolsky, S. A., Vetterling, W. T. and Flannery, B. P. (2007), Numerical Recipes: The Art of Scientific Computing, 3rd ed., Cambridge University Press, page 470. ↩  Jenkins, M. A. and Traub, J. F. (1970), A Three-Stage Variables-Shift Iteration for Polynomial Zeros and Its Relation to Generalized Rayleigh Iteration , Numer. Math. 14, 252–263. ↩  Ralston, A. and Rabinowitz, P. (1978), A First Course in Numerical Analysis, 2nd ed., McGraw-Hill, New York. ↩  Traub, J. F. (1966), A Class of Globally Convergent Iteration Functions for the Solution of Polynomial Equations , Math. Comp., 20(93), 113–138. ↩  Jenkins, M. A. and Traub, J. F. (1970), A Three-Stage Algorithm for Real Polynomials Using Quadratic Iteration , SIAM J. Numer. Anal., 7(4), 545–566. ↩  Dekker, T. J. and Traub, J. F. (1971), The shifted QR algorithm for Hermitian matrices , Lin. Algebra Appl., 4(2), 137–154. ↩  Jenkins, M. A. and Traub, J. F. (1972), [ http://portal.acm.org/citation.cfm?id=361262&coll; ;=portal&dl;=ACM Algorithm 419: Zeros of a Complex Polynomial], Comm. ACM, 15, 97–99. ↩  Jenkins, M. A. (1975), [ http://portal.acm.org/citation.cfm?id=355643&coll; ;=ACM&dl;=ACM Algorithm 493: Zeros of a Real Polynomial], ACM TOMS, 1, 178–189. ↩  Wilkinson, J. H. (1963), Rounding Errors in Algebraic Processes, Prentice Hall, Englewood Cliffs, N.J. ↩     