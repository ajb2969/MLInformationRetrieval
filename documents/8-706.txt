   Power iteration      Power iteration  table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */     In mathematics , the power iteration is an eigenvalue algorithm : given a matrix  A , the algorithm will produce a number λ (the eigenvalue ) and a nonzero vector v (the eigenvector), such that Av = λ v . The algorithm is also known as the Von Mises iteration. 1  The power iteration is a very simple algorithm. It does not compute a matrix decomposition , and hence it can be used when A is a very large sparse matrix . However, it will find only one eigenvalue (the one with the greatest absolute value ) and it may converge only slowly.  The method  The power iteration algorithm starts with a vector b 0 , which may be an approximation to the dominant eigenvector or a random vector. The method is described by the iteration        b   k  +  1    =    A   b  k     ∥   A   b  k    ∥     .       subscript  b    k  1        A   subscript  b  k     norm    A   subscript  b  k        b_{k+1}=\frac{Ab_{k}}{\|Ab_{k}\|}.   So, at every iteration, the vector b k is multiplied by the matrix A and normalized.  Under the assumptions:   A has an eigenvalue that is strictly greater in magnitude than its other eigenvalues  The starting vector    b  0     subscript  b  0    b_{0}   has a nonzero component in the direction of an eigenvector associated with the dominant eigenvalue.   then:   A subsequence of    (   b  k   )     subscript  b  k    \left(b_{k}\right)   converges to an eigenvector associated with the dominant eigenvalue   Note that the sequence    (   b  k   )     subscript  b  k    \left(b_{k}\right)   does not necessarily converge. It can be shown that:      b  k   =     e   i   ϕ  k      v  1    +   r  k         subscript  b  k        superscript  e    i   subscript  ϕ  k      subscript  v  1     subscript  r  k      b_{k}=e^{i\phi_{k}}v_{1}+r_{k}   where    v  1     subscript  v  1    v_{1}   is an eigenvector associated with the dominant eigenvalue, and     ∥   r  k   ∥   →  0     normal-→   norm   subscript  r  k    0    \|r_{k}\|\rightarrow 0   . The presence of the term    e   i   ϕ  k       superscript  e    i   subscript  ϕ  k      e^{i\phi_{k}}   implies that    (   b  k   )     subscript  b  k    \left(b_{k}\right)   does not converge unless     e   i   ϕ  k     =  1       superscript  e    i   subscript  ϕ  k     1    e^{i\phi_{k}}=1   Under the two assumptions listed above, the sequence    (   μ  k   )     subscript  μ  k    \left(\mu_{k}\right)   defined by:     μ  k   =     b  k  *   A   b  k      b  k  *    b  k          subscript  μ  k        superscript   subscript  b  k     A   subscript  b  k       superscript   subscript  b  k      subscript  b  k       \mu_{k}=\frac{b_{k}^{*}Ab_{k}}{b_{k}^{*}b_{k}}   converges to the dominant eigenvalue.  This can be run as a simulation program with the following simple algorithm:  for each( '' simulation '' ) { // calculate the matrix-by-vector product Ab  for (i= 0 ; i "0;" (k= "0;" *= "" += "tmp[k]*tmp[k];" <= "" a= "" b= "tmp/norm;" b[j];= "" calculate= "" column= "" dot= ""  for = "" i++)= "" i-th= "" in= "" iteration= "" j++)= "" j "" k++)= "" k "" length= "" next= "" norm= "sqrt(norm_sq);" norm_sq= "" normalize= "" of= "" product= "" resultant= "" row= "" source= "" the= "" tmp[i]= "" to= "" unit= "" vector= "" with= "" {= "" }= "" >
 The value of '' norm '' converges to the absolute value of the dominant eigenvalue, and the vector '' b '' to an associated eigenvector. '' Note: '' The above code assumes real A,b. To handle complex; A[i][j] becomes conj(A[i][j]), and tmp[k]*tmp[k] becomes conj(tmp[k])*tmp[k]
 
 This algorithm is the one used to calculate such things as the Google [[ PageRank ]].
 
 The method can also be used to calculate the [[ spectral  radius ]] of a matrix by computing the [[ Rayleigh  quotient ]]
 : \frac{b_k^\top A b_k}{b_k^\top b_k} = \frac{b_{k +1 }^\top b_k}{b_k^\top b_k}. ==Analysis==
 Let A be decomposed into its [[ Jordan  canonical  form ]]: A=VJV^{ -1 } ,
 where the first column of V is an eigenvector of A corresponding to the dominant eigenvalue \lambda_{ 1 } .
 Since the dominant eigenvalue of A is unique,
 the first Jordan block of J is the 1 \times 1 matrix \begin{bmatrix} \lambda_{ 1 } \end{bmatrix} , where \lambda_{ 1 } is the largest eigenvalue of '' A '' in magnitude.
 The starting vector b_{ 0 } can be written as a linear combination of the columns of V: b_{ 0 } = c_{ 1 }v_{ 1 } + c_{ 2 }v_{ 2 } + \cdots + c_{n}v_{n} .
 By assumption, b_{ 0 } has a nonzero component in the direction of the dominant eigenvalue, so c_{ 1 } \ne 0 .
 
 The computationally useful [[ recurrence  relation ]] for  b_{k +1 } can be rewritten as: b_{k +1 }=\frac{Ab_{k}}{\|Ab_{k}\|}=\frac{A^{k +1 }b_{ 0 }}{\|A^{k +1 }b_{ 0 }\|} ,
 where the expression: \frac{A^{k +1 }b_{ 0 }}{\|A^{k +1 }b_{ 0 }\|} is more amenable to the following analysis.  \displaystyle
 \begin{array}{lcl}
 b_{k} &=& \frac{A^{k}b_{ 0 }}{\| A^{k} b_{ 0 } \|} \\
       &=& \frac{\left( VJV^{ -1 } \right)^{k} b_{ 0 }}{\|\left( VJV^{ -1 } \right)^{k}b_{ 0 }\|} \\
       &=& \frac{ VJ^{k}V^{ -1 } b_{ 0 }}{\| V J^{k} V^{ -1 } b_{ 0 }\|} \\
       &=& \frac{ VJ^{k}V^{ -1 } \left( c_{ 1 }v_{ 1 } + c_{ 2 }v_{ 2 } + \cdots + c_{n}v_{n} \right)}
                {\| V J^{k} V^{ -1 } \left( c_{ 1 }v_{ 1 } + c_{ 2 }v_{ 2 } + \cdots + c_{n}v_{n} \right)\|} \\
       &=& \frac{ VJ^{k}\left( c_{ 1 }e_{ 1 } + c_{ 2 }e_{ 2 } + \cdots + c_{n}e_{n} \right)}
                 {\| V J^{k} \left( c_{ 1 }e_{ 1 } + c_{ 2 }e_{ 2 } + \cdots + c_{n}e_{n} \right) \|} \\
       &=& \left( \frac{\lambda_{ 1 }}{|\lambda_{ 1 }|} \right)^{k} \frac{c_{ 1 }}{|c_{ 1 }|}
           \frac{ v_{ 1 } + \frac{ 1 }{c_{ 1 }} V \left( \frac{ 1 }{\lambda_1} J \right)^{k} 
                       \left( c_{ 2 }e_{ 2 } +  \cdots + c_{n}e_{n} \right)}
                {\| v_{ 1 } + \frac{ 1 }{c_{ 1 }} V \left( \frac{ 1 }{\lambda_1} J \right)^{k} 
                       \left( c_{ 2 }e_{ 2 } +  \cdots + c_{n}e_{n} \right) \| }
            
 \end{array}  The expression above simplifies as k \rightarrow \infty   \left( \frac{ 1 }{\lambda_{ 1 }} J \right)^{k} = 
 \begin{bmatrix}
 [ 1 ] & & & & \\
 & \left( \frac{ 1 }{\lambda_{ 1 }} J_{ 2 } \right)^{k}& & & \\
 & & \ddots & \\
 & & & \left( \frac{ 1 }{\lambda_{ 1 }} J_{m} \right)^{k} \\
 \end{bmatrix}
 \rightarrow
 \begin{bmatrix} 1 & & & & \\
 & 0 & & & \\
 & & \ddots & \\
 & & & 0 \\
 \end{bmatrix} as k \rightarrow \infty . The limit follows from the fact that the eigenvalue of \frac{ 1 }{\lambda_{ 1 }} J_{i} is less than 1 in magnitude, so \left( \frac{ 1 }{\lambda_{ 1 }} J_{i} \right)^{k} \rightarrow 0  as k \rightarrow \infty  It follows that:  \frac{ 1 }{c_{ 1 }} V \left( \frac{ 1 }{\lambda_1} J \right)^{k} 
 \left( c_{ 2 }e_{ 2 } +  \cdots + c_{n}e_{n} \right)
 \rightarrow 0  as k \rightarrow \infty  Using this fact, b_{k} can be written in a form that emphasizes its relationship with v_{ 1 } when k is large:  \begin{matrix}
 b_{k} &=& \left( \frac{\lambda_{ 1 }}{|\lambda_{ 1 }|} \right)^{k} \frac{c_{ 1 }}{|c_{ 1 }|}
           \frac{ v_{ 1 } + \frac{ 1 }{c_{ 1 }} V \left( \frac{ 1 }{\lambda_1} J \right)^{k} 
                       \left( c_{ 2 }e_{ 2 } +  \cdots + c_{n}e_{n} \right)}
                {\| v_{ 1 } + \frac{ 1 }{c_{ 1 }} V \left( \frac{ 1 }{\lambda_1} J \right)^{k} 
                       \left( c_{ 2 }e_{ 2 } +  \cdots + c_{n}e_{n} \right) \| }
       &=& e^{i \phi_{k}} \frac{c_{ 1 }}{|c_{ 1 }|} v_{ 1 } + r_{k}
 \end{matrix} where e^{i \phi_{k}} = \left( \lambda_{ 1 } / |\lambda_{ 1 }| \right)^{k}  and  \| r_{k} \| \rightarrow 0  as k \rightarrow \infty  The sequence \left( b_{k} \right) is bounded, so it contains a convergent subsequence. Note that the eigenvector corresponding to the dominant eigenvalue is only unique up to a scalar, so although the sequence \left(b_{k}\right) may not converge, b_{k} is nearly an eigenvector of '' A ''  for large k.
 
 Alternatively, if  '' A '' is [[ diagonalizable ]], then the following proof yields the same result Let λ 1 , λ 2 , …, λ '' m '' be the m eigenvalues (counted with multiplicity) of A  and let '' v '' 1 , '' v '' 2 , …, '' v '' '' m '' be the corresponding eigenvectors.  Suppose that \lambda_1 is the dominant eigenvalue, so that |\lambda_1| > |\lambda_j|  for  j> 1 .
 
 The initial vector b_0 can be written:
 : b_0 = c_{ 1 }v_{ 1 } + c_{ 2 }v_{ 2 } + \cdots + c_{m}v_{m}. If b_0 is chosen randomly (with uniform probability), then '' c '' 1 ≠ 0 with [[ Almost  surely | probability  1 ]].  Now,
 : \begin{array}{lcl}A^{k}b_0 & = & c_{ 1 }A^{k}v_{ 1 } + c_{ 2 }A^{k}v_{ 2 } + \cdots + c_{m}A^{k}v_{m} \\
 & = & c_{ 1 }\lambda_{ 1 }^{k}v_{ 1 } + c_{ 2 }\lambda_{ 2 }^{k}v_{ 2 } + \cdots + c_{m}\lambda_{m}^{k}v_{m} \\
 & = & c_{ 1 }\lambda_{ 1 }^{k} \left( v_{ 1 } + \frac{c_{ 2 }}{c_{ 1 }}\left(\frac{\lambda_{ 2 }}{\lambda_{ 1 }}\right)^{k}v_{ 2 } + \cdots + \frac{c_{m}}{c_{ 1 }}\left(\frac{\lambda_{m}}{\lambda_{ 1 }}\right)^{k}v_{m}\right). \end{array} The expression within parentheses converges to v_1 because |\lambda_j/\lambda_1| < 1  for  j> 1 . On the other hand, we have
 : b_k = \frac{A^kb_0}{\|A^kb_0\|}. Therefore, b_k converges to (a multiple of) the eigenvector v_1 . The convergence is [[ geometric  sequence | geometric ]], with ratio
 : \left| \frac{\lambda_2}{\lambda_1} \right|, where \lambda_2 denotes the second dominant eigenvalue. Thus, the method converges slowly if there is an eigenvalue close in magnitude to the dominant eigenvalue.
 
 ==Applications==
 Although the power iteration method approximates only one eigenvalue of a matrix, it remains useful for certain [[ computational  problem ]]s. For instance, [[ Google ]] uses it to calculate the [[ PageRank ]] of documents in their search engine, {{cite news|author=Ipsen, Ilse, and Rebecca M. Wills|url=http: //www4.ncsu.edu/~ipsen/ps/slides_imacs.pdf|title=7th IMACS International Symposium on Iterative Methods in Scientific Computing|location=Fields Institute, Toronto, Canada|date=5–8 May 2005}} and [[Twitter]] uses it to show users recommendations of who to follow. Pankaj Gupta, Ashish Goel, Jimmy Lin, Aneesh Sharma, Dong Wang, and Reza Bosagh Zadeh [http://dl.acm.org/citation.cfm?id=2488433 WTF: The who-to-follow system at Twitter], Proceedings of the 22nd international conference on World Wide Web For matrices that are well-conditioned and as sparse as the Web matrix, the power iteration method can be more efficient than other methods of finding the dominant eigenvector.
 
 Some of the more advanced eigenvalue algorithms can be understood as variations of the power iteration. For instance, the [[ inverse  iteration ]] method applies power iteration to the matrix A^{ -1 } . Other algorithms look at the whole subspace generated by the vectors b_k . This subspace is known as the [[ Krylov  subspace ]]. It can be computed by [[ Arnoldi  iteration ]] or [[ Lanczos  iteration ]].
 Another variation of the power method that simultaneously gives n eigenvalues and eigenfunctions,
 as well as accelerated convergence as \left| \lambda_{n +1 } / \lambda_1\right|, is "Multiple extremal eigenpairs by the power method" in the Journal of Computational Physics
 Volume 227 Issue 19 , October, 2008 ,
 Pages 8508-8522 (Also see pdf below for Los Alamos National Laboratory report LA-UR -07 -4046 )
 
 ==See also==
 * [[ Rayleigh  quotient  iteration ]]
 * [[ Inverse  iteration ]]
 
 ==References==
 {{Reflist}}
 
 ==External links==
 * [http: //www.math.buffalo.edu/~pitman/courses/mth437/na2/node17.html Power method], part of lecture notes on numerical linear algebra by E. Bruce Pitman, State University of New York. * [http: //math.fullerton.edu/mathews/n2003/PowerMethodMod.html Module for the Power Method] * [http: //arxiv.org/pdf/0807.1261.pdf] Los Alamos report LA-UR-07-4046 ""Multiple extremal eigenpairs by the power method" {{Numerical linear algebra}}
 {{Use dmy dates|date=September 2010 }}
 {{DEFAULTSORT:Power Iteration}}
 [[ Category:Numerical  linear  algebra ]] "      Richard von Mises and H. Pollaczek-Geiringer, Praktische Verfahren der Gleichungsauflösung , ZAMM - Zeitschrift für Angewandte Mathematik und Mechanik 9, 152-164 (1929). ↩   