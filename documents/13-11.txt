   Matrix multiplication algorithm      Matrix multiplication algorithm   Because matrix multiplication is such a central operation in many numerical algorithms , much work has been invested in making matrix multiplication algorithms efficient. Applications of matrix multiplication in computational problems are found in many fields including scientific computing and pattern recognition and in seemingly unrelated problems such counting the paths through a graph . 1 Many different algorithms have been designed for multiplying matrices on different types of hardware, including parallel and distributed systems, where the computational work is spread over multiple processors (perhaps over a network).  Directly applying the mathematical definition of matrix multiplication gives an algorithm that takes time on the order of to multiply two    n  ×  n      n  normal-×  n    n×n   matrices ( in big O notation ). Better asymptotic bounds on the time required to multiply matrices have been known since the work of Strassen in the 1960s, but it is still unknown what the optimal time is (i.e., what the complexity of the problem is).  Iterative algorithm  The definition of matrix multiplication is that if    C  =   A  B       C    A  B     C=AB   for an    n  ×  m      n  normal-×  m    n×m   matrix   A   A   A   and an    m  ×  p      m  normal-×  p    m×p   matrix   B   B   B   , then   C   C   C   is an    n  ×  p      n  normal-×  p    n×p   matrix with entries       c   i  j    =    ∑   k  =  1   m     a   i  k     b   k  j           subscript  c    i  j      superscript   subscript     k  1    m      subscript  a    i  k     subscript  b    k  j        c_{ij}=\sum_{k=1}^{m}a_{ik}b_{kj}   .  From this, a simple algorithm can be constructed which loops over the indices   i   i   i   from 1 through   n   n   n   and   j   j   j   from 1 through   p   p   p   , computing the above using a nested loop:    Input: matrices   A   A   A   and   B   B   B     Let   C   C   C   be a new matrix of the appropriate size  For   i   i   i   from 1 to   n   n   n   :  For   j   j   j   from 1 to   p   p   p   :  Let     s  u  m   =  0        s  u  m   0    sum=0     For   k   k   k   from 1 to   m   m   m   :  Set   Set    Return   C   C   C       This algorithms takes time     Θ   (   n  m  p   )       normal-Θ    n  m  p     Θ(nmp)   (in asymptotic notation ), 2 or in the case of square matrices, all of shape    n  ×  n      n  normal-×  n    n×n   . 3  Cache behavior  The three loops in iterative matrix multiplication can be arbitrarily swapped with each other without an effect on correctness or asymptotic running time. The order can have an impact on practical performance due to the memory access patterns and cache use of the algorithm; 4 which order is best also depends on whether the matrices are stored in row-major order , column-major order, or a mix of both.  In particular, in the idealized case of a fully associative cache consisting of   M   M   M   cache lines of   b   b   b   bytes each, the above algorithm is suboptimal for   A   A   A   and   B   B   B   stored in row-major order. When    n  >   M  ∕  b       n    M  normal-∕  b     n>M∕b   , every iteration of the inner loop (a simultaneous sweep through a row of   A   A   A   and a column of   B   B   B   ) incurs a cache miss when accessing an element of   B   B   B   . This means the algorithm incurs cache misses in the worst case. , the speed of memories compared to that of processors is such that the cache misses, rather than the actual calculations, dominate the running time. 5  Divide and conquer algorithm  An alternative to the iterative algorithm is the divide and conquer algorithm for matrix multiplication. This relies on the block partitioning       C  =   (      C  11      C  12        C  21      C  22      )    ,    A  =   (      A  11      A  12        A  21      A  22      )    ,   B  =   (      B  11      B  12        B  21      B  22      )        formulae-sequence    C     subscript  C  11    subscript  C  12      subscript  C  21    subscript  C  22       formulae-sequence    A     subscript  A  11    subscript  A  12      subscript  A  21    subscript  A  22        B     subscript  B  11    subscript  B  12      subscript  B  21    subscript  B  22         C=\begin{pmatrix}C_{11}&C_{12}\\
 C_{21}&C_{22}\\
 \end{pmatrix},\,A=\begin{pmatrix}A_{11}&A_{12}\\
 A_{21}&A_{22}\\
 \end{pmatrix},\,B=\begin{pmatrix}B_{11}&B_{12}\\
 B_{21}&B_{22}\\
 \end{pmatrix}   .  which works for all square matrices whose dimensions are powers of two, i.e., the shapes are for some   n   n   n   . The matrix product is now       (      C  11      C  12        C  21      C  22      )   =    (      A  11      A  12        A  21      A  22      )    (      B  11      B  12        B  21      B  22      )    =   (        A  11    B  11    +    A  12    B  21          A  11    B  12    +    A  12    B  22            A  21    B  11    +    A  22    B  21          A  21    B  12    +    A  22    B  22        )            subscript  C  11    subscript  C  12      subscript  C  21    subscript  C  22          subscript  A  11    subscript  A  12      subscript  A  21    subscript  A  22        subscript  B  11    subscript  B  12      subscript  B  21    subscript  B  22                  subscript  A  11    subscript  B  11       subscript  A  12    subscript  B  21          subscript  A  11    subscript  B  12       subscript  A  12    subscript  B  22            subscript  A  21    subscript  B  11       subscript  A  22    subscript  B  21          subscript  A  21    subscript  B  12       subscript  A  22    subscript  B  22          \begin{pmatrix}C_{11}&C_{12}\\
 C_{21}&C_{22}\\
 \end{pmatrix}=\begin{pmatrix}A_{11}&A_{12}\\
 A_{21}&A_{22}\\
 \end{pmatrix}\begin{pmatrix}B_{11}&B_{12}\\
 B_{21}&B_{22}\\
 \end{pmatrix}=\begin{pmatrix}A_{11}B_{11}+A_{12}B_{21}&A_{11}B_{12}+A_{12}B_{2%
 2}\\
 A_{21}B_{11}+A_{22}B_{21}&A_{21}B_{12}+A_{22}B_{22}\\
 \end{pmatrix}     which consists of eight multiplications of pairs of submatrices, followed by an addition step. The divide and conquer algorithm computes the smaller multiplications recursively , using the scalar multiplication   a 11 b 11 }} as its base case.  The complexity of this algorithm as a function of   n   n   n   is given by the recurrence 6       T   (  1  )    =   Θ   (  1  )          T  1     normal-Θ  1     T(1)=\Theta(1)   ;       T   (  n  )    =    8  T   (   n  /  2   )    +   Θ   (   n  2   )           T  n       8  T    n  2      normal-Θ   superscript  n  2       T(n)=8T(n/2)+\Theta(n^{2})   ,  accounting for the eight recursive calls on matrices of size    n  /  2      n  2    n/2   and to sum the four pairs of resulting matrices element-wise. Application of the master theorem shows this recursion to have the solution , the same as the iterative algorithm. 7  Non-square matrices  A variant of this algorithm that works for matrices of arbitrary shapes and is faster in practice 8 splits matrices in two instead of four submatrices, as follows. 9 Let matrix shapes be    n  ×  m      n  normal-×  m    n×m   for   A   A   A   and    m  ×  p      m  normal-×  p    m×p   for   B   B   B   . Splitting a matrix means dividing it into two parts of equal size, or as close to equal sizes as possible in the case of odd dimensions.    Base case:    m  a  x   (  n  ,  m  ,  p  )       m  a  x   n  m  p     max(n,m,p)   below some threshold, use an unrolled version of the iterative algorithm.    Recursive cases:   :* If     m  a  x   (  n  ,  m  ,  p  )    =  n        m  a  x   n  m  p    n    max(n,m,p)=n   , split   A   A   A   horizontally:    C = \begin{pmatrix} A_1 \\ A_2 \end{pmatrix} {B}     = \begin{pmatrix} A_1 B \\ A_2 B \end{pmatrix}  :* Else, if     m  a  x   (  n  ,  m  ,  p  )    =  p        m  a  x   n  m  p    p    max(n,m,p)=p   , split   B   B   B   vertically:    C = A \begin{pmatrix} B_1 & B_2 \end{pmatrix}     = \begin{pmatrix} A B_1 & A B_2 \end{pmatrix}  :* Otherwise,     m  a  x   (  n  ,  m  ,  p  )    =  m        m  a  x   n  m  p    m    max(n,m,p)=m   . Split   A   A   A   vertically and   B   B   B   horizontally:    C = \begin{pmatrix} A_1 & A_2 \end{pmatrix} \begin{pmatrix} B_1 \\ B_2 \end{pmatrix}     = A_1 B_1 + A_2 B_2   Cache behavior  The cache miss rate of recursive matrix multiplication is the same as that of a tiled iterative version, but unlike that algorithm, the recursive algorithm is cache-oblivious : 10 there is no tuning parameter required to get optimal cache performance, and it behaves well in a multiprogramming environment where cache sizes are effectively dynamic due to other processes taking up cache space. 11 (The simple iterative algorithm is cache-oblivious as well, but much slower in practice if the matrix layout is not adapted to the algorithm.)  Sub-cubic algorithms  (Figure)  The bound on   ω   ω   ω   over time.   Algorithms exist that provide better running times than the straightforward ones. The first to be discovered was Strassen's algorithm , devised by Volker Strassen in 1969 and often referred to as "fast matrix multiplication". It is based on a way of multiplying two    2  ×  2      2  normal-×  2    2×2   -matrices which requires only 7 multiplications (instead of the usual 8), at the expense of several additional addition and subtraction operations. Applying this recursively gives an algorithm with a multiplicative cost of     O   (   n    log  2   7    )    ≈   O   (   n  2.807   )          O   superscript  n    subscript   2   7       O   superscript  n  2.807      O(n^{\log_{2}7})\approx O(n^{2.807})   . Strassen's algorithm is more complex, and the numerical stability is reduced compared to the naïve algorithm, 12 but it is faster in cases where    n  >  100      n  100    n>100   or so 13 and appears in several libraries, such as BLAS . 14 It is very useful for large matrices over exact domains such as finite fields, where numerical stability is not an issue.  The current algorithm with the lowest known exponent   k   k   k   is a generalization of the Coppersmith–Winograd algorithm that has an asymptotic complexity of , by François Le Gall. 15 The Le Gall algorithm, and the Coppersmith–Winograd algorithm on which it is based, are similar to Strassen's algorithm: a way is devised for multiplying two    k  ×  k      k  normal-×  k    k×k   -matrices with fewer than multiplications, and this technique is applied recursively. However, the constant coefficient hidden by the Big O notation is so large that these algorithms are only worthwhile for matrices that are too large to handle on present-day computers. 16 17  Since any algorithm for multiplying two    n  ×  n      n  normal-×  n    n×n   -matrices has to process all -entries, there is an asymptotic lower bound of operations. Raz proves a lower bound of for bounded coefficient arithmetic circuits over the real or complex numbers. 18  Cohn et al. put methods such as the Strassen and Coppersmith–Winograd algorithms in an entirely different group-theoretic context, by utilising triples of subsets of finite groups which satisfy a disjointness property called the triple product property (TPP) . They show that if families of wreath products of Abelian groups with symmetric groups realise families of subset triples with a simultaneous version of the TPP, then there are matrix multiplication algorithms with essentially quadratic complexity. 19 20 Most researchers believe that this is indeed the case. 21 However, Alon, Shpilka and Chris Umans have recently shown that some of these conjectures implying fast matrix multiplication are incompatible with another plausible conjecture, the sunflower conjecture . 22  Freivalds' algorithm is a simple Monte Carlo algorithm that, given matrices   A   A   A   ,   B   B   B   and   C   C   C   , verifies in time if     A  B   =  C        A  B   C    AB=C   .  Parallel and distributed algorithms  Shared-memory parallelism  The divide and conquer algorithm sketched earlier can be parallelized in two ways for shared-memory multiprocessors . These are based on the fact that the eight recursive matrix multiplications in      (        A  11    B  11    +    A  12    B  21          A  11    B  12    +    A  12    B  22            A  21    B  11    +    A  22    B  21          A  21    B  12    +    A  22    B  22        )           subscript  A  11    subscript  B  11       subscript  A  12    subscript  B  21          subscript  A  11    subscript  B  12       subscript  A  12    subscript  B  22            subscript  A  21    subscript  B  11       subscript  A  22    subscript  B  21          subscript  A  21    subscript  B  12       subscript  A  22    subscript  B  22        \begin{pmatrix}A_{11}B_{11}+A_{12}B_{21}&A_{11}B_{12}+A_{12}B_{22}\\
 A_{21}B_{11}+A_{22}B_{21}&A_{21}B_{12}+A_{22}B_{22}\\
 \end{pmatrix}     can be performed independently of each other, as can the four summations (although the algorithm needs to "join" the multiplications before doing the summations). Exploiting the full parallelism of the problem, one obtains an algorithm that can be expressed in fork–join style  pseudocode : 23   Procedure     m  u  l  t  i  p  l  y   (  C  ,  A  ,  B  )       m  u  l  t  i  p  l  y   C  A  B     multiply(C,A,B)   :   Base case: if    n  =  1      n  1    n=1   , set (or multiply a small block matrix).  Otherwise, allocate space for a new matrix   T   T   T   of shape    n  ×  n      n  normal-×  n    n×n   , then:  Partition   A   A   A   into , , , .  Partition   B   B   B   into , , , .  Partition   C   C   C   into , , , .  Partition   T   T   T   into , , , .  Parallel execution:  Fork  .  Fork  .  Fork  .  Fork  .  Fork  .  Fork  .  Fork  .  Fork  .   Join (wait for parallel forks to complete).      a  d  d   (  C  ,  T  )       a  d  d   C  T     add(C,T)   .  Deallocate   T   T   T   .    Procedure     a  d  d   (  C  ,  T  )       a  d  d   C  T     add(C,T)   adds   T   T   T   into   C   C   C   , element-wise:   Base case: if    n  =  1      n  1    n=1   , set (or do a short loop, perhaps unrolled).  Otherwise:  Partition   C   C   C   into , , , .  Partition   T   T   T   into , , , .  In parallel:  Fork  .  Fork  .  Fork  .  Fork  .   Join .     Here, fork is a keyword that signal a computation may be run in parallel with the rest of the function call, while join waits for all previously "forked" computations to complete.    p  a  r  t  i  t  i  o  n      p  a  r  t  i  t  i  o  n    partition   achieves its goal by pointer manipulation only.  This algorithm has a critical path length of steps, meaning it takes that much time on an ideal machine with an infinite number of processors; therefore, it has a maximum possible speedup of on any real computer. The algorithm isn't practical due to the communication cost inherent in moving data to and from the temporary matrix   T   T   T   , but a more practical variant achieves speedup, without using a temporary. 24  (Figure)  Block matrix multiplication. In the 2D algorithm, each processor is responsible for one submatrix of   C   C   C   . In the 3D algorithm, every pair of submatrices from   A   A   A   and   B   B   B   that is multiplied is assigned to one processor.   Communication-avoiding and distributed algorithms  On modern architectures with hierarchical memory, the cost of loading and storing input matrix elements tends to dominate the cost of arithmetic. On a single machine this is the amount of data transferred between RAM and cache, while on a distributed memory multi-node machine it is the amount transferred between nodes; in either case it is called the communication bandwidth . The naïve algorithm using three nested loops uses communication bandwidth.  Cannon's algorithm , also known as the 2D algorithm , partitions each input matrix into a block matrix whose elements are submatrices of size     M   /  3        M   3    \sqrt{M}{/3}   by     M   /  3        M   3    \sqrt{M}{/3}   , where   M   M   M   is the size of fast memory. 25 The naïve algorithm is then used over the block matrices, computing products of submatrices entirely in fast memory. This reduces communication bandwidth to , which is asymptotically optimal (for algorithms performing computation). 26 27  In a distributed setting with   p   p   p   processors arranged in a    p      p    \sqrt{p}   by    p      p    \sqrt{p}   2D mesh, one submatrix of the result can be assigned to each processor, and the product can be computed with each processor transmitting words, which is asymptotically optimal assuming that each node stores the minimum elements. 28 This can be improved by the 3D algorithm, which arranges the processors in a 3D cube mesh, assigning every product of two input submatrices to a single processor. The result submatrices are then generated by performing a reduction over each row. 29 This algorithm transmits words per processor, which is asymptotically optimal. 30 However, this requires replicating each input matrix element times, and so requires a factor of more memory than is needed to store the inputs. This algorithm can be combined with Strassen to further reduce runtime. 31 "2.5D" algorithms provide a continuous tradeoff between memory usage and communication bandwidth. 32 On modern distributed computing environments such as MapReduce , specialized multiplication algorithms have been developed. 33  Algorithms for meshes  There are a variety of algorithms for multiplication on meshes . For multiplication of two n×n on a standard two-dimensional mesh using the 2D Cannon's algorithm , one can complete the multiplication in 3n-2 steps although this is reduced to half this number for repeated computations. 34 The standard array is inefficient because the data from the two matrices does not arrive simultaneously and it must be padded with zeroes.  The result is even faster on a two-layered cross-wired mesh, where only 2n-1 steps are needed. 35 The performance improves further for repeated computations leading to 100% efficiency. 36 The cross-wired mesh array may be seen as a special case of a non-planar (i.e. multilayered) processing structure. 37   See also   Computational complexity of mathematical operations  CYK algorithm, §Valiant's algorithm  Matrix chain multiplication  Sparse matrix-vector multiplication   References  Further reading      "         ↩  ↩  ↩     ↩    ↩   ↩  . The original algorithm was presented by Don Coppersmith and Shmuel Winograd in 1990, has an asymptotic complexity of . It was improved in 2013 to by Virginia Vassilevska Williams, giving a time only slightly worse than Le Gall's improvement: ↩  ↩  ↩  Ran Raz . On the complexity of matrix product. In Proceedings of the thirty-fourth annual ACM symposium on Theory of computing. ACM Press, 2002. . ↩  Henry Cohn, Robert Kleinberg , Balázs Szegedy , and Chris Umans. Group-theoretic Algorithms for Matrix Multiplication. . Proceedings of the 46th Annual Symposium on Foundations of Computer Science , 23–25 October 2005, Pittsburgh, PA, IEEE Computer Society, pp. 379–388. ↩  Henry Cohn, Chris Umans. A Group-theoretic Approach to Fast Matrix Multiplication. . Proceedings of the 44th Annual IEEE Symposium on Foundations of Computer Science , 11–14 October 2003, Cambridge, MA, IEEE Computer Society, pp. 438–449. ↩   Alon , Shpilka, Umans, On Sunflowers and Matrix Multiplication ↩   ↩  Lynn Elliot Cannon, [ http://portal.acm.org/citation.cfm?coll=GUIDE&dl; ;=GUIDE&id;=905686 A cellular computer to implement the Kalman Filter Algorithm] , Technical report, Ph.D. Thesis, Montana State University, 14 July 1969. ↩  ↩  ↩   ↩    ↩  ↩  Bae, S.E., T.-W. Shinn, T. Takaoka (2014) A faster parallel algorithm for matrix multiplication on a mesh array. Procedia Computer Science 29: 2230-2240 ↩  Kak, S. (1988) A two-layered mesh array for matrix multiplication. Parallel Computing 6: 383-385 ↩  Kak, S. (2014) Efficiency of matrix multiplication on the cross-wired mesh array. http://arxiv.org/abs/1411.3273 ↩  Kak, S. (1988) Multilayered array computing. Information Sciences 45: 347-365 ↩     