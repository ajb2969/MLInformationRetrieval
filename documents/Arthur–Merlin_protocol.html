<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="158">Arthur–Merlin protocol</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Arthur–Merlin protocol</h1>
<hr/>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, an <strong>Arthur–Merlin protocol</strong> is an <a href="interactive_proof_system" title="wikilink">interactive proof system</a> in which the verifier's coin tosses are constrained to be public (i.e. known to the prover too). This notion was introduced by .  proved that all languages with interactive proofs of arbitrary length with private coins also have interactive proofs with public coins.</p>

<p>The basic assumption is that Arthur is a standard computer (or verifier) equipped with a <a href="Random_number_generation" title="wikilink">random number generating device</a>, while Merlin is effectively an <a href="oracle_(computer_science)" title="wikilink">oracle</a> with infinite computational power (also known as a prover); but Merlin is not necessarily honest, so Arthur must analyze the information provided by Merlin in response to Arthur's queries and decide the problem itself. A problem is considered to be solvable by this protocol if whenever the answer is "yes", Merlin has some series of responses which will cause Arthur to accept at least 2/3 of the time, and if whenever the answer is "no", Arthur will never accept more than 1/3 of the time. Thus, Arthur acts as a probabilistic polynomial-time verifier, assuming it is allotted polynomial time to make its decisions and queries.</p>
<h2 id="ma">MA</h2>

<p>The simplest such protocol is the 1-message protocol where Merlin sends Arthur a message, and then Arthur decides whether to accept or not by running a probabilistic polynomial time computation. (This is similar to the verifier-based definition of NP, the only difference being that Arthur is allowed to use randomness here.) Merlin does not have access to Arthur's coin tosses in this protocol, since it is a single-message protocol and Arthur tosses his coins only after receiving Merlin's message. This protocol is called <em>MA</em>. Informally, a language <em>L</em> is in <strong>MA</strong> if for all strings in the language, there is a polynomial sized proof that Merlin can send Arthur to convince him of this fact with high probability, and for all strings not in the language there is no proof that convinces Arthur with high probability. However, Arthur is not necessarily a <strong>BPP</strong> verifier as it is not known whether <strong>MA</strong> is contained in the class <strong>

<math display="inline" id="Arthur–Merlin_protocol:0">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mrow>
    <mi>B</mi>
    <mi>P</mi>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <apply>
     <times></times>
     <ci>B</ci>
     <ci>P</ci>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists BPP
  </annotation>
 </semantics>
</math>

</strong>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Formally, the complexity class <strong>MA</strong> is the set of decision problems that can be decided in polynomial time by an Arthur–Merlin protocol where Merlin's only move precedes any computation by Arthur. In other words, a language <em>L</em> is in <strong>MA</strong> if there exists a polynomial-time deterministic Turing machine <em>M</em> and polynomials <em>p</em>, <em>q</em> such that for every input string <em>x</em> of length <em>n</em> = |<em>x</em>|,</p>
<ul>
<li>if <em>x</em> is in <em>L</em>, then 

<math display="inline" id="Arthur–Merlin_protocol:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∃</mo>
     <mi>z</mi>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <msup>
       <mrow>
        <mo stretchy="false">{</mo>
        <mn>0</mn>
        <mo>,</mo>
        <mn>1</mn>
        <mo stretchy="false">}</mo>
       </mrow>
       <mrow>
        <mi>q</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </msup>
     </mpadded>
     <mrow>
      <msub>
       <mi>Pr</mi>
       <mrow>
        <mi>y</mi>
        <mo>∈</mo>
        <msup>
         <mrow>
          <mo stretchy="false">{</mo>
          <mn>0</mn>
          <mo>,</mo>
          <mn>1</mn>
          <mo stretchy="false">}</mo>
         </mrow>
         <mrow>
          <mi>p</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>n</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </msup>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>M</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo>,</mo>
          <mi>y</mi>
          <mo>,</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mn>2</mn>
     <mo>/</mo>
     <mn>3</mn>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <apply>
      <exists></exists>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <set>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </set>
       <apply>
        <times></times>
        <ci>q</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Pr</ci>
        <apply>
         <in></in>
         <ci>y</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <set>
           <cn type="integer">0</cn>
           <cn type="integer">1</cn>
          </set>
          <apply>
           <times></times>
           <ci>p</ci>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <ci>M</ci>
         <vector>
          <ci>x</ci>
          <ci>y</ci>
          <ci>z</ci>
         </vector>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists z\in\{0,1\}^{q(n)}\,\Pr\nolimits_{y\in\{0,1\}^{p(n)}}(M(x,y,z)=1)\geq 2%
/3,
  </annotation>
 </semantics>
</math>

</li>
<li>if <em>x</em> is not in <em>L</em>, then 

<math display="inline" id="Arthur–Merlin_protocol:2">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>z</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <msup>
      <mrow>
       <mo stretchy="false">{</mo>
       <mn>0</mn>
       <mo>,</mo>
       <mn>1</mn>
       <mo stretchy="false">}</mo>
      </mrow>
      <mrow>
       <mi>q</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msup>
    </mpadded>
    <mrow>
     <msub>
      <mi>Pr</mi>
      <mrow>
       <mi>y</mi>
       <mo>∈</mo>
       <msup>
        <mrow>
         <mo stretchy="false">{</mo>
         <mn>0</mn>
         <mo>,</mo>
         <mn>1</mn>
         <mo stretchy="false">}</mo>
        </mrow>
        <mrow>
         <mi>p</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </msup>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>M</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>y</mi>
         <mo>,</mo>
         <mi>z</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mn>2</mn>
    <mo>/</mo>
    <mn>3.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <set>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </set>
       <apply>
        <times></times>
        <ci>q</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Pr</ci>
        <apply>
         <in></in>
         <ci>y</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <set>
           <cn type="integer">0</cn>
           <cn type="integer">1</cn>
          </set>
          <apply>
           <times></times>
           <ci>p</ci>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <ci>M</ci>
         <vector>
          <ci>x</ci>
          <ci>y</ci>
          <ci>z</ci>
         </vector>
        </apply>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <cn type="float">3.</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall z\in\{0,1\}^{q(n)}\,\Pr\nolimits_{y\in\{0,1\}^{p(n)}}(M(x,y,z)=0)\geq 2%
/3.
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>The second condition can alternately be written as</p>
<ul>
<li>if <em>x</em> is not in <em>L</em>, then 

<math display="inline" id="Arthur–Merlin_protocol:3">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>z</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <msup>
      <mrow>
       <mo stretchy="false">{</mo>
       <mn>0</mn>
       <mo>,</mo>
       <mn>1</mn>
       <mo stretchy="false">}</mo>
      </mrow>
      <mrow>
       <mi>q</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msup>
    </mpadded>
    <mrow>
     <msub>
      <mi>Pr</mi>
      <mrow>
       <mi>y</mi>
       <mo>∈</mo>
       <msup>
        <mrow>
         <mo stretchy="false">{</mo>
         <mn>0</mn>
         <mo>,</mo>
         <mn>1</mn>
         <mo stretchy="false">}</mo>
        </mrow>
        <mrow>
         <mi>p</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </msup>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>M</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>y</mi>
         <mo>,</mo>
         <mi>z</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>3.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <set>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </set>
       <apply>
        <times></times>
        <ci>q</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Pr</ci>
        <apply>
         <in></in>
         <ci>y</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <set>
           <cn type="integer">0</cn>
           <cn type="integer">1</cn>
          </set>
          <apply>
           <times></times>
           <ci>p</ci>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <ci>M</ci>
         <vector>
          <ci>x</ci>
          <ci>y</ci>
          <ci>z</ci>
         </vector>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="float">3.</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall z\in\{0,1\}^{q(n)}\,\Pr\nolimits_{y\in\{0,1\}^{p(n)}}(M(x,y,z)=1)\leq 1%
/3.
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>To compare this with the informal definition above, <em>z</em> is the alleged proof from Merlin (whose size is bounded by a polynomial) and <em>y</em> is the random string that Arthur uses, which is also polynomially bounded.</p>
<h2 id="am">AM</h2>

<p>The <a href="complexity_class" title="wikilink">complexity class</a> <strong>AM</strong> (or <strong>AM[2]</strong>) is the set of <a href="decision_problem" title="wikilink">decision problems</a> that can be decided in polynomial time by an Arthur–Merlin protocol with two messages. There is only one query/response pair: Arthur tosses some random coins and sends the outcome of <em>all</em> his coin tosses to Merlin, Merlin responds with a purported proof, and Arthur deterministically verifies the proof. In this protocol, Arthur is only allowed to send outcomes of coin tosses to Merlin, and in the final stage Arthur must decide whether to accept or reject using only his previously generated random coin flips and Merlin's message.</p>

<p>In other words, a language <em>L</em> is in <strong>AM</strong> if there exists a polynomial-time deterministic Turing machine <em>M</em> and polynomials <em>p</em>, <em>q</em> such that for every input string <em>x</em> of length <em>n</em> = |<em>x</em>|,</p>
<ul>
<li>if <em>x</em> is in <em>L</em>, then 

<math display="inline" id="Arthur–Merlin_protocol:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>Pr</mi>
      <mrow>
       <mi>y</mi>
       <mo>∈</mo>
       <msup>
        <mrow>
         <mo stretchy="false">{</mo>
         <mn>0</mn>
         <mo>,</mo>
         <mn>1</mn>
         <mo stretchy="false">}</mo>
        </mrow>
        <mrow>
         <mi>p</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </msup>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo>∃</mo>
        <mi>z</mi>
       </mrow>
       <mo>∈</mo>
       <mrow>
        <mpadded width="+1.7pt">
         <msup>
          <mrow>
           <mo stretchy="false">{</mo>
           <mn>0</mn>
           <mo>,</mo>
           <mn>1</mn>
           <mo stretchy="false">}</mo>
          </mrow>
          <mrow>
           <mi>q</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </msup>
        </mpadded>
        <mi>M</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>y</mi>
         <mo>,</mo>
         <mi>z</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mn>2</mn>
     <mo>/</mo>
     <mn>3</mn>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Pr</ci>
      <apply>
       <in></in>
       <ci>y</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <set>
         <cn type="integer">0</cn>
         <cn type="integer">1</cn>
        </set>
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <and></and>
      <apply>
       <in></in>
       <apply>
        <exists></exists>
        <ci>z</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <set>
          <cn type="integer">0</cn>
          <cn type="integer">1</cn>
         </set>
         <apply>
          <times></times>
          <ci>q</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <ci>M</ci>
        <vector>
         <ci>x</ci>
         <ci>y</ci>
         <ci>z</ci>
        </vector>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <share href="#.cmml">
       </share>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr\nolimits_{y\in\{0,1\}^{p(n)}}(\exists z\in\{0,1\}^{q(n)}\,M(x,y,z)=1)\geq 2%
/3,
  </annotation>
 </semantics>
</math>

</li>
<li>if <em>x</em> is not in <em>L</em>, then 

<math display="inline" id="Arthur–Merlin_protocol:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Pr</mi>
     <mrow>
      <mi>y</mi>
      <mo>∈</mo>
      <msup>
       <mrow>
        <mo stretchy="false">{</mo>
        <mn>0</mn>
        <mo>,</mo>
        <mn>1</mn>
        <mo stretchy="false">}</mo>
       </mrow>
       <mrow>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </msup>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo>∀</mo>
       <mi>z</mi>
      </mrow>
      <mo>∈</mo>
      <mrow>
       <mpadded width="+1.7pt">
        <msup>
         <mrow>
          <mo stretchy="false">{</mo>
          <mn>0</mn>
          <mo>,</mo>
          <mn>1</mn>
          <mo stretchy="false">}</mo>
         </mrow>
         <mrow>
          <mi>q</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>n</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </msup>
       </mpadded>
       <mi>M</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo>,</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mn>2</mn>
    <mo>/</mo>
    <mn>3.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Pr</ci>
      <apply>
       <in></in>
       <ci>y</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <set>
         <cn type="integer">0</cn>
         <cn type="integer">1</cn>
        </set>
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <and></and>
      <apply>
       <in></in>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <ci>z</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <set>
          <cn type="integer">0</cn>
          <cn type="integer">1</cn>
         </set>
         <apply>
          <times></times>
          <ci>q</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <ci>M</ci>
        <vector>
         <ci>x</ci>
         <ci>y</ci>
         <ci>z</ci>
        </vector>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <share href="#.cmml">
       </share>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <cn type="float">3.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr\nolimits_{y\in\{0,1\}^{p(n)}}(\forall z\in\{0,1\}^{q(n)}\,M(x,y,z)=0)\geq 2%
/3.
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>The second condition here can be rewritten as</p>
<ul>
<li>if <em>x</em> is not in <em>L</em>, then 

<math display="inline" id="Arthur–Merlin_protocol:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Pr</mi>
     <mrow>
      <mi>y</mi>
      <mo>∈</mo>
      <msup>
       <mrow>
        <mo stretchy="false">{</mo>
        <mn>0</mn>
        <mo>,</mo>
        <mn>1</mn>
        <mo stretchy="false">}</mo>
       </mrow>
       <mrow>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </msup>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo>∃</mo>
       <mi>z</mi>
      </mrow>
      <mo>∈</mo>
      <mrow>
       <mpadded width="+1.7pt">
        <msup>
         <mrow>
          <mo stretchy="false">{</mo>
          <mn>0</mn>
          <mo>,</mo>
          <mn>1</mn>
          <mo stretchy="false">}</mo>
         </mrow>
         <mrow>
          <mi>q</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>n</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </msup>
       </mpadded>
       <mi>M</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo>,</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>3.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Pr</ci>
      <apply>
       <in></in>
       <ci>y</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <set>
         <cn type="integer">0</cn>
         <cn type="integer">1</cn>
        </set>
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <and></and>
      <apply>
       <in></in>
       <apply>
        <exists></exists>
        <ci>z</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <set>
          <cn type="integer">0</cn>
          <cn type="integer">1</cn>
         </set>
         <apply>
          <times></times>
          <ci>q</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <ci>M</ci>
        <vector>
         <ci>x</ci>
         <ci>y</ci>
         <ci>z</ci>
        </vector>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <share href="#.cmml">
       </share>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="float">3.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr\nolimits_{y\in\{0,1\}^{p(n)}}(\exists z\in\{0,1\}^{q(n)}\,M(x,y,z)=1)\leq 1%
/3.
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>As above, <em>z</em> is the alleged proof from Merlin (whose size is bounded by a polynomial) and <em>y</em> is the random string that Arthur uses, which is also polynomially bounded.</p>

<p>The complexity class <strong>AM[<em>k</em>]</strong> is the set of problems that can be decided in polynomial time, with <em>k</em> queries and responses. <strong>AM</strong> as defined above is <strong>AM[2]</strong>. <strong>AM[3]</strong> would start with one message from Merlin to Arthur, then a message from Arthur to Merlin and then finally a message from Merlin to Arthur. The last message should always be from Merlin to Arthur, since it never helps for Arthur to send a message to Merlin before deciding his answer.</p>
<h2 id="properties">Properties</h2>
<ul>
<li>Both <strong>MA</strong> and <strong>AM</strong> remain unchanged if their definitions are changed to require perfect completeness, which means that Arthur accepts with probability 1 (instead of 2/3) when <em>x</em> is in the language.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></li>
</ul>
<ul>
<li>For any fixed <em>k</em> ≥ 2, the class <strong>AM[<em>k</em>]</strong> is equal to <strong>AM[2]</strong>. If <em>k</em> can vary polynomially on input size, the class <strong>AM</strong>[poly(<em>n</em>)] is a much stronger class, <strong><a href="IP_(complexity)" title="wikilink">IP</a></strong>, which is known to be equal to <strong><a class="uri" href="PSPACE" title="wikilink">PSPACE</a></strong>.</li>
</ul>
<ul>
<li><strong>MA</strong> is contained in <strong>AM</strong>, since <strong>AM</strong>[3] = <strong>MA</strong>: Arthur can, after receiving Merlin's certificate, flip the required number of coins, send them to Merlin, and ignore the response.</li>
</ul>
<ul>
<li>It is open whether <strong>AM</strong> and <strong>MA</strong> are different. Under plausible circuit lower bounds (similar to those implying <strong>P</strong>=<strong>BPP</strong>), they are both equal to <strong>NP</strong>.</li>
</ul>
<ul>
<li><strong>AM</strong> is the same as the class <strong>BP.NP</strong> where <strong>BP</strong> denotes the bounded-error probabilistic operator. Also, <strong>

<math display="inline" id="Arthur–Merlin_protocol:7">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mo>.</mo>
   <mrow>
    <mi>B</mi>
    <mi>P</mi>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <exists></exists>
    <apply>
     <times></times>
     <ci>B</ci>
     <ci>P</ci>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists.BPP
  </annotation>
 </semantics>
</math>

</strong> ( also written as <strong>ExistsBPP</strong>) is a subset of <strong>MA</strong>. Whether <strong>MA</strong> is equal to <strong>

<math display="inline" id="Arthur–Merlin_protocol:8">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mo>.</mo>
   <mrow>
    <mi>B</mi>
    <mi>P</mi>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <exists></exists>
    <apply>
     <times></times>
     <ci>B</ci>
     <ci>P</ci>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists.BPP
  </annotation>
 </semantics>
</math>

</strong> is an open question.</li>
</ul>
<ul>
<li>The conversion to a private coin protocol, in which Merlin cannot predict the outcome of Arthur's random decisions, will increase the number of rounds of interaction by at most 2 in the general case. So the private-coin version of <strong>AM</strong> is equal to the public-coin version.</li>
</ul>
<ul>
<li><strong>MA</strong> contains both <strong><a href="NP_(complexity)" title="wikilink">NP</a></strong> and <strong><a href="BPP_(complexity)" title="wikilink">BPP</a></strong>. For BPP this is immediate, since Arthur can simply ignore Merlin and solve the problem directly; for NP, Merlin need only send Arthur a certificate, which Arthur can validate deterministically in polynomial time.</li>
</ul>
<ul>
<li>Both <strong>MA</strong> and <strong>AM</strong> are contained in the <a href="polynomial_hierarchy" title="wikilink">polynomial hierarchy</a>. In particular, <strong>MA</strong> is contained in the intersection of Σ<sub>2</sub><sup>P</sup> and Π<sub>2</sub><sup>P</sup> and <strong>AM</strong> is contained in Π<sub>2</sub><sup>P</sup>. Even more, <strong>MA</strong> is contained in subclass <strong><a href="S2P_(complexity)" title="wikilink"></a></strong>,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> a complexity class expressing "symmetric alternation". This is a generalization of <a href="Sipser–Lautemann_theorem" title="wikilink">Sipser–Lautemann theorem</a>.</li>
</ul>
<ul>
<li><strong>AM</strong> is contained in <strong>NP/poly</strong>, the class of decision problems computable in non-deterministic polynomial time with a polynomial size <a href="advice_(complexity)" title="wikilink">advice</a>. The proof is a variation of <a href="P/poly#Adleman's_theorem" title="wikilink">Adleman's theorem</a>.</li>
</ul>
<ul>
<li><strong>MA</strong> is contained in <strong><a href="PP_(complexity)" title="wikilink">PP</a></strong>; this result is due to Vereshchagin.</li>
</ul>
<ul>
<li><strong>MA</strong> is contained in its quantum version, <strong><a class="uri" href="QMA" title="wikilink">QMA</a></strong>.</li>
</ul>
<ul>
<li><strong>AM</strong> contains the <a href="graph_isomorphism_problem" title="wikilink">problem</a> of deciding if two graphs are <em>not</em> isomorphic. The protocol using private coins is the following and can be transformed to a public coin protocol. Given two graphs <em>G</em> and <em>H</em>, Arthur randomly chooses one of them, and chooses a random permutation of its vertices, presenting the permuted graph <em>I</em> to Merlin. Merlin has to answer if <em>I</em> was created from <em>G</em> or <em>H</em>. If the graphs are nonisomorphic, Merlin will be able to answer with full certainty (by checking if <em>I</em> is isomorphic to <em>G</em>). However, if the graphs are isomorphic, it is both possible that <em>G</em> or <em>H</em> was used to create <em>I</em>, and equally likely. In this case, Merlin has no way to tell them apart and can convince Arthur with probability at most 1/2, and this can be amplified to 1/4 by repetition. This is in fact a <a href="zero_knowledge_proof" title="wikilink">zero knowledge proof</a>.</li>
</ul>
<ul>
<li>If <strong>AM</strong> contains <strong>coNP</strong> then <strong><a href="Polynomial_hierarchy" title="wikilink">PH</a></strong> = <strong>AM</strong>. This is evidence that graph isomorphism is unlikely to be NP-complete, since it implies collapse of polynomial hierarchy.</li>
</ul>
<ul>
<li>It is known, assuming <a href="extended_Riemann_hypothesis" title="wikilink">ERH</a>, that for any <em>d</em> the problem</li>
</ul>
<dl>
<dd><dl>
<dd>Given a collection of multivarariate polynomials 

<math display="inline" id="Arthur–Merlin_protocol:9">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}
  </annotation>
 </semantics>
</math>

 each with integer coefficients and of degree at most <em>d</em>, do they have a common complex zero?
</dd>
</dl>
</dd>
<dd>is in <strong>AM</strong>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a>
</dd>
</dl>
<h2 id="footnotes">Footnotes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li><a href="http://theory.lcs.mit.edu/~madhu/ST05/">Madhu Sudan's MIT course on advanced complexity</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Probabilistic_complexity_theory" title="wikilink">Category:Probabilistic complexity theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a class="uri" href="https://complexityzoo.uwaterloo.ca/Complexity_Zoo:E#existsbpp">https://complexityzoo.uwaterloo.ca/Complexity_Zoo:E#existsbpp</a><a href="#fnref1">↩</a></li>
<li id="fn2">For a proof, see <a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://www.ccs.neu.edu/home/koods/papers/russell98symmetric.pdf">Symmetric Alternation captures BPP</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="Madhu_Sudan" title="wikilink">Madhu Sudan</a>, Algebra and Computation lecture notes <a href="http://people.csail.mit.edu/madhu/FT98/course.html">1</a>, lecture 22<a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
