<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1902">Homomorphic encryption</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Homomorphic encryption</h1>
<hr/>

<p><strong>Homomorphic encryption</strong> is a form of <a class="uri" href="encryption" title="wikilink">encryption</a> that allows computations to be carried out on <a class="uri" href="ciphertext" title="wikilink">ciphertext</a>, thus generating an encrypted result which, when decrypted, matches the result of operations performed on the <a class="uri" href="plaintext" title="wikilink">plaintext</a>.</p>

<p>This is sometimes a desirable feature in modern communication system architectures. Homomorphic encryption would allow the chaining together of different services without exposing the data to each of those services. For example, a chain of different services from different companies could calculate 1) the tax 2) the currency exchange rate 3) shipping, on a transaction without exposing the unencrypted data to each of those services.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <a class="uri" href="Homomorphic" title="wikilink">Homomorphic</a> encryption schemes are <a href="malleability_(cryptography)" title="wikilink">malleable</a> by design. This enables their use in cloud computing environment for ensuring the confidentiality of processed data. In addition the homomorphic property of various cryptosystems can be used to create many other secure systems, for example secure voting systems,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> collision-resistant <a href="hash_function" title="wikilink">hash functions</a>, <a href="private_information_retrieval" title="wikilink">private information retrieval</a> schemes, and many more.</p>

<p>There are several partially homomorphic cryptosystems, and also a number of fully homomorphic cryptosystems. Although a cryptosystem which is unintentionally malleable can be subject to attacks on this basis, if treated carefully homomorphism can also be used to perform computations securely.</p>
<h2 id="partially-homomorphic-cryptosystems">Partially homomorphic cryptosystems</h2>

<p>In the following examples, the notation 

<math display="inline" id="Homomorphic_encryption:0">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℰ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ℰ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}(x)
  </annotation>
 </semantics>
</math>

 is used to denote the encryption of the message <em>x</em>.</p>
<h3 id="unpadded-rsa">Unpadded RSA</h3>

<p>If the <a href="RSA_cryptosystem" title="wikilink">RSA</a> public key is modulus 

<math display="inline" id="Homomorphic_encryption:1">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 and exponent 

<math display="inline" id="Homomorphic_encryption:2">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

, then the encryption of a message 

<math display="inline" id="Homomorphic_encryption:3">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is given by 

<math display="inline" id="Homomorphic_encryption:4">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+2.8pt">
     <msup>
      <mi>x</mi>
      <mi>e</mi>
     </msup>
    </mpadded>
    <mo lspace="2.5pt" rspace="5.3pt">mod</mo>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ℰ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>e</ci>
     </apply>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}(x)=x^{e}\;\bmod\;m
  </annotation>
 </semantics>
</math>

. The homomorphic property is then</p>

<p>

<math display="block" id="Homomorphic_encryption:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi class="ltx_font_mathcaligraphic">ℰ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msubsup>
      <mi>x</mi>
      <mn>1</mn>
      <mi>e</mi>
     </msubsup>
     <mpadded width="+2.8pt">
      <msubsup>
       <mi>x</mi>
       <mn>2</mn>
       <mi>e</mi>
      </msubsup>
     </mpadded>
    </mrow>
    <mo lspace="2.5pt" rspace="5.3pt">mod</mo>
    <mi>m</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+2.8pt">
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <msub>
         <mi>x</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>e</mi>
     </msup>
    </mpadded>
    <mo lspace="2.5pt" rspace="5.3pt">mod</mo>
    <mi>m</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>⋅</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <ci>ℰ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>ℰ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>e</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>e</ci>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>e</ci>
      </apply>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>ℰ</ci>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}(x_{1})\cdot\mathcal{E}(x_{2})=x_{1}^{e}x_{2}^{e}\;\bmod\;m=(x_{1}x%
_{2})^{e}\;\bmod\;m=\mathcal{E}(x_{1}\cdot x_{2})
  </annotation>
 </semantics>
</math>

</p>
<h3 id="elgamal">ElGamal</h3>

<p>In the <a href="ElGamal_encryption" title="wikilink">ElGamal cryptosystem</a>, in a cyclic group 

<math display="inline" id="Homomorphic_encryption:6">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 of order 

<math display="inline" id="Homomorphic_encryption:7">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 with generator 

<math display="inline" id="Homomorphic_encryption:8">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

, if the public key is 

<math display="inline" id="Homomorphic_encryption:9">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>G</mi>
   <mo>,</mo>
   <mi>q</mi>
   <mo>,</mo>
   <mi>g</mi>
   <mo>,</mo>
   <mi>h</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>G</ci>
    <ci>q</ci>
    <ci>g</ci>
    <ci>h</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (G,q,g,h)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Homomorphic_encryption:10">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>=</mo>
   <msup>
    <mi>g</mi>
    <mi>x</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>h</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>g</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h=g^{x}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Homomorphic_encryption:11">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is the secret key, then the encryption of a message 

<math display="inline" id="Homomorphic_encryption:12">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Homomorphic_encryption:13">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>g</mi>
     <mi>r</mi>
    </msup>
    <mo>,</mo>
    <mrow>
     <mi>m</mi>
     <mo>⋅</mo>
     <msup>
      <mi>h</mi>
      <mi>r</mi>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ℰ</ci>
     <ci>m</ci>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <ci>r</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <ci>m</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <ci>r</ci>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}(m)=(g^{r},m\cdot h^{r})
  </annotation>
 </semantics>
</math>

, for some random 

<math display="inline" id="Homomorphic_encryption:14">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>q</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>r</ci>
    <set>
     <cn type="integer">0</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>q</ci>
      <cn type="integer">1</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\in\{0,\ldots,q-1\}
  </annotation>
 </semantics>
</math>

. The homomorphic property is then</p>

<p>

<math display="inline" id="Homomorphic_encryption:15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi class="ltx_font_mathcaligraphic">ℰ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>m</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>m</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>g</mi>
      <msub>
       <mi>r</mi>
       <mn>1</mn>
      </msub>
     </msup>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>m</mi>
       <mn>1</mn>
      </msub>
      <mo>⋅</mo>
      <msup>
       <mi>h</mi>
       <msub>
        <mi>r</mi>
        <mn>1</mn>
       </msub>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>g</mi>
      <msub>
       <mi>r</mi>
       <mn>2</mn>
      </msub>
     </msup>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>m</mi>
       <mn>2</mn>
      </msub>
      <mo>⋅</mo>
      <msup>
       <mi>h</mi>
       <msub>
        <mi>r</mi>
        <mn>2</mn>
       </msub>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <ci>ℰ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>ℰ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>h</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </interval>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>h</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\mathcal{E}(m_{1})\cdot\mathcal{E}(m_{2})=(g^{r_{1}},m_{1}\cdot h%
^{r_{1}})(g^{r_{2}},m_{2}\cdot h^{r_{2}})
  </annotation>
 </semantics>
</math>


</p>
<h3 id="goldwassermicali">Goldwasser–Micali</h3>

<p>In the <a href="Goldwasser–Micali_cryptosystem" title="wikilink">Goldwasser–Micali cryptosystem</a>, if the public key is the modulus <em>m</em> and quadratic non-residue <em>x</em>, then the encryption of a bit <em>b</em> is 

<math display="inline" id="Homomorphic_encryption:16">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>x</mi>
      <mi>b</mi>
     </msup>
     <mpadded width="+2.8pt">
      <msup>
       <mi>r</mi>
       <mn>2</mn>
      </msup>
     </mpadded>
    </mrow>
    <mo lspace="2.5pt" rspace="5.3pt">mod</mo>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ℰ</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>b</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>r</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}(b)=x^{b}r^{2}\;\bmod\;m
  </annotation>
 </semantics>
</math>

, for some random 

<math display="inline" id="Homomorphic_encryption:17">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>m</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>r</ci>
    <set>
     <cn type="integer">0</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>m</ci>
      <cn type="integer">1</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\in\{0,\ldots,m-1\}
  </annotation>
 </semantics>
</math>

. The homomorphic property is then</p>

<p>

<math display="block" id="Homomorphic_encryption:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi class="ltx_font_mathcaligraphic">ℰ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>b</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>b</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
    </msup>
    <msubsup>
     <mi>r</mi>
     <mn>1</mn>
     <mn>2</mn>
    </msubsup>
    <msup>
     <mi>x</mi>
     <msub>
      <mi>b</mi>
      <mn>2</mn>
     </msub>
    </msup>
    <msubsup>
     <mi>r</mi>
     <mn>2</mn>
     <mn>2</mn>
    </msubsup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mrow>
      <msub>
       <mi>b</mi>
       <mn>1</mn>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>b</mi>
       <mn>2</mn>
      </msub>
     </mrow>
    </msup>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>r</mi>
        <mn>1</mn>
       </msub>
       <msub>
        <mi>r</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>b</mi>
       <mn>1</mn>
      </msub>
      <mo>⊕</mo>
      <msub>
       <mi>b</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <ci>ℰ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>ℰ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>ℰ</ci>
      <apply>
       <csymbol cd="latexml">direct-sum</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}(b_{1})\cdot\mathcal{E}(b_{2})=x^{b_{1}}r_{1}^{2}x^{b_{2}}r_{2}^{2}%
=x^{b_{1}+b_{2}}(r_{1}r_{2})^{2}=\mathcal{E}(b_{1}\oplus b_{2})
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Homomorphic_encryption:19">
 <semantics>
  <mo>⊕</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">direct-sum</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \oplus
  </annotation>
 </semantics>
</math>


 denotes addition modulo 2, (i.e. <a href="Exclusive_disjunction" title="wikilink">exclusive-or</a>).</p>
<h3 id="benaloh">Benaloh</h3>

<p>In the <a href="Benaloh_cryptosystem" title="wikilink">Benaloh cryptosystem</a>, if the public key is the modulus <em>m</em> and the base <em>g</em> with a blocksize of <em>c</em>, then the encryption of a message <em>x</em> is 

<math display="inline" id="Homomorphic_encryption:20">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>g</mi>
      <mi>x</mi>
     </msup>
     <mpadded width="+2.8pt">
      <msup>
       <mi>r</mi>
       <mi>c</mi>
      </msup>
     </mpadded>
    </mrow>
    <mo lspace="2.5pt" rspace="5.3pt">mod</mo>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ℰ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>r</ci>
       <ci>c</ci>
      </apply>
     </apply>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}(x)=g^{x}r^{c}\;\bmod\;m
  </annotation>
 </semantics>
</math>

, for some random 

<math display="inline" id="Homomorphic_encryption:21">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>m</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>r</ci>
    <set>
     <cn type="integer">0</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>m</ci>
      <cn type="integer">1</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\in\{0,\ldots,m-1\}
  </annotation>
 </semantics>
</math>

. The homomorphic property is then</p>

<p>

<math display="block" id="Homomorphic_encryption:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi class="ltx_font_mathcaligraphic">ℰ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>g</mi>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
      </msup>
      <msubsup>
       <mi>r</mi>
       <mn>1</mn>
       <mi>c</mi>
      </msubsup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>g</mi>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
      </msup>
      <msubsup>
       <mi>r</mi>
       <mn>2</mn>
       <mi>c</mi>
      </msubsup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>g</mi>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
     </mrow>
    </msup>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>r</mi>
        <mn>1</mn>
       </msub>
       <msub>
        <mi>r</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>c</mi>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>+</mo>
       <mpadded width="+2.8pt">
        <msub>
         <mi>x</mi>
         <mn>2</mn>
        </msub>
       </mpadded>
      </mrow>
      <mo lspace="2.5pt" rspace="5.3pt">mod</mo>
      <mi>c</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <ci>ℰ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>ℰ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>g</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>c</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>g</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>c</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>ℰ</ci>
      <apply>
       <csymbol cd="latexml">modulo</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}(x_{1})\cdot\mathcal{E}(x_{2})=(g^{x_{1}}r_{1}^{c})(g^{x_{2}}r_{2}^%
{c})=g^{x_{1}+x_{2}}(r_{1}r_{2})^{c}=\mathcal{E}(x_{1}+x_{2}\;\bmod\;c)
  </annotation>
 </semantics>
</math>

</p>
<h3 id="paillier">Paillier</h3>

<p>In the <a href="Paillier_cryptosystem" title="wikilink">Paillier cryptosystem</a>, if the public key is the modulus <em>m</em> and the base <em>g</em>, then the encryption of a message <em>x</em> is 

<math display="inline" id="Homomorphic_encryption:23">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>g</mi>
      <mi>x</mi>
     </msup>
     <mpadded width="+2.8pt">
      <msup>
       <mi>r</mi>
       <mi>m</mi>
      </msup>
     </mpadded>
    </mrow>
    <mo lspace="2.5pt" rspace="5.3pt">mod</mo>
    <msup>
     <mi>m</mi>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ℰ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>r</ci>
       <ci>m</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}(x)=g^{x}r^{m}\;\bmod\;m^{2}
  </annotation>
 </semantics>
</math>

, for some random 

<math display="inline" id="Homomorphic_encryption:24">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>m</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>r</ci>
    <set>
     <cn type="integer">0</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>m</ci>
      <cn type="integer">1</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\in\{0,\ldots,m-1\}
  </annotation>
 </semantics>
</math>


. The homomorphic property is then</p>

<p>

<math display="block" id="Homomorphic_encryption:25">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi class="ltx_font_mathcaligraphic">ℰ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>g</mi>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
      </msup>
      <msubsup>
       <mi>r</mi>
       <mn>1</mn>
       <mi>m</mi>
      </msubsup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>g</mi>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
      </msup>
      <msubsup>
       <mi>r</mi>
       <mn>2</mn>
       <mi>m</mi>
      </msubsup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>g</mi>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
     </mrow>
    </msup>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>r</mi>
        <mn>1</mn>
       </msub>
       <msub>
        <mi>r</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>m</mi>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>+</mo>
       <mpadded width="+2.8pt">
        <msub>
         <mi>x</mi>
         <mn>2</mn>
        </msub>
       </mpadded>
      </mrow>
      <mo lspace="2.5pt" rspace="5.3pt">mod</mo>
      <msup>
       <mi>m</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <ci>ℰ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>ℰ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>g</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>m</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>g</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>ℰ</ci>
      <apply>
       <csymbol cd="latexml">modulo</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>m</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}(x_{1})\cdot\mathcal{E}(x_{2})=(g^{x_{1}}r_{1}^{m})(g^{x_{2}}r_{2}^%
{m})=g^{x_{1}+x_{2}}(r_{1}r_{2})^{m}=\mathcal{E}(x_{1}+x_{2}\;\bmod\;m^{2})
  </annotation>
 </semantics>
</math>

</p>
<h3 id="other-partially-homomorphic-cryptosystems">Other partially homomorphic cryptosystems</h3>
<ul>
<li><a href="Okamoto–Uchiyama_cryptosystem" title="wikilink">Okamoto–Uchiyama cryptosystem</a></li>
<li><a href="Naccache–Stern_cryptosystem" title="wikilink">Naccache–Stern cryptosystem</a></li>
<li><a href="Damgård–Jurik_cryptosystem" title="wikilink">Damgård–Jurik cryptosystem</a></li>
<li><a href="Boneh–Goh–Nissim_cryptosystem" title="wikilink">Boneh–Goh–Nissim cryptosystem</a></li>
<li><a href="Ishai-Paskin_cryptosystem" title="wikilink">Ishai-Paskin cryptosystem</a></li>
</ul>
<h2 id="fully-homomorphic-encryption">Fully homomorphic encryption</h2>

<p>The examples listed above allow homomorphic computation of some operations on ciphertexts (e.g., additions, multiplications, quadratic functions, etc.). A cryptosystem that supports  on ciphertexts is known as fully homomorphic encryption (FHE) and is far more powerful. Such a scheme enables the construction of programs for any desirable functionality, which can be run on encrypted inputs to produce an encryption of the result. Since such a program need never decrypts its inputs, it can be run by an untrusted party without revealing its inputs and internal state. The existence of an efficient and fully homomorphic cryptosystem would have great practical implications in the outsourcing of private computations, for instance, in the context of <a href="cloud_computing" title="wikilink">cloud computing</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>The utility of fully homomorphic encryption has been long recognized. The problem of constructing such a scheme was first proposed within a year of the development of RSA.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> A solution proved more elusive; for more than 30 years, it was unclear whether fully homomorphic encryption was even possible. During that period, partial results included the Boneh–Goh–Nissim cryptosystem that supports evaluation of an unlimited number of addition operations but at most one multiplication,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> and the Ishai-Paskin cryptosystem that supports evaluation of (polynomial-size) <a href="Branching_program" title="wikilink">Branching program</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h3 id="early-homomorphic-cryptosystems">Early homomorphic cryptosystems</h3>
<h4 id="gentrys-cryptosystem">Gentry's cryptosystem</h4>

<p> <a href="Craig_Gentry_(computer_scientist)" title="wikilink">Craig Gentry</a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> using <a href="lattice-based_cryptography" title="wikilink">lattice-based cryptography</a>, described the first plausible construction for a fully homomorphic encryption scheme. Gentry's scheme supports both addition and multiplication operations on ciphertexts, from which it is possible to construct circuits for performing arbitrary computation.</p>

<p>The construction starts from a <em>somewhat homomorphic</em> encryption scheme, which is limited to evaluating low-degree polynomials over encrypted data. (It is limited because each ciphertext is noisy in some sense, and this noise grows as one adds and multiplies ciphertexts, until ultimately the noise makes the resulting ciphertext indecipherable.) Gentry then shows how to slightly modify this scheme to make it <em>bootstrappable,</em> i.e., capable of evaluating its own decryption circuit and then at least one more operation. Finally, he shows that any bootstrappable somewhat homomorphic encryption scheme can be converted into a fully homomorphic encryption through a recursive self-embedding. For Gentry's "noisy" scheme, the bootstrapping procedure effectively "refreshes" the ciphertext by applying to it the decryption procedure homomorphically, thereby obtaining a new ciphertext that encrypts the same value as before but has lower noise. By "refreshing" the ciphertext periodically whenever the noise grows too large, it is possible to compute arbitrary number of additions and multiplications without increasing the noise too much. Gentry based the security of his scheme on the assumed hardness of two problems: certain worst-case problems over <a href="Ideal_lattice_cryptography" title="wikilink">ideal lattices</a>, and the sparse (or low-weight) subset sum problem. Gentry's Ph.D. thesis<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> provides additional details.</p>

<p>Regarding performance, ciphertexts in Gentry's scheme remain compact insofar as their lengths do not depend at all on the complexity of the function that is evaluated over the encrypted data, but the scheme is impractical, and its ciphertext size and computation time increase sharply as one increases the security level. Several optimizations and refinements were proposed by <a href="Damien_Stehle" title="wikilink">Damien Stehle</a> and <a href="Ron_Steinfeld" title="wikilink">Ron Steinfeld</a>,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> <a href="Nigel_Smart_(cryptographer)" title="wikilink">Nigel Smart</a> and <a href="Frederik_Vercauteren" title="wikilink">Frederik Vercauteren</a>,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> and <a href="Craig_Gentry_(computer_scientist)" title="wikilink">Craig Gentry</a> and <a href="Shai_Halevi" title="wikilink">Shai Halevi</a>,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> the latter obtaining the first working implementation of Gentry's fully homomorphic encryption.</p>
<h4 id="cryptosystem-over-the-integers">Cryptosystem over the integers</h4>

<p>In 2010, <a href="Marten_van_Dijk" title="wikilink">Marten van Dijk</a>, <a href="Craig_Gentry_(computer_scientist)" title="wikilink">Craig Gentry</a>, <a href="Shai_Halevi" title="wikilink">Shai Halevi</a> and <a href="Vinod_Vaikuntanathan" title="wikilink">Vinod Vaikuntanathan</a> presented a second fully homomorphic encryption scheme,<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> which uses many of the tools of Gentry's construction, but which does not require <a href="Ideal_lattice_cryptography" title="wikilink">ideal lattices</a>. Instead, they show that the somewhat homomorphic component of Gentry's <a href="Ideal_lattice_cryptography" title="wikilink">ideal lattice</a>-based scheme can be replaced with a very simple somewhat homomorphic scheme that uses integers. The scheme is therefore conceptually simpler than Gentry's ideal lattice scheme, but has similar properties with regards to homomorphic operations and efficiency. The somewhat homomorphic component in the work of van Dijk et al. is similar to an encryption scheme proposed by Levieil and Naccache in 2008,<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> and also to one that was proposed by <a href="Bram_Cohen" title="wikilink">Bram Cohen</a> in 1998.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> Cohen's method is not even additively homomorphic, however. The Levieil–Naccache scheme supports only additions, but it can be modified to also support a small number of multiplications. Many refinements and optimizations of the scheme of van Dijk et al. were proposed in a sequence of works by <a href="Jean-Sébastien_Coron" title="wikilink">Jean-Sébastien Coron</a>, <a href="Tancrède_Lepoint" title="wikilink">Tancrède Lepoint</a>, <a href="Avradip_Mandal" title="wikilink">Avradip Mandal</a>, <a href="David_Naccache" title="wikilink">David Naccache</a>, and <a href="Mehdi_Tibouchi" title="wikilink">Mehdi Tibouchi</a>.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> Some of these works included also implementations the resulting schemes.</p>
<h3 id="the-2nd-generation-of-homomorphic-cryptosystems">The 2nd generation of homomorphic cryptosystems</h3>

<p>Several new techniques that were developed starting in 2011-2012 by <a href="Zvika_Brakerski" title="wikilink">Zvika Brakerski</a>, <a href="Craig_Gentry_(computer_scientist)" title="wikilink">Craig Gentry</a>, <a href="Vinod_Vaikuntanathan" title="wikilink">Vinod Vaikuntanathan</a>, and others, led to the development of much more efficient somewhat and fully homomorphic cryptosystems. These include:</p>
<ul>
<li>The Brakerski-Gentry-Vaikuntanathan cryptosystem (BGV),<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> building on techniques of Brakerski-Vaikuntanathan.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></li>
<li>Brakerski's  cryptosystem.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></li>
<li>The <a class="uri" href="NTRU" title="wikilink">NTRU</a>-based cryptosystem due to Lopez-Alt, Tromer, and Vaikuntanathan (LTV).<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></li>
<li>The Gentry-Sahai-Waters cryptosystem (GSW).<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></li>
</ul>

<p>The security of most of these schemes is based on the hardness of the <a href="Learning_with_errors" title="wikilink">Learning with errors</a> problem, except for the LTV scheme whose security is based on a variant of the <a class="uri" href="NTRU" title="wikilink">NTRU</a> computational problem. The distinguishing characteristic of these cryptosystem is that they all feature much slower growth of the noise during the homomorphic computations. Additional optimizations by <a href="Craig_Gentry_(computer_scientist)" title="wikilink">Craig Gentry</a>, <a href="Shai_Halevi" title="wikilink">Shai Halevi</a>, and <a href="Nigel_Smart_(cryptographer)" title="wikilink">Nigel Smart</a> resulted in cryptosystems with nearly optimal asymptotic complexity: Performing 

<math display="inline" id="Homomorphic_encryption:26">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 operations on data encrypted with security parameter 

<math display="inline" id="Homomorphic_encryption:27">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 has complexity of only 

<math display="inline" id="Homomorphic_encryption:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mo>⋅</mo>
    <mi>p</mi>
   </mrow>
   <mi>o</mi>
   <mi>l</mi>
   <mi>y</mi>
   <mi>l</mi>
   <mi>o</mi>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-⋅</ci>
     <ci>T</ci>
     <ci>p</ci>
    </apply>
    <ci>o</ci>
    <ci>l</ci>
    <ci>y</ci>
    <ci>l</ci>
    <ci>o</ci>
    <ci>g</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\cdot polylog(k)
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a><a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a><a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> These optimizations build on the Smart-Vercauteren techniques that enables packing of many plaintext values in a single ciphertext and operating on all these plaintext values in a <a class="uri" href="SIMD" title="wikilink">SIMD</a> fashion.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> Many of the advances in these second-generation cryptosystems were also ported to the cryptosystem over the integers.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a><a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>

<p><a href="Zvika_Brakerski" title="wikilink">Zvika Brakerski</a> and <a href="Vinod_Vaikuntanathan" title="wikilink">Vinod Vaikuntanathan</a> observed that for certain types of circuits, the GSW cryptosystem features an even slower growth rate of noise, and hence better efficiency and stronger security.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> <a href="Jacob_Alperin-Sheriff" title="wikilink">Jacob Alperin-Sheriff</a> and <a href="Chris_Peikert" title="wikilink">Chris Peikert</a> then described a very efficient bootstrapping technique that uses exactly this type of circuits<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> This type of circuits, however, seems incompatible with the ciphertext-packing techniques, and hence the Gentry-Halevi-Smart optimizations<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> cannot be applied here.</p>

<p>All the second-generation cryptosystems still follow the basic blueprint of Gentry's original construction, namely they first construct a somewhat-homomorphic cryptosystem that handles noisy ciphertexts, and then convert it to a fully homomorphic cryptosystem using bootstrapping.</p>
<h3 id="implementations">Implementations</h3>

<p>The first reported implementation of fully homomorphic encryption is the Gentry-Halevi implementation mentioned above of Gentry's original cryptosystem,<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> they reported timing of about 30 minutes per basic bit operation. The second-generation schemes made this implementation obsolete, however.</p>

<p>Many implementations of second-generation somewhat-homomorphic cryptosystems were reported in the literature. An early implementation from 2012 due to Gentry, Halevi, and Smart (GHS)<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> of a variant of the BGV cryptosystem,<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> reported evaluation of a complex circuit (implementing the encryption procedure of the <a href="Advanced_Encryption_Standard" title="wikilink">AES cipher</a>) in 36 hours. Using the packed-ciphertext techniques, that implementation could evaluate the same circuit on 54 different inputs in the same 36 hours, yielding amortized time of roughly 40 minutes per input. This AES-encryption circuit was adopted as a benchmark in several follow-up works,<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a><a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a><a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> gradually bringing the evaluation time down to about four hours and the per-input amortized time to just over 7 seconds.</p>

<p>Two implementations of second-generation homomorphic cryptosystems are available in open source libraries: The HElib library<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> due to <a href="Shai_Halevi" title="wikilink">Shai Halevi</a> and <a href="Victor_Shoup" title="wikilink">Victor Shoup</a> that implements the BGV cryptosystem with the GHS optimizations, and the FHEW library<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> due to <a href="Leo_Ducas" title="wikilink">Leo Ducas</a> and <a href="Daniele_Micciancio" title="wikilink">Daniele Micciancio</a> that implements a combination of <a href="Learning_with_errors#Public-key_cryptosystem" title="wikilink">Regev's LWE cryptosystem</a> with the bootstrapping techniques of Alperin-Sheriff and Peikert.<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> Both libraries implement fully homomorphic encryption including bootstrapping. HElib reports time of 5–10 minutes for bootstrapping a packed ciphertext with about 1000 plaintext values,<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a> and FHEW reports time of around 1/2 second for bootstrapping a non-packed ciphertext encrypting a single bit.<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a> In late-2014, a re-implementation of homomorphic evaluation of the AES-encryption circuit using HElib, reported evaluation time of just over four minutes on 120 inputs, bringing the amortized per-input time to about 2 seconds<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a></p>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://windowsontheory.org/2012/05/01/the-swiss-army-knife-of-cryptography/">The Swiss Army Knife of Cryptography</a></li>
<li><a href="http://www.cs.ut.ee/~lipmaa/crypto/link/public/homomorphic.php">Homomorphic encryption</a> in <a href="http://research.cyber.ee/~lipmaa/crypto/">Cryptology Pointers</a></li>
<li><a href="http://www.americanscientist.org/issues/pub/2012/5/alice-and-bob-in-cipherspace">American Scientist article</a>, September 2012</li>
<li><a href="http://code.google.com/p/thep/">The Homomorphic Encryption Project</a></li>
<li><a href="http://www.hcrypt.com/">The Open Source hcrypt Project</a></li>
<li><a href="https://github.com/shaih/HElib">HElib</a>, open source homomorphic encryption library for C++</li>
<li><a href="https://github.com/lducas/FHEW">FHEW</a>, open source homomorphic encryption library for C and C++</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Homomorphic_signatures_for_network_coding" title="wikilink">Homomorphic signatures for network coding</a></li>
<li><a href="Verifiable_computing" title="wikilink">Verifiable computing using a fully homomorphic scheme</a></li>
<li><a href="Client-side_encryption" title="wikilink">Client-side encryption</a></li>
<li><a href="Secure_multi-party_computation" title="wikilink">Secure multi-party computation</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Cryptographic_primitives" title="wikilink">Category:Cryptographic primitives</a> <a href="Category:Public-key_cryptography" title="wikilink">Category:Public-key cryptography</a> <a class="uri" href="Category:Homeomorphisms" title="wikilink">Category:Homeomorphisms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">R. L. Rivest, L. Adleman, and M. L. Dertouzos. On data banks and privacy homomorphisms. In <em>Foundations of Secure Computation</em>, 1978.<a href="#fnref4">↩</a></li>
<li id="fn5">D. Boneh, E. Goh, and K. Nissim. Evaluating 2-DNF Formulas on Ciphertexts. In <em>Theory of Cryptography Conference</em>, 2005.<a href="#fnref5">↩</a></li>
<li id="fn6">Y. Ishai and A. Paskin. Evaluating branching programs on encrypted data. In <em>Theory of Cryptography Conference</em>, 2007.<a href="#fnref6">↩</a></li>
<li id="fn7">Craig Gentry. <a href="http://portal.acm.org/citation.cfm?id=1536414.1536440">Fully Homomorphic Encryption Using Ideal Lattices</a>. In <em>the 41st ACM Symposium on Theory of Computing (STOC)</em>, 2009.<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21">Z. Brakerski, C. Gentry, and V. Vaikuntanathan. <a href="http://eprint.iacr.org/2011/277">Fully Homomorphic Encryption without Bootstrapping</a>. In <em>ITCS 2012</em><a href="#fnref21">↩</a></li>
<li id="fn22">Z. Brakerski and V. Vaikuntanathan. <a href="http://eprint.iacr.org/2011/344">Efficient Fully Homomorphic Encryption from (Standard) LWE</a>. In <em>FOCS 2011</em> (IEEE)<a href="#fnref22">↩</a></li>
<li id="fn23">Z. Brakerski. <a href="http://eprint.iacr.org/2012/078">Fully Homomorphic Encryption without Modulus Switching from Classical GapSVP</a>. In <em>CRYPTO 2012</em> (Springer)<a href="#fnref23">↩</a></li>
<li id="fn24">A. Lopez-Alt, E. Tromer, and V. Vaikuntanathan. <a href="https://eprint.iacr.org/2013/094">On-the-Fly Multiparty Computation on the Cloud via Multikey Fully Homomorphic Encryption</a>. In <em>STOC 2012</em> (ACM)<a href="#fnref24">↩</a></li>
<li id="fn25">C. Gentry, A. Sahai, and B. Waters. <a href="http://eprint.iacr.org/2013/340">Homomorphic Encryption from Learning with Errors: Conceptually-Simpler, Asymptotically-Faster, Attribute-Based</a>. In <em>CRYPTO 2013</em> (Springer)<a href="#fnref25">↩</a></li>
<li id="fn26">C. Gentry, S. Halevi, and N. P. Smart. <a href="http://eprint.iacr.org/2011/566">Fully Homomorphic Encryption with Polylog Overhead</a>. In <em>EUROCRYPT 2012</em> (Springer)<a href="#fnref26">↩</a></li>
<li id="fn27">C. Gentry, S. Halevi, and N. P. Smart. <a href="http://eprint.iacr.org/2011/680">Better Bootstrapping in Fully Homomorphic Encryption</a>. In <em>PKC 2012</em> (SpringeR)<a href="#fnref27">↩</a></li>
<li id="fn28">C. Gentry, S. Halevi, and N. P. Smart. <a href="http://eprint.iacr.org/2012/099">Homomorphic Evaluation of the AES Circuit</a>. In <em>CRYPTO 2012</em> (Springer)<a href="#fnref28">↩</a></li>
<li id="fn29"></li>
<li id="fn30"></li>
<li id="fn31"></li>
<li id="fn32">Z. Brakerski and V. Vaikuntanathan. <a href="http://eprint.iacr.org/2013/541">Lattice-Based FHE as Secure as PKE</a>. In <em>ITCS 2014</em><a href="#fnref32">↩</a></li>
<li id="fn33">J. Alperin-Sheriff and C. Peikert. <a href="http://eprint.iacr.org/2014/094">Faster Bootstrapping with Polynomial Error</a>. In <em>CRYPTO 2014</em> (Springer)<a href="#fnref33">↩</a></li>
<li id="fn34"></li>
<li id="fn35"></li>
<li id="fn36"></li>
<li id="fn37"></li>
<li id="fn38"></li>
<li id="fn39">Y. Doroz, Y. Hu, and B. Sunar. <a href="http://eprint.iacr.org/2014/039">Homomorphic AES Evaluation using NTRU</a>. In <em>Financial Cryptography 2014</em><a href="#fnref39">↩</a></li>
<li id="fn40"><a href="#fnref40">↩</a></li>
<li id="fn41"><a href="#fnref41">↩</a></li>
<li id="fn42"><a href="#fnref42">↩</a></li>
<li id="fn43"></li>
<li id="fn44"><a href="#fnref44">↩</a></li>
<li id="fn45"><a href="#fnref45">↩</a></li>
<li id="fn46"></li>
</ol>
</section>
</body>
</html>
