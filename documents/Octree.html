<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="234">Octree</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Octree</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Left: Recursive subdivision of a cube into <a href="octant_(solid_geometry)" title="wikilink">octants</a>. Right: The corresponding octree.</figcaption>
</figure>

<p>An <strong>octree</strong> is a <a href="tree_data_structure" title="wikilink">tree data structure</a> in which each <a href="internal_node" title="wikilink">internal node</a> has exactly eight <a href="child_node" title="wikilink">children</a>. Octrees are most often used to partition a three dimensional space by recursively subdividing it into eight octants. Octrees are the three-dimensional analog of <a href="quadtree" title="wikilink">quadtrees</a>. The name is formed from <em>oct</em> + <em>tree</em>, but note that it is normally written "<em>octree</em>" with only one "t". Octrees are often used in <a href="3D_graphics" title="wikilink">3D graphics</a> and 3D <a href="game_engine" title="wikilink">game engines</a>.</p>
<h2 id="for-spatial-representation">For spatial representation</h2>

<p>Each node in an octree subdivides the space it represents into eight <a href="octant_(solid_geometry)" title="wikilink">octants</a>. In a point region (PR) octree, the node stores an explicit 3-dimensional point, which is the "center" of the subdivision for that node; the point defines one of the corners for each of the eight children. In a matrix based (MX) octree, the subdivision point is implicitly the center of the space the node represents. The root node of a PR octree can represent infinite space; the root node of an MX octree must represent a finite bounded space so that the implicit centers are well-defined. Note that Octrees are not the same as <a href="k-d_tree" title="wikilink"><em>k</em>-d trees</a>: <em>k</em>-d trees split along a dimension and octrees split around a point. Also <em>k</em>-d trees are always binary, which is not the case for octrees. By using a <a href="depth-first_search" title="wikilink">depth-first search</a> the nodes are to be traversed and only required surfaces are to be viewed.</p>
<h2 id="history">History</h2>

<p>The use of octrees for <a href="3D_computer_graphics" title="wikilink">3D computer graphics</a> was pioneered by Donald Meagher at <a href="Rensselaer_Polytechnic_Institute" title="wikilink">Rensselaer Polytechnic Institute</a>, described in a 1980 report "Octree Encoding: A New Technique for the Representation, Manipulation and Display of Arbitrary 3-D Objects by Computer",<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> for which he holds a 1995 patent (with a 1984 <a href="priority_right" title="wikilink">priority date</a>) "High-speed image generation of complex solid objects using octree encoding" <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="common-uses">Common uses</h2>
<ul>
<li><a href="3D_computer_graphics" title="wikilink">3D computer graphics</a></li>
<li><a href="Spatial_index" title="wikilink">Spatial indexing</a></li>
<li><a href="Nearest_neighbor_search" title="wikilink">Nearest neighbor search</a></li>
<li>Efficient <a href="collision_detection" title="wikilink">collision detection</a> in three dimensions</li>
<li><a href="View_frustum_culling" title="wikilink">View frustum culling</a></li>
<li><a href="Fast_Multipole_Method" title="wikilink">Fast Multipole Method</a></li>
<li><a href="Unstructured_grid" title="wikilink">Unstructured grid</a></li>
<li><a href="Finite_element_analysis" title="wikilink">Finite element analysis</a></li>
<li><a href="Sparse_voxel_octree" title="wikilink">Sparse voxel octree</a></li>
<li><a href="State_estimation" title="wikilink">State estimation</a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
<li><a href="Set_estimation" title="wikilink">Set estimation</a><ref></ref></li>
</ul>

<p><a href="http://www.ensta-bretagne.fr/jaulin/paper_drevelle_nolcos_2013.pdf">V. Drevelle, L. Jaulin and B. Zerr, <em>Guaranteed Characterization of the Explored Space of a Mobile Robot by using Subpavings</em>, NOLCOS 2013.</a></p>
<h2 id="application-to-color-quantization">Application to color quantization</h2>

<p>The octree <a href="color_quantization" title="wikilink">color quantization</a> algorithm, invented by Gervautz and Purgathofer in 1988, encodes image color data as an octree up to nine levels deep. Octrees are used because 

<math display="inline" id="Octree:0">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mn>3</mn>
   </msup>
   <mo>=</mo>
   <mn>8</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
    </apply>
    <cn type="integer">8</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{3}=8
  </annotation>
 </semantics>
</math>

 and there are three color components in the <a class="uri" href="RGB" title="wikilink">RGB</a> system. The node index to branch out from at the top level is determined by a formula that uses the most significant bits of the red, green, and blue color components, e.g. 4r + 2g + b. The next lower level uses the next bit significance, and so on. Less significant bits are sometimes ignored to reduce the tree size.</p>

<p>The algorithm is highly memory efficient because the tree's size can be limited. The bottom level of the octree consists of leaf nodes that accrue color data not represented in the tree; these nodes initially contain single bits. If much more than the desired number of palette colors are entered into the octree, its size can be continually reduced by seeking out a bottom-level node and averaging its bit data up into a leaf node, pruning part of the tree. Once sampling is complete, exploring all routes in the tree down to the leaf nodes, taking note of the bits along the way, will yield approximately the required number of colors.</p>
<h2 id="implementation-for-point-decomposition">Implementation for point decomposition</h2>

<p>The example recursive algorithm outline below (MATLAB syntax) decomposes an array of 3-dimensional points into octree style bins. The implementation begins with a single bin surrounding all given points, which then recursively subdivides into its 8 octree regions. Recursion is stopped when a given exit condition is met. Examples of such exit conditions (shown in code below) are:</p>
<ul>
<li>When a bin contains fewer than a given number of points</li>
<li>When a bin reaches a minimum size or volume based on the length of its edges</li>
<li>When recursion has reached a maximum number of subdivisions</li>
</ul>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">function [binDepths,binParents,binCorners,pointBins] = OcTree(points)
 
binDepths = [<span class="fl">0</span>]     <span class="co">% Initialize an array of bin depths with this single base-level bin</span>
binParents = [<span class="fl">0</span>]    <span class="co">% This base level bin is not a child of other bins</span>
binCorners = [min(points) max(points)] <span class="co">% It surrounds all points in XYZ space</span>
pointBins(:) = <span class="fl">1</span>    <span class="co">% Initially, all points are assigned to this first bin</span>
divide(<span class="fl">1</span>)           <span class="co">% Begin dividing this first bin</span>
 
function divide(binNo)
    
<span class="co">% If this bin meets any exit conditions, do not divide it any further.</span>
binPointCount = nnz(pointBins==binNo)
binEdgeLengths = binCorners(binNo,<span class="fl">1</span>:<span class="fl">3</span>) - binCorners(binNo,<span class="fl">4</span>:<span class="fl">6</span>)
binDepth = binDepths(binNo)
exitConditionsMet = binPointCount<value bindepth="" min(binedgelengths)<value="" ||="">value
if exitConditionsMet
    return; <span class="co">% Exit recursive function</span>
end
 
<span class="co">% Otherwise, split this bin into 8 new sub-bins with a new division point</span>
newDiv = (binCorners(binNo,<span class="fl">1</span>:<span class="fl">3</span>) + binCorners(binNo,<span class="fl">4</span>:<span class="fl">6</span>)) / <span class="fl">2</span>
for i = <span class="fl">1</span>:<span class="fl">8</span>
    newBinNo = length(binDepths) + <span class="fl">1</span>
    binDepths(newBinNo) = binDepths(binNo) + <span class="fl">1</span>
    binParents(newBinNo) = binNo
    binCorners(newBinNo) = [one of the <span class="fl">8</span> pairs of the newDiv with minCorner or maxCorner]
    oldBinMask = pointBins==binNo
    <span class="co">% Calculate which points in pointBins==binNo now belong in newBinNo </span>
    pointBins(newBinMask) = newBinNo
    <span class="co">% Recursively divide this newly created bin</span>
    divide(newBinNo)
end
</value></code></pre></div>
<h2 id="example-color-quantization">Example color quantization</h2>

<p>Taking the full list of colors of a 24-bit RGB image as point input to the Octree point decomposition implementation outlined above, the following example show the results of octree color quantization. The first image is the original (532818 distinct colors), while the second is the quantized image (184 distinct colors) using octree decomposition, with each pixel assigned the color at the center of the octree bin in which it falls. Alternatively, final colors could be chosen at the centroid of all colors in each octree bin, however this added computation has very little effect on the visual result.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span class="co">% Read the original RGB image</span>
Img = imread(<span class="st">'IMG_9980.CR2'</span>);
<span class="co">% Extract pixels as RGB point triplets</span>
pts = reshape(Img,[],<span class="fl">3</span>);
<span class="co">% Create OcTree decomposition object using a target bin capacity</span>
OT = OcTree(pts,<span class="st">'BinCapacity'</span>,ceil((size(pts,<span class="fl">1</span>) / <span class="fl">256</span>) *<span class="fl">7</span>));
<span class="co">% Find which bins are "leaf nodes" on the octree object</span>
leafs = find(~ismember(<span class="fl">1</span>:OT.BinCount, OT.BinParents) &amp; ...
    ismember(<span class="fl">1</span>:OT.BinCount,OT.PointBins));
<span class="co">% Find the central RGB location of each leaf bin</span>
binCents = mean(reshape(OT.BinBoundaries(leafs,:),[],<span class="fl">3</span>,<span class="fl">2</span>),<span class="fl">3</span>);
 
<span class="co">% Make a new "indexed" image with a color map</span>
ImgIdx = zeros(size(Img,<span class="fl">1</span>), size(Img,<span class="fl">2</span>));
for i = <span class="fl">1</span>:length(leafs)
    pxNos = find(OT.PointBins==leafs(i));
    ImgIdx(pxNos) = i;
end
ImgMap = binCents / <span class="fl">255</span>; <span class="co">% Convert 8-bit color to MATLAB rgb values</span>
 
<span class="co">% Display the original 532818-color image and resulting 184-color image </span>
figure
subplot(<span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">1</span>), imshow(Img)
title(sprintf(<span class="st">'Original %d color image'</span>, size(unique(pts,<span class="st">'rows'</span>),<span class="fl">1</span>)))
subplot(<span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">2</span>), imshow(ImgIdx, ImgMap)
title(sprintf(<span class="st">'Octree-quantized %d color image'</span>, size(ImgMap,<span class="fl">1</span>)))</code></pre></div>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Binary_space_partitioning" title="wikilink">Binary space partitioning</a></li>
<li><a href="Bounding_interval_hierarchy" title="wikilink">Bounding interval hierarchy</a></li>
<li><em><a href="Cube_2:_Sauerbraten" title="wikilink">Cube 2: Sauerbraten</a></em>, a 3D game engine in which geometry is almost entirely based on octrees</li>
<li><a href="id_Tech_6" title="wikilink">id Tech 6</a> an in-development 3D game engine that utilizes voxels stored in octrees</li>
<li><a href="Irrlicht_Engine" title="wikilink">Irrlicht Engine</a>, supports octree scene nodes</li>
<li><a href="Klee's_measure_problem" title="wikilink">Klee's measure problem</a></li>
<li><a href="Linear_octree" title="wikilink">Linear octree</a></li>
<li><a class="uri" href="OGRE" title="wikilink">OGRE</a>, has an Octree Scene Manager Implementation</li>
<li><a class="uri" href="Subpaving" title="wikilink">Subpaving</a></li>
<li><a class="uri" href="Voxel" title="wikilink">Voxel</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.microsoft.com/msj/archive/S3F1.aspx">Octree Quantization in Microsoft Systems Journal</a></li>
<li><a href="http://www.ddj.com/184409805">Color Quantization using Octrees in Dr. Dobb's</a></li>
<li><a href="ftp://ftp.drdobbs.com/sourcecode/ddj/1996/9601.zip">Color Quantization using Octrees in Dr. Dobb's Source Code</a></li>
<li><a href="http://web.cs.wpi.edu/~matt/courses/cs563/talks/color_quant/CQoctree.html">Octree Color Quantization Overview</a></li>
<li><a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=727419">Parallel implementation of octtree generation algorithm, P. Sojan Lal, A Unnikrishnan, K Poulose Jacob, ICIP 1997, IEEE Digital Library</a></li>
<li><a href="http://dblp.uni-trier.de/db/conf/viip/viip2001.html#LalUJ01">Generation of Octrees from Raster Scan with Reduced Information Loss, P. Sojan Lal, A Unnikrishnan, K Poulose Jacob, IASTED International conference VIIP 2001</a> <a href="http://www.actapress.com/catalogue2009/proc_series13.html#viip2001">1</a></li>
<li><a href="http://nomis80.org/code/octree.html">C++ implementation (GPL license)</a></li>
<li><a href="http://sc07.supercomputing.org/schedule/pdf/pap117.pdf">Parallel Octrees for Finite Element Applications</a></li>
<li><a href="http://www.cc.gatech.edu/csela/dendro">Dendro: parallel multigrid for octree meshes (MPI/C++ implementation)</a></li>
<li><a href="http://www.youtube.com/watch?v=Jw4VAgcWruY">Video: Use of an octree in state estimation</a></li>
<li><a href="https://github.com/toki78/RayCL">Source code of an OpenCL raytracer applet using an Octree</a></li>
<li><a href="http://www.mathworks.com/matlabcentral/fileexchange/40732-octree-partitioning-3d-points-into-spatial-subvolumes">MATLAB implementation of OcTree decomposition</a></li>
</ul>

<p>"</p>

<p><a href="Category:Trees_(data_structures)" title="wikilink">Category:Trees (data structures)</a> <a href="Category:Computer_graphics_data_structures" title="wikilink">Category:Computer graphics data structures</a> <a href="Category:Database_index_techniques" title="wikilink">Category:Database index techniques</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://isas.uka.de/Publikationen/Fusion10_EberhardtKlumpp.pdf">Henning Eberhardt, Vesa Klumpp, Uwe D. Hanebeck, <em>Density Trees for Efficient Nonlinear State Estimation</em>, Proceedings of the 13th International Conference on Information Fusion, Edinburgh, United Kingdom, July, 2010.</a><a href="#fnref3">↩</a></li>
<li id="fn4">Bloomberg, Dan S. <a href="http://leptonica.net/papers/colorquant.pdf">"Color quantization using octrees."</a>, 4 September 2008. Retrieved on 12 December 2014.<a href="#fnref4">↩</a></li>
</ol>
</section>
</body>

