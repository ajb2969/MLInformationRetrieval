<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1025">Zig-zag product</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Zig-zag product</h1>
<hr/>

<p>In <a href="graph_theory" title="wikilink">graph theory</a>, the <strong>zig-zag product</strong> of <a href="regular_graph" title="wikilink">regular graphs</a> 

<math display="inline" id="Zig-zag_product:0">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>,</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>G</ci>
    <ci>H</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G,H
  </annotation>
 </semantics>
</math>

, denoted by 

<math display="inline" id="Zig-zag_product:1">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>∘</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <ci>G</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\circ H
  </annotation>
 </semantics>
</math>

, takes a large graph (

<math display="inline" id="Zig-zag_product:2">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

) and a small graph (

<math display="inline" id="Zig-zag_product:3">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

), and produces a graph that approximately inherits the size of the large one but the degree of the small one. An important property of the zig-zag product is that if 

<math display="inline" id="Zig-zag_product:4">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 is a good <a href="Expander_graph" title="wikilink">expander</a>, then the expansion of the resulting graph is only slightly worse than the expansion of 

<math display="inline" id="Zig-zag_product:5">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

.</p>

<p>Roughly speaking, the zig-zag product 

<math display="inline" id="Zig-zag_product:6">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>∘</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <ci>G</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\circ H
  </annotation>
 </semantics>
</math>

 replaces each vertex of 

<math display="inline" id="Zig-zag_product:7">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 with a copy (cloud) of 

<math display="inline" id="Zig-zag_product:8">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

, and connects the vertices by moving a small step (zig) inside a cloud, followed by a big step (zag) between two clouds, and finally performs another small step inside the destination cloud.</p>

<p>The zigzag product was introduced by . When the zig-zag product was first introduced, it was used for the explicit construction of constant degree expanders and extractors. Later on the zig-zag product was used in <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a> to prove that <a href="SL_(complexity)" title="wikilink">symmetric logspace</a> and <a href="L_(complexity)" title="wikilink">logspace</a> are equal .</p>
<h2 id="definition">Definition</h2>

<p>Let 

<math display="inline" id="Zig-zag_product:9">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 be a 

<math display="inline" id="Zig-zag_product:10">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

-regular graph on 

<math display="inline" id="Zig-zag_product:11">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>N</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [N]
  </annotation>
 </semantics>
</math>

 with <a href="rotation_map" title="wikilink">rotation map</a> 

<math display="inline" id="Zig-zag_product:12">
 <semantics>
  <msub>
   <mi>Rot</mi>
   <mi>G</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Rot</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Rot}_{G}
  </annotation>
 </semantics>
</math>

 and let 

<math display="inline" id="Zig-zag_product:13">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 be a 

<math display="inline" id="Zig-zag_product:14">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

-regular graph on 

<math display="inline" id="Zig-zag_product:15">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>D</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [D]
  </annotation>
 </semantics>
</math>

 with rotation map 

<math display="inline" id="Zig-zag_product:16">
 <semantics>
  <msub>
   <mi>Rot</mi>
   <mi>H</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Rot</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Rot}_{H}
  </annotation>
 </semantics>
</math>

. The zig-zag product 

<math display="inline" id="Zig-zag_product:17">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>∘</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <ci>G</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\circ H
  </annotation>
 </semantics>
</math>

 is defined to be the 

<math display="inline" id="Zig-zag_product:18">
 <semantics>
  <msup>
   <mi>d</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>d</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d^{2}
  </annotation>
 </semantics>
</math>

-regular graph on 

<math display="inline" id="Zig-zag_product:19">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>N</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>×</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>D</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [N]\times[D]
  </annotation>
 </semantics>
</math>

 whose rotation map 

<math display="inline" id="Zig-zag_product:20">
 <semantics>
  <msub>
   <mi>Rot</mi>
   <mrow>
    <mi>G</mi>
    <mo>∘</mo>
    <mi>H</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Rot</ci>
    <apply>
     <compose></compose>
     <ci>G</ci>
     <ci>H</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Rot}_{G\circ H}
  </annotation>
 </semantics>
</math>

 is as follows:<br/>


<math display="inline" id="Zig-zag_product:21">
 <semantics>
  <mrow>
   <msub>
    <mi>Rot</mi>
    <mrow>
     <mi>G</mi>
     <mo>∘</mo>
     <mi>H</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Rot</ci>
     <apply>
      <compose></compose>
      <ci>G</ci>
      <ci>H</ci>
     </apply>
    </apply>
    <interval closure="open">
     <interval closure="open">
      <ci>v</ci>
      <ci>a</ci>
     </interval>
     <interval closure="open">
      <ci>i</ci>
      <ci>j</ci>
     </interval>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Rot}_{G\circ H}((v,a),(i,j))
  </annotation>
 </semantics>
</math>

:</p>
<ol>
<li>Let 

<math display="inline" id="Zig-zag_product:22">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>a</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>i</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>Rot</mi>
     <mi>H</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>i</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Rot</ci>
      <ci>H</ci>
     </apply>
     <interval closure="open">
      <ci>a</ci>
      <ci>i</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a^{\prime},i^{\prime})=\mathrm{Rot}_{H}(a,i)
  </annotation>
 </semantics>
</math>

.</li>
<li>Let 

<math display="inline" id="Zig-zag_product:23">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo>,</mo>
    <msup>
     <mi>b</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>Rot</mi>
     <mi>G</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <msup>
      <mi>a</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <ci>w</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Rot</ci>
      <ci>G</ci>
     </apply>
     <interval closure="open">
      <ci>v</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>normal-′</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (w,b^{\prime})=\mathrm{Rot}_{G}(v,a^{\prime})
  </annotation>
 </semantics>
</math>

.</li>
<li>Let 

<math display="inline" id="Zig-zag_product:24">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo>,</mo>
    <msup>
     <mi>j</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>Rot</mi>
     <mi>H</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>b</mi>
      <mo>′</mo>
     </msup>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <ci>b</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>j</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Rot</ci>
      <ci>H</ci>
     </apply>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>j</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (b,j^{\prime})=\mathrm{Rot}_{H}(b^{\prime},j)
  </annotation>
 </semantics>
</math>

.</li>
<li>Output 

<math display="inline" id="Zig-zag_product:25">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>j</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>i</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <interval closure="open">
     <ci>w</ci>
     <ci>b</ci>
    </interval>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>j</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>i</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((w,b),(j^{\prime},i^{\prime}))
  </annotation>
 </semantics>
</math>

.</li>
</ol>
<h2 id="properties">Properties</h2>
<h3 id="reduction-of-the-degree">Reduction of the degree</h3>

<p>It is immediate from the definition of the zigzag product that it transforms a graph 

<math display="inline" id="Zig-zag_product:26">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 to a new graph which is 

<math display="inline" id="Zig-zag_product:27">
 <semantics>
  <msup>
   <mi>d</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>d</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d^{2}
  </annotation>
 </semantics>
</math>

-regular. Thus if 

<math display="inline" id="Zig-zag_product:28">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is a significantly larger than 

<math display="inline" id="Zig-zag_product:29">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

, the zigzag product will reduce the degree of 

<math display="inline" id="Zig-zag_product:30">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

. Roughly speaking, by amplifying each vertex of 

<math display="inline" id="Zig-zag_product:31">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 into a cloud of the size of 

<math display="inline" id="Zig-zag_product:32">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 the product in fact splits the edges of each original vertex between the vertices of the cloud that replace it.</p>
<h3 id="spectral-gap-preservation">Spectral gap preservation</h3>

<p>The expansion of a graph can be measured by its spectral gap. An important property of the zigzag product is the preservation of the <a href="spectral_gap" title="wikilink">spectral gap</a>. That is, if 

<math display="inline" id="Zig-zag_product:33">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 is a “good enough” expander (has a large spectral gap) then the expansion of the zigzag product is close to the original expansion of 

<math display="inline" id="Zig-zag_product:34">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

.</p>

<p>Formally: Define a 

<math display="inline" id="Zig-zag_product:35">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>N</mi>
   <mo>,</mo>
   <mi>D</mi>
   <mo>,</mo>
   <mi>λ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>N</ci>
    <ci>D</ci>
    <ci>λ</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (N,D,\lambda)
  </annotation>
 </semantics>
</math>

-graph as any 

<math display="inline" id="Zig-zag_product:36">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

-regular graph on 

<math display="inline" id="Zig-zag_product:37">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 vertices, whose second largest eigenvalue (of the associated random walk) has absolute value at most 

<math display="inline" id="Zig-zag_product:38">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

.</p>

<p>Let 

<math display="inline" id="Zig-zag_product:39">
 <semantics>
  <msub>
   <mi>G</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{1}
  </annotation>
 </semantics>
</math>

 be a 

<math display="inline" id="Zig-zag_product:40">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>N</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>D</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>λ</mi>
    <mn>1</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>N</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <cn type="integer">1</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (N_{1},D_{1},\lambda_{1})
  </annotation>
 </semantics>
</math>

-graph and 

<math display="inline" id="Zig-zag_product:41">
 <semantics>
  <msub>
   <mi>G</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{2}
  </annotation>
 </semantics>
</math>

 be a 

<math display="inline" id="Zig-zag_product:42">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>D</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>D</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>λ</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <cn type="integer">2</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (D_{1},D_{2},\lambda_{2})
  </annotation>
 </semantics>
</math>

-graph, then 

<math display="inline" id="Zig-zag_product:43">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mo>∘</mo>
    <mi>z</mi>
   </mrow>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <compose></compose>
     <ci>G</ci>
     <ci>z</ci>
    </apply>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\circ{z}H
  </annotation>
 </semantics>
</math>

 is a 

<math display="inline" id="Zig-zag_product:44">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>N</mi>
     <mn>1</mn>
    </msub>
    <mo>⋅</mo>
    <msub>
     <mi>D</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>,</mo>
   <msubsup>
    <mi>D</mi>
    <mn>2</mn>
    <mn>2</mn>
   </msubsup>
   <mo>,</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>λ</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>λ</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (N_{1}\cdot D_{1},D_{2}^{2},f(\lambda_{1},\lambda_{2}))
  </annotation>
 </semantics>
</math>

-graph, where 

<math display="inline" id="Zig-zag_product:45">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>λ</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>λ</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <msub>
     <mi>λ</mi>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>λ</mi>
     <mn>2</mn>
    </msub>
    <mo>+</mo>
    <msubsup>
     <mi>λ</mi>
     <mn>2</mn>
     <mn>2</mn>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\lambda_{1},\lambda_{2})<\lambda_{1}+\lambda_{2}+\lambda_{2}^{2}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="connectivity-preservation">Connectivity preservation</h3>

<p>The zigzag product 

<math display="inline" id="Zig-zag_product:46">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>∘</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <ci>G</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\circ H
  </annotation>
 </semantics>
</math>

 operates separately on each connected component of 

<math display="inline" id="Zig-zag_product:47">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

.</p>

<p>Formally speaking, given two graphs

<math display="block" id="Zig-zag_product:48">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, a 

<math display="inline" id="Zig-zag_product:49">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

-regular graph on 

<math display="inline" id="Zig-zag_product:50">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>N</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [N]
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Zig-zag_product:51">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

, a 

<math display="inline" id="Zig-zag_product:52">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

-regular graph on 

<math display="inline" id="Zig-zag_product:53">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>D</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [D]
  </annotation>
 </semantics>
</math>

 - if 

<math display="inline" id="Zig-zag_product:54">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊆</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>N</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subseteq[N]
  </annotation>
 </semantics>
</math>

 is a connected component of 

<math display="inline" id="Zig-zag_product:55">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Zig-zag_product:56">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mi>G</mi>
      <mo fence="true">|</mo>
     </mrow>
     <mi>S</mi>
    </msub>
    <mo>∘</mo>
    <mi>H</mi>
   </mrow>
   <mo>=</mo>
   <msub>
    <mrow>
     <mrow>
      <mi>G</mi>
      <mo>∘</mo>
      <mi>H</mi>
     </mrow>
     <mo fence="true">|</mo>
    </mrow>
    <mrow>
     <mi>S</mi>
     <mo>×</mo>
     <mi>D</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="latexml">evaluated-at</csymbol>
      <ci>G</ci>
      <ci>S</ci>
     </apply>
     <ci>H</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">evaluated-at</csymbol>
     <apply>
      <compose></compose>
      <ci>G</ci>
      <ci>H</ci>
     </apply>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>D</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G|_{S}\circ H=G\circ H|_{S\times D}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Zig-zag_product:57">
 <semantics>
  <msub>
   <mrow>
    <mi>G</mi>
    <mo fence="true">|</mo>
   </mrow>
   <mi>S</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">evaluated-at</csymbol>
    <ci>G</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G|_{S}
  </annotation>
 </semantics>
</math>

 is the subgraph of 

<math display="inline" id="Zig-zag_product:58">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 induced by 

<math display="inline" id="Zig-zag_product:59">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 (i.e., the graph on 

<math display="inline" id="Zig-zag_product:60">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 which contains all of the edges in 

<math display="inline" id="Zig-zag_product:61">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 between vertices in 

<math display="inline" id="Zig-zag_product:62">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

).</p>
<h2 id="applications">Applications</h2>
<h3 id="construction-of-constant-degree-expanders">Construction of constant degree expanders</h3>

<p>In 2002 Omer Reingold, Salil Vadhan, and Avi Wigderson have given a simple, explicit combinatorial construction of constant-degree expander graphs. The construction is iterative, and needs as a basic building block a single, expander of constant size. In each iteration the zigzag product is used in order to generate another graph whose size is increased but its degree and expansion remains unchanged. This process continues, yielding arbitrarily large expanders.</p>

<p>From the properties of the zigzag product mentioned above, we see that the product of a large graph with a small graph, inherits a size similar to the large graph, and degree similar to the small graph, while preserving its expansion properties from both, thus enabling to increase the size of the expander without deleterious effects.</p>
<h3 id="solving-the-undirected-s-t-connectivity-problem-in-logarithmic-space">Solving the undirected s-t connectivity problem in logarithmic space</h3>

<p>In 2005 Omer Reingold introduced an algorithm that solves the undirected <a class="uri" href="st-connectivity" title="wikilink">st-connectivity</a> problem, the problem of testing whether there is a path between two given vertices in an undirected graph, using only logarithmic space. The algorithm relies heavily on the zigzag product.</p>

<p>Roughly speaking, in order to solve the undirected s-t connectivity problem in logarithmic space, the input graph is transformed, using a combination of powering and the zigzag product, into a constant-degree regular graph with a logarithmic diameter. The power product increases the expansion (hence reduces the diameter) at the price of increasing the degree, and the zigzag product is used to reduce the degree while preserving the expansion.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Graph_operations" title="wikilink">Graph operations</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Graph_products" title="wikilink">Category:Graph products</a></p>
</body>
</html>
