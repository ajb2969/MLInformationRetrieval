<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="533">Left recursion</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Left recursion</h1>
<hr/>

<p>In the <a href="formal_language_theory" title="wikilink">formal language theory</a> of <a href="computer_science" title="wikilink">computer science</a>, <strong>left recursion</strong> is a special case of <a class="uri" href="recursion" title="wikilink">recursion</a> where a string is recognized as part of a language by the fact that it decomposes into a string from that same language (on the left) and a suffix (on the right). For instance, 

<math display="inline" id="Left_recursion:0">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>+</mo>
   <mn>2</mn>
   <mo>+</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+2+3
  </annotation>
 </semantics>
</math>

 can be recognized as a sum because it can be broken into 

<math display="inline" id="Left_recursion:1">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>+</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+2
  </annotation>
 </semantics>
</math>

, also a sum, and 

<math display="inline" id="Left_recursion:2">
 <semantics>
  <mrow>
   <mo>+</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}+3
  </annotation>
 </semantics>
</math>

, a suitable suffix.</p>

<p>In terms of <a href="context-free_grammar" title="wikilink">context-free grammar</a>, a <a href="Terminal_and_nonterminal_symbols#Nonterminal_symbols" title="wikilink">nonterminal</a> is left-recursive if the leftmost symbol in one of its productions is itself (in the case of direct left recursion) or can be made itself by some sequence of substitutions (in the case of indirect left recursion).</p>
<h2 id="definition">Definition</h2>

<p>A grammar is left-recursive if and only if there exists a nonterminal symbol 

<math display="inline" id="Left_recursion:3">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 that can derive to a <a href="Formal_grammar#The_semantics_of_grammars" title="wikilink">sentential form</a> with itself as the leftmost symbol.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Symbolically,</p>

<p>

<math display="block" id="Left_recursion:4">
 <semantics>
  <mrow>
   <mi>A</mi>
   <msup>
    <mo>⇒</mo>
    <mo>+</mo>
   </msup>
   <mrow>
    <mi>A</mi>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-⇒</ci>
     <plus></plus>
    </apply>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\Rightarrow^{+}A\alpha
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Left_recursion:5">
 <semantics>
  <msup>
   <mo>⇒</mo>
   <mo>+</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-⇒</ci>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Rightarrow^{+}
  </annotation>
 </semantics>
</math>

 indicates the operation of making one or more substitutions, and 

<math display="inline" id="Left_recursion:6">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is any sequence of terminal and nonterminal symbols.</p>
<h3 id="direct-left-recursion">Direct left recursion</h3>

<p>Direct left recursion occurs when the definition can be satisfied with only one substitution. It requires a rule of the form</p>

<p>

<math display="block" id="Left_recursion:7">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>→</mo>
   <mrow>
    <mi>A</mi>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\to A\alpha
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Left_recursion:8">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is a sequence of nonterminals and terminals. For example, the rule</p>

<p>

<math display="block" id="Left_recursion:9">
 <semantics>
  <mrow>
   <mi>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</mi>
   <mo>→</mo>
   <mrow>
    <mi>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</mi>
    <mo>+</mo>
    <mi>𝑇𝑒𝑟𝑚</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</ci>
    <apply>
     <plus></plus>
     <ci>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</ci>
     <ci>𝑇𝑒𝑟𝑚</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{Expression}\to\mathit{Expression}+\mathit{Term}
  </annotation>
 </semantics>
</math>

 is directly left-recursive. A left-to-right <a href="recursive_descent_parser" title="wikilink">recursive descent parser</a> for this rule might look like</p>
<pre class="text"><code>function Expression()
{
    Expression();  match('+');  Term();
}</code></pre>

<p>and such code would fall into infinite recursion when executed.</p>
<h3 id="indirect-left-recursion">Indirect left recursion</h3>

<p>Indirect left recursion occurs when the definition is satisfied via several substitutions. It entails a set of rules following the pattern</p>

<p>

<math display="block" id="Left_recursion:10">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>0</mn>
   </msub>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>β</mi>
     <mn>0</mn>
    </msub>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>α</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{0}\to\beta_{0}A_{1}\alpha_{0}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Left_recursion:11">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>1</mn>
   </msub>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>β</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>A</mi>
     <mn>2</mn>
    </msub>
    <msub>
     <mi>α</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{1}\to\beta_{1}A_{2}\alpha_{1}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Left_recursion:12">
 <semantics>
  <mi mathvariant="normal">⋯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⋯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cdots
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Left_recursion:13">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mi>n</mi>
   </msub>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>β</mi>
     <mi>n</mi>
    </msub>
    <msub>
     <mi>A</mi>
     <mn>0</mn>
    </msub>
    <msub>
     <mi>α</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{n}\to\beta_{n}A_{0}\alpha_{n}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Left_recursion:14">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>β</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>β</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{0},\beta_{1},\ldots,\beta_{n}
  </annotation>
 </semantics>
</math>

 are sequences that can each yield the empty string, while 

<math display="inline" id="Left_recursion:15">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>α</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>α</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{0},\alpha_{1},\ldots,\alpha_{n}
  </annotation>
 </semantics>
</math>

 may be any sequences at all. The derivation</p>

<p>

<math display="block" id="Left_recursion:16">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>0</mn>
   </msub>
   <mo>⇒</mo>
   <mrow>
    <msub>
     <mi>β</mi>
     <mn>0</mn>
    </msub>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>α</mi>
     <mn>0</mn>
    </msub>
   </mrow>
   <msup>
    <mo>⇒</mo>
    <mo>+</mo>
   </msup>
   <mrow>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>α</mi>
     <mn>0</mn>
    </msub>
   </mrow>
   <mo>⇒</mo>
   <mrow>
    <msub>
     <mi>β</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>A</mi>
     <mn>2</mn>
    </msub>
    <msub>
     <mi>α</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>α</mi>
     <mn>0</mn>
    </msub>
   </mrow>
   <msup>
    <mo>⇒</mo>
    <mo>+</mo>
   </msup>
   <mi mathvariant="normal">⋯</mi>
   <msup>
    <mo>⇒</mo>
    <mo>+</mo>
   </msup>
   <mrow>
    <msub>
     <mi>A</mi>
     <mn>0</mn>
    </msub>
    <msub>
     <mi>α</mi>
     <mi>n</mi>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>α</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>α</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-⇒</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-⇒</ci>
      <plus></plus>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-⇒</ci>
      <plus></plus>
     </apply>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-⇒</ci>
      <plus></plus>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>n</ci>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{0}\Rightarrow\beta_{0}A_{1}\alpha_{0}\Rightarrow^{+}A_{1}\alpha_{0}%
\Rightarrow\beta_{1}A_{2}\alpha_{1}\alpha_{0}\Rightarrow^{+}\cdots\Rightarrow^%
{+}A_{0}\alpha_{n}\dots\alpha_{1}\alpha_{0}
  </annotation>
 </semantics>
</math>

 then gives 

<math display="inline" id="Left_recursion:17">
 <semantics>
  <msub>
   <mi>A</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{0}
  </annotation>
 </semantics>
</math>

 as leftmost in its final sentential form.</p>
<h2 id="removing-left-recursion">Removing left recursion</h2>

<p>Left recursion often poses problems for parsers, either because it leads them into infinite recursion (as in the case of most <a href="top-down_parsing" title="wikilink">top-down parsers</a>) or because they expect rules in a normal form that forbids it (as in the case of many <a href="bottom-up_parsing" title="wikilink">bottom-up parsers</a>, including the <a href="CYK_algorithm" title="wikilink">CYK algorithm</a>). Therefore a grammar is often preprocessed to eliminate the left recursion.</p>
<h3 id="removing-direct-left-recursion">Removing direct left recursion</h3>

<p>The general algorithm to remove direct left recursion follows. Several improvements to this method have been made.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> For a left-recursive nonterminal 

<math display="inline" id="Left_recursion:18">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, discard any rules of the form 

<math display="inline" id="Left_recursion:19">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>→</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>A</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\rightarrow A
  </annotation>
 </semantics>
</math>

 and consider those that remain:</p>

<p>

<math display="block" id="Left_recursion:20">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>→</mo>
   <mi>A</mi>
   <msub>
    <mi>α</mi>
    <mn>1</mn>
   </msub>
   <mo>∣</mo>
   <mi mathvariant="normal">…</mi>
   <mo>∣</mo>
   <mi>A</mi>
   <msub>
    <mi>α</mi>
    <mi>n</mi>
   </msub>
   <mo>∣</mo>
   <msub>
    <mi>β</mi>
    <mn>1</mn>
   </msub>
   <mo>∣</mo>
   <mi mathvariant="normal">…</mi>
   <mo>∣</mo>
   <msub>
    <mi>β</mi>
    <mi>m</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">A</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-∣</ci>
    <ci>normal-…</ci>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">A</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>n</ci>
    </apply>
    <ci>normal-∣</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-∣</ci>
    <ci>normal-…</ci>
    <ci>normal-∣</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>m</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\rightarrow A\alpha_{1}\mid\ldots\mid A\alpha_{n}\mid\beta_{1}\mid\ldots\mid%
\beta_{m}
  </annotation>
 </semantics>
</math>

 where:</p>
<ul>
<li>each 

<math display="inline" id="Left_recursion:21">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is a nonempty sequence of nonterminals and terminals, and</li>
<li>each 

<math display="inline" id="Left_recursion:22">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 is a sequence of nonterminals and terminals that does not start with 

<math display="inline" id="Left_recursion:23">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>Replace these with two sets of productions, one set for 

<math display="inline" id="Left_recursion:24">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Left_recursion:25">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>β</mi>
     <mn>1</mn>
    </msub>
    <msup>
     <mi>A</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo>∣</mo>
     <mi mathvariant="normal">…</mi>
     <mo>∣</mo>
    </mrow>
    <msub>
     <mi>β</mi>
     <mi>m</mi>
    </msub>
    <msup>
     <mi>A</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>A</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-∣∣</csymbol>
      <ci>normal-…</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\rightarrow\beta_{1}A^{\prime}\mid\ldots\mid\beta_{m}A^{\prime}
  </annotation>
 </semantics>
</math>

 and another set for the fresh nonterminal 

<math display="inline" id="Left_recursion:26">
 <semantics>
  <msup>
   <mi>A</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>A</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{\prime}
  </annotation>
 </semantics>
</math>

 (often called the "tail" or the "rest"):</p>

<p>

<math display="block" id="Left_recursion:27">
 <semantics>
  <mrow>
   <msup>
    <mi>A</mi>
    <mo>′</mo>
   </msup>
   <mo>→</mo>
   <msub>
    <mi>α</mi>
    <mn>1</mn>
   </msub>
   <msup>
    <mi>A</mi>
    <mo>′</mo>
   </msup>
   <mo>∣</mo>
   <mi mathvariant="normal">…</mi>
   <mo>∣</mo>
   <msub>
    <mi>α</mi>
    <mi>n</mi>
   </msub>
   <msup>
    <mi>A</mi>
    <mo>′</mo>
   </msup>
   <mo>∣</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>normal-∣</ci>
    <ci>normal-…</ci>
    <ci>normal-∣</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">ϵ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{\prime}\rightarrow\alpha_{1}A^{\prime}\mid\ldots\mid\alpha_{n}A^{\prime}\mid\epsilon
  </annotation>
 </semantics>
</math>

 Repeat this process until no direct left recursion remains.</p>

<p>As an example, consider the rule set</p>

<p>

<math display="block" id="Left_recursion:28">
 <semantics>
  <mrow>
   <mi>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</mi>
   <mo>→</mo>
   <mrow>
    <mi>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</mi>
    <mo>+</mo>
    <mrow>
     <mi>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</mi>
     <mrow>
      <mo>∣</mo>
      <mi>𝐼𝑛𝑡𝑒𝑔𝑒𝑟</mi>
      <mo>∣</mo>
     </mrow>
     <mi>𝑆𝑡𝑟𝑖𝑛𝑔</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</ci>
    <apply>
     <plus></plus>
     <ci>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</ci>
     <apply>
      <times></times>
      <ci>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</ci>
      <apply>
       <csymbol cd="latexml">delimited-∣∣</csymbol>
       <ci>𝐼𝑛𝑡𝑒𝑔𝑒𝑟</ci>
      </apply>
      <ci>𝑆𝑡𝑟𝑖𝑛𝑔</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{Expression}\rightarrow\mathit{Expression}+\mathit{Expression}\mid%
\mathit{Integer}\mid\mathit{String}
  </annotation>
 </semantics>
</math>

 This could be rewritten to avoid left recursion as</p>

<p>

<math display="block" id="Left_recursion:29">
 <semantics>
  <mrow>
   <mi>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</mi>
   <mo>→</mo>
   <mpadded width="+1.7pt">
    <mi>𝐼𝑛𝑡𝑒𝑔𝑒𝑟</mi>
   </mpadded>
   <msup>
    <mi>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</mi>
    <mo>′</mo>
   </msup>
   <mo>∣</mo>
   <mpadded width="+1.7pt">
    <mi>𝑆𝑡𝑟𝑖𝑛𝑔</mi>
   </mpadded>
   <msup>
    <mi>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Expression</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">Integer</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">String</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</ci>
     <ci>normal-′</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{Expression}\rightarrow\mathit{Integer}\,\mathit{Expression}^{\prime}%
\mid\mathit{String}\,\mathit{Expression}^{\prime}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Left_recursion:30">
 <semantics>
  <mrow>
   <msup>
    <mi>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</mi>
    <mo>′</mo>
   </msup>
   <mo>→</mo>
   <mo>+</mo>
   <mpadded width="+1.7pt">
    <mi>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</mi>
   </mpadded>
   <msup>
    <mi>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</mi>
    <mo>′</mo>
   </msup>
   <mo>∣</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>normal-→</ci>
    <plus></plus>
    <csymbol cd="unknown">Expression</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">ϵ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{Expression}^{\prime}\rightarrow{}+\mathit{Expression}\,\mathit{%
Expression}^{\prime}\mid\epsilon
  </annotation>
 </semantics>
</math>

</p>
<h3 id="removing-all-left-recursion">Removing all left recursion</h3>

<p>By establishing a <a href="topological_ordering" title="wikilink">topological ordering</a> on nonterminals, the above process can be extended to also eliminate indirect left recursion:</p>
<dl>
<dd><strong>Inputs</strong> <em>A grammar: a set of nonterminals 

<math display="inline" id="Left_recursion:31">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>A</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{1},\ldots,A_{n}
  </annotation>
 </semantics>
</math>

 and their productions</em>
</dd>
<dd><strong>Output</strong> <em>A modified grammar generating the same language but without left recursion</em>
<ol>
<li><em>For each nonterminal 

<math display="inline" id="Left_recursion:32">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}
  </annotation>
 </semantics>
</math>

:</em>
<ol>
<li><em>Repeat until an iteration leaves the grammar unchanged:</em>
<ol>
<li><em>For each rule 

<math display="inline" id="Left_recursion:33">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mi>i</mi>
   </msub>
   <mo>→</mo>
   <msub>
    <mi>α</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}\rightarrow\alpha_{i}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Left_recursion:34">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}
  </annotation>
 </semantics>
</math>

 being a sequence of terminals and nonterminals:</em>
<ol>
<li><em>If 

<math display="inline" id="Left_recursion:35">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}
  </annotation>
 </semantics>
</math>

 begins with a nonterminal 

<math display="inline" id="Left_recursion:36">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{j}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Left_recursion:37">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}
  </annotation>
 </semantics>
</math>

 be 

<math display="inline" id="Left_recursion:38">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{j}
  </annotation>
 </semantics>
</math>

 without its leading 

<math display="inline" id="Left_recursion:39">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mi>i</mi>
   </msub>
   <mo>→</mo>
   <msub>
    <mi>α</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}\rightarrow\alpha_{i}
  </annotation>
 </semantics>
</math>

.</em>
<ol>
<li><em>Remove the rule 

<math display="inline" id="Left_recursion:40">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mi>j</mi>
   </msub>
   <mo>→</mo>
   <msub>
    <mi>α</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{j}\rightarrow\alpha_{j}
  </annotation>
 </semantics>
</math>

.</em></li>
<li><em>For each rule 

<math display="inline" id="Left_recursion:41">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mi>i</mi>
   </msub>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>α</mi>
     <mi>j</mi>
    </msub>
    <msub>
     <mi>β</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}\rightarrow\alpha_{j}\beta_{i}
  </annotation>
 </semantics>
</math>

:</em>
<ol>
<li><em>Add the rule 

<math display="inline" id="Left_recursion:42">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}
  </annotation>
 </semantics>
</math>

.</em></li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
<li><em>Remove direct left recursion for 

<math display="block" id="Left_recursion:43">
 <semantics>
  <mrow>
   <mi>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</mi>
   <mo>→</mo>
   <mpadded width="+1.7pt">
    <mi>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</mi>
   </mpadded>
   <mo rspace="4.2pt">-</mo>
   <mi>𝑇𝑒𝑟𝑚</mi>
   <mo>∣</mo>
   <mi>𝑇𝑒𝑟𝑚</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Expression</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">Expression</csymbol>
    <minus></minus>
    <csymbol cd="unknown">Term</csymbol>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">Term</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{Expression}\rightarrow\mathit{Expression}\,-\,\mathit{Term}\mid\mathit%
{Term}
  </annotation>
 </semantics>
</math>

 as described above.</em></li>
</ol></li>
</ol>
</dd>
</dl>

<p>Note that this algorithm is highly sensitive to the nonterminal ordering; optimizations often focus on choosing this ordering well.</p>
<h2 id="pitfalls">Pitfalls</h2>

<p>Although the above transformations preserve the language generated by a grammar, they may change the <a href="parse_tree" title="wikilink">parse trees</a> that <a href="Witness_(mathematics)" title="wikilink">witness</a> strings' recognition. With suitable bookkeeping, <a href="Rewriting#Term_rewriting_systems" title="wikilink">tree rewriting</a> can recover the originals, but if this step is omitted, the differences may change the semantics of a parse.</p>

<p>Associativity is particularly vulnerable; left-associative operators typically appear in right-associative-like arrangements under the new grammar. For example, starting with this grammar:</p>

<p>

<math display="block" id="Left_recursion:44">
 <semantics>
  <mrow>
   <mi>𝑇𝑒𝑟𝑚</mi>
   <mo>→</mo>
   <mpadded width="+1.7pt">
    <mi>𝑇𝑒𝑟𝑚</mi>
   </mpadded>
   <mo rspace="4.2pt">*</mo>
   <mi>𝐹𝑎𝑐𝑡𝑜𝑟</mi>
   <mo>∣</mo>
   <mi>𝐹𝑎𝑐𝑡𝑜𝑟</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Term</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">Term</csymbol>
    <times></times>
    <csymbol cd="unknown">Factor</csymbol>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">Factor</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{Term}\rightarrow\mathit{Term}\,*\,\mathit{Factor}\mid\mathit{Factor}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Left_recursion:45">
 <semantics>
  <mrow>
   <mi>𝐹𝑎𝑐𝑡𝑜𝑟</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∣</mo>
   <mi>𝐼𝑛𝑡𝑒𝑔𝑒𝑟</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Factor</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Expression</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">Integer</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{Factor}\rightarrow(\mathit{Expression})\mid\mathit{Integer}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Left_recursion:46">
 <semantics>
  <mrow>
   <mi>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</mi>
   <mo>→</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>𝑇𝑒𝑟𝑚</mi>
    </mpadded>
    <msup>
     <mi>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</ci>
    <apply>
     <times></times>
     <ci>𝑇𝑒𝑟𝑚</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{Expression}\rightarrow\mathit{Term}\ \mathit{Expression}^{\prime}
  </annotation>
 </semantics>
</math>

 the standard transformations to remove left recursion yield the following:</p>

<p>

<math display="block" id="Left_recursion:47">
 <semantics>
  <mrow>
   <msup>
    <mi>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</mi>
    <mo>′</mo>
   </msup>
   <mo>→</mo>
   <mo>-</mo>
   <mpadded width="+5pt">
    <mi>𝑇𝑒𝑟𝑚</mi>
   </mpadded>
   <msup>
    <mi>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</mi>
    <mo>′</mo>
   </msup>
   <mo>∣</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>normal-→</ci>
    <minus></minus>
    <csymbol cd="unknown">Term</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">ϵ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{Expression}^{\prime}\rightarrow{}-\mathit{Term}\ \mathit{Expression}^{%
\prime}\mid\epsilon
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Left_recursion:48">
 <semantics>
  <mrow>
   <mi>𝑇𝑒𝑟𝑚</mi>
   <mo>→</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>𝐹𝑎𝑐𝑡𝑜𝑟</mi>
    </mpadded>
    <msup>
     <mi>𝑇𝑒𝑟𝑚</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>𝑇𝑒𝑟𝑚</ci>
    <apply>
     <times></times>
     <ci>𝐹𝑎𝑐𝑡𝑜𝑟</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝑇𝑒𝑟𝑚</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{Term}\rightarrow\mathit{Factor}\ \mathit{Term}^{\prime}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Left_recursion:49">
 <semantics>
  <mrow>
   <msup>
    <mi>𝑇𝑒𝑟𝑚</mi>
    <mo>′</mo>
   </msup>
   <mo>→</mo>
   <mo>*</mo>
   <mpadded width="+5pt">
    <mi>𝐹𝑎𝑐𝑡𝑜𝑟</mi>
   </mpadded>
   <msup>
    <mi>𝑇𝑒𝑟𝑚</mi>
    <mo>′</mo>
   </msup>
   <mo>∣</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝑇𝑒𝑟𝑚</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>normal-→</ci>
    <times></times>
    <csymbol cd="unknown">Factor</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝑇𝑒𝑟𝑚</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">ϵ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{Term}^{\prime}\rightarrow{}*\mathit{Factor}\ \mathit{Term}^{\prime}\mid\epsilon
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Left_recursion:50">
 <semantics>
  <mrow>
   <mi>𝐹𝑎𝑐𝑡𝑜𝑟</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐸𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∣</mo>
   <mi>𝐼𝑛𝑡𝑒𝑔𝑒𝑟</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Factor</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Expression</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">Integer</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{Factor}\rightarrow(\mathit{Expression})\mid\mathit{Integer}
  </annotation>
 </semantics>
</math>

</p>

<p><span class="LaTeX">$$\mathit{Factor} \rightarrow (\mathit{Expression}) \mid \mathit{Integer}$$</span></p>

<p>Parsing the string "1 - 2 - 3" with the first grammar in an LALR parser (which can handle left-recursive grammars) would have resulted in the parse tree:  This parse tree groups the terms on the left, giving the correct semantics <em>(1 - 2) - 3</em>.</p>

<p>Parsing with the second grammar gives  which, properly interpreted, signifies <em>1 + (-2 + (-3))</em>, also correct, but less faithful to the input and much harder to implement for some operators. Notice how terms to the right appear deeper in the tree, much as a right-recursive grammar would arrange them for <em>1 - (2 - 3)</em>.</p>
<h2 id="accommodating-left-recursion-in-top-down-parsing">Accommodating left recursion in top-down parsing</h2>

<p>A <a href="formal_grammar" title="wikilink">formal grammar</a> that contains left recursion cannot be <a href="parse" title="wikilink">parsed</a> by a <a href="LL_parser" title="wikilink">LL(k)-parser</a> or other naive <a href="recursive_descent_parser" title="wikilink">recursive descent parser</a> unless it is converted to a <a href="Weak_equivalence_(formal_languages)" title="wikilink">weakly equivalent</a> right-recursive form. In contrast, left recursion is preferred for <a href="LALR_parser" title="wikilink">LALR parsers</a> because it results in lower stack usage than <a href="right_recursion" title="wikilink">right recursion</a>. However, more sophisticated top-down parsers can implement general <a href="context-free_grammar" title="wikilink">context-free grammars</a> by use of <a class="uri" href="curtailment" title="wikilink">curtailment</a>. In 2006, Frost and Hafiz described an algorithm which accommodates <a href="ambiguous_grammar" title="wikilink">ambiguous grammars</a> with direct left-recursive <a href="Formal_grammar#The_syntax_of_grammars" title="wikilink">production rules</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> That algorithm was extended to a complete <a class="uri" href="parsing" title="wikilink">parsing</a> algorithm to accommodate indirect as well as direct left recursion in <a class="uri" href="polynomial" title="wikilink">polynomial</a> time, and to generate compact polynomial-size representations of the potentially exponential number of parse trees for highly ambiguous grammars by Frost, Hafiz and Callaghan in 2007.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The authors then implemented the algorithm as a set of <a href="parser_combinator" title="wikilink">parser combinators</a> written in the <a href="Haskell_(programming_language)" title="wikilink">Haskell</a> programming language.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Tail_recursion" title="wikilink">Tail recursion</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cs.umd.edu/class/fall2002/cmsc430/lec4.pdf">CMU lecture on left recursion</a></li>
<li><a href="http://lambda.uta.edu/cse5317/notes/node21.html">Practical Considerations for LALR(1) Grammars</a></li>
<li><a href="http://www.cs.uwindsor.ca/~hafiz/proHome.html">X-SAIGA</a> - eXecutable SpecificAtIons of GrAmmars</li>
</ul>

<p>"</p>

<p><a href="Category:Control_flow" title="wikilink">Category:Control flow</a> <a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a> <a class="uri" href="Category:Parsing" title="wikilink">Category:Parsing</a> <a class="uri" href="Category:Recursion" title="wikilink">Category:Recursion</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">[<a class="uri" href="http://www.cs.may.ie/~jpower/Courses/parsing/parsing.pdf#search">http://www.cs.may.ie/~jpower/Courses/parsing/parsing.pdf#search</a>='indirect%20left%20recursion' Notes on Formal Language Theory and Parsing], James Power, Department of Computer Science National University of Ireland, Maynooth Maynooth, Co. Kildare, Ireland.<a class="uri" href="JPR02" title="wikilink">JPR02</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">, available from the author at <a class="uri" href="http://hafiz.myweb.cs.uwindsor.ca/pub/p46-frost.pdf">http://hafiz.myweb.cs.uwindsor.ca/pub/p46-frost.pdf</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
