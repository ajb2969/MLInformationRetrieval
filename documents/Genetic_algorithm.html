<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1220">Genetic algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Genetic algorithm</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>The 2006 NASA <a href="Space_Technology_5" title="wikilink">ST5</a> spacecraft antenna. This complicated shape was found by an evolutionary computer design program to create the best radiation pattern. It is known as an <a href="Evolved_antenna" title="wikilink">Evolved antenna</a>.</figcaption>
</figure>

<p>In the field of <a href="artificial_intelligence" title="wikilink">artificial intelligence</a>, a <strong>genetic algorithm (GA)</strong> is a <a href="Search_algorithm" title="wikilink">search</a> <a href="Heuristic_(computer_science)" title="wikilink">heuristic</a> that mimics the process of <a href="natural_selection" title="wikilink">natural selection</a>. This heuristic (also sometimes called a <a class="uri" href="metaheuristic" title="wikilink">metaheuristic</a>) is routinely used to generate useful solutions to <a href="Optimization_(mathematics)" title="wikilink">optimization</a> and <a href="Search_algorithm" title="wikilink">search problems</a>. Genetic algorithms belong to the larger class of <a href="evolutionary_algorithm" title="wikilink">evolutionary algorithms</a> (EA), which generate solutions to optimization problems using techniques inspired by natural evolution, such as <a href="Heredity" title="wikilink">inheritance</a>, <a href="Mutation_(genetic_algorithm)" title="wikilink">mutation</a>, <a href="selection_(genetic_algorithm)" title="wikilink">selection</a>, and <a href="crossover_(genetic_algorithm)" title="wikilink">crossover</a>.</p>

<p>In <a href="computer_science" title="wikilink">computer science</a>, <a class="uri" href="engineering" title="wikilink">engineering</a>, <a href="computational_physics" title="wikilink">computational physics,</a> <a href="molecular_chemistry" title="wikilink">molecular chemistry</a>, <a class="uri" href="statistics" title="wikilink">statistics</a> and <a href="applied_probability" title="wikilink">applied probability</a>, genetic algorithms are a class of interacting and nonlinear <a href="Monte_Carlo_method" title="wikilink">Monte Carlo methods</a> to sample from complex high-dimensional probability distributions and to estimate their normalizing constants. Genetic particle algorithms approximate the target probability distributions by a large cloud of random samples termed particles or individuals. During the mutation transition, the particles evolve randomly around the space independently and to each particle is associated a fitness weight function. During the selection transitions, such an algorithm duplicates particles with high fitness at the expense of particles with low fitness which die. These genetic type particle samplers belong to the class of <a href="mean_field_particle_methods" title="wikilink">mean field particle methods</a>.</p>

<p>In signal processing and Bayesian inference genetic algorithms allow to solve the nonlinear <a href="Filtering_problem_(stochastic_processes)" title="wikilink">filtering problem</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> These algorithms are called <a href="particle_filter" title="wikilink">particle filters</a> or <a href="sequential_Monte_Carlo_method" title="wikilink">sequential Monte Carlo methods</a>. In <a href="computational_physics" title="wikilink">computational physics</a> and molecular simulation, genetic algorithms are also used to compute Feynman-Kac path integrals as the number of individuals tends to infinity.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> These mutation-selection type algorithms are often called Resample or Reconfiguration Monte Carlo. They belong to the class of <a href="Quantum_Monte_Carlo" title="wikilink">Quantum Monte Carlo methods</a> and more specifically <a href="Diffusion_Monte_Carlo" title="wikilink">Diffusion Monte Carlo</a> methodologies.</p>

<p>Genetic algorithms find application in <a class="uri" href="bioinformatics" title="wikilink">bioinformatics</a>, <a class="uri" href="phylogenetics" title="wikilink">phylogenetics</a>, <a href="computational_science" title="wikilink">computational science</a>, <a href="Signal_processing" title="wikilink">signal and image processing,</a> <a href="Bayesian_inference" title="wikilink">Bayesian inference</a>, <a href="machine_learning" title="wikilink">machine learning</a>, <a href="Rare_Event_Sampling" title="wikilink">risk analysis and rare event sampling,</a> <a class="uri" href="Engineering" title="wikilink">Engineering</a> <a href="Robotics" title="wikilink">and robotics</a>, <a class="uri" href="economics" title="wikilink">economics</a>, <a class="uri" href="manufacturing" title="wikilink">manufacturing</a>, <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <a href="mathematical_finance" title="wikilink">mathematical finance</a>, <a href="molecular_chemistry" title="wikilink">molecular chemistry</a>, <a href="computational_physics" title="wikilink">computational physics</a>, <a href="Pharmacokinetics" title="wikilink">pharmacokinetic</a>, <a class="uri" href="pharmacometrics" title="wikilink">pharmacometrics</a>, and other fields.</p>
<h2 id="methodology">Methodology</h2>
<h3 id="optimization-problems">Optimization problems</h3>

<p>In a genetic algorithm, a <a class="uri" href="population" title="wikilink">population</a> of <a href="candidate_solution" title="wikilink">candidate solutions</a> (called individuals, creatures, or <a href="phenotype" title="wikilink">phenotypes</a>) to an optimization problem is evolved toward better solutions. Each candidate solution has a set of properties (its <a href="chromosome" title="wikilink">chromosomes</a> or <a class="uri" href="genotype" title="wikilink">genotype</a>) which can be mutated and altered; traditionally, solutions are represented in binary as strings of 0s and 1s, but other encodings are also possible.</p>

<p>The evolution usually starts from a population of randomly generated individuals, and is an <a href="Iteration" title="wikilink">iterative process</a>, with the population in each iteration called a <em>generation</em>. In each generation, the <a href="fitness_(biology)" title="wikilink">fitness</a> of every individual in the population is evaluated; the fitness is usually the value of the <a href="objective_function" title="wikilink">objective function</a> in the optimization problem being solved. The more fit individuals are <a href="Stochastics" title="wikilink">stochastically</a> selected from the current population, and each individual's genome is modified (<a href="Crossover_(genetic_algorithm)" title="wikilink">recombined</a> and possibly randomly mutated) to form a new generation. The new generation of candidate solutions is then used in the next iteration of the <a class="uri" href="algorithm" title="wikilink">algorithm</a>. Commonly, the algorithm terminates when either a maximum number of generations has been produced, or a satisfactory fitness level has been reached for the population.</p>

<p>A typical genetic algorithm requires:</p>
<ol>
<li>a <a href="genetic_representation" title="wikilink">genetic representation</a> of the solution domain,</li>
<li>a <a href="fitness_function" title="wikilink">fitness function</a> to evaluate the solution domain.</li>
</ol>

<p>A standard representation of each candidate solution is as an <a href="bit_array" title="wikilink">array of bits</a>. Arrays of other types and structures can be used in essentially the same way. The main property that makes these genetic representations convenient is that their parts are easily aligned due to their fixed size, which facilitates simple <a href="Crossover_(genetic_algorithm)" title="wikilink">crossover</a> operations. Variable length representations may also be used, but crossover implementation is more complex in this case. Tree-like representations are explored in <a href="genetic_programming" title="wikilink">genetic programming</a> and graph-form representations are explored in <a href="evolutionary_programming" title="wikilink">evolutionary programming</a>; a mix of both linear chromosomes and trees is explored in <a href="gene_expression_programming" title="wikilink">gene expression programming</a>.</p>

<p>Once the genetic representation and the fitness function are defined, a GA proceeds to initialize a population of solutions and then to improve it through repetitive application of the mutation, crossover, inversion and selection operators.</p>
<h4 id="initialization">Initialization</h4>

<p>The population size depends on the nature of the problem, but typically contains several hundreds or thousands of possible solutions. Often, the initial population is generated randomly, allowing the entire range of possible solutions (the <em>search space</em>). Occasionally, the solutions may be "seeded" in areas where optimal solutions are likely to be found.</p>
<h4 id="selection">Selection</h4>

<p>During each successive generation, a proportion of the existing population is <a href="selection_(genetic_algorithm)" title="wikilink">selected</a> to breed a new generation. Individual solutions are selected through a <em>fitness-based</em> process, where <a href="Fitness_(biology)" title="wikilink">fitter</a> solutions (as measured by a <a href="fitness_function" title="wikilink">fitness function</a>) are typically more likely to be selected. Certain selection methods rate the fitness of each solution and preferentially select the best solutions. Other methods rate only a random sample of the population, as the former process may be very time-consuming.</p>

<p>The fitness function is defined over the genetic representation and measures the <em>quality</em> of the represented solution. The fitness function is always problem dependent. For instance, in the <a href="knapsack_problem" title="wikilink">knapsack problem</a> one wants to maximize the total value of objects that can be put in a knapsack of some fixed capacity. A representation of a solution might be an array of bits, where each bit represents a different object, and the value of the bit (0 or 1) represents whether or not the object is in the knapsack. Not every such representation is valid, as the size of objects may exceed the capacity of the knapsack. The <em>fitness</em> of the solution is the sum of values of all objects in the knapsack if the representation is valid, or 0 otherwise.</p>

<p>In some problems, it is hard or even impossible to define the fitness expression; in these cases, a <a href="Computer_simulation" title="wikilink">simulation</a> may be used to determine the fitness function value of a phenotype (e.g. <a href="computational_fluid_dynamics" title="wikilink">computational fluid dynamics</a> is used to determine the air resistance of a vehicle whose shape is encoded as the phenotype), or even <a href="Interactive_evolutionary_computation" title="wikilink">interactive genetic algorithms</a> are used.</p>
<h4 id="genetic-operators">Genetic operators</h4>

<p>The next step is to generate a second generation population of solutions from those selected through a combination of <a href="genetic_operator" title="wikilink">genetic operators</a>: <a href="crossover_(genetic_algorithm)" title="wikilink">crossover</a> (also called recombination), and <a href="mutation_(genetic_algorithm)" title="wikilink">mutation</a>.</p>

<p>For each new solution to be produced, a pair of "parent" solutions is selected for breeding from the pool selected previously. By producing a "child" solution using the above methods of crossover and mutation, a new solution is created which typically shares many of the characteristics of its "parents". New parents are selected for each new child, and the process continues until a new population of solutions of appropriate size is generated. Although reproduction methods that are based on the use of two parents are more "biology inspired", some research<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> suggests that more than two "parents" generate higher quality chromosomes.</p>

<p>These processes ultimately result in the next generation population of chromosomes that is different from the initial generation. Generally the average fitness will have increased by this procedure for the population, since only the best organisms from the first generation are selected for breeding, along with a small proportion of less fit solutions. These less fit solutions ensure genetic diversity within the genetic pool of the parents and therefore ensure the genetic diversity of the subsequent generation of children.</p>

<p>Opinion is divided over the importance of crossover versus mutation. There are many references in <a href="David_B._Fogel" title="wikilink">Fogel</a> (2006) that support the importance of mutation-based search.</p>

<p>Although crossover and mutation are known as the main genetic operators, it is possible to use other operators such as regrouping, colonization-extinction, or migration in genetic algorithms.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>It is worth tuning parameters such as the <a href="Mutation_(genetic_algorithm)" title="wikilink">mutation</a> probability, <a href="Crossover_(genetic_algorithm)" title="wikilink">crossover</a> probability and population size to find reasonable settings for the problem class being worked on. A very small mutation rate may lead to <a href="genetic_drift" title="wikilink">genetic drift</a> (which is non-<a href="Ergodicity" title="wikilink">ergodic</a> in nature). A recombination rate that is too high may lead to premature convergence of the genetic algorithm. A mutation rate that is too high may lead to loss of good solutions, unless <a href="#Elitism" title="wikilink">elitist selection</a> is employed.</p>
<h4 id="termination">Termination</h4>

<p>This generational process is repeated until a termination condition has been reached. Common terminating conditions are:</p>
<ul>
<li>A solution is found that satisfies minimum criteria</li>
<li>Fixed number of generations reached</li>
<li>Allocated budget (computation time/money) reached</li>
<li>The highest ranking solution's fitness is reaching or has reached a plateau such that successive iterations no longer produce better results</li>
<li>Manual inspection</li>
<li>Combinations of the above</li>
</ul>
<h3 id="monte-carlo-integration"><a href="Monte_Carlo_integration" title="wikilink">Monte Carlo integration</a></h3>
<h4 id="a-mutation-selection-sampler">A mutation-selection sampler</h4>

<p>Simple genetic algorithms with mutation-selection transitions can also be used as to solve complex path integration problems. Suppose we are given some <a href="Markov_process" title="wikilink">Markov process</a> 

<math display="inline" id="Genetic_algorithm:0">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{n}
  </annotation>
 </semantics>
</math>

 evolving in some solution space 

<math display="inline" id="Genetic_algorithm:1">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 at every time step 

<math display="inline" id="Genetic_algorithm:2">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>∈</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>n</ci>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\in\mathbb{N}
  </annotation>
 </semantics>
</math>

.</p>

<p>We let 

<math display="inline" id="Genetic_algorithm:3">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <msub>
     <mi>G</mi>
     <mi>n</mi>
    </msub>
   </mpadded>
   <mo rspace="5.8pt">:</mo>
   <mrow>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>S</mi>
    <mo>↦</mo>
    <mrow>
     <msub>
      <mi>G</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mi mathvariant="normal">∞</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <in></in>
      <ci>x</ci>
      <ci>S</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>G</ci>
        <ci>n</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <interval closure="closed">
       <cn type="integer">0</cn>
       <infinity></infinity>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{n}~{}:~{}x\in S\mapsto G_{n}(x)\in\mathbb{[}0,\infty]
  </annotation>
 </semantics>
</math>

 be some bounded fitness functions on the solution space 

<math display="inline" id="Genetic_algorithm:4">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

.</p>

<p>We consider a population of 

<math display="inline" id="Genetic_algorithm:5">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 individuals starting with 

<math display="inline" id="Genetic_algorithm:6">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 independent copies 

<math display="inline" id="Genetic_algorithm:7">
 <semantics>
  <msub>
   <mrow>
    <mo>(</mo>
    <msubsup>
     <mi>ξ</mi>
     <mn>0</mn>
     <mi>i</mi>
    </msubsup>
    <mo>)</mo>
   </mrow>
   <mrow>
    <mn>1</mn>
    <mo>≤</mo>
    <mi>i</mi>
    <mo>≤</mo>
    <mi>N</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ξ</ci>
      <ci>i</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <and></and>
     <apply>
      <leq></leq>
      <cn type="integer">1</cn>
      <ci>i</ci>
     </apply>
     <apply>
      <leq></leq>
      <share href="#.cmml">
      </share>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\xi^{i}_{0}\right)_{1\leq i\leq N}
  </annotation>
 </semantics>
</math>

 of the random variable 

<math display="inline" id="Genetic_algorithm:8">
 <semantics>
  <msub>
   <mi>X</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{0}
  </annotation>
 </semantics>
</math>

 . The genetic algorithm is defined the selection-mutation transitions given by the synthetic diagram</p>

<p>

<math display="inline" id="Genetic_algorithm:9">
 <semantics>
  <mrow>
   <msub>
    <mi>ξ</mi>
    <mi>n</mi>
   </msub>
   <mo>:=</mo>
   <msub>
    <mrow>
     <mo>(</mo>
     <msubsup>
      <mi>ξ</mi>
      <mi>n</mi>
      <mi>i</mi>
     </msubsup>
     <mo>)</mo>
    </mrow>
    <mrow>
     <mn>1</mn>
     <mo>≤</mo>
     <mi>i</mi>
     <mo>≤</mo>
     <mi>N</mi>
    </mrow>
   </msub>
   <mo>∈</mo>
   <msup>
    <mi>S</mi>
    <mi>N</mi>
   </msup>
   <mpadded width="+3.3pt">
    <mover>
     <mrow>
      <mo movablelimits="false" rspace="0pt">-</mo>
      <mo movablelimits="false" rspace="0pt">-</mo>
      <mo movablelimits="false" rspace="0pt">-</mo>
      <mo movablelimits="false" rspace="0pt">-</mo>
      <mo movablelimits="false" rspace="0pt">-</mo>
      <mo movablelimits="false" rspace="0pt">-</mo>
      <mo movablelimits="false" rspace="0pt">-</mo>
      <mo movablelimits="false" rspace="0pt">-</mo>
      <mo movablelimits="false" rspace="0pt">-</mo>
      <mo movablelimits="false" rspace="0pt">-</mo>
      <mo movablelimits="false">⟶</mo>
     </mrow>
     <mtext>selection</mtext>
    </mover>
   </mpadded>
   <msub>
    <mover accent="true">
     <mi>ξ</mi>
     <mo>^</mo>
    </mover>
    <mi>n</mi>
   </msub>
   <mo>:=</mo>
   <msub>
    <mrow>
     <mo>(</mo>
     <msubsup>
      <mover accent="true">
       <mi>ξ</mi>
       <mo>^</mo>
      </mover>
      <mi>n</mi>
      <mi>i</mi>
     </msubsup>
     <mo>)</mo>
    </mrow>
    <mrow>
     <mn>1</mn>
     <mo>≤</mo>
     <mi>i</mi>
     <mo>≤</mo>
     <mi>N</mi>
    </mrow>
   </msub>
   <mo>∈</mo>
   <msup>
    <mi>S</mi>
    <mi>N</mi>
   </msup>
   <mpadded width="+3.3pt">
    <mover>
     <mrow>
      <mo movablelimits="false" rspace="0pt">-</mo>
      <mo movablelimits="false" rspace="0pt">-</mo>
      <mo movablelimits="false" rspace="0pt">-</mo>
      <mo movablelimits="false" rspace="0pt">-</mo>
      <mo movablelimits="false" rspace="0pt">-</mo>
      <mo movablelimits="false" rspace="0pt">-</mo>
      <mo movablelimits="false" rspace="0pt">-</mo>
      <mo movablelimits="false" rspace="0pt">-</mo>
      <mo movablelimits="false" rspace="0pt">-</mo>
      <mo movablelimits="false" rspace="0pt">-</mo>
      <mo movablelimits="false">⟶</mo>
     </mrow>
     <mtext>mutation</mtext>
    </mover>
   </mpadded>
   <msub>
    <mi>ξ</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>:=</mo>
   <msub>
    <mrow>
     <mo>(</mo>
     <msubsup>
      <mi>ξ</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mi>i</mi>
     </msubsup>
     <mo>)</mo>
    </mrow>
    <mrow>
     <mn>1</mn>
     <mo>≤</mo>
     <mi>i</mi>
     <mo>≤</mo>
     <mi>N</mi>
    </mrow>
   </msub>
   <mo>∈</mo>
   <msup>
    <mi>S</mi>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ξ</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ξ</ci>
        <ci>i</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <and></and>
       <apply>
        <leq></leq>
        <cn type="integer">1</cn>
        <ci>i</ci>
       </apply>
       <apply>
        <leq></leq>
        <share href="#.cmml">
        </share>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <list>
       <minus></minus>
       <minus></minus>
       <minus></minus>
       <minus></minus>
       <minus></minus>
       <minus></minus>
       <minus></minus>
       <minus></minus>
       <minus></minus>
       <minus></minus>
       <ci>normal-⟶</ci>
      </list>
      <mtext>selection</mtext>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>ξ</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>ξ</ci>
        </apply>
        <ci>i</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <and></and>
       <apply>
        <leq></leq>
        <cn type="integer">1</cn>
        <ci>i</ci>
       </apply>
       <apply>
        <leq></leq>
        <share href="#.cmml">
        </share>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <list>
       <minus></minus>
       <minus></minus>
       <minus></minus>
       <minus></minus>
       <minus></minus>
       <minus></minus>
       <minus></minus>
       <minus></minus>
       <minus></minus>
       <minus></minus>
       <ci>normal-⟶</ci>
      </list>
      <mtext>mutation</mtext>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ξ</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ξ</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <and></and>
       <apply>
        <leq></leq>
        <cn type="integer">1</cn>
        <ci>i</ci>
       </apply>
       <apply>
        <leq></leq>
        <share href="#.cmml">
        </share>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{n}:=\left(\xi^{i}_{n}\right)_{1\leq i\leq N}\in S^{N}\stackrel{\mbox{%
selection}}{-\!\!\!\!-\!\!\!\!-\!\!\!\!-\!\!\!\!-\!\!\!\!-\!\!\!\!-\!\!\!\!-\!%
\!\!\!-\!\!\!\!-\!\!\!\!\longrightarrow}~{}\widehat{\xi}_{n}:=\left(\widehat{%
\xi}^{i}_{n}\right)_{1\leq i\leq N}\in S^{N}\stackrel{\mbox{mutation}}{-\!\!\!%
\!-\!\!\!\!-\!\!\!\!-\!\!\!\!-\!\!\!\!-\!\!\!\!-\!\!\!\!-\!\!\!\!-\!\!\!\!-\!%
\!\!\!\longrightarrow}~{}\xi_{n+1}:=\left(\xi^{i}_{n+1}\right)_{1\leq i\leq N}%
\in S^{N}
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li><strong><u>During the selection transition</u></strong> we sample N (conditionally) independent random variables 

<math display="inline" id="Genetic_algorithm:10">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>ξ</mi>
     <mo>^</mo>
    </mover>
    <mi>n</mi>
   </msub>
   <mo>:=</mo>
   <msub>
    <mrow>
     <mo>(</mo>
     <msubsup>
      <mover accent="true">
       <mi>ξ</mi>
       <mo>^</mo>
      </mover>
      <mi>n</mi>
      <mi>i</mi>
     </msubsup>
     <mo>)</mo>
    </mrow>
    <mrow>
     <mn>1</mn>
     <mo>≤</mo>
     <mi>i</mi>
     <mo>≤</mo>
     <mi>N</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>ξ</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>ξ</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <and></and>
      <apply>
       <leq></leq>
       <cn type="integer">1</cn>
       <ci>i</ci>
      </apply>
      <apply>
       <leq></leq>
       <share href="#.cmml">
       </share>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\xi}_{n}:=\left(\widehat{\xi}^{i}_{n}\right)_{1\leq i\leq N}
  </annotation>
 </semantics>
</math>

 with common (conditional) distribution 

<math display="inline" id="Genetic_algorithm:11">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>r</mi>
   <mi>o</mi>
   <mi>b</mi>
   <mi>a</mi>
   <mrow>
    <mo>(</mo>
    <msubsup>
     <mover accent="true">
      <mi>ξ</mi>
      <mo>^</mo>
     </mover>
     <mi>n</mi>
     <mi>i</mi>
    </msubsup>
    <mo>=</mo>
    <mpadded width="+3.3pt">
     <msubsup>
      <mi>ξ</mi>
      <mi>n</mi>
      <mi>j</mi>
     </msubsup>
    </mpadded>
    <mo rspace="5.8pt" stretchy="false">|</mo>
    <msub>
     <mi>ξ</mi>
     <mi>n</mi>
    </msub>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>G</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msubsup>
       <mi>ξ</mi>
       <mi>n</mi>
       <mi>j</mi>
      </msubsup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mstyle displaystyle="false">
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mn>1</mn>
        <mo>≤</mo>
        <mi>k</mi>
        <mo>≤</mo>
        <mi>N</mi>
       </mrow>
      </msub>
     </mstyle>
     <mrow>
      <msub>
       <mi>G</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msubsup>
        <mi>ξ</mi>
        <mi>n</mi>
        <mi>k</mi>
       </msubsup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
   <mo rspace="5.8pt">,</mo>
   <mpadded width="+3.3pt">
    <mtext>for each</mtext>
   </mpadded>
   <mi>j</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>N</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <csymbol cd="unknown">o</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>ξ</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ξ</ci>
       <ci>j</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ξ</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>G</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ξ</ci>
        <ci>j</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <and></and>
        <apply>
         <leq></leq>
         <cn type="integer">1</cn>
         <ci>k</ci>
        </apply>
        <apply>
         <leq></leq>
         <share href="#.cmml">
         </share>
         <ci>N</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>G</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ξ</ci>
         <ci>k</ci>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <ci>normal-,</ci>
    <mtext>for each</mtext>
    <csymbol cd="unknown">j</csymbol>
    <in></in>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Proba\left(\widehat{\xi}^{i}_{n}=\xi^{j}_{n}~{}|~{}\xi_{n}\right)=\frac{G_{n}(%
\xi^{j}_{n})}{\sum_{1\leq k\leq N}G_{n}(\xi^{k}_{n})},~{}\mbox{for each}~{}j%
\in\{1,\ldots,N\}
  </annotation>
 </semantics>
</math>

In other words, if 

<math display="inline" id="Genetic_algorithm:12">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>ξ</mi>
     <mi>n</mi>
     <mi>j</mi>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ξ</ci>
      <ci>j</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{n}(\xi^{j}_{n})
  </annotation>
 </semantics>
</math>

 is the fitness of the 

<math display="inline" id="Genetic_algorithm:13">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 -th individual 

<math display="inline" id="Genetic_algorithm:14">
 <semantics>
  <msubsup>
   <mi>ξ</mi>
   <mi>n</mi>
   <mi>j</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ξ</ci>
     <ci>j</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi^{j}_{n}
  </annotation>
 </semantics>
</math>

 in the population 

<math display="inline" id="Genetic_algorithm:15">
 <semantics>
  <msub>
   <mi>ξ</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ξ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{n}
  </annotation>
 </semantics>
</math>

, its probability of being selected in the next generation 

<math display="inline" id="Genetic_algorithm:16">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>ξ</mi>
    <mo>^</mo>
   </mover>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>ξ</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\xi}_{n}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Genetic_algorithm:17">
 <semantics>
  <mfrac>
   <mrow>
    <msub>
     <mi>G</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>ξ</mi>
      <mi>n</mi>
      <mi>j</mi>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mrow>
    <mstyle displaystyle="false">
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mn>1</mn>
       <mo>≤</mo>
       <mi>k</mi>
       <mo>≤</mo>
       <mi>N</mi>
      </mrow>
     </msub>
    </mstyle>
    <mrow>
     <msub>
      <mi>G</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msubsup>
       <mi>ξ</mi>
       <mi>n</mi>
       <mi>k</mi>
      </msubsup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ξ</ci>
       <ci>j</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <and></and>
       <apply>
        <leq></leq>
        <cn type="integer">1</cn>
        <ci>k</ci>
       </apply>
       <apply>
        <leq></leq>
        <share href="#.cmml">
        </share>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>G</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ξ</ci>
        <ci>k</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{G_{n}(\xi^{j}_{n})}{\sum_{1\leq k\leq N}G_{n}(\xi^{k}_{n})}
  </annotation>
 </semantics>
</math>

. This selection transition is also called the <a href="Fitness_proportionate_selection" title="wikilink">fitness-proportionate selection</a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a href="Fitness_proportionate_selection" title="wikilink">,</a> or the roulette-wheel selection.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> For 

<math display="inline" id="Genetic_algorithm:18">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0,1]
  </annotation>
 </semantics>
</math>

-valued fitness functions 

<math display="inline" id="Genetic_algorithm:19">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{n}
  </annotation>
 </semantics>
</math>

 an alternative acceptance-rejection type selection transition can be underlined: For each 

<math display="inline" id="Genetic_algorithm:20">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>i</mi>
   <mo>≤</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq i\leq N
  </annotation>
 </semantics>
</math>

, with a probability 

<math display="inline" id="Genetic_algorithm:21">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>ξ</mi>
     <mi>n</mi>
     <mi>i</mi>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ξ</ci>
      <ci>i</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{n}(\xi^{i}_{n})
  </annotation>
 </semantics>
</math>

 we accept the individual 

<math display="inline" id="Genetic_algorithm:22">
 <semantics>
  <msubsup>
   <mi>ξ</mi>
   <mi>n</mi>
   <mi>i</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ξ</ci>
     <ci>i</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi^{i}_{n}
  </annotation>
 </semantics>
</math>

 ; that is, we set 

<math display="inline" id="Genetic_algorithm:23">
 <semantics>
  <mrow>
   <msubsup>
    <mover accent="true">
     <mi>ξ</mi>
     <mo>^</mo>
    </mover>
    <mi>n</mi>
    <mi>i</mi>
   </msubsup>
   <mo>=</mo>
   <msubsup>
    <mi>ξ</mi>
    <mi>n</mi>
    <mi>i</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>ξ</ci>
      </apply>
      <ci>i</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ξ</ci>
      <ci>i</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\xi}^{i}_{n}=\xi^{i}_{n}
  </annotation>
 </semantics>
</math>

. Otherwise, we sample a new indidual 

<math display="inline" id="Genetic_algorithm:24">
 <semantics>
  <msubsup>
   <mover accent="true">
    <mi>ξ</mi>
    <mo>~</mo>
   </mover>
   <mi>n</mi>
   <mi>i</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>ξ</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widetilde{\xi}^{i}_{n}
  </annotation>
 </semantics>
</math>

 in the current population with the probability measure</li>
</ul>

<p>

<math display="inline" id="Genetic_algorithm:25">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>r</mi>
   <mi>o</mi>
   <mi>b</mi>
   <mi>a</mi>
   <mrow>
    <mo>(</mo>
    <msubsup>
     <mover accent="true">
      <mi>ξ</mi>
      <mo>~</mo>
     </mover>
     <mi>n</mi>
     <mi>i</mi>
    </msubsup>
    <mo>=</mo>
    <mpadded width="+3.3pt">
     <msubsup>
      <mi>ξ</mi>
      <mi>n</mi>
      <mi>j</mi>
     </msubsup>
    </mpadded>
    <mo rspace="5.8pt" stretchy="false">|</mo>
    <msub>
     <mi>ξ</mi>
     <mi>n</mi>
    </msub>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>G</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msubsup>
       <mi>ξ</mi>
       <mi>n</mi>
       <mi>j</mi>
      </msubsup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mstyle displaystyle="false">
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mn>1</mn>
        <mo>≤</mo>
        <mi>k</mi>
        <mo>≤</mo>
        <mi>N</mi>
       </mrow>
      </msub>
     </mstyle>
     <mrow>
      <msub>
       <mi>G</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msubsup>
        <mi>ξ</mi>
        <mi>n</mi>
        <mi>k</mi>
       </msubsup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
   <mo rspace="5.8pt">,</mo>
   <mpadded width="+3.3pt">
    <mtext>for each</mtext>
   </mpadded>
   <mi>j</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>N</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <csymbol cd="unknown">o</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>ξ</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ξ</ci>
       <ci>j</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ξ</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>G</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ξ</ci>
        <ci>j</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <and></and>
        <apply>
         <leq></leq>
         <cn type="integer">1</cn>
         <ci>k</ci>
        </apply>
        <apply>
         <leq></leq>
         <share href="#.cmml">
         </share>
         <ci>N</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>G</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ξ</ci>
         <ci>k</ci>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <ci>normal-,</ci>
    <mtext>for each</mtext>
    <csymbol cd="unknown">j</csymbol>
    <in></in>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Proba\left(\widetilde{\xi}^{i}_{n}=\xi^{j}_{n}~{}|~{}\xi_{n}\right)=\frac{G_{n%
}(\xi^{j}_{n})}{\sum_{1\leq k\leq N}G_{n}(\xi^{k}_{n})},~{}\mbox{for each}~{}j%
\in\{1,\ldots,N\}
  </annotation>
 </semantics>
</math>

and we set 

<math display="inline" id="Genetic_algorithm:26">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mover accent="true">
      <mi>ξ</mi>
      <mo>^</mo>
     </mover>
     <mi>n</mi>
     <mi>i</mi>
    </msubsup>
    <mo>=</mo>
    <msubsup>
     <mover accent="true">
      <mi>ξ</mi>
      <mo>~</mo>
     </mover>
     <mi>n</mi>
     <mi>i</mi>
    </msubsup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>ξ</ci>
      </apply>
      <ci>i</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-~</ci>
       <ci>ξ</ci>
      </apply>
      <ci>i</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\xi}^{i}_{n}=\widetilde{\xi}^{i}_{n}.
  </annotation>
 </semantics>
</math>

 This selection scheme can be interpreted as an acceptance-rejection sampler equipped with a recycling mechanism.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<ul>
<li><strong><u>During the mutation transition</u>,</strong> from each selected particle 

<math display="inline" id="Genetic_algorithm:27">
 <semantics>
  <msubsup>
   <mover accent="true">
    <mi>ξ</mi>
    <mo>^</mo>
   </mover>
   <mi>n</mi>
   <mi>i</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>ξ</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\xi}^{i}_{n}
  </annotation>
 </semantics>
</math>

 we sample independently a transition 

<math display="inline" id="Genetic_algorithm:28">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <msubsup>
     <mover accent="true">
      <mi>ξ</mi>
      <mo>^</mo>
     </mover>
     <mi>n</mi>
     <mi>i</mi>
    </msubsup>
   </mpadded>
   <mo>⟶</mo>
   <msubsup>
    <mi>ξ</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mi>i</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⟶</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>ξ</ci>
      </apply>
      <ci>i</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ξ</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\xi}^{i}_{n}~{}\longrightarrow\xi^{i}_{n+1}
  </annotation>
 </semantics>
</math>

 of the Markov chain 

<math display="inline" id="Genetic_algorithm:29">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
   </mpadded>
   <mo rspace="5.8pt">→</mo>
   <msub>
    <mi>X</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{n}~{}\rightarrow~{}X_{n+1}
  </annotation>
 </semantics>
</math>

 starting at 

<math display="inline" id="Genetic_algorithm:30">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <msubsup>
    <mover accent="true">
     <mi>ξ</mi>
     <mo>^</mo>
    </mover>
    <mi>n</mi>
    <mi>i</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>ξ</ci>
      </apply>
      <ci>i</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{n}=\widehat{\xi}^{i}_{n}
  </annotation>
 </semantics>
</math>

, for 

<math display="inline" id="Genetic_algorithm:31">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>N</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>i</ci>
    <set>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>N</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\in\{1,\ldots,N\}
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<h4 id="convergence-results">Convergence results</h4>

<p>When the number of individuals (and the computational power) 

<math display="inline" id="Genetic_algorithm:32">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>↑</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↑</ci>
    <ci>N</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\uparrow\infty
  </annotation>
 </semantics>
</math>

, for any function 

<math display="inline" id="Genetic_algorithm:33">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <mi>f</mi>
   </mpadded>
   <mo rspace="5.8pt">:</mo>
   <mrow>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>S</mi>
    <mo>↦</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <and></and>
     <apply>
      <in></in>
      <ci>x</ci>
      <ci>S</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <ci>ℝ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f~{}:~{}x\in S\mapsto f(x)\in\mathbb{R}
  </annotation>
 </semantics>
</math>

, we have</p>

<p>

<math display="inline" id="Genetic_algorithm:34">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>N</mi>
     </mfrac>
     <mrow>
      <mpadded width="+3.3pt">
       <msub>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mn>1</mn>
         <mo>≤</mo>
         <mi>i</mi>
         <mo>≤</mo>
         <mi>N</mi>
        </mrow>
       </msub>
      </mpadded>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo>(</mo>
        <msubsup>
         <mi>ξ</mi>
         <mi>n</mi>
         <mi>i</mi>
        </msubsup>
        <mo rspace="5.8pt">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mpadded width="+3.3pt">
     <msub>
      <mo>≈</mo>
      <mrow>
       <mi>N</mi>
       <mo>↑</mo>
       <mi></mi>
      </mrow>
     </msub>
    </mpadded>
    <mrow>
     <mfrac>
      <mrow>
       <mi>E</mi>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>X</mi>
           <mi>n</mi>
          </msub>
          <mo rspace="5.8pt" stretchy="false">)</mo>
         </mrow>
         <mrow>
          <mstyle displaystyle="false">
           <msub>
            <mo largeop="true" symmetric="true">∏</mo>
            <mrow>
             <mn>0</mn>
             <mo>≤</mo>
             <mi>k</mi>
             <mo><</mo>
             <mi>n</mi>
            </mrow>
           </msub>
          </mstyle>
          <mrow>
           <msub>
            <mi>G</mi>
            <mi>k</mi>
           </msub>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>X</mi>
             <mi>k</mi>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi>E</mi>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mstyle displaystyle="false">
          <msub>
           <mo largeop="true" symmetric="true">∏</mo>
           <mrow>
            <mn>0</mn>
            <mo>≤</mo>
            <mi>k</mi>
            <mo><</mo>
            <mi>n</mi>
           </mrow>
          </msub>
         </mstyle>
         <mrow>
          <msub>
           <mi>G</mi>
           <mi>k</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>X</mi>
            <mi>k</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mfrac>
     <mtext>and</mtext>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>N</mi>
     </mfrac>
     <mrow>
      <mpadded width="+3.3pt">
       <msub>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mn>1</mn>
         <mo>≤</mo>
         <mi>i</mi>
         <mo>≤</mo>
         <mi>N</mi>
        </mrow>
       </msub>
      </mpadded>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo>(</mo>
        <msubsup>
         <mover accent="true">
          <mi>ξ</mi>
          <mo>^</mo>
         </mover>
         <mi>n</mi>
         <mi>i</mi>
        </msubsup>
        <mo rspace="5.8pt">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mpadded width="+3.3pt">
     <msub>
      <mo>≈</mo>
      <mrow>
       <mi>N</mi>
       <mo>↑</mo>
       <mi></mi>
      </mrow>
     </msub>
    </mpadded>
    <mfrac>
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>X</mi>
          <mi>n</mi>
         </msub>
         <mo rspace="5.8pt" stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mstyle displaystyle="false">
          <msub>
           <mo largeop="true" symmetric="true">∏</mo>
           <mrow>
            <mn>0</mn>
            <mo>≤</mo>
            <mi>k</mi>
            <mo>≤</mo>
            <mi>n</mi>
           </mrow>
          </msub>
         </mstyle>
         <mrow>
          <msub>
           <mi>G</mi>
           <mi>k</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>X</mi>
            <mi>k</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mstyle displaystyle="false">
         <msub>
          <mo largeop="true" symmetric="true">∏</mo>
          <mrow>
           <mn>0</mn>
           <mo>≤</mo>
           <mi>k</mi>
           <mo>≤</mo>
           <mi>n</mi>
          </mrow>
         </msub>
        </mstyle>
        <mrow>
         <msub>
          <mi>G</mi>
          <mi>k</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>X</mi>
           <mi>k</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <approx></approx>
      <apply>
       <ci>normal-↑</ci>
       <ci>N</ci>
       <csymbol cd="latexml">absent</csymbol>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>N</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <and></and>
         <apply>
          <leq></leq>
          <cn type="integer">1</cn>
          <ci>i</ci>
         </apply>
         <apply>
          <leq></leq>
          <share href="#.cmml">
          </share>
          <ci>N</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>ξ</ci>
          <ci>i</ci>
         </apply>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <list>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>E</ci>
        <apply>
         <times></times>
         <ci>f</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <ci>n</ci>
         </apply>
         <apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <csymbol cd="latexml">product</csymbol>
           <apply>
            <and></and>
            <apply>
             <leq></leq>
             <cn type="integer">0</cn>
             <ci>k</ci>
            </apply>
            <apply>
             <lt></lt>
             <share href="#.cmml">
             </share>
             <ci>n</ci>
            </apply>
           </apply>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>G</ci>
            <ci>k</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>X</ci>
            <ci>k</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>E</ci>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <csymbol cd="latexml">product</csymbol>
          <apply>
           <and></and>
           <apply>
            <leq></leq>
            <cn type="integer">0</cn>
            <ci>k</ci>
           </apply>
           <apply>
            <lt></lt>
            <share href="#.cmml">
            </share>
            <ci>n</ci>
           </apply>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>G</ci>
           <ci>k</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>X</ci>
           <ci>k</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <mtext>and</mtext>
     </list>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <approx></approx>
      <apply>
       <ci>normal-↑</ci>
       <ci>N</ci>
       <csymbol cd="latexml">absent</csymbol>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>N</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <and></and>
         <apply>
          <leq></leq>
          <cn type="integer">1</cn>
          <ci>i</ci>
         </apply>
         <apply>
          <leq></leq>
          <share href="#.cmml">
          </share>
          <ci>N</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <ci>normal-^</ci>
           <ci>ξ</ci>
          </apply>
          <ci>i</ci>
         </apply>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>E</ci>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <csymbol cd="latexml">product</csymbol>
          <apply>
           <and></and>
           <apply>
            <leq></leq>
            <cn type="integer">0</cn>
            <ci>k</ci>
           </apply>
           <apply>
            <leq></leq>
            <share href="#.cmml">
            </share>
            <ci>n</ci>
           </apply>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>G</ci>
           <ci>k</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>X</ci>
           <ci>k</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>E</ci>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <csymbol cd="latexml">product</csymbol>
         <apply>
          <and></and>
          <apply>
           <leq></leq>
           <cn type="integer">0</cn>
           <ci>k</ci>
          </apply>
          <apply>
           <leq></leq>
           <share href="#.cmml">
           </share>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>G</ci>
          <ci>k</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{N}\sum_{1\leq i\leq N}~{}f\left(\xi^{i}_{n}\right)~{}\approx_{N%
\uparrow}~{}\frac{E\left(f(X_{n})~{}\prod_{0\leq k<n}G_{k}(X_{k})\right)}{E%
\left(\prod_{0\leq k<n}G_{k}(X_{k})\right)}\quad\mbox{and}\quad\frac{1}{N}\sum%
_{1\leq i\leq N}~{}f\left(\widehat{\xi}^{i}_{n}\right)~{}\approx_{N\uparrow}~{%
}\frac{E\left(f(X_{n})~{}\prod_{0\leq k\leq n}G_{k}(X_{k})\right)}{E\left(%
\prod_{0\leq k\leq n}G_{k}(X_{k})\right)}
  </annotation>
 </semantics>
</math>

</p>

<p>In addition, we have the <a href="unbiased_estimate" title="wikilink">unbiased estimate</a>

<math display="inline" id="Genetic_algorithm:35">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∏</mo>
     <mrow>
      <mn>0</mn>
      <mo>≤</mo>
      <mi>k</mi>
      <mo>≤</mo>
      <mi>n</mi>
     </mrow>
    </msub>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>N</mi>
     </mfrac>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mn>1</mn>
        <mo>≤</mo>
        <mi>i</mi>
        <mo>≤</mo>
        <mi>N</mi>
       </mrow>
      </msub>
      <mrow>
       <msub>
        <mi>G</mi>
        <mi>k</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msubsup>
         <mi>ξ</mi>
         <mi>k</mi>
         <mi>i</mi>
        </msubsup>
        <mo rspace="5.8pt" stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mpadded width="+3.3pt">
    <msub>
     <mo>≈</mo>
     <mrow>
      <mi>N</mi>
      <mo>↑</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
   </mpadded>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∏</mo>
       <mrow>
        <mn>0</mn>
        <mo>≤</mo>
        <mi>k</mi>
        <mo>≤</mo>
        <mi>n</mi>
       </mrow>
      </msub>
      <mrow>
       <msub>
        <mi>G</mi>
        <mi>k</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>X</mi>
         <mi>k</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <approx></approx>
     <apply>
      <ci>normal-↑</ci>
      <ci>N</ci>
      <infinity></infinity>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <and></and>
       <apply>
        <leq></leq>
        <cn type="integer">0</cn>
        <ci>k</ci>
       </apply>
       <apply>
        <leq></leq>
        <share href="#.cmml">
        </share>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>N</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <and></and>
         <apply>
          <leq></leq>
          <cn type="integer">1</cn>
          <ci>i</ci>
         </apply>
         <apply>
          <leq></leq>
          <share href="#.cmml">
          </share>
          <ci>N</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>G</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>ξ</ci>
          <ci>i</ci>
         </apply>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <and></and>
        <apply>
         <leq></leq>
         <cn type="integer">0</cn>
         <ci>k</ci>
        </apply>
        <apply>
         <leq></leq>
         <share href="#.cmml">
         </share>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>G</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \prod_{0\leq k\leq n}\frac{1}{N}\sum_{1\leq i\leq N}G_{k}(\xi^{i}_{k})~{}%
\approx_{N\uparrow\infty}~{}E\left(\prod_{0\leq k\leq n}G_{k}(X_{k})\right)
  </annotation>
 </semantics>
</math>

In <a class="uri" href="statistics" title="wikilink">statistics</a> and <a href="probability_theory" title="wikilink">probability theory</a> the limiting expectations are called <a href="Feynman–Kac_formula" title="wikilink">Feynman-Kac</a> formulae.</p>
<h4 id="genealogical-tree-algorithm">Genealogical tree algorithm</h4>
<div>

<p>Tracing back in time <strong>the ancestral lines</strong> <strong>of each individual</strong> 

<math display="inline" id="Genetic_algorithm:36">
 <semantics>
  <msubsup>
   <mover accent="true">
    <mi>ξ</mi>
    <mo>^</mo>
   </mover>
   <mi>n</mi>
   <mi>i</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>ξ</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\xi}^{i}_{n}
  </annotation>
 </semantics>
</math>

 in the population after the n-th selection, we define the <strong>genealogical tree of the genetic population</strong> 

<math display="inline" id="Genetic_algorithm:37">
 <semantics>
  <mrow>
   <msubsup>
    <mover accent="true">
     <mi>ξ</mi>
     <mo>^</mo>
    </mover>
    <mrow>
     <mn>0</mn>
     <mo>,</mo>
     <mi>n</mi>
    </mrow>
    <mi>i</mi>
   </msubsup>
   <mo rspace="5.8pt">⟵</mo>
   <msubsup>
    <mover accent="true">
     <mi>ξ</mi>
     <mo>^</mo>
    </mover>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mi>n</mi>
    </mrow>
    <mi>i</mi>
   </msubsup>
   <mo rspace="5.8pt">⟵</mo>
   <mrow>
    <mi mathvariant="normal">…</mi>
    <msubsup>
     <mover accent="true">
      <mi>ξ</mi>
      <mo>^</mo>
     </mover>
     <mrow>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo>,</mo>
      <mi>n</mi>
     </mrow>
     <mi>i</mi>
    </msubsup>
   </mrow>
   <mo>⟵</mo>
   <msubsup>
    <mover accent="true">
     <mi>ξ</mi>
     <mo>^</mo>
    </mover>
    <mrow>
     <mi>k</mi>
     <mo>,</mo>
     <mi>n</mi>
    </mrow>
    <mi>i</mi>
   </msubsup>
   <mo>⟵</mo>
   <mrow>
    <mi mathvariant="normal">…</mi>
    <msubsup>
     <mover accent="true">
      <mi>ξ</mi>
      <mo>^</mo>
     </mover>
     <mrow>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo>,</mo>
      <mi>n</mi>
     </mrow>
     <mi>i</mi>
    </msubsup>
   </mrow>
   <mo>⟵</mo>
   <msubsup>
    <mover accent="true">
     <mi>ξ</mi>
     <mo>^</mo>
    </mover>
    <mrow>
     <mi>n</mi>
     <mo>,</mo>
     <mi>n</mi>
    </mrow>
    <mi>i</mi>
   </msubsup>
   <mo>=</mo>
   <msubsup>
    <mover accent="true">
     <mi>ξ</mi>
     <mo>^</mo>
    </mover>
    <mi>n</mi>
    <mi>i</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-⟵</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>ξ</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <list>
       <cn type="integer">0</cn>
       <ci>n</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>ξ</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <list>
       <cn type="integer">1</cn>
       <ci>n</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <ci>normal-⟵</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>ξ</ci>
        </apply>
        <ci>i</ci>
       </apply>
       <list>
        <apply>
         <minus></minus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>n</ci>
       </list>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-⟵</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>ξ</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <list>
       <ci>k</ci>
       <ci>n</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <ci>normal-⟵</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>ξ</ci>
        </apply>
        <ci>i</ci>
       </apply>
       <list>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>n</ci>
       </list>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-⟵</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>ξ</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <list>
       <ci>n</ci>
       <ci>n</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>ξ</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\xi}^{i}_{0,n}\longleftarrow~{}\widehat{\xi}^{i}_{1,n}\longleftarrow~%
{}\ldots\widehat{\xi}^{i}_{k-1,n}\longleftarrow\widehat{\xi}^{i}_{k,n}%
\longleftarrow\ldots\widehat{\xi}^{i}_{n-1,n}\longleftarrow\widehat{\xi}^{i}_{%
n,n}=\widehat{\xi}^{i}_{n}
  </annotation>
 </semantics>
</math>

The lower indices 

<math display="inline" id="Genetic_algorithm:38">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>.</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>normal-.</ci>
     <ci>normal-)</ci>
    </cerror>
    <list>
     <ci>k</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (.)_{k,n}
  </annotation>
 </semantics>
</math>

 represent the level k of the ancestor of 

<math display="inline" id="Genetic_algorithm:39">
 <semantics>
  <msubsup>
   <mover accent="true">
    <mi>ξ</mi>
    <mo>^</mo>
   </mover>
   <mi>n</mi>
   <mi>i</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>ξ</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\xi}^{i}_{n}
  </annotation>
 </semantics>
</math>

 .</p>
</div>

<p>When the number of individuals (and the computational power) 

<math display="inline" id="Genetic_algorithm:40">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>↑</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↑</ci>
    <ci>N</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\uparrow\infty
  </annotation>
 </semantics>
</math>

, for any function 

<math display="inline" id="Genetic_algorithm:41">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <msub>
     <mi>f</mi>
     <mi>n</mi>
    </msub>
   </mpadded>
   <mo rspace="5.8pt">:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <msup>
     <mi>S</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>↦</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>0</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <in></in>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </vector>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>n</ci>
       </apply>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </vector>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <ci>ℝ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{n}~{}:~{}(x_{0},\ldots,x_{n})\in S^{n+1}\mapsto f_{n}(x_{0},\ldots,x_{n})%
\in\mathbb{R}
  </annotation>
 </semantics>
</math>

 we have the Monte Carlo approximation<br/>


<math display="inline" id="Genetic_algorithm:42">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>N</mi>
    </mfrac>
    <mrow>
     <mpadded width="+3.3pt">
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mn>1</mn>
        <mo>≤</mo>
        <mi>i</mi>
        <mo>≤</mo>
        <mi>N</mi>
       </mrow>
      </msub>
     </mpadded>
     <mrow>
      <msub>
       <mi>f</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo>(</mo>
       <msubsup>
        <mover accent="true">
         <mi>ξ</mi>
         <mo>^</mo>
        </mover>
        <mrow>
         <mn>0</mn>
         <mo>,</mo>
         <mi>n</mi>
        </mrow>
        <mi>i</mi>
       </msubsup>
       <mo>,</mo>
       <msubsup>
        <mover accent="true">
         <mi>ξ</mi>
         <mo>^</mo>
        </mover>
        <mrow>
         <mn>1</mn>
         <mo>,</mo>
         <mi>n</mi>
        </mrow>
        <mi>i</mi>
       </msubsup>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msubsup>
        <mover accent="true">
         <mi>ξ</mi>
         <mo>^</mo>
        </mover>
        <mrow>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo>,</mo>
         <mi>n</mi>
        </mrow>
        <mi>i</mi>
       </msubsup>
       <mo>,</mo>
       <msubsup>
        <mover accent="true">
         <mi>ξ</mi>
         <mo>^</mo>
        </mover>
        <mrow>
         <mi>n</mi>
         <mo>,</mo>
         <mi>n</mi>
        </mrow>
        <mi>i</mi>
       </msubsup>
       <mo rspace="5.8pt">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mpadded width="+3.3pt">
    <msub>
     <mo>≈</mo>
     <mrow>
      <mi>N</mi>
      <mo>↑</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
   </mpadded>
   <mfrac>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msub>
        <mi>f</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>X</mi>
         <mn>0</mn>
        </msub>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <msub>
         <mi>X</mi>
         <mi>n</mi>
        </msub>
        <mo rspace="5.8pt" stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mstyle displaystyle="false">
         <msub>
          <mo largeop="true" symmetric="true">∏</mo>
          <mrow>
           <mn>0</mn>
           <mo>≤</mo>
           <mi>k</mi>
           <mo>≤</mo>
           <mi>n</mi>
          </mrow>
         </msub>
        </mstyle>
        <mrow>
         <msub>
          <mi>G</mi>
          <mi>k</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>X</mi>
           <mi>k</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mstyle displaystyle="false">
        <msub>
         <mo largeop="true" symmetric="true">∏</mo>
         <mrow>
          <mn>0</mn>
          <mo>≤</mo>
          <mi>k</mi>
          <mo>≤</mo>
          <mi>n</mi>
         </mrow>
        </msub>
       </mstyle>
       <mrow>
        <msub>
         <mi>G</mi>
         <mi>k</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>X</mi>
          <mi>k</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <approx></approx>
     <apply>
      <ci>normal-↑</ci>
      <ci>N</ci>
      <infinity></infinity>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <and></and>
        <apply>
         <leq></leq>
         <cn type="integer">1</cn>
         <ci>i</ci>
        </apply>
        <apply>
         <leq></leq>
         <share href="#.cmml">
         </share>
         <ci>N</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>n</ci>
       </apply>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <ci>normal-^</ci>
           <ci>ξ</ci>
          </apply>
          <ci>i</ci>
         </apply>
         <list>
          <cn type="integer">0</cn>
          <ci>n</ci>
         </list>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <ci>normal-^</ci>
           <ci>ξ</ci>
          </apply>
          <ci>i</ci>
         </apply>
         <list>
          <cn type="integer">1</cn>
          <ci>n</ci>
         </list>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <ci>normal-^</ci>
           <ci>ξ</ci>
          </apply>
          <ci>i</ci>
         </apply>
         <list>
          <apply>
           <minus></minus>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
          <ci>n</ci>
         </list>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <ci>normal-^</ci>
           <ci>ξ</ci>
          </apply>
          <ci>i</ci>
         </apply>
         <list>
          <ci>n</ci>
          <ci>n</ci>
         </list>
        </apply>
       </vector>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>n</ci>
       </apply>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>n</ci>
        </apply>
       </vector>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <csymbol cd="latexml">product</csymbol>
         <apply>
          <and></and>
          <apply>
           <leq></leq>
           <cn type="integer">0</cn>
           <ci>k</ci>
          </apply>
          <apply>
           <leq></leq>
           <share href="#.cmml">
           </share>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>G</ci>
          <ci>k</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <and></and>
         <apply>
          <leq></leq>
          <cn type="integer">0</cn>
          <ci>k</ci>
         </apply>
         <apply>
          <leq></leq>
          <share href="#.cmml">
          </share>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>G</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{N}\sum_{1\leq i\leq N}~{}f_{n}\left(\widehat{\xi}^{i}_{0,n},\widehat{%
\xi}^{i}_{1,n},\ldots,\widehat{\xi}^{i}_{n-1,n},\widehat{\xi}^{i}_{n,n}\right)%
~{}\approx_{N\uparrow\infty}~{}\frac{E\left(f_{n}(X_{0},\ldots,X_{n})~{}\prod_%
{0\leq k\leq n}G_{k}(X_{k})\right)}{E\left(\prod_{0\leq k\leq n}G_{k}(X_{k})%
\right)}
  </annotation>
 </semantics>
</math>

The mathematical foundations and the first rigorous analysis of genetic algorithms for solving Monte Carlo integration problems are due to Pierre Del Moral<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> in 1996. The theory on Feynman-Kac genetic type particle algorithms has been developed in 2000 and 2004 in the books.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h4 id="illustrations">Illustrations</h4>
<div>

<p>These Feynman-Kac path integration models arise a variety of scientific disciplines, including in computational physics, biology, information theory and computer sciences.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> Their interpretations depend on the application domain. We illustrate these path integration models with some concrete examples:</p>
<ol>
<li>If we choose the indicator function 

<math display="inline" id="Genetic_algorithm:43">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>G</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mn>1</mn>
     <mi>A</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="integer">1</cn>
      <ci>A</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{n}(x_{n})=1_{A}(x_{n})
  </annotation>
 </semantics>
</math>

 of some subset of the state space, they represent the conditional distribution of a Markov chain given it stays in a given tube; that is, we have that<math display="block">E\left(f_n(X_0,\ldots,X_n)~|~X_0\in A,~\ldots, X_n\in A\right)</math></li>
</ol>
<h1 id="displaystylefraceleftf_nx_0ldotsx_nprod_0leq-kleq-ng_kx_krighteleftprod_0leq-kleq-ng_kx_kright-quadmboxandquad-eleftprod_0leq-kleq-ng_kx_kright">\displaystyle\frac{E\left(f_n(X_0,\ldots,X_n)\prod_{0\leq k\leq n}G_k(X_k)\right)}{E\left(\prod_{0\leq k\leq n}G_k(X_k)\right)} \quad\mbox{and}\quad E\left(\prod_{0\leq k\leq n}G_k(X_k)\right)</h1>

<p>P\left(X_0\in A,~\ldots, X_n\in A\right)~ (as soon as the normalizing constant is strictly positive). In addition, we have the <a href="unbiased_estimate" title="wikilink">unbiased estimate</a>

<math display="inline" id="Genetic_algorithm:44">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∏</mo>
    <mrow>
     <mn>0</mn>
     <mo>≤</mo>
     <mi>k</mi>
     <mo>≤</mo>
     <mi>n</mi>
    </mrow>
   </msub>
   <mfrac>
    <mn>1</mn>
    <mi>N</mi>
   </mfrac>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mn>1</mn>
     <mo>≤</mo>
     <mi>i</mi>
     <mo>≤</mo>
     <mi>N</mi>
    </mrow>
   </msub>
   <msub>
    <mn>1</mn>
    <mi>A</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>ξ</mi>
     <mi>k</mi>
     <mi>i</mi>
    </msubsup>
    <mo rspace="5.8pt" stretchy="false">)</mo>
   </mrow>
   <mpadded width="+3.3pt">
    <msub>
     <mo>≈</mo>
     <mrow>
      <mi>N</mi>
      <mo>↑</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
   </mpadded>
   <mi>P</mi>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>X</mi>
     <mn>0</mn>
    </msub>
    <mo>∈</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
    <mo>∈</mo>
    <mi>A</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">product</csymbol>
     <apply>
      <and></and>
      <apply>
       <leq></leq>
       <cn type="integer">0</cn>
       <ci>k</ci>
      </apply>
      <apply>
       <leq></leq>
       <share href="#.cmml">
       </share>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <and></and>
      <apply>
       <leq></leq>
       <cn type="integer">1</cn>
       <ci>i</ci>
      </apply>
      <apply>
       <leq></leq>
       <share href="#.cmml">
       </share>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cn type="integer">1</cn>
     <ci>A</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ξ</ci>
       <ci>i</ci>
      </apply>
      <ci>k</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <approx></approx>
     <apply>
      <ci>normal-↑</ci>
      <ci>N</ci>
      <infinity></infinity>
     </apply>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">0</cn>
     </apply>
     <in></in>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
     <in></in>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \prod_{0\leq k\leq n}\frac{1}{N}\sum_{1\leq i\leq N}1_{A}(\xi^{i}_{k})~{}%
\approx_{N\uparrow\infty}~{}P\left(X_{0}\in A,\ldots,X_{n}\in A\right)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Genetic_algorithm:45">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+3.3pt">
     <msub>
      <mn>1</mn>
      <mi>A</mi>
     </msub>
    </mpadded>
    <mi>x</mi>
   </mrow>
   <mo>∈</mo>
   <mi>S</mi>
   <mo>↦</mo>
   <mrow>
    <msub>
     <mn>1</mn>
     <mi>A</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <cn type="integer">1</cn>
       <ci>A</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <ci>S</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <cn type="integer">1</cn>
       <ci>A</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1_{A}~{}x\in S\mapsto 1_{A}(x)\in\{0,1\}
  </annotation>
 </semantics>
</math>

 stands for the <a href="indicator_function" title="wikilink">indicator function</a> of the set A.</p>
<ol>
<li>In <a href="Particle_filter" title="wikilink">filtering problems</a> the Markov chain 

<math display="inline" id="Genetic_algorithm:46">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{n}
  </annotation>
 </semantics>
</math>

 represents the signal process. This Markov chain can represent the evolution of some target (missile, plane, boat, and so on). Suppose the state 

<math display="inline" id="Genetic_algorithm:47">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{n}
  </annotation>
 </semantics>
</math>

 is partially observed by some sensor of the form 

<math display="inline" id="Genetic_algorithm:48">
 <semantics>
  <mrow>
   <msub>
    <mi>Y</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>X</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>V</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Y</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>h</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{n}=h(X_{n})+V_{n}
  </annotation>
 </semantics>
</math>

 for some function 

<math display="inline" id="Genetic_algorithm:49">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <mi>h</mi>
   </mpadded>
   <mo rspace="5.8pt">:</mo>
   <mrow>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>S</mi>
    <mo>↦</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>h</ci>
    <apply>
     <and></and>
     <apply>
      <in></in>
      <ci>x</ci>
      <ci>S</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <ci>ℝ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h~{}:~{}x\in S\mapsto h(x)\in\mathbb{R}
  </annotation>
 </semantics>
</math>

 and some sequence of random variables with a probability density 

<math display="inline" id="Genetic_algorithm:50">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(v)
  </annotation>
 </semantics>
</math>

. We fix the observations 

<math display="inline" id="Genetic_algorithm:51">
 <semantics>
  <mrow>
   <msub>
    <mi>Y</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>y</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Y</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{n}=y_{n}
  </annotation>
 </semantics>
</math>

 and we set 

<math display="inline" id="Genetic_algorithm:52">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>G</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msub>
       <mi>y</mi>
       <mi>n</mi>
      </msub>
      <mo>-</mo>
      <mrow>
       <mi>h</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <ci>n</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{n}(x)=g\left(y_{n}-h(x)\right)
  </annotation>
 </semantics>
</math>

. In this situation, the Feynman-Kac probability measures defined above coincide with the conditional distributions of the signal given the observation sequence; that is, we have that <math display="block">E\left(f_n(X_0,\ldots,X_n)~|~Y_0=y_0,~\ldots, Y_n=y_n\right)</math></li>
</ol>

<p>=\displaystyle\frac{E\left(f_n(X_0,\ldots,X_n)\prod_{0\leq k\leq n}G_k(X_k)\right)}{E\left(\prod_{0\leq k\leq n}G_k(X_k)\right)} In addition, we have the <a href="unbiased_estimate" title="wikilink">unbiased estimate</a> 

<math display="inline" id="Genetic_algorithm:53">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∏</mo>
     <mrow>
      <mn>0</mn>
      <mo>≤</mo>
      <mi>k</mi>
      <mo>≤</mo>
      <mi>n</mi>
     </mrow>
    </msub>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>N</mi>
     </mfrac>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mn>1</mn>
        <mo>≤</mo>
        <mi>i</mi>
        <mo>≤</mo>
        <mi>N</mi>
       </mrow>
      </msub>
      <mrow>
       <msub>
        <mi>G</mi>
        <mi>k</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msubsup>
         <mi>ξ</mi>
         <mi>k</mi>
         <mi>i</mi>
        </msubsup>
        <mo rspace="5.8pt" stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mpadded width="+3.3pt">
    <msub>
     <mo>≈</mo>
     <mrow>
      <mi>N</mi>
      <mo>↑</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
   </mpadded>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>y</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <approx></approx>
     <apply>
      <ci>normal-↑</ci>
      <ci>N</ci>
      <infinity></infinity>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <and></and>
       <apply>
        <leq></leq>
        <cn type="integer">0</cn>
        <ci>k</ci>
       </apply>
       <apply>
        <leq></leq>
        <share href="#.cmml">
        </share>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>N</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <and></and>
         <apply>
          <leq></leq>
          <cn type="integer">1</cn>
          <ci>i</ci>
         </apply>
         <apply>
          <leq></leq>
          <share href="#.cmml">
          </share>
          <ci>N</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>G</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>ξ</ci>
          <ci>i</ci>
         </apply>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>p</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \prod_{0\leq k\leq n}\frac{1}{N}\sum_{1\leq i\leq N}G_{k}(\xi^{i}_{k})~{}%
\approx_{N\uparrow\infty}~{}p(y_{0},\ldots,y_{n})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Genetic_algorithm:54">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>y</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(y_{0},\ldots,y_{n})
  </annotation>
 </semantics>
</math>

 stands for the <a href="Probability_density_function" title="wikilink">probability density</a> of the random variable 

<math display="inline" id="Genetic_algorithm:55">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>Y</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>Y</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Y</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Y</ci>
     <ci>n</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Y_{0},\ldots,Y_{n})
  </annotation>
 </semantics>
</math>

 evaluated at 

<math display="inline" id="Genetic_algorithm:56">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>y</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (y_{0},\ldots,y_{n})
  </annotation>
 </semantics>
</math>

. In signal processing and Bayesian inference, the mutation-selection genetic algorithm is also called <a href="particle_filter" title="wikilink">particle filter of Sequential Monte Carlo algorithm.</a></p>
<ol>
<li>Consider a sequence of probability measures 

<math display="inline" id="Genetic_algorithm:57">
 <semantics>
  <msub>
   <mi>π</mi>
   <mi>β</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>π</ci>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{\beta}
  </annotation>
 </semantics>
</math>

 on a finite solution space S indexed by some inverse temperature parameter 

<math display="inline" id="Genetic_algorithm:58">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>β</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta>0
  </annotation>
 </semantics>
</math>

 and defined by 

<math display="inline" id="Genetic_algorithm:59">
 <semantics>
  <mrow>
   <msub>
    <mi>π</mi>
    <mi>β</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>β</mi>
       <mi>V</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msup>
    <mrow>
     <mstyle displaystyle="false">
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>y</mi>
        <mo>∈</mo>
        <mi>S</mi>
       </mrow>
      </msub>
     </mstyle>
     <msup>
      <mi>e</mi>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>β</mi>
        <mi>V</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msup>
    </mrow>
   </mfrac>
   <mpadded width="+3.3pt">
    <mtext>for some function</mtext>
   </mpadded>
   <mpadded width="+3.3pt">
    <mi>V</mi>
   </mpadded>
   <mo rspace="5.8pt">:</mo>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>S</mi>
   <mo>↦</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">∞</mi>
    <mo stretchy="false">[</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <ci>β</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>β</ci>
        <ci>V</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>y</ci>
        <ci>S</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>β</ci>
         <ci>V</ci>
         <ci>y</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <ci></ci>
    <mtext>for some function</mtext>
    <csymbol cd="unknown">V</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">x</csymbol>
    <in></in>
    <csymbol cd="unknown">S</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <in></in>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cn type="integer">0</cn>
     <ci>normal-,</ci>
     <infinity></infinity>
     <ci>normal-[</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{\beta}(x)=\frac{e^{-\beta V(x)}}{\sum_{y\in S}e^{-\beta V(y)}}\quad\mbox{%
for some function}~{}V~{}:~{}x\in S\mapsto V(x)\in[0,\infty[
  </annotation>
 </semantics>
</math>

These probability measures concentrate to the set of global minima of the function V(.). More precisely, we have<math display="block">V_{\star}:=\inf_{x\in S}V(x)\quad\mbox{and}\quad\mathcal V:=\{x\in S~:~V(x)=V_{\star}\}\Rightarrow~\forall x\in\mathcal V\quad \pi_{\beta}(x)=\frac{</math></li>
</ol>

<p>e^{-\beta \left(V(x)-V_{\star}\right)} }{\sum_{y\in S} e^{-\beta \left(V(y)-V_{\star}\right)}}= \frac{1}{\mbox{Card}(\mathcal V)+\sum_{y\in S-\mathcal V} e^{-\beta \left(V(y)-V_{\star}\right)}}\approx_{\beta\uparrow\infty}~\frac{1}{\mbox{Card}(\mathcal V)}and for 

<math display="inline" id="Genetic_algorithm:60">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∉</mo>
   <mi class="ltx_font_mathcaligraphic">𝒱</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>x</ci>
    <ci>𝒱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\not\in\mathcal{V}
  </annotation>
 </semantics>
</math>

 we have 

<math display="inline" id="Genetic_algorithm:61">
 <semantics>
  <mrow>
   <msub>
    <mi>π</mi>
    <mrow>
     <mi>β</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
   <msub>
    <mo>≈</mo>
    <mrow>
     <mi>β</mi>
     <mo>↑</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
   </msub>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <approx></approx>
     <apply>
      <ci>normal-↑</ci>
      <ci>β</ci>
      <infinity></infinity>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <apply>
      <times></times>
      <ci>β</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{\beta(x)}\approx_{\beta\uparrow\infty}0
  </annotation>
 </semantics>
</math>

. This implies that 

<math display="inline" id="Genetic_algorithm:62">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>π</mi>
     <mi>β</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo rspace="5.8pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mpadded width="+3.3pt">
    <msub>
     <mo>≈</mo>
     <mrow>
      <mi>β</mi>
      <mo>↑</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
   </mpadded>
   <mrow>
    <mpadded width="+3.3pt">
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mtext>Card</mtext>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi class="ltx_font_mathcaligraphic">𝒱</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mpadded>
    <msub>
     <mn>1</mn>
     <mi class="ltx_font_mathcaligraphic">𝒱</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <approx></approx>
     <apply>
      <ci>normal-↑</ci>
      <ci>β</ci>
      <infinity></infinity>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <ci>β</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <mtext>Card</mtext>
       <ci>𝒱</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="integer">1</cn>
      <ci>𝒱</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{\beta}(x)~{}\approx_{\beta\uparrow\infty}~{}\frac{1}{\mbox{Card}(\mathcal%
{V})}~{}1_{\mathcal{V}}(x)
  </annotation>
 </semantics>
</math>

 In other words, sampling a random variable with probability distribution 

<math display="inline" id="Genetic_algorithm:63">
 <semantics>
  <mrow>
   <msub>
    <mi>π</mi>
    <mi>β</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <ci>β</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{\beta}(x)
  </annotation>
 </semantics>
</math>

 is almost <em>equivalent to that of sampling uniformly one of the global minima of the function V(.).</em> Let 

<math display="inline" id="Genetic_algorithm:64">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mi>n</mi>
   </msub>
   <mo>≥</mo>
   <msub>
    <mi>β</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{n}\geq\beta_{n-1}
  </annotation>
 </semantics>
</math>

 be a increasing sequence of parameters with 

<math display="inline" id="Genetic_algorithm:65">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{0}=0
  </annotation>
 </semantics>
</math>

. Consider a <a href="Markov_chain" title="wikilink">Markov chain</a> 

<math display="inline" id="Genetic_algorithm:66">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{n}
  </annotation>
 </semantics>
</math>

 starting with the uniform distribution 

<math display="inline" id="Genetic_algorithm:67">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>π</mi>
     <mn>0</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mtext>Card</mtext>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <mtext>Card</mtext>
     </apply>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{0}(x)=1/\mbox{Card}(S)
  </annotation>
 </semantics>
</math>

 on 

<math display="inline" id="Genetic_algorithm:68">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 and such that 

<math display="inline" id="Genetic_algorithm:69">
 <semantics>
  <msub>
   <mi>π</mi>
   <msub>
    <mi>β</mi>
    <mi>n</mi>
   </msub>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>π</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{\beta_{n}}
  </annotation>
 </semantics>
</math>

 is an <a href="invariant_measure" title="wikilink">invariant probability</a> measure of the transition 

<math display="inline" id="Genetic_algorithm:70">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>→</mo>
   <msub>
    <mi>X</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{n-1}\rightarrow X_{n}
  </annotation>
 </semantics>
</math>

 at time n; that is, for any 

<math display="inline" id="Genetic_algorithm:71">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>≥</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\geq 1
  </annotation>
 </semantics>
</math>

 we have that

<math display="inline" id="Genetic_algorithm:72">
 <semantics>
  <mrow>
   <msub>
    <mi>π</mi>
    <msub>
     <mi>β</mi>
     <mi>n</mi>
    </msub>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mpadded width="+3.3pt">
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>y</mi>
      <mo>∈</mo>
      <mi>S</mi>
     </mrow>
    </msub>
   </mpadded>
   <mi>P</mi>
   <mi>r</mi>
   <mi>o</mi>
   <mi>b</mi>
   <mi>a</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mpadded width="+3.3pt">
     <mi>x</mi>
    </mpadded>
    <mo rspace="5.8pt" stretchy="false">|</mo>
    <msub>
     <mi>X</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mi>y</mi>
    <mo rspace="5.8pt" stretchy="false">)</mo>
   </mrow>
   <msub>
    <mi>π</mi>
    <msub>
     <mi>β</mi>
     <mi>n</mi>
    </msub>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <ci>y</ci>
      <ci>S</ci>
     </apply>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <csymbol cd="unknown">o</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{\beta_{n}}(x)=\sum_{y\in S}~{}Proba(X_{n}=x~{}|~{}X_{n-1}=y)~{}\pi_{\beta%
_{n}}(y)
  </annotation>
 </semantics>
</math>

These Markov transitions can be designed using <a href="Markov_chain_Monte_Carlo" title="wikilink">Markov Chain Monte Carlo</a> (MCMC) methods such as the <a href="Metropolis–Hastings_algorithm" title="wikilink">Metropolis-Hasting algorithm</a>, or the <a href="Gibbs_sampling" title="wikilink">Gibbs sampler.</a> We consider the fitness function 

<math display="inline" id="Genetic_algorithm:73">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>G</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>β</mi>
          <mrow>
           <mi>n</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>β</mi>
          <mi>n</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>V</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <ci>n</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <exp></exp>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>β</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>β</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <ci>V</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{n}(x)=\exp{\left[-(\beta_{n+1}-\beta_{n})V(x)\right]}
  </annotation>
 </semantics>
</math>

In this situation, for any function 

<math display="inline" id="Genetic_algorithm:74">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <mi>f</mi>
   </mpadded>
   <mo rspace="5.8pt">:</mo>
   <mrow>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>S</mi>
    <mo>↦</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <and></and>
     <apply>
      <in></in>
      <ci>x</ci>
      <ci>S</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <ci>ℝ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f~{}:~{}x\in S\mapsto f(x)\in\mathbb{R}
  </annotation>
 </semantics>
</math>

, we have

<math display="inline" id="Genetic_algorithm:75">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 stands for the cardinality of the set <span class="LaTeX">$S$</span>. The corresponding genetic algorithm is defined in terms of MCMC mutations, the selection transitions consists of selecting the particles which are better adapted to the change of temperature. <strong>At every time step</strong>, we have the particle estimates<span class="LaTeX">$\frac{1}{N}\sum_{1\leq i\leq N}~f\left(\xi^i_n\right)~\approx_{N\uparrow\infty}~\sum_{x\in S}~f(x)~\pi_{\beta_n}(x)\quad\mbox{and the unbiased approximation}\quad
\prod_{0\leq k<n}\frac{1}{n}\sum_{1\leq i\leq="" math="" n}\exp{\left[-(\beta_{k+1}-\beta_k)v(\xi^i_k)\right]}~\approx_{n\uparrow\infty}~\frac{1}{\mbox{card}(s)}\sum_{x\in="" s}~e^{-\beta_nv(x)}<="">In particular, this implies that<math display="block">\lim_{n\uparrow\infty}\beta_n=\infty~\Rightarrow~\lim_{n\uparrow\infty}\lim_{N\uparrow\infty}\frac{1}{N}\sum_{1\leq i\leq N}~f\left(\xi^i_n\right)=\frac{1}{\mbox{Card}(\mathcal V)}\sum_{x\in \mathcal V}~f(x)~$</math></n}\frac{1}{n}\sum_{1\leq></span>Further details on these genetic type interacting MCMC methods (a.k.a. <a href="Particle_filter" title="wikilink">Sequential Monte Carlo</a> - SMC) can be found in.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> </p>
</div>
<h2 id="the-building-block-hypothesis">The building block hypothesis</h2>

<p>Genetic algorithms are simple to implement, but their behavior is difficult to understand. In particular it is difficult to understand why these algorithms frequently succeed at generating solutions of high fitness when applied to practical problems. The building block hypothesis (BBH) consists of:</p>
<ol>
<li>A description of a heuristic that performs adaptation by identifying and recombining "building blocks", i.e. low order, low defining-length <a href="Schema_(genetic_algorithms)" title="wikilink">schemata</a> with above average fitness.</li>
<li>A hypothesis that a genetic algorithm performs adaptation by implicitly and efficiently implementing this heuristic.</li>
</ol>

<p>Goldberg describes the heuristic as follows:</p>
<dl>
<dd>"Short, low order, and highly fit schemata are sampled, <a href="crossover_(genetic_algorithm)" title="wikilink">recombined</a> [crossed over], and resampled to form strings of potentially higher fitness. In a way, by working with these particular schemata [the building blocks], we have reduced the complexity of our problem; instead of building high-performance strings by trying every conceivable combination, we construct better and better strings from the best partial solutions of past samplings.
</dd>
</dl>
<dl>
<dd>"Because highly fit schemata of low defining length and low order play such an important role in the action of genetic algorithms, we have already given them a special name: building blocks. Just as a child creates magnificent fortresses through the arrangement of simple blocks of wood, so does a genetic algorithm seek near optimal performance through the juxtaposition of short, low-order, high-performance schemata, or building blocks."
</dd>
</dl>
<h2 id="limitations">Limitations</h2>

<p>There are limitations of the use of a genetic algorithm compared to alternative optimization algorithms:</p>
<ul>
<li>Repeated <a href="fitness_function" title="wikilink">fitness function</a> evaluation for complex problems is often the most prohibitive and limiting segment of artificial evolutionary algorithms. Finding the optimal solution to complex high-dimensional, multimodal problems often requires very expensive <a href="fitness_function" title="wikilink">fitness function</a> evaluations. In real world problems such as structural optimization problems, a single function evaluation may require several hours to several days of complete simulation. Typical optimization methods can not deal with such types of problem. In this case, it may be necessary to forgo an exact evaluation and use an <a href="fitness_approximation" title="wikilink">approximated fitness</a> that is computationally efficient. It is apparent that amalgamation of <a href="fitness_approximation" title="wikilink">approximate models</a> may be one of the most promising approaches to convincingly use GA to solve complex real life problems.</li>
</ul>
<ul>
<li>Genetic algorithms do not scale well with complexity. That is, where the number of elements which are exposed to mutation is large there is often an exponential increase in search space size. This makes it extremely difficult to use the technique on problems such as designing an engine, a house or plane. In order to make such problems tractable to evolutionary search, they must be broken down into the simplest representation possible. Hence we typically see evolutionary algorithms encoding designs for fan blades instead of engines, building shapes instead of detailed construction plans, airfoils instead of whole aircraft designs. The second problem of complexity is the issue of how to protect parts that have evolved to represent good solutions from further destructive mutation, particularly when their fitness assessment requires them to combine well with other parts.</li>
</ul>
<ul>
<li>The "better" solution is only in comparison to other solutions. As a result, the stop criterion is not clear in every problem.</li>
</ul>
<ul>
<li>In many problems, GAs may have a tendency to converge towards <a href="local_optimum" title="wikilink">local optima</a> or even arbitrary points rather than the <a href="global_optimum" title="wikilink">global optimum</a> of the problem. This means that it does not "know how" to sacrifice short-term fitness to gain longer-term fitness. The likelihood of this occurring depends on the shape of the <a href="fitness_landscape" title="wikilink">fitness landscape</a>: certain problems may provide an easy ascent towards a global optimum, others may make it easier for the function to find the local optima. This problem may be alleviated by using a different fitness function, increasing the rate of mutation, or by using selection techniques that maintain a diverse population of solutions,<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> although the <a href="No_free_lunch_in_search_and_optimization" title="wikilink">No Free Lunch theorem</a><a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> proves that there is no general solution to this problem. A common technique to maintain diversity is to impose a "niche penalty", wherein, any group of individuals of sufficient similarity (niche radius) have a penalty added, which will reduce the representation of that group in subsequent generations, permitting other (less similar) individuals to be maintained in the population. This trick, however, may not be effective, depending on the landscape of the problem. Another possible technique would be to simply replace part of the population with randomly generated individuals, when most of the population is too similar to each other. Diversity is important in genetic algorithms (and <a href="genetic_programming" title="wikilink">genetic programming</a>) because crossing over a homogeneous population does not yield new solutions. In <a href="Evolution_strategy" title="wikilink">evolution strategies</a> and <a href="evolutionary_programming" title="wikilink">evolutionary programming</a>, diversity is not essential because of a greater reliance on mutation.</li>
</ul>
<ul>
<li>Operating on dynamic data sets is difficult, as genomes begin to converge early on towards solutions which may no longer be valid for later data. Several methods have been proposed to remedy this by increasing genetic diversity somehow and preventing early convergence, either by increasing the probability of mutation when the solution quality drops (called <em>triggered hypermutation</em>), or by occasionally introducing entirely new, randomly generated elements into the gene pool (called <em>random immigrants</em>). Again, <a href="Evolution_strategy" title="wikilink">evolution strategies</a> and <a href="evolutionary_programming" title="wikilink">evolutionary programming</a> can be implemented with a so-called "comma strategy" in which parents are not maintained and new parents are selected only from offspring. This can be more effective on dynamic problems.</li>
</ul>
<ul>
<li>GAs cannot effectively solve problems in which the only fitness measure is a single right/wrong measure (like <a href="decision_problem" title="wikilink">decision problems</a>), as there is no way to converge on the solution (no hill to climb). In these cases, a random search may find a solution as quickly as a GA. However, if the situation allows the success/failure trial to be repeated giving (possibly) different results, then the ratio of successes to failures provides a suitable fitness measure.</li>
</ul>
<ul>
<li>For specific optimization problems and problem instances, other optimization algorithms may be more efficient than genetic algorithms in terms of speed of convergence. Alternative and complementary algorithms include <a href="Evolution_strategy" title="wikilink">evolution strategies</a>, <a href="evolutionary_programming" title="wikilink">evolutionary programming</a>, <a href="simulated_annealing" title="wikilink">simulated annealing</a>, <a href="Gaussian_adaptation" title="wikilink">Gaussian adaptation</a>, <a href="hill_climbing" title="wikilink">hill climbing</a>, and <a href="swarm_intelligence" title="wikilink">swarm intelligence</a> (e.g.: <a href="ant_colony_optimization" title="wikilink">ant colony optimization</a>, <a href="particle_swarm_optimization" title="wikilink">particle swarm optimization</a>) and methods based on <a href="integer_linear_programming" title="wikilink">integer linear programming</a>. The suitability of genetic algorithms is dependent on the amount of knowledge of the problem; well known problems often have better, more specialized approaches.</li>
</ul>
<h2 id="variants">Variants</h2>
<h3 id="chromosome-representation">Chromosome representation</h3>

<p>The simplest algorithm represents each chromosome as a <a href="Bit_array" title="wikilink">bit string</a>. Typically, numeric parameters can be represented by <a href="integer" title="wikilink">integers</a>, though it is possible to use <a href="floating_point" title="wikilink">floating point</a> representations. The floating point representation is natural to <a href="Evolution_strategy" title="wikilink">evolution strategies</a> and <a href="evolutionary_programming" title="wikilink">evolutionary programming</a>. The notion of real-valued genetic algorithms has been offered but is really a misnomer because it does not really represent the building block theory that was proposed by <a href="John_Henry_Holland" title="wikilink">John Henry Holland</a> in the 1970s. This theory is not without support though, based on theoretical and experimental results (see below). The basic algorithm performs crossover and mutation at the bit level. Other variants treat the chromosome as a list of numbers which are indexes into an instruction table, nodes in a <a href="linked_list" title="wikilink">linked list</a>, <a href="associative_array" title="wikilink">hashes</a>, <a href="object_(computer_science)" title="wikilink">objects</a>, or any other imaginable <a href="data_structure" title="wikilink">data structure</a>. Crossover and mutation are performed so as to respect data element boundaries. For most data types, specific variation operators can be designed. Different chromosomal data types seem to work better or worse for different specific problem domains.</p>

<p>When bit-string representations of integers are used, <a href="Gray_coding" title="wikilink">Gray coding</a> is often employed. In this way, small changes in the integer can be readily effected through mutations or crossovers. This has been found to help prevent premature convergence at so called <em>Hamming walls</em>, in which too many simultaneous mutations (or crossover events) must occur in order to change the chromosome to a better solution.</p>

<p>Other approaches involve using arrays of real-valued numbers instead of bit strings to represent chromosomes. Results from the theory of schemata suggest that in general the smaller the alphabet, the better the performance, but it was initially surprising to researchers that good results were obtained from using real-valued chromosomes. This was explained as the set of real values in a finite population of chromosomes as forming a <em>virtual alphabet</em> (when selection and recombination are dominant) with a much lower cardinality than would be expected from a floating point representation.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a><a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>

<p>An expansion of the Genetic Algorithm accessible problem domain can be obtained through more complex encoding of the solution pools by concatenating several types of heterogenously encoded genes into one chromosome.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> This particular approach allows for solving optimization problems that require vastly disparate definition domains for the problem parameters. For instance, in problems of cascaded controller tuning, the internal loop controller structure can belong to a conventional regulator of three parameters, whereas the external loop could implement a linguistic controller (such as a fuzzy system) which has an inherently different description. This particular form of encoding requires a specialized crossover mechanism that recombines the chromosome by section, and it is a useful tool for the modelling and simulation of complex adaptive systems, especially evolution processes.</p>
<h3 id="elitism">Elitism</h3>

<p>A practical variant of the general process of constructing a new population is to allow the best organism(s) from the current generation to carry over to the next, unaltered. This strategy is known as <em>elitist selection</em> and guarantees that the solution quality obtained by the GA will not decrease from one generation to the next.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>
<h3 id="parallel-implementations">Parallel implementations</h3>

<p>Parallel implementations of genetic algorithms come in two flavours. Coarse-grained parallel genetic algorithms assume a population on each of the computer nodes and migration of individuals among the nodes. Fine-grained parallel genetic algorithms assume an individual on each processor node which acts with neighboring individuals for selection and reproduction. Other variants, like genetic algorithms for online optimization problems, introduce time-dependence or noise in the fitness function.</p>
<h3 id="adaptive-gas">Adaptive GAs</h3>

<p>Genetic algorithms with adaptive parameters (adaptive genetic algorithms, AGAs) is another significant and promising variant of genetic algorithms. The probabilities of crossover (pc) and mutation (pm) greatly determine the degree of solution accuracy and the convergence speed that genetic algorithms can obtain. Instead of using fixed values of <em>pc</em> and <em>pm</em>, AGAs utilize the population information in each generation and adaptively adjust the <em>pc</em> and <em>pm</em> in order to maintain the population diversity as well as to sustain the convergence capacity. In AGA (adaptive genetic algorithm),<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> the adjustment of <em>pc</em> and <em>pm</em> depends on the fitness values of the solutions. In <em>CAGA</em> (clustering-based adaptive genetic algorithm),<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> through the use of clustering analysis to judge the optimization states of the population, the adjustment of <em>pc</em> and <em>pm</em> depends on these optimization states. It can be quite effective to combine GA with other optimization methods. GA tends to be quite good at finding generally good global solutions, but quite inefficient at finding the last few mutations to find the absolute optimum. Other techniques (such as simple hill climbing) are quite efficient at finding absolute optimum in a limited region. Alternating GA and hill climbing can improve the efficiency of GA while overcoming the lack of robustness of hill climbing.</p>

<p>This means that the rules of genetic variation may have a different meaning in the natural case. For instance – provided that steps are stored in consecutive order – crossing over may sum a number of steps from maternal DNA adding a number of steps from paternal DNA and so on. This is like adding vectors that more probably may follow a ridge in the phenotypic landscape. Thus, the efficiency of the process may be increased by many orders of magnitude. Moreover, the <a href="Chromosomal_inversion" title="wikilink">inversion operator</a> has the opportunity to place steps in consecutive order or any other suitable order in favour of survival or efficiency. (See for instance <a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> or example in <a href="travelling_salesman_problem" title="wikilink">travelling salesman problem</a>, in particular the use of an <a href="edge_recombination_operator" title="wikilink">edge recombination operator</a>.)</p>

<p>A variation, where the population as a whole is evolved rather than its individual members, is known as gene pool recombination.</p>

<p>A number of variations have been developed to attempt to improve performance of GAs on problems with a high degree of fitness epistasis, i.e. where the fitness of a solution consists of interacting subsets of its variables. Such algorithms aim to learn (before exploiting) these beneficial phenotypic interactions. As such, they are aligned with the Building Block Hypothesis in adaptively reducing disruptive recombination. Prominent examples of this approach include the mGA,<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> GEMGA<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> and LLGA.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></p>
<h2 id="problem-domains">Problem domains</h2>

<p>Problems which appear to be particularly appropriate for solution by genetic algorithms include <a href="Timeline" title="wikilink">timetabling</a> and scheduling problems, and many scheduling software packages are based on GAs. GAs have also been applied to <a class="uri" href="engineering" title="wikilink">engineering</a>.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> Genetic algorithms are often applied as an approach to solve <a href="global_optimization" title="wikilink">global optimization</a> problems.</p>

<p>As a general rule of thumb genetic algorithms might be useful in problem domains that have a complex <a href="fitness_landscape" title="wikilink">fitness landscape</a> as mixing, i.e., <a href="Mutation_(genetic_algorithm)" title="wikilink">mutation</a> in combination with <a href="Crossover_(genetic_algorithm)" title="wikilink">crossover</a>, is designed to move the population away from <a href="local_optima" title="wikilink">local optima</a> that a traditional <a href="hill_climbing" title="wikilink">hill climbing</a> algorithm might get stuck in. Observe that commonly used crossover operators cannot change any uniform population. Mutation alone can provide ergodicity of the overall genetic algorithm process (seen as a <a href="Markov_chain" title="wikilink">Markov chain</a>).</p>

<p>Examples of problems solved by genetic algorithms include: mirrors designed to funnel sunlight to a solar collector,<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> antennae designed to pick up radio signals in space,<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> and walking methods for computer figures.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a></p>

<p>In his <em>Algorithm Design Manual</em>, <a href="Steven_Skiena" title="wikilink">Skiena</a> advises against genetic algorithms for any task:</p>
<h2 id="history">History</h2>

<p>In 1950, Alan Turing proposed a "learning machine" which would parallel the principles of evolution.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> Computer simulation of evolution started as early as in 1954 with the work of <a href="Nils_Aall_Barricelli" title="wikilink">Nils Aall Barricelli</a>, who was using the computer at the <a href="Institute_for_Advanced_Study" title="wikilink">Institute for Advanced Study</a> in <a href="Princeton,_New_Jersey" title="wikilink">Princeton, New Jersey</a>.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a><a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> His 1954 publication was not widely noticed. Starting in 1957,<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> the Australian quantitative geneticist <a href="Alex_Fraser_(scientist)" title="wikilink">Alex Fraser</a> published a series of papers on simulation of <a href="artificial_selection" title="wikilink">artificial selection</a> of organisms with multiple loci controlling a measurable trait. From these beginnings, computer simulation of evolution by biologists became more common in the early 1960s, and the methods were described in books by Fraser and Burnell (1970)<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> and Crosby (1973).<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> Fraser's simulations included all of the essential elements of modern genetic algorithms. In addition, <a href="Hans-Joachim_Bremermann" title="wikilink">Hans-Joachim Bremermann</a> published a series of papers in the 1960s that also adopted a population of solution to optimization problems, undergoing recombination, mutation, and selection. Bremermann's research also included the elements of modern genetic algorithms.<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> Other noteworthy early pioneers include Richard Friedberg, George Friedman, and Michael Conrad. Many early papers are reprinted by <a href="David_B._Fogel" title="wikilink">Fogel</a> (1998).<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a></p>

<p>Although Barricelli, in work he reported in 1963, had simulated the evolution of ability to play a simple game,<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a> <a href="artificial_evolution" title="wikilink">artificial evolution</a> became a widely recognized optimization method as a result of the work of <a href="Ingo_Rechenberg" title="wikilink">Ingo Rechenberg</a> and <a href="Hans-Paul_Schwefel" title="wikilink">Hans-Paul Schwefel</a> in the 1960s and early 1970s – Rechenberg's group was able to solve complex engineering problems through <a href="Evolution_strategy" title="wikilink">evolution strategies</a>.<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a><a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a><a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a><a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a> Another approach was the evolutionary programming technique of <a href="Lawrence_J._Fogel" title="wikilink">Lawrence J. Fogel</a>, which was proposed for generating artificial intelligence. <a href="Evolutionary_programming" title="wikilink">Evolutionary programming</a> originally used finite state machines for predicting environments, and used variation and selection to optimize the predictive logics. Genetic algorithms in particular became popular through the work of <a href="John_Henry_Holland" title="wikilink">John Holland</a> in the early 1970s, and particularly his book <em>Adaptation in Natural and Artificial Systems</em> (1975). His work originated with studies of <a href="cellular_automata" title="wikilink">cellular automata</a>, conducted by <a href="John_Henry_Holland" title="wikilink">Holland</a> and his students at the <a href="University_of_Michigan" title="wikilink">University of Michigan</a>. Holland introduced a formalized framework for predicting the quality of the next generation, known as <a href="Holland's_Schema_Theorem" title="wikilink">Holland's Schema Theorem</a>. Research in GAs remained largely theoretical until the mid-1980s, when The First International Conference on Genetic Algorithms was held in <a href="Pittsburgh,_Pennsylvania" title="wikilink">Pittsburgh, Pennsylvania</a>.</p>

<p>As academic interest grew, the dramatic increase in desktop computational power allowed for practical application of the new technique. In the late 1980s, General Electric started selling the world's first genetic algorithm product, a mainframe-based toolkit designed for industrial processes. In 1989, Axcelis, Inc. released <a href="Evolver_(software)" title="wikilink">Evolver</a>, the world's first commercial GA product for desktop computers. <a href="The_New_York_Times" title="wikilink">The New York Times</a> technology writer <a href="John_Markoff" title="wikilink">John Markoff</a> wrote<a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a> about Evolver in 1990, and it remained the only interactive commercial genetic algorithm until 1995.<a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a> Evolver was sold to Palisade in 1997, translated into several languages, and is currently in its 6th version.<a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a></p>

<p><a href="Quantum_Monte_Carlo" title="wikilink">Quantum Monte Carlo</a>, and more specifically <a href="Diffusion_Monte_Carlo" title="wikilink">Diffusion Monte Carlo methods</a> can also be interpreted as genetic type particle approximations of Feynman-Kac path integrals.<a class="footnoteRef" href="#fn53" id="fnref53"><sup>53</sup></a><a class="footnoteRef" href="#fn54" id="fnref54"><sup>54</sup></a><a class="footnoteRef" href="#fn55" id="fnref55"><sup>55</sup></a><a class="footnoteRef" href="#fn56" id="fnref56"><sup>56</sup></a><a class="footnoteRef" href="#fn57" id="fnref57"><sup>57</sup></a><a class="footnoteRef" href="#fn58" id="fnref58"><sup>58</sup></a><a class="footnoteRef" href="#fn59" id="fnref59"><sup>59</sup></a> The origins of Quantum Monte Carlo methods are often attributed to Enrico Fermi and Robert Richtmyer who developed in 1948 a mean field particle interpretation of neutron-chain reactions,<a class="footnoteRef" href="#fn60" id="fnref60"><sup>60</sup></a> but the first heuristic-like and genetic type particle algorithm (a.k.a. Resampled or Reconfiguration Monte Carlo methods) for estimating ground state energies of quantum systems (in reduced matrix models) is due to Jack H. Hetherington in 1984.<a class="footnoteRef" href="#fn61" id="fnref61"><sup>61</sup></a> We also quote an earlier seminal works of <a href="Ted_Harris_(mathematician)" title="wikilink">Theodore E. Harris</a> and Herman Kahn in particle physics, published in 1951, using mean field but heuristic-like genetic methods for estimating particle transmission energies.<a class="footnoteRef" href="#fn62" id="fnref62"><sup>62</sup></a> In molecular chemistry, the use of genetic heuristic-like particle methodologies on path spaces (a.k.a. pruning and enrichment strategies) can be traced back to 1955 with the seminal work of Marshall. N. Rosenbluth and Arianna. W. Rosenbluth.<a class="footnoteRef" href="#fn63" id="fnref63"><sup>63</sup></a></p>

<p>The use of genetic particle algorithms in advanced <a href="signal_processing" title="wikilink">signal processing</a> and <a href="Bayesian_inference" title="wikilink">Bayesian inference</a> is more recent. It was in 1993, that Gordon et al., published in their seminal work<a class="footnoteRef" href="#fn64" id="fnref64"><sup>64</sup></a> the first application of genetic type algorithm in Bayesian statistical inference. The authors named their algorithm 'the bootstrap filter', and demonstrated that compared to other filtering methods, their bootstrap algorithm does not require any assumption about that state-space or the noise of the system. We also quote another pioneering article in this field of Genshiro Kitagawa on a related "Monte Carlo filter",<a class="footnoteRef" href="#fn65" id="fnref65"><sup>65</sup></a> and the ones by Pierre Del Moral<a class="footnoteRef" href="#fn66" id="fnref66"><sup>66</sup></a> and Himilcon Carvalho, Pierre Del Moral, André Monin and Gérard Salut<a class="footnoteRef" href="#fn67" id="fnref67"><sup>67</sup></a> on genetic type <a href="particle_filter" title="wikilink">particle filters</a> published in the mid-1990s. Genetic mutation-selection type particle filters were also developed in signal processing in the early 1989-1992 by P. Del Moral, J.C. Noyer, G. Rigal, and G. Salut in the LAAS-CNRS in a series of restricted and classified research reports with STCAN (Service Technique des Constructions et Armes Navales), the IT company DIGILOG, and the <a href="https://www.laas.fr/public/en">LAAS-CNRS</a> (the Laboratory for Analysis and Architecture of Systems) on RADAR/SONAR and GPS signal processing problems.<a class="footnoteRef" href="#fn68" id="fnref68"><sup>68</sup></a><a class="footnoteRef" href="#fn69" id="fnref69"><sup>69</sup></a><a class="footnoteRef" href="#fn70" id="fnref70"><sup>70</sup></a><a class="footnoteRef" href="#fn71" id="fnref71"><sup>71</sup></a><a class="footnoteRef" href="#fn72" id="fnref72"><sup>72</sup></a><a class="footnoteRef" href="#fn73" id="fnref73"><sup>73</sup></a></p>

<p>From 1950 to 1996, all the publications on genetic algorithms, including the pruning and resample Monte Carlo methods introduced in computational physics and molecular chemistry, present natural and heuristic-like genetic algorithms applied to different situations without a single proof of their consistency, nor a discussion on the bias of the estimates and on genealogical and ancestral tree based algorithms. The mathematical foundations and the first rigorous analysis of these genetic particle algorithms are due to Pierre Del Moral<a class="footnoteRef" href="#fn74" id="fnref74"><sup>74</sup></a><a class="footnoteRef" href="#fn75" id="fnref75"><sup>75</sup></a> in 1996. The article<a class="footnoteRef" href="#fn76" id="fnref76"><sup>76</sup></a> also contains a proof of the unbiased properties of a particle approximations of likelihood functions and unnormalized conditional probability measures. The unbiased particle estimator of the likelihood functions presented in this article is currently used today in Bayesian statistical inference. The theory on Feynman-Kac formulae and their genetic type particle interpretations has been developed in 2000 and 2004 in the books.<a class="footnoteRef" href="#fn77" id="fnref77"><sup>77</sup></a><a class="footnoteRef" href="#fn78" id="fnref78"><sup>78</sup></a> These abstract probabilistic models encapsulate genetic type algorithms, particle and bootstrap filters, interacting Kalman filters (a.k.a. Rao–Blackwellized particle filter <a class="footnoteRef" href="#fn79" id="fnref79"><sup>79</sup></a>), importance sampling and resampling style particle filter techniques, including genealogical tree based and particle backward methodologies for solving filtering and smoothing problems. Other classes of genetic type methodologies includes genealogical tree based models,<a class="footnoteRef" href="#fn80" id="fnref80"><sup>80</sup></a><a class="footnoteRef" href="#fn81" id="fnref81"><sup>81</sup></a><a class="footnoteRef" href="#fn82" id="fnref82"><sup>82</sup></a> backward Markov particle models,<a class="footnoteRef" href="#fn83" id="fnref83"><sup>83</sup></a><a class="footnoteRef" href="#fn84" id="fnref84"><sup>84</sup></a> adaptive genetic algorithms,<a class="footnoteRef" href="#fn85" id="fnref85"><sup>85</sup></a> island type methodologies,<a class="footnoteRef" href="#fn86" id="fnref86"><sup>86</sup></a><a class="footnoteRef" href="#fn87" id="fnref87"><sup>87</sup></a> and the more recent particle Markov chain Monte Carlo methodologies.<a class="footnoteRef" href="#fn88" id="fnref88"><sup>88</sup></a><a class="footnoteRef" href="#fn89" id="fnref89"><sup>89</sup></a></p>
<h2 id="related-techniques">Related techniques</h2>
<h3 id="parent-fields">Parent fields</h3>

<p>Genetic algorithms are a sub-field of:</p>
<ul>
<li><a href="Evolutionary_algorithms" title="wikilink">Evolutionary algorithms</a></li>
<li><a href="Evolutionary_computing" title="wikilink">Evolutionary computing</a></li>
<li><a href="Metaheuristic" title="wikilink">Metaheuristics</a></li>
<li><a href="Stochastic_optimization" title="wikilink">Stochastic optimization</a></li>
<li><a href="Optimization_(mathematics)" title="wikilink">Optimization</a></li>
</ul>
<h3 id="related-fields">Related fields</h3>
<h4 id="particle-filters">Particle filters</h4>

<p><a href="Particle_filter" title="wikilink">Particle filters</a> or <a href="Sequential_Monte_Carlo_methods" title="wikilink">Sequential Monte Carlo methods</a> (SMC) use a simple genetic algorithm with <strong>mutation-selection</strong> transitions to approximate the <strong>prediction-updating</strong> transitions of the <a href="Filtering_problem_(stochastic_processes)" title="wikilink">nonlinear filtering equation</a>. The number of individuals (a.k.a. particle or samples) represents the precision of the numerical algorithm. When the number of particles tends to infinity, the occupation measures of the population converge to the conditional distribution of the internal state of some dynamical system given some noisy and partial observations. In addition, the occupation measure of the ancestral lines of the genetic genealogical tree converge to the conditional distribution of the random trajectories of the system w.r.t. the sequence of observations. In this context, genetic algorithms provide a natural way to learn sequentially a series of observations to estimate the random states of some unknown dynamical process.</p>
<h4 id="evolutionary-algorithms">Evolutionary algorithms</h4>

<p>Evolutionary algorithms is a sub-field of <a href="Evolutionary_Computation" title="wikilink">evolutionary computing</a>.</p>
<ul>
<li><a href="Evolution_strategy" title="wikilink">Evolution strategies</a> (ES, see Rechenberg, 1994) evolve individuals by means of mutation and intermediate or discrete recombination. ES algorithms are designed particularly to solve problems in the real-value domain. They use self-adaptation to adjust control parameters of the search. De-randomization of self-adaptation has led to the contemporary Covariance Matrix Adaptation Evolution Strategy (<a class="uri" href="CMA-ES" title="wikilink">CMA-ES</a>).</li>
</ul>
<ul>
<li><a href="Evolutionary_programming" title="wikilink">Evolutionary programming</a> (EP) involves populations of solutions with primarily mutation and selection and arbitrary representations. They use self-adaptation to adjust parameters, and can include other variation operations such as combining information from multiple parents.</li>
</ul>
<ul>
<li><a href="Gene_expression_programming" title="wikilink">Gene expression programming</a> (GEP) also uses populations of computer programs. These complex computer programs are encoded in simpler linear chromosomes of fixed length, which are afterwards expressed as expression trees. Expression trees or computer programs evolve because the chromosomes undergo mutation and recombination in a manner similar to the canonical GA. But thanks to the special organization of GEP chromosomes, these genetic modifications always result in valid computer programs.<a class="footnoteRef" href="#fn90" id="fnref90"><sup>90</sup></a></li>
</ul>
<ul>
<li><a href="Genetic_programming" title="wikilink">Genetic programming</a> (GP) is a related technique popularized by <a href="John_Koza" title="wikilink">John Koza</a> in which computer programs, rather than function parameters, are optimized. Genetic programming often uses <a href="Tree_(data_structure)" title="wikilink">tree-based</a> internal <a href="data_structure" title="wikilink">data structures</a> to represent the computer programs for adaptation instead of the <a href="List_(computing)" title="wikilink">list</a> structures typical of genetic algorithms.</li>
</ul>
<ul>
<li><a href="Grouping_genetic_algorithm" title="wikilink">Grouping genetic algorithm</a> (GGA) is an evolution of the GA where the focus is shifted from individual items, like in classical GAs, to groups or subset of items.<a class="footnoteRef" href="#fn91" id="fnref91"><sup>91</sup></a> The idea behind this GA evolution proposed by <a href="Emanuel_Falkenauer" title="wikilink">Emanuel Falkenauer</a> is that solving some complex problems, a.k.a. <em>clustering</em> or <em>partitioning</em> problems where a set of items must be split into disjoint group of items in an optimal way, would better be achieved by making characteristics of the groups of items equivalent to genes. These kind of problems include <a href="bin_packing_problem" title="wikilink">bin packing</a>, line balancing, <a href="cluster_analysis" title="wikilink">clustering</a> with respect to a distance measure, equal piles, etc., on which classic GAs proved to perform poorly. Making genes equivalent to groups implies chromosomes that are in general of variable length, and special genetic operators that manipulate whole groups of items. For bin packing in particular, a GGA hybridized with the Dominance Criterion of Martello and Toth, is arguably the best technique to date.</li>
</ul>
<ul>
<li><a href="Interactive_evolutionary_algorithm" title="wikilink">Interactive evolutionary algorithms</a> are evolutionary algorithms that use human evaluation. They are usually applied to domains where it is hard to design a computational fitness function, for example, evolving images, music, artistic designs and forms to fit users' aesthetic preference.</li>
</ul>
<h4 id="swarm-intelligence">Swarm intelligence</h4>

<p>Swarm intelligence is a sub-field of <a href="Evolutionary_Computation" title="wikilink">evolutionary computing</a>.</p>
<ul>
<li><a href="Ant_colony_optimization" title="wikilink">Ant colony optimization</a> (<strong>ACO</strong>) uses many ants (or agents) to traverse the solution space and find locally productive areas. While usually inferior to genetic algorithms and other forms of local search, it is able to produce results in problems where no global or up-to-date perspective can be obtained, and thus the other methods cannot be applied.</li>
</ul>
<ul>
<li><a href="Particle_swarm_optimization" title="wikilink">Particle swarm optimization</a> (PSO) is a computational method for multi-parameter optimization which also uses population-based approach. A population (swarm) of candidate solutions (particles) moves in the search space, and the movement of the particles is influenced both by their own best known position and swarm's global best known position. Like genetic algorithms, the PSO method depends on information sharing among population members. In some problems the PSO is often more computationally efficient than the GAs, especially in unconstrained problems with continuous variables.<ref>Rania Hassan, Babak Cohanim, Olivier de Weck, Gerhard Vente</ref></li>
</ul>

<p>r (2005) <a href="http://www.mit.edu/~deweck/PDF_archive/3%20Refereed%20Conference/3_50_AIAA-2005-1897.pdf">A comparison of particle swarm optimization and the genetic algorithm</a></p>
<ul>
<li><a href="Intelligent_Water_Drops" title="wikilink">Intelligent Water Drops</a> or the IWD algorithm <a class="footnoteRef" href="#fn92" id="fnref92"><sup>92</sup></a> is a nature-inspired optimization algorithm inspired from natural water drops which change their environment to find the near optimal or optimal path to their destination. The memory is the river's bed and what is modified by the water drops is the amount of soil on the river's bed.</li>
</ul>
<h4 id="other-evolutionary-computing-algorithms">Other evolutionary computing algorithms</h4>

<p>Evolutionary computation is a sub-field of the <a class="uri" href="metaheuristic" title="wikilink">metaheuristic</a> methods.</p>
<ul>
<li><a href="Harmony_search" title="wikilink">Harmony search</a> (HS) is an algorithm mimicking the behaviour of musicians in the process of improvisation.</li>
</ul>
<ul>
<li><a href="Memetic_algorithm" title="wikilink">Memetic algorithm</a> (MA), often called <em>hybrid genetic algorithm</em> among others, is a population-based method in which solutions are also subject to local improvement phases. The idea of memetic algorithms comes from <a href="meme" title="wikilink">memes</a>, which unlike genes, can adapt themselves. In some problem areas they are shown to be more efficient than traditional evolutionary algorithms.</li>
</ul>
<ul>
<li><a href="Bacteriologic_algorithm" title="wikilink">Bacteriologic algorithms</a> (BA) inspired by <a href="evolutionary_ecology" title="wikilink">evolutionary ecology</a> and, more particularly, bacteriologic adaptation. Evolutionary ecology is the study of living organisms in the context of their environment, with the aim of discovering how they adapt. Its basic concept is that in a heterogeneous environment, you can't find one individual that fits the whole environment. So, you need to reason at the population level. It is also believed BAs could be successfully applied to complex positioning problems (antennas for cell phones, urban planning, and so on) or data mining.<a class="footnoteRef" href="#fn93" id="fnref93"><sup>93</sup></a></li>
</ul>
<ul>
<li><a href="Cultural_algorithm" title="wikilink">Cultural algorithm</a> (CA) consists of the population component almost identical to that of the genetic algorithm and, in addition, a knowledge component called the belief space.</li>
</ul>
<ul>
<li><a href="Differential_Search_Algorithm" title="wikilink">Differential Search Algorithm</a> (DS) inspired by migration of superorganisms.<a class="footnoteRef" href="#fn94" id="fnref94"><sup>94</sup></a></li>
</ul>
<ul>
<li><a href="Gaussian_adaptation" title="wikilink">Gaussian adaptation</a> (normal or natural adaptation, abbreviated NA to avoid confusion with GA) is intended for the maximisation of manufacturing yield of signal processing systems. It may also be used for ordinary parametric optimisation. It relies on a certain theorem valid for all regions of acceptability and all Gaussian distributions. The efficiency of NA relies on information theory and a certain theorem of efficiency. Its efficiency is defined as information divided by the work needed to get the information.<a class="footnoteRef" href="#fn95" id="fnref95"><sup>95</sup></a> Because NA maximises mean fitness rather than the fitness of the individual, the landscape is smoothed such that valleys between peaks may disappear. Therefore it has a certain “ambition” to avoid local peaks in the fitness landscape. NA is also good at climbing sharp crests by adaptation of the moment matrix, because NA may maximise the disorder (<a href="average_information" title="wikilink">average information</a>) of the Gaussian simultaneously keeping the <a href="mean_fitness" title="wikilink">mean fitness</a> constant.</li>
</ul>
<h4 id="other-metaheuristic-methods">Other metaheuristic methods</h4>

<p>Metaheuristic methods broadly fall within <a href="Stochastic_optimization" title="wikilink">stochastic</a> optimisation methods.</p>
<ul>
<li><a href="Simulated_annealing" title="wikilink">Simulated annealing</a> (SA) is a related global optimization technique that traverses the search space by testing random mutations on an individual solution. A mutation that increases fitness is always accepted. A mutation that lowers fitness is accepted probabilistically based on the difference in fitness and a decreasing temperature parameter. In SA parlance, one speaks of seeking the lowest energy instead of the maximum fitness. SA can also be used within a standard GA algorithm by starting with a relatively high rate of mutation and decreasing it over time along a given schedule.</li>
</ul>
<ul>
<li><a href="Tabu_search" title="wikilink">Tabu search</a> (TS) is similar to simulated annealing in that both traverse the solution space by testing mutations of an individual solution. While simulated annealing generates only one mutated solution, tabu search generates many mutated solutions and moves to the solution with the lowest energy of those generated. In order to prevent cycling and encourage greater movement through the solution space, a tabu list is maintained of partial or complete solutions. It is forbidden to move to a solution that contains elements of the tabu list, which is updated as the solution traverses the solution space.</li>
</ul>
<ul>
<li><a href="Extremal_optimization" title="wikilink">Extremal optimization</a> (EO) Unlike GAs, which work with a population of candidate solutions, EO evolves a single solution and makes <a href="local_search_(optimization)" title="wikilink">local</a> modifications to the worst components. This requires that a suitable representation be selected which permits individual solution components to be assigned a quality measure ("fitness"). The governing principle behind this algorithm is that of <em>emergent</em> improvement through selectively removing low-quality components and replacing them with a randomly selected component. This is decidedly at odds with a GA that selects good solutions in an attempt to make better solutions.</li>
</ul>
<h4 id="other-stochastic-optimisation-methods">Other stochastic optimisation methods</h4>
<ul>
<li>The <a href="Cross-entropy_method" title="wikilink">cross-entropy (CE) method</a> generates candidates solutions via a parameterized probability distribution. The parameters are updated via cross-entropy minimization, so as to generate better samples in the next iteration.</li>
</ul>
<ul>
<li><a href="Reactive_search_optimization" title="wikilink">Reactive search optimization</a> (RSO) advocates the integration of sub-symbolic machine learning techniques into search heuristics for solving complex optimization problems. The word reactive hints at a ready response to events during the search through an internal online feedback loop for the self-tuning of critical parameters. Methodologies of interest for Reactive Search include machine learning and statistics, in particular reinforcement learning, active or query learning, neural networks, and meta-heuristics.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="List_of_genetic_algorithm_applications" title="wikilink">List of genetic algorithm applications</a></li>
<li><a href="particle_filter" title="wikilink">Genetic algorithms in signal processing (a.k.a. particle filters)</a></li>
<li><a href="Propagation_of_schema" title="wikilink">Propagation of schema</a></li>
<li><a href="Universal_Darwinism" title="wikilink">Universal Darwinism</a></li>
<li><a class="uri" href="Metaheuristics" title="wikilink">Metaheuristics</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="bibliography">Bibliography</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>Rechenberg, Ingo (1994): Evolutionsstrategie '94, Stuttgart: Fromman-Holzboog.</li>
<li>Schmitt, Lothar M; Nehaniv, Chrystopher L; Fujii, Robert H (1998), <em>Linear analysis of genetic algorithms</em>, Theoretical Computer Science 208: 111–148</li>
<li>Schmitt, Lothar M (2001), <em>Theory of Genetic Algorithms</em>, Theoretical Computer Science 259: 1–61</li>
<li>Schmitt, Lothar M (2004), <em>Theory of Genetic Algorithms II: models for genetic operators over the string-tensor representation of populations and convergence to global optima for arbitrary fitness function under scaling</em>, Theoretical Computer Science 310: 181–231</li>
<li>Schwefel, Hans-Paul (1974): Numerische Optimierung von Computer-Modellen (PhD thesis). Reprinted by Birkhäuser (1977).</li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<h3 id="resources">Resources</h3>
<ul>
<li><a href="http://www.geneticprogramming.com/ga/index.htm">Genetic Algorithms Index</a> Provides a list of resources in the genetic algorithms field</li>
</ul>
<h3 id="tutorials">Tutorials</h3>
<ul>
<li><a href="http://www2.econ.iastate.edu/tesfatsi/holland.gaintro.htm">Genetic Algorithms Computer "evolve" in ways that resemble natural selection can solve complex problems even their creators do not fully understand</a> An excellent introduction to GA by John Holland and with an application to the Prisoner's Dilemma</li>
<li><a href="http://userweb.eng.gla.ac.uk/yun.li/ga_demo/">An online interactive GA tutorial for a reader to practise or learn how a GA works</a>: Learn step by step or watch global convergence in batch, change the population size, crossover rates/bounds, mutation rates/bounds and selection mechanisms, and add constraints.</li>
<li><a href="http://samizdat.mines.edu/ga_tutorial/ga_tutorial.ps">A Genetic Algorithm Tutorial by Darrell Whitley Computer Science Department Colorado State University</a> An excellent tutorial with lots of theory</li>
<li><a href="http://cs.gmu.edu/~sean/book/metaheuristics/">"Essentials of Metaheuristics"</a>, 2009 (225 p). Free open text by Sean Luke.</li>
<li><a href="http://www.it-weise.de/projects/book.pdf">Global Optimization Algorithms – Theory and Application</a></li>
</ul>

<p><a href="de:Genetische_Algorithmen" title="wikilink">de:Genetische Algorithmen</a> <a href="sv:Genetisk_programmering#Genetisk_algoritm" title="wikilink">sv:Genetisk programmering#Genetisk algoritm</a>"</p>

<p><a href="Category:Genetic_algorithms" title="wikilink"> </a> <a href="Category:Mathematical_optimization" title="wikilink">Category:Mathematical optimization</a> <a href="Category:Optimization_algorithms_and_methods" title="wikilink">Category:Optimization algorithms and methods</a> <a href="Category:Search_algorithms" title="wikilink">Category:Search algorithms</a> <a class="uri" href="Category:Cybernetics" title="wikilink">Category:Cybernetics</a> <a href="Category:Digital_organisms" title="wikilink">Category:Digital organisms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">Eiben, A. E. et al (1994). "Genetic algorithms with multi-parent recombination". PPSN III: Proceedings of the International Conference on Evolutionary Computation. The Third Conference on Parallel Problem Solving from Nature: 78–87. ISBN 3-540-58484-6.<a href="#fnref5">↩</a></li>
<li id="fn6">Ting, Chuan-Kang (2005). "On the Mean Convergence Time of Multi-parent Genetic Algorithms Without Selection". Advances in Artificial Life: 403–412. ISBN 978-3-540-28848-0.<a href="#fnref6">↩</a></li>
<li id="fn7">Akbari, Ziarati (2010). "A multilevel evolutionary algorithm for optimizing numerical functions" IJIEC 2 (2011): 419–430 <a href="http://growingscience.com/ijiec/Vol2/IJIEC_2010_11.pdf">1</a><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22">Wolpert, D.H., Macready, W.G., 1995. No Free Lunch Theorems for Optimisation. Santa Fe Institute, SFI-TR-05-010, Santa Fe.<a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=286385">Srinivas. M and Patnaik. L, "Adaptive probabilities of crossover and mutation in genetic algorithms," IEEE Transactions on System, Man and Cybernetics, vol.24, no.4, pp.656–667, 1994.</a><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4220690">ZHANG. J, Chung. H and Lo. W. L, “Clustering-Based Adaptive Crossover and Mutation Probabilities for Genetic Algorithms”, IEEE Transactions on Evolutionary Computation vol.11, no.3, pp. 326–335, 2007.</a><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="http://web.telia.com/~u91131915/traveller.htm">Evolution-in-a-nutshell</a><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="http://www.complex-systems.com/issues/03-5.html">D.E. Goldberg, B. Korb, and K. Deb. "Messy genetic algorithms: Motivation, analysis, and first results". Complex Systems, 5(3):493–530, October 1989.</a><a href="#fnref30">↩</a></li>
<li id="fn31">Gene expression: The missing link in evolutionary computation<a href="#fnref31">↩</a></li>
<li id="fn32"><a href="http://portal.acm.org/citation.cfm?id=269517">G. Harik. Learning linkage to efficiently solve problems of bounded difficulty using genetic algorithms. PhD thesis, Dept. Computer Science, University of Michigan, Ann Arbour, 1997</a><a href="#fnref32">↩</a></li>
<li id="fn33">Tomoiagă B, Chindriş M, Sumper A, Sudria-Andreu A, Villafafila-Robles R. <a href="http://www.mdpi.com/1996-1073/6/3/1439/pdf">Pareto Optimal Reconfiguration of Power Distribution Systems Using a Genetic Algorithm Based on NSGA-II.</a> Energies. 2013; 6(3):1439-1455.<a href="#fnref33">↩</a></li>
<li id="fn34"><a href="#fnref34">↩</a></li>
<li id="fn35"><a href="#fnref35">↩</a></li>
<li id="fn36"><a class="uri" href="http://goatstream.com/research/papers/SA2013/index.html">http://goatstream.com/research/papers/SA2013/index.html</a><a href="#fnref36">↩</a></li>
<li id="fn37"><a href="#fnref37">↩</a></li>
<li id="fn38"><a href="#fnref38">↩</a></li>
<li id="fn39"><a href="#fnref39">↩</a></li>
<li id="fn40"><a href="#fnref40">↩</a></li>
<li id="fn41"><a href="#fnref41">↩</a></li>
<li id="fn42"><a href="#fnref42">↩</a></li>
<li id="fn43"><a href="http://berkeley.edu/news/media/releases/96legacy/releases.96/14319.html">02.27.96 - UC Berkeley's Hans Bremermann, professor emeritus and pioneer in mathematical biology, has died at 69</a><a href="#fnref43">↩</a></li>
<li id="fn44"><a href="#fnref44">↩</a></li>
<li id="fn45"><a href="#fnref45">↩</a></li>
<li id="fn46"><a href="#fnref46">↩</a></li>
<li id="fn47"><a href="#fnref47">↩</a></li>
<li id="fn48"><a href="#fnref48">↩</a></li>
<li id="fn49"><a href="#fnref49">↩</a></li>
<li id="fn50"><a href="#fnref50">↩</a></li>
<li id="fn51">Ruggiero, Murray A.. (2009-08-01) [<a class="uri" href="http://www.futuresmag.com/2009/08/01/fifteen-years-and-counting?t=technology&amp;page">http://www.futuresmag.com/2009/08/01/fifteen-years-and-counting?t=technology&amp;page;</a>;=2 Fifteen years and counting]. Futuresmag.com. Retrieved on 2013-08-07.<a href="#fnref51">↩</a></li>
<li id="fn52"><a href="http://www.palisade.com/evolver/">Evolver: Sophisticated Optimization for Spreadsheets</a>. Palisade. Retrieved on 2013-08-07.<a href="#fnref52">↩</a></li>
<li id="fn53"></li>
<li id="fn54"><a href="#fnref54">↩</a></li>
<li id="fn55"><a href="#fnref55">↩</a></li>
<li id="fn56"><a href="#fnref56">↩</a></li>
<li id="fn57"><a href="#fnref57">↩</a></li>
<li id="fn58"><a href="#fnref58">↩</a></li>
<li id="fn59"><a href="#fnref59">↩</a></li>
<li id="fn60"><a href="#fnref60">↩</a></li>
<li id="fn61"></li>
<li id="fn62"><a href="#fnref62">↩</a></li>
<li id="fn63"><a href="#fnref63">↩</a></li>
<li id="fn64"><a href="#fnref64">↩</a></li>
<li id="fn65"><a href="#fnref65">↩</a></li>
<li id="fn66"></li>
<li id="fn67"><a href="#fnref67">↩</a></li>
<li id="fn68"></li>
<li id="fn69"></li>
<li id="fn70"></li>
<li id="fn71"></li>
<li id="fn72"></li>
<li id="fn73"></li>
<li id="fn74"></li>
<li id="fn75"></li>
<li id="fn76"></li>
<li id="fn77"></li>
<li id="fn78"></li>
<li id="fn79"><a href="#fnref79">↩</a></li>
<li id="fn80"></li>
<li id="fn81"></li>
<li id="fn82"><a href="#fnref82">↩</a></li>
<li id="fn83"></li>
<li id="fn84"><a href="#fnref84">↩</a></li>
<li id="fn85"><a href="#fnref85">↩</a></li>
<li id="fn86"><a href="#fnref86">↩</a></li>
<li id="fn87"><a href="#fnref87">↩</a></li>
<li id="fn88"><a href="#fnref88">↩</a></li>
<li id="fn89"><a href="#fnref89">↩</a></li>
<li id="fn90"><a href="#fnref90">↩</a></li>
<li id="fn91"><a href="#fnref91">↩</a></li>
<li id="fn92">Hamed Shah-Hosseini, The intelligent water drops algorithm: a nature-inspired swarm-based optimization algorithm, International Journal of Bio-Inspired Computation (IJBIC), vol. 1, no. ½, 2009, <a href="http://inderscience.metapress.com/media/g3t6qnluqp0uc9j3kg0v/contributions/a/4/0/6/a4065612210t6130.pdf">2</a><a href="#fnref92">↩</a></li>
<li id="fn93"><a href="#fnref93">↩</a></li>
<li id="fn94"><a href="#fnref94">↩</a></li>
<li id="fn95"><a href="#fnref95">↩</a></li>
</ol>
</section>
</body>
</html>
