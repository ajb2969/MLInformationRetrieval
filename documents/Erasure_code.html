<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1810">Erasure code</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Erasure code</h1>
<hr/>

<p>In <a href="information_theory" title="wikilink">information theory</a>, an <strong>erasure code</strong> is a <a href="forward_error_correction" title="wikilink">forward error correction</a> (FEC) code for the <a href="binary_erasure_channel" title="wikilink">binary erasure channel</a>, which transforms a message of <em>k</em> symbols into a longer message (code word) with <em>n</em> symbols such that the original message can be recovered from a subset of the <em>n</em> symbols. The fraction <em>r</em> = <em>k</em>/<em>n</em> is called the <a href="code_rate" title="wikilink">code rate</a>, the fraction <em>k’/k</em>, where <em>k’</em> denotes the number of symbols required for recovery, is called <a href="reception_efficiency" title="wikilink">reception efficiency</a>.</p>
<h2 id="optimal-erasure-codes">Optimal erasure codes</h2>

<p>Optimal erasure codes have the property that any <em>k</em> out of the <em>n</em> code word symbols are sufficient to recover the original message (i.e., they have optimal reception efficiency). Optimal erasure codes are <a href="Maximum_distance_separable_code#MDS_codes" title="wikilink">maximum distance separable codes</a> (MDS codes).</p>

<p>Optimal codes are often costly (in terms of memory usage, CPU time, or both) when <em>n</em> is large. Except for very simple schemes, practical solutions usually have quadratic encoding and decoding <a href="Computational_complexity_theory" title="wikilink">complexity</a>. In 2014, Lin et al. <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> gave an approach with 

<math display="inline" id="Erasure_code:0">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n\log n)
  </annotation>
 </semantics>
</math>

 operations.</p>
<h3 id="parity-check">Parity check</h3>

<p>Parity check is the special case where <em>n</em> = <em>k</em> + 1. From a set of <em>k</em> values 

<math display="inline" id="Erasure_code:1">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>v</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mn>1</mn>
    <mo>≤</mo>
    <mi>i</mi>
    <mo>≤</mo>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
    </set>
    <apply>
     <and></and>
     <apply>
      <leq></leq>
      <cn type="integer">1</cn>
      <ci>i</ci>
     </apply>
     <apply>
      <leq></leq>
      <share href="#.cmml">
      </share>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{v_{i}\}_{1\leq i\leq k}
  </annotation>
 </semantics>
</math>

, a checksum is computed and appended to the <em>k</em> source values:</p>

<p>

<math display="block" id="Erasure_code:2">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>v</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>k</mi>
      </munderover>
      <msub>
       <mi>v</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{k+1}=-\sum_{i=1}^{k}v_{i}.
  </annotation>
 </semantics>
</math>

 The set of <em>k</em> + 1 values 

<math display="inline" id="Erasure_code:3">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>v</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mn>1</mn>
    <mo>≤</mo>
    <mi>i</mi>
    <mo>≤</mo>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
    </set>
    <apply>
     <and></and>
     <apply>
      <leq></leq>
      <cn type="integer">1</cn>
      <ci>i</ci>
     </apply>
     <apply>
      <leq></leq>
      <share href="#.cmml">
      </share>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{v_{i}\}_{1\leq i\leq k+1}
  </annotation>
 </semantics>
</math>


 is now consistent with regard to the checksum. If one of these values, 

<math display="inline" id="Erasure_code:4">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{e}
  </annotation>
 </semantics>
</math>

, is erased, it can be easily recovered by summing the remaining variables:</p>

<p>

<math display="block" id="Erasure_code:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>v</mi>
     <mi>e</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mo>,</mo>
        <mrow>
         <mi>i</mi>
         <mo>≠</mo>
         <mi>e</mi>
        </mrow>
       </mrow>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </munderover>
      <msub>
       <mi>v</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>e</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <csymbol cd="ambiguous">formulae-sequence</csymbol>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <neq></neq>
          <ci>i</ci>
          <ci>e</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{e}=-\sum_{i=1,i\neq e}^{k+1}v_{i}.
  </annotation>
 </semantics>
</math>

</p>
<h3 id="polynomial-oversampling">Polynomial oversampling</h3>

<p>====Example: Err-mail (<em>k</em> = 2)==== In the simple case where <em>k</em> = 2, redundancy symbols may be created by sampling different points along the line between the two original symbols. This is pictured with a simple example, called err-mail:</p>

<p><a href="Alice_and_Bob" title="wikilink">Alice</a> wants to send her telephone number (555629) to <a href="Alice_and_Bob" title="wikilink">Bob</a> using err-mail. Err-mail works just like e-mail, except</p>
<ol>
<li>About half of all the mail gets lost.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></li>
<li>Messages longer than 5 characters are illegal.</li>
<li>It is very expensive (similar to air-mail).</li>
</ol>

<p>Instead of asking Bob to acknowledge the messages she sends, Alice devises the following scheme.</p>
<ol>
<li>She breaks her telephone number up into two parts <em>a</em> = 555, <em>b</em> = 629, and sends 2 messages – "<em>A</em> = 555" and "<em>B</em> = 629" – to Bob.</li>
<li>She constructs a linear function, 

<math display="inline" id="Erasure_code:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>a</mi>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>b</mi>
       <mo>-</mo>
       <mi>a</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>a</ci>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>b</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(i)=a+(b-a)(i-1)
  </annotation>
 </semantics>
</math>

, in this case 

<math display="inline" id="Erasure_code:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>555</mn>
    <mo>+</mo>
    <mrow>
     <mn>74</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <plus></plus>
     <cn type="integer">555</cn>
     <apply>
      <times></times>
      <cn type="integer">74</cn>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(i)=555+74(i-1)
  </annotation>
 </semantics>
</math>

, such that 

<math display="inline" id="Erasure_code:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>555</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">555</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(1)=555
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Erasure_code:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>629</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">629</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(2)=629
  </annotation>
 </semantics>
</math>

.</li>
</ol>
<figure><b>(Figure)</b>
<figcaption>Optimal Erasure Codes1.gif</figcaption>
</figure>
<ol>
<li>She computes the values <em>f</em>(3), <em>f</em>(4), and <em>f</em>(5), and then transmits three redundant messages: "C = 703", "D = 777" and "E = 851".</li>
</ol>

<p>Bob knows that the form of <em>f</em>(<em>k</em>) is 

<math display="inline" id="Erasure_code:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>a</mi>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>b</mi>
       <mo>-</mo>
       <mi>a</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>a</ci>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>b</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(i)=a+(b-a)(i-1)
  </annotation>
 </semantics>
</math>

, where <em>a</em> and <em>b</em> are the two parts of the telephone number. Now suppose Bob receives "D = 777" and "E = 851".</p>
<figure><b>(Figure)</b>
<figcaption>Optimal Erasure Codes2.gif</figcaption>
</figure>

<p>Bob can reconstruct Alice's phone number by computing the values of <em>a</em> and <em>b</em> from the values (<em>f</em>(4) and <em>f</em>(5)) he has received. Bob can perform this procedure using any two err-mails, so the erasure code in this example has a rate of 40%.</p>

<p>Note that Alice cannot encode her telephone number in just one err-mail, because it contains six characters, and the maximum length of one err-mail message is five characters. If she sent her phone number in pieces, asking Bob to acknowledge receipt of each piece, at least four messages would have to be sent anyway (two from Alice, and two acknowledgments from Bob). So the erasure code in this example, which requires five messages, is quite economical.</p>

<p>This example is a little bit contrived. For truly generic erasure codes that work over any data set, we would need something other than the <em>f</em>(<em>i</em>) given.</p>
<h4 id="general-case">General case</h4>

<p>The linear construction above can be generalized to <a href="polynomial_interpolation" title="wikilink">polynomial interpolation</a>. Additionally, points are now computed over a <a href="finite_field" title="wikilink">finite field</a>.</p>

<p>First we choose a finite field <em>F</em> with order of at least <em>n</em>, but usually a power of 2. The sender numbers the data symbols from 0 to <em>k</em> − 1 and sends them. He then constructs a <a href="Lagrange_polynomial" title="wikilink">(Lagrange) polynomial</a> <em>p</em>(<em>x</em>) of order <em>k</em> such that <em>p</em>(<em>i</em>) is equal to data symbol <em>i</em>. He then sends <em>p</em>(<em>k</em>), ..., <em>p</em>(<em>n</em> − 1). The receiver can now also use polynomial interpolation to recover the lost packets, provided he receives <em>k</em> symbols successfully. If the order of <em>F</em> is less than 2<sup><em>b</em></sup>, where b is the number of bits in a symbol, then multiple polynomials can be used.</p>

<p>The sender can construct symbols <em>k</em> to <em>n</em> − 1 'on the fly', i.e., distribute the workload evenly between transmission of the symbols. If the receiver wants to do his calculations 'on the fly', he can construct a new polynomial <em>q</em>, such that <em>q</em>(<em>i</em>) = <em>p</em>(<em>i</em>) if symbol <em>i</em> 0). Reducing ε can be done at the cost of CPU time. <em>Near-optimal erasure codes</em> trade correction capabilities for computational complexity: practical algorithms can encode and decode with linear time complexity.</p>

<p><a href="Fountain_code" title="wikilink">Fountain codes</a> (also known as <em>rateless erasure codes</em>) are notable examples of <em>near-optimal erasure codes</em>. They can transform a <em>k</em> symbol message into a practically infinite encoded form, i.e., they can generate an arbitrary amount of redundancy symbols that can all be used for error correction. Receivers can start decoding after they have received slightly more than <em>k</em> encoded symbols.</p>

<p><a href="Regenerating_code" title="wikilink">Regenerating codes</a> address the issue of rebuilding (also called repairing) lost encoded fragments from existing encoded fragments. This issue arises in distributed storage systems where communication to maintain encoded redundancy is a problem.</p>
<h2 id="examples">Examples</h2>
<h3 id="near-optimal-erasure-codes">Near optimal erasure codes</h3>
<ul>
<li><a href="Tornado_codes" title="wikilink">Tornado codes</a></li>
<li><a href="Low-density_parity-check_codes" title="wikilink">Low-density parity-check codes</a></li>
</ul>
<h3 id="near-optimal-fountain-rateless-erasure-codes">Near optimal fountain (rateless erasure) codes</h3>
<ul>
<li><a href="Online_codes" title="wikilink">Online codes</a></li>
<li><a href="LT_codes" title="wikilink">LT codes</a></li>
<li><a href="Raptor_codes" title="wikilink">Raptor codes</a></li>
</ul>
<h3 id="optimal-erasure-codes-1">Optimal erasure codes</h3>
<ul>
<li><a href="Parity_(telecommunication)" title="wikilink">Parity</a>: used in <a class="uri" href="RAID" title="wikilink">RAID</a> storage systems.</li>
<li><a class="uri" href="Parchive" title="wikilink">Parchive</a></li>
<li><a class="uri" href="Tahoe-LAFS" title="wikilink">Tahoe-LAFS</a> includes <a href="https://pypi.python.org/pypi/zfec">zfec</a></li>
<li><a href="Reed–Solomon" title="wikilink">Reed–Solomon coding</a></li>
<li><a href="http://switzernet.com/people/emin-gabrielyan/051103-erasure-9-5-resilient/">Erasure Resilient Systematic Code</a>, an MDS code outperforming Reed–Solomon in the maximal number of redundant packets, see <a href="http://switzernet.com/people/emin-gabrielyan/051025-erasure-resilient/">RS(4,2) with 2 bits</a> or <a href="http://switzernet.com/people/emin-gabrielyan/051027-erasure-9-2-resilient/">RS(9,2) with 3 bits</a></li>
<li><a href="Regenerating_Codes" title="wikilink">Regenerating Codes</a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> see also <a href="http://csi.usc.edu/~dimakis/StorageWiki">1</a>.</li>
<li>any other <a href="Maximum_distance_separable_code#MDS_codes" title="wikilink">MDS code</a></li>
</ul>
<h3 id="other">Other</h3>
<ul>
<li><a href="Spelling_alphabet" title="wikilink">Spelling alphabet</a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Forward_error_correction" title="wikilink">Forward error correction</a> codes.</li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://jerasure.org/">Jerasure</a> is a Free Software library implementing Reed-Solomon and Cauchy erasure code techniques with SIMD optimisations.</li>
<li><a href="http://info.iet.unipi.it/~luigi/fec.html">Software FEC in computer communications</a> by Luigi Rizzo describes optimal erasure correction codes</li>
<li><a href="http://feclib.sourceforge.net">Feclib</a> is a near optimal extension to Luigi Rizzo's work that uses band matrices. Many parameters can be set, like the size of the width of the band and size of the finite field. It also successfully exploits the large <a href="Processor_register" title="wikilink">register</a> size of modern CPUs. How it compares to the near optimal codes mentioned above is unknown.</li>
<li><a href="http://storagewiki.ece.utexas.edu?id=wiki:definitions:repair_problem">Coding for Distributed Storage wiki</a> for regenerating codes and rebuilding erasure codes.</li>
</ul>

<p>"</p>

<p><a href="Category:Coding_theory" title="wikilink">Category:Coding theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Sian-Jheng Lin, Wei-Ho Chung, and Yunghsiang S. Han, "Novel polynomial basis and its application to Reed-Solomon erasure codes", The 55th Annual Symposium on Foundations of Computer Science (FOCS 2014). <a href="#fnref1">↩</a></li>
<li id="fn2">Some versions of this story refer to the err-mail daemon.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
