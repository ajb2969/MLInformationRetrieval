   Shamir's Secret Sharing      Shamir's Secret Sharing  table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */     Shamir's Secret Sharing is an algorithm in cryptography created by Adi Shamir . It is a form of secret sharing , where a secret is divided into parts, giving each participant its own unique part, where some of the parts or all of them are needed in order to reconstruct the secret.  Counting on all participants to combine together the secret might be impractical, and therefore sometimes the threshold scheme is used where any   k   k   k   of the parts are sufficient to reconstruct the original secret.  Mathematical definition  The goal is to divide secret   S   S   S   (e.g., a safe combination) into   n   n   n   pieces of data     S  1   ,  …  ,   S  n       subscript  S  1   normal-…   subscript  S  n     S_{1},\ldots,S_{n}   in such a way that:   Knowledge of any   k   k   k   or more    S  i     subscript  S  i    S_{i}   pieces makes   S   S   S   easily computable.  Knowledge of any    k  -  1      k  1    k-1   or fewer    S  i     subscript  S  i    S_{i}   pieces leaves   S   S   S   completely undetermined (in the sense that all its possible values are equally likely).   This scheme is called    (  k  ,  n  )     k  n    \left(k,n\right)   threshold scheme. If    k  =  n      k  n    k=n   then all participants are required to reconstruct the secret.  Shamir's secret-sharing scheme  The essential idea of Adi Shamir 's threshold scheme is that 2 points are sufficient to define a line , 3 points are sufficient to define a parabola , 4 points to define a cubic curve and so forth. That is, it takes   k   k   k\,\!   points to define a polynomial of degree     k  -  1      k  1    k-1\,\!   .  Suppose we want to use a    (  k  ,  n  )     k  n    \left(k,n\right)\,\!   threshold scheme to share our secret   S   S   S\,\!   , without loss of generality assumed to be an element in a finite field    F   F   F   of size   P   P   P   where    k  -  1      k  1    k-1\,\!   is a prime number.  Choose at random     a  1   ,  ⋯  ,   a   k  -  1        subscript  a  1   normal-⋯   subscript  a    k  1      a_{1},\cdots,a_{k-1}\,\!   positive integers     f   (  x  )    =    a  0   +    a  1   x   +    a  2    x  2    +    a  3    x  3    +  ⋯  +    a   k  -  1     x   k  -  1            f  x      subscript  a  0      subscript  a  1   x      subscript  a  2    superscript  x  2       subscript  a  3    superscript  x  3    normal-⋯     subscript  a    k  1     superscript  x    k  1        f\left(x\right)=a_{0}+a_{1}x+a_{2}x^{2}+a_{3}x^{3}+\cdots+a_{k-1}x^{k-1}\,\!   with   n   n   n\,\!   . Build the polynomial    i  =   1  ,  ⋯  ,  n       i   1  normal-⋯  n     i=1,\cdots,n\,\!   . Let us construct any    (  i  ,   f   (  i  )    )     i    f  i     \left(i,f\left(i\right)\right)\,\!   points out of it, for instance set   k   k   k\,\!   to retrieve    a  0     subscript  a  0    a_{0}\,\!   . Every participant is given a point (an integer input to the polynomial, and the corresponding integer output). Given any subset of    (   S  =  1234   )      S  1234    (S=1234)\,\!   of these pairs, we can find the coefficients of the polynomial using interpolation . The secret is the constant term    (   n  =  6   )      n  6    (n=6)\,\!   .  Usage  Example  The following example illustrates the basic idea. Note, however, that calculations in the example are done using integer arithmetic rather than using finite field arithmetic . Therefore the example below does not provide perfect secrecy and is not a true example of Shamir's scheme. So we'll explain this problem and show the right way to implement it (using finite field arithmetic).  Preparation  Suppose that our secret is 1234    (   k  =  3   )      k  3    (k=3)\,\!   .  We wish to divide the secret into 6 parts    k  -  1      k  1    k-1   , where any subset of 3 parts    (     a  1   =  166   ;    a  2   =  94    )     formulae-sequence     subscript  a  1   166      subscript  a  2   94     (a_{1}=166;a_{2}=94)\,\!   is sufficient to reconstruct the secret. At random we obtain two (     f   (  x  )    =   1234  +   166  x   +   94   x  2           f  x     1234    166  x     94   superscript  x  2       f\left(x\right)=1234+166x+94x^{2}\,\!   ) numbers: 166 and 94.       D   x  -  1    =   (  x  ,   f   (  x  )    )        subscript  D    x  1     x    f  x      D_{x-1}=(x,f(x))     Our polynomial to produce secret shares (points) is therefore:        D  0   =   (  1  ,  1494  )    ;     D  1   =   (  2  ,  1942  )    ;     D  2   =   (  3  ,  2578  )    ;     D  3   =   (  4  ,  3402  )    ;     D  4   =   (  5  ,  4414  )    ;    D  5   =   (  6  ,  5614  )           formulae-sequence     subscript  D  0    1  1494     formulae-sequence     subscript  D  1    2  1942     formulae-sequence     subscript  D  2    3  2578     formulae-sequence     subscript  D  3    4  3402     formulae-sequence     subscript  D  4    5  4414       subscript  D  5    6  5614          D_{0}=\left(1,1494\right);D_{1}=\left(2,1942\right);D_{2}=\left(3,2578\right);%
 D_{3}=\left(4,3402\right);D_{4}=\left(5,4414\right);D_{5}=\left(6,5614\right)\,\!     We construct 6 points   x   x   x\,\!   from the polynomial:      f   (  x  )       f  x    f\left(x\right)\,\!     We give each participant a different single point (both    D   x  -  1      subscript  D    x  1     D_{x-1}   and    D  x     subscript  D  x    D_{x}   ). Because we use    (  1  ,   f   (  1  )    )     1    f  1     (1,f(1))   instead of    (  0  ,   f   (  0  )    )     0    f  0     (0,f(0))   the points start from    (  0  ,   f   (  0  )    )     0    f  0     (0,f(0))   and not    S  =   f   (  0  )        S    f  0     S=f(0)   . This is necessary because if one would have      (   x  0   ,   y  0   )   =   (  2  ,  1942  )    ;     (   x  1   ,   y  1   )   =   (  4  ,  3402  )    ;    (   x  2   ,   y  2   )   =   (  5  ,  4414  )        formulae-sequence      subscript  x  0    subscript  y  0     2  1942     formulae-sequence      subscript  x  1    subscript  y  1     4  3402        subscript  x  2    subscript  y  2     5  4414       \left(x_{0},y_{0}\right)=\left(2,1942\right);\left(x_{1},y_{1}\right)=\left(4,%
 3402\right);\left(x_{2},y_{2}\right)=\left(5,4414\right)\,\!   he would also know the secret (     ℓ  0   =     x  -   x  1      x  0   -   x  1     ⋅    x  -   x  2      x  0   -   x  2      =     x  -  4    2  -  4    ⋅    x  -  5    2  -  5     =      1  6    x  2    -    3  2   x    +   10  3           subscript  normal-ℓ  0    normal-⋅      x   subscript  x  1       subscript  x  0    subscript  x  1         x   subscript  x  2       subscript  x  0    subscript  x  2            normal-⋅      x  4     2  4        x  5     2  5                  1  6    superscript  x  2        3  2   x      10  3       \ell_{0}=\frac{x-x_{1}}{x_{0}-x_{1}}\cdot\frac{x-x_{2}}{x_{0}-x_{2}}=\frac{x-4%
 }{2-4}\cdot\frac{x-5}{2-5}=\frac{1}{6}x^{2}-\frac{3}{2}x+\frac{10}{3}\,\!   )  Reconstruction  In order to reconstruct the secret any 3 points will be enough.  Let us consider     ℓ  1   =     x  -   x  0      x  1   -   x  0     ⋅    x  -   x  2      x  1   -   x  2      =     x  -  2    4  -  2    ⋅    x  -  5    4  -  5     =     -    1  2    x  2     +    7  2   x    -  5          subscript  normal-ℓ  1    normal-⋅      x   subscript  x  0       subscript  x  1    subscript  x  0         x   subscript  x  2       subscript  x  1    subscript  x  2            normal-⋅      x  2     4  2        x  5     4  5                    1  2    superscript  x  2         7  2   x    5      \ell_{1}=\frac{x-x_{0}}{x_{1}-x_{0}}\cdot\frac{x-x_{2}}{x_{1}-x_{2}}=\frac{x-2%
 }{4-2}\cdot\frac{x-5}{4-5}=-\frac{1}{2}x^{2}+\frac{7}{2}x-5\,\!   .  We will compute Lagrange basis polynomials :       ℓ  2   =     x  -   x  0      x  2   -   x  0     ⋅    x  -   x  1      x  2   -   x  1      =     x  -  2    5  -  2    ⋅    x  -  4    5  -  4     =      1  3    x  2    -   2  x    +   8  3           subscript  normal-ℓ  2    normal-⋅      x   subscript  x  0       subscript  x  2    subscript  x  0         x   subscript  x  1       subscript  x  2    subscript  x  1            normal-⋅      x  2     5  2        x  4     5  4                  1  3    superscript  x  2      2  x      8  3       \ell_{2}=\frac{x-x_{0}}{x_{2}-x_{0}}\cdot\frac{x-x_{1}}{x_{2}-x_{1}}=\frac{x-2%
 }{5-2}\cdot\frac{x-4}{5-4}=\frac{1}{3}x^{2}-2x+\frac{8}{3}\,\!        f   (  x  )    =    ∑   j  =  0   2      y  j   ⋅   ℓ  j     (  x  )           f  x     superscript   subscript     j  0    2      normal-⋅   subscript  y  j    subscript  normal-ℓ  j    x      f(x)=\sum_{j=0}^{2}y_{j}\cdot\ell_{j}(x)\,\!        =   1234  +   166  x   +   94   x  2         absent    1234    166  x     94   superscript  x  2       =1234+166x+94x^{2}\,\!     Therefore      S  =  1234      S  1234    S=1234\,\!      S   S   S     Recall that the secret is the free coefficient, which means that    D  i     subscript  D  i    D_{i}   , and we are done.  Problem  Although this method works fine, there is a security problem: Eve wins a lot of information about     D  0   =   (  1  ,  1494  )        subscript  D  0    1  1494     D_{0}=(1,1494)   with every     D  1   =   (  2  ,  1942  )        subscript  D  1    2  1942     D_{1}=(2,1942)   that she finds.  Suppose that she finds the 2 points    k  =  3      k  3    k=3   and   S   S   S   , she still doesn't have     n  =  6   ,    k  =  3   ,     f   (  x  )    =    a  0   +    a  1   x   +  …  +    a   k  -  1     x   k  -  1       ,     a  0   =  S   ,    a  i   ∈  ℕ         formulae-sequence    n  6    formulae-sequence    k  3    formulae-sequence      f  x      subscript  a  0      subscript  a  1   x   normal-…     subscript  a    k  1     superscript  x    k  1        formulae-sequence     subscript  a  0   S      subscript  a  i   ℕ        n=6,k=3,f(x)=a_{0}+a_{1}x+\dots+a_{k-1}x^{k-1},a_{0}=S,a_{i}\in\mathbb{N}   points so in theory she shouldn't have won anymore info about    S  ∈   [  1046  ,  1048  ,  …  ,  1342  ,  1344  ]       S   1046  1048  normal-…  1342  1344     S\in[1046,1048,\dots,1342,1344]   . But she combines the info from the 2 points with the public info     p  ∈  ℙ   :    p  >  S   ,   p  >  n       normal-:    p  ℙ    formulae-sequence    p  S     p  n      p\in\mathbb{P}:p>S,p>n   and she :   p   p   p   . She now only has 150 numbers to guess from instead of an infinite number of natural numbers.  Solution  This problem can be fixed by using finite field arithmetic in a field of size    a  i     subscript  a  i    a_{i}   .  This is in practice only a small change, it just means that we should choose a prime     a  0   =  S       subscript  a  0   S    a_{0}=S   that is bigger than the number of participants and every    (  x  ,    f   (  x  )       (   mod  p   )    )     x   annotated    f  x    pmod  p      (x,f(x)\;\;(\mathop{{\rm mod}}p))   (including    (  x  ,   f   (  x  )    )     x    f  x     (x,f(x))   ) and we have to calculate the points as   p   p   p   instead of   p   p   p   .  Since everyone who receives a point also has to know the value of   p   p   p   so it may be considered to be publicly known. Therefore, one should select a value for    p  >  S  ⇒  S  ∈   [  0  ,  1  ,  …  ,   p  -  2   ,   p  -  1   ]         p  S    normal-⇒    S        0  1  normal-…    p  2     p  1       p>S\Rightarrow{}S\in{[0,1,\dots,p-2,p-1]}   that is neither too low nor too high.  Low values of   p   p   p   are risky because Eve knows   S   S   S   , so the lower one sets   p   p   p   , the lower the number of possible values Eve has to guess from to get      f   (  x  )       (   mod  p   )    =   f   (  x  )         annotated    f  x    pmod  p      f  x     f(x)\;\;(\mathop{{\rm mod}}p)=f(x)   .  High values of   p   p   p   are risky because Eve knows that the chance for   S   S   S   increases with a higher    p  =  1613      p  1613    p=1613   , and she can use the procedure from the original problem to guess     f   (  x  )    =    1234  +   166  x   +   94   x  2     mod  1613         f  x    modulo    1234    166  x     94   superscript  x  2     1613     f\left(x\right)=1234+166x+94x^{2}\mod{1613}   (although now, instead of being sure of the 150 possible values, they merely have an increased chance of being valid compared to the other natural numbers).  For this example we choose     (  1  ,  1494  )   ;   (  2  ,  329  )   ;   (  3  ,  965  )   ;   (  4  ,  176  )   ;   (  5  ,  1188  )   ;   (  6  ,  775  )       1  1494    2  329    3  965    4  176    5  1188    6  775     \left(1,1494\right);\left(2,329\right);\left(3,965\right);\left(4,176\right);%
 \left(5,1188\right);\left(6,775\right)   , so our polynomial becomes    D  x     subscript  D  x    D_{x}   which gives the points   k   k   k     This time Eve doesn't win any info when she finds a     D  0   =   (  1  ,  1494  )        subscript  D  0    1  1494     D_{0}=\left(1,1494\right)   (until she has     D  1   =   (  2  ,  329  )        subscript  D  1    2  329     D_{1}=\left(2,329\right)   points).  Suppose again Eve again finds     n  =  6   ,    k  =  3   ,    p  =  1613   ,     f   (  x  )    =     a  0   +    a  1   x   +  …  +    a   k  -  1     x   k  -  1      mod  p    ,     a  0   =  S   ,    a  i   ∈  ℕ          formulae-sequence    n  6    formulae-sequence    k  3    formulae-sequence    p  1613    formulae-sequence      f  x    modulo     subscript  a  0      subscript  a  1   x   normal-…     subscript  a    k  1     superscript  x    k  1      p     formulae-sequence     subscript  a  0   S      subscript  a  i   ℕ         n=6,k=3,p=1613,f(x)=a_{0}+a_{1}x+\dots+a_{k-1}x^{k-1}\mod{p},a_{0}=S,a_{i}\in%
 \mathbb{N}   and    (    m  1   -   m  2    )       subscript  m  1    subscript  m  2     (m_{1}-m_{2})   , this time the public info is     m  2   >   m  1        subscript  m  2    subscript  m  1     m_{2}>m_{1}   so she:  This time she can't stop because    a  1     subscript  a  1    a_{1}   could be any integer (even negative if    [  448  ,  445  ,  442  ,  …  ]     448  445  442  normal-…    [448,445,442,...]   ) so there are an infinite amount of possible values for   1613   1613   1613   . She knows that   3   3   3   always decreases by 3 so if     a  1   ∈   [  1  ,  4  ,  7  ,  …  ]        subscript  a  1    1  4  7  normal-…     a_{1}\in[1,4,7,\dots]   was divisible by    (  k  ,  n  )     k  n    \left(k,n\right)\,\!   she could conclude   k   k   k\,\!   but because it's prime she can't even conclude that and so she didn't win any information.  Javascript example   var prime =  257 ;  /* Split number into the shares */  function  split (number , available , needed) {  var coef = [number ,  166 ,  94 ] , x , exp , c , accum , shares = [] ;  /* Normally, we use the line:  * for(c = 1, coef[0] = number; c < needed; c++) coef[c] = Math.floor(Math.random() * (prime  - 1));  * where (prime - 1) is the maximum allowable value.  * However, to follow this example, we hardcode the values:  * coef = [number, 166, 94];  * For production, replace the hardcoded value with the random loop  * For each share that is requested to be available, run through the formula plugging the corresponding coefficient  * The result is f(x), where x is the byte we are sharing (in the example, 1234)  */  for (x =  1 ; x <= available ; x ++ ) {  /* coef = [1234, 166, 94] which is 1234x^0 + 166x^1 + 94x^2 */  for (exp =  1 , accum = coef[ 0 ] ; exp < needed ; exp ++ ) accum = (accum + (coef[exp] * ( Math . pow (x , exp) % prime) % prime)) % prime ;  /* Store values as (1, 132), (2, 66), (3, 188), (4, 241), (5, 225) (6, 140) */ shares[x -  1 ] = [x , accum] ;  }  return shares ;  }  /* Gives the decomposition of the gcd of a and b.  Returns [x,y,z] such that x = gcd(a,b) and y*a + z*b = x */  function  gcdD (a , b) {  if (b ==  0 ) return [a ,  1 ,  0 ] ;  else  {  var n =  Math . floor (a/b) , c = a % b , r =  gcdD (b , c) ;  return [r[ 0 ] , r[ 2 ] , r[ 1 ] - r[ 2 ] * n] ;  }  }  /* Gives the multiplicative inverse of k mod prime.  In other words (k * modInverse(k)) % prime = 1 for all prime > k >= 1  */  function  modInverse (k) { k = k % prime ;  var r = (k <  0 ) ?  - gcdD (prime ,- k)[ 2 ] : gcdD (prime , k)[ 2 ] ;  return (prime + r) % prime ;  }  /* Join the shares into a number */  function  join (shares) {  var accum , count , formula , startposition , nextposition , value , numerator , denominator ;  for (formula = accum =  0 ; formula <  shares . length ; formula ++ ) {  /* Multiply the numerator across the top and denominators across the bottom to do Lagrange's interpolation  * Result is x0(2), x1(4), x2(5) -> -4*-5 and (2-4=-2)(2-5=-3), etc for l0, l1, l2...  */  for (count =  0 , numerator = denominator =  1 ; count <  shares . length ; count ++ ) {  if (formula == count) continue ;  // If not the same value startposition = shares[formula][ 0 ] ; nextposition = shares[count][ 0 ] ; numerator = (numerator *  - nextposition) % prime ; denominator = (denominator * (startposition - nextposition)) % prime ;  } value = shares[formula][ 1 ] ; accum = (prime + accum + (value * numerator *  modInverse (denominator))) % prime ;  }  return accum ;  }  var sh =  split ( 129 ,  6 ,  3 ) /* split the secret value 129 into 6 components - at least 3 of which will be needed to figure out the secret value */  var newshares = [sh[ 1 ] , sh[ 3 ] , sh[ 4 ]] ;  /* pick any selection of 3 shared keys from sh */  alert ( join (newshares)) ;   Properties  Some of the useful properties of Shamir's    D  i     subscript  D  i    D_{i}\,\!   threshold scheme are:   Secure : Information theoretic security .  Minimal : The size of each piece does not exceed the size of the original data.  Extensible : When $k\,\!$ is kept fixed, $D_i\,\!$ pieces can be dynamically added or deleted without affecting the other pieces.  Dynamic : Security can be easily enhanced without changing the secret, but by changing the polynomial occasionally (keeping the same free term) and constructing new shares to the participants.  Flexible : In organizations where hierarchy is important, we can supply each participant different number of pieces according to their importance inside the organization. For instance, the president can unlock the safe alone, whereas 3 secretaries are required together to unlock it.   See also   Secret sharing  Lagrange polynomial  Homomorphic secret sharing - A simplistic decentralized voting protocol.  Two-man rule  Partial Password   References    .     .     .     .   External links   A proper Javascript implementation of Shamir's secret sharing scheme with open source (MIT) license  ssss: An open source (GPL) implementation of Shamir's Scheme with online demo  An open source (GPL) perl implementation of Shamir's Secret Sharing  Secret Sharp: An open source (GPL) implementation of Shamir's Scheme for windows  Christophe David's web based implementation of Shamir's scheme 'How to share a Secret'  Shamir's Secret Sharing in Java : An open source (LGPL) implementation of Shamir's scheme in Java  An open source implementation of the Shamir's Secret Sharing as open Web application, augmented by additional security features  libgfshare: a secret sharing library in GF(2**8), opensource (MIT)  Web implementation of Shamir's method  Java library implementation of multiple secret sharing methods, opensource(LGPLv2)   "  Category:Secret sharing  Category:Information-theoretically secure algorithms  