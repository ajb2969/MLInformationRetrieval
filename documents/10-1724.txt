   Heuristic function      Heuristic function   A heuristic function , or simply a heuristic , is a function that ranks alternatives in search algorithms at each branching step based on available information to decide which branch to follow.  Shortest paths  For example, for shortest path problems , a heuristic is a function ,    h   (  n  )       h  n    h(n)   defined on the nodes of a search tree , which serves as an estimate of the cost of the cheapest path from that node to the goal node. Heuristics are used by informed search algorithms such as Greedy best-first search and A* to choose the best node to explore. Greedy best-first search will choose the node that has the lowest value for the heuristic function. A* search will expand nodes that have the lowest value for     g   (  n  )    +   h   (  n  )          g  n     h  n     g(n)+h(n)   , where    g   (  n  )       g  n    g(n)   is the (exact) cost of the path from the initial state to the current node. If    h   (  n  )       h  n    h(n)   is admissible , i.e., if    h   (  n  )       h  n    h(n)   never overestimates the costs of reaching the goal, then A* will always find an optimal solution.  The classical problem involving heuristics is the n-puzzle . Commonly used heuristics for this problem include counting the number of misplaced tiles and finding the sum of the Manhattan distances between each block and its position in the goal configuration. Note that both are admissible.  Effect of heuristics on computational performance  In any searching problem where there are   b   b   b   choices at each node and a depth of   d   d   d   at the goal node, a naive searching algorithm would have to potentially search around    b  d     superscript  b  d    b^{d}   nodes before finding a solution. Heuristics improve the efficiency of search algorithms by reducing the branching factor from   b   b   b   to a lower constant    b  ′     superscript  b  normal-′    b^{\prime}   , using a cutoff mechanism. The branching factor can be used for defining a partial order on the heuristics, such that      h  1    (  n  )    <    h  2    (  n  )           subscript  h  1   n      subscript  h  2   n     h_{1}(n)   if     h  1    (  n  )        subscript  h  1   n    h_{1}(n)   has a lower branch factor than     h  2    (  n  )        subscript  h  2   n    h_{2}(n)   for a given node   n   n   n   of the search tree. Heuristics giving lower branching factors at every node in the search tree are preferred for the resolution of a particular problem, as they are more computationally efficient.  There is a useful and usually considered partial order on admissible heuristics where     h  1   ≤   h  2        subscript  h  1    subscript  h  2     h_{1}\leq h_{2}   if     h   (  n  )    ≤    h  ′    (  n  )          h  n      superscript  h  normal-′   n     h(n)\leq h^{\prime}(n)   for every state n. Thus the true cost is greatest element, and the zero heuristic is the least element in this partial order. If     h  1   ≤   h  2        subscript  h  1    subscript  h  2     h_{1}\leq h_{2}   , then the A* search using    h  2     subscript  h  2    h_{2}   will have better performance than using    h  1     subscript  h  1    h_{1}   .  Finding heuristics  The problem of finding an admissible heuristic with a low branching factor for common search tasks has been extensively researched in the artificial intelligence community. Several common techniques are used:   Solution costs of sub-problems often serve as useful estimates of the overall solution cost. These are always admissible. For example, a heuristic for a 10-puzzle might be the cost of moving tiles 1-5 into their correct places. A common idea is to use a pattern database that stores the exact solution cost of every subproblem instance.    The solution of a relaxed problem often serves as a useful admissible estimate of the original. For example, Manhattan distance is a relaxed version of the n-puzzle problem, because we assume we can move each tile to its position independently of moving the other tiles.    Given a set of admissible heuristic functions      h  1    (  n  )    ,    h  2    (  n  )    ,  …  ,    h  i    (  n  )          subscript  h  1   n      subscript  h  2   n   normal-…     subscript  h  i   n     h_{1}(n),h_{2}(n),...,h_{i}(n)   , the function     h   (  n  )    =   max   {    h  1    (  n  )    ,    h  2    (  n  )    ,  …  ,    h  i    (  n  )    }          h  n        subscript  h  1   n      subscript  h  2   n   normal-…     subscript  h  i   n      h(n)=\max\{h_{1}(n),h_{2}(n),...,h_{i}(n)\}   is an admissible heuristic that dominates all of them.   Using these techniques a program called ABSOLVER was written (1993) by A.E. Prieditis for automatically generating heuristics for a given problem 1 ". ABSOLVER generated a new heuristic for the 8-puzzle better than any pre-existing heuristic and found the first useful heuristic for solving the Rubik's Cube . 2  Consistency and Admissibility  If a Heuristic function never overestimates the cost reaching to goal, then it is called an Admissible heuristic function.  A heuristic    h   (  n  )       h  n    h(n)   is consistent if      h   (  n  )    -   h   (   n  ′   )     ≤   c   (  n  ,   n  ′   )            h  n     h   superscript  n  normal-′       c   n   superscript  n  normal-′       h(n)-h(n^{\prime})\leq c(n,n^{\prime})   for any successor state    n  ′     superscript  n  normal-′    n^{\prime}   , where    c   (  n  ,   n  ′   )       c   n   superscript  n  normal-′      c(n,n^{\prime})   is the actual cost of going from   n   n   n   to    n  ′     superscript  n  normal-′    n^{\prime}   . Thus the value of the sum "total cost so far + heuristic estimate of the cost left" (which is the one used in A* search) is non-decreasing along any path.  Any consistent heuristic with     h   (   g  o  a  l   )    =  0        h    g  o  a  l    0    h(goal)=0   is admissible, and any heuristic obtained by solving a relaxed problem is consistent (as      h   (  n  )    -   h   (   n  ′   )     ≤    c  relaxed    (  n  ,   n  ′   )    ≤   c   (  n  ,   n  ′   )              h  n     h   superscript  n  normal-′        subscript  c  relaxed    n   superscript  n  normal-′            c   n   superscript  n  normal-′        h(n)-h(n^{\prime})\leq c_{\mathrm{relaxed}}(n,n^{\prime})\leq c(n,n^{\prime})   ).  Example  (Figure)  8puzzle example   One might be interested in finding a heuristic to estimate the number of steps required to solve an 8-puzzle from a given state. Two simple heuristic functions are:      h  1     subscript  h  1    h_{1}   = the number of misplaced tiles. This is also known as the Hamming Distance . In the pictured example, the start state has    h  1     subscript  h  1    h_{1}   = 8. Clearly,    h  1     subscript  h  1    h_{1}   is an admissible heuristic because any tile that is out of place will have to be moved at least once.      h  2     subscript  h  2    h_{2}   = the sum of the distances of the tiles from their goal positions. Because tiles cannot be moved diagonally, the distance counted is the sum of horizontal and vertical distances. This is also known as the Manhattan Distance . In the pictured example, the start state has    h  2     subscript  h  2    h_{2}   = 3 + 1 + 2 + 2 + 2 + 3 + 3 + 2 = 18. Clearly,    h  2     subscript  h  2    h_{2}   is also an admissible heuristic because any move can, at best, move one tile one step closer to the goal.  As expected, neither heuristic overestimates the true number of moves required to solve the puzzle, which is 26 (    h  1     subscript  h  1    h_{1}   +    h  2     subscript  h  2    h_{2}   ). Additionally, it is easy to see from the definitions of the heuristic functions that for any given state,    h  2     subscript  h  2    h_{2}   will always be greater than or equal to    h  1     subscript  h  1    h_{1}   . Thus, we can say that    h  2     subscript  h  2    h_{2}   dominates    h  1     subscript  h  1    h_{1}   .  (example taken from Russell and Norvig)  See also   Heuristic algorithm  Artificial intelligence  Consistent heuristic  Expert system  Heuristic evaluation  Inference engine  Inquiry  Problem solving  Admissible heuristic   References      —Chapter 4   "  Category:Heuristics     ↩      