<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1832">Predicate functor logic</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Predicate functor logic</h1>
<hr/>

<p>In <a href="mathematical_logic" title="wikilink">mathematical logic</a>, <strong>predicate functor logic</strong> (<strong>PFL</strong>) is one of several ways to express <a href="first-order_logic" title="wikilink">first-order logic</a> (also known as <a href="predicate_logic" title="wikilink">predicate logic</a>) by purely algebraic means, i.e., without <a href="Quantification_(logic)" title="wikilink">quantified variables</a>. PFL employs a small number of algebraic devices called predicate functors (or predicate modifiers) that operate on terms to yield terms. PFL is mostly the invention of the <a href="logic" title="wikilink">logician</a> and <a class="uri" href="philosopher" title="wikilink">philosopher</a> <a href="Willard_Quine" title="wikilink">Willard Quine</a>.</p>
<h2 id="motivation">Motivation</h2>

<p>The source for this section, as well as for much of this entry, is Quine (1976). Quine proposed PFL as a way of algebraizing <a href="first-order_logic" title="wikilink">first-order logic</a> in a manner analogous to how <a href="Boolean_algebra_(logic)" title="wikilink">Boolean algebra</a> algebraizes <a href="propositional_logic" title="wikilink">propositional logic</a>. He designed PFL to have exactly the expressive power of <a href="first-order_logic" title="wikilink">first-order logic</a> with <a href="Identity_(mathematics)" title="wikilink">identity</a>. Hence the <a class="uri" href="metamathematics" title="wikilink">metamathematics</a> of PFL are exactly those of first-order logic with no interpreted predicate letters: both logics are <a href="consistency_proof" title="wikilink">sound</a>, <a href="Completeness_(logic)" title="wikilink">complete</a>, and <a href="undecidable_problem" title="wikilink">undecidable</a>. Most work Quine published on logic and mathematics in the last 30 years of his life touched on PFL in some way.</p>

<p>Quine took "functor" from the writings of his friend <a href="Rudolf_Carnap" title="wikilink">Rudolf Carnap</a>, the first to employ it in <a class="uri" href="philosophy" title="wikilink">philosophy</a> and <a href="mathematical_logic" title="wikilink">mathematical logic</a>, and defined it as follows:</p>
<blockquote>

<p>"The word <em>functor</em>, grammatical in import but logical in habitat... is a sign that attaches to one or more expressions of given grammatical kind(s) to produce an expression of a given grammatical kind." (Quine 1982: 129)</p>
</blockquote>

<p>Ways other than PFL to algebraize <a href="first-order_logic" title="wikilink">first-order logic</a> include:</p>
<ul>
<li><a href="Cylindric_algebra" title="wikilink">Cylindric algebra</a> by <a href="Alfred_Tarski" title="wikilink">Alfred Tarski</a> and his American students. The simplified cylindric algebra proposed in Bernays (1959) led Quine to write the paper containing the first use of the phrase "predicate functor";</li>
<li>The <a href="polyadic_algebra" title="wikilink">polyadic algebra</a> of <a href="Paul_Halmos" title="wikilink">Paul Halmos</a>. By virtue of its economical primitives and axioms, this algebra most resembles PFL;</li>
<li><a href="Relation_algebra" title="wikilink">Relation algebra</a> algebraizes the fragment of <a href="first-order_logic" title="wikilink">first-order logic</a> consisting of formulas having no atomic formula lying in the scope of more than three <a href="Quantifier_(logic)" title="wikilink">quantifiers</a>. That fragment suffices, however, for <a href="Peano_arithmetic" title="wikilink">Peano arithmetic</a> and the <a href="axiomatic_set_theory" title="wikilink">axiomatic set theory</a> <a class="uri" href="ZFC" title="wikilink">ZFC</a>; hence relation algebra, unlike PFL, is <a href="Gödel's_incompleteness_theorem" title="wikilink">incompletable</a>. Most work on relation algebra since about 1920 has been by Tarski and his American students. The power of relation algebra did not become manifest until the monograph Tarski and Givant (1987), published after the three important papers bearing on PFL, namely Bacon (1985), Kuhn (1983), and Quine (1976);</li>
<li><a href="Combinatory_logic" title="wikilink">Combinatory logic</a> builds on <a href="combinator" title="wikilink">combinators</a>, <a href="higher_order_function" title="wikilink">higher order functions</a> whose <a href="domain_(mathematics)" title="wikilink">domain</a> is another combinator or function, and whose <a href="range_(mathematics)" title="wikilink">range</a> is yet another combinator. Hence <a href="combinatory_logic" title="wikilink">combinatory logic</a> goes beyond first-order logic by having the expressive power of <a href="set_theory" title="wikilink">set theory</a>, which makes combinatory logic vulnerable to <a href="paradox" title="wikilink">paradoxes</a>. A predicate functor, on the other hand, simply maps predicates (also called <a href="Term_(mathematics)" title="wikilink">terms</a>) into predicates.</li>
</ul>

<p>PFL is arguably the simplest of these formalisms, yet also the one about which the least has been written.</p>

<p>Quine had a lifelong fascination with <a href="combinatory_logic" title="wikilink">combinatory logic</a>, attested to by his (1976) and his introduction to the translation in Van Heijenoort (1967) of the paper by the Russian logician <a href="Moses_Schönfinkel" title="wikilink">Moses Schönfinkel</a> founding combinatory logic. When Quine began working on PFL in earnest, in 1959, combinatory logic was commonly deemed a failure for the following reasons:</p>
<ul>
<li>Until <a href="Dana_Scott" title="wikilink">Dana Scott</a> began writing on the <a href="model_theory" title="wikilink">model theory</a> of combinatory logic in the late 1960s, almost only <a href="Haskell_Curry" title="wikilink">Haskell Curry</a>, his students, and <a href="Robert_Feys" title="wikilink">Robert Feys</a> in Belgium worked on that logic;</li>
<li>Satisfactory axiomatic formulations of combinatory logic were slow in coming. In the 1930s, some formulations of combinatory logic were found to be <a href="consistency_proof" title="wikilink">inconsistent</a>. Curry also discovered the <a href="Curry_paradox" title="wikilink">Curry paradox</a>, peculiar to combinatory logic;</li>
<li>The <a href="lambda_calculus" title="wikilink">lambda calculus</a>, with the same expressive power as <a href="combinatory_logic" title="wikilink">combinatory logic</a>, was seen as a superior formalism.</li>
</ul>
<h2 id="kuhns-formalization">Kuhn's formalization</h2>

<p>The PFL <a class="uri" href="syntax" title="wikilink">syntax</a>, primitives, and axioms described in this section are largely Kuhn's (1983). The <a class="uri" href="semantics" title="wikilink">semantics</a> of the functors are Quine's (1982). The rest of this entry incorporates some terminology from Bacon (1985).</p>
<h3 id="syntax">Syntax</h3>

<p>An <em>atomic term</em> is an upper case Latin letter, <em>I</em> and <em>S</em> excepted, followed by a numerical <a class="uri" href="superscript" title="wikilink">superscript</a> called its <em>degree</em>, or by concatenated lower case variables, collectively known as an <em>argument list</em>. The degree of a term conveys the same information as the number of variables following a predicate letter. An atomic term of degree 0 denotes a <a href="Boolean_variable" title="wikilink">Boolean variable</a> or a <a href="truth_value" title="wikilink">truth value</a>. The degree of <em>I</em> is invariably 2 and so is not indicated.</p>

<p>The "combinatory" (the word is Quine's) predicate functors, all monadic and peculiar to PFL, are <strong>Inv</strong>, <strong>inv</strong>, <strong>∃</strong>, <strong>+</strong>, and <strong>p</strong>. A term is either an atomic term, or constructed by the following recursive rule. If τ is a term, then <strong>Inv</strong>τ, <strong>inv</strong>τ, <strong>∃</strong>τ, <strong>+</strong>τ, and <strong>p</strong>τ are terms. A functor with a superscript <em>n</em>, <em>n</em> a <a href="natural_number" title="wikilink">natural number</a> &gt; 1, denotes <em>n</em> consecutive applications (iterations) of that functor.</p>

<p>A formula is either a term or defined by the recursive rule: if α and β are formulas, then αβ and ~(α) are likewise formulas. Hence "~" is another monadic functor, and concatenation is the sole dyadic predicate functor. Quine called these functors "alethic." The natural interpretation of "~" is <a class="uri" href="negation" title="wikilink">negation</a>; that of concatenation is any <a class="uri" href="connective" title="wikilink">connective</a> that, when combined with negation, forms a <a href="functional_completeness" title="wikilink">functionally complete</a> set of connectives. Quine's preferred functionally complete set was <a href="Logical_conjunction" title="wikilink">conjunction</a> and <a class="uri" href="negation" title="wikilink">negation</a>. Thus concatenated terms are taken as conjoined. The notation <strong>+</strong> is Bacon's (1985); all other notation is Quine's (1976; 1982). The alethic part of PFL is identical to the <em>Boolean term schemata</em> of Quine (1982).</p>

<p>As is well known, the two alethic functors could be replaced by a single dyadic functor with the following <a class="uri" href="syntax" title="wikilink">syntax</a> and <a class="uri" href="semantics" title="wikilink">semantics</a>: if α and β are formulas, then (αβ) is a formula whose semantics are "not (α and/or β)" (see <a href="Sheffer_stroke" title="wikilink">NAND</a> and <a href="Logical_NOR" title="wikilink">NOR</a>).</p>
<h3 id="axioms-and-semantics">Axioms and semantics</h3>

<p>Quine set out neither axiomatization nor proof procedure for PFL. The following axiomatization of PFL, one of two proposed in Kuhn (1983), is concise and easy to describe, but makes extensive use of <a href="free_variable" title="wikilink">free variables</a> and so does not do full justice to the spirit of PFL. Kuhn gives another axiomatization dispensing with free variables, but that is harder to describe and that makes extensive use of defined functors. Kuhn proved both of his PFL axiomatizations <a href="consistency_proof" title="wikilink">sound</a> and <a href="Completeness_(logic)" title="wikilink">complete</a>.</p>

<p>This section is built around the primitive predicate functors and a few defined ones. The alethic functors can be axiomatized by any set of axioms for <a href="sentential_logic" title="wikilink">sentential logic</a> whose primitives are negation and one of ∧ or ∨. Equivalently, all <a href="tautology_(logic)" title="wikilink">tautologies</a> of sentential logic can be taken as axioms.</p>

<p>Quine's (1982) semantics for each predicate functor are stated below in terms of <a class="uri" href="abstraction" title="wikilink">abstraction</a> (set builder notation), followed by either the relevant axiom from Kuhn (1983), or a definition from Quine (1976). The notation 

<math display="inline" id="Predicate_functor_logic:0">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>F</mi>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x_{1}...x_{n}:Fx_{1}...x_{n}\}
  </annotation>
 </semantics>
</math>

 denotes the set of <a href="n-tuple" title="wikilink">n-tuples</a> satisfying the atomic formula 

<math display="inline" id="Predicate_functor_logic:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Fx_{1}...x_{n}.
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li><em>Identity</em>, <em>I</em>, is defined as:</li>
</ul>

<p>

<math display="block" id="Predicate_functor_logic:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>I</mi>
     <mi>F</mi>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>↔</mo>
    <mrow>
     <mi>F</mi>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>↔</mo>
    <mrow>
     <mi>F</mi>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-↔</ci>
     <apply>
      <times></times>
      <ci>I</ci>
      <ci>F</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>F</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-↔</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>F</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   IFx_{1}x_{2}...x_{n}\leftrightarrow Fx_{1}x_{1}...x_{n}\leftrightarrow Fx_{2}x%
_{2}...x_{n}.
  </annotation>
 </semantics>
</math>

 Identity is <a href="reflexive_relation" title="wikilink">reflexive</a> (<em>Ixx</em>), <a class="uri" href="symmetric" title="wikilink">symmetric</a> (<em>Ixy</em>→<em>Iyx</em>), <a href="transitive_relation" title="wikilink">transitive</a> ( (<em>Ixy</em>∧<em>Iyz</em>) → <em>Ixz</em>), and obeys the substitution property:</p>

<p>

<math display="block" id="Predicate_functor_logic:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>F</mi>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mi mathvariant="italic">and</mi>
      <mi>I</mi>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>F</mi>
     <mi>y</mi>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <ci>italic- and</ci>
     <ci>I</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>y</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Fx_{1}...x_{n}\and Ix_{1}y)\rightarrow Fyx_{2}...x_{n}.
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li><em>Padding</em>, <strong>+</strong>, adds a variable to the left of any argument list.</li>
</ul>

<p>

<math display="block" id="Predicate_functor_logic:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo lspace="7.5pt">+</mo>
     <msup>
      <mi>F</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <msub>
     <mo>=</mo>
     <mrow>
      <mi>d</mi>
      <mi>e</mi>
      <mi>f</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>0</mn>
      </msub>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>:</mo>
     <mrow>
      <msup>
       <mi>F</mi>
       <mi>n</mi>
      </msup>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>F</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ +F^{n}=_{def}\{x_{0}x_{1}...x_{n}:F^{n}x_{1}...x_{n}\}.
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Predicate_functor_logic:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>+</mo>
     <mrow>
      <mi>F</mi>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </mrow>
    <mo>↔</mo>
    <mrow>
     <mi>F</mi>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>F</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   +Fx_{1}...x_{n}\leftrightarrow Fx_{2}...x_{n}.
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li><em>Cropping</em>, <strong>∃</strong>, erases the leftmost variable in any argument list.</li>
</ul>

<p>

<math display="block" id="Predicate_functor_logic:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\exist</mtext>
     </merror>
     <msup>
      <mi>F</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <msub>
     <mo>=</mo>
     <mrow>
      <mi>d</mi>
      <mi>e</mi>
      <mi>f</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>:</mo>
     <mrow>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\exist</mtext>
      </merror>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <msup>
       <mi>F</mi>
       <mi>n</mi>
      </msup>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <mtext>\exist</mtext>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <mtext>\exist</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>F</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exist F^{n}=_{def}\{x_{2}...x_{n}:\exist x_{1}F^{n}x_{1}...x_{n}\}.
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Predicate_functor_logic:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>F</mi>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>→</mo>
    <mrow>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\exist</mtext>
     </merror>
     <mi>F</mi>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <mtext>\exist</mtext>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Fx_{1}...x_{n}\rightarrow\exist Fx_{2}...x_{n}.
  </annotation>
 </semantics>
</math>

</p>

<p><em>Cropping</em> enables two useful defined functors:</p>
<ul>
<li><em>Reflection</em>, <strong>S</strong>:</li>
</ul>

<p>

<math display="block" id="Predicate_functor_logic:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded lspace="5pt" width="+5pt">
      <mi>S</mi>
     </mpadded>
     <msup>
      <mi>F</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <msub>
     <mo>=</mo>
     <mrow>
      <mi>d</mi>
      <mi>e</mi>
      <mi>f</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>:</mo>
     <mrow>
      <msup>
       <mi>F</mi>
       <mi>n</mi>
      </msup>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>F</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ SF^{n}=_{def}\{x_{2}...x_{n}:F^{n}x_{2}x_{2}...x_{n}\}.
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Predicate_functor_logic:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>S</mi>
     <msup>
      <mi>F</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo>↔</mo>
    <mrow>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\exist</mtext>
     </merror>
     <mi>I</mi>
     <msup>
      <mi>F</mi>
      <mi>n</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <mtext>\exist</mtext>
     <ci>I</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SF^{n}\leftrightarrow\exist IF^{n}.
  </annotation>
 </semantics>
</math>

 <strong>S</strong> generalizes the notion of reflexivity to all terms of any finite degree greater than 2. N.B: <strong>S</strong> should not be confused with the <a href="combinatory_logic" title="wikilink">primitive combinator</a> <strong>S</strong> of combinatory logic.</p>
<ul>
<li><em><a href="Cartesian_product" title="wikilink">Cartesian product</a></em>, 

<math display="inline" id="Predicate_functor_logic:10">
 <semantics>
  <mo>×</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \times
  </annotation>
 </semantics>
</math>

;</li>
</ul>

<p>

<math display="block" id="Predicate_functor_logic:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>F</mi>
      <mi>m</mi>
     </msup>
     <mo>×</mo>
     <msup>
      <mi>G</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo>↔</mo>
    <mrow>
     <msup>
      <mi>F</mi>
      <mi>m</mi>
     </msup>
     <msup>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\exist</mtext>
      </merror>
      <mi>m</mi>
     </msup>
     <msup>
      <mi>G</mi>
      <mi>n</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>G</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <mtext>\exist</mtext>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>G</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{m}\times G^{n}\leftrightarrow F^{m}\exist^{m}G^{n}.
  </annotation>
 </semantics>
</math>

 Here only, Quine adopted an infix notation, because this infix notation for Cartesian product is very well established in mathematics. Cartesian product allows restating conjunction as follows:</p>

<p>

<math display="block" id="Predicate_functor_logic:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>F</mi>
      <mi>m</mi>
     </msup>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>x</mi>
      <mi>m</mi>
     </msub>
     <msup>
      <mi>G</mi>
      <mi>n</mi>
     </msup>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>↔</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>F</mi>
        <mi>m</mi>
       </msup>
       <mo>×</mo>
       <msup>
        <mi>G</mi>
        <mi>n</mi>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>x</mi>
      <mi>m</mi>
     </msub>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>G</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>F</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>G</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{m}x_{1}...x_{m}G^{n}x_{1}...x_{n}\leftrightarrow(F^{m}\times G^{n})x_{1}...%
x_{m}x_{1}...x_{n}.
  </annotation>
 </semantics>
</math>

 Reorder the concatenated argument list so as to shift a pair of duplicate variables to the far left, then invoke <strong>S</strong> to eliminate the duplication. Repeating this as many times as required results in an argument list of length max(<em>m</em>,<em>n</em>).</p>

<p>The next three functors enable reordering argument lists at will.</p>
<ul>
<li><em>Major inversion</em>, <strong>Inv</strong>, rotates the variables in an argument list to the right, so that the last variable becomes the first.</li>
</ul>

<p>

<math display="block" id="Predicate_functor_logic:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded lspace="5pt" width="+5pt">
      <mi>I</mi>
     </mpadded>
     <mi>n</mi>
     <mi>v</mi>
     <msup>
      <mi>F</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <msub>
     <mo>=</mo>
     <mrow>
      <mi>d</mi>
      <mi>e</mi>
      <mi>f</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>:</mo>
     <mrow>
      <msup>
       <mi>F</mi>
       <mi>n</mi>
      </msup>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>I</ci>
     <ci>n</ci>
     <ci>v</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>F</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ InvF^{n}=_{def}\{x_{1}...x_{n}:F^{n}x_{n}x_{1}...x_{n-1}\}.
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Predicate_functor_logic:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>I</mi>
     <mi>n</mi>
     <mi>v</mi>
     <mi>F</mi>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>↔</mo>
    <mrow>
     <mi>F</mi>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <times></times>
     <ci>I</ci>
     <ci>n</ci>
     <ci>v</ci>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   InvFx_{1}...x_{n}\leftrightarrow Fx_{n}x_{1}...x_{n-1}.
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li><em>Minor inversion</em>, <strong>inv</strong>, swaps the first two variables in an argument list.</li>
</ul>

<p>

<math display="block" id="Predicate_functor_logic:15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded lspace="5pt" width="+5pt">
      <mi>i</mi>
     </mpadded>
     <mi>n</mi>
     <mi>v</mi>
     <msup>
      <mi>F</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <msub>
     <mo>=</mo>
     <mrow>
      <mi>d</mi>
      <mi>e</mi>
      <mi>f</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>:</mo>
     <mrow>
      <msup>
       <mi>F</mi>
       <mi>n</mi>
      </msup>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>n</ci>
     <ci>v</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>F</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ invF^{n}=_{def}\{x_{1}...x_{n}:F^{n}x_{2}x_{1}...x_{n}\}.
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Predicate_functor_logic:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>i</mi>
     <mi>n</mi>
     <mi>v</mi>
     <mi>F</mi>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>↔</mo>
    <mrow>
     <mi>F</mi>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>n</ci>
     <ci>v</ci>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   invFx_{1}...x_{n}\leftrightarrow Fx_{2}x_{1}...x_{n}.
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li><em>Permutation</em>, <strong>p</strong>, rotates the second through last variables in an argument list to the left, so that the second variable becomes the last.</li>
</ul>

<p>

<math display="block" id="Predicate_functor_logic:17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded lspace="5pt" width="+5pt">
      <mi>p</mi>
     </mpadded>
     <msup>
      <mi>F</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <msub>
     <mo>=</mo>
     <mrow>
      <mi>d</mi>
      <mi>e</mi>
      <mi>f</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>:</mo>
     <mrow>
      <msup>
       <mi>F</mi>
       <mi>n</mi>
      </msup>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>x</mi>
       <mn>3</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>F</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ pF^{n}=_{def}\{x_{1}...x_{n}:F^{n}x_{1}x_{3}...x_{n}x_{2}\}.
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Predicate_functor_logic:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mi>F</mi>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>↔</mo>
    <mrow>
     <mi>I</mi>
     <mi>n</mi>
     <mi>v</mi>
     <mi>i</mi>
     <mi>n</mi>
     <mi>v</mi>
     <mi>F</mi>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>x</mi>
      <mn>3</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>I</ci>
     <ci>n</ci>
     <ci>v</ci>
     <ci>i</ci>
     <ci>n</ci>
     <ci>v</ci>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   pFx_{1}...x_{n}\leftrightarrow InvinvFx_{1}x_{3}...x_{n}x_{2}.
  </annotation>
 </semantics>
</math>

 Given an argument list consisting of <em>n</em> variables, <strong>p</strong> implicitly treats the last <em>n</em>-1 variables like a bicycle chain, with each variable constituting a link in the chain. One application of <strong>p</strong> advances the chain by one link. <em>k</em> consecutive applications of <strong>p</strong> to <em>F</em><sup>n</sup> moves the <em>k</em>+1 variable to the second argument position in <em>F</em>.</p>

<p>When <em>n</em>=2, <strong>Inv</strong> and <strong>inv</strong> merely interchange <em>x</em><sub>1</sub> and <em>x</em><sub>2</sub>. When <em>n</em>=1, they have no effect. Hence <strong>p</strong> has no effect when <em>n</em> p; Inv; inv; \lnot; I |no change |- |

<math display="inline" id="Predicate_functor_logic:19">
 <semantics>
  <mrow>
   <mrow>
    <mo lspace="7.5pt">+</mo>
    <msup>
     <mi>F</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>F</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ +F^{n-1};
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Predicate_functor_logic:20">
 <semantics>
  <mrow>
   <mrow>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\exist</mtext>
    </merror>
    <msup>
     <mi>F</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>\exist</mtext>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>F</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exist F^{n+1};
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Predicate_functor_logic:21">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>S</mi>
   </mpadded>
   <msup>
    <mi>F</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>F</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ SF^{n+1}
  </annotation>
 </semantics>
</math>

 |

<math display="inline" id="Predicate_functor_logic:22">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>n</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ n
  </annotation>
 </semantics>
</math>

 |- |

<math display="inline" id="Predicate_functor_logic:23">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mpadded lspace="5pt" width="+5pt">
      <mi>α</mi>
     </mpadded>
     <mi>m</mi>
    </msup>
    <msup>
     <mi>β</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>α</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>β</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \alpha^{m}\beta^{n};
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Predicate_functor_logic:24">
 <semantics>
  <mrow>
   <msup>
    <mi>F</mi>
    <mi>m</mi>
   </msup>
   <mo>×</mo>
   <msup>
    <mi>G</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>F</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{m}\times G^{n}
  </annotation>
 </semantics>
</math>

 |

<math display="inline" id="Predicate_functor_logic:25">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>m</mi>
   </mpadded>
   <mi>a</mi>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>a</ci>
    <ci>x</ci>
    <interval closure="open">
     <ci>m</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ max(m,n)
  </annotation>
 </semantics>
</math>

 |- |}</p>
<h3 id="rules">Rules</h3>

<p>All instances of a predicate letter may be replaced by another predicate letter of the same degree, without affecting validity. The <a href="first-order_logic" title="wikilink">rules</a> are:</p>
<ul>
<li><a href="Modus_ponens" title="wikilink">Modus ponens</a>;</li>
<li>Let α and β be PFL formulas in which 

<math display="inline" id="Predicate_functor_logic:26">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

 does not appear. Then if 

<math display="inline" id="Predicate_functor_logic:27">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>α</mi>
     <mi mathvariant="italic">and</mi>
     <mi>F</mi>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>α</ci>
     <ci>italic- and</ci>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\alpha\and Fx_{1}...x_{n})\rightarrow\beta
  </annotation>
 </semantics>
</math>

 is a PFL theorem, then 

<math display="inline" id="Predicate_functor_logic:28">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>α</mi>
     <mi mathvariant="italic">and</mi>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\exist</mtext>
     </merror>
     <mi>F</mi>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>α</ci>
     <ci>italic- and</ci>
     <mtext>\exist</mtext>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\alpha\and\exist Fx_{2}...x_{n})\rightarrow\beta
  </annotation>
 </semantics>
</math>

 is likewise a PFL theorem.</li>
</ul>
<h3 id="some-useful-results">Some useful results</h3>

<p>Instead of axiomatizing PFL, Quine (1976) proposed the following conjectures as candidate axioms.</p>
<ul>
<li>

<math display="inline" id="Predicate_functor_logic:29">
 <semantics>
  <mrow>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\exist</mtext>
   </merror>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>\exist</mtext>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exist I
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p><em>n</em>-1 consecutive iterations of <strong>p</strong> restores the <em>status quo ante</em>:</p>
<ul>
<li>

<math display="inline" id="Predicate_functor_logic:30">
 <semantics>
  <mrow>
   <msup>
    <mi>F</mi>
    <mi>n</mi>
   </msup>
   <mo>↔</mo>
   <mrow>
    <msup>
     <mi>p</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <msup>
     <mi>F</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>F</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{n}\leftrightarrow p^{n-1}F^{n}
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p><strong>+</strong> and <strong>∃</strong> annihilate each other:  </p>
<ul>
<li>

<math display="inline" id="Predicate_functor_logic:31">
 <semantics>
  <mrow>
   <msup>
    <mi>F</mi>
    <mi>n</mi>
   </msup>
   <mo>→</mo>
   <mrow>
    <mo>+</mo>
    <mrow>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\exist</mtext>
     </merror>
     <msup>
      <mi>F</mi>
      <mi>n</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>F</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <mtext>\exist</mtext>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>F</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{n}\rightarrow+\exist F^{n}
  </annotation>
 </semantics>
</math>

</li>
</ul>
<ul>
<li>

<math display="inline" id="Predicate_functor_logic:32">
 <semantics>
  <mrow>
   <msup>
    <mi>F</mi>
    <mi>n</mi>
   </msup>
   <mo>↔</mo>
   <mrow>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\exist</mtext>
    </merror>
    <mo>+</mo>
    <msup>
     <mi>F</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>F</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <mtext>\exist</mtext>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{n}\leftrightarrow\exist+F^{n}
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Negation distributes over <strong>+</strong>, <strong>∃</strong>, and <strong>p</strong>:  </p>
<ul>
<li>

<math display="inline" id="Predicate_functor_logic:33">
 <semantics>
  <mrow>
   <mrow>
    <mo>+</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <msup>
      <mi>F</mi>
      <mi>n</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>↔</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mo>+</mo>
    <msup>
     <mi>F</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <not></not>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>F</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <not></not>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   +\lnot F^{n}\leftrightarrow\lnot+F^{n}
  </annotation>
 </semantics>
</math>

</li>
</ul>
<ul>
<li>

<math display="inline" id="Predicate_functor_logic:34">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\exist</mtext>
    </merror>
    <msup>
     <mi>F</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>→</mo>
   <mrow>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\exist</mtext>
    </merror>
    <mi mathvariant="normal">¬</mi>
    <msup>
     <mi>F</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <not></not>
     <mtext>\exist</mtext>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <mtext>\exist</mtext>
     <not></not>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lnot\exist F^{n}\rightarrow\exist\lnot F^{n}
  </annotation>
 </semantics>
</math>

</li>
</ul>
<ul>
<li>

<math display="inline" id="Predicate_functor_logic:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mi mathvariant="normal">¬</mi>
    <msup>
     <mi>F</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>↔</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>p</mi>
    <msup>
     <mi>F</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <times></times>
     <ci>p</ci>
     <not></not>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\lnot F^{n}\leftrightarrow\lnot pF^{n}
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p><strong>+</strong> and <strong>p</strong> distributes over conjunction:  </p>
<ul>
<li>

<math display="inline" id="Predicate_functor_logic:36">
 <semantics>
  <mrow>
   <mrow>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>F</mi>
       <mi>n</mi>
      </msup>
      <msup>
       <mi>G</mi>
       <mi>m</mi>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>↔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo>+</mo>
      <msup>
       <mi>F</mi>
       <mi>n</mi>
      </msup>
     </mrow>
     <mo>+</mo>
     <msup>
      <mi>G</mi>
      <mi>m</mi>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>F</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>G</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>F</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>G</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   +(F^{n}G^{m})\leftrightarrow(+F^{n}+G^{m})
  </annotation>
 </semantics>
</math>

</li>
</ul>
<ul>
<li>

<math display="inline" id="Predicate_functor_logic:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>F</mi>
       <mi>n</mi>
      </msup>
      <msup>
       <mi>G</mi>
       <mi>m</mi>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>↔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>p</mi>
     <msup>
      <mi>F</mi>
      <mi>n</mi>
     </msup>
     <mi>p</mi>
     <msup>
      <mi>G</mi>
      <mi>m</mi>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <times></times>
     <ci>p</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>F</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>G</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>G</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(F^{n}G^{m})\leftrightarrow(pF^{n}pG^{m})
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Identity has the interesting implication:</p>
<ul>
<li>

<math display="inline" id="Predicate_functor_logic:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <msup>
     <mi>F</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>p</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\exist</mtext>
     </merror>
     <mi>p</mi>
    </mrow>
    <mo>+</mo>
    <msup>
     <mi>F</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>I</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <mtext>\exist</mtext>
      <ci>p</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   IF^{n}\rightarrow p^{n-2}\exist p+F^{n}
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Quine also conjectured the rule: If 

<math display="inline" id="Predicate_functor_logic:39">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>α</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \alpha
  </annotation>
 </semantics>
</math>

 is a PFL theorem, then so are 

<math display="inline" id="Predicate_functor_logic:40">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="5pt" width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>α</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ p\alpha,
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Predicate_functor_logic:41">
 <semantics>
  <mrow>
   <mrow>
    <mo lspace="7.5pt">+</mo>
    <mi>α</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ +\alpha,
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Predicate_functor_logic:42">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\exist</mtext>
   </merror>
   <mi mathvariant="normal">¬</mi>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <mtext>\exist</mtext>
    <not></not>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lnot\exist\lnot\alpha
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="bacons-work">Bacon's work</h2>

<p>Bacon (1985) takes the <a href="Material_conditional" title="wikilink">conditional</a>, <a class="uri" href="negation" title="wikilink">negation</a>, <em>Identity</em>, <em>Padding</em>, and <em>Major</em> and <em>Minor inversion</em> as primitive, and <em>Cropping</em> as defined. Employing terminology and notation differing somewhat from the above, Bacon (1985) sets out two formulations of PFL:</p>
<ul>
<li>A <a href="natural_deduction" title="wikilink">natural deduction</a> formulation in the style of <a href="Frederick_Fitch" title="wikilink">Frederick Fitch</a>. Bacon proves this formulation <a href="consistency_proof" title="wikilink">sound</a> and <a href="Completeness_(logic)" title="wikilink">complete</a> in full detail.</li>
<li>An axiomatic formulation which Bacon asserts, but does not prove, equivalent to the preceding one. Some of these axioms are simply Quine conjectures restated in Bacon's notation.</li>
</ul>

<p>Bacon also:</p>
<ul>
<li>Discusses the relation of PFL to the <a href="term_logic" title="wikilink">term logic</a> of Sommers (1982), and argues that recasting PFL using a syntax proposed in Lockwood's appendix to Sommers, should make PFL easier to "read, use, and teach";</li>
<li>Touches on the <a href="group_theory" title="wikilink">group theoretic</a> structure of <strong>Inv</strong> and <strong>inv</strong>;</li>
<li>Mentions that <a href="sentential_logic" title="wikilink">sentential logic</a>, <a href="monadic_predicate_logic" title="wikilink">monadic predicate logic</a>, the <a href="modal_logic" title="wikilink">modal logic</a> <a href="S5_(modal_logic)" title="wikilink">S5</a>, and the Boolean logic of (un)permuted <a href="relation_(mathematics)" title="wikilink">relations</a>, are all fragments of PFL.</li>
</ul>
<h2 id="from-first-order-logic-to-pfl">From first-order logic to PFL</h2>

<p>The following <a class="uri" href="algorithm" title="wikilink">algorithm</a> is adapted from Quine (1976: 300-2). Given a <a href="sentence_(mathematical_logic)" title="wikilink">closed formula</a> of <a href="first-order_logic" title="wikilink">first-order logic</a>, first do the following:</p>
<ul>
<li>Attach a numerical subscript to every predicate letter, stating its degree;</li>
<li>Translate all <a href="universal_quantifier" title="wikilink">universal quantifiers</a> into <a href="existential_quantifier" title="wikilink">existential quantifiers</a> and negation;</li>
<li>Restate all <a href="atomic_formula" title="wikilink">atomic formulas</a> of the form <em>x</em>=<em>y</em> as <em>Ixy</em>.</li>
</ul>

<p>Now apply the following algorithm to the preceding result:</p>

<p><strong>1.</strong> Translate the matrices of the most deeply nested quantifiers into <a href="disjunctive_normal_form" title="wikilink">disjunctive normal form</a>, consisting of <a href="logical_OR" title="wikilink">disjuncts</a> of <a href="logical_AND" title="wikilink">conjuncts</a> of terms, negating atomic terms as required. The resulting subformula contains only negation, conjunction, disjunction, and existential quantification.</p>

<p><strong>2.</strong> Distribute the existential quantifiers over the disjuncts in the matrix using the <a href="rules_of_passage_(logic)" title="wikilink">rule of passage</a> (Quine 1982: 119):</p>

<p>

<math display="block" id="Predicate_functor_logic:43">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\exist</mtext>
     </merror>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>α</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>γ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>↔</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\exist</mtext>
      </merror>
      <mi>x</mi>
      <mi>α</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\exist</mtext>
      </merror>
      <mi>x</mi>
      <mi>γ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <times></times>
     <mtext>\exist</mtext>
     <ci>x</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>α</ci>
       <ci>x</ci>
       <ci>γ</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <mtext>\exist</mtext>
     <ci>x</ci>
     <ci>α</ci>
     <ci>x</ci>
     <mtext>\exist</mtext>
     <ci>x</ci>
     <ci>γ</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exist x[\alpha(x)\gamma(x)]\leftrightarrow(\exist x\alpha(x)\exist x\gamma(x)).
  </annotation>
 </semantics>
</math>

</p>

<p><strong>3.</strong> Replace conjunction by <a href="Cartesian_product" title="wikilink">Cartesian product</a>, by invoking the fact:</p>

<p><span class="LaTeX">$$(F^m \and G^n) \leftrightarrow (F^m \times G^n) \leftrightarrow (F^m \exist^m G^n); m<n.< math="">

'''4.''' Concatenate the argument lists of all atomic terms, and move the concatenated list to the far right of the subformula.

'''5.''' Use '''Inv''' and '''inv''' to move all instances of the quantified variable (call it ''y'') to the left of the argument list.

'''6.''' Invoke '''S''' as many times as required to eliminate all but the last instance of ''y''. Eliminate ''y'' by prefixing the subformula with one instance of '''∃'''.

'''7.''' Repeat (1)-(6) until all quantified variables have been eliminated. Eliminate any disjunctions falling within the scope of a quantifier by invoking the equivalence:
:<math> (\alpha \or \beta \or ...) \leftrightarrow \lnot(\lnot\alpha \and \lnot\beta \and ...).$$</math></n.<></span></p>

<p>The reverse translation, from PFL to first-order logic, is discussed in Quine (1976: 302-4).</p>

<p>The canonical <a href="foundation_of_mathematics" title="wikilink">foundation of mathematics</a> is <a href="axiomatic_set_theory" title="wikilink">axiomatic set theory</a>, with a background logic consisting of <a href="first-order_logic" title="wikilink">first-order logic</a> with <a href="Identity_(mathematics)" title="wikilink">identity</a>, with a <a href="universe_of_discourse" title="wikilink">universe of discourse</a> consisting entirely of sets. There is a single <a href="first-order_logic" title="wikilink">predicate letter</a> of degree 2, interpreted as set membership. The PFL translation of the canonical <a href="axiomatic_set_theory" title="wikilink">axiomatic set theory</a> <a class="uri" href="ZFC" title="wikilink">ZFC</a> is not difficult, as no <a class="uri" href="ZFC" title="wikilink">ZFC</a> axiom requires more than 6 quantified variables.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="algebraic_logic" title="wikilink">algebraic logic</a></li>
<li><a href="combinatory_logic" title="wikilink">combinatory logic</a></li>
<li><a href="cylindric_algebra" title="wikilink">cylindric algebra</a></li>
<li><a href="relation_algebra" title="wikilink">relation algebra</a></li>
<li><a href="term_logic" title="wikilink">term logic</a></li>
</ul>
<h2 id="footnotes">Footnotes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li>Bacon, John, 1985, "The completeness of a predicate-functor logic," <em>Journal of Symbolic Logic 50</em>: 903-26.</li>
<li><a href="Paul_Bernays" title="wikilink">Paul Bernays</a>, 1959, "Uber eine naturliche Erweiterung des Relationenkalkuls" in Heyting, A., ed., <em>Constructivity in Mathematics</em>. North Holland: 1-14.</li>
<li>Kuhn, Stephen T., 1983, "[<a class="uri" href="http://projecteuclid.org/DPubS/Repository/1.0/Disseminate?view=body&amp;id">http://projecteuclid.org/DPubS/Repository/1.0/Disseminate?view=body&amp;id;</a>;=pdf_1&amp;handle;=euclid.ndjfl/1093870313 An Axiomatization of Predicate Functor Logic,]" <em>Notre Dame Journal of Formal Logic 24</em>: 233-41.</li>
<li><a href="Willard_Quine" title="wikilink">Willard Quine</a>, 1976, "Algebraic Logic and Predicate Functors" in <em>Ways of Paradox and Other Essays</em>, enlarged ed. Harvard Univ. Press: 283-307.</li>
<li>--------, 1982. <em>Methods of Logic</em>, 4th ed. Harvard Univ. Press. Chpt. 45.</li>
<li>Sommers, Fred, 1982. <em>The Logic of Natural Language</em>. Oxford Univ. Press.</li>
<li><a href="Alfred_Tarski" title="wikilink">Alfred Tarski</a> and Givant, Steven, 1987. <em>A Formalization of Set Theory Without Variables</em>. <a href="American_Mathematical_Society" title="wikilink">AMS</a>.</li>
<li><a href="Jean_Van_Heijenoort" title="wikilink">Jean Van Heijenoort</a>, 1967. <em>From Frege to Gödel: A Source Book on Mathematical Logic</em>. Harvard Univ. Press.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>[<a class="uri" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.55.5673&amp;rep">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.55.5673&amp;rep;</a>;=rep1&amp;type;=ps <em>An introduction to predicate-functor logic</em>] (one-click download, PS file) by Mats Dahllöf (Department of Linguistics, Uppsala University)</li>
</ul>

<p>"</p>

<p><a href="Category:Algebraic_logic" title="wikilink">Category:Algebraic logic</a> <a href="Category:Mathematical_axioms" title="wikilink">Category:Mathematical axioms</a> <a href="Category:Predicate_logic" title="wikilink">Category:Predicate logic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://us.metamath.org/mpegif/mmset.html#staxioms">Metamath axioms.</a><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
