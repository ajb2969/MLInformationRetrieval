<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1119">Conditional random field</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Conditional random field</h1>
<hr/>

<p><strong>Conditional random fields (CRFs)</strong> are a class of <a href="statistical_model" title="wikilink"> statistical modelling method</a> often applied in <a href="pattern_recognition" title="wikilink">pattern recognition</a> and <a href="machine_learning" title="wikilink">machine learning</a>, where they are used for <a href="structured_prediction" title="wikilink">structured prediction</a>. Whereas an ordinary <a href="statistical_classification" title="wikilink">classifier</a> predicts a label for a single sample without regard to "neighboring" samples, a CRF can take context into account; e.g., the linear chain CRF popular in <a href="natural_language_processing" title="wikilink">natural language processing</a> predicts sequences of labels for sequences of input samples.</p>

<p>CRFs are a type of <a href="discriminative_model" title="wikilink">discriminative</a> <a href="Markov_random_field" title="wikilink">undirected</a> <a href="Statistical_model" title="wikilink">probabilistic</a> <a href="graphical_model" title="wikilink">graphical model</a>. It is used to encode known relationships between observations and construct consistent interpretations. It is often used for <a href="sequence_labeling" title="wikilink">labeling</a> or <a class="uri" href="parsing" title="wikilink">parsing</a> of sequential data, such as natural language text or <a href="bioinformatics" title="wikilink">biological sequences</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and in <a href="computer_vision" title="wikilink">computer vision</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Specifically, CRFs find applications in <a href="shallow_parsing" title="wikilink">shallow parsing</a>,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <a href="named_entity_recognition" title="wikilink">named entity recognition</a>,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> <a href="Gene_prediction" title="wikilink">gene finding</a> and peptide critical functional region finding,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> among other tasks, being an alternative to the related <a href="hidden_Markov_model" title="wikilink">hidden Markov models</a> (HMMs). In computer vision, CRFs are often used for object recognition and image segmentation.</p>
<h2 id="description">Description</h2>

<p><a href="John_D._Lafferty" title="wikilink">Lafferty</a>, <a href="Andrew_McCallum" title="wikilink">McCallum</a> and Pereira<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> define a CRF on observations 

<math display="inline" id="Conditional_random_field:0">
 <semantics>
  <mi>𝑿</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝑿</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{X}
  </annotation>
 </semantics>
</math>

 and <a href="random_variable" title="wikilink">random variables</a> 

<math display="inline" id="Conditional_random_field:1">
 <semantics>
  <mi>𝒀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{Y}
  </annotation>
 </semantics>
</math>

 as follows:</p>
<blockquote>

<p>Let 

<math display="inline" id="Conditional_random_field:2">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

 be a graph such that 

<math display="inline" id="Conditional_random_field:3">
 <semantics>
  <mrow>
   <mi>𝒀</mi>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝒀</mi>
      <mi>v</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>v</mi>
     <mo>∈</mo>
     <mi>V</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒀</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒀</ci>
      <ci>v</ci>
     </apply>
     <apply>
      <in></in>
      <ci>v</ci>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{Y}=(\boldsymbol{Y}_{v})_{v\in V}
  </annotation>
 </semantics>
</math>


,</p>

<p><code>so that </code>

<math display="inline" id="Conditional_random_field:4">
 <semantics>
  <mi>𝒀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{Y}
  </annotation>
 </semantics>
</math>

<code> is indexed by the vertices of </code>

<math display="inline" id="Conditional_random_field:5">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

<code>. </code></p>

<p>Then 

<math display="inline" id="Conditional_random_field:6">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>𝑿</mi>
   <mo>,</mo>
   <mi>𝒀</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>𝑿</ci>
    <ci>𝒀</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\boldsymbol{X},\boldsymbol{Y})
  </annotation>
 </semantics>
</math>

 is a conditional random field when the random variables 

<math display="inline" id="Conditional_random_field:7">
 <semantics>
  <msub>
   <mi>𝒀</mi>
   <mi>v</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝒀</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{Y}_{v}
  </annotation>
 </semantics>
</math>

, conditioned on 

<math display="inline" id="Conditional_random_field:8">
 <semantics>
  <mi>𝑿</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝑿</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{X}
  </annotation>
 </semantics>
</math>


, obey the <a href="Markov_property" title="wikilink">Markov property</a> with respect to the graph

<math display="block" id="Conditional_random_field:9">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>𝒀</mi>
     <mi>v</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <mi>𝑿</mi>
    <mo>,</mo>
    <msub>
     <mi>𝒀</mi>
     <mi>w</mi>
    </msub>
    <mo>,</mo>
    <mi>w</mi>
    <mo>≠</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>𝒀</mi>
     <mi>v</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <mi>𝑿</mi>
    <mo>,</mo>
    <msub>
     <mi>𝒀</mi>
     <mi>w</mi>
    </msub>
    <mo>,</mo>
    <mi>w</mi>
    <mo>∼</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒀</ci>
      <ci>v</ci>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒀</ci>
      <ci>w</ci>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="unknown">w</csymbol>
     <neq></neq>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒀</ci>
      <ci>v</ci>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒀</ci>
      <ci>w</ci>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="unknown">w</csymbol>
     <csymbol cd="latexml">similar-to</csymbol>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\boldsymbol{Y}_{v}|\boldsymbol{X},\boldsymbol{Y}_{w},w\neq v)=p(\boldsymbol{%
Y}_{v}|\boldsymbol{X},\boldsymbol{Y}_{w},w\sim v)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Conditional_random_field:10">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>∼</mo>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <ci>w</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{w}\sim v
  </annotation>
 </semantics>
</math>

 means that 

<math display="inline" id="Conditional_random_field:11">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Conditional_random_field:12">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 are neighbors in 

<math display="inline" id="Conditional_random_field:13">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>


.</p>
</blockquote>

<p>What this means is that a CRF is an <a href="Graphical_model" title="wikilink">undirected graphical model</a> whose nodes can be divided into exactly two disjoint sets 

<math display="inline" id="Conditional_random_field:14">
 <semantics>
  <mi>𝑿</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝑿</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{X}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Conditional_random_field:15">
 <semantics>
  <mi>𝒀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{Y}
  </annotation>
 </semantics>
</math>

, the observed and output variables, respectively; the conditional distribution 

<math display="inline" id="Conditional_random_field:16">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝒀</mi>
    <mo stretchy="false">|</mo>
    <mi>𝑿</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\boldsymbol{Y}|\boldsymbol{X})
  </annotation>
 </semantics>
</math>

 is then modeled.</p>
<h3 id="inference">Inference</h3>

<p>For general graphs, the problem of <a href="exact_inference" title="wikilink">exact inference</a> in CRFs is intractable. The inference problem for a CRF is basically the same as for an <a href="Markov_random_field#Inference" title="wikilink">MRF</a> and the same arguments hold.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> However there exist special cases for which exact inference is feasible:</p>
<ul>
<li>If the graph is a chain or a tree, message passing algorithms yield exact solutions. The algorithms used in these cases are analogous to the <a href="forward-backward_algorithm" title="wikilink">forward-backward</a> and <a href="Viterbi_algorithm" title="wikilink">Viterbi algorithm</a> for the case of HMMs.</li>
<li>If the CRF only contains pair-wise potentials and the energy is submodular, combinatorial min cut/max flow algorithms yield exact solutions.</li>
</ul>

<p>If exact inference is impossible, several algorithms can be used to obtain approximate solutions. These include:</p>
<ul>
<li>Loopy belief propagation</li>
<li>Alpha expansion</li>
<li>Mean field inference</li>
<li>Linear programming relaxations</li>
</ul>
<h3 id="parameter-learning">Parameter Learning</h3>

<p>Learning the parameters 

<math display="inline" id="Conditional_random_field:17">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 is usually done by <a href="maximum_likelihood" title="wikilink">maximum likelihood</a> learning for 

<math display="inline" id="Conditional_random_field:18">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Y</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>X</mi>
     <mi>i</mi>
    </msub>
    <mo>;</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-;</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(Y_{i}|X_{i};\theta)
  </annotation>
 </semantics>
</math>


. If all nodes have exponential family distributions and all nodes are observed during training, this <a href="Optimization_(mathematics)" title="wikilink">optimization</a> is convex.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> It can be solved for example using <a href="gradient_descent" title="wikilink">gradient descent</a> algorithms, or <a href="Quasi-Newton_method" title="wikilink">Quasi-Newton methods</a> such as the <a class="uri" href="L-BFGS" title="wikilink">L-BFGS</a> algorithm. On the other hand, if some variables are unobserved, the inference problem has to be solved for these variables. Exact inference is intractable in general graphs, so approximations have to be used.</p>
<h3 id="examples">Examples</h3>

<p>In sequence modeling, the graph of interest is usually a chain graph. An input sequence of observed variables 

<math display="inline" id="Conditional_random_field:19">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 represents a sequence of observations and 

<math display="inline" id="Conditional_random_field:20">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 represents a hidden (or unknown) state variable that needs to be inferred given the observations. The 

<math display="inline" id="Conditional_random_field:21">
 <semantics>
  <msub>
   <mi>Y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{i}
  </annotation>
 </semantics>
</math>

 are structured to form a chain, with an edge between each 

<math display="inline" id="Conditional_random_field:22">
 <semantics>
  <msub>
   <mi>Y</mi>
   <mrow>
    <mi>i</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Y</ci>
    <apply>
     <minus></minus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{i-1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Conditional_random_field:23">
 <semantics>
  <msub>
   <mi>Y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{i}
  </annotation>
 </semantics>
</math>


. As well as having a simple interpretation of the 

<math display="inline" id="Conditional_random_field:24">
 <semantics>
  <msub>
   <mi>Y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{i}
  </annotation>
 </semantics>
</math>

 as "labels" for each element in the input sequence, this layout admits efficient algorithms for:</p>
<ul>
<li>model <em>training</em>, learning the conditional distributions between the 

<math display="inline" id="Conditional_random_field:25">
 <semantics>
  <msub>
   <mi>Y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{i}
  </annotation>
 </semantics>
</math>

 and feature functions from some corpus of training data.</li>
<li><em>decoding</em>, determining the probability of a given label sequence 

<math display="inline" id="Conditional_random_field:26">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 given 

<math display="inline" id="Conditional_random_field:27">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

.</li>
<li><em>inference</em>, determining the <em>most likely</em> label sequence 

<math display="inline" id="Conditional_random_field:28">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>


 given 

<math display="inline" id="Conditional_random_field:29">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>The conditional dependency of each 

<math display="inline" id="Conditional_random_field:30">
 <semantics>
  <msub>
   <mi>Y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{i}
  </annotation>
 </semantics>
</math>

 on 

<math display="inline" id="Conditional_random_field:31">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is defined through a fixed set of <em>feature functions</em> of the form 

<math display="inline" id="Conditional_random_field:32">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <msub>
     <mi>Y</mi>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>Y</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <vector>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <ci>i</ci>
     </apply>
     <ci>X</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(i,Y_{i-1},Y_{i},X)
  </annotation>
 </semantics>
</math>

, which can informally be thought of as measurements on the input sequence that partially determine the <a href="Likelihood_function" title="wikilink">likelihood</a> of each possible value for 

<math display="inline" id="Conditional_random_field:33">
 <semantics>
  <msub>
   <mi>Y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{i}
  </annotation>
 </semantics>
</math>


. The model assigns each feature a numerical weight and combines them to determine the probability of a certain value for 

<math display="inline" id="Conditional_random_field:34">
 <semantics>
  <msub>
   <mi>Y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{i}
  </annotation>
 </semantics>
</math>

.</p>

<p>Linear-chain CRFs have many of the same applications as conceptually simpler hidden Markov models (HMMs), but relax certain assumptions about the input and output sequence distributions. An HMM can loosely be understood as a CRF with very specific feature functions that use constant probabilities to model state transitions and emissions. Conversely, a CRF can loosely be understood as a generalization of an HMM that makes the constant transition probabilities into arbitrary functions that vary across the positions in the sequence of hidden states, depending on the input sequence.</p>

<p>Notably in contrast to HMMs, CRFs can contain any number of feature functions, the feature functions can inspect the entire input sequence 

<math display="inline" id="Conditional_random_field:35">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 at any point during inference, and the range of the feature functions need not have a probabilistic interpretation.</p>
<h2 id="variants">Variants</h2>
<h3 id="higher-order-crfs-and-semi-markov-crfs">Higher-order CRFs and semi-Markov CRFs</h3>

<p>CRFs can be extended into higher order models by making each 

<math display="inline" id="Conditional_random_field:36">
 <semantics>
  <msub>
   <mi>Y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{i}
  </annotation>
 </semantics>
</math>

 dependent on a fixed number 

<math display="inline" id="Conditional_random_field:37">
 <semantics>
  <mi>o</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>o</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o
  </annotation>
 </semantics>
</math>

 of previous variables 

<math display="inline" id="Conditional_random_field:38">
 <semantics>
  <mrow>
   <msub>
    <mi>Y</mi>
    <mrow>
     <mi>i</mi>
     <mo>-</mo>
     <mi>o</mi>
    </mrow>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>Y</mi>
    <mrow>
     <mi>i</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Y</ci>
     <apply>
      <minus></minus>
      <ci>i</ci>
      <ci>o</ci>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Y</ci>
     <apply>
      <minus></minus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{i-o},...,Y_{i-1}
  </annotation>
 </semantics>
</math>


. Training and inference are only practical for small values of 

<math display="inline" id="Conditional_random_field:39">
 <semantics>
  <mi>o</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>o</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o
  </annotation>
 </semantics>
</math>

 (such as <em>o</em> ≤ 5), since their computational cost increases exponentially with 

<math display="inline" id="Conditional_random_field:40">
 <semantics>
  <mi>o</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>o</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o
  </annotation>
 </semantics>
</math>

. Large-margin models for <a href="structured_prediction" title="wikilink">structured prediction</a>, such as the <a href="Structured_SVM" title="wikilink">structured Support Vector Machine</a> can be seen as an alternative training procedure to CRFs.</p>

<p>There exists another generalization of CRFs, the <strong>semi-Markov conditional random field (semi-CRF)</strong>, which models variable-length <em>segmentations</em> of the label sequence 

<math display="inline" id="Conditional_random_field:41">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> This provides much of the power of higher-order CRFs to model long-range dependencies of the 

<math display="inline" id="Conditional_random_field:42">
 <semantics>
  <msub>
   <mi>Y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{i}
  </annotation>
 </semantics>
</math>

, at a reasonable computational cost.</p>
<h3 id="latent-dynamic-conditional-random-field">Latent-dynamic conditional random field</h3>

<p><strong>Latent-dynamic conditional random fields</strong> (<strong>LDCRF</strong>) or <strong>discriminative probabilistic latent variable models</strong> (<strong>DPLVM</strong>) are a type of CRFs for sequence tagging tasks. They are <a href="latent_variable_model" title="wikilink">latent variable models</a> that are trained discriminatively.</p>

<p>In an LDCRF, like in any sequence tagging task, given a sequence of observations <strong>x</strong> = 

<math display="inline" id="Conditional_random_field:43">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


₁, … 

<math display="inline" id="Conditional_random_field:44">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mi>ₙ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>ₙ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   xₙ
  </annotation>
 </semantics>
</math>

, the main problem the model must solve is how to assign a sequence of labels <strong>y</strong> = 

<math display="inline" id="Conditional_random_field:45">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

₁, … 

<math display="inline" id="Conditional_random_field:46">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mi>ₙ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <ci>ₙ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   yₙ
  </annotation>
 </semantics>
</math>

 from one finite set of labels 

<math display="inline" id="Conditional_random_field:47">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

. Instead of directly modeling 

<math display="inline" id="Conditional_random_field:48">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>


(<strong>y</strong>|<strong>x</strong>) as an ordinary linear-chain CRF would do, instead a set of latent variables <strong>h</strong> is "inserted" between <strong>x</strong> and <strong>y</strong> using the <a href="chain_rule_of_probability" title="wikilink">chain rule of probability</a>:<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>

<math display="block" id="Conditional_random_field:49">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐲</mi>
    <mo stretchy="false">|</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mi>𝐡</mi>
   </munder>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐲</mi>
    <mo stretchy="false">|</mo>
    <mi>𝐡</mi>
    <mo>,</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐡</mi>
    <mo stretchy="false">|</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>𝐡</ci>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">h</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">h</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\mathbf{y}|\mathbf{x})=\sum_{\mathbf{h}}P(\mathbf{y}|\mathbf{h},\mathbf{x})P%
(\mathbf{h}|\mathbf{x})
  </annotation>
 </semantics>
</math>

</p>

<p>This allows the capturing of latent structure between the observations and labels.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> While LDCRFs can be trained using quasi-Newton methods, a specialized version of the <a class="uri" href="perceptron" title="wikilink">perceptron</a> algorithm called the <strong>latent-variable perceptron</strong> has been developed for them as well, based on Collins' <a href="structured_perceptron" title="wikilink">structured perceptron</a> algorithm.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> These models find applications in <a href="computer_vision" title="wikilink">computer vision</a>, specifically <a href="gesture_recognition" title="wikilink">gesture recognition</a> from video streams,<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> and <a href="shallow_parsing" title="wikilink">shallow parsing</a>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="software">Software</h2>

<p>This is a partial list of software that implement generic CRF tools.</p>
<ul>
<li><a href="http://rnnsharp.codeplex.com/">RNNSharp</a> CRFs based on recurrent neural networks (<a href="C_Sharp_(programming_language)" title="wikilink">C#</a>, <a href=".NET_Framework" title="wikilink">.NET</a>)</li>
<li><a href="http://klcl.pku.edu.cn/member/sunxu/code.htm">CRF-ADF</a> Linear-chain CRFs with fast online ADF training (<a href="C_Sharp_(programming_language)" title="wikilink">C#</a>, <a href=".NET_Framework" title="wikilink">.NET</a>)</li>
<li><a href="http://github.com/zhongkaifu/CRFSharp">CRFSharp</a> Linear-chain CRFs (<a href="C_Sharp_(programming_language)" title="wikilink">C#</a>, <a href=".NET_Framework" title="wikilink">.NET</a>)</li>
<li><a href="http://vision.csd.uwo.ca/code/">GCO</a> CRFs with submodular energy functions (<a class="uri" href="C++" title="wikilink">C++</a>, <a class="uri" href="Matlab" title="wikilink">Matlab</a>)</li>
<li><a href="http://research.project-10.de/dgm">DGM</a> General CRFs (<a class="uri" href="C++" title="wikilink">C++</a>)</li>
<li><a href="http://mallet.cs.umass.edu/grmm/index.php">GRMM</a> General CRFs (<a href="Java_(programming_language)" title="wikilink">Java</a>)</li>
<li><a href="http://factorie.cs.umass.edu/">factorie</a> General CRFs (<a href="Scala_(programming_language)" title="wikilink">Scala</a>)</li>
<li><a href="http://www.cs.ubc.ca/~murphyk/Software/CRFall.zip">CRFall</a> General CRFs (<a href="MATLAB" title="wikilink">Matlab</a>)</li>
<li><a href="http://crf.sourceforge.net/">Sarawagi's CRF</a> Linear-chain CRFs (<a href="Java_(programming_language)" title="wikilink">Java</a>)</li>
<li><a href="http://sourceforge.net/projects/hcrf/">HCRF library</a> Hidden-state CRFs (<a class="uri" href="C++" title="wikilink">C++</a>, <a href="MATLAB" title="wikilink">Matlab</a>)</li>
<li><a href="http://accord-framework.net">Accord.NET</a> Linear-chain CRF, HCRF and HMMs (<a href="C_Sharp_(programming_language)" title="wikilink">C#</a>, <a href=".NET_Framework" title="wikilink">.NET</a>)</li>
<li><a href="http://wapiti.limsi.fr/">Wapiti</a> Fast linear-chain CRFs (<a href="C_(programming_language)" title="wikilink">C</a>)<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></li>
<li><a href="http://www.chokkan.org/software/crfsuite/">CRFSuite</a> Fast restricted linear-chain CRFs (<a href="C_(programming_language)" title="wikilink">C</a>)</li>
<li><a href="http://crfpp.sourceforge.net/">CRF++</a> Linear-chain CRFs (<a class="uri" href="C++" title="wikilink">C++</a>)</li>
<li><a href="http://flexcrfs.sourceforge.net/">FlexCRFs</a> First-order and second-order Markov CRFs (<a class="uri" href="C++" title="wikilink">C++</a>)</li>
<li><a href="http://hackage.haskell.org/package/crf-chain1">crf-chain1</a> First-order, linear-chain CRFs (<a href="Haskell_(programming_language)" title="wikilink">Haskell</a>)</li>
<li><a href="http://www.cs.rochester.edu/~bhole/code/crf/">imageCRF</a> CRF for segmenting images and image volumes (<a class="uri" href="C++" title="wikilink">C++</a>)</li>
<li><a href="http://mallet.cs.umass.edu/">MALLET</a> Linear-chain for sequence tagging (<a class="uri" href="Java" title="wikilink">Java</a>)</li>
<li><a href="https://pystruct.github.io/">PyStruct</a> Structured Learning in Python (<a href="Python_(programming_language)" title="wikilink">Python</a>)</li>
</ul>

<p>This is a partial list of software that implement CRF related tools.</p>
<ul>
<li><a href="http://www.broadinstitute.org/annotation/conrad">Conrad</a> CRF based gene predictor (<a href="Java_(programming_language)" title="wikilink">Java</a>)</li>
<li><a href="http://nlp.stanford.edu/software/CRF-NER.shtml">Stanford NER</a> Named Entity Recognizer (<a href="Java_(programming_language)" title="wikilink">Java</a>)</li>
<li><a href="http://cbioc.eas.asu.edu/banner/">BANNER</a> Named Entity Recognizer (<a href="Java_(programming_language)" title="wikilink">Java</a>)</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Hammersley–Clifford_theorem" title="wikilink">Hammersley–Clifford theorem</a></li>
<li><a href="Graphical_model" title="wikilink">Graphical model</a></li>
<li><a href="Markov_random_field" title="wikilink">Markov random field</a></li>
<li><a href="Maximum_entropy_Markov_model" title="wikilink">Maximum entropy Markov model</a> (MEMM)</li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>McCallum, A.: Efficiently inducing features of conditional random fields. In: <em>Proc. 19th Conference on Uncertainty in Artificial Intelligence</em>. (2003)</li>
</ul>
<ul>
<li>Wallach, H.M.: <a href="http://www.cs.umass.edu/~wallach/technical_reports/wallach04conditional.pdf">Conditional random fields: An introduction</a>. Technical report MS-CIS-04-21, University of Pennsylvania (2004)</li>
<li>Sutton, C., McCallum, A.: An Introduction to Conditional Random Fields for Relational Learning. In "Introduction to Statistical Relational Learning". Edited by <a href="Lise_Getoor" title="wikilink">Lise Getoor</a> and Ben Taskar. MIT Press. (2006) <a href="http://www.cs.umass.edu/~mccallum/papers/crf-tutorial.pdf">Online PDF</a></li>
<li>Klinger, R., Tomanek, K.: Classical Probabilistic Models and Conditional Random Fields. Algorithm Engineering Report TR07-2-013, Department of Computer Science, Dortmund University of Technology, December 2007. ISSN 1864-4503. <a href="http://www.scai.fraunhofer.de/fileadmin/images/bio/data_mining/paper/crf_klinger_tomanek.pdf">Online PDF</a></li>
</ul>

<p>"</p>

<p><a href="Category:Graphical_models" title="wikilink">Category:Graphical models</a> <a href="Category:Log-linear_models" title="wikilink">Category:Log-linear models</a> <a href="Category:Machine_learning" title="wikilink">Category:Machine learning</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15">T. Lavergne, O. Cappé and F. Yvon (2010). <a href="http://acl.eldoc.ub.rug.nl/mirror/P/P10/P10-1052.pdf">Practical very large scale CRFs</a>. Proc. 48th Annual Meeting of the <a href="Association_for_Computational_Linguistics" title="wikilink">ACL</a>, pp. 504-513.<a href="#fnref15">↩</a></li>
</ol>
</section>
</body>
</html>
