<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1819">Linear feedback shift register</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Linear feedback shift register</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>
<figure><b>(Figure)</b>
<figcaption>501 px|A 4-bit Fibonacci LFSR with its state diagram. The <a href="XOR_gate" title="wikilink">XOR gate</a> provides feedback to the register that shifts bits from left to right. The maximal sequence consists of every possible state except the "0000" state.</figcaption>
</figure>

<p>In <a class="uri" href="computing" title="wikilink">computing</a>, a <strong>linear-feedback shift register</strong> (LFSR) is a <a href="shift_register" title="wikilink">shift register</a> whose input bit is a <a href="Linear#Boolean_functions" title="wikilink">linear function</a> of its previous state.</p>

<p>The most commonly used linear function of single bits is <a class="uri" href="exclusive-or" title="wikilink">exclusive-or</a> (XOR). Thus, an LFSR is most often a shift register whose input bit is driven by the XOR of some bits of the overall shift register value.</p>

<p>The initial value of the LFSR is called the seed, and because the operation of the register is deterministic, the stream of values produced by the register is completely determined by its current (or previous) state. Likewise, because the register has a finite number of possible states, it must eventually enter a repeating cycle. However, an LFSR with a <a href="Primitive_polynomial_(field_theory)" title="wikilink">well-chosen feedback function</a> can produce a sequence of bits which appears random and which has a <a href="Maximal_length_sequence" title="wikilink">very long cycle</a>.</p>

<p>Applications of LFSRs include generating <a href="Pseudorandomness" title="wikilink">pseudo-random numbers</a>, <a href="Pseudorandom_noise" title="wikilink">pseudo-noise sequences</a>, fast digital counters, and <a href="whitening_sequences" title="wikilink">whitening sequences</a>. Both hardware and software implementations of LFSRs are common.</p>

<p>The mathematics of a <a href="cyclic_redundancy_check" title="wikilink">cyclic redundancy check</a>, used to provide a quick check against transmission errors, are closely related to those of an LFSR.</p>
<h2 id="fibonacci-lfsrs">Fibonacci LFSRs</h2>

<p> The bit positions that affect the next state are called the taps. In the diagram the taps are [16,14,13,11]. The rightmost bit of the LFSR is called the output bit. The taps are XOR'd sequentially with the output bit and then fed back into the leftmost bit. The sequence of bits in the rightmost position is called the output stream.</p>
<ul>
<li>The bits in the LFSR state that influence the input are called <em>taps</em> (white in the diagram).</li>
<li>A maximum-length LFSR produces an <a href="maximum_length_sequence" title="wikilink">m-sequence</a> (i.e. it cycles through all possible 2<sup><em>n</em></sup> − 1 states within the shift register except the state where all bits are zero), unless it contains all zeros, in which case it will never change.</li>
<li>As an alternative to the XOR-based feedback in an LFSR, one can also use <a class="uri" href="XNOR" title="wikilink">XNOR</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> This function is an <a href="affine_transformation" title="wikilink">affine map</a>, not strictly a <a href="linear_map" title="wikilink">linear map</a>, but it results in an equivalent polynomial counter whose state is the complement of the state of an LFSR. A state with all ones is illegal when using an XNOR feedback, in the same way as a state with all zeroes is illegal when using XOR. This state is considered illegal because the counter would remain "locked-up" in this state.</li>
</ul>

<p>The sequence of numbers generated by an LFSR or its XNOR counterpart can be considered a <a href="binary_numeral_system" title="wikilink">binary numeral system</a> just as valid as <a href="Gray_code" title="wikilink">Gray code</a> or the natural binary code.</p>

<p>The arrangement of taps for feedback in an LFSR can be expressed in <a href="finite_field_arithmetic" title="wikilink">finite field arithmetic</a> as a <a class="uri" href="polynomial" title="wikilink">polynomial</a> <a href="modular_arithmetic" title="wikilink">mod</a> 2. This means that the coefficients of the polynomial must be 1's or 0's. This is called the feedback polynomial or reciprocal characteristic polynomial. For example, if the taps are at the 16th, 14th, 13th and 11th bits (as shown), the feedback polynomial is</p>

<p>

<math display="block" id="Linear_feedback_shift_register:0">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>16</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>14</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>13</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>11</mn>
   </msup>
   <mo>+</mo>
   <mpadded width="+1.7pt">
    <mn>1.</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">16</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">14</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">13</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">11</cn>
    </apply>
    <cn type="float">1.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{16}+x^{14}+x^{13}+x^{11}+1.\,
  </annotation>
 </semantics>
</math>

</p>

<p>The 'one' in the polynomial does not correspond to a tap – it corresponds to the input to the first bit (i.e. <em>x<sup>0</sup></em>, which is equivalent to 1). The powers of the terms represent the tapped bits, counting from the left. The first and last bits are always connected as an input and output tap respectively.</p>

<p>The LFSR is maximal-length if and only if the corresponding feedback polynomial is <a href="primitive_polynomial_(field_theory)" title="wikilink">primitive</a>. This means that the following conditions are necessary (but not sufficient):</p>
<ul>
<li>The number of taps should be <a href="Even_and_odd_numbers" title="wikilink">even</a>.</li>
<li>The set of taps – taken all together, <em>not</em> pairwise (i.e. as pairs of elements) – must be <a href="relatively_prime" title="wikilink">relatively prime</a>. In other words, there must be no divisor other than 1 common to all taps.</li>
</ul>

<p>Tables of primitive polynomials from which maximum-length LFSRs can be constructed are given below and in the references.</p>

<p>There can be more than one maximum-length tap sequence for a given LFSR length. Also, once one maximum-length tap sequence has been found, another automatically follows. If the tap sequence, in an <em>n</em>-bit LFSR, is [<em>n</em>, <em>A</em>, <em>B</em>, <em>C</em>, 0], where the 0 corresponds to the <em>x</em><sup>0</sup> = 1 term, then the corresponding 'mirror' sequence is [<em>n</em>, <em>n</em> − <em>C</em>, <em>n</em> − <em>B</em>, <em>n</em> − <em>A</em>, 0]. So the tap sequence [32, 7, 3, 2, 0] has as its counterpart [32, 30, 29, 25, 0]. Both give a maximum-length sequence.</p>

<p>Some example C code is below:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot"># include <stdint.h></stdint.h></span>
<span class="dt">int</span> main(<span class="dt">void</span>)
{
    <span class="dt">uint16_t</span> start_state = 0xACE1u;  <span class="co">/* Any nonzero start state will work. */</span>
    <span class="dt">uint16_t</span> lfsr = start_state;
    <span class="dt">unsigned</span> bit;
    <span class="dt">unsigned</span> period = <span class="dv">0</span>;

    <span class="kw">do</span>
    {
        <span class="co">/* taps: 16 14 13 11; feedback polynomial: x^16 + x^14 + x^13 + x^11 + 1 */</span>
        bit  = ((lfsr &gt;&gt; <span class="dv">0</span>) ^ (lfsr &gt;&gt; <span class="dv">2</span>) ^ (lfsr &gt;&gt; <span class="dv">3</span>) ^ (lfsr &gt;&gt; <span class="dv">5</span>) ) &amp; <span class="dv">1</span>;
        lfsr =  (lfsr &gt;&gt; <span class="dv">1</span>) | (bit &lt;&lt; <span class="dv">15</span>);
        ++period;
    } <span class="kw">while</span> (lfsr != start_state);

    <span class="kw">return</span> <span class="dv">0</span>;
}
</code></pre></div></body>

<p>This LFSR configuration is also known as <strong>standard</strong>, <strong>many-to-one</strong> or <strong>external XOR gates</strong>. The alternative Galois configuration is described in the next section.</p>
<h2 id="galois-lfsrs">Galois LFSRs</h2>

<p>Named after the French mathematician <a href="Évariste_Galois" title="wikilink">Évariste Galois</a>, an LFSR in Galois configuration, which is also known as <strong>modular</strong>, <strong>internal XORs</strong> as well as <strong>one-to-many LFSR</strong>, is an alternate structure that can generate the same output stream as a conventional LFSR (but offset in time).<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> In the Galois configuration, when the system is clocked, bits that are not taps are shifted one position to the right unchanged. The taps, on the other hand, are XOR'd with the output bit before they are stored in the next position. The new output bit is the next input bit. The effect of this is that when the output bit is zero all the bits in the register shift to the right unchanged, and the input bit becomes zero. When the output bit is one, the bits in the tap positions all flip (if they are 0, they become 1, and if they are 1, they become 0), and then the entire register is shifted to the right and the input bit becomes 1.</p>
<figure><b>(Figure)</b>
<figcaption>393 px|A 16-bit Galois LFSR. The register numbers in white correspond to the same primitive polynomial as the Fibonacci example but are counted in reverse to the shifting direction. This register also cycles through the maximal number of 65535 states excluding the all-zeroes state. The state ACE1 hex shown will be followed by E270 hex.</figcaption>
</figure>

<p>To generate the same output stream, the order of the taps is the <em>counterpart</em> (see above) of the order for the conventional LFSR, otherwise the stream will be in reverse. Note that the internal state of the LFSR is not necessarily the same. The Galois register shown has the same output stream as the Fibonacci register in the first section. A time offset exists between the streams, so a different startpoint will be needed to get the same output each cycle.</p>
<ul>
<li>Galois LFSRs do not concatenate every tap to produce the new input (the XORing is done within the LFSR and no XOR gates are run in serial, therefore the propagation times are reduced to that of one XOR rather than a whole chain), thus it is possible for each tap to be computed in parallel, increasing the speed of execution.</li>
<li>In a software implementation of an LFSR, the Galois form is more efficient as the XOR operations can be implemented a word at a time: only the output bit must be examined individually.</li>
</ul>

<p>Below is a <a href="C_(programming_language)" title="wikilink">C</a> code example for the 16 bit maximal period Galois LFSR example in the figure:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot"># include <stdint.h></stdint.h></span>
<span class="dt">int</span> main(<span class="dt">void</span>)
{
    <span class="dt">uint16_t</span> start_state = 0xACE1u;  <span class="co">/* Any nonzero start state will work. */</span>
    <span class="dt">uint16_t</span> lfsr = start_state;
    <span class="dt">unsigned</span> period = <span class="dv">0</span>;

    <span class="kw">do</span>
    {
        <span class="dt">unsigned</span> lsb = lfsr &amp; <span class="dv">1</span>;   <span class="co">/* Get LSB (i.e., the output bit). */</span>
        lfsr &gt;&gt;= <span class="dv">1</span>;                <span class="co">/* Shift register */</span>
        lfsr ^= (-lsb) &amp; 0xB400u;  <span class="co">/* If the output bit is 1, apply toggle mask.</span>
<span class="co">                                    * The value has 1 at bits corresponding</span>
<span class="co">                                    * to taps, 0 elsewhere. */</span>
        ++period;
    } <span class="kw">while</span> (lfsr != start_state);

    <span class="kw">return</span> <span class="dv">0</span>;
}
</code></pre></div>
<h3 id="non-binary-galois-lfsr">Non-binary Galois LFSR</h3>

<p>Binary Galois LFSRs like the ones shown above can be generalized to any <em>q</em>-ary alphabet {0, 1, ..., <em>q</em> − 1} (e.g., for binary, <em>q</em> is equal to two, and the alphabet is simply {0, 1}). In this case, the exclusive-or component is generalized to addition <a href="Modular_arithmetic" title="wikilink">modulo</a>-<em>q</em> (note that XOR is addition modulo 2), and the feedback bit (output bit) is multiplied (modulo-<em>q</em>) by a <em>q</em>-ary value which is constant for each specific tap point. Note that this is also a generalization of the binary case, where the feedback is multiplied by either 0 (no feedback, i.e., no tap) or 1 (feedback is present). Given an appropriate tap configuration, such LFSRs can be used to generate <a href="Finite_field" title="wikilink">Galois fields</a> for arbitrary prime values of <em>q</em>.</p>
<h2 id="some-polynomials-for-maximal-lfsrs">Some polynomials for maximal LFSRs</h2>

<p>The following table lists maximal-length polynomials for shift-register lengths up to 19. Note that more than one maximal-length polynomial may exist for any given shift-register length. A list of alternative maximal-length polynomials for shift-register lengths 4-32 (beyond which it becomes unfeasible to store or transfer them) can be found here: <a class="uri" href="http://www.ece.cmu.edu/~koopman/lfsr/index.html">http://www.ece.cmu.edu/~koopman/lfsr/index.html</a></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Bits</p></th>
<th style="text-align: left;">
<p>Feedback polynomial</p></th>
<th style="text-align: left;">
<p>Period</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>n</em></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_feedback_shift_register:1">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>n</mi>
   </msup>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}-1
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_feedback_shift_register:2">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
   <mo>+</mo>
   <mi>x</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}+x+1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_feedback_shift_register:3">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>3</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{3}+x^{2}+1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>7</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_feedback_shift_register:4">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>4</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>3</mn>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">4</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">3</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{4}+x^{3}+1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>15</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_feedback_shift_register:5">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>5</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>3</mn>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">5</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">3</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{5}+x^{3}+1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>31</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_feedback_shift_register:6">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>6</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>5</mn>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">6</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">5</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{6}+x^{5}+1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>63</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_feedback_shift_register:7">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>7</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>6</mn>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">7</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">6</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{7}+x^{6}+1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>127</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_feedback_shift_register:8">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>8</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>6</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>5</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>4</mn>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">8</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">6</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">5</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">4</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{8}+x^{6}+x^{5}+x^{4}+1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>255</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>9</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_feedback_shift_register:9">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>9</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>5</mn>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">9</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">5</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{9}+x^{5}+1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>511</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>10</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_feedback_shift_register:10">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>10</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>7</mn>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">10</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">7</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{10}+x^{7}+1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>1023</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>11</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_feedback_shift_register:11">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>11</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>9</mn>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">11</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">9</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{11}+x^{9}+1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>2047</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>12</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_feedback_shift_register:12">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>12</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>11</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>10</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>4</mn>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">12</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">11</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">10</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">4</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{12}+x^{11}+x^{10}+x^{4}+1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>4095</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>13</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_feedback_shift_register:13">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>13</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>12</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>11</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>8</mn>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">13</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">12</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">11</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">8</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{13}+x^{12}+x^{11}+x^{8}+1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>8191</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>14</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_feedback_shift_register:14">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>14</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>13</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>12</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">14</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">13</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">12</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{14}+x^{13}+x^{12}+x^{2}+1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>16383</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>15</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_feedback_shift_register:15">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>15</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>14</mn>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">15</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">14</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{15}+x^{14}+1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>32767</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>16</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_feedback_shift_register:16">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>16</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>14</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>13</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>11</mn>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">16</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">14</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">13</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">11</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{16}+x^{14}+x^{13}+x^{11}+1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>65535</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>17</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_feedback_shift_register:17">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>17</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>14</mn>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">17</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">14</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{17}+x^{14}+1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>131071</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>18</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_feedback_shift_register:18">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>18</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>11</mn>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">18</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">11</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{18}+x^{11}+1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>262143</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>19</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_feedback_shift_register:19">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>19</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>18</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>17</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>x</mi>
    <mn>14</mn>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">19</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">18</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">17</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">14</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{19}+x^{18}+x^{17}+x^{14}+1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>524287</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>20-168</p></td>
<td style="text-align: left;">
<p><a href="http://www.xilinx.com/support/documentation/application_notes/xapp052.pdf">1</a></p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2-786,1024,2048,4096</p></td>
<td style="text-align: left;">
<p><a href="http://www.eej.ulst.ac.uk/~ian/modules/EEE515/files/old_files/lfsr/lfsr_table.pdf">2</a></p></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="output-stream-properties">Output-stream properties</h2>
<ul>
<li>Ones and zeroes occur in 'runs'. The output stream 1110010, for example consists of four runs of lengths 3,2,1,1, in order. In one period of a maximal LFSR, 2<sup><em>n</em> −1</sup> runs occur (for example, a six bit LFSR will have 32 runs). Exactly half of these runs will be one bit long, a quarter will be two bits long, up to a single run of zeroes <em>n</em> − 1 bits long, and a single run of ones <em>n</em> bits long. This distribution almost equals the statistical <a href="Expected_value" title="wikilink">expectation value</a> for a truly random sequence. However, the probability of finding exactly this distribution in a sample of a truly random sequence is rather low.</li>
<li>LFSR output streams are <a class="uri" href="deterministic" title="wikilink">deterministic</a>. If you know the present state as well as the positions of the XOR gates in the LFSR, you can predict the next state.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> This is not possible with truly random events. With minimal-length LFSRs, it is much easier to compute the next state, as there are only an easily limited number of them for each length.</li>
<li>The output stream is reversible; an LFSR with mirrored taps will cycle through the output sequence in reverse order.</li>
<li>The value consisting of all zeros cannot appear. Thus you can not use an LFSR of length n to generate all 2<sup>n</sup> values.</li>
</ul>
<h2 id="applications">Applications</h2>

<p>LFSRs can be implemented in hardware, and this makes them useful in applications that require very fast generation of a pseudo-random sequence, such as <a href="direct-sequence_spread_spectrum" title="wikilink">direct-sequence spread spectrum</a> radio. LFSRs have also been used for generating an approximation of <a href="white_noise" title="wikilink">white noise</a> in various <a href="programmable_sound_generator" title="wikilink">programmable sound generators</a>.</p>
<h3 id="uses-as-counters">Uses as counters</h3>

<p>The repeating sequence of states of an LFSR allows it to be used as a <a href="clock_divider" title="wikilink">clock divider</a>, or as a counter when a non-binary sequence is acceptable as is often the case where computer index or framing locations need to be machine-readable.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> LFSR <a href="Counter_(digital)" title="wikilink">counters</a> have simpler feedback logic than natural binary counters or <a href="Gray_code" title="wikilink">Gray code</a> counters, and therefore can operate at higher clock rates. However it is necessary to ensure that the LFSR never enters an all-zeros state, for example by presetting it at start-up to any other state in the sequence. The table of primitive polynomials shows how LFSRs can be arranged in Fibonacci or Galois form to give maximal periods. One can obtain any other period by adding to an LFSR that has a longer period some logic that shortens the sequence by skipping some states.</p>
<h3 id="uses-in-cryptography">Uses in cryptography</h3>

<p>LFSRs have long been used as <a href="pseudo-random_number_generator" title="wikilink">pseudo-random number generators</a> for use in <a href="stream_cipher" title="wikilink">stream ciphers</a> (especially in <a class="uri" href="military" title="wikilink">military</a> <a class="uri" href="cryptography" title="wikilink">cryptography</a>), due to the ease of construction from simple <a class="uri" href="electromechanical" title="wikilink">electromechanical</a> or <a href="electronic_circuits" title="wikilink">electronic circuits</a>, long <a href="periodic_function" title="wikilink">periods</a>, and very uniformly <a href="probability_distribution" title="wikilink">distributed</a> output streams. However, an LFSR is a linear system, leading to fairly easy <a class="uri" href="cryptanalysis" title="wikilink">cryptanalysis</a>. For example, given a stretch of known plaintext and corresponding ciphertext, an attacker can intercept and recover a stretch of LFSR output stream used in the system described, and from that stretch of the output stream can construct an LFSR of minimal size that simulates the intended receiver by using the <a href="Berlekamp-Massey_algorithm" title="wikilink">Berlekamp-Massey algorithm</a>. This LFSR can then be fed the intercepted stretch of output stream to recover the remaining plaintext.</p>

<p>Three general methods are employed to reduce this problem in LFSR-based stream ciphers:</p>
<ul>
<li><a class="uri" href="Non-linear" title="wikilink">Non-linear</a> combination of several <a href="bit" title="wikilink">bits</a> from the LFSR <a href="state_(computer_science)" title="wikilink">state</a>;</li>
<li>Non-linear combination of the output bits of two or more LFSRs (see also: <a href="shrinking_generator" title="wikilink">shrinking generator</a>); or using <a href="Evolutionary_algorithm" title="wikilink">Evolutionary algorithm</a> to introduce non-linearity.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
<li>Irregular clocking of the LFSR, as in the <a href="alternating_step_generator" title="wikilink">alternating step generator</a>.</li>
</ul>

<p>Important LFSR-based stream ciphers include <a class="uri" href="A5/1" title="wikilink">A5/1</a> and <a class="uri" href="A5/2" title="wikilink">A5/2</a>, used in <a class="uri" href="GSM" title="wikilink">GSM</a> cell phones, <a href="E0_(cipher)" title="wikilink">E0</a>, used in <a class="uri" href="Bluetooth" title="wikilink">Bluetooth</a>, and the <a href="shrinking_generator" title="wikilink">shrinking generator</a>. The A5/2 cipher has been broken and both A5/1 and E0 have serious weaknesses.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>The linear feedback shift register has a strong relationship to <a href="linear_congruential_generator" title="wikilink">linear congruential generators</a>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h3 id="uses-in-circuit-testing">Uses in circuit testing</h3>

<p>LFSRs are used in circuit testing, for test-pattern generation (for exhaustive testing, pseudo-random testing or pseudo-exhaustive testing) and for signature analysis.</p>
<h4 id="test-pattern-generation">Test-pattern generation</h4>

<p>Complete LFSR are commonly used as pattern generators for exhaustive testing, since they cover all possible inputs for an n input circuit. Maximum length LFSRs and weighted LFSRs are widely used as pseudo-random test pattern generators for pseudo-random test applications.</p>
<h4 id="signature-analysis">Signature analysis</h4>

<p>In <a href="built-in_self-test" title="wikilink">built-in self-test</a> (BIST) techniques, storing all the circuit outputs on chip is not possible, but the circuit output can be compressed to form a signature that will later be compared to the golden signature (of the good circuit) to detect faults. Since this compression is lossy, there is always a possibility that a faulty output also generates the same signature as the golden signature and the faults cannot be detected. This condition is called error masking or aliasing. BIST is accomplished with a multiple-input signature register (MISR or MSR), which is a type of LFSR. A standard LFSR has a single XOR or XNOR gate, where the input of the gate is connected to several "taps" and the output is connected to the input of the first flip-flop. A MISR has the same structure, but the input to every flip-flop is fed through an XOR/XNOR gate. For example, a four-bit MISR has a four-bit parallel output and a four-bit parallel input. The input of the first flip-flop is XOR/XNORd with parallel input bit zero and the "taps." Every other flip-flop input is XOR/XNORd with the preceding flip-flop output and the corresponding parallel input bit. Consequently, the next state of the MISR depends on the last several states opposed to just the current state. Therefore, a MISR will always generate the same golden signature given that the input sequence is the same every time.</p>
<h3 id="uses-in-digital-broadcasting-and-communications">Uses in digital broadcasting and communications</h3>
<h4 id="scrambling">Scrambling</h4>

<p>To prevent short repeating sequences (e.g., runs of 0's or 1's) from forming spectral lines that may complicate symbol tracking at the receiver or interfere with other transmissions, the data bit sequence is combined with the output of a linear feedback register before modulation and transmission. This scrambling is removed at the receiver after demodulation. When the LFSR runs at the same <a href="bit_rate" title="wikilink">bit rate</a> as the transmitted symbol stream, this technique is referred to as <a href="scrambler" title="wikilink">scrambling</a>. When the LFSR runs considerably faster than the symbol stream, the LFSR-generated bit sequence is called <em>chipping code</em>. The chipping code is combined with the data using <a href="exclusive_or" title="wikilink">exclusive or</a> before transmitting using <a href="binary_phase_shift_keying" title="wikilink">binary phase shift keying</a> or a similar modulation method. The resulting signal has an higher bandwidth than the data and therefore this is a method of <a href="spread_spectrum" title="wikilink">spread spectrum</a> communication. When used only for the spread spectrum property, this technique is called <a href="direct-sequence_spread_spectrum" title="wikilink">direct-sequence spread spectrum</a>; when used to distinguish several signals transmitted in the same channel at the same time and frequency it is called <a href="code_division_multiple_access" title="wikilink">code division multiple access</a>.</p>

<p>Neither scheme should be confused with <a class="uri" href="encryption" title="wikilink">encryption</a> or <a class="uri" href="encipherment" title="wikilink">encipherment</a>; scrambling and spreading with LFSRs do <em>not</em> protect the information from eavesdropping. They are instead used to produce equivalent streams that possess convenient engineering properties to allow for robust and efficient modulation and demodulation.</p>

<p>Digital broadcasting systems that use linear feedback registers:</p>
<ul>
<li><a href="ATSC_Standards" title="wikilink">ATSC Standards</a> (digital TV transmission system – North America)</li>
<li><a href="Digital_Audio_Broadcasting" title="wikilink">DAB</a> (<a href="Digital_Audio_Broadcasting" title="wikilink">Digital Audio Broadcasting</a> system – for radio)</li>
<li><a class="uri" href="DVB-T" title="wikilink">DVB-T</a> (digital TV transmission system – Europe, Australia, parts of Asia)</li>
<li><a class="uri" href="NICAM" title="wikilink">NICAM</a> (digital audio system for television)</li>
</ul>

<p>Other digital communications systems using LFSRs:</p>
<ul>
<li>INTELSAT business service (IBS)</li>
<li>Intermediate data rate (IDR)</li>
<li><a href="Serial_digital_interface" title="wikilink">SDI</a> (Serial Digital Interface transmission)</li>
<li>Data transfer over <a class="uri" href="PSTN" title="wikilink">PSTN</a> (according to the <a class="uri" href="ITU-T" title="wikilink">ITU-T</a> V-series recommendations)</li>
<li><a class="uri" href="CDMA" title="wikilink">CDMA</a> (Code Division Multiple Access) cellular telephony</li>
<li><a href="Fast_Ethernet#100BASE-T2" title="wikilink">100BASE-T2 "fast" Ethernet</a> scrambles bits using an LFSR</li>
<li><a href="Gigabit_Ethernet#1000BASE-T" title="wikilink">1000BASE-T Ethernet</a>, the most common form of Gigabit Ethernet, scrambles bits using an LFSR</li>
<li><a href="PCI_Express" title="wikilink">PCI Express</a> 3.0</li>
<li><a class="uri" href="SATA" title="wikilink">SATA</a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></li>
<li><a href="Serial_attached_SCSI" title="wikilink">Serial attached SCSI</a> (SAS/SPL)</li>
<li><a href="USB_3.0" title="wikilink">USB 3.0</a></li>
<li><a href="IEEE_802.11a" title="wikilink">IEEE 802.11a</a> scrambles bits using an LFSR</li>
<li><a href="Bluetooth_Low_Energy" title="wikilink">Bluetooth Low Energy</a> Link Layer is making use of LFSR (referred to as whitening)</li>
<li><a href="Satellite_navigation_system" title="wikilink">Satellite navigation systems</a> such as <a class="uri" href="GPS" title="wikilink">GPS</a> and <a class="uri" href="GLONASS" title="wikilink">GLONASS</a>. All current systems use LFSR outputs to generate some or all of their ranging codes, that is: as the chipping code for CDMA or DSSS, or to modulate the carrier without data (like GPS L2 CL ranging code). GLONASS also uses <a href="frequency_division_multiple_access" title="wikilink">frequency division multiple access</a> combined with DSSS.</li>
</ul>
<h4 id="other-uses">Other uses</h4>

<p>LFSRs are also used in <a href="Communications_System_Jamming" title="wikilink">Communications System Jamming</a> systems to generate pseudo-random noise to raise the noise floor of a target communication system.</p>

<p>The German time signal <a class="uri" href="DCF77" title="wikilink">DCF77</a>, in addition to amplitude keying, employs <a href="phase-shift_keying" title="wikilink">phase-shift keying</a> driven by a 9-stage LFSR to increase the accuracy of received time and the robustness of the data stream in the presence of noise.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Pinwheel_(cryptography)" title="wikilink">Pinwheel</a></li>
<li><a href="Mersenne_twister" title="wikilink">Mersenne twister</a></li>
<li><a href="Maximum_length_sequence" title="wikilink">Maximum length sequence</a></li>
<li><a href="Analog_feedback_shift_register" title="wikilink">Analog feedback shift register</a></li>
<li><a class="uri" href="NLFSR" title="wikilink">NLFSR</a>, Non-Linear Feedback Shift Register</li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.newwaveinstruments.com/resources/articles/m_sequence_linear_feedback_shift_register_lfsr.htm">LFSR Reference</a> LFSR theory and implementation, maximal length sequences, and comprehensive feedback tables for lengths from 7 to 16,777,215 (3 to 24 stages), and partial tables for lengths up to 4,294,967,295 (25 to 32 stages).</li>
<li><a href="http://www.itu.int/rec/T-REC-O.151-199210-I/en">International Telecommunications Union Recommendation O.151</a> (August 1992)</li>
<li>[<a class="uri" href="http://spreadsheets.google.com/ccc?key=0AvYtZsho-JTldFRYZnJLRFFaSWtUcVNXc1Y3M2VWd1E&amp;hl">http://spreadsheets.google.com/ccc?key=0AvYtZsho-JTldFRYZnJLRFFaSWtUcVNXc1Y3M2VWd1E&amp;hl;</a>;=en Maximal Length LFSR table] with length from 2 to 67.</li>
<li>[<a class="uri" href="http://www.maxim-ic.com/appnotes.cfm?appnote_number=1743&amp;CMP">http://www.maxim-ic.com/appnotes.cfm?appnote_number=1743&amp;CMP;</a>;=WP-9 Pseudo-Random Number Generation Routine]</li>
<li><a class="uri" href="http://www.ece.ualberta.ca/~elliott/ee552/studentAppNotes/1999f/Drivers_Ed/lfsr.html">http://www.ece.ualberta.ca/~elliott/ee552/studentAppNotes/1999f/Drivers_Ed/lfsr.html</a></li>
<li><a class="uri" href="http://www.quadibloc.com/crypto/co040801.htm">http://www.quadibloc.com/crypto/co040801.htm</a></li>
<li><a href="http://www.yikes.com/~ptolemy/lfsr_web/index.htm">Simple explanation of LFSRs for Engineers</a></li>
<li><a href="http://www.ece.cmu.edu/~koopman/lfsr/index.html">Feedback terms</a></li>
<li><a href="http://homepage.mac.com/afj/lfsr.html">General LFSR Theory</a></li>
<li><a href="http://opencores.org/project,lfsr_randgen">An implementation of LFSR in VHDL.</a></li>
<li><a href="http://emmanuel.pouly.free.fr">Simple VHDL coding for Galois and Fibonacci LFSR.</a></li>
</ul>

<p>"</p>

<p><a href="Category:Binary_arithmetic" title="wikilink">Category:Binary arithmetic</a> <a href="Category:Digital_registers" title="wikilink">Category:Digital registers</a> <a href="Category:Cryptographic_algorithms" title="wikilink">Category:Cryptographic algorithms</a> <a href="Category:Pseudorandom_number_generators" title="wikilink">Category:Pseudorandom number generators</a> <a href="Category:Articles_with_example_C_code" title="wikilink">Category:Articles with example C code</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.xilinx.com/support/documentation/application_notes/xapp210.pdf">Linear Feedback Shift Registers in Virtex Devices</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a class="uri" href="http://www.xilinx.com/support/documentation/application_notes/xapp052.pdf">http://www.xilinx.com/support/documentation/application_notes/xapp052.pdf</a><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5">A. Poorghanad, A. Sadr, A. Kashanipour" Generating High Quality Pseudo Random Number Using Evolutionary Methods", IEEE Congress on Computational Intelligence and Security, vol. 9, pp. 331-335 , May,2008 <a href="http://www.computer.org/csdl/proceedings/cis/2008/3508/01/3508a331.pdf">3</a><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8">RFC 4086 section 6.1.3 "Traditional Pseudo-random Sequences"<a href="#fnref8">↩</a></li>
<li id="fn9">Section 9.5 of the SATA Specification, revision 2.6<a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
</ol>
</section>


