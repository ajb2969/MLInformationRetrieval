   NTRUEncrypt      NTRUEncrypt   The NTRUEncrypt  public key cryptosystem , also known as the NTRU encryption algorithm , is a lattice-based alternative to RSA and ECC and is based on the shortest vector problem in a lattice (which is not known to be breakable using quantum computers ). Operations are based on objects in a truncated polynomial ring      R   =    ℤ   [  X  ]    /   (    X  N   -  1   )        R      ℤ   delimited-[]  X       superscript  X  N   1      \ R=\mathbb{Z}[X]/(X^{N}-1)   with convolution multiplication and all polynomials in the ring have integer  coefficients and degree at most N -1:      𝐚  =    a  0   +    a  1   X   +    a  2    X  2    +  ⋯  +    a   N  -  2     X   N  -  2     +    a   N  -  1     X   N  -  1          a     subscript  a  0      subscript  a  1   X      subscript  a  2    superscript  X  2    normal-⋯     subscript  a    N  2     superscript  X    N  2        subscript  a    N  1     superscript  X    N  1        \textbf{a}=a_{0}+a_{1}X+a_{2}X^{2}+\cdots+a_{N-2}X^{N-2}+a_{N-1}X^{N-1}     NTRU is actually a parameterised family of cryptosystems; each system is specified by three integer parameters ( N , p , q ) which represent the maximal degree     N   -  1      N  1    \ N-1   for all polynomials in the truncated ring R , a small modulus and a large modulus, respectively, where it is assumed that N is prime , q is always larger than p , and p and q are coprime ; and four sets of polynomials      ℒ   f   ,   ℒ  g   ,   ℒ  m       subscript  ℒ  f    subscript  ℒ  g    subscript  ℒ  m     \ \mathcal{L}_{f},\mathcal{L}_{g},\mathcal{L}_{m}   and     ℒ   r     subscript  ℒ  r    \ \mathcal{L}_{r}   (a polynomial part of the private key, a polynomial for generation of the public key, the message and a blinding value, respectively), all of degree at most     N   -  1      N  1    \ N-1   .  It relies on the presumed difficulty of factoring certain polynomials in such rings into a quotient of two polynomials having very small coefficients. Breaking the cryptosystem is strongly related, though not equivalent, to the algorithmic problem of lattice reduction in certain lattices . Careful choice of parameters is necessary to thwart some published attacks.  Since both encryption and decryption use only simple polynomial multiplication, these operations are very fast compared to other asymmetric encryption schemes, such as RSA, El Gamal and elliptic curve cryptography . However, NTRUEncrypt has not yet undergone a comparable amount of cryptographic analysis.  A related algorithm is the NTRUSign  digital signature algorithm.  History  The NTRUEncrypt Public Key Cryptosystem is a relatively new cryptosystem. The first version of the system, which was simply called NTRU, was developed around 1996 by three mathematicians (, Jill Pipher , and Joseph H. Silverman ). In 1996 these mathematicians together with Daniel Lieman founded the NTRU Cryptosystems, Inc. and were given a patent on the cryptosystem.  During the last ten years people have been working on improving the cryptosystem. Since the first presentation of the cryptosystem, some changes were made to improve both the performance of the system and its security. Most performance improvements were focussed on speeding up the process. Up till 2005 literature can be found that describes the decryption failures of the NTRUEncrypt. As for security, since the first version of the NTRUEncrypt, new parameters have been introduced that seem secure for all currently known attacks and reasonable increase in computation power.  Now the system is fully accepted to IEEE P1363 standards under the specifications for lattice-based public-key cryptography ( IEEE P1363.1 ). Because of the speed of the NTRUEncrypt Public Key Cryptosystem (see http://bench.cr.yp.to for benchmarking results) and its low memory use (see below ), it can be used in applications such as mobile devices and Smart-cards . In April 2011, NTRUEncrypt was accepted as a X9.98 Standard, for use in the financial services industry. 1  Public key generation  Sending a secret message from Alice to Bob requires the generation of a public and a private key. The public key is known by both Alice and Bob and the private key is only known by Bob. To generate the key pair two polynomials f and g , with degree at most     N   -  1      N  1    \ N-1   and with coefficients in {-1,0,1} are required. They can be considered as representations of the residue classes of polynomials modulo      X   N   -  1       superscript  X  N   1    \ X^{N}-1   in R . The polynomial    𝐟  ∈   L  f       f   subscript  L  f     \textbf{f}\in L_{f}   must satisfy the additional requirement that the inverses modulo q and modulo p (computed using the Euclidean algorithm ) exist, which means that      𝐟   ⋅   𝐟  p    =   1     (   mod  p   )         normal-⋅  f   subscript  f  p     annotated  1   pmod  p      \ \textbf{f}\cdot\textbf{f}_{p}=1\;\;(\mathop{{\rm mod}}p)   and      𝐟   ⋅   𝐟  q    =   1     (   mod  q   )         normal-⋅  f   subscript  f  q     annotated  1   pmod  q      \ \textbf{f}\cdot\textbf{f}_{q}=1\;\;(\mathop{{\rm mod}}q)   must hold. So when the chosen f is not invertible, Bob has to go back and try another f .  Both f and     𝐟   p     subscript  𝐟  p    \ \mathbf{f}_{p}   are Bob’s private key. The public key h is generated computing the quantity       𝐡  =     p   𝐟  q    ⋅  𝐠      (   mod  q   )     .      h   annotated   normal-⋅    p   subscript  f  q    g    pmod  q      \textbf{h}=p\textbf{f}_{q}\cdot\textbf{g}\;\;(\mathop{{\rm mod}}q).     Example : In this example the parameters ( N , p , q ) will have the values N = 11, p = 3 and q = 32 and therefore the polynomials f and g are of degree at most 10. The system parameters ( N , p , q ) are known to everybody. The polynomials are randomly chosen, so suppose they are represented by      𝐟  =       -  1   +  X  +   X  2    -   X  4    +   X  6   +   X  9    -   X  10        f            1   X   superscript  X  2     superscript  X  4     superscript  X  6    superscript  X  9     superscript  X  10      \textbf{f}=-1+X+X^{2}-X^{4}+X^{6}+X^{9}-X^{10}         𝐠  =     -  1   +   X  2   +   X  3   +   X  5    -   X  8   -   X  10        g        1    superscript  X  2    superscript  X  3    superscript  X  5     superscript  X  8    superscript  X  10      \textbf{g}=-1+X^{2}+X^{3}+X^{5}-X^{8}-X^{10}     Using the Euclidean algorithm the inverse of f modulo p and modulo q , respectively, is computed       𝐟  p   =    1  +   2  X   +   2   X  3    +   2   X  4    +   X  5   +   2   X  7    +   X  8   +   2   X  9        (   mod  3   )         subscript  f  p    annotated    1    2  X     2   superscript  X  3      2   superscript  X  4     superscript  X  5     2   superscript  X  7     superscript  X  8     2   superscript  X  9      pmod  3      \textbf{f}_{p}=1+2X+2X^{3}+2X^{4}+X^{5}+2X^{7}+X^{8}+2X^{9}\;\;(\mathop{{\rm
 mod%
 }}3)          𝐟  q   =    5  +   9  X   +   6   X  2    +   16   X  3    +   4   X  4    +   15   X  5    +   16   X  6    +   22   X  7    +   20   X  8    +   18   X  9    +   30   X  10        (   mod  32   )         subscript  f  q    annotated    5    9  X     6   superscript  X  2      16   superscript  X  3      4   superscript  X  4      15   superscript  X  5      16   superscript  X  6      22   superscript  X  7      20   superscript  X  8      18   superscript  X  9      30   superscript  X  10      pmod  32      \textbf{f}_{q}=5+9X+6X^{2}+16X^{3}+4X^{4}+15X^{5}+16X^{6}+22X^{7}+20X^{8}+18X^%
 {9}+30X^{10}\;\;(\mathop{{\rm mod}}32)     Which creates the public key h (known to both Alice and Bob) computing the product      𝐡  =     p   𝐟  q    ⋅  𝐠      (   mod  32   )    =           8  -   7  X   -   10   X  2    -   12   X  3     +   12   X  4     -   8   X  5     +   15   X  6     -   13   X  7     +   12   X  8     -   13   X  9     +   16   X  10        (   mod  32   )          h   annotated   normal-⋅    p   subscript  f  q    g    pmod  32          annotated                  8    7  X     10   superscript  X  2      12   superscript  X  3       12   superscript  X  4       8   superscript  X  5       15   superscript  X  6       13   superscript  X  7       12   superscript  X  8       13   superscript  X  9       16   superscript  X  10      pmod  32       \textbf{h}=p\textbf{f}_{q}\cdot\textbf{g}\;\;(\mathop{{\rm mod}}32)=8-7X-10X^{%
 2}-12X^{3}+12X^{4}-8X^{5}+15X^{6}-13X^{7}+12X^{8}-13X^{9}+16X^{10}\;\;(\mathop%
 {{\rm mod}}32)     Encryption  Alice, who wants to send a secret message to Bob, puts her message in the form of a polynomial m with coefficients {-1,0,1}. In modern applications of the encryption, the message polynomial can be translated in a binary or ternary representation. After creating the message polynomial, Alice chooses randomly a polynomial r with small coefficients (not restricted to the set {-1,0,1}), that is meant to obscure the message.  With Bob’s public key h the encrypted message e is computed:      𝐞  =     𝐫  ⋅  𝐡   +  𝐦      (   mod  q   )        e   annotated     normal-⋅  r  h   m    pmod  q      \textbf{e}=\textbf{r}\cdot\textbf{h}+\textbf{m}\;\;(\mathop{{\rm mod}}q)     This ciphertext hides Alice’s messages and can be sent safely to Bob.  Example : Assume that Alice wants to send a message that can be written as polynomial      𝐦  =      -  1   +   X  3    -   X  4   -   X  8    +   X  9   +   X  10        m          1    superscript  X  3     superscript  X  4    superscript  X  8     superscript  X  9    superscript  X  10      \textbf{m}=-1+X^{3}-X^{4}-X^{8}+X^{9}+X^{10}   and that the randomly chosen ‘blinding value’ can be expressed as      𝐫  =     -  1   +   X  2   +   X  3   +   X  4    -   X  5   -   X  7        r        1    superscript  X  2    superscript  X  3    superscript  X  4     superscript  X  5    superscript  X  7      \textbf{r}=-1+X^{2}+X^{3}+X^{4}-X^{5}-X^{7}     The ciphertext e that represents her encrypted message to Bob will look like      𝐞  =     𝐫  ⋅  𝐡   +  𝐦      (   mod  32   )    =    14  +   11  X   +   26   X  2    +   24   X  3    +   14   X  4    +   16   X  5    +   30   X  6    +   7   X  7    +   25   X  8    +   6   X  9    +   19   X  10        (   mod  32   )          e   annotated     normal-⋅  r  h   m    pmod  32          annotated    14    11  X     26   superscript  X  2      24   superscript  X  3      14   superscript  X  4      16   superscript  X  5      30   superscript  X  6      7   superscript  X  7      25   superscript  X  8      6   superscript  X  9      19   superscript  X  10      pmod  32       \textbf{e}=\textbf{r}\cdot\textbf{h}+\textbf{m}\;\;(\mathop{{\rm mod}}32)=14+1%
 1X+26X^{2}+24X^{3}+14X^{4}+16X^{5}+30X^{6}+7X^{7}+25X^{8}+6X^{9}+19X^{10}\;\;(%
 \mathop{{\rm mod}}32)     Decryption  Anybody knowing r could compute the message m ; so r must not be revealed by Alice. In addition to the publicly available information, Bob knows his own private key. Here is how he can obtain m : First he multiplies the encrypted message e and part of his private key f      𝐚  =    𝐟  ⋅  𝐞      (   mod  q   )        a   annotated   normal-⋅  f  e    pmod  q      \textbf{a}=\textbf{f}\cdot\textbf{e}\;\;(\mathop{{\rm mod}}q)     By rewriting the polynomials, this equation is actually representing the following computation:      𝐚  =    𝐟  ⋅  𝐞      (   mod  q   )        a   annotated   normal-⋅  f  e    pmod  q      \textbf{a}=\textbf{f}\cdot\textbf{e}\;\;(\mathop{{\rm mod}}q)         𝐚  =    𝐟  ⋅   (    𝐫  ⋅  𝐡   +  𝐦   )       (   mod  q   )        a   annotated   normal-⋅  f     normal-⋅  r  h   m     pmod  q      \textbf{a}=\textbf{f}\cdot(\textbf{r}\cdot\textbf{h}+\textbf{m})\;\;(\mathop{{%
 \rm mod}}q)         𝐚  =    𝐟  ⋅   (      𝐫  ⋅  p    𝐟  q    ⋅  𝐠   +  𝐦   )       (   mod  q   )        a   annotated   normal-⋅  f     normal-⋅     normal-⋅  r  p    subscript  f  q    g   m     pmod  q      \textbf{a}=\textbf{f}\cdot(\textbf{r}\cdot p\textbf{f}_{q}\cdot\textbf{g}+%
 \textbf{m})\;\;(\mathop{{\rm mod}}q)         𝐚  =      p  𝐫   ⋅  𝐠   +   𝐟  ⋅  𝐦       (   mod  q   )        a   annotated     normal-⋅    p  r   g    normal-⋅  f  m     pmod  q      \textbf{a}=p\textbf{r}\cdot\textbf{g}+\textbf{f}\cdot\textbf{m}\;\;(\mathop{{%
 \rm mod}}q)     Instead of choosing the coefficients of a between 0 and q – 1 they are chosen in the interval [- q /2, q /2] to prevent that the original message may not be properly recovered since Alice chooses the coordinates of her message m in the interval [- p /2, p /2]. This implies that all coefficients of       p   𝐫   ⋅  𝐠   +   𝐟  ⋅  𝐦        normal-⋅    p  r   g    normal-⋅  f  m     \ p\textbf{r}\cdot\textbf{g}+\textbf{f}\cdot\textbf{m}   already lie within the interval [- q /2, q /2] because the polynomials r , g , f and m and prime p all have coefficients that are small compared to q . This means that all coefficients are left unchanged during reducing modulo q and that the original message may be recovered properly.  The next step will be to calculate a modulo p :      𝐛  =   𝐚     (   mod  p   )    =    𝐟  ⋅  𝐦      (   mod  p   )          b   annotated  a   pmod  p          annotated   normal-⋅  f  m    pmod  p       \textbf{b}=\textbf{a}\;\;(\mathop{{\rm mod}}p)=\textbf{f}\cdot\textbf{m}\;\;(%
 \mathop{{\rm mod}}p)   because        p   𝐫   ⋅  𝐠      (   mod  p   )    =  0       annotated   normal-⋅    p  r   g    pmod  p    0    \ p\textbf{r}\cdot\textbf{g}\;\;(\mathop{{\rm mod}}p)=0   .  Knowing b Bob can use the other part of his private key    (   𝐟  p   )     subscript  f  p    \ \left(\textbf{f}_{p}\right)   to recover Alice’s message by multiplication of b and     𝐟   p     subscript  f  p    \ \textbf{f}_{p}         𝐜  =    𝐟  p   ⋅  𝐛   =     𝐟  p   ⋅  𝐟  ⋅  𝐦      (   mod  p   )          c   normal-⋅   subscript  f  p   b         annotated   normal-⋅   subscript  f  p   f  m    pmod  p       \textbf{c}=\textbf{f}_{p}\cdot\textbf{b}=\textbf{f}_{p}\cdot\textbf{f}\cdot%
 \textbf{m}\;\;(\mathop{{\rm mod}}p)         𝐜  =   𝐦     (   mod  p   )        c   annotated  m   pmod  p      \textbf{c}=\textbf{m}\;\;(\mathop{{\rm mod}}p)     because the property      𝐟   ⋅   𝐟  p    =   1     (   mod  p   )         normal-⋅  f   subscript  f  p     annotated  1   pmod  p      \ \textbf{f}\cdot\textbf{f}_{p}=1\;\;(\mathop{{\rm mod}}p)   was required for     𝐟   p     subscript  f  p    \ \textbf{f}_{p}   .  Example : The encrypted message e from Alice to Bob is multiplied with polynomial f       𝐚  =    𝐟  ⋅  𝐞      (   mod  32   )    =      3  -   7  X   -   10   X  2    -   11   X  3     +   10   X  4    +   7   X  5    +   6   X  6    +   7   X  7    +   5   X  8     -   3   X  9    -   7   X  10        (   mod  32   )     ,        a   annotated   normal-⋅  f  e    pmod  32          annotated        3    7  X     10   superscript  X  2      11   superscript  X  3       10   superscript  X  4      7   superscript  X  5      6   superscript  X  6      7   superscript  X  7      5   superscript  X  8       3   superscript  X  9      7   superscript  X  10      pmod  32       \textbf{a}=\textbf{f}\cdot\textbf{e}\;\;(\mathop{{\rm mod}}32)=3-7X-10X^{2}-11%
 X^{3}+10X^{4}+7X^{5}+6X^{6}+7X^{7}+5X^{8}-3X^{9}-7X^{10}\;\;(\mathop{{\rm mod}%
 }32),   where Bob uses the interval [- q /2, q /2] instead of the interval [0, q – 1] for the coefficients of polynomial a to prevent that the original message may not be recovered correctly.  Reducing the coefficients of a mod p results in      𝐛  =   𝐚     (   mod  3   )    =       -  X   -   X  2    +   X  3   +   X  4   +   X  5   +   X  7    -   X  8   -   X  10       (   mod  3   )          b   annotated  a   pmod  3          annotated          X    superscript  X  2     superscript  X  3    superscript  X  4    superscript  X  5    superscript  X  7     superscript  X  8    superscript  X  10     pmod  3       \textbf{b}=\textbf{a}\;\;(\mathop{{\rm mod}}3)=-X-X^{2}+X^{3}+X^{4}+X^{5}+X^{7%
 }-X^{8}-X^{10}\;\;(\mathop{{\rm mod}}3)   which equals     𝐛   =    𝐟  ⋅  𝐦      (   mod  3   )        b   annotated   normal-⋅  f  m    pmod  3      \ \textbf{b}=\textbf{f}\cdot\textbf{m}\;\;(\mathop{{\rm mod}}3)   .  In the last step the result is multiplied with     𝐟   p     subscript  f  p    \ \textbf{f}_{p}   from Bob’s private key to end up with the original message m      𝐜  =    𝐟  p   ⋅  𝐛   =     𝐟  p   ⋅  𝐟  ⋅  𝐦      (   mod  3   )    =   𝐦     (   mod  3   )          c   normal-⋅   subscript  f  p   b         annotated   normal-⋅   subscript  f  p   f  m    pmod  3          annotated  m   pmod  3       \textbf{c}=\textbf{f}_{p}\cdot\textbf{b}=\textbf{f}_{p}\cdot\textbf{f}\cdot%
 \textbf{m}\;\;(\mathop{{\rm mod}}3)=\textbf{m}\;\;(\mathop{{\rm mod}}3)         𝐜  =      -  1   +   X  3    -   X  4   -   X  8    +   X  9   +   X  10        c          1    superscript  X  3     superscript  X  4    superscript  X  8     superscript  X  9    superscript  X  10      \textbf{c}=-1+X^{3}-X^{4}-X^{8}+X^{9}+X^{10}   Which indeed is the original message Alice has sent to Bob!  Attacks  Since the proposal of NTRU several attacks on the NTRUEncrypt public key cryptosystem have been introduced. Most attacks are focused on making a total break by finding the secret key f instead of just recovering the message m . If f is known to have very few non-zero coefficients Eve can successfully mount a brute force attack by trying all values for f . When Eve wants to know whether f ´ is the secret key, she simply calculates       𝐟     ′    ⋅  𝐡      (   mod  q   )      annotated   normal-⋅   superscript  f   normal-′    h    pmod  q     \ \textbf{f}^{{}^{\prime}}\cdot\textbf{h}\;\;(\mathop{{\rm mod}}q)   . If it has small coefficients it might be the secret key f , and Eve can test if f ´ is the secret key by using it to decrypt a message she encrypted herself. Eve could also try values of g and test if       𝐠     ′    ⋅   𝐡   -  1        (   mod  q   )      annotated   normal-⋅   superscript  g   normal-′     superscript  h    1      pmod  q     \ \textbf{g}^{{}^{\prime}}\cdot\textbf{h}^{-1}\;\;(\mathop{{\rm mod}}q)   has small values.  It is possible to mount a meet-in-the-middle attack which is more powerful. It can cut the search time by square root. The attack is based on the property that      𝐟   ⋅  𝐡   =   𝐠     (   mod  q   )         normal-⋅  f  h    annotated  g   pmod  q      \ \textbf{f}\cdot\textbf{h}=\textbf{g}\;\;(\mathop{{\rm mod}}q)   .  Eve wants to find     𝐟   1     subscript  f  1    \ \textbf{f}_{1}   and     𝐟   2     subscript  f  2    \ \textbf{f}_{2}   such that     𝐟   =    𝐟  1   +   𝐟  2        f     subscript  f  1    subscript  f  2      \ \textbf{f}=\textbf{f}_{1}+\textbf{f}_{2}   holds and such that they have the property        (    𝐟  1   +   𝐟  2    )   ⋅  𝐡   =   𝐠     (   mod  q   )         normal-⋅     subscript  f  1    subscript  f  2    h    annotated  g   pmod  q      \left(\textbf{f}_{1}+\textbf{f}_{2}\right)\cdot\textbf{h}=\textbf{g}\;\;(%
 \mathop{{\rm mod}}q)           𝐟  1   ⋅  𝐡   =    𝐠  -    𝐟  2   ⋅  𝐡       (   mod  q   )         normal-⋅   subscript  f  1   h    annotated    g   normal-⋅   subscript  f  2   h     pmod  q      \textbf{f}_{1}\cdot\textbf{h}=\textbf{g}-\textbf{f}_{2}\cdot\textbf{h}\;\;(%
 \mathop{{\rm mod}}q)     If f has d one’s and N - d zero’s, then Eve creates all possible     𝐟   1     subscript  f  1    \ \textbf{f}_{1}   and     𝐟   2     subscript  f  2    \ \textbf{f}_{2}   in which they both have length      1  2    N        1  2   N    \ \frac{1}{2}N   (e.g.     𝐟   1     subscript  f  1    \ \textbf{f}_{1}   covers the      1  2    N        1  2   N    \ \frac{1}{2}N   lowest coefficients of f and     𝐟   2     subscript  f  2    \ \textbf{f}_{2}   the highest) with d /2 one’s. Then she computes      𝐟  1   ⋅  𝐡      (   mod  q   )      annotated   normal-⋅   subscript  f  1   h    pmod  q     \textbf{f}_{1}\cdot\textbf{h}\;\;(\mathop{{\rm mod}}q)   for all     𝐟   1     subscript  f  1    \ \textbf{f}_{1}   and orders them in bins based on the first k coordinates. After that she computes all     -    𝐟  2   ⋅  𝐡       (   mod  q   )      annotated     normal-⋅   subscript  f  2   h     pmod  q     \ -\textbf{f}_{2}\cdot\textbf{h}\;\;(\mathop{{\rm mod}}q)   and orders them in bins not only based on the first k coordinates, but also based on what happens if you add 1 to the first k coordinates. Then you check the bins that contain both     𝐟   1     subscript  f  1    \ \textbf{f}_{1}   and     𝐟   2     subscript  f  2    \ \textbf{f}_{2}   and see if the property       𝐟   1   ⋅  𝐡   =    𝐠  -    𝐟  2   ⋅  𝐡       (   mod  q   )         normal-⋅   subscript  f  1   h    annotated    g   normal-⋅   subscript  f  2   h     pmod  q      \ \textbf{f}_{1}\cdot\textbf{h}=\textbf{g}-\textbf{f}_{2}\cdot\textbf{h}\;\;(%
 \mathop{{\rm mod}}q)   holds.  The lattice reduction attack is one of the best known and one of the most practical methods to break the NTRUEncrypt. In a way it can be compared to the factorization of the modulus in RSA. The most used algorithm for the lattice reduction attack is the Lenstra-Lenstra-Lovász algorithm . Because the public key h contains both f and g one can try to obtain them from h . It is however too hard to find the secret key when the NTRUEncrypt parameters are chosen secure enough. The lattice reduction attack becomes harder if the dimension of the lattice gets bigger and the shortest vector gets longer.  The chosen ciphertext attack is also a method which recovers the secret key f and thereby results in a total break. In this attack Eve tries to obtain her own message from the ciphertext and thereby tries to obtain the secret key. In this attack Eve doesn’t have any interaction with Bob.  How it works :  First Eve creates a cipher text     𝐞   =    c  𝐡   +  c       e      c  h   c     \ \textbf{e}=c\textbf{h}+c   such that      c   =   0     (   mod  p   )     ,   c  <   q  2       formulae-sequence    c   annotated  0   pmod  p       c    q  2      \ c=0\;\;(\mathop{{\rm mod}}p),c<\frac{q}{2}   and     2  c   >   q  2         2  c     q  2     \ 2c>\frac{q}{2}   When Eve writes down the steps to deciphers e (without actually calculating the values since she does not know f) she finds     𝐚   =    𝐟  ⋅  𝐞      (   mod  q   )        a   annotated   normal-⋅  f  e    pmod  q      \ \textbf{a}=\textbf{f}\cdot\textbf{e}\;\;(\mathop{{\rm mod}}q)   :      𝐚  =    𝐟   (    c  𝐡   +  c   )       (   mod  q   )        a   annotated    f      c  h   c     pmod  q      \textbf{a}=\textbf{f}\left(c\textbf{h}+c\right)\;\;(\mathop{{\rm mod}}q)         𝐚  =     c  𝐠   +   c  𝐟       (   mod  q   )        a   annotated      c  g     c  f     pmod  q      \textbf{a}=c\textbf{g}+c\textbf{f}\;\;(\mathop{{\rm mod}}q)         𝐚  =     c  𝐠   +   c  𝐟    -   q  K        a        c  g     c  f      q  K      \textbf{a}=c\textbf{g}+c\textbf{f}-qK     In which     K   =   ∑    k  i    x  i         K       subscript  k  i    superscript  x  i       \ K=\sum k_{i}x^{i}   such that       k  i   =   {      1    if the     i   t  h      coefficient of    𝐟    and    𝐠   is  1           -  1      if the     i   t  h      coefficient of    𝐟    and    𝐠    is    -  1          0  Otherwise             subscript  k  i    cases   1    if the   superscript  i    t  h    coefficient of  f  and  g  is  1    otherwise     1       if the   superscript  i    t  h    coefficient of  f  and  g  is   1    otherwise   0  Otherwise   otherwise     k_{i}=\begin{cases}1\ \ \qquad\text{if the}\ i^{th}\ \text{coefficient of}\ %
 \textbf{f}\ \text{and}\ \textbf{g}\ \text{is}\ 1\\
 -1\qquad\text{if the}\ i^{th}\ \text{coefficient of}\ \textbf{f}\ \text{and}\ %
 \textbf{g}\ \text{is}\ -1\\
 0\ \ \qquad\text{Otherwise}\end{cases}     Example :      𝐟  =       -  1   +  X  +   X  2    -   X  4    +   X  6   +   X  9    -   X  10        f            1   X   superscript  X  2     superscript  X  4     superscript  X  6    superscript  X  9     superscript  X  10      \textbf{f}=-1+X+X^{2}-X^{4}+X^{6}+X^{9}-X^{10}         𝐠  =     -  1   +   X  2   +   X  3   +   X  5    -   X  8   -   X  10        g        1    superscript  X  2    superscript  X  3    superscript  X  5     superscript  X  8    superscript  X  10      \textbf{g}=-1+X^{2}+X^{3}+X^{5}-X^{8}-X^{10}     Then K becomes     K   =     -  1   +   X  2    -   X  10        K        1    superscript  X  2     superscript  X  10      \ K=-1+X^{2}-X^{10}   .  Reducing the coefficients of polynomials a mod p really reduces the coefficients of        c   𝐠   +   c  𝐟    -   q  K       (   mod  p   )      annotated        c  g     c  f      q  K     pmod  p     \ c\textbf{g}+c\textbf{f}-qK\;\;(\mathop{{\rm mod}}p)   . After multiplication with     𝐟   p     subscript  f  p    \ \textbf{f}_{p}   , Eve finds:      𝐦  =       c   𝐟  p    ⋅  𝐠   +    c   𝐟  p    ⋅  𝐟    -    q   𝐟  p    ⋅  K       (   mod  p   )        m   annotated       normal-⋅    c   subscript  f  p    g    normal-⋅    c   subscript  f  p    f     normal-⋅    q   subscript  f  p    K     pmod  p      \textbf{m}=c\textbf{f}_{p}\cdot\textbf{g}+c\textbf{f}_{p}\cdot\textbf{f}-q%
 \textbf{f}_{p}\cdot K\;\;(\mathop{{\rm mod}}p)         𝐦  =      c  𝐡   +  c   -    q   𝐟  p    ⋅  K       (   mod  p   )        m   annotated        c  h   c    normal-⋅    q   subscript  f  p    K     pmod  p      \textbf{m}=c\textbf{h}+c-q\textbf{f}_{p}\cdot K\;\;(\mathop{{\rm mod}}p)     Because c was chosen to be a multiple of p , m can be written as      𝐦  =    -    q   𝐟  p    ⋅  K       (   mod  p   )        m   annotated     normal-⋅    q   subscript  f  p    K     pmod  p      \textbf{m}=-q\textbf{f}_{p}\cdot K\;\;(\mathop{{\rm mod}}p)     Which means that     𝐟   =    -    q  K   ⋅   𝐦   -  1         (   mod  p   )        f   annotated     normal-⋅    q  K    superscript  m    1       pmod  p      \ \textbf{f}=-qK\cdot\textbf{m}^{-1}\;\;(\mathop{{\rm mod}}p)   .  Now if f and g have few coefficients which are the same at the same factors, K has few non zero coefficients and is thereby small. By trying different values of K the attacker can recover f .  By encrypting and decrypting a message according to the NTRUEncrypt the attacker can check whether the function f is the correct secret key or not.  Security and performance improvements  Using the latest suggested parameters (see below ) the NTRUEncrypt public key cryptosystem is secure to most attacks. There continues however to be a struggle between performance and security. It is hard to improve the security without slowing down the speed, and vice versa.  One way to speed up the process without damaging the effectiveness of the algorithm, is to make some changes in the secret key f . First, construct f such that     𝐟   =   1  +   p  𝐅        f    1    p  F      \ \textbf{f}=1+p\textbf{F}   , in which F is a small polynomial (i.e. coefficients {-1,0, 1}). By constructing f this way, f is invertible mod p . In fact      𝐟    -  1    =   1     (   mod  p   )         superscript  f    1     annotated  1   pmod  p      \ \textbf{f}^{-1}=1\;\;(\mathop{{\rm mod}}p)   , which means that Bob does not have to actually calculate the inverse and that Bob does not have to conduct the second step of decryption. Therefore constructing f this way saves a lot of time but it does not affect the security of the NTRUEncrypt because it is only easier to find     𝐟   p     subscript  f  p    \ \textbf{f}_{p}   but f is still hard to recover. In this case f has coefficients different from -1, 0 or 1, because of the multiplication by p . But because Bob multiplies by p to generate the public key h , and later on reduces the ciphertext modulo p , this will not have an effect on the encryption method.  Second, f can be written as the product of multiple polynomials, such that the polynomials have many zero coefficients. This way fewer calculations have to be conducted.  In most commercial applications of the NTRUEncrypt, the parameter N =251 is used. To avoid lattice attacks, brute force attacks and meet-in-the-middle attacks, f and g should have about 72 non-zero coefficients.  According to the latest research 2 the following parameters are considered secure:  Table 1: Parameters       N   q   p       Moderate Security   167   128   3     Standard Security   251   128   3     High Security   347   128   3     Highest Security   503   256   3     References   Jaulmes, E. and Joux, A. A Chosen-Ciphertext Attack against NTRU. Lecture notes in computer science; Vol 1880. Proceedings of the 20th Annual International Cryptology Conference on Advances in Cryptography. pp. 20–35, 2000.  Jeffrey Hoffstein, Jill Pipher, Joseph H. Silverman. NTRU: A Ring Based Public Key Cryptosystem . In Algorithmic Number Theory (ANTS III), Portland, OR, June 1998, J.P. Buhler (ed.), Lecture Notes in Computer Science 1423, Springer-Verlag, Berlin, 1998, 267-288.  Howgrave-Graham, N., Silverman, J.H. & Whyte, W., Meet-In-The-Middle Attack on a NTRU Private Key .  J. Hoffstein, J. Silverman. Optimizations for NTRU . Public-Key Cryptography and Computational Number Theory (Warsaw, September 11–15, 2000), DeGruyter, to appear.  A. C. Atici, L. Batina, J. Fan & I. Verbauwhede. Low-cost implementations of NTRU for pervasive security .   External links   NTRU technical website  The IEEE P1363 Home Page  Security Innovation (acquired NTRU Cryptosystems, Inc.)  Open Source BSD license implementation of NTRUEncrypt  Open Source GPL v2 license of NTRUEncrypt  strongSwan Open Source IPsec solution using NTRUEncrypt-based key exchange  - Embedded SSL Library offering cipher suites utilizing NTRU   "  Category:Public-key encryption schemes  Category:Lattice-based cryptography     http://www.businesswire.com/news/home/20110411005309/en/Security-Innovation%E2%80%99s-NTRUEncrypt-Adopted-X9-Standard-Data ↩  NTRU PKCS Parameters ↩     