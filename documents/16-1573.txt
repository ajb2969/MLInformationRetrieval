   Image derivatives      Image derivatives  Image derivatives can be computed by using small convolution filters of size 2 x 2 or 3 x 3, such as the  [[Discrete Laplace operator|Laplacian]], [[Sobel operator|Sobel]], [[Roberts cross|Roberts]] and [[Prewitt operator|Prewitt]]  operators. Pratt, W.K., 2007. Digital image processing (4th ed.). John Wiley & Sons, Inc. pp. 465–522 However, a larger mask will generally give a better approximation of the derivative and examples of such filters are Gaussian derivatives H. Bouma, A. Vilanova, J.O. Bescós, B.M.T.H. Romeny, F.A. Gerritsen, Fast and accurate gaussian derivatives based on b-splines, in: Proceedings of the 1st Internati table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */    onal Conference on Scale Space and Variational Methods in Computer Vision, Springer-Verlag, Berlin, Heidelberg, 2007, pp. 406–417. and Gabor filters. 1 Sometimes high frequency noise needs to be removed and this can be incorporated in the filter so that the Gaussian kernel will act as a band pass filter. 2 The use of Gabor filters 3 in image processing has been motivated by some of its similarities to the perception in the human visual system. 4  The pixel value is computed as a convolution       p  u  ′   =   𝐝  ∗  G        subscript   superscript  p  normal-′   u    normal-∗  𝐝  G     p^{\prime}_{u}=\mathbf{d}\ast G   where   𝐝   𝐝   \mathbf{d}   is the derivative kernel and   G   G   G   is the pixel values in a region of the image and   ∗   normal-∗   \ast   is the operator that performs the convolution .  Sobel Derivatives  The derivative kernels, known as the Sobel operator are defined as follows, for the   u   u   u   and   v   v   v   directions respectively:        p  u  ′   =     [      -  1      -  2      -  1       0    0    0       +  1      +  2      +  1      ]   *  𝐆   and      p  v  ′   =    [      -  1     0     +  1        -  2     0     +  2        -  1     0     +  1      ]   *  𝐆       formulae-sequence     subscript   superscript  p  normal-′   u          1     2     1     0  0  0      1     2     1     𝐆   and       subscript   superscript  p  normal-′   v         1   0    1       2   0    2       1   0    1     𝐆      p^{\prime}_{u}=\begin{bmatrix}-1&-2&-1\\
 0&0&0\\
 +1&+2&+1\end{bmatrix}*\mathbf{G}\quad\mbox{and}\quad p^{\prime}_{v}=\begin{%
 bmatrix}-1&0&+1\\
 \ \ -2&\ \ 0&\ \ +2\\
 -1&0&+1\end{bmatrix}*\mathbf{G}     where   *     *   here denotes the 2-dimensional convolution operation.  This operator is separable and can be decomposed as the products of an interpolation and a differentiation kernel, so that,    p  v  ′     subscript   superscript  p  normal-′   v    p^{\prime}_{v}   , for an example can be written as       [      -  1     0     +  1        -  2     0     +  2        -  1     0     +  1      ]   =    [     1      2      1     ]    [      -  1     0     +  1      ]            1   0    1       2   0    2       1   0    1         1    2    1        1   0    1        \begin{bmatrix}-1&0&+1\\
 -2&0&+2\\
 -1&0&+1\end{bmatrix}=\begin{bmatrix}1\\
 2\\
 1\end{bmatrix}\begin{bmatrix}-1&0&+1\end{bmatrix}     Farid and Simoncelli Derivatives  Farid and Simoncelli. 5 6 propose to use a pair of kernels, one for interpolation and another for differentiation (compare to Sobel above). These kernels, of fixed sizes 5 x 5 and 7 x 7, are optimized so that the Fourier transform approximates their correct derivative relationship.  In Matlab code the so called 5-tap filter is  k  = [ 0.030320  0.249724  0.439911  0.249724  0.030320 ];
   d  = [ 0.104550  0.292315  0.000000 - 0.292315 - 0.104550 ];
   d2 = [ 0.232905  0.002668 - 0.471147  0.002668  0.232905 ];  And the 7-tap filter is  k  = [ 0.004711  0.069321  0.245410  0.361117  0.245410  0.069321  0.004711 ];
   d  = [ 0.018708  0.125376  0.193091  0.000000 - 0.193091 - 0.125376 - 0.018708 ];
   d2 = [ 0.055336  0.137778 - 0.056554 - 0.273118 - 0.056554  0.137778  0.055336 ];  As an example the first order derivatives can be computed in the following using Matlab in order to perform the convolution  Iu=-conv2(conv(d,k),conv(k,k),im, 'same' );
 Iv=-conv2(conv(k,k),conv(d,k),im, 'same' );  Hast Derivatives  Derivative filters based on arbitrary cubic splines was presented by Hast. 7 He showed how both first and second order derivatives can be computed more correctly using cubic or trigonometric splines. Efficient derivative filters need to be of odd length so that the derivative is computed for the central pixel. However, any cubic filter is fitted over 4 sample points, giving a centre that falls between pixels. This is solved by a double filtering approach giving filters of size 7 x 7. The idea is to first filter by interpolation so that the interpolated value between pixels are obtained, whereafter the procedure is repeated using a derivative filters, where the centre value now falls on pixel centres. This can easily be proved by the associative law for convolution       p  u  ′   =   𝐝  ∗   (   𝐤  ∗  G   )    =    (   𝐝  ∗  𝐤   )   ∗  G          subscript   superscript  p  normal-′   u    normal-∗  𝐝   normal-∗  𝐤  G          normal-∗   normal-∗  𝐝  𝐤   G      p^{\prime}_{u}=\mathbf{d}\ast(\mathbf{k}\ast G)=(\mathbf{d}\ast\mathbf{k})\ast
 G   Therefore the convolution kernel for computing the derivative    𝐤  𝐝     subscript  𝐤  𝐝    \mathbf{k_{d}}   using an interpolating kernel   𝐤   𝐤   \mathbf{k}   and a derivative kernel   𝐝   𝐝   \mathbf{d}   becomes       𝐤  𝐝   =   𝐝  ∗  𝐤        subscript  𝐤  𝐝    normal-∗  𝐝  𝐤     \mathbf{k_{d}}=\mathbf{d}\ast\mathbf{k}     Also keep in mind that convolution is commutative, so that the order of the two kernels does not matter and it is also possible to insert a second order derivative as well as a first order derivative kernel. These kernels are derived from the fact that any spline surface can be fitted over a square pixel region, compare to Bezier surfaces . Hast proves that such a surface can be performed as a separable convolution       p   (  u  ,  v  )    =    𝐮  T   M  G   M  T   𝐯   =       M  T   𝐮   ⊗   𝐯  T    M   ∗  G           p   u  v       superscript  𝐮  T   M  G   superscript  M  T   𝐯         normal-∗     tensor-product     superscript  M  T   𝐮    superscript  𝐯  T    M   G      p(u,v)=\mathbf{u}^{T}MGM^{T}\mathbf{v}=M^{T}\mathbf{u}\otimes\mathbf{v}^{T}M\ast
 G     where   M   M   M   is the spline basis matrix,   𝐮   𝐮   \mathbf{u}   and   𝐯   𝐯   \mathbf{v}   are vectors containing the variables   u   u   u   and   v   v   v   , such as      𝐮  =    [   u  3   ,   u  2   ,  u  ,  1  ]   T       𝐮   superscript    superscript  u  3    superscript  u  2   u  1   T     \mathbf{u}=[u^{3},u^{2},u,1]^{T}         𝐯  =    [   v  3   ,   v  2   ,  v  ,  1  ]   T       𝐯   superscript    superscript  v  3    superscript  v  2   v  1   T     \mathbf{v}=[v^{3},v^{2},v,1]^{T}   The convolution kernels can now be set to      𝐤  =    𝐮  T   M   =    (    M  T   𝐯   )   T         𝐤     superscript  𝐮  T   M         superscript     superscript  M  T   𝐯   T      \mathbf{k}=\mathbf{u}^{T}M=(M^{T}\mathbf{v})^{T}         𝐝  =     ∂   𝐮  T     ∂  u    M   =    (    M  T     ∂  𝐯    ∂  v     )   T         𝐝         superscript  𝐮  T      u    M         superscript     superscript  M  T       𝐯     v     T      \mathbf{d}=\frac{\partial\mathbf{u}^{T}}{\partial u}M=\left(M^{T}\frac{%
 \partial\mathbf{v}}{\partial v}\right)^{T}          𝐝  𝟐   =      ∂  2    𝐮  T     ∂   u  2     M   =    (    M  T      ∂  2   𝐯    ∂   v  2      )   T          superscript  𝐝  2         superscript   2    superscript  𝐮  T       superscript  u  2     M         superscript     superscript  M  T       superscript   2   𝐯      superscript  v  2      T      \mathbf{d^{2}}=\frac{\partial^{2}\mathbf{u}^{T}}{\partial u^{2}}M=\left(M^{T}%
 \frac{\partial^{2}\mathbf{v}}{\partial v^{2}}\right)^{T}     The first order derivatives at the central pixel are hence computed as       D  u   =         ∂   𝐮  T     ∂  u    M   ∗   𝐮  T    M  G   M  T   𝐯   ∗   M  T    𝐯   =     𝐝  ∗  𝐤   ⊗    (   𝐤  ∗  𝐤   )   T    ∗  G          subscript  D  u      normal-∗     normal-∗         superscript  𝐮  T      u    M    superscript  𝐮  T    M  G   superscript  M  T   𝐯    superscript  M  T    𝐯         normal-∗   tensor-product   normal-∗  𝐝  𝐤    superscript   normal-∗  𝐤  𝐤   T    G      D_{u}=\frac{\partial\mathbf{u}^{T}}{\partial u}M\ast\mathbf{u}^{T}MGM^{T}%
 \mathbf{v}\ast M^{T}\mathbf{v}=\mathbf{d}\ast\mathbf{k}\otimes(\mathbf{k}\ast%
 \mathbf{k})^{T}\ast G   and       D  v   =        𝐮  T   M   ∗   𝐮  T    M  G   M  T   𝐯   ∗   M  T      ∂  𝐯    ∂  v     =     𝐤  ∗  𝐤   ⊗    (   𝐝  ∗  𝐤   )   T    ∗  G          subscript  D  v      normal-∗     normal-∗     superscript  𝐮  T   M    superscript  𝐮  T    M  G   superscript  M  T   𝐯    superscript  M  T        𝐯     v           normal-∗   tensor-product   normal-∗  𝐤  𝐤    superscript   normal-∗  𝐝  𝐤   T    G      D_{v}=\mathbf{u}^{T}M\ast\mathbf{u}^{T}MGM^{T}\mathbf{v}\ast M^{T}\frac{%
 \partial\mathbf{v}}{\partial v}=\mathbf{k}\ast\mathbf{k}\otimes(\mathbf{d}\ast%
 \mathbf{k})^{T}\ast G     Likewise, with the second order derivative kernels are       D  u  2   =          ∂  2    𝐮  T     ∂   u  2     M   ∗   𝐮  T    M  G   M  T   𝐯   ∗   M  T    𝐯   =      𝐝  𝟐   ∗  𝐤   ⊗    (   𝐤  ∗  𝐤   )   T    ∗  G          subscript   superscript  D  2   u      normal-∗     normal-∗        superscript   2    superscript  𝐮  T       superscript  u  2     M    superscript  𝐮  T    M  G   superscript  M  T   𝐯    superscript  M  T    𝐯         normal-∗   tensor-product   normal-∗   superscript  𝐝  2   𝐤    superscript   normal-∗  𝐤  𝐤   T    G      D^{2}_{u}=\frac{\partial^{2}\mathbf{u}^{T}}{\partial u^{2}}M\ast\mathbf{u}^{T}%
 MGM^{T}\mathbf{v}\ast M^{T}\mathbf{v}=\mathbf{d^{2}}\ast\mathbf{k}\otimes(%
 \mathbf{k}\ast\mathbf{k})^{T}\ast G   and       D  v  2   =        𝐮  T   M   ∗   𝐮  T    M  G   M  T   𝐯   ∗   M  T       ∂  2   𝐯    ∂   v  2      =     𝐤  ∗  𝐤   ⊗    (    𝐝  𝟐   ∗  𝐤   )   T    ∗  G          subscript   superscript  D  2   v      normal-∗     normal-∗     superscript  𝐮  T   M    superscript  𝐮  T    M  G   superscript  M  T   𝐯    superscript  M  T        superscript   2   𝐯      superscript  v  2            normal-∗   tensor-product   normal-∗  𝐤  𝐤    superscript   normal-∗   superscript  𝐝  2   𝐤   T    G      D^{2}_{v}=\mathbf{u}^{T}M\ast\mathbf{u}^{T}MGM^{T}\mathbf{v}\ast M^{T}\frac{%
 \partial^{2}\mathbf{v}}{\partial v^{2}}=\mathbf{k}\ast\mathbf{k}\otimes(%
 \mathbf{d^{2}}\ast\mathbf{k})^{T}\ast G     The cubic spline filter is evaluated in its centre    u  =  v  =  0.5        u  v       0.5     u=v=0.5   and therefore      𝐮  =  𝐯  =    [    (  0.5  )   3   ,    (  0.5  )   2   ,  0.5  ,  1  ]   T   =    [  0.125  ,  0.25  ,  0.5  ,  1  ]   T         𝐮  𝐯        superscript    superscript  0.5  3    superscript  0.5  2   0.5  1   T         superscript   0.125  0.25  0.5  1   T      \mathbf{u}=\mathbf{v}=[(0.5)^{3},(0.5)^{2},0.5,1]^{T}=[0.125,0.25,0.5,1]^{T}   Likewise the first order derivatives becomes         ∂  𝐮    (  0.5  )     ∂  u    =     ∂  𝐯    (  0.5  )     ∂  v    =    [   3  ⋅    (  0.5  )   2    ,   2  ⋅   (  0.5  )    ,  1  ,  0  ]   T   =    [  0.75  ,  1  ,  1  ,  0  ]   T               𝐮   0.5     u          𝐯   0.5     v          superscript    normal-⋅  3   superscript  0.5  2     normal-⋅  2  0.5   1  0   T         superscript   0.75  1  1  0   T      \frac{\partial\mathbf{u}(0.5)}{\partial u}=\frac{\partial\mathbf{v}(0.5)}{%
 \partial v}=[3\cdot(0.5)^{2},2\cdot(0.5),1,0]^{T}=[0.75,1,1,0]^{T}   And in a similar manner the second order derivatives are         d  2   𝐮   (  0.5  )     u  2    =     d  2   𝐯   (  0.5  )     d   v  2     =    [   6  ⋅   (  0.5  )    ,  2  ,  0  ,  0  ]   T   =    [  3  ,  2  ,  0  ,  0  ]   T              superscript  d  2   𝐮  0.5    superscript  u  2         superscript  d  2   𝐯  0.5     d   superscript  v  2           superscript    normal-⋅  6  0.5   2  0  0   T         superscript   3  2  0  0   T      \frac{d^{2}\mathbf{u}(0.5)}{u^{2}}=\frac{d^{2}\mathbf{v}(0.5)}{dv^{2}}=[6\cdot%
 (0.5),2,0,0]^{T}=[3,2,0,0]^{T}     It should be noted that any cubic filter can be applied and used for computing the image derivates using the above equations, such as Bézier , Hermite or B-splines .  The example in below in Matlab use the Catmull-Rom spline to compute the derivatives  M=[- 1 , 3 ,- 3 , 1 ; 2 ,- 5 , 4 ,- 1 ;- 1 , 0 , 1 , 0 ; 0 , 2 , 0 , 0 ]* 0.5 ;
 u = [ 0.125 ; 0.25 ; 0.5 ; 1 ];
 up = [ 0.75 ; 1 ; 1 ; 0 ];
 d=up'*M;
 k=u'*M;
 Iu=-conv2(conv(d,k),conv(k,k),im, 'same' );
 Iv=-conv2(conv(k,k),conv(d,k),im, 'same' );  Other Approaches  Steerable filters can be used for computing derivatives 8 Moreover, Savitzky and Golay 9 propose a least-squares polynomial smoothing approach, which could be used for computing derivatives and Luo et al 10 discuss this approach in further detail. Scharr 11 12 13 shows how to create derivative filters by minimizing the error in the Fourier domain and Jähne et al 14 discuss in more detail the principles of filter design, including derivative filters.  References  External links   derivative5.m Farid and Simoncelli: 5-Tap 1st and 2nd discrete derivatives.  derivative7.m Farid and Simoncelli: 7-Tap 1st and 2nd discrete derivatives  kernel.m Hast: 1st and 2nd discrete derivatives for Cubic splines, Catmull-Rom splines, Bezier splines, B-Splines and Trigonometric splines.   "  Category:Image processing     P. Moreno, A. Bernardino, J. Santos-Victor, Improving the sift descriptor with smooth derivative filters, Pattern Recognition Letters 30 (2009) 18–26. ↩  J.J. Koenderink, A.J. van Doorn, Generic neighborhood operators, IEEE Trans. Pattern Anal. Mach. Intell. 14 (1992) 597–605. ↩  D. Gabor, Theory of communication, J. Inst. Electr. Eng. 93 (1946) 429–457. ↩  J.G. Daugman, Complete discrete 2-D Gabor transforms by neural networks for image analysis and compression, IEEE Trans. Acoust. Speech Signal Process. 36 (1988) 1169–1179. ↩  H. Farid and E. P. Simoncelli, Differentiation of discrete multi-dimensional signals , IEEE Trans Image Processing, vol.13(4), pp. 496--508, Apr 2004. ↩  H. Farid and E. P. Simoncelli, Optimally Rotation-Equivariant Directional Derivative Kernels , Int'l Conf Computer Analysis of Images and Patterns, pp. 207--214, Sep 1997. ↩  A. Hast., "Simple filter design for first and second order derivatives by a double filtering approach" , Pattern Recognition Letters, Vol. 42, no.1 June, pp. 65--71. 2014. ↩  W.T. Freeman, E.H. Adelson, The design and use of steerable filters, IEEE Trans. Pattern Anal. Mach. Intell. 13 (1991) 891–906. ↩  A. Savitzky, M.J.E. Golay, Smoothing and differentiation of data by simplified least squares procedures, Anal. Chem. 36 (1964) 1627–1639. ↩  J. Luo, K. Ying, P. He, J. Bai, Properties of savitzky–golay digital differentiators, Digit. Signal Process. 15 (2005) 122–136. ↩  H. Scharr, Optimal second order derivative filter families for transparent motion estimation, in: M. Domanski, R. Stasinski, M. Bartkowiak (Eds.), EUSIPCO 2007. ↩  Scharr, Hanno, 2000, Dissertation (in German), Optimal Operators in Digital Image Processing . ↩  B. Jähne, H. Scharr, and S. Körkel. Principles of filter design. In Handbook of Computer Vision and Applications. Academic Press, 1999. ↩  B. Jähne, P. Geissler, H. Haussecker (Eds.), Handbook of Computer Vision and Applications with Cdrom, 1st ed., Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 1999, pp. 125–151 (Chapter 6). ↩    