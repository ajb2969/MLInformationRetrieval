<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1155">Canny edge detector</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Canny edge detector</h1>
<hr/>

<p>The <strong>Canny edge detector</strong> is an <a href="edge_detection" title="wikilink">edge detection</a> operator that uses a multi-stage <a class="uri" href="algorithm" title="wikilink">algorithm</a> to detect a wide range of edges in images. It was developed by <a href="John_F._Canny" title="wikilink">John F. Canny</a> in 1986. Canny also produced a <em>computational theory of edge detection</em> explaining why the technique works.</p>
<h2 id="development-of-the-canny-algorithm">Development of the Canny algorithm</h2>

<p>Edge detection, especially step edge detection has been widely applied in various different computer vision systems, which is an important technique to extract useful structural information from different vision objects and dramatically reduce the amount of data to be processed. Canny has found that, the requirements for the application of edge detection on diverse vision systems are relatively the same. Thus, a development of an edge detection solution to address these requirements can be implemented in a wide range of situations. The general criteria for edge detection includes</p>
<ol>
<li>Detection of edge with low error rate, which means that the detection should accurately catch as many edges shown in the image as possible</li>
<li>The edge point detected from the operator should accurately localize on the center of the edge.</li>
<li>a given edge in the image should only be marked once, and where possible, image noise should not create false edges.</li>
</ol>

<p>To satisfy these requirements Canny used the <a href="calculus_of_variations" title="wikilink">calculus of variations</a> ‚Äì a technique which finds the <a href="function_(mathematics)" title="wikilink">function</a> which optimizes a given <a href="functional_(mathematics)" title="wikilink">functional</a>. The optimal function in Canny's detector is described by the sum of four <a href="Exponential_function" title="wikilink">exponential</a> terms, but it can be approximated by the first <a class="uri" href="derivative" title="wikilink">derivative</a> of a <a href="Gaussian_function" title="wikilink">Gaussian</a>.</p>

<p>Among the edge detection methods developed so far, canny edge detection algorithm is one of the most strictly defined methods that provides good and reliable detection. Owing to its optimality to meet with the three criteria for edge detection and the simplicity of process for implementation, it becomes one of the most popular algorithms for edge detection.</p>
<h2 id="process-of-canny-edge-detection-algorithm">Process of Canny edge detection algorithm</h2>

<p>The Process of Canny edge detection algorithm can be broken down to 5 different steps:</p>
<ol>
<li>Apply Gaussian filter to smooth the image in order to remove the noise</li>
<li>Find the intensity gradients of the image</li>
<li>Apply non-maximum suppression to get rid of spurious response to edge detection</li>
<li>Apply double threshold to determine potential edges</li>
<li>Track edge by hysteresis: Finalize the detection of edges by suppressing all the other edges that are weak and not connected to strong edges.</li>
</ol>

<p>Every step will be described in details as following. The introduction of procedure below is developed based on Prof Thomas Moeslund‚Äôs lecture note for digital image processing in Indian Institute of Technology.[5]</p>
<h3 id="gaussian-filter">Gaussian Filter</h3>
<figure><b>(Figure)</b>
<figcaption>The image after a 5√ó5 Gaussian mask has been passed across each pixel.</figcaption>
</figure>

<p>Since all edge detection results are easily affected by image noise, it is essential to filter out the noise to prevent false detection caused by noise. To smooth the image, a Gaussian filter is applied to convolve with the image. This step will slightly smooth the image to reduce the effects of obvious noise on the edge detector. The equation for a Gaussian filter kernel of size (2<em>k</em>+1)√ó(2<em>k</em>+1) is given by:</p>

<p>

<math display="inline" id="Canny_edge_detector:0">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <mi>œÄ</mi>
      <msup>
       <mi>œÉ</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </mfrac>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mfrac>
        <mrow>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>i</mi>
            <mo>-</mo>
            <mi>k</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mn>2</mn>
         </msup>
         <mo>+</mo>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>j</mi>
            <mo>-</mo>
            <mi>k</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mn>2</mn>
         </msup>
        </mrow>
        <mrow>
         <mn>2</mn>
         <msup>
          <mi>œÉ</mi>
          <mn>2</mn>
         </msup>
        </mrow>
       </mfrac>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>œÄ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>œÉ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <exp></exp>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <minus></minus>
           <ci>i</ci>
           <ci>k</ci>
           <cn type="integer">1</cn>
          </apply>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <minus></minus>
           <ci>j</ci>
           <ci>k</ci>
           <cn type="integer">1</cn>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>œÉ</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{ij}=\frac{1}{2\pi\sigma^{2}}\exp(-\frac{(i-k-1)^{2}+(j-k-1)^{2}}{2\sigma^{2%
}})
  </annotation>
 </semantics>
</math>

</p>

<p>Here is an example of a 5√ó5 Gaussian filter, used to create the image to the right, with 

<math display="inline" id="Canny_edge_detector:1">
 <semantics>
  <mi>œÉ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>œÉ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 = 1.3. (The asterisk denotes a <a class="uri" href="convolution" title="wikilink">convolution</a> operation.)</p>

<p>

<math display="block" id="Canny_edge_detector:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>ùêÅ</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mn>159</mn>
      </mfrac>
      <mrow>
       <mo>[</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mn>2</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>4</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>5</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>4</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>2</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>4</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>9</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>12</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>9</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>4</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>5</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>12</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>15</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>12</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>5</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>4</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>9</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>12</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>9</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>4</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>2</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>4</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>5</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>4</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>2</mn>
         </mtd>
        </mtr>
       </mtable>
       <mo>]</mo>
      </mrow>
     </mrow>
     <mo>*</mo>
     <mi>ùêÄ</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ùêÅ</ci>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">159</cn>
      </apply>
      <matrix>
       <matrixrow>
        <cn type="integer">2</cn>
        <cn type="integer">4</cn>
        <cn type="integer">5</cn>
        <cn type="integer">4</cn>
        <cn type="integer">2</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">4</cn>
        <cn type="integer">9</cn>
        <cn type="integer">12</cn>
        <cn type="integer">9</cn>
        <cn type="integer">4</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">5</cn>
        <cn type="integer">12</cn>
        <cn type="integer">15</cn>
        <cn type="integer">12</cn>
        <cn type="integer">5</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">4</cn>
        <cn type="integer">9</cn>
        <cn type="integer">12</cn>
        <cn type="integer">9</cn>
        <cn type="integer">4</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">2</cn>
        <cn type="integer">4</cn>
        <cn type="integer">5</cn>
        <cn type="integer">4</cn>
        <cn type="integer">2</cn>
       </matrixrow>
      </matrix>
     </apply>
     <ci>ùêÄ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{B}=\frac{1}{159}\begin{bmatrix}2&4&5&4&2\\
4&9&12&9&4\\
5&12&15&12&5\\
4&9&12&9&4\\
2&4&5&4&2\end{bmatrix}*\mathbf{A}.
  </annotation>
 </semantics>
</math>

</p>

<p>It is important to understand that the selection of the size of the Gaussian kernel will affect the performance of the detector. The larger the size is, the lower the detector‚Äôs sensitivity to noise. Additionally, the localization error to detect the edge will slightly increase with the increase of the Gaussian filter kernel size. A 5√ó5 is a good size for most cases, but this will also vary depending on specific situations.</p>
<h3 id="finding-the-intensity-gradient-of-the-image">Finding the Intensity Gradient of the Image</h3>

<p>An edge in an image may point in a variety of directions, so the Canny algorithm uses four filters to detect horizontal, vertical and diagonal edges in the blurred image. The <a href="Edge_detection" title="wikilink">edge detection operator</a> (<a href="Roberts_Cross" title="wikilink">Roberts</a>, <a class="uri" href="Prewitt" title="wikilink">Prewitt</a>, <a href="Sobel_operator" title="wikilink">Sobel</a> for example) returns a value for the first derivative in the horizontal direction (G<sub><em>x</em></sub>) and the vertical direction (G<sub><em>y</em></sub>). From this the edge gradient and direction can be determined:</p>

<p>

<math display="block" id="Canny_edge_detector:3">
 <semantics>
  <mrow>
   <mi>ùêÜ</mi>
   <mo>=</mo>
   <msqrt>
    <mrow>
     <mmultiscripts>
      <mi>ùêÜ</mi>
      <mi>x</mi>
      <none></none>
      <none></none>
      <mn>2</mn>
     </mmultiscripts>
     <mo>+</mo>
     <mmultiscripts>
      <mi>ùêÜ</mi>
      <mi>y</mi>
      <none></none>
      <none></none>
      <mn>2</mn>
     </mmultiscripts>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ùêÜ</ci>
    <apply>
     <root></root>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ùêÜ</ci>
        <ci>x</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ùêÜ</ci>
        <ci>y</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G}=\sqrt{{\mathbf{G}_{x}}^{2}+{\mathbf{G}_{y}}^{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Canny_edge_detector:4">
 <semantics>
  <mrow>
   <mi>ùöØ</mi>
   <mo>=</mo>
   <mrow>
    <mo>atan2</mo>
    <mrow>
     <mo>(</mo>
     <msub>
      <mi>ùêÜ</mi>
      <mi>y</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>ùêÜ</mi>
      <mi>x</mi>
     </msub>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ùöØ</ci>
    <apply>
     <ci>atan2</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùêÜ</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùêÜ</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\Theta}=\operatorname{atan2}\left(\mathbf{G}_{y},\mathbf{G}_{x}\right)
  </annotation>
 </semantics>
</math>

,</p>

<p>where G can be computed using the <a class="uri" href="hypot" title="wikilink">hypot</a> function and <a class="uri" href="atan2" title="wikilink">atan2</a> is the arctangent function with two arguments. The edge direction angle is rounded to one of four angles representing vertical, horizontal and the two diagonals (0¬∞, 45¬∞, 90¬∞ and 135¬∞ for example). An edge direction falling in each color region will be set to a specific angle values, for example alpha lying in yellow region (0¬∞ to 22.5¬∞ and 157.5¬∞ to 180¬∞) will be set to 0¬∞.</p>
<h3 id="non-maximum-suppression">Non-maximum Suppression</h3>

<p>Non-maximum suppression is an <a href="Edge_detection#Edge_thinning" title="wikilink">edge thinning</a> technique.</p>

<p>Non-Maximum suppression is applied to "thin" the edge. After applying gradient calculation, the edge extracted from the gradient value is still quite blurred. With respect to criteria 3, there should only be one accurate response to the edge. Thus non-maximum suppression can help to suppress all the gradient values to 0 except the local maximal, which indicates location with the sharpest change of intensity value. The algorithm for each pixel in the gradient image is:</p>
<ol>
<li>Compare the edge strength of the current pixel with the edge strength of the pixel in the positive and negative gradient directions.</li>
<li>If the edge strength of the current pixel is the largest compared to the other pixels in the mask with the same direction(i.e., the pixel that is pointing in the y direction, it will be compared to the pixel above and below it in the vertical axis), the value will be preserved. Otherwise, the value will be suppressed.</li>
</ol>

<p>In some implementations, the algorithm categorizes the continuous gradient directions into a small set of discrete directions, and then moves a 3x3 filter over the output of the previous step (that is, the edge strength and gradient directions). At every pixel, it suppresses the edge strength of the center pixel (by setting its value to 0) if its magnitude is not greater than the magnitude of the two neighbors in the gradient direction. For example,</p>
<ul>
<li>if the rounded gradient angle is 0¬∞ (i.e. the edge is in the north‚Äìsouth direction) the point will be considered to be on the edge if its gradient magnitude is greater than the magnitudes at pixels in the <strong>east and west</strong> directions,</li>
<li>if the rounded gradient angle is 90¬∞ (i.e. the edge is in the east‚Äìwest direction) the point will be considered to be on the edge if its gradient magnitude is greater than the magnitudes at pixels in the <strong>north and south</strong> directions,</li>
<li>if the rounded gradient angle is 135¬∞ (i.e. the edge is in the northeast‚Äìsouthwest direction) the point will be considered to be on the edge if its gradient magnitude is greater than the magnitudes at pixels in the <strong>north west and south east</strong> directions,</li>
<li>if the rounded gradient angle is 45¬∞ (i.e. the edge is in the north west‚Äìsouth east direction) the point will be considered to be on the edge if its gradient magnitude is greater than the magnitudes at pixels in the <strong>north east and south west</strong> directions.</li>
</ul>

<p>In more accurate implementations, linear interpolation is used between the two neighbouring pixels that straddle the gradient direction. For example, if the gradient angle is between 45¬∞ and 90¬∞, interpolation between gradients at the <strong>north</strong> and <strong>north east</strong> pixels will give one interpolated value, and interpolation between the <strong>south</strong> and <strong>south west</strong> pixels will give the other (using the conventions of last paragraph). The gradient magnitude at the central pixel must be greater than both of these for it to be marked as an edge.</p>

<p>Note that the sign of the direction is irrelevant, i.e. north‚Äìsouth is the same as south‚Äìnorth and so on.</p>
<h3 id="double-threshold">Double Threshold</h3>

<p>After application of non-maximum suppression, the edge pixels are quite accurate to present the real edge. However, there are still some edge pixels at this point caused by noise and color variation. In order to get rid of the spurious responses from these bothering factors, it is essential to filter out the edge pixel with the weak gradient value and preserve the edge with the high gradient value. Thus two threshold values are set to clarify the different types of edge pixels, one is called high threshold value and the other is called the low threshold value. If the edge pixel‚Äôs gradient value is higher than the high threshold value, they are marked as strong edge pixels. If the edge pixel‚Äôs gradient value is smaller than the high threshold value and larger than the low threshold value, they are marked as weak edge pixels. If the pixel value is smaller than the low threshold value, they will be suppressed. The two threshold values are empirically determined values, which will need to be defined when applying to different images.</p>
<h3 id="edge-tracking-by-hysteresis">Edge Tracking by Hysteresis</h3>

<p> So far, the strong edge pixels should certainly be involved in the final edge image, as they are extracted from the true edges in the image. However, there will be some debate on the weak image pixels, as these pixels can either be extracted from the true edge, or the noise/color variations. To achieve an accurate result, the weak edges caused from the latter reasons should be removed. The criteria to determine which case does the weak edge belongs to is that, usually the weak edge pixel caused from true edges will be connected to the strong edge pixel. To track the edge connection, Binary Large Object-analysis is applied by looking at a weak edge pixel and its 8-connected neighborhood pixels. As long as there is one strong edge pixel is involved in the BLOB, that weak edge point can be identified as one that should be preserved.</p>
<h2 id="improvement-on-canny-edge-detection">Improvement on Canny Edge Detection</h2>

<p>While traditional canny edge detection provides relatively simple but precise methodology for edge detection problem, with the more demanding requirements on the accuracy and robustness on the detection, the traditional algorithm can no longer handle the challenging edge detection task. The main defects of the traditional algorithm can be summarized as following:[8]</p>
<ol>
<li>Gaussian filter is applied to smooth out the noise, but it will also smooth the edge, which is considered as the high frequency feature. This will increase the possibility to miss weak edges, and the appearance of isolated edges in the result.</li>
<li>For the gradient amplitude calculation, the old canny edge detection algorithm uses center in a small 2√ó2 neighborhoods window to calculate the finite difference mean value to represent the gradient amplitude. This method is sensitive to noise and can easily detect fake edges and lose real edges.</li>
<li>In traditional canny edge detection algorithm, there will be two fixed global threshold values to filter out the false edges. However, as the image gets complex, different local areas will need very different threshold values to accurately find the real edges. In addition, the global threshold values are determined manually through experiments in the traditional method, which leads to complexity of calculation when large number of different images needs to be dealt with.</li>
<li>The result of the traditional detection cannot reach a satisfactory high accuracy of single response for each edge- multi-point responses will appear.</li>
</ol>

<p>In order to address these defects, improvement for the canny edge algorithm is added in the fields below.</p>
<h3 id="replace-gaussian-filter">Replace Gaussian Filter</h3>

<p>As both edge and noise will be identified as high frequency signal, simple Gaussian filter will add smooth effect on both of them. However, in order to reach high accuracy of detection of the real edge, it is expected that more smooth effect should be added to noise and less smooth effect should be added to the edge. Thus, Bing Wang and Shaosheng Fan from Changsha University of Science and Technology develop an adaptive filter, where the filter will evaluate discontinuity between gray values of each pixel.[8] The higher the discontinuity, the lower the weight value is set for the smooth filter at that point. Contrarily, the lower the discontinuity between the grey values, the higher the weight value is set to the filter. The process to implement this adaptive filter can be summarized in five step:</p>
<ol>
<li>K = 1, set the iteration n and the coefficient of the amplitude of the edge h.</li>
<li>Calculate the gradient valueG_x (x,y) and G_y (x,y)</li>
<li>Calculate the weight according to the formula below:</li>
</ol>

<p>

<math display="inline" id="Canny_edge_detector:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msqrt>
    <mrow>
     <mrow>
      <msub>
       <mi>G</mi>
       <mi>x</mi>
      </msub>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>G</mi>
       <mi>y</mi>
      </msub>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <root></root>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>G</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <interval closure="open">
         <ci>x</ci>
         <ci>y</ci>
        </interval>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>G</ci>
        <ci>y</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <interval closure="open">
         <ci>x</ci>
         <ci>y</ci>
        </interval>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(x,y)=\sqrt{G_{x}(x,y)^{2}+G_{y}(x,y)^{2}}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Canny_edge_detector:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo>-</mo>
      <mfrac>
       <msqrt>
        <mrow>
         <mi>d</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo>,</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </msqrt>
       <mrow>
        <mn>2</mn>
        <msup>
         <mi>h</mi>
         <mn>2</mn>
        </msup>
       </mrow>
      </mfrac>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>w</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <exp></exp>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <root></root>
        <apply>
         <times></times>
         <ci>d</ci>
         <interval closure="open">
          <ci>x</ci>
          <ci>y</ci>
         </interval>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>h</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w(x,y)=\exp\left(-\frac{\sqrt{d(x,y)}}{2h^{2}}\right)
  </annotation>
 </semantics>
</math>

</p>
<ol>
<li>The definition of the adaptive filter is:</li>
</ol>

<p>

<math display="inline" id="Canny_edge_detector:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>N</mi>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mrow>
      <mn>1</mn>
     </munderover>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </mrow>
       <mn>1</mn>
      </munderover>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>x</mi>
         <mo>+</mo>
         <mi>i</mi>
        </mrow>
        <mo>,</mo>
        <mrow>
         <mi>y</mi>
         <mo>+</mo>
         <mi>j</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>w</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>x</mi>
         <mo>+</mo>
         <mi>i</mi>
        </mrow>
        <mo>,</mo>
        <mrow>
         <mi>y</mi>
         <mo>+</mo>
         <mi>j</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>j</ci>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <interval closure="open">
         <apply>
          <plus></plus>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <plus></plus>
          <ci>y</ci>
          <ci>j</ci>
         </apply>
        </interval>
        <ci>w</ci>
        <interval closure="open">
         <apply>
          <plus></plus>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <plus></plus>
          <ci>y</ci>
          <ci>j</ci>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)=\frac{1}{N}\sum\limits_{i=-1}^{1}\sum\limits_{j=-1}^{1}f(x+i,y+j)w(x+i,%
y+j)
  </annotation>
 </semantics>
</math>

</p>

<p>to smooth the image, which</p>

<p>

<math display="inline" id="Canny_edge_detector:8">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </mrow>
     <mn>1</mn>
    </munderover>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mrow>
      <mn>1</mn>
     </munderover>
     <mrow>
      <mi>w</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>+</mo>
        <mi>i</mi>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>y</mi>
        <mo>+</mo>
        <mi>j</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>w</ci>
       <interval closure="open">
        <apply>
         <plus></plus>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <plus></plus>
         <ci>y</ci>
         <ci>j</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=\sum\limits_{i=-1}^{1}\sum\limits_{j=-1}^{1}w(x+i,y+j)
  </annotation>
 </semantics>
</math>

</p>
<ol>
<li>When K = n, stop the iterative, otherwise, k = k+1, keep do the second step</li>
</ol>
<h3 id="improvement-on-gradient-magnitude-and-direction-calculation">Improvement on gradient magnitude and direction calculation</h3>

<p>The study work conducted by Ping Zhou and his colleagues resolve the high sentivity‚Äôs issue brought by the small-scale window to calculate the gradient magnitude values and directions.[10] Instead of using a 2*2 neighborhood window to calculate the gradient magnitude values and directions, Ping developed a 3*3 neighborhood windows to calculate the gradient values, so that a better magnitude and direction value can be calculated. The equations are demonstrated as following:</p>

<p>

<math display="block" id="Canny_edge_detector:9">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>G</mi>
     <mi>x</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <mrow>
        <mrow>
         <mrow>
          <mrow>
           <mi>I</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>i</mi>
            <mo>,</mo>
            <mrow>
             <mi>j</mi>
             <mo>+</mo>
             <mn>1</mn>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>-</mo>
          <mrow>
           <mi>I</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>i</mi>
            <mo>,</mo>
            <mrow>
             <mi>j</mi>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo>+</mo>
         <mrow>
          <mi>I</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>i</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
           <mo>,</mo>
           <mrow>
            <mi>j</mi>
            <mo>+</mo>
            <mn>1</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>I</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>i</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo>,</mo>
          <mrow>
           <mi>j</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>I</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>i</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
         <mo>,</mo>
         <mrow>
          <mi>j</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>I</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>i</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo>,</mo>
        <mrow>
         <mi>j</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <ci>x</ci>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <apply>
         <minus></minus>
         <apply>
          <plus></plus>
          <apply>
           <minus></minus>
           <apply>
            <times></times>
            <ci>I</ci>
            <interval closure="open">
             <ci>i</ci>
             <apply>
              <plus></plus>
              <ci>j</ci>
              <cn type="integer">1</cn>
             </apply>
            </interval>
           </apply>
           <apply>
            <times></times>
            <ci>I</ci>
            <interval closure="open">
             <ci>i</ci>
             <apply>
              <minus></minus>
              <ci>j</ci>
              <cn type="integer">1</cn>
             </apply>
            </interval>
           </apply>
          </apply>
          <apply>
           <times></times>
           <ci>I</ci>
           <interval closure="open">
            <apply>
             <minus></minus>
             <ci>i</ci>
             <cn type="integer">1</cn>
            </apply>
            <apply>
             <plus></plus>
             <ci>j</ci>
             <cn type="integer">1</cn>
            </apply>
           </interval>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>I</ci>
          <interval closure="open">
           <apply>
            <minus></minus>
            <ci>i</ci>
            <cn type="integer">1</cn>
           </apply>
           <apply>
            <minus></minus>
            <ci>j</ci>
            <cn type="integer">1</cn>
           </apply>
          </interval>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>I</ci>
         <interval closure="open">
          <apply>
           <plus></plus>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <plus></plus>
           <ci>j</ci>
           <cn type="integer">1</cn>
          </apply>
         </interval>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>I</ci>
        <interval closure="open">
         <apply>
          <plus></plus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <minus></minus>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{x}(x,y)=[I(i,j+1)-I(i,j-1)+I(i-1,j+1)-I(i-1,j-1)+I(i+1,j+1)-I(i+1,j-1)]/2
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Canny_edge_detector:10">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>G</mi>
     <mi>y</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <mrow>
        <mrow>
         <mrow>
          <mrow>
           <mi>I</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>i</mi>
             <mo>+</mo>
             <mn>1</mn>
            </mrow>
            <mo>,</mo>
            <mi>j</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>-</mo>
          <mrow>
           <mi>I</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>i</mi>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
            <mo>,</mo>
            <mi>j</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo>+</mo>
         <mrow>
          <mi>I</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>i</mi>
            <mo>+</mo>
            <mn>1</mn>
           </mrow>
           <mo>,</mo>
           <mrow>
            <mi>j</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>I</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>i</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo>,</mo>
          <mrow>
           <mi>j</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>I</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>i</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
         <mo>,</mo>
         <mrow>
          <mi>j</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>I</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>i</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo>,</mo>
        <mrow>
         <mi>j</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <ci>y</ci>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <apply>
         <minus></minus>
         <apply>
          <plus></plus>
          <apply>
           <minus></minus>
           <apply>
            <times></times>
            <ci>I</ci>
            <interval closure="open">
             <apply>
              <plus></plus>
              <ci>i</ci>
              <cn type="integer">1</cn>
             </apply>
             <ci>j</ci>
            </interval>
           </apply>
           <apply>
            <times></times>
            <ci>I</ci>
            <interval closure="open">
             <apply>
              <minus></minus>
              <ci>i</ci>
              <cn type="integer">1</cn>
             </apply>
             <ci>j</ci>
            </interval>
           </apply>
          </apply>
          <apply>
           <times></times>
           <ci>I</ci>
           <interval closure="open">
            <apply>
             <plus></plus>
             <ci>i</ci>
             <cn type="integer">1</cn>
            </apply>
            <apply>
             <minus></minus>
             <ci>j</ci>
             <cn type="integer">1</cn>
            </apply>
           </interval>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>I</ci>
          <interval closure="open">
           <apply>
            <minus></minus>
            <ci>i</ci>
            <cn type="integer">1</cn>
           </apply>
           <apply>
            <minus></minus>
            <ci>j</ci>
            <cn type="integer">1</cn>
           </apply>
          </interval>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>I</ci>
         <interval closure="open">
          <apply>
           <plus></plus>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <plus></plus>
           <ci>j</ci>
           <cn type="integer">1</cn>
          </apply>
         </interval>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>I</ci>
        <interval closure="open">
         <apply>
          <minus></minus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <plus></plus>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{y}(x,y)=[I(i+1,j)-I(i-1,j)+I(i+1,j-1)-I(i-1,j-1)+I(i+1,j+1)-I(i-1,j+1)]/2
  </annotation>
 </semantics>
</math>

</p>
<h3 id="robust-method-to-determine-the-dual-threshold-value">Robust method to determine the dual-threshold value</h3>

<p>In order to resolve the challenges where it is hard to determine the dual-threshold value empirically, a Japanese scholar, Otsu [11]has developed an adaptive method to determine the threshold value for different images. What he does is that he has put all the pixel values in the image into two groups c0 and c1, which is separated by an unknown threshold value T. Defining the corresponding pixel number of intensity level i is noted as n_i, thus the probability is defined as:</p>

<p>

<math display="block" id="Canny_edge_detector:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mi>i</mi>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <msub>
     <mi>n</mi>
     <mi>i</mi>
    </msub>
    <mi>n</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>i</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   pi=\frac{n_{i}}{n}
  </annotation>
 </semantics>
</math>

 Where n is the total number of the pixel points in the image The mean value of the gray level distribution probability is defined as :</p>

<p>

<math display="block" id="Canny_edge_detector:12">
 <semantics>
  <mrow>
   <msub>
    <mi>u</mi>
    <mi>T</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>L</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mfrac>
     <mrow>
      <mi>i</mi>
      <msub>
       <mi>p</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <msub>
      <mi>w</mi>
      <mn>0</mn>
     </msub>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>L</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>i</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{T}=\sum\limits_{i=0}^{L-1}\frac{ip_{i}}{w_{0}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Canny_edge_detector:13">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>L</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <msub>
     <mi>p</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>L</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{0}=\sum\limits_{i=0}^{L-1}p_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Canny_edge_detector:14">
 <semantics>
  <mrow>
   <msub>
    <mi>u</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mrow>
       <mi>T</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </mrow>
     <mrow>
      <mi>L</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mfrac>
     <mrow>
      <mi>i</mi>
      <msub>
       <mi>p</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <msub>
      <mi>w</mi>
      <mn>1</mn>
     </msub>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <apply>
         <plus></plus>
         <ci>T</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>L</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>i</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{1}=\sum\limits_{i=T+1}^{L-1}\frac{ip_{i}}{w_{1}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Canny_edge_detector:15">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <msub>
     <mi>w</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{1}=1-w_{0}
  </annotation>
 </semantics>
</math>

 Between-class variance is defined as: The high threshold value T is determined as the one that can maximize the value of 

<math display="inline" id="Canny_edge_detector:16">
 <semantics>
  <msubsup>
   <mi>œÉ</mi>
   <mi>b</mi>
   <mn>2</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>œÉ</ci>
     <ci>b</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{b}^{2}
  </annotation>
 </semantics>
</math>

 and the lower threshold value is determined as Tl = 0.5*Th. In this way, for each image, an adaptive dual threshold value can be best determined to filter out the pixel values that are not considered as edges.</p>
<h3 id="the-thinning-of-the-edge">The thinning of the edge</h3>

<p>While the traditional canny edge detection have implemented a good detection result to meet with the first two criteria, it does not meet with the single response per edge strictly. A mathematical morphology to thin the detected edge is developed by Mallat S and Zhong.[9]</p>
<h2 id="differential-geometric-formulation-of-the-canny-edge-detector">Differential geometric formulation of the Canny edge detector</h2>

<p>A more refined approach to obtain edges with sub-pixel accuracy is by using the approach of <a href="Edge_detection#Differential_edge_detection" title="wikilink">differential edge detection</a>, where the requirement of non-maximum suppression is formulated in terms of second- and third-order derivatives computed from a <a href="scale_space" title="wikilink">scale space</a> representation (Lindeberg 1998) ‚Äì see the article on <a href="Edge_detection#Differential_edge_detection" title="wikilink">edge detection</a> for a detailed description.</p>
<h2 id="variational-formulation-of-the-haralickcanny-edge-detector">Variational formulation of the Haralick‚ÄìCanny edge detector</h2>

<p>A variational explanation for the main ingredient of the Canny edge detector, that is, finding the zero crossings of the 2nd derivative along the gradient direction, was shown to be the result of minimizing a Kronrod‚ÄìMinkowski functional while maximizing the integral over the alignment of the edge with the gradient field (Kimmel and Bruckstein 2003). See article on regularized Laplacian zero crossings and other optimal edge integrators for a detailed description.</p>
<h2 id="parameters">Parameters</h2>

<p>The Canny algorithm contains a number of adjustable parameters, which can affect the computation time and effectiveness of the algorithm.</p>
<ul>
<li>The size of the Gaussian filter: the smoothing filter used in the first stage directly affects the results of the Canny algorithm. Smaller filters cause less blurring, and allow detection of small, sharp lines. A larger filter causes more blurring, smearing out the value of a given pixel over a larger area of the image. Larger blurring radii are more useful for detecting larger, smoother edges ‚Äì for instance, the edge of a rainbow.</li>
<li>Thresholds: the use of two thresholds with hysteresis allows more flexibility than in a single-threshold approach, but general problems of thresholding approaches still apply. A threshold set too high can miss important information. On the other hand, a threshold set too low will falsely identify irrelevant information (such as noise) as important. It is difficult to give a generic threshold that works well on all images. No tried and tested approach to this problem yet exists.</li>
</ul>
<h2 id="conclusion">Conclusion</h2>

<p>The Canny algorithm is adaptable to various environments. Its parameters allow it to be tailored to recognition of edges of differing characteristics depending on the particular requirements of a given implementation. In Canny's original paper, the derivation of the optimal filter led to a <a href="Finite_Impulse_Response" title="wikilink">Finite Impulse Response</a> filter, which can be slow to compute in the spatial domain if the amount of smoothing required is important (the filter will have a large spatial support in that case). For this reason, it is often suggested to use Rachid Deriche's <a href="infinite_impulse_response" title="wikilink">infinite impulse response</a> form of Canny's filter (the <a href="Deriche_edge_detector" title="wikilink">Canny‚ÄìDeriche detector</a>), which is recursive, and which can be computed in a short, fixed amount of time for any desired amount of smoothing. The second form is suitable for real time implementations in <a href="FPGA" title="wikilink">FPGAs</a> or <a href="Digital_signal_processor" title="wikilink">DSPs</a>, or very fast embedded PCs. In this context, however, the regular recursive implementation of the Canny operator does not give a good approximation of rotational symmetry and therefore gives a bias towards horizontal and vertical edges.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Feature_detection_(computer_vision)" title="wikilink">Feature detection (computer vision)</a></li>
<li><a href="Feature_extraction" title="wikilink">Feature extraction</a></li>
<li><a href="Scale_space" title="wikilink">Scale space</a></li>
<li><a href="Ridge_detection" title="wikilink">Ridge detection</a></li>
<li><a href="Computer_vision" title="wikilink">Computer vision</a></li>
<li><a href="Digital_image_processing" title="wikilink">Digital image processing</a></li>
</ul>
<h2 id="references">References</h2>
<ol>
<li>Canny, J., <em>A Computational Approach To Edge Detection</em>, IEEE Trans. Pattern Analysis and Machine Intelligence, 8(6):679‚Äì698, 1986.</li>
<li>R. Deriche, <em>Using Canny's criteria to derive a recursively implemented optimal edge detector</em>, Int. J. Computer Vision, Vol. 1, pp.¬†167‚Äì187, April 1987.</li>
<li><a href="http://www.nada.kth.se/cvap/abstracts/cvap191.html">Lindeberg, Tony "Edge detection and ridge detection with automatic scale selection", International Journal of Computer Vision, 30, 2, pp 117‚Äî154, 1998. (Includes the differential approach to non-maximum suppression.)</a></li>
<li><a href="http://www.cs.technion.ac.il/~ron/PAPERS/laplacian_ijcv2003.pdf">Kimmel, Ron and Bruckstein, Alfred M. "On regularized Laplacian zero crossings and other optimal edge integrators", International Journal of Computer Vision, 53(3):225‚Äì243, 2003. (Includes the geometric variational interpretation for the Haralick‚ÄìCanny edge detector.)</a></li>
<li><a href="http://www.cse.iitd.ernet.in/~pkalra/csl783/canny.pdf">Moeslund, T. (2009, March 23). Canny Edge Detection. Retrieved December 3, 2014</a></li>
<li>Thomas B. Moeslund. Image and Video Processing. August 2008</li>
<li><a href="http://dasl.mem.drexel.edu/alumni/bGreen/www.pages.drexel.edu/_weg22/can_tut.html">Green, B. (2002, January 1). Canny Edge Detection Tutorial. Retrieved December 3, 2014</a></li>
<li>Li, Q., Wang, B., &amp; Fan, S. (2009). Browse Conference Publications Computer Science and Engineer ... Help Working with Abstracts An Improved CANNY Edge Detection Algorithm. In 2009 Second International Workshop on Computer Science and Engineering proceedings : WCSE 2009 : 28‚Äì30 October 2009, Qingdao, China (pp.¬†497‚Äì500). Los Alamitos, CA: IEEE Computer Society</li>
<li>Mallat S, Zhong S. Characterization of Signals from Multi scale Edges [J]. IEEE Trans on PAMI, 1992, 14 (7):710-732.</li>
<li>Zhou, P., Ye, W., &amp; Wang, Q. (2011). An Improved Canny Algorithm for Edge Detection. Journal of Computational Information Systems, 7(5), 1516-1523.</li>
<li>Otsu N. A threshold selection method from gray-level histograms. IEEE Trans Systems, Man and Cybernetics,9(1):62-66,1979.</li>
</ol>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cs.berkeley.edu/~jfc/">John Canny's home page</a></li>
<li><a href="http://www-sop.inria.fr/odyssee/team/Rachid.Deriche/Publications/RD.references.html">Publication List of Rachid Deriche</a></li>
<li><a href="http://www.cs.technion.ac.il/~ron/PAPERS">Journal Publications of Ron Kimmel</a></li>
<li><a href="https://code.google.com/p/fast-edge/">Easy-to-follow MIT licensed c implementation</a></li>
<li><a href="http://docs.opencv.org/doc/tutorials/imgproc/imgtrans/canny_detector/canny_detector.html">Canny edge detection in c++ OpenCV</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.org/en/latest/py_tutorials/py_imgproc/py_canny/py_canny.html">Canny edge detection in Python OpenCV</a></li>
<li><a href="http://www.tomgibara.com/computer-vision/canny-edge-detector">Free Java implementation of Canny edge detector</a></li>
<li><a href="http://reference.wolfram.com/mathematica/ref/EdgeDetect.html">Canny edge detector in Mathematica</a></li>
<li><a href="http://www.mathworks.com/discovery/edge-detection.html">Edge detection in MATLAB</a></li>
<li><a href="http://code.google.com/p/in-spirit/wiki/CannyEdgeDetector">Canny edge detector implementation in ActionScript for the Flash Platform</a></li>
<li><a href="http://matlabserver.cs.rug.nl/">On-line Canny edge detector</a></li>
<li><a href="http://www.tomgibara.com/computer-vision/canny-edge-detector">Matlab Code for Canny Edge Detection from UC Berkeley</a></li>
<li><a href="http://www.tomgibara.com/computer-vision/canny-edge-detector">File Exchange for Canny Edge Detection Code</a></li>
<li><a href="http://www.tomgibara.com/computer-vision/canny-edge-detector">Canny Edge Detection in Java</a></li>
</ul>

<p>"</p>

<p><a href="Category:Feature_detection_(computer_vision)" title="wikilink">Category:Feature detection (computer vision)</a></p>
</body>
</html>
