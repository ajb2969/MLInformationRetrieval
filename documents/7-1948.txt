   Semidefinite programming      Semidefinite programming   Semidefinite programming ( SDP ) is a subfield of convex optimization concerned with the optimization of a linear objective function (that is, a function to be maximized or minimized) over the intersection of the cone of positive semidefinite  matrices with an affine space , i.e., a spectrahedron .  Semidefinite programming is a relatively new field of optimization which is of growing interest for several reasons. Many practical problems in operations research and combinatorial optimization can be modeled or approximated as semidefinite programming problems. In automatic control theory, SDPs are used in the context of linear matrix inequalities . SDPs are in fact a special case of cone programming and can be efficiently solved by interior point methods . All linear programs can be expressed as SDPs, and via hierarchies of SDPs the solutions of polynomial optimization problems can be approximated. Semidefinite programming has been used in the optimization of complex systems . In recent years, some quantum query complexity problems have been formulated in term of semidefinite programs.  Motivation and definition  Initial motivation  A linear programming problem is one in which we wish to maximize or minimize a linear objective function of real variables over a polytope . In semidefinite programming, we instead use real-valued vectors and are allowed to take the dot product of vectors; nonnegativity constraints on real variables in LP are replaced by semidefiniteness constraints on matrix variables in SDP. Specifically, a general semidefinite programming problem can be defined as any mathematical programming problem of the form         min     x  1   ,  …  ,   x  n    ∈   ℝ  n         ∑    i  ,  j   ∈   [  n  ]       c   i  ,  j     (    x  i   ⋅   x  j    )         subject to        ∑    i  ,  j   ∈   [  n  ]       a   i  ,  j  ,  k     (    x  i   ⋅   x  j    )     ≤    b  k    ∀  k     .          subscript       superscript  x  1   normal-…   superscript  x  n     superscript  ℝ  n       subscript      i  j    delimited-[]  n        subscript  c   i  j     normal-⋅   superscript  x  i    superscript  x  j        subject to      subscript      i  j    delimited-[]  n        subscript  a   i  j  k     normal-⋅   superscript  x  i    superscript  x  j        subscript  b  k    for-all  k        \begin{array}[]{rl}{\displaystyle\min_{x^{1},\ldots,x^{n}\in\mathbb{R}^{n}}}&{%
 \displaystyle\sum_{i,j\in[n]}c_{i,j}(x^{i}\cdot x^{j})}\\
 \text{subject to}&{\displaystyle\sum_{i,j\in[n]}a_{i,j,k}(x^{i}\cdot x^{j})%
 \leq b_{k}\qquad\forall k}.\\
 \end{array}     Equivalent formulations  An    n  ×  n      n  n    n\times n   matrix   M   M   M   is said to be positive semidefinite if it is the gramian matrix of some vectors (i.e. if there exist vectors     x  1   ,  …  ,   x  n       superscript  x  1   normal-…   superscript  x  n     x^{1},\ldots,x^{n}   such that     m   i  ,  j    =    x  i   ⋅   x  j         subscript  m   i  j     normal-⋅   superscript  x  i    superscript  x  j      m_{i,j}=x^{i}\cdot x^{j}   for all    i  ,  j     i  j    i,j   ). If this is the case, we denote this as    M  ⪰  0     succeeds-or-equals  M  0    M\succeq 0   . Note that there are several other equivalent definitions of being positive semidefinite, for example, positive semidefinite matrices have only non-negative eigenvalues and have a positive definite square root.  Denote by    𝕊  n     superscript  𝕊  n    \mathbb{S}^{n}   the space of all    n  ×  n      n  n    n\times n   real symmetric matrices. The space is equipped with the inner product (where   tr   tr   {\rm tr}   denotes the trace )       ⟨  A  ,  B  ⟩    𝕊  n    =   tr   (    A  T   B   )    =    ∑    i  =  1   ,   j  =  1    n     A   i  j     B   i  j       .         subscript   A  B    superscript  𝕊  n      tr     superscript  A  T   B           superscript   subscript    formulae-sequence    i  1     j  1     n      subscript  A    i  j     subscript  B    i  j         \langle A,B\rangle_{\mathbb{S}^{n}}={\rm tr}(A^{T}B)=\sum_{i=1,j=1}^{n}A_{ij}B%
 _{ij}.     We can rewrite the mathematical program given in the previous section equivalently as         min   X  ∈   𝕊  n         ⟨  C  ,  X  ⟩    𝕊  n        subject to        ⟨   A  k   ,  X  ⟩    𝕊  n    ≤   b  k    ,   k  =   1  ,  …  ,  m           X  ⪰  0          subscript     X   superscript  𝕊  n      subscript   C  X    superscript  𝕊  n      subject to   formulae-sequence     subscript    subscript  A  k   X    superscript  𝕊  n     subscript  b  k      k   1  normal-…  m        missing-subexpression    succeeds-or-equals  X  0      \begin{array}[]{rl}{\displaystyle\min_{X\in\mathbb{S}^{n}}}&\langle C,X\rangle%
 _{\mathbb{S}^{n}}\\
 \text{subject to}&\langle A_{k},X\rangle_{\mathbb{S}^{n}}\leq b_{k},\quad k=1,%
 \ldots,m\\
 &X\succeq 0\end{array}     where entry    i  ,  j     i  j    i,j   in   C   C   C   is given by    c   i  ,  j      subscript  c   i  j     c_{i,j}   from the previous section and    A  k     subscript  A  k    A_{k}   is an    n  ×  n      n  n    n\times n   matrix having    i  ,  j     i  j    i,j   th entry    a   i  ,  j  ,  k      subscript  a   i  j  k     a_{i,j,k}   from the previous section.  Note that if we add slack variables appropriately, this SDP can be converted to one of the form         min   X  ∈   𝕊  n         ⟨  C  ,  X  ⟩    𝕊  n        subject to        ⟨   A  i   ,  X  ⟩    𝕊  n    =   b  i    ,   i  =   1  ,  …  ,  m           X  ⪰  0.          subscript     X   superscript  𝕊  n      subscript   C  X    superscript  𝕊  n      subject to   formulae-sequence     subscript    subscript  A  i   X    superscript  𝕊  n     subscript  b  i      i   1  normal-…  m        missing-subexpression    succeeds-or-equals  X  0.      \begin{array}[]{rl}{\displaystyle\min_{X\in\mathbb{S}^{n}}}&\langle C,X\rangle%
 _{\mathbb{S}^{n}}\\
 \text{subject to}&\langle A_{i},X\rangle_{\mathbb{S}^{n}}=b_{i},\quad i=1,%
 \ldots,m\\
 &X\succeq 0.\end{array}     For convenience, an SDP may be specified in a slightly different, but equivalent form. For example, linear expressions involving nonnegative scalar variables may be added to the program specification. This remains an SDP because each variable can be incorporated into the matrix   X   X   X   as a diagonal entry (    X   i  i      subscript  X    i  i     X_{ii}   for some   i   i   i   ). To ensure that     X   i  i    ≥  0       subscript  X    i  i    0    X_{ii}\geq 0   , constraints     X   i  j    =  0       subscript  X    i  j    0    X_{ij}=0   can be added for all    j  ≠  i      j  i    j\neq i   . As another example, note that for any positive semidefinite matrix   X   X   X   , there exists a set of vectors    {   v  i   }      subscript  v  i     \{v_{i}\}   such that the   i   i   i   ,   j   j   j   entry of   X   X   X   is     X   i  j    =   (   v  i   ,   v  j   )        subscript  X    i  j      subscript  v  i    subscript  v  j      X_{ij}=(v_{i},v_{j})   the scalar product of    v  i     subscript  v  i    v_{i}   and    v  j     subscript  v  j    v_{j}   . Therefore, SDPs are often formulated in terms of linear expressions on scalar products of vectors. Given the solution to the SDP in the standard form, the vectors    {   v  i   }      subscript  v  i     \{v_{i}\}   can be recovered in    O   (   n  3   )       O   superscript  n  3     O(n^{3})   time (e.g., by using an incomplete Cholesky decomposition of X).  Duality theory  Definitions  Analogously to linear programming, given a general SDP of the form         min   X  ∈   𝕊  n         ⟨  C  ,  X  ⟩    𝕊  n        subject to        ⟨   A  i   ,  X  ⟩    𝕊  n    =   b  i    ,   i  =   1  ,  …  ,  m           X  ⪰  0          subscript     X   superscript  𝕊  n      subscript   C  X    superscript  𝕊  n      subject to   formulae-sequence     subscript    subscript  A  i   X    superscript  𝕊  n     subscript  b  i      i   1  normal-…  m        missing-subexpression    succeeds-or-equals  X  0      \begin{array}[]{rl}{\displaystyle\min_{X\in\mathbb{S}^{n}}}&\langle C,X\rangle%
 _{\mathbb{S}^{n}}\\
 \text{subject to}&\langle A_{i},X\rangle_{\mathbb{S}^{n}}=b_{i},\quad i=1,%
 \ldots,m\\
 &X\succeq 0\end{array}     (the primal problem or P-SDP), we define the dual semidefinite program (D-SDP) as         max   y  ∈   ℝ  m         ⟨  b  ,  y  ⟩    ℝ  m        subject to       ∑   i  =  1   m     y  i    A  i     ⪯  C          subscript     y   superscript  ℝ  m      subscript   b  y    superscript  ℝ  m      subject to   precedes-or-equals    superscript   subscript     i  1    m      subscript  y  i    subscript  A  i     C      \begin{array}[]{rl}{\displaystyle\max_{y\in\mathbb{R}^{m}}}&\langle b,y\rangle%
 _{\mathbb{R}^{m}}\\
 \text{subject to}&{\displaystyle\sum_{i=1}^{m}}y_{i}A_{i}\preceq C\end{array}     where for any two matrices   P   P   P   and   Q   Q   Q   ,    P  ⪰  Q     succeeds-or-equals  P  Q    P\succeq Q   means     P  -  Q   ⪰  0     succeeds-or-equals    P  Q   0    P-Q\succeq 0   .  Weak duality  The weak duality theorem states that the value of the primal SDP is at least the value of the dual SDP. Therefore, any feasible solution to the dual SDP lower-bounds the primal SDP value, and conversely, any feasible solution to the primal SDP upper-bounds the dual SDP value. This is because         ⟨  C  ,  X  ⟩   -   ⟨  b  ,  y  ⟩    =    ⟨  C  ,  X  ⟩   -    ∑   i  =  1   m     y  i    b  i      =    ⟨  C  ,  X  ⟩   -    ∑   i  =  1   m     y  i    ⟨   A  i   ,  X  ⟩      =   ⟨   C  -    ∑   i  =  1   m     y  i    A  i      ,  X  ⟩   ≥  0   ,           C  X    b  y       C  X     superscript   subscript     i  1    m      subscript  y  i    subscript  b  i              C  X     superscript   subscript     i  1    m      subscript  y  i     subscript  A  i   X              C    superscript   subscript     i  1    m      subscript  y  i    subscript  A  i      X        0     \langle C,X\rangle-\langle b,y\rangle=\langle C,X\rangle-\sum_{i=1}^{m}y_{i}b_%
 {i}=\langle C,X\rangle-\sum_{i=1}^{m}y_{i}\langle A_{i},X\rangle=\langle C-%
 \sum_{i=1}^{m}y_{i}A_{i},X\rangle\geq 0,   where the last inequality is because both matrices are positive semidefinite, and the result of this function is sometimes referred to as duality gap.  Strong duality  Under a condition known as Slater's condition, the value of the primal and dual SDPs are equal. This is known as strong duality . Unlike for linear programs , however, not every SDP satisfies strong duality; in general, the value of the dual SDP may lie strictly below the value of the primal.  (i) Suppose the primal problem (P-SDP) is bounded below and strictly feasible (i.e., there exists      X  0   ∈   𝕊  n    ,    X  0   ≻  0      formulae-sequence     subscript  X  0    superscript  𝕊  n     succeeds   subscript  X  0   0     X_{0}\in\mathbb{S}^{n},X_{0}\succ 0   such that      ⟨   A  i   ,   X  0   ⟩    𝕊  n    =   b  i        subscript    subscript  A  i    subscript  X  0     superscript  𝕊  n     subscript  b  i     \langle A_{i},X_{0}\rangle_{\mathbb{S}^{n}}=b_{i}   ,    i  =   1  ,  …  ,  m       i   1  normal-…  m     i=1,\ldots,m   ). Then there is an optimal solution    y  *     superscript  y     y^{*}   to (D-SDP) and         ⟨  C  ,   X  *   ⟩    𝕊  n    =    ⟨  b  ,   y  *   ⟩     \R   m     .       subscript   C   superscript  X      superscript  𝕊  n     subscript   b   superscript  y      superscript  \R  m      \langle C,X^{*}\rangle_{\mathbb{S}^{n}}=\langle b,y^{*}\rangle_{\R^{m}}.     (ii) Suppose the dual problem (D-SDP) is bounded above and strictly feasible (i.e.,      ∑   i  =  1   m      (   y  0   )   i    A  i     ≺  C     precedes    superscript   subscript     i  1    m      subscript   subscript  y  0   i    subscript  A  i     C    \sum_{i=1}^{m}(y_{0})_{i}A_{i}\prec C   for some     y  0   ∈    \R   m        subscript  y  0    superscript  \R  m     y_{0}\in\R^{m}   ). Then there is an optimal solution    X  *     superscript  X     X^{*}   to (P-SDP) and the equality from (i) holds.  Examples  Example 1  Consider three random variables   A   A   A   ,   B   B   B   , and   C   C   C   . By definition, their correlation coefficients      ρ   A  B    ,   ρ   A  C    ,   ρ   B  C        subscript  ρ    A  B     subscript  ρ    A  C     subscript  ρ    B  C      \rho_{AB},\ \rho_{AC},\rho_{BC}   are valid if and only if       (     1     ρ   A  B       ρ   A  C         ρ   A  B      1     ρ   B  C         ρ   A  C       ρ   B  C      1     )   ⪰  0     succeeds-or-equals    1   subscript  ρ    A  B     subscript  ρ    A  C       subscript  ρ    A  B    1   subscript  ρ    B  C       subscript  ρ    A  C     subscript  ρ    B  C    1    0    \begin{pmatrix}1&\rho_{AB}&\rho_{AC}\\
 \rho_{AB}&1&\rho_{BC}\\
 \rho_{AC}&\rho_{BC}&1\end{pmatrix}\succeq 0     Suppose that we know from some prior knowledge (empirical results of an experiment, for example) that     -  0.2   ≤   ρ   A  B    ≤   -  0.1           0.2    subscript  ρ    A  B           0.1      -0.2\leq\rho_{AB}\leq-0.1   and    0.4  ≤   ρ   B  C    ≤  0.5        0.4   subscript  ρ    B  C         0.5     0.4\leq\rho_{BC}\leq 0.5   . The problem of determining the smallest and largest values that    ρ   A  C      subscript  ρ    A  C     \rho_{AC}   can take is given by:   minimize/maximize    x  13     subscript  x  13    x_{13}     subject to       -  0.2   ≤   x  12   ≤   -  0.1           0.2    subscript  x  12          0.1      -0.2\leq x_{12}\leq-0.1         0.4  ≤   x  23   ≤  0.5        0.4   subscript  x  23        0.5     0.4\leq x_{23}\leq 0.5          x  11   =   x  22   =   x  33   =  1         subscript  x  11    subscript  x  22         subscript  x  33        1     x_{11}=x_{22}=x_{33}=1     \begin{pmatrix}   1 & x_{12} & x_{13} \\  x_{12} & 1 & x_{23} \\  x_{13} & x_{23} & 1  \end{pmatrix} \succeq 0  we set      ρ   A  B    =   x  12    ,     ρ   A  C    =   x  13    ,    ρ   B  C    =   x  23        formulae-sequence     subscript  ρ    A  B     subscript  x  12     formulae-sequence     subscript  ρ    A  C     subscript  x  13       subscript  ρ    B  C     subscript  x  23       \rho_{AB}=x_{12},\ \rho_{AC}=x_{13},\ \rho_{BC}=x_{23}   to obtain the answer. This can be formulated by an SDP. We handle the inequality constraints by augmenting the variable matrix and introducing slack variables , for example       tr   (    (     0    1    0    0    0    0      0    0    0    0    0    0      0    0    0    0    0    0      0    0    0    1    0    0      0    0    0    0    0    0      0    0    0    0    0    0     )   ⋅   (     1     x  12      x  13     0    0    0       x  12     1     x  23     0    0    0       x  13      x  23     1    0    0    0      0    0    0     s  1     0    0      0    0    0    0     s  2     0      0    0    0    0    0     s  3      )    )    =    x  12   +   s  1    =   -  0.1           tr   normal-⋅    0  1  0  0  0  0    0  0  0  0  0  0    0  0  0  0  0  0    0  0  0  1  0  0    0  0  0  0  0  0    0  0  0  0  0  0      1   subscript  x  12    subscript  x  13   0  0  0     subscript  x  12   1   subscript  x  23   0  0  0     subscript  x  13    subscript  x  23   1  0  0  0    0  0  0   subscript  s  1   0  0    0  0  0  0   subscript  s  2   0    0  0  0  0  0   subscript  s  3          subscript  x  12    subscript  s  1           0.1      \mathrm{tr}\left(\left(\begin{array}[]{cccccc}0&1&0&0&0&0\\
 0&0&0&0&0&0\\
 0&0&0&0&0&0\\
 0&0&0&1&0&0\\
 0&0&0&0&0&0\\
 0&0&0&0&0&0\end{array}\right)\cdot\left(\begin{array}[]{cccccc}1&x_{12}&x_{13}%
 &0&0&0\\
 x_{12}&1&x_{23}&0&0&0\\
 x_{13}&x_{23}&1&0&0&0\\
 0&0&0&s_{1}&0&0\\
 0&0&0&0&s_{2}&0\\
 0&0&0&0&0&s_{3}\end{array}\right)\right)=x_{12}+s_{1}=-0.1     Solving this SDP gives the minimum and maximum values of     ρ   A  C    =   x  13        subscript  ρ    A  C     subscript  x  13     \rho_{AC}=x_{13}   as    -  0.978      0.978    -0.978   and   0.872   0.872   0.872   respectively.  Example 2  Consider the problem   minimize      (    c  T   x   )   2     d  T   x        superscript     superscript  c  T   x   2      superscript  d  T   x     \frac{(c^{T}x)^{2}}{d^{T}x}     subject to      A  x   +  b   ≥  0          A  x   b   0    Ax+b\geq 0      where we assume that      d  T   x   >  0         superscript  d  T   x   0    d^{T}x>0   whenever      A  x   +  b   ≥  0          A  x   b   0    Ax+b\geq 0   .  Introducing an auxiliary variable   t   t   t   the problem can be reformulated:   minimize   t   t   t     subject to       A  x   +  b   ≥  0   ,      (    c  T   x   )   2     d  T   x    ≤  t      formulae-sequence        A  x   b   0        superscript     superscript  c  T   x   2      superscript  d  T   x    t     Ax+b\geq 0,\,\frac{(c^{T}x)^{2}}{d^{T}x}\leq t      In this formulation, the objective is a linear function of the variables    x  ,  t     x  t    x,t   .  The first restriction can be written as       𝐝𝐢𝐚𝐠   (    A  x   +  b   )    ≥  0        diag      A  x   b    0    \textbf{diag}(Ax+b)\geq 0     where the matrix    𝐝𝐢𝐚𝐠   (    A  x   +  b   )       diag      A  x   b     \textbf{diag}(Ax+b)   is the square matrix with values in the diagonal equal to the elements of the vector     A  x   +  b        A  x   b    Ax+b   .  The second restriction can be written as        t   d  T   x   -    (    c  T   x   )   2    ≥  0          t   superscript  d  T   x    superscript     superscript  c  T   x   2    0    td^{T}x-(c^{T}x)^{2}\geq 0     Defining   D   D   D   as follows      D  =   [     t     c   ;  T   x         c  T   x      d   ;  T   x      ]       D   delimited-[]    t   fragments  c   superscript  normal-;  T   x        superscript  c  T   x    fragments  d   superscript  normal-;  T   x        D=\left[\begin{array}[]{cc}t&c^{T}x\\
 c^{T}x&d^{T}x\end{array}\right]     We can use the theory of Schur Complements to see that      D  ⪰  0     succeeds-or-equals  D  0    D\succeq 0   (Boyd and Vandenberghe, 1996)  The semidefinite program associated with this problem is   minimize   t   t   t     subject to     [      𝐝𝐢𝐚𝐠   (    A  x   +  b   )      0    0      0     t  ;      c   ;  T   x       0     c   ;  T   x      d   ;  T   x      ]   ⪰  0     succeeds-or-equals   delimited-[]      diag      A  x   b    0  0    0  t   fragments  c   superscript  normal-;  T   x     0   fragments  c   superscript  normal-;  T   x    fragments  d   superscript  normal-;  T   x      0    \left[\begin{array}[]{ccc}\textbf{diag}(Ax+b)&0&0\\
 0&t&c^{T}x\\
 0&c^{T}x&d^{T}x\end{array}\right]\succeq 0      Example 3 (Goemans-Williamson MAX CUT approximation algorithm)  Semidefinite programs are important tools for developing approximation algorithms for NP-hard maximization problems. The first approximation algorithm based on an SDP is due to Michel Goemans and David P. Williamson (JACM, 1995). They studied the MAX CUT problem: Given a graph  G = ( V , E ), output a partition of the vertices V so as to maximize the number of edges crossing from one side to the other. This problem can be expressed as an integer quadratic program :   Maximize      ∑    (  i  ,  j  )   ∈  E      1  -    v  i    v  j     2    ,      subscript      i  j   E        1     subscript  v  i    subscript  v  j     2     \sum_{(i,j)\in E}\frac{1-v_{i}v_{j}}{2},   such that each     v  i   ∈   {  1  ,   -  1   }        subscript  v  i    1    1      v_{i}\in\{1,-1\}   .   Unless P = NP , we cannot solve this maximization problem efficiently. However, Goemans and Williamson observed a general three-step procedure for attacking this sort of problem:   Relax the integer quadratic program into an SDP.  Solve the SDP (to within an arbitrarily small additive error   ϵ   ϵ   \epsilon   ).  Round the SDP solution to obtain an approximate solution to the original integer quadratic program.   For MAX CUT, the most natural relaxation is       max    ∑    (  i  ,  j  )   ∈  E      1  -   ⟨   v  i   ,   v  j   ⟩    2     ,         subscript      i  j   E        1    subscript  v  i    subscript  v  j     2      \max\sum_{(i,j)\in E}\frac{1-\langle v_{i},v_{j}\rangle}{2},   such that      ∥   v  i   ∥   2   =  1       superscript   norm   subscript  v  i    2   1    \lVert v_{i}\rVert^{2}=1   , where the maximization is over vectors    {   v  i   }      subscript  v  i     \{v_{i}\}   instead of integer scalars.  This is an SDP because the objective function and constraints are all linear functions of vector inner products. Solving the SDP gives a set of unit vectors in    𝐑  𝐧     superscript  𝐑  𝐧    \mathbf{R^{n}}   ; since the vectors are not required to be collinear, the value of this relaxed program can only be higher than the value of the original quadratic integer program. Finally, a rounding procedure is needed to obtain a partition. Goemans and Williamson simply choose a uniformly random hyperplane through the origin and divide the vertices according to which side of the hyperplane the corresponding vectors lie. Straightforward analysis shows that this procedure achieves an expected approximation ratio (performance guarantee) of 0.87856 - ε. (The expected value of the cut is the sum over edges of the probability that the edge is cut, which is proportional to the angle     cos   -  1     ⟨   v  i   ,   v  j   ⟩       superscript     1     subscript  v  i    subscript  v  j     \cos^{-1}\langle v_{i},v_{j}\rangle   between the vectors at the endpoints of the edge over   π   π   \pi   . Comparing this probability to     (   1  -   ⟨   v  i   ,   v  j   ⟩    )   /  2        1    subscript  v  i    subscript  v  j     2    (1-\langle v_{i},v_{j}\rangle)/{2}   , in expectation the ratio is always at least 0.87856.) Assuming the Unique Games Conjecture , it can be shown that this approximation ratio is essentially optimal.  Since the original paper of Goemans and Williamson, SDPs have been applied to develop numerous approximation algorithms. Recently, Prasad Raghavendra has developed a general framework for constraint satisfaction problems based on the Unique Games Conjecture . 1  Algorithms  There are several types of algorithms for solving SDPs. These algorithms output the value of the SDP up to an additive error   ϵ   ϵ   \epsilon   in time that is polynomial in the program description size and    log   (   1  /  ϵ   )         1  ϵ     \log(1/\epsilon)   .  Interior point methods  Most codes are based on interior point methods (CSDP, SeDuMi, SDPT3, DSDP, SDPA). Robust and efficient for general linear SDP problems. Restricted by the fact that the algorithms are second-order methods and need to store and factorize a large (and often dense) matrix.  Bundle method  The code ConicBundle formulates the SDP problem as a nonsmooth optimization problem and solves it by the Spectral Bundle method of nonsmooth optimization. This approach is very efficient for a special class of linear SDP problems.  Other  Algorithms based on augmented Lagrangian method (PENSDP) are similar in behavior to the interior point methods and can be specialized to some very large scale problems. Other algorithms use low-rank information and reformulation of the SDP as a nonlinear programming problem (SPDLR).  Software  The following codes are available for SDP:   SDPA , C++  CSDP , C  SDPT3 , Matlab. Free.  SeDuMi , Matlab. Free.  DSDP  PENSDP , C, Fortran, Matlab. Commercial.  SDPLR , C, Matlab  ConicBundle , C/C++  CVXOPT , python. Free.   SeDuMi runs on MATLAB and uses the Self-Dual method for solving general convex optimization problems.  Applications  Semidefinite programming has been applied to find approximate solutions to combinatorial optimization problems, such as the solution of the max cut problem with an approximation ratio of 0.87856. SDPs are also used in geometry to determine tensegrity graphs, and arise in control theory as LMIs .  References   Lieven Vandenberghe, Stephen Boyd, "Semidefinite Programming", SIAM Review 38, March 1996, pp. 49–95. pdf    Monique Laurent, Franz Rendl, "Semidefinite Programming and Integer Programming", Report PNA-R0210, CWI, Amsterdam, April 2002. optimization-online    E. de Klerk, "Aspects of Semidefinite Programming: Interior Point Algorithms and Selected Applications", Kluwer Academic Publishers, March 2002, ISBN 1-4020-0547-4.    Robert M. Freund, "Introduction to Semidefinite Programming (SDP), SDP-Introduction   External links   Links to introductions and events in the field  Lecture notes from László Lovász on Semidefinite Programming   "  Category:Mathematical optimization  Category:Operations research  Category:P-complete problems  Category:Real algebraic geometry  Category:Linear programming     Raghavendra, P. 2008. Optimal algorithms and inapproximability results for every CSP? . In Proceedings of the 40th Annual ACM Symposium on theory of Computing (Victoria, British Columbia, Canada, May 17–20, 2008). STOC '08. ACM, New York, NY, 245-254. ↩     