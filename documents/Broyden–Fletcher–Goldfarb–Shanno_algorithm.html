<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1755">Broyden–Fletcher–Goldfarb–Shanno algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Broyden–Fletcher–Goldfarb–Shanno algorithm</h1>
<hr/>

<p>In <a href="numerical_analysis" title="wikilink">numerical</a> <a href="optimization_(mathematics)" title="wikilink">optimization</a>, the <strong>Broyden–Fletcher–Goldfarb–Shanno</strong> (<strong>BFGS</strong>) <strong>algorithm</strong> is an <a href="iterative_method" title="wikilink">iterative method</a> for solving unconstrained <a href="nonlinear_optimization" title="wikilink">nonlinear optimization</a> problems.</p>

<p>The BFGS method <a href="approximation_theory" title="wikilink">approximates</a> <a href="Newton's_method_in_optimization" title="wikilink">Newton's method</a>, a class of <a href="hill_climbing" title="wikilink">hill-climbing optimization</a> techniques that seeks a <a href="stationary_point" title="wikilink">stationary point</a> of a (preferably twice continuously differentiable) function. For such problems, a <a href="Kuhn–Tucker_conditions" title="wikilink">necessary condition for optimality</a> is that the <a class="uri" href="gradient" title="wikilink">gradient</a> be zero. Newton's method and the BFGS methods are not guaranteed to converge unless the function has a quadratic <a href="Taylor_expansion" title="wikilink">Taylor expansion</a> near an <a href="Local_optimum" title="wikilink">optimum</a>. These methods use both the first and second derivatives of the function. However, BFGS has proven to have good performance even for non-smooth optimizations.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>In <a href="quasi-Newton_methods" title="wikilink">quasi-Newton methods</a>, the <a href="Hessian_matrix" title="wikilink">Hessian matrix</a> of second <a href="derivative" title="wikilink">derivatives</a> doesn't need to be evaluated directly. Instead, the Hessian matrix is approximated using rank-one updates specified by gradient evaluations (or approximate gradient evaluations). <a href="Quasi-Newton_methods" title="wikilink">Quasi-Newton methods</a> are generalizations of the <a href="secant_method" title="wikilink">secant method</a> to find the root of the first derivative for multidimensional problems. In multi-dimensional problems, the secant equation does not specify a unique solution, and quasi-Newton methods differ in how they constrain the solution. The BFGS method is one of the most popular members of this class.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Also in common use is <a class="uri" href="L-BFGS" title="wikilink">L-BFGS</a>, which is a limited-memory version of BFGS that is particularly suited to problems with very large numbers of variables (e.g., &gt;1000). The BFGS-B<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> variant handles simple box constraints.</p>
<h2 id="rationale">Rationale</h2>

<p>The search direction <strong>p</strong><sub><strong><em>k</em></strong></sub> at stage <em>k</em> is given by the solution of the analogue of the Newton equation</p>

<p>

<math display="block" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>B</mi>
     <mi>k</mi>
    </msub>
    <msub>
     <mi>𝐩</mi>
     <mi>k</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mrow>
      <mo>∇</mo>
      <mi>f</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>𝐱</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐩</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-∇</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k}\mathbf{p}_{k}=-\nabla f(\mathbf{x}_{k})
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:1">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k}
  </annotation>
 </semantics>
</math>

 is an approximation to the <a href="Hessian_matrix" title="wikilink">Hessian matrix</a> which is updated iteratively at each stage, and 

<math display="inline" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:2">
 <semantics>
  <mrow>
   <mrow>
    <mo>∇</mo>
    <mi>f</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>𝐱</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-∇</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐱</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla f(\mathbf{x}_{k})
  </annotation>
 </semantics>
</math>

 is the gradient of the function evaluated at <strong>x</strong><sub><em>k</em></sub>. A <a href="line_search" title="wikilink">line search</a> in the direction <strong>p</strong><sub><em>k</em></sub> is then used to find the next point <strong>x</strong><sub><em>k</em>+1</sub>. Instead of requiring the full Hessian matrix at the point <strong>x</strong><sub><em>k</em>+1</sub> to be computed as <em>B</em><sub><em>k</em>+1</sub>, the approximate Hessian at stage <em>k</em> is updated by the addition of two matrices.</p>

<p>

<math display="block" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:3">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>B</mi>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>U</mi>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>V</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k+1}=B_{k}+U_{k}+V_{k}\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>Both <em>U<sub>k</sub></em> and <em>V<sub>k</sub></em> are symmetric rank-one matrices but have different (matrix) bases. The symmetric rank one assumption here means that we may write</p>

<p>

<math display="block" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:4">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <msup>
    <mi>𝐚𝐛</mi>
    <mi mathvariant="normal">T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐚𝐛</ci>
     <ci>normal-T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=\mathbf{a}\mathbf{b}^{\mathrm{T}}
  </annotation>
 </semantics>
</math>

</p>

<p>So equivalently, <em>U<sub>k</sub></em> and <em>V<sub>k</sub></em> construct a rank-two update matrix which is robust against the scale problem often suffered in the <a href="gradient_descent" title="wikilink">gradient descent</a> searching (<em>e.g.</em>, in <a href="Broyden's_method" title="wikilink">Broyden's method</a>).</p>

<p>The quasi-Newton condition imposed on this update is</p>

<p>

<math display="block" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>B</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>𝐱</mi>
        <mrow>
         <mi>k</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>𝐱</mi>
        <mi>k</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo>∇</mo>
       <mi>f</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>𝐱</mi>
        <mrow>
         <mi>k</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mo>∇</mo>
       <mi>f</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>𝐱</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-∇</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-∇</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k+1}(\mathbf{x}_{k+1}-\mathbf{x}_{k})=\nabla f(\mathbf{x}_{k+1})-\nabla f(%
\mathbf{x}_{k}).
  </annotation>
 </semantics>
</math>

</p>
<h2 id="algorithm">Algorithm</h2>

<p>From an initial guess 

<math display="inline" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:6">
 <semantics>
  <msub>
   <mi>𝐱</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐱</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{0}
  </annotation>
 </semantics>
</math>

 and an approximate Hessian matrix 

<math display="inline" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:7">
 <semantics>
  <msub>
   <mi>B</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{0}
  </annotation>
 </semantics>
</math>

 the following steps are repeated as 

<math display="inline" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:8">
 <semantics>
  <msub>
   <mi>𝐱</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐱</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{k}
  </annotation>
 </semantics>
</math>

 converges to the solution.</p>
<ol>
<li>Obtain a direction 

<math display="inline" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:9">
 <semantics>
  <msub>
   <mi>𝐩</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐩</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{p}_{k}
  </annotation>
 </semantics>
</math>

 by solving

<math display="block" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>B</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>𝐩</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mo>∇</mo>
       <mi>f</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>𝐱</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐩</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-∇</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k}\mathbf{p}_{k}=-\nabla f(\mathbf{x}_{k}).
  </annotation>
 </semantics>
</math>

</li>
<li>Perform a <a href="line_search" title="wikilink">line search</a> to find an acceptable stepsize 

<math display="inline" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:11">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{k}
  </annotation>
 </semantics>
</math>

 in the direction found in the first step, then update 

<math display="inline" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐱</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>𝐱</mi>
      <mi>k</mi>
     </msub>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>α</mi>
       <mi>k</mi>
      </msub>
      <msub>
       <mi>𝐩</mi>
       <mi>k</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐱</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐩</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{k+1}=\mathbf{x}_{k}+\alpha_{k}\mathbf{p}_{k}.
  </annotation>
 </semantics>
</math>

</li>
<li>Set 

<math display="inline" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:13">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐬</mi>
     <mi>k</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>𝐩</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐬</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐩</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}_{k}=\alpha_{k}\mathbf{p}_{k}.
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:14">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐲</mi>
     <mi>k</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo>∇</mo>
       <mi>f</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>𝐱</mi>
        <mrow>
         <mi>k</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mo>∇</mo>
       <mi>f</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>𝐱</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐲</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-∇</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-∇</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}_{k}={\nabla f(\mathbf{x}_{k+1})-\nabla f(\mathbf{x}_{k})}.
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>B</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>B</mi>
       <mi>k</mi>
      </msub>
      <mo>+</mo>
      <mfrac>
       <mrow>
        <msub>
         <mi>𝐲</mi>
         <mi>k</mi>
        </msub>
        <msubsup>
         <mi>𝐲</mi>
         <mi>k</mi>
         <mi mathvariant="normal">T</mi>
        </msubsup>
       </mrow>
       <mrow>
        <msubsup>
         <mi>𝐲</mi>
         <mi>k</mi>
         <mi mathvariant="normal">T</mi>
        </msubsup>
        <msub>
         <mi>𝐬</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </mfrac>
     </mrow>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <msub>
        <mi>B</mi>
        <mi>k</mi>
       </msub>
       <msub>
        <mi>𝐬</mi>
        <mi>k</mi>
       </msub>
       <msubsup>
        <mi>𝐬</mi>
        <mi>k</mi>
        <mi mathvariant="normal">T</mi>
       </msubsup>
       <msub>
        <mi>B</mi>
        <mi>k</mi>
       </msub>
      </mrow>
      <mrow>
       <msubsup>
        <mi>𝐬</mi>
        <mi>k</mi>
        <mi mathvariant="normal">T</mi>
       </msubsup>
       <msub>
        <mi>B</mi>
        <mi>k</mi>
       </msub>
       <msub>
        <mi>𝐬</mi>
        <mi>k</mi>
       </msub>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐲</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐲</ci>
          <ci>k</ci>
         </apply>
         <ci>normal-T</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐲</ci>
          <ci>k</ci>
         </apply>
         <ci>normal-T</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐬</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐬</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐬</ci>
         <ci>k</ci>
        </apply>
        <ci>normal-T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐬</ci>
         <ci>k</ci>
        </apply>
        <ci>normal-T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐬</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k+1}=B_{k}+\frac{\mathbf{y}_{k}\mathbf{y}_{k}^{\mathrm{T}}}{\mathbf{y}_{k}^%
{\mathrm{T}}\mathbf{s}_{k}}-\frac{B_{k}\mathbf{s}_{k}\mathbf{s}_{k}^{\mathrm{T%
}}B_{k}}{\mathbf{s}_{k}^{\mathrm{T}}B_{k}\mathbf{s}_{k}}.
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>

<math display="inline" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:16">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\mathbf{x})
  </annotation>
 </semantics>
</math>

 denotes the objective function to be minimized. Convergence can be checked by observing the norm of the gradient, 

<math display="inline" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:17">
 <semantics>
  <mrow>
   <mo>|</mo>
   <mrow>
    <mrow>
     <mo>∇</mo>
     <mi>f</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐱</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <times></times>
     <apply>
      <ci>normal-∇</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left|\nabla f(\mathbf{x}_{k})\right|
  </annotation>
 </semantics>
</math>

. Practically, 

<math display="inline" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:18">
 <semantics>
  <msub>
   <mi>B</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{0}
  </annotation>
 </semantics>
</math>

 can be initialized with 

<math display="inline" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:19">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{0}=I
  </annotation>
 </semantics>
</math>

, so that the first step will be equivalent to a <a href="gradient_descent" title="wikilink">gradient descent</a>, but further steps are more and more refined by 

<math display="inline" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:20">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k}
  </annotation>
 </semantics>
</math>

, the approximation to the Hessian.</p>

<p>The first step of the algorithm is carried out using the inverse of the matrix 

<math display="inline" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:21">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k}
  </annotation>
 </semantics>
</math>

, which is usually obtained efficiently by applying the <a href="Sherman–Morrison_formula" title="wikilink">Sherman–Morrison formula</a> to the fifth line of the algorithm, giving</p>

<p>

<math display="block" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:22">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>B</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mi>I</mi>
        <mo>-</mo>
        <mfrac>
         <mrow>
          <msub>
           <mi>s</mi>
           <mi>k</mi>
          </msub>
          <msubsup>
           <mi>y</mi>
           <mi>k</mi>
           <mi>T</mi>
          </msubsup>
         </mrow>
         <mrow>
          <msubsup>
           <mi>y</mi>
           <mi>k</mi>
           <mi>T</mi>
          </msubsup>
          <msub>
           <mi>s</mi>
           <mi>k</mi>
          </msub>
         </mrow>
        </mfrac>
       </mrow>
       <mo>)</mo>
      </mrow>
      <msubsup>
       <mi>B</mi>
       <mi>k</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mi>I</mi>
        <mo>-</mo>
        <mfrac>
         <mrow>
          <msub>
           <mi>y</mi>
           <mi>k</mi>
          </msub>
          <msubsup>
           <mi>s</mi>
           <mi>k</mi>
           <mi>T</mi>
          </msubsup>
         </mrow>
         <mrow>
          <msubsup>
           <mi>y</mi>
           <mi>k</mi>
           <mi>T</mi>
          </msubsup>
          <msub>
           <mi>s</mi>
           <mi>k</mi>
          </msub>
         </mrow>
        </mfrac>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mfrac>
      <mrow>
       <msub>
        <mi>s</mi>
        <mi>k</mi>
       </msub>
       <msubsup>
        <mi>s</mi>
        <mi>k</mi>
        <mi>T</mi>
       </msubsup>
      </mrow>
      <mrow>
       <mpadded width="+1.7pt">
        <msubsup>
         <mi>y</mi>
         <mi>k</mi>
         <mi>T</mi>
        </msubsup>
       </mpadded>
       <msub>
        <mi>s</mi>
        <mi>k</mi>
       </msub>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>I</ci>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>s</ci>
          <ci>k</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>k</ci>
          </apply>
          <ci>T</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>k</ci>
          </apply>
          <ci>T</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>s</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>I</ci>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>k</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>s</ci>
           <ci>k</ci>
          </apply>
          <ci>T</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>k</ci>
          </apply>
          <ci>T</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>s</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <ci>k</ci>
        </apply>
        <ci>T</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>k</ci>
        </apply>
        <ci>T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k+1}^{-1}=\left(I-\frac{s_{k}y_{k}^{T}}{y_{k}^{T}s_{k}}\right)B_{k}^{-1}%
\left(I-\frac{y_{k}s_{k}^{T}}{y_{k}^{T}s_{k}}\right)+\frac{s_{k}s_{k}^{T}}{y_{%
k}^{T}\,s_{k}}.
  </annotation>
 </semantics>
</math>

</p>

<p>This can be computed efficiently without temporary matrices, recognizing that 

<math display="inline" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:23">
 <semantics>
  <msubsup>
   <mi>B</mi>
   <mi>k</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k}^{-1}
  </annotation>
 </semantics>
</math>

 is symmetric, and that 

<math display="inline" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:24">
 <semantics>
  <mrow>
   <msubsup>
    <mi>𝐲</mi>
    <mi>k</mi>
    <mi mathvariant="normal">T</mi>
   </msubsup>
   <msubsup>
    <mi>B</mi>
    <mi>k</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
   <msub>
    <mi>𝐲</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐲</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-T</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐲</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}_{k}^{\mathrm{T}}B_{k}^{-1}\mathbf{y}_{k}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:25">
 <semantics>
  <mrow>
   <msubsup>
    <mi>𝐬</mi>
    <mi>k</mi>
    <mi mathvariant="normal">T</mi>
   </msubsup>
   <msub>
    <mi>𝐲</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐬</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-T</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐲</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}_{k}^{\mathrm{T}}\mathbf{y}_{k}
  </annotation>
 </semantics>
</math>

 are scalar, using an expansion such as</p>

<p>

<math display="block" id="Broyden–Fletcher–Goldfarb–Shanno_algorithm:26">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>B</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msubsup>
       <mi>B</mi>
       <mi>k</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
      <mo>+</mo>
      <mfrac>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <msubsup>
            <mi>𝐬</mi>
            <mi>k</mi>
            <mi mathvariant="normal">T</mi>
           </msubsup>
           <msub>
            <mi>𝐲</mi>
            <mi>k</mi>
           </msub>
          </mrow>
          <mo>+</mo>
          <mrow>
           <msubsup>
            <mi>𝐲</mi>
            <mi>k</mi>
            <mi mathvariant="normal">T</mi>
           </msubsup>
           <msubsup>
            <mi>B</mi>
            <mi>k</mi>
            <mrow>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
           </msubsup>
           <msub>
            <mi>𝐲</mi>
            <mi>k</mi>
           </msub>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msub>
           <mi>𝐬</mi>
           <mi>k</mi>
          </msub>
          <msubsup>
           <mi>𝐬</mi>
           <mi>k</mi>
           <mi mathvariant="normal">T</mi>
          </msubsup>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msubsup>
           <mi>𝐬</mi>
           <mi>k</mi>
           <mi mathvariant="normal">T</mi>
          </msubsup>
          <msub>
           <mi>𝐲</mi>
           <mi>k</mi>
          </msub>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mfrac>
     </mrow>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mrow>
        <msubsup>
         <mi>B</mi>
         <mi>k</mi>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msubsup>
        <msub>
         <mi>𝐲</mi>
         <mi>k</mi>
        </msub>
        <msubsup>
         <mi>𝐬</mi>
         <mi>k</mi>
         <mi mathvariant="normal">T</mi>
        </msubsup>
       </mrow>
       <mo>+</mo>
       <mrow>
        <msub>
         <mi>𝐬</mi>
         <mi>k</mi>
        </msub>
        <msubsup>
         <mi>𝐲</mi>
         <mi>k</mi>
         <mi mathvariant="normal">T</mi>
        </msubsup>
        <msubsup>
         <mi>B</mi>
         <mi>k</mi>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msubsup>
       </mrow>
      </mrow>
      <mrow>
       <msubsup>
        <mi>𝐬</mi>
        <mi>k</mi>
        <mi mathvariant="normal">T</mi>
       </msubsup>
       <msub>
        <mi>𝐲</mi>
        <mi>k</mi>
       </msub>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>𝐬</ci>
            <ci>k</ci>
           </apply>
           <ci>normal-T</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐲</ci>
           <ci>k</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>𝐲</ci>
            <ci>k</ci>
           </apply>
           <ci>normal-T</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>B</ci>
            <ci>k</ci>
           </apply>
           <apply>
            <minus></minus>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐲</ci>
           <ci>k</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐬</ci>
          <ci>k</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐬</ci>
           <ci>k</ci>
          </apply>
          <ci>normal-T</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐬</ci>
           <ci>k</ci>
          </apply>
          <ci>normal-T</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐲</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>B</ci>
          <ci>k</ci>
         </apply>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐲</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐬</ci>
          <ci>k</ci>
         </apply>
         <ci>normal-T</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐬</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐲</ci>
          <ci>k</ci>
         </apply>
         <ci>normal-T</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>B</ci>
          <ci>k</ci>
         </apply>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐬</ci>
         <ci>k</ci>
        </apply>
        <ci>normal-T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐲</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k+1}^{-1}=B_{k}^{-1}+\frac{(\mathbf{s}_{k}^{\mathrm{T}}\mathbf{y}_{k}+%
\mathbf{y}_{k}^{\mathrm{T}}B_{k}^{-1}\mathbf{y}_{k})(\mathbf{s}_{k}\mathbf{s}_%
{k}^{\mathrm{T}})}{(\mathbf{s}_{k}^{\mathrm{T}}\mathbf{y}_{k})^{2}}-\frac{B_{k%
}^{-1}\mathbf{y}_{k}\mathbf{s}_{k}^{\mathrm{T}}+\mathbf{s}_{k}\mathbf{y}_{k}^{%
\mathrm{T}}B_{k}^{-1}}{\mathbf{s}_{k}^{\mathrm{T}}\mathbf{y}_{k}}.
  </annotation>
 </semantics>
</math>

</p>

<p>In statistical estimation problems (such as maximum likelihood or Bayesian inference), <a href="credible_interval" title="wikilink">credible intervals</a> or <a href="confidence_interval" title="wikilink">confidence intervals</a> for the solution can be estimated from the <a href="matrix_inverse" title="wikilink">inverse</a> of the final Hessian matrix. However, these quantities are technically defined by the true Hessian matrix, and the BFGS approximation may not converge to the true Hessian matrix.</p>
<h2 id="implementations">Implementations</h2>

<p>The <a href="GNU_Scientific_Library" title="wikilink">GSL</a> implements BFGS as <a href="http://www.gnu.org/software/gsl/manual/html_node/Multimin-Algorithms-with-Derivatives.html">gsl_multimin_fdfminimizer_vector_bfgs2</a>. <a href="http://ceres-solver.org/">Ceres Solver</a> implements both BFGS and <a class="uri" href="L-BFGS" title="wikilink">L-BFGS</a>. In <a class="uri" href="SciPy" title="wikilink">SciPy</a>, the <a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fmin_bfgs.html#scipy.optimize.fmin_bfgs">scipy.optimize.fmin_bfgs</a> function implements BFGS. It is also possible to run BFGS using any of the <a class="uri" href="L-BFGS" title="wikilink">L-BFGS</a> algorithms by setting the parameter L to a very large number.</p>

<p>Octave uses BFGS with a double-dogleg approximation to the cubic line search.</p>

<p>In the MATLAB <a href="Optimization_Toolbox" title="wikilink">Optimization Toolbox</a>, the <a href="http://www.mathworks.com/help/toolbox/optim/ug/fminunc.html">fminunc</a> function uses BFGS with cubic <a href="line_search" title="wikilink">line search</a> when the problem size is set to <a href="http://www.mathworks.com/help/toolbox/optim/ug/brnoxr7-1.html#brnpcye">"medium scale."</a></p>

<p>A high-precision arithmetic version of BFGS (<a href="http://www.loshchilov.com/pbfgs.html">pBFGS</a>), implemented in C++ and integrated with the high-precision arithmetic package <a href="http://crd-legacy.lbl.gov/~dhbailey/mpdist/">ARPREC</a> is robust against numerical instability (e.g. round-off errors).</p>

<p>Another C++ implementation of BFGS, along with L-BFGS, L-BFGS-B, CG, and Newton's method) using <a href="Eigen_(C++_library)" title="wikilink">Eigen (C++ library)</a> are available on github under the <a href="MIT_License" title="wikilink">MIT License</a> <a href="https://github.com/PatWie/CppNumericalSolvers">here</a>.</p>

<p>BFGS and L-BFGS are also implemented in C as part of the open-source Gnu Regression, Econometrics and Time-series Library (<a class="uri" href="gretl" title="wikilink">gretl</a>).</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Quasi-Newton_methods" title="wikilink">Quasi-Newton methods</a></li>
<li><a href="Davidon–Fletcher–Powell_formula" title="wikilink">Davidon–Fletcher–Powell formula</a></li>
<li><a class="uri" href="L-BFGS" title="wikilink">L-BFGS</a></li>
<li><a href="Gradient_descent" title="wikilink">Gradient descent</a></li>
<li><a href="Nelder–Mead_method" title="wikilink">Nelder–Mead method</a></li>
<li><a href="Pattern_search_(optimization)" title="wikilink">Pattern search (optimization)</a></li>
<li><a href="BHHH_algorithm" title="wikilink">BHHH algorithm</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="bibliography">Bibliography</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.loshchilov.com/pbfgs.html">Source code of high-precision BFGS</a> A C++ source code of BFGS with high-precision arithmetic</li>
</ul>

<p>"</p>

<p><a href="Category:Optimization_algorithms_and_methods" title="wikilink">Category:Optimization algorithms and methods</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">, page 24<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
