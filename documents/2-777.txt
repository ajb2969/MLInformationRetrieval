   Time hierarchy theorem      Time hierarchy theorem   In computational complexity theory , the time hierarchy theorems are important statements about time-bounded computation on Turing machines . Informally, these theorems say that given more time, a Turing machine can solve more problems. For example, there are problems that can be solved with n 2 time but not n time.  The time hierarchy theorem for deterministic multi-tape Turing machines was first proven by Richard E. Stearns and Juris Hartmanis in 1965. 1 It was improved a year later when F. C. Hennie and Richard E. Stearns improved the efficiency of the Universal Turing machine . 2 Consequent to the theorem, for every deterministic time-bounded complexity class , there is a strictly larger time-bounded complexity class, and so the time-bounded hierarchy of complexity classes does not completely collapse. More precisely, the time hierarchy theorem for deterministic Turing machines states that for all time-constructible functions  f ( n ),       ğƒğ“ğˆğŒğ„   (   o   (    f   (  n  )      log  f    (  n  )     )    )    âŠŠ   ğƒğ“ğˆğŒğ„   (   f   (  n  )    )          ğƒğ“ğˆğŒğ„    o      f  n       f   n        ğƒğ“ğˆğŒğ„    f  n      \mathbf{DTIME}\left(o\left(\frac{f(n)}{\log f(n)}\right)\right)\subsetneq%
 \mathbf{DTIME}(f(n))   .  The time hierarchy theorem for nondeterministic Turing machines was originally proven by Stephen Cook in 1972. 3 It was improved to its current form via a complex proof by Joel Seiferas, Michael Fischer , and Albert Meyer in 1978. 4 Finally in 1983, Stanislav Å½Ã¡k achieved the same result with the simple proof taught today. 5 The time hierarchy theorem for nondeterministic Turing machines states that if g ( n ) is a time-constructible function, and f ( n ) = o ( g ( n )), then       ğğ“ğˆğŒğ„   (   f   (  n  )    )    âŠŠ   ğğ“ğˆğŒğ„   (   g   (  n  )    )          ğğ“ğˆğŒğ„    f  n      ğğ“ğˆğŒğ„    g  n      \mathbf{NTIME}(f(n))\subsetneq\mathbf{NTIME}(g(n))   .  The analogous theorems for space are the space hierarchy theorems . A similar theorem is not known for time-bounded probabilistic complexity classes, unless the class also has advice . 6  Background  Both theorems use the notion of a time-constructible function . A function     f  :   â„•  â†’  â„•      normal-:  f   normal-â†’  â„•  â„•     f:\mathbb{N}\rightarrow\mathbb{N}   is time-constructible if there exists a deterministic Turing machine such that for every    n  âˆˆ  â„•      n  â„•    n\in\mathbb{N}   , if the machine is started with an input of n ones, it will halt after precisely f ( n ) steps. All polynomials with non-negative integral coefficients are time-constructible, as are exponential functions such as 2 n .  Proof overview  We need to prove that some time class TIME ( g ( n )) is strictly larger than some time class TIME ( f ( n )). We do this by constructing a machine which cannot be in TIME ( f ( n )), by diagonalization . We then show that the machine is in TIME ( g ( n )), using a simulator machine .  Deterministic time hierarchy theorem  Statement   Time Hierarchy Theorem. If f ( n ) is a time-constructible function, then there exists a decision problem which cannot be solved in worst-case deterministic time f ( n ) but can be solved in worst-case deterministic time f ( n ) 2 . In other words,        ğƒğ“ğˆğŒğ„   (   f   (  n  )    )    âŠŠ   ğƒğ“ğˆğŒğ„   (   f    (  n  )   2    )     .        ğƒğ“ğˆğŒğ„    f  n      ğƒğ“ğˆğŒğ„    f   superscript  n  2       \mathbf{DTIME}(f(n))\subsetneq\mathbf{DTIME}\left(f(n)^{2}\right).      Note 1.  f ( n ) is at least n , since smaller functions are never time-constructible.  Note 2. Even more generally, it can be shown that if f ( n ) is time-constructible, then        ğƒğ“ğˆğŒğ„   (   o   (    f   (  n  )      log  f    (  n  )     )    )    âŠŠ   ğƒğ“ğˆğŒğ„   (   f   (  n  )    )     .        ğƒğ“ğˆğŒğ„    o      f  n       f   n        ğƒğ“ğˆğŒğ„    f  n      \mathbf{DTIME}\left(o\left(\frac{f(n)}{\log f(n)}\right)\right)\subsetneq%
 \mathbf{DTIME}\left(f(n)\right).   For example, there are problems solvable in time n 2 but not time n , since n is in       o   (    n  2    log   n  2     )    .      o     superscript  n  2      superscript  n  2       o\left(\frac{n^{2}}{\log{n^{2}}}\right).     Proof  We include here a proof that DTIME ( f ( n )) is a strict subset of DTIME ( f (2 n + 1) 3 ) as it is simpler. See the bottom of this section for information on how to extend the proof to f ( n ) 2 .  To prove this, we first define a language as follows:        H  f   =   {   (   [  M  ]   ,  x  )   |    M    accepts    x    in   f   (   |  x  |   )   steps   }    .       subscript  H  f    conditional-set    delimited-[]  M   x     M  accepts  x  in  f    x   steps      H_{f}=\left\{([M],x)\ |\ M\ \mbox{accepts}\ x\ \mbox{in}\ f(|x|)\ \mbox{steps}%
 \right\}.     Here, M is a deterministic Turing machine, and x is its input (the initial contents of its tape). [ M ] denotes an input that encodes the Turing machine M . Let m be the size of the tuple ([ M ], x ).  We know that we can decide membership of H f by way of a deterministic Turing machine that first calculates f (| x |), then writes out a row of 0s of that length, and then uses this row of 0s as a "clock" or "counter" to simulate M for at most that many steps. At each step, the simulating machine needs to look through the definition of M to decide what the next action would be. It is safe to say that this takes at most f ( m ) 3 operations, so        H  f   âˆˆ   ğ“ğˆğŒğ„   (   f    (  m  )   3    )     .       subscript  H  f     ğ“ğˆğŒğ„    f   superscript  m  3       H_{f}\in\mathbf{TIME}(f(m)^{3}).     The rest of the proof will show that       H  f   âˆ‰   ğ“ğˆğŒğ„   (   f   (   âŒŠ    m  2    âŒ‹   )    )         subscript  H  f     ğ“ğˆğŒğ„    f      m  2        H_{f}\notin\mathbf{TIME}(f(\left\lfloor\tfrac{m}{2}\right\rfloor))     so that if we substitute 2 n + 1 for m , we get the desired result. Let us assume that H f is in this time complexity class, and we will attempt to reach a contradiction.  If H f is in this time complexity class, it means we can construct some machine K which, given some machine description [ M ] and input x , decides whether the tuple ([ M ], x ) is in H f within       ğ“ğˆğŒğ„   (   f   (   âŒŠ    m  2    âŒ‹   )    )    .      ğ“ğˆğŒğ„    f      m  2       \mathbf{TIME}(f(\left\lfloor\tfrac{m}{2}\right\rfloor)).     Therefore we can use this K to construct another machine, N , which takes a machine description [ M ] and runs K on the tuple ([ M ], [ M ]), and then accepts only if K rejects, and rejects if K accepts. If now n is the length of the input to N , then m (the length of the input to K ) is twice n plus some delimiter symbol, so m = 2 n + 1. N 's running time is thus        ğ“ğˆğŒğ„   (   f   (   âŒŠ    m  2    âŒ‹   )    )    =   ğ“ğˆğŒğ„   (   f   (   âŒŠ      2  n   +  1   2    âŒ‹   )    )    =   ğ“ğˆğŒğ„   (   f   (  n  )    )     .          ğ“ğˆğŒğ„    f      m  2        ğ“ğˆğŒğ„    f          2  n   1   2             ğ“ğˆğŒğ„    f  n       \mathbf{TIME}(f(\left\lfloor\tfrac{m}{2}\right\rfloor))=\mathbf{TIME}(f(\left%
 \lfloor\tfrac{2n+1}{2}\right\rfloor))=\mathbf{TIME}(f(n)).     Now if we feed [ N ] as input into N itself (which makes n the length of [ N ]) and ask the question whether N accepts its own description as input, we get:   If N  accepts [ N ] (which we know it does in at most f ( n ) operations), this means that K  rejects ([ N ], [ N ]), so ([ N ], [ N ]) is not in H f , and thus N does not accept [ N ] in f ( n ) steps. Contradiction!  If N  rejects [ N ] (which we know it does in at most f ( n ) operations), this means that K  accepts ([ N ], [ N ]), so ([ N ], [ N ]) is in H f , and thus N  does accept [ N ] in f ( n ) steps. Contradiction!   We thus conclude that the machine K does not exist, and so        H  f   âˆ‰   ğ“ğˆğŒğ„   (   f   (   âŒŠ    m  2    âŒ‹   )    )     .       subscript  H  f     ğ“ğˆğŒğ„    f      m  2        H_{f}\notin\mathbf{TIME}(f(\left\lfloor\tfrac{m}{2}\right\rfloor)).     Extension  The reader may have realised that the proof is simpler because we have chosen a simple Turing machine simulation for which we can be certain that        H  f   âˆˆ   ğ“ğˆğŒğ„   (   f    (  m  )   3    )     .       subscript  H  f     ğ“ğˆğŒğ„    f   superscript  m  3       H_{f}\in\mathbf{TIME}(f(m)^{3}).     It has been shown 7 that a more efficient model of simulation exists which establishes that       H  f   âˆˆ   ğ“ğˆğŒğ„   (   f   (  m  )    log  f    (  m  )    )         subscript  H  f     ğ“ğˆğŒğ„    f  m    f   m      H_{f}\in\mathbf{TIME}(f(m)\log f(m))     but since this model of simulation is rather involved, it is not included here.  Non-deterministic time hierarchy theorem  If g ( n ) is a time-constructible function, and f ( n +1) = o ( g ( n )), then there exists a decision problem which cannot be solved in non-deterministic time f ( n ) but can be solved in non-deterministic time g ( n ). In other words, the complexity class NTIME ( f ( n )) is a strict subset of NTIME ( g ( n )).  Consequences  The time hierarchy theorems guarantee that the deterministic and non-deterministic versions of the exponential hierarchy are genuine hierarchies: in other words P    âŠŠ     \subsetneq    EXPTIME    âŠŠ     \subsetneq    2-EXP    âŠŠ     \subsetneq   ... and NP    âŠŠ     \subsetneq    NEXPTIME    âŠŠ     \subsetneq    2-NEXP    âŠŠ     \subsetneq   ....  For example,    ğ  âŠŠ  ğ„ğ—ğğ“ğˆğŒğ„      ğ  ğ„ğ—ğğ“ğˆğŒğ„    \mathbf{P}\subsetneq\mathbf{EXPTIME}   since    ğ  âŠ†   ğƒğ“ğˆğŒğ„   (   2  n   )    âŠŠ   ğƒğ“ğˆğŒğ„   (   2   2  n    )    âŠ†  ğ„ğ—ğğ“ğˆğŒğ„        ğ    ğƒğ“ğˆğŒğ„   superscript  2  n           ğƒğ“ğˆğŒğ„   superscript  2    2  n          ğ„ğ—ğğ“ğˆğŒğ„     \mathbf{P}\subseteq\mathbf{DTIME}(2^{n})\subsetneq\mathbf{DTIME}(2^{2n})%
 \subseteq\mathbf{EXPTIME}   . Indeed     ğƒğ“ğˆğŒğ„   (   2  n   )    âŠ†   ğƒğ“ğˆğŒğ„   (   o   (    2   2  n     2  n    )    )    âŠŠ   ğƒğ“ğˆğŒğ„   (   2   2  n    )            ğƒğ“ğˆğŒğ„   superscript  2  n      ğƒğ“ğˆğŒğ„    o     superscript  2    2  n      2  n             ğƒğ“ğˆğŒğ„   superscript  2    2  n        \mathbf{DTIME}\left(2^{n}\right)\subseteq\mathbf{DTIME}\left(o\left(\frac{2^{2%
 n}}{2n}\right)\right)\subsetneq\mathbf{DTIME}(2^{2n})   form the time hierarchy theorem.  The theorem also guarantees that there are problems in P requiring arbitrary large exponents to solve; in other words, P does not collapse to DTIME ( n k ) for any fixed k . For example, there are problems solvable in n 5000 time but not n 4999 time. This is one argument against Cobham's thesis , the convention that P is a practical class of algorithms. If such a collapse did occur, we could deduce that P â‰  PSPACE , since it is a well-known theorem that DTIME ( f ( n )) is strictly contained in DSPACE ( f ( n )).  However, the time hierarchy theorems provide no means to relate deterministic and non-deterministic complexity, or time and space complexity, so they cast no light on the great unsolved questions of computational complexity theory : whether P and NP , NP and PSPACE , PSPACE and EXPTIME , or EXPTIME and NEXPTIME are equal or not.  See Also   Space hierarchy theorem   References    Pages 310â€“313 of section 9.1: Hierarchy theorems.   Section 7.2: The Hierarchy Theorem, pp.Â 143â€“146.   "  Category:Structural complexity theory  Category:Theorems in computational complexity theory  Category:Articles containing proofs     â†©  â†©  â†©  â†©  â†©  â†©  Luca Trevisan, Notes on Hierarchy Theorems , U.C. Berkeley â†©     