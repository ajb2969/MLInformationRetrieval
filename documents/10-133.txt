   Forcing (recursion theory)      Forcing (recursion theory)  '''Forcing''' in [[recursion theory]] is a modification of [[Paul Cohen (mathematician)|Paul Cohen's]] original [[set theory|set theoretic]] technique of [[forcing (set theory)|forcing]] to deal with the effective concerns in recursion theory . Conceptually the two techniques are quite similar, in both one attempts to build generic objects (intuitively objects that are somehow 'typical') by meeting dense sets. Also both techniques are elegantly described as a relation (customarily denoted   ⊩   forces   \Vdash   ) between 'conditions' and sentences. However, where set theoretic forcing is usually interested in creating objects that meet every dense set of conditions in the ground model, recursion theoretic forcing only aims to meet dense sets that are arithmetically or hyperarithmetically definable. Therefore some of the more difficult machinery used in set theoretic forcing can be eliminated or substantially simplified when defining forcing in recursion theory. But while the machinery may be somewhat different recursion theoretic and set theoretic forcing are properly regarded as an application of the same technique to different classes of formulas.  Terminology  In this article we use the following terminology.   real: an element of    2  ω     superscript  2  ω    2^{\omega}   . In other words a function that maps each integer to either 0 or 1. string: an element of    2    <  ω      superscript  2    absent  ω     2^{<\omega}   . In other words a finite approximation to a real.    notion of forcing : A notion of forcing is a set   P   P   P   and a partial order on   P   P   P   ,    ≻  P     subscript  succeeds  P    \succ_{P}   with a greatest element     0  P     subscript  0  P    0_{P}   .    condition: An element in a notion of forcing. We say a condition   p   p   p   is stronger than a condition   q   q   q   just when    q   ≻  P   p      subscript  succeeds  P   q  p    q\succ_{P}p   .        p  ∣  q     fragments  p  normal-∣  q    p\mid q   : Given conditions    p  ,  q     p  q    p,q   say that   p   p   p   and   q   q   q   are incompatible if there is no condition   r   r   r   with    p   ≻  P   r      subscript  succeeds  P   p  r    p\succ_{P}r   and    q   ≻  P   r      subscript  succeeds  P   q  r    q\succ_{P}r   .   p   p   p   is compatible with   q   q   q   if they are not incompatible.    Filter : A subset   F   F   F   of a notion of forcing   P   P   P   is a filter if     p  ,  q   ∈  F  ⟹  p  ∤  q         p  q   F       p    not-divides    q     p,q\in F\implies p\nmid q   and    p  ∈   F  ∧  q    ≻  P   p  ⟹  q  ∈  F        p    F  q      subscript  succeeds  P     p       q       F     p\in F\land q\succ_{P}p\implies q\in F   . In other words a filter is a compatible set of conditions closed under weakening of conditions.    Ultrafilter : A maximal filter, i.e.,   F   F   F   is an ultrafilter if   F   F   F   is a filter and there is no filter    F  ′     superscript  F  normal-′    F^{\prime}   properly containing   F   F   F       Cohen forcing: The notion of forcing   C   C   C   where conditions are elements of    2    <  ω      superscript  2    absent  ω     2^{<\omega}   and    (  τ   ≻  C   σ  ⇔  σ  ⊃  τ     fragments  normal-(  τ   subscript  succeeds  C   σ  iff  σ  superset-of  τ    (\tau\succ_{C}\sigma\iff\sigma\supset\tau   )   Note that for Cohen forcing    ≻  C     subscript  succeeds  C    \succ_{C}   is the reverse of the containment relation. This leads to an unfortunate notational confusion where some recursion theorists reverse the direction of the forcing partial order (exchanging    ≻  P     subscript  succeeds  P    \succ_{P}   with    ≺  P     subscript  precedes  P    \prec_{P}   which is more natural for Cohen forcing but is at odds with the notation used in set theory.  Generic objects  The intuition behind forcing is that our conditions are finite approximations to some object we wish to build and that   σ   σ   \sigma   is stronger than   τ   τ   \tau   when   σ   σ   \sigma   agrees with everything   τ   τ   \tau   says about the object we are building and adds some information of its own. For instance in Cohen forcing the conditions can be viewed as finite approximations to a real and if    τ   ≻  C   σ      subscript  succeeds  C   τ  σ    \tau\succ_{C}\sigma   then   σ   σ   \sigma   tells us the value of the real on more places.  In a moment we will define a relation    σ   ⊩  P   ψ      subscript  forces  P   σ  ψ    \sigma\Vdash_{P}\psi   (read   σ   σ   \sigma   forces   ψ   ψ   \psi   ) that holds between conditions (elements of   P   P   P   ) and sentences but first we need to explain the language (mathematics) that   ψ   ψ   \psi   is a sentence for. However, forcing is a technique not a definition and the language for   ψ   ψ   \psi   will depend on the application one has in mind and the choice of   P   P   P   .  The idea is that our language should express facts about the object we wish to build with our forcing construction.  References   Melvin Fitting (1981), Fundamentals of generalized recursion theory .  Piergiorgio Odifreddi (1999), Classical Recursion Theory , v. 2.   "  Category:Computability theory   