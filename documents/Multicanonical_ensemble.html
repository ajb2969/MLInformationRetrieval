<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="564">Multicanonical ensemble</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Multicanonical ensemble</h1>
<hr/>

<p>In <a class="uri" href="statistics" title="wikilink">statistics</a> and <a class="uri" href="physics" title="wikilink">physics</a>, <strong>multicanonical ensemble</strong> (also called <strong>multicanonical sampling</strong> or <strong>flat histogram</strong>) is a <a href="Markov_chain_Monte_Carlo" title="wikilink">Markov chain Monte Carlo</a> sampling technique that uses the <a href="Metropolisâ€“Hastings_algorithm" title="wikilink">Metropolisâ€“Hastings algorithm</a> to compute <a href="integral" title="wikilink">integrals</a> where the integrand has a rough landscape with multiple <a href="Local_minimum" title="wikilink">local minima</a>. It samples states according to the inverse of the <a href="density_of_states" title="wikilink">density of states</a>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> which has to be known a priori or be computed using other techniques like the <a href="Wang_and_Landau_algorithm" title="wikilink">Wang and Landau algorithm</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Multicanonical sampling is an important technique for <a href="spin_(physics)" title="wikilink">spin</a> systems like the <a href="Ising_model" title="wikilink">Ising model</a> or <a href="spin_glass" title="wikilink">spin glasses</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="motivation">Motivation</h2>

<p>In systems with a large number of degrees of freedom, like spin systems, <a href="Monte_Carlo_integration" title="wikilink">Monte Carlo integration</a> is required. In this integration, <a href="importance_sampling" title="wikilink">importance sampling</a> and in particular the <a href="Metropolis_algorithm" title="wikilink">Metropolis algorithm</a>, is a very important technique.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> However, the Metropolis algorithm samples states according to 

<math display="inline" id="Multicanonical_ensemble:0">
 <semantics>
  <mrow>
   <mi>exp</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>Î²</mi>
      <mi>E</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exp></exp>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>Î²</ci>
      <ci>E</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exp(-\beta E)
  </annotation>
 </semantics>
</math>

 where beta is the inverse of the temperature. This means that an energy barrier of 

<math display="inline" id="Multicanonical_ensemble:1">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Î”</mi>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Î”</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta E
  </annotation>
 </semantics>
</math>

 on the energy spectrum is exponentially difficult to overcome.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Systems with multiple local energy minima like the <a href="Potts_model" title="wikilink">Potts model</a> become hard to sample as the algorithm gets stuck in the system's local minima.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> This motivates other approaches, namely, other sampling distributions.</p>
<h2 id="overview">Overview</h2>

<p>Multicanonical ensemble uses the Metropolisâ€“Hastings algorithm with a sampling distribution given by the inverse of the density of states of the system, contrary to the sampling distribution 

<math display="inline" id="Multicanonical_ensemble:2">
 <semantics>
  <mrow>
   <mi>exp</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>Î²</mi>
      <mi>E</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exp></exp>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>Î²</ci>
      <ci>E</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exp(-\beta E)
  </annotation>
 </semantics>
</math>

 of the Metropolis algorithm.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> With this choice, on average, the number of states sampled at each energy is constant, i.e. it is a simulation with a "flat histogram" on energy. This leads to an algorithm for which the energy barriers are no longer difficult to overcome. Another advantage over the Metropolis algorithm is that the sampling is independent of the temperature of the system, which means that one simulation allows the estimation of thermodynamical variables for all temperatures (thus the name "multicanonical": several temperatures). This is a great improvement in the study of first order <a href="phase_transition" title="wikilink">phase transitions</a>.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>The biggest problem in performing a multicanonical ensemble is that the density of states has to be known <em>a priori</em>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> One important contribution to multicanonical sampling was the <a href="Wang_and_Landau_algorithm" title="wikilink">Wang and Landau algorithm</a>, which asymptotically converges to a multicanonical ensemble while calculating the density of states during the convergence.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>The multicanonical ensemble is not restricted to physical systems. It can be employed on abstract systems which have a cost function <em>F</em>. By using the density of states with respect to F, the method becomes general for computing higher-dimensional integrals or finding local minima.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="motivation-1">Motivation</h2>

<p>Consider a system and it phase-space 

<math display="inline" id="Multicanonical_ensemble:3">
 <semantics>
  <mi mathvariant="normal">Î©</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Î©</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 characterized by a configuration 

<math display="inline" id="Multicanonical_ensemble:4">
 <semantics>
  <mrow>
   <mi>ğ’“</mi>
   <mo>âˆˆ</mo>
   <mi mathvariant="normal">Î©</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ğ’“</ci>
    <ci>normal-Î©</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{r}\in\Omega
  </annotation>
 </semantics>
</math>

 and a "cost" function <em>F</em> from the system's phase-space to a one-dimensional space 

<math display="inline" id="Multicanonical_ensemble:5">
 <semantics>
  <mi mathvariant="normal">Î“</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Î“</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>



<math display="block" id="Multicanonical_ensemble:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">Î©</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi mathvariant="normal">Î“</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi mathvariant="normal">Î“</mi>
     <mi>min</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi mathvariant="normal">Î“</mi>
     <mi>max</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>normal-Î©</ci>
     </apply>
     <ci>normal-Î“</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <interval closure="closed">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Î“</ci>
       <min></min>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Î“</ci>
       <max></max>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\Omega)=\Gamma=[\Gamma_{\min},\Gamma_{\max}]
  </annotation>
 </semantics>
</math>

, the spectrum of <em>F</em>.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>{{show</p></td>
<td style="text-align: left;">
<p>example:</p></td>
<td style="text-align: left;">
<p>The <a href="Ising_model" title="wikilink">Ising model</a> with <em>N</em> sites is an example of such a system; the phase-space is a discrete phase-space defined by all possible configurations of <em>N</em> spins 

<math display="inline" id="Multicanonical_ensemble:7">
 <semantics>
  <mrow>
   <mi>ğ’“</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Ïƒ</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">â€¦</mi>
    <mo>,</mo>
    <msub>
     <mi>Ïƒ</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">â€¦</mi>
    <mo>,</mo>
    <msub>
     <mi>Ïƒ</mi>
     <mi>N</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ’“</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Ïƒ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-â€¦</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Ïƒ</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-â€¦</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Ïƒ</ci>
      <ci>N</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{r}=(\sigma_{1},\ldots,\sigma_{i},\ldots,\sigma_{N})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Multicanonical_ensemble:8">
 <semantics>
  <mrow>
   <msub>
    <mi>Ïƒ</mi>
    <mi>i</mi>
   </msub>
   <mo>âˆˆ</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Ïƒ</ci>
     <ci>i</ci>
    </apply>
    <set>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{i}\in\{-1,1\}
  </annotation>
 </semantics>
</math>

. The cost function is the <a href="Hamiltonian_(quantum_mechanics)" title="wikilink">Hamiltonian</a> of the system:</p>

<p>

<math display="block" id="Multicanonical_ensemble:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>H</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ğ’“</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">âˆ‘</mo>
       <mrow>
        <mo stretchy="false">âŸ¨</mo>
        <mrow>
         <mpadded width="+3.3pt">
          <mi>i</mi>
         </mpadded>
         <mi>j</mi>
        </mrow>
        <mo stretchy="false">âŸ©</mo>
       </mrow>
      </munder>
      <mrow>
       <msub>
        <mi>J</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mrow>
          <msub>
           <mi>Ïƒ</mi>
           <mi>i</mi>
          </msub>
          <msub>
           <mi>Ïƒ</mi>
           <mi>j</mi>
          </msub>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>ğ’“</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <csymbol cd="latexml">delimited-âŸ¨âŸ©</csymbol>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>J</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Ïƒ</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Ïƒ</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(\boldsymbol{r})=-\sum_{\langle i~{}j\rangle}J_{ij}(1-\sigma_{i}\sigma_{j}),
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Multicanonical_ensemble:10">
 <semantics>
  <msub>
   <mi>J</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>J</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J_{ij}
  </annotation>
 </semantics>
</math>

 is the sum over neighborhoods and 

<math display="inline" id="Multicanonical_ensemble:11">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Î“</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>E</mi>
     <mi>min</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>E</mi>
     <mi>max</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Î“</ci>
    <interval closure="closed">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <min></min>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <max></max>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma=[E_{\min},E_{\max}]
  </annotation>
 </semantics>
</math>

 is the interaction matrix. The energy spectrum is 

<math display="inline" id="Multicanonical_ensemble:12">
 <semantics>
  <msub>
   <mi>J</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>J</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J_{ij}
  </annotation>
 </semantics>
</math>

 which, in this case, depends on the particular 

<math display="inline" id="Multicanonical_ensemble:13">
 <semantics>
  <msub>
   <mi>J</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>J</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J_{ij}
  </annotation>
 </semantics>
</math>

 used. If all 

<math display="inline" id="Multicanonical_ensemble:14">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mi>min</mi>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <min></min>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{\min}=0
  </annotation>
 </semantics>
</math>

 are 1 (the ferromagnetic Ising model), 

<math display="inline" id="Multicanonical_ensemble:15">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mi>max</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mi>D</mi>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <max></max>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>D</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{\max}=2DN
  </annotation>
 </semantics>
</math>

 (e.g. all spins are 1.) and 

<math display="inline" id="Multicanonical_ensemble:16">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Î“</mi>
   <mo>âˆˆ</mo>
   <mi>â„¤</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>normal-Î“</ci>
    <ci>â„¤</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\in\mathbb{Z}
  </annotation>
 </semantics>
</math>

 (half spins are up, half spins are down). Also notice that in this system, 

<math display="inline" id="Multicanonical_ensemble:17">
 <semantics>
  <mrow>
   <mo stretchy="false">âŸ¨</mo>
   <mi>Q</mi>
   <mo stretchy="false">âŸ©</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-âŸ¨âŸ©</csymbol>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle Q\rangle
  </annotation>
 </semantics>
</math>

 }}</p></td>
</tr>
</tbody>
</table>

<p>The computation of an average quantity 

<math display="block" id="Multicanonical_ensemble:18">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">âŸ¨</mo>
    <mi>Q</mi>
    <mo stretchy="false">âŸ©</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>V</mi>
    </mfrac>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">âˆ«</mo>
      <mi mathvariant="normal">Î©</mi>
     </msub>
     <mrow>
      <mi>Q</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ğ’“</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ğ’“</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>ğ’“</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">delimited-âŸ¨âŸ©</csymbol>
     <ci>Q</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>V</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Î©</ci>
      </apply>
      <apply>
       <times></times>
       <ci>Q</ci>
       <ci>ğ’“</ci>
       <ci>p</ci>
       <ci>ğ’“</ci>
       <ci>d</ci>
       <ci>ğ’“</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle Q\rangle=\frac{1}{V}\int_{\Omega}Q(\boldsymbol{r})p(\boldsymbol{r})\,d%
\boldsymbol{r}
  </annotation>
 </semantics>
</math>

 over the phase-space requires the evaluation of an integral:</p>

<p>

<math display="inline" id="Multicanonical_ensemble:19">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ğ’“</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>ğ’“</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\boldsymbol{r})
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="block" id="Multicanonical_ensemble:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ğ’“</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>V</mi>
     </mfrac>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">âˆ«</mo>
       <mi mathvariant="normal">Î©</mi>
      </msub>
      <mrow>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ğ’“</mi>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <mi>d</mi>
       <mi>ğ’“</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>ğ’“</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>V</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Î©</ci>
      </apply>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>ğ’“</ci>
       <ci>d</ci>
       <ci>ğ’“</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\boldsymbol{r})=\frac{1}{V}\int_{\Omega}p(\boldsymbol{r})\,d\boldsymbol{r}.
  </annotation>
 </semantics>
</math>

 is weight of each state per volume,</p>

<p>

<math display="block" id="Multicanonical_ensemble:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>Ï</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>V</mi>
    </mfrac>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">âˆ«</mo>
      <mi mathvariant="normal">Î©</mi>
     </msub>
     <mrow>
      <mi>Î´</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>f</mi>
        <mo>-</mo>
        <mrow>
         <mi>F</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>ğ’“</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>ğ’“</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Ï</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>V</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Î©</ci>
      </apply>
      <apply>
       <times></times>
       <ci>Î´</ci>
       <apply>
        <minus></minus>
        <ci>f</ci>
        <apply>
         <times></times>
         <ci>F</ci>
         <ci>ğ’“</ci>
        </apply>
       </apply>
       <ci>d</ci>
       <ci>ğ’“</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(f)=\frac{1}{V}\int_{\Omega}\delta(f-F(\boldsymbol{r}))\,d\boldsymbol{r}
  </annotation>
 </semantics>
</math>

</p>

<p>The density of states in respect with <em>F</em> is given by</p>

<p>

<math display="inline" id="Multicanonical_ensemble:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ğ’“</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>F</mi>
    <mi>ğ’“</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>ğ’“</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>ğ’“</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\boldsymbol{r})=F_{\boldsymbol{r}}
  </annotation>
 </semantics>
</math>

</p>

<p>which means that if both <em>Q</em> and <em>p</em> do not depend on the particular state but only on the particular F's value of the state 

<math display="block" id="Multicanonical_ensemble:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>Q</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ğ’“</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>Q</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>F</mi>
        <mi>ğ’“</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ğ’“</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>F</mi>
        <mi>ğ’“</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>ğ’“</ci>
     </apply>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>ğ’“</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>ğ’“</ci>
     </apply>
     <apply>
      <times></times>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>ğ’“</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(\boldsymbol{r})=Q(F_{\boldsymbol{r}}),p(\boldsymbol{r})=p(F_{\boldsymbol{r}}),
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="inline" id="Multicanonical_ensemble:24">
 <semantics>
  <mrow>
   <mo stretchy="false">âŸ¨</mo>
   <mi>Q</mi>
   <mo stretchy="false">âŸ©</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-âŸ¨âŸ©</csymbol>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle Q\rangle
  </annotation>
 </semantics>
</math>

</p>

<p>the formula for 

<math display="inline" id="Multicanonical_ensemble:25">
 <semantics>
  <mrow>
   <mo stretchy="false">âŸ¨</mo>
   <mi>Q</mi>
   <mo stretchy="false">âŸ©</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-âŸ¨âŸ©</csymbol>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\langle Q\rangle
  </annotation>
 </semantics>
</math>


 can be integrated over <em>f</em> by adding a <a href="dirac_delta_function" title="wikilink">dirac delta function</a>,</p>

<p>

<math display="inline" id="Multicanonical_ensemble:26">
 <semantics>
  <mi mathvariant="normal">Î©</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Î©</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

</p>

<p>i.e. the knowledge of the density of states allows the computation of averages over <em>F</em> using a one-dimensional integral instead of a multidimensional integral as it is the projection of the number of states on 

<math display="inline" id="Multicanonical_ensemble:27">
 <semantics>
  <mi mathvariant="normal">Î“</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Î“</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Multicanonical_ensemble:28">
 <semantics>
  <mi>Î²</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Î²</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>{{show</p></td>
<td style="text-align: left;">
<p>example:</p></td>
<td style="text-align: left;">
<p>A system in contact with a heat bath at inverse temperature 

<math display="block" id="Multicanonical_ensemble:29">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">âŸ¨</mo>
    <mi>E</mi>
    <mo stretchy="false">âŸ©</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>V</mi>
    </mfrac>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">âˆ«</mo>
      <mi mathvariant="normal">Î©</mi>
     </msub>
     <mrow>
      <mi>H</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ğ’“</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mpadded width="+1.7pt">
       <mfrac>
        <msup>
         <mi>e</mi>
         <mrow>
          <mo>-</mo>
          <mrow>
           <mi>Î²</mi>
           <mi>H</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>ğ’“</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
        </msup>
        <mi>Z</mi>
       </mfrac>
      </mpadded>
      <mi>d</mi>
      <mi>ğ’“</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">delimited-âŸ¨âŸ©</csymbol>
     <ci>E</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>V</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Î©</ci>
      </apply>
      <apply>
       <times></times>
       <ci>H</ci>
       <ci>ğ’“</ci>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <ci>Î²</ci>
           <ci>H</ci>
           <ci>ğ’“</ci>
          </apply>
         </apply>
        </apply>
        <ci>Z</ci>
       </apply>
       <ci>d</ci>
       <ci>ğ’“</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle E\rangle=\frac{1}{V}\int_{\Omega}H(\boldsymbol{r})\frac{e^{-\beta H(%
\boldsymbol{r})}}{Z}\,d\boldsymbol{r}
  </annotation>
 </semantics>
</math>

 is a clear example for computing this kind of integral. For instance, the mean energy of the system is weighted by the <a href="Boltzmann_factor" title="wikilink">Boltzmann factor</a>:</p>

<p>

<math display="block" id="Multicanonical_ensemble:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>Z</mi>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>V</mi>
     </mfrac>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">âˆ«</mo>
       <mi mathvariant="normal">Î©</mi>
      </msub>
      <mrow>
       <mpadded width="+1.7pt">
        <msup>
         <mi>e</mi>
         <mrow>
          <mo>-</mo>
          <mrow>
           <mi>Î²</mi>
           <mi>H</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>ğ’“</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
        </msup>
       </mpadded>
       <mi>d</mi>
       <mi>ğ’“</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Z</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>V</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Î©</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>Î²</ci>
          <ci>H</ci>
          <ci>ğ’“</ci>
         </apply>
        </apply>
       </apply>
       <ci>d</ci>
       <ci>ğ’“</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z=\frac{1}{V}\int_{\Omega}e^{-\beta H(\boldsymbol{r})}\,d\boldsymbol{r}.
  </annotation>
 </semantics>
</math>

 where</p>

<p>

<math display="inline" id="Multicanonical_ensemble:31">
 <semantics>
  <mrow>
   <mi>Ï</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Ï</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(E)
  </annotation>
 </semantics>
</math>

 The density of states 

<math display="inline" id="Multicanonical_ensemble:32">
 <semantics>
  <mrow>
   <mo stretchy="false">âŸ¨</mo>
   <mi>E</mi>
   <mo stretchy="false">âŸ©</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-âŸ¨âŸ©</csymbol>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle E\rangle
  </annotation>
 </semantics>
</math>

 can used to compute 

<math display="block" id="Multicanonical_ensemble:33">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">âŸ¨</mo>
    <mi>E</mi>
    <mo stretchy="false">âŸ©</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">âˆ«</mo>
     <msub>
      <mi>E</mi>
      <mi>min</mi>
     </msub>
     <msub>
      <mi>E</mi>
      <mi>max</mi>
     </msub>
    </msubsup>
    <mrow>
     <mi>E</mi>
     <mfrac>
      <msup>
       <mi>e</mi>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>Î²</mi>
         <mi>E</mi>
        </mrow>
       </mrow>
      </msup>
      <mi>Z</mi>
     </mfrac>
     <mi>Ï</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>E</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>E</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">delimited-âŸ¨âŸ©</csymbol>
     <ci>E</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <min></min>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <max></max>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>Î²</ci>
          <ci>E</ci>
         </apply>
        </apply>
       </apply>
       <ci>Z</ci>
      </apply>
      <ci>Ï</ci>
      <ci>E</ci>
      <ci>d</ci>
      <ci>E</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle E\rangle=\int_{E_{\min}}^{E_{\max}}E\frac{e^{-\beta E}}{Z}\rho(E)\,dE
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="inline" id="Multicanonical_ensemble:34">
 <semantics>
  <mrow>
   <mo stretchy="false">âŸ¨</mo>
   <mi>Q</mi>
   <mo stretchy="false">âŸ©</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-âŸ¨âŸ©</csymbol>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle Q\rangle
  </annotation>
 </semantics>
</math>

 }}</p></td>
</tr>
</tbody>
</table>

<p>Because the number of states can be high for systems with high number of degrees of freedom, an analytical expression can be hard to obtain and the computation of 

<math display="inline" id="Multicanonical_ensemble:35">
 <semantics>
  <mrow>
   <msub>
    <mi>ğ’“</mi>
    <mi>i</mi>
   </msub>
   <mo>âˆˆ</mo>
   <mi mathvariant="normal">Î©</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ’“</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-Î©</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{r}_{i}\in\Omega
  </annotation>
 </semantics>
</math>

 can be expensive. Typically, because the problem is a multidimensional integral, <a href="Monte_Carlo_integration" title="wikilink">Monte Carlo integration</a> is normally employed. On the simplest formulation, the method chooses <em>N</em> uniform random states 

<math display="block" id="Multicanonical_ensemble:36">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>Q</mi>
     <mo>Â¯</mo>
    </mover>
    <mi>N</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>N</mi>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">âˆ‘</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mrow>
      <mi>Q</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>ğ’“</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>ğ’“</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-Â¯</ci>
      <ci>Q</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <ci>Q</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ğ’“</ci>
        <ci>i</ci>
       </apply>
       <ci>p</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ğ’“</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{Q}_{N}=\frac{1}{N}\sum_{i=0}^{N}Q(\boldsymbol{r}_{i})p(\boldsymbol{r%
}_{i})
  </annotation>
 </semantics>
</math>

, and uses the <a class="uri" href="estimator" title="wikilink">estimator</a></p>

<p>

<math display="inline" id="Multicanonical_ensemble:37">
 <semantics>
  <mrow>
   <mo stretchy="false">âŸ¨</mo>
   <mi>Q</mi>
   <mo stretchy="false">âŸ©</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-âŸ¨âŸ©</csymbol>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle Q\rangle
  </annotation>
 </semantics>
</math>

</p>

<p>for computing 

<math display="block" id="Multicanonical_ensemble:38">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>Q</mi>
    <mo>Â¯</mo>
   </mover>
   <mi>N</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-Â¯</ci>
     <ci>Q</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{Q}_{N}
  </annotation>
 </semantics>
</math>



<math display="inline" id="Multicanonical_ensemble:39">
 <semantics>
  <mrow>
   <mo stretchy="false">âŸ¨</mo>
   <mi>Q</mi>
   <mo stretchy="false">âŸ©</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-âŸ¨âŸ©</csymbol>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle Q\rangle
  </annotation>
 </semantics>
</math>

 converges almost surely to 

<math display="block" id="Multicanonical_ensemble:40">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder>
      <mo movablelimits="false">lim</mo>
      <mrow>
       <mi>N</mi>
       <mo>â†’</mo>
       <mi mathvariant="normal">âˆ</mi>
      </mrow>
     </munder>
     <msub>
      <mover accent="true">
       <mi>Q</mi>
       <mo>Â¯</mo>
      </mover>
      <mi>N</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">âŸ¨</mo>
     <mi>Q</mi>
     <mo stretchy="false">âŸ©</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-â†’</ci>
       <ci>N</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-Â¯</ci>
       <ci>Q</ci>
      </apply>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-âŸ¨âŸ©</csymbol>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lim_{N\rightarrow\infty}\overline{Q}_{N}=\langle Q\rangle.
  </annotation>
 </semantics>
</math>

 by the <a href="Law_of_large_numbers#Strong_law" title="wikilink">strong law of large numbers</a>:</p>

<p>

<math display="inline" id="Multicanonical_ensemble:41">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>Q</mi>
    <mo>Â¯</mo>
   </mover>
   <mi>N</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-Â¯</ci>
     <ci>Q</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{Q}_{N}
  </annotation>
 </semantics>
</math>

</p>

<p>One typical problem of this convergence is that the variance of <em>Q</em> can be very high, which leads to a high computational effort to achieve reasonable results.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>{{show</p></td>
<td style="text-align: left;">
<p>example</p></td>
<td style="text-align: left;">
<p>On the previous example, the states that mostly contribute to the integral are the ones with low energy. If the states are sampled uniformly, on average, the number of states which are sampled with energy <em>E</em> is given by the density of states. This density of states can be centered far away from the energy's minima and thus the average can be difficult to obtain. }}</p></td>
</tr>
</tbody>
</table>

<p>To improve this convergence, the <a href="Metropolisâ€“Hastings_algorithm" title="wikilink">Metropolisâ€“Hastings algorithm</a> was proposed. Generally, Monte Carlo methods' idea is to use <a href="importance_sampling" title="wikilink">importance sampling</a> to improve the convergence of the estimator 

<math display="inline" id="Multicanonical_ensemble:42">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ğ’“</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>ğ’“</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\boldsymbol{r})
  </annotation>
 </semantics>
</math>

 by sampling states according to an arbitrary distribution 

<math display="block" id="Multicanonical_ensemble:43">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>Q</mi>
     <mo>Â¯</mo>
    </mover>
    <mi>N</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>X</mi>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">âˆ‘</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mrow>
      <mi>Q</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>ğ’“</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>P</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>ğ’“</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>ğ’“</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-Â¯</ci>
      <ci>Q</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>X</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <ci>Q</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ğ’“</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>P</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ğ’“</ci>
        <ci>i</ci>
       </apply>
       <ci>p</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ğ’“</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{Q}_{N}=\frac{1}{X}\sum_{i=0}^{N}Q(\boldsymbol{r}_{i})P^{-1}(%
\boldsymbol{r}_{i})p(\boldsymbol{r}_{i})
  </annotation>
 </semantics>
</math>

 (notice the capital <em>P</em>, different from <em>p</em>), and use the appropriate estimator:</p>

<p>

<math display="inline" id="Multicanonical_ensemble:44">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">âˆ‘</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>N</mi>
    </msubsup>
    <mrow>
     <msup>
      <mi>P</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>ğ’“</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>P</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ğ’“</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=\sum_{i=0}^{N}P^{-1}(\boldsymbol{r}_{i})
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="block" id="Multicanonical_ensemble:45">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ğ’“</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi>Boltzmann</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ğ’“</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>Î²</mi>
       <mi>F</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ğ’“</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msup>
    <mrow>
     <mpadded width="+1.7pt">
      <msub>
       <mo largeop="true" symmetric="true">âˆ«</mo>
       <mi mathvariant="normal">Î©</mi>
      </msub>
     </mpadded>
     <mrow>
      <mi>d</mi>
      <mi>ğ’“</mi>
      <msup>
       <mi>e</mi>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>Î²</mi>
         <mi>F</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>ğ’“</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>ğ’“</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>Boltzmann</ci>
      </apply>
      <ci>ğ’“</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>Î²</ci>
         <ci>F</ci>
         <ci>ğ’“</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <ci>normal-Î©</ci>
       </apply>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>ğ’“</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <ci>Î²</ci>
           <ci>F</ci>
           <ci>ğ’“</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\boldsymbol{r})=p_{\mathrm{Boltzmann}}(\boldsymbol{r})=\frac{e^{-\beta F(%
\boldsymbol{r})}}{\int_{\Omega}\,d\boldsymbol{r}e^{-\beta F(\boldsymbol{r})}}
  </annotation>
 </semantics>
</math>

.</p>

<p>Notice that when <em>P</em> is a uniform distribution, this estimator equals the one used on a uniform sampling, as it should.</p>

<p>One important choice of <em>P</em> is to define an arbitrary temperature, and use it equals to <a href="Boltzmann_factor" title="wikilink">Boltzmann factor</a> with the energy being the cost function:</p>

<p>

<math display="block" id="Multicanonical_ensemble:46">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ğ’“</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>Ï</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>F</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ğ’“</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>ğ’“</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>Ï</ci>
      <apply>
       <times></times>
       <ci>F</ci>
       <ci>ğ’“</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\boldsymbol{r})=\frac{1}{\rho(F(\boldsymbol{r}))}
  </annotation>
 </semantics>
</math>

</p>

<p>I.e. the lower the cost function of a particular state, the more likely it is to be sampled.</p>

<p>Historically, this occurred because the <a href="Equation_of_State_Calculations_by_Fast_Computing_Machines" title="wikilink">original idea</a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> was exactly to use <a href="Metropolisâ€“Hastings_algorithm" title="wikilink">Metropolisâ€“Hastings algorithm</a> to compute averages on a system in contact with a heat bath where the weight is given by the Boltzmann factor. On these systems, the choice of states according to it led to a considerable improvement on studying physical systems.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>However, it is not true that the sampling distribution must equals the weight distribution. One reason for this is that <a href="Metropolisâ€“Hastings_algorithm" title="wikilink">Metropolisâ€“Hastings algorithm</a> fails to converge when the cost function has multiple minima.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> The reason is that the algorithm uses a random walk with local steps. I.e. the random walk normally performs steps whose energy difference is of order 1. This means that the computational cost to the algorithm leave a specific region with a local minimum exponentially increases with the cost function's value of the minimum. I.e. the deeper the minimum, the more time the algorithm spends there, and harder (exponentially with deep) it will leave.</p>

<p>This is the motivation to introduce a multicanonic ensemble. The idea is to avoid becoming stuck on local minima of the cost function by making them "invisible" to the sampling technique.</p>
<h2 id="multicanonic-ensemble">Multicanonic ensemble</h2>

<p>A multicanonic ensemble is choosing the sampling distribution used in the importance sampling to be</p>

<p>

<math display="block" id="Multicanonical_ensemble:47">
 <semantics>
  <mrow>
   <mrow>
    <mi>Ï</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>V</mi>
    </mfrac>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">âˆ«</mo>
      <mi mathvariant="normal">Î©</mi>
     </msub>
     <mrow>
      <mi>Î´</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>F</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>ğ’“</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mi>f</mi>
       </mrow>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>ğ’“</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Ï</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>V</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Î©</ci>
      </apply>
      <apply>
       <times></times>
       <ci>Î´</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>F</ci>
         <ci>ğ’“</ci>
        </apply>
        <ci>f</ci>
       </apply>
       <ci>d</ci>
       <ci>ğ’“</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(f)=\frac{1}{V}\int_{\Omega}\delta(F(\boldsymbol{r})-f)\,d\boldsymbol{r}
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="Multicanonical_ensemble:48">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <msub>
       <mi>f</mi>
       <mi>max</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>f</mi>
       <mi>min</mi>
      </msub>
     </mrow>
    </mfrac>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">âˆ«</mo>
      <mi mathvariant="normal">Î©</mi>
     </msub>
     <mrow>
      <mi>Î´</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>f</mi>
        <mo>-</mo>
        <mrow>
         <mi>F</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>ğ’“</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ğ’“</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>ğ’“</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <msub>
       <mi>f</mi>
       <mi>max</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>f</mi>
       <mi>min</mi>
      </msub>
     </mrow>
    </mfrac>
    <mfrac>
     <mn>1</mn>
     <mi>V</mi>
    </mfrac>
    <mi>Ï</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">âˆ«</mo>
      <mi mathvariant="normal">Î©</mi>
     </msub>
     <mrow>
      <mi>Î´</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>f</mi>
        <mo>-</mo>
        <mrow>
         <mi>F</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>ğ’“</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>ğ’“</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>max</mi>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>f</mi>
      <mi>min</mi>
     </msub>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mtext>constant</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <max></max>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <min></min>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <ci>normal-Î©</ci>
       </apply>
       <apply>
        <times></times>
        <ci>Î´</ci>
        <apply>
         <minus></minus>
         <ci>f</ci>
         <apply>
          <times></times>
          <ci>F</ci>
          <ci>ğ’“</ci>
         </apply>
        </apply>
        <ci>P</ci>
        <ci>ğ’“</ci>
        <ci>d</ci>
        <ci>ğ’“</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <max></max>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <min></min>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>V</ci>
      </apply>
      <ci>Ï</ci>
      <ci>f</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <ci>normal-Î©</ci>
       </apply>
       <apply>
        <times></times>
        <ci>Î´</ci>
        <apply>
         <minus></minus>
         <ci>f</ci>
         <apply>
          <times></times>
          <ci>F</ci>
          <ci>ğ’“</ci>
         </apply>
        </apply>
        <ci>d</ci>
        <ci>ğ’“</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <max></max>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <min></min>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <mtext>constant</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(f)=\frac{1}{f_{\max}-f_{\min}}\int_{\Omega}\delta(f-F(\boldsymbol{r}))P(%
\boldsymbol{r})\,d\boldsymbol{r}=\frac{1}{f_{\max}-f_{\min}}\frac{1}{V}\rho(f)%
\int_{\Omega}\delta(f-F(\boldsymbol{r}))\,d\boldsymbol{r}=\frac{1}{f_{\max}-f_%
{\min}}=\text{constant}
  </annotation>
 </semantics>
</math>

</p>

<p>is the density of states of the system with respect to the cost function (<em>V</em> is the phase-space volume). The consequence of this choice is that the probability to sample a state and it has cost function <em>f</em> is</p>

<p>

<math display="inline" id="Multicanonical_ensemble:49">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ğ’“</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>ğ’“</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\boldsymbol{r})
  </annotation>
 </semantics>
</math>

</p>

<p>which motivates the name "flat histogram". I.e. all costs are equally sampled, and thus there are no barriers. For systems in contact with a heat bath, there is another important advantage: because the sampling is independent of the temperature, one simulation is enough to study all temperatures (thus the name "multicanonic": several temperatures).</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>{{show</p></td>
<td style="text-align: left;">
<p>example:</p></td>
<td style="text-align: left;">
<p>On the ferromagnetic <a href="Ising_model" title="wikilink">Ising model</a> with <em>N</em> sites (exemplified on previous section), the density of states can be analytically computed. In this case, a multicanonic ensemble can be used to compute any other quantity <em>Q</em> by sampling the system according to 

<math display="inline" id="Multicanonical_ensemble:50">
 <semantics>
  <mover accent="true">
   <mi>Q</mi>
   <mo>Â¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-Â¯</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{Q}
  </annotation>
 </semantics>
</math>

 and using the proper estimator 

<math display="inline" id="Multicanonical_ensemble:51">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ğ’“</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>ğ’“</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\boldsymbol{r})
  </annotation>
 </semantics>
</math>

 defined on the previous section. }}</p></td>
</tr>
</tbody>
</table>
<h2 id="tunneling-time-and-critical-slowing-down">Tunneling time and critical slowing down</h2>

<p>Like in any other Monte Carlo method, there are correlations of the samples being drawn from 

<math display="block" id="Multicanonical_ensemble:52">
 <semantics>
  <mrow>
   <msub>
    <mi>Ï„</mi>
    <mrow>
     <mi>t</mi>
     <mi>t</mi>
    </mrow>
   </msub>
   <mo>âˆ</mo>
   <msup>
    <mi>N</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proportional-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Ï„</ci>
     <apply>
      <times></times>
      <ci>t</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>N</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau_{tt}\propto N^{2}
  </annotation>
 </semantics>
</math>

. A typical measurement of the correlation is the <em>tunneling time</em>. The tunneling time is defined by the number of Markov steps (of the Markov chain) the simulation needs to perform a round-trip between the minimum and maximum of the spectrum of <em>F</em>. One motivation to use the tunneling time is that when it crosses the spectra, it passes through the region of the maximum of the density of states, thus de-correlating the process. On the other hand using round-trips ensures that the system visits all the spectrum.</p>

<p>Because the histogram is flat on the variable <em>F</em>, a multicanonic ensemble can be seen as a diffusion process (i.e. a random walk) on the one-dimensional line of <em>F</em> values. <a href="Detailed_balance" title="wikilink">Detailed balance</a> of the process dictates that there is no <a href="stochastic_drift" title="wikilink">drift</a> on the process.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> This implies that the tunneling time, in local dynamics, should scale as a diffusion process, and thus the tunneling time should scale quadratically with the size of the spectrum, <em>N</em>:</p>

<p>

<math display="inline" id="Multicanonical_ensemble:53">
 <semantics>
  <msup>
   <mi>N</mi>
   <mrow>
    <mn>2</mn>
    <mo>+</mo>
    <mi>z</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>N</ci>
    <apply>
     <plus></plus>
     <cn type="integer">2</cn>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N^{2+z}
  </annotation>
 </semantics>
</math>

</p>

<p>However, in some systems (the Ising model being the most paradigmatic), the scaling suffers from critical slowing down: it is 

<math display="inline" id="Multicanonical_ensemble:54">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>z</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z>0
  </annotation>
 </semantics>
</math>

 where <span class="LaTeX">$z&gt;0$</span> depends on the particular system.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>Non-local dynamics were developed to improve the scaling to a quadratic scaling<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> (see <a href="wolff_algorithm" title="wikilink">wolff algorithm</a>), beating the critical slowing down. However, it is still an open question whether there is a local dynamics that does not suffer from critical slowing down in spin systems like Ising model.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Monte_Carlo_methods" title="wikilink">Category:Monte Carlo methods</a> <a href="Category:Statistical_algorithms" title="wikilink">Category:Statistical algorithms</a> <a href="Category:Computational_physics" title="wikilink">Category:Computational physics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"></li>
</ol>
</section>
</body>
</html>
