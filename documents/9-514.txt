   Multidelay block frequency domain adaptive filter      Multidelay block frequency domain adaptive filter   The Multidelay block frequency domain adaptive filter (MDF) algorithm is a block-based frequency domain implementation of the (normalised) Least mean squares filter (LMS) algorithm.  Introduction  The MDF algorithm is based on the fact that convolutions may be efficiently computed in the frequency domain (thanks to the Fast Fourier Transform ). However, the algorithm differs from the Fast LMS algorithm in that block size it uses may be smaller than the filter length. If both are equal, then MDF reduces to the FLMS algorithm.  The advantages of MDF over the (N)LMS algorithm are:   Lower algorithmic complexity  Partial de-correlation of the input (which 'may' lead to faster convergence)   Variable definitions  (Figure)  LMS filter   Let   N   N   N   be the length of the processing blocks,   K   K   K   be the number of blocks and   ğ…   ğ…   \mathbf{F}   denote the 2Nx2N Fourier transform matrix. The variables are defined as:        ğ  Â¯    (  â„“  )    =   ğ…    [   ğŸ   1  x  N    ,   e   (   â„“  N   )    ,  â€¦  ,   e   (    â„“  N   -  N  -  1   )    ]   T           normal-Â¯  ğ   normal-â„“     ğ…   superscript    subscript  0    1  x  N      e    normal-â„“  N    normal-â€¦    e      normal-â„“  N   N  1     T      \underline{\mathbf{e}}(\ell)=\mathbf{F}\left[\mathbf{0}_{1xN},e(\ell N),\dots,%
 e(\ell N-N-1)\right]^{T}            ğ±  Â¯   k    (  â„“  )    =   diag   {   ğ…    [   x   (    (    â„“  -  k   +  1   )   N   )    ,  â€¦  ,   x   (     (   â„“  -  k  -  1   )   N   -  1   )    ]   T    }           subscript   normal-Â¯  ğ±   k   normal-â„“     diag     ğ…   superscript     x        normal-â„“  k   1   N    normal-â€¦    x        normal-â„“  k  1   N   1     T        \underline{\mathbf{x}}_{k}(\ell)=\mathrm{diag}\left\{\mathbf{F}\left[x((\ell-k%
 +1)N),\dots,x((\ell-k-1)N-1)\right]^{T}\right\}           ğ—  Â¯    (  â„“  )    =   [     ğ±  Â¯   0    (  â„“  )    ,     ğ±  Â¯   1    (  â„“  )    ,  â€¦  ,     ğ±  Â¯    K  -  1     (  â„“  )    ]          normal-Â¯  ğ—   normal-â„“       subscript   normal-Â¯  ğ±   0   normal-â„“      subscript   normal-Â¯  ğ±   1   normal-â„“   normal-â€¦     subscript   normal-Â¯  ğ±     K  1    normal-â„“      \underline{\mathbf{X}}(\ell)=\left[\underline{\mathbf{x}}_{0}(\ell),\underline%
 {\mathbf{x}}_{1}(\ell),\dots,\underline{\mathbf{x}}_{K-1}(\ell)\right]           ğ  Â¯    (  â„“  )    =   ğ…    [   ğŸ   1  x  N    ,   d   (   â„“  N   )    ,  â€¦  ,   d   (    â„“  N   -  N  -  1   )    ]   T           normal-Â¯  ğ   normal-â„“     ğ…   superscript    subscript  0    1  x  N      d    normal-â„“  N    normal-â€¦    d      normal-â„“  N   N  1     T      \underline{\mathbf{d}}(\ell)=\mathbf{F}\left[\mathbf{0}_{1xN},d(\ell N),\dots,%
 d(\ell N-N-1)\right]^{T}   With normalisation matrices    ğ†  1     subscript  ğ†  1    \mathbf{G}_{1}   and    ğ†  2     subscript  ğ†  2    \mathbf{G}_{2}   :       ğ†  1   =   ğ…   [      ğŸ   N  x  N       ğŸ   N  x  N         ğŸ   N  x  N       ğˆ   N  x  N       ]    ğ…   -  1          subscript  ğ†  1     ğ…     subscript  0    N  x  N     subscript  0    N  x  N       subscript  0    N  x  N     subscript  ğˆ    N  x  N       superscript  ğ…    1       \mathbf{G}_{1}=\mathbf{F}\begin{bmatrix}\mathbf{0}_{NxN}&\mathbf{0}_{NxN}\\
 \mathbf{0}_{NxN}&\mathbf{I}_{NxN}\\
 \end{bmatrix}\mathbf{F}^{-1}           ğ†  ~   2   =   ğ…   [      ğˆ   N  x  N       ğŸ   N  x  N         ğŸ   N  x  N       ğŸ   N  x  N       ]    ğ…   -  1          subscript   normal-~  ğ†   2     ğ…     subscript  ğˆ    N  x  N     subscript  0    N  x  N       subscript  0    N  x  N     subscript  0    N  x  N       superscript  ğ…    1       \tilde{\mathbf{G}}_{2}=\mathbf{F}\begin{bmatrix}\mathbf{I}_{NxN}&\mathbf{0}_{%
 NxN}\\
 \mathbf{0}_{NxN}&\mathbf{0}_{NxN}\\
 \end{bmatrix}\mathbf{F}^{-1}          ğ†  2   =   diag   {    ğ†  ~   2   ,    ğ†  ~   2   ,  â€¦  ,    ğ†  ~   2   }         subscript  ğ†  2     diag    subscript   normal-~  ğ†   2    subscript   normal-~  ğ†   2   normal-â€¦   subscript   normal-~  ğ†   2       \mathbf{G}_{2}=\mathrm{diag}\left\{\tilde{\mathbf{G}}_{2},\tilde{\mathbf{G}}_{%
 2},\dots,\tilde{\mathbf{G}}_{2}\right\}     In practice, when multiplying a column vector   ğ±   ğ±   \mathbf{x}   by    ğ†  1     subscript  ğ†  1    \mathbf{G}_{1}   , we take the inverse FFT of   ğ±   ğ±   \mathbf{x}   , set the first   N   N   N   values in the result to zero and then take the FFT. This is meant to remove the effects of the circular convolution.  Algorithm description  For each block, the MDF algorithm is computed as:        ğ²  Â¯  ^    (  â„“  )    =    ğ†  1    ğ—  Â¯    (  â„“  )    ğ¡  Â¯  ^    (   â„“  -  1   )           normal-Â¯   normal-^  ğ²    normal-â„“      subscript  ğ†  1    normal-Â¯  ğ—   normal-â„“   normal-Â¯   normal-^  ğ¡      normal-â„“  1      \underline{\hat{\mathbf{y}}}(\ell)=\mathbf{G}_{1}\underline{\mathbf{X}}(\ell)%
 \underline{\hat{\mathbf{h}}}(\ell-1)           ğ  Â¯    (  â„“  )    =     ğ  Â¯    (  â„“  )    -    ğ²  Â¯  ^    (  â„“  )            normal-Â¯  ğ   normal-â„“        normal-Â¯  ğ   normal-â„“      normal-Â¯   normal-^  ğ²    normal-â„“      \underline{\mathbf{e}}(\ell)=\underline{\mathbf{d}}(\ell)-\underline{\hat{%
 \mathbf{y}}}(\ell)          ğš½  ğ±ğ±   =    ğ—  Â¯    (  â„“  )    ğ—  Â¯     (  â„“  )   H         subscript  ğš½  ğ±ğ±      normal-Â¯  ğ—   normal-â„“   normal-Â¯  ğ—    superscript  normal-â„“  H      \mathbf{\Phi}_{\mathbf{xx}}=\underline{\mathbf{X}}(\ell)\underline{\mathbf{X}}%
 (\ell)^{H}           ğ¡  Â¯  ^    (  â„“  )    =     ğ¡  Â¯  ^    (   â„“  -  1   )    +   Î¼   ğ†  2    ğš½  ğ±ğ±   -  1     (  â„“  )     ğ—  Â¯   H    (  â„“  )    ğ  Â¯    (  â„“  )            normal-Â¯   normal-^  ğ¡    normal-â„“        normal-Â¯   normal-^  ğ¡      normal-â„“  1      Î¼   subscript  ğ†  2    superscript   subscript  ğš½  ğ±ğ±     1    normal-â„“   superscript   normal-Â¯  ğ—   H   normal-â„“   normal-Â¯  ğ   normal-â„“      \underline{\hat{\mathbf{h}}}(\ell)=\underline{\hat{\mathbf{h}}}(\ell-1)+\mu%
 \mathbf{G}_{2}\mathbf{\Phi}_{\mathbf{xx}}^{-1}(\ell)\underline{\mathbf{X}}^{H}%
 (\ell)\underline{\mathbf{e}}(\ell)     It is worth noting that, while the algorithm is more easily expressed in matrix form, the actual implementation requires no matrix multiplications. For instance the normalisation matrix computation     ğš½  ğ±ğ±   =    ğ—  Â¯    (  â„“  )    ğ—  Â¯     (  â„“  )   H         subscript  ğš½  ğ±ğ±      normal-Â¯  ğ—   normal-â„“   normal-Â¯  ğ—    superscript  normal-â„“  H      \mathbf{\Phi}_{\mathbf{xx}}=\underline{\mathbf{X}}(\ell)\underline{\mathbf{X}}%
 (\ell)^{H}   reduces to an element-wise vector multiplication because     ğ—  Â¯    (  â„“  )        normal-Â¯  ğ—   normal-â„“    \underline{\mathbf{X}}(\ell)   is block-diagonal. The same goes for other multiplications.  References   J.-S. Soo and K. Pang, â€œMultidelay block frequency domain adaptive filter,â€ IEEE Transactions on Acoustics, Speech and Signal Processing , vol. 38, no. 2, pp.Â 373â€“376, 1990.  H. Buchner, J. Benesty, W. Kellermann, "An Extended Multidelay Filter: Fast Low-Delay Algorithms for Very High-Order Adaptive Systems". Proc. IEEE International Conference on Acoustics, Speech, and Signal Processing (ICASSP) , 2003.  A free implementation of the MDF algorithm is available in Speex ( main source file )   See also   Adaptive filter  Recursive least squares  For statistical techniques relevant to LMS filter see Least squares .   "  Category:Digital signal processing  Category:Filter theory   