<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="562">Hilbert curve</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Hilbert curve</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p> A <strong>Hilbert curve</strong> (also known as a <strong>Hilbert space-filling curve</strong>) is a <a href="Geometric_continuity" title="wikilink">continuous</a> <a class="uri" href="fractal" title="wikilink">fractal</a> <a href="space-filling_curve" title="wikilink">space-filling curve</a> first described by the German mathematician <a href="David_Hilbert" title="wikilink">David Hilbert</a> in 1891,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> as a variant of the space-filling <a href="Peano_curve" title="wikilink">Peano curves</a> discovered by <a href="Giuseppe_Peano" title="wikilink">Giuseppe Peano</a> in 1890.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Because it is space-filling, its <a href="Hausdorff_dimension" title="wikilink">Hausdorff dimension</a> is 

<math display="inline" id="Hilbert_curve:0">
 <semantics>
  <mn>2</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">2</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2
  </annotation>
 </semantics>
</math>

 (precisely, its image is the unit square, whose dimension is 2 in any definition of dimension; its graph is a compact set homeomorphic to the closed unit interval, with Hausdorff dimension 2).</p>

<p>

<math display="inline" id="Hilbert_curve:1">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{n}
  </annotation>
 </semantics>
</math>

 is the 

<math display="inline" id="Hilbert_curve:2">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

th approximation to the limiting curve. The <a href="euclidean_distance" title="wikilink">Euclidean length</a> of 

<math display="inline" id="Hilbert_curve:3">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{n}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Hilbert_curve:4">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>n</mi>
   </msup>
   <mo>-</mo>
   <mfrac>
    <mn>1</mn>
    <msup>
     <mn>2</mn>
     <mi>n</mi>
    </msup>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle 2^{n}-{1\over 2^{n}}
  </annotation>
 </semantics>
</math>

, i.e., it grows exponentially with 

<math display="inline" id="Hilbert_curve:5">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, while at the same time always being bounded by a square with a finite area.</p>
<h2 id="images">Images</h2>

<p>Image:Hilbert_curve_1.svg|Hilbert curve, first order Image:Hilbert_curve_2.svg|Hilbert curves, first and second orders Image:Hilbert_curve_3.svg|Hilbert curves, first to third orders <a class="uri" href="File:HilbertCurveString.JPG|String">File:HilbertCurveString.JPG|String</a> art Image:Hilbert.png|Hilbert curve, construction color-coded</p>

<p>Image:Hilbert512.gif|A Hilbert curve in three dimensions Image:Hilbert3d-step3.png|A 3-D Hilbert curve with color showing progression Image:Hilbert Curve Animation.gif|This GIF file displays an animation of circles traveling along the path of a Hilbert Space filling Curve.</p>
<h2 id="applications-and-mapping-algorithms">Applications and mapping algorithms</h2>

<p>Both the true Hilbert curve and its discrete approximations are useful because they give a mapping between 1D and 2D space that fairly well preserves locality.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> If (<em>x</em>,<em>y</em>) are the coordinates of a point within the unit square, and <em>d</em> is the distance along the curve when it reaches that point, then points that have nearby <em>d</em> values will also have nearby (<em>x</em>,<em>y</em>) values. The converse can't always be true. There will sometimes be points where the (<em>x</em>,<em>y</em>) coordinates are close but their <em>d</em> values are far apart.</p>

<p>Because of this locality property, the Hilbert curve is widely used in computer science. For example, the range of <a href="IP_address" title="wikilink">IP addresses</a> used by computers can be mapped into a picture using the Hilbert curve. Code to generate the image would map from 2D to 1D to find the color of each pixel, and the Hilbert curve is sometimes used because it keeps nearby IP addresses close to each other in the picture. A <a class="uri" href="grayscale" title="wikilink">grayscale</a> photograph can be converted to a <a href="dithering" title="wikilink">dithered</a> black and white image using thresholding, with the leftover amount from each pixel added to the next pixel along the Hilbert curve. Code to do this would map from 1D to 2D, and the Hilbert curve is sometimes used because it does not create the distracting patterns that would be visible to the eye if the order were simply left to right across each row of pixels. Hilbert curves in higher dimensions are an instance of a generalization of <a href="Gray_code" title="wikilink">Gray codes</a>, and are sometimes used for similar purposes, for similar reasons. For multidimensional databases, Hilbert order has been proposed to be used instead of <a href="z-order_(curve)" title="wikilink">Z order</a> because it has better locality-preserving behavior. For example, Hilbert curves have been used to compress and accelerate <a class="uri" href="R-tree" title="wikilink">R-tree</a> indexes<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> (see <a href="Hilbert_R-tree" title="wikilink">Hilbert R-tree</a>). They have also been used to help compress data warehouses.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Given the variety of applications, it is useful to have algorithms to map in both directions. In many languages, these are better if implemented with iteration rather than recursion. The following <a href="C_(programming_language)" title="wikilink">C</a> code performs the mappings in both directions, using iteration and bit operations rather than recursion. It assumes a square divided into <em>n</em> by <em>n</em> cells, for <em>n</em> a power of 2, with integer coordinates, with (0,0) in the lower left corner, (<em>n</em>-1,<em>n</em>-1) in the upper right corner, and a distance <em>d</em> that starts at 0 in the lower left corner and goes to 

<math display="inline" id="Hilbert_curve:6">
 <semantics>
  <mrow>
   <msup>
    <mi>n</mi>
    <mn>2</mn>
   </msup>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{2}-1
  </annotation>
 </semantics>
</math>

 in the lower-right corner.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//convert (x,y) to d</span>
<span class="dt">int</span> xy2d (<span class="dt">int</span> n, <span class="dt">int</span> x, <span class="dt">int</span> y) {
    <span class="dt">int</span> rx, ry, s, d=<span class="dv">0</span>;
    <span class="kw">for</span> (s=n/<span class="dv">2</span>; s&gt;<span class="dv">0</span>; s/=<span class="dv">2</span>) {
        rx = (x &amp; s) &gt; <span class="dv">0</span>;
        ry = (y &amp; s) &gt; <span class="dv">0</span>;
        d += s * s * ((<span class="dv">3</span> * rx) ^ ry);
        rot(s, &amp;x;, &amp;y;, rx, ry);
    }
    <span class="kw">return</span> d;
}

<span class="co">//convert d to (x,y)</span>
<span class="dt">void</span> d2xy(<span class="dt">int</span> n, <span class="dt">int</span> d, <span class="dt">int</span> *x, <span class="dt">int</span> *y) {
    <span class="dt">int</span> rx, ry, s, t=d;
    *x = *y = <span class="dv">0</span>;
    <span class="kw">for</span> (s=<span class="dv">1</span>; s<n; &="&lt;span" class="st">""</n;></code></pre></div></body> (rx=<span class="st">"1)"</span> (ry=<span class="st">"0)"</span> (t=<span class="st">""</span> *=<span class="st">""</span> *x=<span class="st">"*y;"</span> *x,=<span class="st">""</span> *x;=<span class="st">""</span> *y=<span class="st">"t;"</span> *y,=<span class="st">""</span> *y;=<span class="st">""</span> +=<span class="st">"s"</span> -=<span class="st">""</span> <span class="dv">2</span>);=<span class="st">""</span> <span class="dv">4</span>;=<span class="st">""</span> ==<span class="st">""</span> ^=<span class="st">""</span> a=<span class="st">""</span> and=<span class="st">""</span> appropriately=<span class="st">""</span> flip=<span class="st">""</span> <span class="kw">if</span>=<span class="st">""</span> <span class="dt">int</span>=<span class="st">""</span> n,=<span class="st">""</span> quadrant=<span class="st">""</span> rot(<span class="dt">int</span>=<span class="st">""</span> rot(s,=<span class="st">""</span> rotate=<span class="st">""</span> rx=<span class="st">"1"</span> rx);=<span class="st">""</span> rx,=<span class="st">""</span> rx;=<span class="st">""</span> ry=<span class="st">"1"</span> ry)=<span class="st">""</span> ry);=<span class="st">""</span> ry;=<span class="st">""</span> s*=<span class="st">"2)"</span> source=<span class="st">""</span> swap=<span class="st">""</span> t=<span class="st">"*x;"</span> <span class="dt">void</span>=<span class="st">""</span> x=<span class="st">""</span> x,=<span class="st">""</span> y=<span class="st">""</span> y,=<span class="st">""</span> {=<span class="st">""</span> }=<span class="st">""</span> }&lt;=<span class="st">""</span>&gt;

These use the C conventions: the &amp; symbol is a bitwise AND, the ^ symbol is a bitwise XOR, the += operator adds onto a variable, and the /= operator divides a variable.  The handling of booleans in C means that in xy2d, the variable ''rx'' is set to <span class="dv">0</span> or <span class="dv">1</span> to match bit ''s'' of ''x'', and similarly <span class="kw">for</span> ''ry''.

The xy2d function works top down, starting with the most significant bits of ''x'' and ''y'', and building up the most significant bits of ''d'' first.  The d2xy function works in the opposite order, starting with the least significant bits of ''d'', and building up ''x'' and ''y'' starting with the least significant bits.  Both functions use the rotation function to rotate and flip the (''x'',''y'') coordinate system appropriately.

The two mapping algorithms work in similar ways.  The entire square is viewed as composed of <span class="dv">4</span> regions, arranged <span class="dv">2</span> by <span class="dv">2</span>.  Each region is composed of <span class="dv">4</span> smaller regions, and so on, <span class="kw">for</span> a number of levels.  At level ''s'', each region is ''s'' by ''s'' cells.  There is a single FOR loop that iterates through levels.  On each iteration, an amount is added to ''d'' or to ''x'' and ''y'', determined by which of the <span class="dv">4</span> regions it is in at the current level.  The current region out of the <span class="dv">4</span> is (''rx'',''ry''), where ''rx'' and ''ry'' are each <span class="dv">0</span> or <span class="dv">1</span>.  So it consumes <span class="dv">2</span> input bits, (either <span class="dv">2</span> from ''d'' or <span class="dv">1</span> each from ''x'' and ''y''), and generates two output bits.  It also calls the rotation function so that (''x'',''y'') will be appropriate <span class="kw">for</span> the next level, on the next iteration.  For xy2d, it starts at the top level of the entire square, and works its way down to the lowest level of individual cells.  For d2xy, it starts at the bottom with cells, and works up to include the entire square.

It is possible to implement Hilbert curves efficiently even when the data space does not form a square.<ref>C. H. Hamilton, A. Rau-Chaplin, Compact Hilbert indices: Space-filling curves <span class="kw">for</span> domains with unequal side lengths, Information Processing Letters <span class="dv">105</span> (<span class="dv">5</span>) (<span class="dv">2007</span>) <span class="dv">155</span>–<span class="dv">163</span>.</ref> Moreover there are several possible generalizations of Hilbert curves to higher dimensions.<ref>J. Alber, R. Niedermeier, On multidimensional curves with Hilbert property, Theory of Computing Systems <span class="dv">33</span> (<span class="dv">4</span>) (<span class="dv">2000</span>) <span class="dv">295</span>–<span class="dv">312</span>.</ref><ref>H. J. Haverkort, F. van Walderveen, Four-dimensional Hilbert curves <span class="kw">for</span> R-trees, in: Proceedings of the Eleventh Workshop on Algorithm Engineering and Experiments, <span class="dv">2009</span>, pp. <span class="dv">63</span>–<span class="dv">73</span>.</ref>

==Representation as Lindenmayer system==
The Hilbert Curve can be expressed by a [[rewriting|rewrite system]] ([[L-system]]). 
[[File:Hilbert Curve - <span class="fl">6.</span>webm|thumb|Hilbert Curve at its sixth iteration]]

:'''Alphabet''' :   A, B
:'''Constants''' :   F + −
:'''Axiom''' :   A
:'''Production rules''':
:: A → − B F + A F A + F B −
:: B → + A F − B F B − F A +

Here, <span class="st">"F"</span> means <span class="st">"draw forward"</span>, <span class="st">"−"</span> means <span class="st">"turn left 90°"</span>, <span class="st">"+"</span> means <span class="st">"turn right 90°"</span> (see [[turtle graphics]]), and <span class="st">"A"</span> and <span class="st">"B"</span> are ignored during drawing.

== Other implementations ==

[[Arthur Butz]]<ref>{{cite journal |author=A.R. Butz 
|title=Alternative algorithm <span class="kw">for</span> Hilbert’s space filling curve. |journal=IEEE Trans. On Computers, |volume=<span class="dv">20</span> |pages=<span class="dv">424</span>–<span class="dv">42</span> |date=April <span class="dv">1971</span> |doi=<span class="fl">10.1109</span>/T-C<span class="fl">.1971.223258</span>}}</ref> provided an algorithm <span class="kw">for</span> calculating the Hilbert curve in multidimensions.

Graphics Gems II<ref>Voorhies, Douglas: Space-Filling Curves and a Measure of Coherence, p. <span class="dv">26-30</span>, Graphics Gems II.</ref> discusses Hilbert Curve coherency, and provides implementation.

== See also ==
{{Commons|Hilbert curve}}
* [[Hilbert curve scheduling]]
* [[Hilbert R-tree]]
* [[Sierpiński curve]]
* [[Moore curve]]
* [[Space-filling curves]]
* [[List of fractals by Hausdorff dimension]]

== Notes ==
<references></references>

==External links==
* [http:<span class="co">//jsxgraph.uni-bayreuth.de/wiki/index.php/Hilbert_curve Dynamic Hilbert curve with JSXGraph]</span>
* [http:<span class="co">//threejs.org/examples/webgl_lines_colors.html Three.js WebGL 3D Hilbert curve demo]</span>
* [http:<span class="co">//xkcd.com/195/ XKCD cartoon using the locality properties of the Hilbert curve to create a "map of the internet"]</span>
* [http:<span class="co">//www.andyshelley.co.uk/axishilbert/index.php Gcode generator for Hilbert curve]</span>

[[Category:Fractal curves]]
[[Category:Articles containing video clips]]<span class="st">"</span>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">D. Hilbert: [<a class="uri" href="http://www.digizeitschriften.de/dms/img/?PPN=PPN235181684_0038&amp;DMDID">http://www.digizeitschriften.de/dms/img/?PPN=PPN235181684_0038&amp;DMDID;</a>;=dmdlog40 Über die stetige Abbildung einer Linie auf ein Flächenstück.] <a href="Mathematische_Annalen" title="wikilink">Mathematische Annalen</a> 38 (1891), 459–460.<a href="#fnref1">↩</a></li>
<li id="fn2">G.Peano: [<a class="uri" href="http://www.digizeitschriften.de/dms/img/?PPN=PPN235181684_0036&amp;DMDID">http://www.digizeitschriften.de/dms/img/?PPN=PPN235181684_0036&amp;DMDID;</a>;=dmdlog13 Sur une courbe, qui remplit toute une aire plane.] <a href="Mathematische_Annalen" title="wikilink">Mathematische Annalen</a> 36 (1890), 157–160.<a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
<li id="fn4">I. Kamel, C. Faloutsos, Hilbert R-tree: An improved R-tree using fractals, in: Proceedings of the 20th International Conference on Very Large Data Bases, Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 1994, pp. 500–509.<a href="#fnref4">↩</a></li>
<li id="fn5">T. Eavis, D. Cueva, A Hilbert space compression architecture for data warehouse environments, Lecture Notes in Computer Science 4654 (2007) 1–12.<a href="#fnref5">↩</a></li>
<li id="fn6">Daniel Lemire and Owen Kaser, <a href="http://arxiv.org/abs/0909.1346">Reordering Columns for Smaller Indexes</a>, Information Sciences 181 (12), 2011.<a href="#fnref6">↩</a></li>
</ol>
</section>


