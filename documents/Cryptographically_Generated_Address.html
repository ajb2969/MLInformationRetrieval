<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1595">Cryptographically Generated Address</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Cryptographically Generated Address</h1>
<hr/>

<p>A <strong>Cryptographically Generated Address</strong> (<strong>CGA</strong>) is an <a href="IPv6" title="wikilink">Internet Protocol Version 6</a> (IPv6) address that has a host identifier computed from a <a href="cryptographic_hash_function" title="wikilink">cryptographic hash function</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> This procedure is a method for binding a <a href="Public_key" title="wikilink">public signature key</a> to an <a href="IPv6_address" title="wikilink">IPv6 address</a> in the <a href="Secure_Neighbor_Discovery_Protocol" title="wikilink">Secure Neighbor Discovery Protocol</a> (SEND).<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="methodology">Methodology</h2>

<p>A Cryptographically Generated Address is formed by replacing the least-significant 64 bits of the 128-bit IPv6 address with the cryptographic hash of the public key of the address owner. The messages are signed with the corresponding private key. Only if the source address and the public key are known can the verifier authenticate the message from that corresponding sender. This method requires no <a href="public_key_infrastructure" title="wikilink">public key infrastructure</a>. Valid CGAs may be generated by any sender, including a potential attacker, but they cannot use any existing CGAs.</p>
<h2 id="characteristics">Characteristics</h2>

<p>A Cryptographically Generated Address is an IPv6 address whose interface identifier has been generated according to the CGA generation method. The interface identifier is formed by the least-significant 64 bits of an IPv6 address and is used to identify the host's network interface on its subnet. The subnet is determined by the most-significant 64 bits, the subnet prefix.</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>IPv6 address format</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>bits</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>field</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>Apart from the public key that is to be bound to the CGA, the CGA generation method takes several other input parameters including the predefined subnet prefix. These parameters, along with other parameters that are generated during the execution of the CGA generation method, form a set of parameters called the CGA Parameters data structure. The complete set of CGA Parameters has to be known in order to be able to verify the corresponding CGA.</p>

<p>The CGA Parameters data structure consists of:</p>
<ul>
<li><code>''modifier''</code>: a random 128-bit <a href="Signedness" title="wikilink">unsigned</a> integer;</li>
<li><code>''subnetPrefix''</code>: the 64-bit prefix that defines to which subnet the CGA belongs;</li>
<li><code>''collCount''</code>: an 8-bit unsigned integer that must be 0, 1, or 2;</li>
<li><code>''publicKey''</code>: the public key as a <a href="X.690" title="wikilink">DER</a>-encoded <a href="Abstract_Syntax_Notation_One" title="wikilink">ASN.1</a> structure of the type SubjectPublicKeyInfo;</li>
<li><code>''extFields''</code>: an optional variable-length field (default length 0).</li>
</ul>

<p>Additionally, a security parameter <code>''Sec''</code> determines the CGA's strength against <a href="brute-force_attack" title="wikilink">brute-force attacks</a>. This is a 3-bit unsigned integer that can have any value from 0 up to (and including) 7 and is encoded in the three leftmost bits of the CGA's interface identifier. The higher the value of <code>''Sec''</code>, the higher the level of security, but also the longer it generally takes to generate a CGA. For convenience, the intermediate <code>''Sec''</code> values in the pseudocode below are assumed to be stored as 8-bit unsigned integers that cannot have a value greater than 7.</p>
<h2 id="cga-generation-method">CGA generation method</h2>

<p>The following piece of pseudocode represents the CGA generation method, which is used to create a new Cryptographically Generated Address.</p>

<p><code> 1  </code><strong><code>procedure</code></strong><code> generateCGA(</code><em><code>Sec</code></em><code>, </code><em><code>subnetPrefix</code></em><code>, </code><em><code>publicKey</code></em><code>, </code><em><code>extFields</code></em><code>):</code><br/>
<code> 2      </code><em><code>modifier</code></em><code> := random(0x00000000000000000000000000000000,     // 16 octets (128 bits)</code><br/>
<code> 3                         0xffffffffffffffffffffffffffffffff)</code><br/>
<code> 4</code><br/>
<code> 5  </code><u><code>label1</code></u><code>:</code><br/>
<code> 6      </code><em><code>concat</code></em><code> := concatenate(</code><em><code>modifier</code></em><code>, 0x000000000000000000,      // 9 zero octets</code><br/>
<code> 7                            </code><em><code>publicKey</code></em><code>, </code><em><code>extFields</code></em><code>)</code><br/>
<code> 8</code><br/>
<code> 9      </code><em><code>digest</code></em><code> := SHA1(</code><em><code>concat</code></em><code>)</code><br/>
<code>10      </code><em><code>Hash2</code></em><code> := </code><em><code>digest</code></em><code>[0:14]                                      // 14*8 = 112 leftmost bits</code><br/>
<code>11</code><br/>
<code>12      </code><strong><code>if</code></strong><code> </code><em><code>Sec</code></em><code> ≠ 0 </code><strong><code>and</code></strong><code> </code><em><code>Hash2</code></em><code>[0:2*</code><em><code>Sec</code></em><code>] ≠ 0:                         // 2*Sec*8 = 16*Sec leftmost bits</code><br/>
<code>13          </code><em><code>modifier</code></em><code> := </code><em><code>modifier</code></em><code> + 1</code><br/>
<code>14          </code><strong><code>goto</code></strong><code> label1</code><br/>
<code>15      </code><strong><code>end</code> <code>if</code></strong><br/>
<code>16</code><br/>
<code>17      </code><em><code>collCount</code></em><code> := 0x00                                          // 8-bit collision count</code><br/>
<code>18</code><br/>
<code>19  </code><u><code>label2</code></u><code>:</code><br/>
<code>20      </code><em><code>concat</code></em><code> := concatenate(</code><em><code>modifier</code></em><code>, </code><em><code>subnetPrefix</code></em><code>, </code><em><code>collCount</code></em><code>,</code><br/>
<code>21                            </code><em><code>publicKey</code></em><code>, </code><em><code>extFields</code></em><code>)</code><br/>
<code>22</code><br/>
<code>23      </code><em><code>digest</code></em><code> := SHA1(</code><em><code>concat</code></em><code>)</code><br/>
<code>24      </code><em><code>Hash1</code></em><code> := </code><em><code>digest</code></em><code>[0:8]                                       // 8*8 = 64 leftmost bits</code><br/>
<code>25</code><br/>
<code>26      </code><em><code>intID</code></em><code> := </code><em><code>Hash1</code></em><code>                                             // Hash1 becomes interface identifier...</code><br/>
<code>27      </code><em><code>intID</code></em><code>[0] := </code><em><code>intID</code></em><code>[0] </code><strong><code>binary</code> <code>and</code></strong><code> 0x1c </code><strong><code>binary</code> <code>or</code></strong><code> (</code><em><code>Sec</code></em><code> </code><em><code>Hash1</code></em><code>, which is taken from the first 64 bits of the digested CGA Parameters data structure (lines 20 to 24). On line 27, the first three bits are overwritten by the </code><code>''Sec''</code><code> value and the reserved "u" and "g" bits (the seventh and eighth bit) are set to 0.</code></p>

<p>The <code>''Sec''</code> parameter implements a hash extension by enforcing the first 16 times <code>''Sec''</code> bits of another hash, <code>''Hash2''</code>, to be 0. This hash is the result of the digested CGA Parameters data structure with <code>''subnetPrefix''</code> and <code>''collCount''</code> essentially set to 0. A <a href="brute-force_search" title="wikilink">brute-force search</a> is performed to find a suitable <code>''Hash2''</code>, incrementing the <code>''modifier''</code> by 1 each iteration (lines 6 to 15). Because more bits need to be 0 with a higher <code>''Sec''</code> value, the average time required to perform the search increases exponentially with the value of <code>''Sec''</code>.</p>

<p>After concatenating the subnet prefix and the generated interface identifier to create the CGA, <a href="IPv6_address#Duplicate_address_detection" title="wikilink">duplicate address detection</a> may be performed. If the address is already in use, then the collision counter <code>''collCount''</code> is incremented by 1 and a new interface identifier is generated (lines 20 to 39). Because <code>''collCount''</code> is not used in calculating <code>''Hash2''</code>, it is not necessary to search for a new <code>''Hash2''</code> when an address collision occurs. For a similar reason, <code>''subnetPrefix''</code> is not used either so that if the subnet prefix of the address changes but the host's public key does not, then the same modifier could be reused and there is no need to search for a new <code>''Hash2''</code>.</p>

<p>On line 41 the CGA is returned, along with the CGA Parameters data structure.</p>
<h2 id="cga-verification-method">CGA verification method</h2>

<p>A Cryptographically Generated Address is used to verify that received signed messages were sent by the host to which that address has been assigned. This is done by verifying that the key pair used for signing has been bound to the CGA. Because the authenticity of the public key can be verified this way, there is no need for a public key infrastructure. If the host itself is required to be authenticated as well, however, then the CGA itself needs to be authenticated beforehand since the bound public key cannot be trusted if the address is not trusted in such a case (assuming it has not been verified by other methods than CGA).</p>

<p>The CGA verification method, in which a public key is verified to be bound to a CGA, requires the corresponding CGA Parameters data structure as input and can be implemented as follows.</p>

<p><code> 1  </code><strong><code>procedure</code></strong><code> verifyCGA(</code><em><code>CGA</code></em><code>, [</code><em><code>modifier</code></em><code>, </code><em><code>subnetPrefix</code></em><code>, </code><em><code>collCount</code></em><code>, </code><em><code>publicKey</code></em><code>, </code><em><code>extFields</code></em><code>]):</code><br/>
<code> 2      </code><strong><code>if</code></strong><code> </code><em><code>collCount</code></em><code> &gt; 2 </code><strong><code>or</code></strong><code> </code><em><code>CGA</code></em><code>[0:8] ≠ </code><em><code>subnetPrefix</code></em><code>:</code><br/>
<code> 3          </code><strong><code>return</code></strong><code> false</code><br/>
<code> 4      </code><strong><code>end</code> <code>if</code></strong><br/>
<code> 5</code><br/>
<code> 6      </code><em><code>concat</code></em><code> := concatenate(</code><em><code>modifier</code></em><code>, </code><em><code>subnetPrefix</code></em><code>, </code><em><code>collCount</code></em><code>,</code><br/>
<code> 7                            </code><em><code>publicKey</code></em><code>, </code><em><code>extFields</code></em><code>)</code><br/>
<code> 8</code><br/>
<code> 9      </code><em><code>digest</code></em><code> := SHA1(</code><em><code>concat</code></em><code>)</code><br/>
<code>10      </code><em><code>Hash1</code></em><code> := </code><em><code>digest</code></em><code>[0:8]                                   // 8*8 = 64 leftmost bits</code><br/>
<code>11      </code><em><code>Hash1</code></em><code>[0] := </code><em><code>Hash1</code></em><code>[0] </code><strong><code>binary</code> <code>and</code></strong><code> 0x1c                   // ignore Sec and u/g bits</code><br/>
<code>12</code><br/>
<code>13      </code><em><code>intID</code></em><code> := </code><em><code>CGA</code></em><code>[8:16]                                     // interface identifier (64 rightmost bits)</code><br/>
<code>14      </code><em><code>intID</code></em><code>[0] := </code><em><code>intID</code></em><code>[0] </code><strong><code>binary</code> <code>and</code></strong><code> 0x1c                   // ignore Sec and u/g bits</code><br/>
<code>15</code><br/>
<code>16      </code><strong><code>if</code></strong><code> </code><em><code>Hash1</code></em><code> ≠ </code><em><code>intID</code></em><code>:</code><br/>
<code>17          </code><strong><code>return</code></strong><code> false</code><br/>
<code>18      </code><strong><code>end</code> <code>if</code></strong><br/>
<code>19</code><br/>
<code>20      </code><em><code>Sec</code></em><code> := </code><em><code>CGA</code></em><code>[8] &gt;&gt; 5                                     // extract Sec from interface identifier</code><br/>
<code>21</code><br/>
<code>22      </code><em><code>concat</code></em><code> := concatenate(</code><em><code>modifier</code></em><code>, 0x000000000000000000,  // 9 zero octets</code><br/>
<code>23                            </code><em><code>publicKey</code></em><code>, </code><em><code>extFields</code></em><code>)</code><br/>
<code>24</code><br/>
<code>25      </code><em><code>digest</code></em><code> := SHA1(</code><em><code>concat</code></em><code>)</code><br/>
<code>26      </code><em><code>Hash2</code></em><code> := </code><em><code>digest</code></em><code>[0:14]                                  // 14*8 = 112 leftmost bits</code><br/>
<code>27</code><br/>
<code>28      </code><strong><code>if</code></strong><code> </code><em><code>Sec</code></em><code> ≠ 0 </code><strong><code>and</code></strong><code> </code><em><code>Hash2</code></em><code>[0:2*</code><em><code>Sec</code></em><code>] ≠ 0:                     // 2*Sec*8 = 16*Sec leftmost bits</code><br/>
<code>29          </code><strong><code>return</code></strong><code> false</code><br/>
<code>30      </code><strong><code>end</code> <code>if</code></strong><br/>
<code>31</code><br/>
<code>32      </code><strong><code>return</code></strong><code> true                                            // verification succeeded</code><br/>
<code>33  </code><strong><code>end</code> <code>procedure</code></strong></p>

<p>The method starts with checking if <code>''collCount''</code> from the CGA Parameters data structure has a valid value and if <code>''subnetPrefix''</code> from the same data structure matches the CGA's subnet prefix (on line 2). This is done for <a href="#Security" title="wikilink">security reasons</a>.</p>

<p>From line 6 to 18, <code>''Hash1''</code> is calculated from the CGA Parameters data structure (which includes the public key and the subnet prefix) and the relevant bits are compared to those of the CGA's interface identifier. In this case, this is done by setting the first three bits (<code>''Sec''</code>) and the seventh and eighth bit ("u" and "g" bits) of both <code>''Hash1''</code> and the interface identifier to 0 on lines 11 and 14 for easy comparison.</p>

<p>After extracting <code>''Sec''</code> from the CGA's interface identifier, <code>''Hash2''</code> is calculated and the first 16 times <code>''Sec''</code> bits of the hash are compared to 0 (lines 22 to 30). If all checks turn out well, then the public key has been verified to be bound to (i.e. to be valid for) that CGA.</p>
<h2 id="security">Security</h2>

<p>In order for an <a href="Adversary_(cryptography)" title="wikilink">attacker</a> to make a <a href="Client_(computing)" title="wikilink">client</a> believe it received a valid message from a certain CGA that isn't owned by the attacker, the attacker must find a <a href="Collision_(computer_science)" title="wikilink">hash collision</a> for the relevant bits of <code>''Hash1''</code> and <code>''Hash2''</code> by performing a <a href="brute-force_attack" title="wikilink">brute-force attack</a>. If the attacker finds a set of CGA Parameters (including a public key for which the attacker knows the private key) that can be used to generate the same CGA as the target CGA, then the attacker can impersonate the host who actually owns the CGA without being detected (except perhaps when the client has contacted the host before and notices that the public key has changed but the CGA has not).</p>

<p>Of the 64 bits of <code>''Hash1''</code>, only 59 are used in the interface identifier since 5 bits are being overwritten. For a CGA with <code>''Sec''</code> equal to 0, this means that the cost of finding a set of CGA Parameters that yield the desired 59 bits is approximately 

<math display="inline" id="Cryptographically_Generated_Address:0">
<semantics>
<mrow>
<mi>O</mi>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mn>2</mn>
<mn>59</mn>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>O</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<cn type="integer">59</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   O(2^{59})
  </annotation>
</semantics>
</math>

 (in <a href="big_O_notation" title="wikilink">big O notation</a>). A larger value of <code>''Sec''</code>, however, increases this cost by a factor of 

<math display="inline" id="Cryptographically_Generated_Address:1">
<semantics>
<msup>
<mn>2</mn>
<mrow>
<mrow>
<mn>16</mn>
<mo>×</mo>
<mi>S</mi>
</mrow>
<mi>e</mi>
<mi>c</mi>
</mrow>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<times></times>
<apply>
<times></times>
<cn type="integer">16</cn>
<ci>S</ci>
</apply>
<ci>e</ci>
<ci>c</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   2^{16\times Sec}
  </annotation>
</semantics>
</math>

 to 

<math display="inline" id="Cryptographically_Generated_Address:2">
<semantics>
<mrow>
<mi>O</mi>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mn>2</mn>
<mrow>
<mn>59</mn>
<mo>+</mo>
<mrow>
<mrow>
<mn>16</mn>
<mo>×</mo>
<mi>S</mi>
</mrow>
<mi>e</mi>
<mi>c</mi>
</mrow>
</mrow>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>O</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<plus></plus>
<cn type="integer">59</cn>
<apply>
<times></times>
<apply>
<times></times>
<cn type="integer">16</cn>
<ci>S</ci>
</apply>
<ci>e</ci>
<ci>c</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   O(2^{59+16\times Sec})
  </annotation>
</semantics>
</math>

 because the first 16 times <code>''Sec''</code> bits of <code>''Hash2''</code> then become relevant (i.e. it implements a hash extension by demanding those bits to be equal to 0). In the CGA generation process, the cost of generating an address is increased by the same factor depending on the value of <code>''Sec''</code>, but the cost of using and verifying a CGA remains constant.</p>

<p>Because <code>''Sec''</code> is not part of the CGA Parameters data structure but of the address itself, an attacker cannot use a <code>''Sec''</code> value smaller than that of the target address (like 0) in an attempt to skip (or scale down) the brute-force attack on <code>''Hash2''</code>. This would namely yield a different CGA from the target CGA since at least one of the three leftmost bits of the interface identifier would not match. If the target <code>''Sec''</code> value is written to the interface identifier anyway, then <code>''Hash2''</code> will (almost certainly) be found to lack the required amount of leftmost 0-bits during the verification process.</p>

<p>During the CGA generation process, it is very unlikely that three address collisions occur. If a duplicate address would be detected for the third time, then this would most likely be due to a configuration or implementation error or a <a href="denial-of-service_attack" title="wikilink">denial-of-service attack</a>. For this reason, the number of valid values for <code>''collCount''</code> is limited to the range from 0 to 2. This parameter must be verified to be in this range during the CGA verification process in order to prevent an attacker from exploiting it and trying all different values without the need to perform another brute-force search for <code>''Hash2''</code> each time a different value is tried.</p>

<p>By including the subnet prefix in the digest operation that results in <code>''Hash1''</code>, it can be prevented that an attacker is able to use a single pre-computed database to attack addresses with different subnet prefixes. A verifier can also be sure that the public key has been bound to this exact address and not possibly to an address with the same interface identifier but a different subnet prefix. Since the CGA specification prescribes to use the <code>''subnetPrefix''</code> from the CGA Parameters data structure for the digest operations, it must be verified that it matches the subnet prefix of the CGA during the CGA verification process.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="SHA-1" title="wikilink">SHA-1</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Cryptographic_protocols" title="wikilink">Category:Cryptographic protocols</a> <a class="uri" href="Category:IPv6" title="wikilink">Category:IPv6</a> <a href="Category:Articles_with_example_pseudocode" title="wikilink">Category:Articles with example pseudocode</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">RFC 3972, <em>Cryptographically Generated Addresses (CGA)</em>, T. Aura (March 2005)<a href="#fnref1">↩</a></li>
<li id="fn2">RFC 3971, <em>Secure Neighbor Discovery (SEND)</em>, J. Arkko (ed.), J. Kempf, B. Zill, P. Nikander (March 2005)<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
