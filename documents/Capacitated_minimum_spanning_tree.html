<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="585">Capacitated minimum spanning tree</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Capacitated minimum spanning tree</h1>
<hr/>

<p><strong>Capacitated minimum spanning tree</strong> is a minimal cost <a href="Spanning_tree_(mathematics)" title="wikilink">spanning tree</a> of a <a href="Graph_(mathematics)" title="wikilink">graph</a> that has a designated root node 

<math display="inline" id="Capacitated_minimum_spanning_tree:0">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 and satisfies the capacity constraint 

<math display="inline" id="Capacitated_minimum_spanning_tree:1">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

. The capacity constraint ensures that all subtrees (maximal subgraphs connected to the root by a single edge) incident on the root node 

<math display="inline" id="Capacitated_minimum_spanning_tree:2">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 have no more than 

<math display="inline" id="Capacitated_minimum_spanning_tree:3">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 nodes. If the tree nodes have weights, then the capacity constraint may be interpreted as follows: the sum of weights in any subtree should be no greater than 

<math display="inline" id="Capacitated_minimum_spanning_tree:4">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

. The edges connecting the subgraphs to the root node are called <em>gates</em>. Finding the optimal <a class="uri" href="solution" title="wikilink">solution</a> is NP-hard.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="algorithms">Algorithms</h2>

<p>Suppose we have a graph 

<math display="inline" id="Capacitated_minimum_spanning_tree:5">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Capacitated_minimum_spanning_tree:6">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>G</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <abs></abs>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=|G|
  </annotation>
 </semantics>
</math>

 with a root 

<math display="inline" id="Capacitated_minimum_spanning_tree:7">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>∈</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>r</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\in G
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Capacitated_minimum_spanning_tree:8">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}
  </annotation>
 </semantics>
</math>

 be all other nodes in 

<math display="inline" id="Capacitated_minimum_spanning_tree:9">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Capacitated_minimum_spanning_tree:10">
 <semantics>
  <msub>
   <mi>c</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{ij}
  </annotation>
 </semantics>
</math>

 be the edge cost between <a href="Vertex_(graph_theory)" title="wikilink">vertices</a> 

<math display="inline" id="Capacitated_minimum_spanning_tree:11">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Capacitated_minimum_spanning_tree:12">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{j}
  </annotation>
 </semantics>
</math>

 which form a cost matrix 

<math display="inline" id="Capacitated_minimum_spanning_tree:13">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <msub>
    <mi>c</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C={c_{ij}}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="esau-williams-heuristic">Esau-Williams heuristic<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></h3>

<p>Esau-Williams heuristic finds suboptimal CMST that are very close to the exact solutions, but on average EW produces better results than many other heuristics.</p>

<p>Initially, all nodes are connected to the <a class="uri" href="root" title="wikilink">root</a> 

<math display="inline" id="Capacitated_minimum_spanning_tree:14">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 (star graph) and the network's cost is 

<math display="inline" id="Capacitated_minimum_spanning_tree:15">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
   </mstyle>
   <msub>
    <mi>c</mi>
    <mrow>
     <mi>r</mi>
     <mi>i</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\sum_{i=0}^{n}c_{ri}
  </annotation>
 </semantics>
</math>

; each of these edges is a gate. At each iteration, we seek the closest neighbor 

<math display="inline" id="Capacitated_minimum_spanning_tree:16">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{j}
  </annotation>
 </semantics>
</math>

 for every node in 

<math display="inline" id="Capacitated_minimum_spanning_tree:17">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>-</mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>G</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G-{r}
  </annotation>
 </semantics>
</math>

 and evaluate the tradeoff function

<math display="block" id="Capacitated_minimum_spanning_tree:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>g</mi>
     <mi>i</mi>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>c</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>t</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(a_{i})=g_{i}-c_{ij}
  </annotation>
 </semantics>
</math>

. We look for the greatest 

<math display="inline" id="Capacitated_minimum_spanning_tree:19">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(a_{i})
  </annotation>
 </semantics>
</math>

 among the positive tradeoffs and, if the resulting subtree does not violate the capacity constraints, remove the gate 

<math display="inline" id="Capacitated_minimum_spanning_tree:20">
 <semantics>
  <msub>
   <mi>g</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{i}
  </annotation>
 </semantics>
</math>

 connecting the 

<math display="inline" id="Capacitated_minimum_spanning_tree:21">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th subtree to 

<math display="inline" id="Capacitated_minimum_spanning_tree:22">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{j}
  </annotation>
 </semantics>
</math>

 by an edge 

<math display="inline" id="Capacitated_minimum_spanning_tree:23">
 <semantics>
  <msub>
   <mi>c</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{ij}
  </annotation>
 </semantics>
</math>

. We repeat the iterations until we can not make any further improvements to the tree.</p>

<p>Esau-Williams heuristics for computing a suboptimal CMST:</p>

<p><strong><code>function</code></strong><code> CMST(</code><em><code>c</code></em><code>,</code><em><code>C</code></em><code>,</code><em><code>r</code></em><code>):</code><br/>
<code>    </code><em><code>T</code></em><code> = {</code>

<math display="inline" id="Capacitated_minimum_spanning_tree:24">
 <semantics>
  <msub>
   <mi>c</mi>
   <mrow>
    <mn>1</mn>
    <mi>r</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{1r}
  </annotation>
 </semantics>
</math>

<code>, </code>

<math display="inline" id="Capacitated_minimum_spanning_tree:25">
 <semantics>
  <msub>
   <mi>c</mi>
   <mrow>
    <mn>2</mn>
    <mi>r</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{2r}
  </annotation>
 </semantics>
</math>

<code>, ..., </code>

<math display="inline" id="Capacitated_minimum_spanning_tree:26">
 <semantics>
  <msub>
   <mi>c</mi>
   <mrow>
    <mi>n</mi>
    <mi>r</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{nr}
  </annotation>
 </semantics>
</math>

<code>}</code><br/>
<code>    </code><strong><code>while</code></strong><code> have changes:</code><br/>
<code>        </code><strong><code>for</code> <code>each</code></strong><code> node </code>

<math display="inline" id="Capacitated_minimum_spanning_tree:27">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Capacitated_minimum_spanning_tree:28">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}
  </annotation>
 </semantics>
</math>

 = closest node in a different subtree</p>

<p><code>            </code>

<math display="inline" id="Capacitated_minimum_spanning_tree:29">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(a_{i})
  </annotation>
 </semantics>
</math>

<code> = </code>

<math display="inline" id="Capacitated_minimum_spanning_tree:30">
 <semantics>
  <msub>
   <mi>g</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{i}
  </annotation>
 </semantics>
</math>

<code> - </code>

<math display="inline" id="Capacitated_minimum_spanning_tree:31">
 <semantics>
  <msub>
   <mi>c</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{ij}
  </annotation>
 </semantics>
</math>

<br/>
<code>        </code><em><code>t_max</code></em><code> = </code><strong><code>max</code></strong><code>(</code>

<math display="inline" id="Capacitated_minimum_spanning_tree:32">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(a_{i})
  </annotation>
 </semantics>
</math>

<code>)</code><br/>
<code>        </code><em><code>k</code></em><code> = </code><em><code>i</code></em><code> such that </code>

<math display="inline" id="Capacitated_minimum_spanning_tree:33">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(a_{i})
  </annotation>
 </semantics>
</math>

<code> = t_max</code><br/>
<code>        </code><strong><code>if</code></strong><code> ( </code><strong><code>cost</code></strong><code>(i) + </code><strong><code>cost</code></strong><code>(j) </code><code>g_{k}</code><br/>
<code>            </code><em><code>T</code></em><code> = </code><em><code>T</code></em><code> union </code>

<math display="inline" id="Capacitated_minimum_spanning_tree:34">
 <semantics>
  <msub>
   <mi>c</mi>
   <mrow>
    <mi>k</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{kj}
  </annotation>
 </semantics>
</math>

<br/>
<code>    </code><strong><code>return</code></strong><code> </code><em><code>T</code></em></p>

<p>It is easy to see that EW finds a solution in polynomial time.</p>
<h3 id="sharmas-heuristic">Sharma's heuristic</h3>

<p>Sharma's heuristic.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="applications">Applications</h2>

<p>CMST problem is important in network design: when many terminal <a class="uri" href="computers" title="wikilink">computers</a> have to be connected to the central hub, the star configuration is usually not the minimum cost design. Finding a CMST that organizes the terminals into subnetworks can lower the cost of implementing a network.</p>
<h2 id="limitations">Limitations</h2>

<p>But CMST is still not provide the minimum cost for long situated nodes.overcome this drawback ESAU Williams has solved this problem.</p>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Spanning_tree" title="wikilink">Category:Spanning tree</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
