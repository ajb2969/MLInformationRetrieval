<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1656">Cokernel</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Cokernel</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the <strong>cokernel</strong> of a <a href="linear_mapping" title="wikilink">linear mapping</a> of <a href="vector_spaces" title="wikilink">vector spaces</a> <em>f</em> : <em>X</em> → <em>Y</em> is the <a href="quotient_space_(linear_algebra)" title="wikilink">quotient space</a> <em>Y</em>/im(<em>f</em>) of the <a class="uri" href="codomain" title="wikilink">codomain</a> of <em>f</em> by the image of <em>f</em>. The dimension of the cokernel is called the <em>corank</em> of <em>f</em>.</p>

<p>Cokernels are <a href="dual_(category_theory)" title="wikilink">dual</a> to the <a href="kernel_(category_theory)" title="wikilink">kernels of category theory</a>, hence the name: the kernel is a <a class="uri" href="subobject" title="wikilink">subobject</a> of the domain (it maps to the domain), while the cokernel is a <a href="quotient_object" title="wikilink">quotient object</a> of the codomain (it maps from the codomain).</p>

<p>Intuitively, given an equation <em>f(x) = y</em> that one is seeking to solve, the cokernel measures the <em>constraints</em> that <em>y</em> must satisfy for this equation to have a solution – the obstructions to a solution – while the kernel measures the <em>degrees of freedom</em> in a solution, if one exists. This is elaborated in <a href="#Intuition" title="wikilink">intuition</a>, below.</p>

<p>More generally, the cokernel of a <a class="uri" href="morphism" title="wikilink">morphism</a> <em>f</em> : <em>X</em> → <em>Y</em> in some <a href="category_theory" title="wikilink">category</a> (e.g. a <a href="group_homomorphism" title="wikilink">homomorphism</a> between <a href="group_(mathematics)" title="wikilink">groups</a> or a <a href="bounded_linear_operator" title="wikilink">bounded linear operator</a> between <a href="Hilbert_space" title="wikilink">Hilbert spaces</a>) is an object <em>Q</em> and a morphism <em>q</em> : <em>Y</em> → <em>Q</em> such that the composition <em>q f</em> is the <a href="zero_morphism" title="wikilink">zero morphism</a> of the category, and furthermore <em>q</em> is <a href="universal_mapping_property" title="wikilink">universal</a> with respect to this property. Often the map <em>q</em> is understood, and <em>Q</em> itself is called the cokernel of <em>f</em>.</p>

<p>In many situations in <a href="abstract_algebra" title="wikilink">abstract algebra</a>, such as for <a href="abelian_group" title="wikilink">abelian groups</a>, <a href="vector_space" title="wikilink">vector spaces</a> or <a href="module_(mathematics)" title="wikilink">modules</a>, the cokernel of the <a class="uri" href="homomorphism" title="wikilink">homomorphism</a> <em>f</em> : <em>X</em> → <em>Y</em> is the <a href="quotient_set" title="wikilink">quotient</a> of <em>Y</em> by the <a href="Image_(mathematics)" title="wikilink">image</a> of <em>f</em>. In <a href="topology" title="wikilink">topological</a> settings, such as with bounded linear operators between Hilbert spaces, one typically has to take the <a href="closure_(mathematics)" title="wikilink">closure</a> of the image before passing to the quotient.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>One can define the cokernel in the general framework of <a href="category_theory" title="wikilink">category theory</a>. In order for the definition to make sense the category in question must have <a href="zero_morphism" title="wikilink">zero morphisms</a>. The <strong>cokernel</strong> of a <a class="uri" href="morphism" title="wikilink">morphism</a> <em>f</em> : <em>X</em> → <em>Y</em> is defined as the <a class="uri" href="coequalizer" title="wikilink">coequalizer</a> of <em>f</em> and the zero morphism 0<sub><em>XY</em></sub> : <em>X</em> → <em>Y</em>.</p>

<p>Explicitly, this means the following. The cokernel of <em>f</em> : <em>X</em> → <em>Y</em> is an object <em>Q</em> together with a morphism <em>q</em> : <em>Y</em> → <em>Q</em> such that the diagram</p>
<div style="text-align: center;">
<figure><b>(Figure)</b>
<figcaption>Cokernel-01.png</figcaption>
</figure>
</div>

<p><a href="commutative_diagram" title="wikilink">commutes</a>. Moreover the morphism <em>q</em> must be <a href="universal_property" title="wikilink">universal</a> for this diagram, i.e. any other such <em>q</em>′: <em>Y</em> → <em>Q</em>′ can be obtained by composing <em>q</em> with a unique morphism <em>u</em> : <em>Q</em> → <em>Q</em>′:</p>
<div style="text-align: center;">
<figure><b>(Figure)</b>
<figcaption>Cokernel-02.png</figcaption>
</figure>
</div>

<p>As with all universal constructions the cokernel, if it exists, is unique <a href="up_to" title="wikilink">up to</a> a unique <a class="uri" href="isomorphism" title="wikilink">isomorphism</a>, or more precisely: if <em>q</em> : <em>Y</em> → <em>Q</em> and <em>q‘</em> : <em>Y</em> → <em>Q‘</em> are two cokernels of <em>f</em> : <em>X</em> → <em>Y</em>, then there exists a unique isomorphism <em>u</em> : <em>Q</em> → <em>Q‘</em> with <em>q‘</em> = <em>u</em> <em>q</em>.</p>

<p>Like all coequalizers, the cokernel <em>q</em> : <em>Y</em> → <em>Q</em> is necessarily an <a class="uri" href="epimorphism" title="wikilink">epimorphism</a>. Conversely an epimorphism is called <em><a href="normal_morphism" title="wikilink">normal</a></em> (or <em>conormal</em>) if it is the cokernel of some morphism. A category is called <em>conormal</em> if every epimorphism is normal (e.g. the <a href="category_of_groups" title="wikilink">category of groups</a> is conormal).</p>
<h3 id="examples">Examples</h3>

<p>In the <a href="category_of_groups" title="wikilink">category of groups</a>, the cokernel of a <a href="group_homomorphism" title="wikilink">group homomorphism</a> <em>f</em> : <em>G</em> → <em>H</em> is the <a href="quotient_group" title="wikilink">quotient</a> of <em>H</em> by the <a href="Normal_closure_(group_theory)" title="wikilink">normal closure</a> of the image of <em>f</em>. In the case of <a href="abelian_group" title="wikilink">abelian groups</a>, since every <a class="uri" href="subgroup" title="wikilink">subgroup</a> is normal, the cokernel is just <em>H</em> <a href="Ideal_(ring_theory)" title="wikilink">modulo</a> the image of <em>f</em>:</p>
<dl>
<dd>coker(<em>f</em>) = <em>H</em> / im(<em>f</em>).
</dd>
</dl>
<h3 id="special-cases">Special cases</h3>

<p>In a <a href="preadditive_category" title="wikilink">preadditive category</a>, it makes sense to add and subtract morphisms. In such a category, the <a class="uri" href="coequalizer" title="wikilink">coequalizer</a> of two morphisms <em>f</em> and <em>g</em> (if it exists) is just the cokernel of their difference:</p>

<p>

<math display="block" id="Cokernel:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>coeq</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo>,</mo>
     <mi>g</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>coker</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>g</mi>
      <mo>-</mo>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>coeq</ci>
     <interval closure="open">
      <ci>f</ci>
      <ci>g</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>coker</ci>
     <apply>
      <minus></minus>
      <ci>g</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{coeq}(f,g)=\mathrm{coker}(g-f)
  </annotation>
 </semantics>
</math>

.</p>

<p>In an <a href="abelian_category" title="wikilink">abelian category</a> (a special kind of preadditive category) the <a href="image_(category_theory)" title="wikilink">image</a> and <a class="uri" href="coimage" title="wikilink">coimage</a> of a morphism <em>f</em> are given by</p>

<p>

<math display="inline" id="Cokernel:1">
 <semantics>
  <mrow>
   <mi>im</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>im</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\mathrm{im}(f)
  </annotation>
 </semantics>
</math>


.</p>

<p>In particular, every abelian category is normal (and conormal as well). That is, every <a class="uri" href="monomorphism" title="wikilink">monomorphism</a> <em>m</em> can be written as the kernel of some morphism. Specifically, <em>m</em> is the kernel of its own cokernel:</p>

<p>

<math display="block" id="Cokernel:2">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mrow>
    <mi>ker</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>coker</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>m</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <apply>
     <csymbol cd="latexml">kernel</csymbol>
     <apply>
      <times></times>
      <ci>coker</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=\ker(\mathrm{coker}(m))
  </annotation>
 </semantics>
</math>

</p>
<h2 id="intuition">Intuition</h2>

<p>The cokernel can be thought of as the space of <em>constraints</em> that an equation must satisfy, as the space of <em>obstructions,</em> just as the <a href="Kernel_(algebra)" title="wikilink">kernel</a> is the space of <em>solutions.</em></p>

<p>Formally, one may connect the kernel and the cokernel by the <a href="exact_sequence" title="wikilink">exact sequence</a></p>

<p>

<math display="block" id="Cokernel:3">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mrow>
    <mi>ker</mi>
    <mi>T</mi>
   </mrow>
   <mo>→</mo>
   <mi>V</mi>
   <mo>→</mo>
   <mi>W</mi>
   <mo>→</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>coker</mi>
    </mpadded>
    <mi>T</mi>
   </mrow>
   <mo>→</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="latexml">kernel</csymbol>
      <ci>T</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>V</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>W</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>coker</ci>
      <ci>T</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\to\ker T\to V\to W\to\mathrm{coker}\,T\to 0.
  </annotation>
 </semantics>
</math>

 These can be interpreted thus: given a linear equation <em>T(v)=w</em> to solve,</p>
<ul>
<li>the kernel is the space of <em>solutions</em> to the <em>homogeneous</em> equation <em>T(v)=0</em>, and its dimension is the number of <em>degrees of freedom</em> in a solution, if it exists;</li>
<li>the cokernel is the space of <em>constraints</em> that must be satisfied if the equation is to have a solution, and its dimension is the number of constraints that must be satisfied for the equation to have a solution.</li>
</ul>

<p>The dimension of the cokernel plus the dimension of the image (the rank) add up to the dimension of the target space, as the dimension of the quotient space <em>W/T(V)</em> is simply the dimension of the space <em>minus</em> the dimension of the image.</p>

<p>As a simple example, consider the map <em>T</em>: <strong>R</strong><sup>2</sup> → <strong>R</strong><sup>2</sup>, given by <em>T(x,y) = (0,y)</em>. Then for an equation <em>T(x,y)=(a,b)</em> to have a solution, we must have <em>a=0</em> (one constraint), and in that case the solution space is <em>(x,b)</em>, or equivalently stated, <em>(0,b)+(x,0)</em>, (one degree of freedom). The kernel may be expressed as the subspace ''(x,0) </p>
</body>
</html>
