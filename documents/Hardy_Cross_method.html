<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1917">Hardy Cross method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Hardy Cross method</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>HardyCrossMethodNetwork| An example pipe flow network</figcaption>
</figure>

<p>The <strong>Hardy Cross method</strong> is an <a href="iterative_method" title="wikilink">iterative method</a> for determining the flow in pipe network systems where the inputs and outputs are known, but the flow inside the network is unknown.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The method was first published in November 1936 by its namesake, <a href="Hardy_Cross" title="wikilink">Hardy Cross</a>, a structural engineering professor at the <a href="University_of_Illinois_at_Urbana–Champaign" title="wikilink">University of Illinois at Urbana–Champaign</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The Hardy Cross method is an adaptation of the <a href="Moment_distribution_method" title="wikilink">Moment distribution method</a>, which was also developed by Hardy Cross as a way to determine the moments in indeterminate structures.</p>

<p>The introduction of the Hardy Cross method for analyzing pipe flow networks revolutionized <a href="municipal_water_supply" title="wikilink">municipal water supply</a> design. Before the method was introduced, solving complex pipe systems for distribution was extremely difficult due to the nonlinear relationship between head loss and flow. The method was later made obsolete by computer solving algorithms employing the <a href="Newton-Raphson_method" title="wikilink">Newton-Raphson method</a> or other solving methods that prevent the need to solve nonlinear systems of equations by hand.</p>
<h2 id="history">History</h2>

<p>In 1930, <a href="Hardy_Cross" title="wikilink">Hardy Cross</a> published a paper called "Analysis of Continuous Frames by Distributing Fixed-End Moments" in which he described the <a href="moment_distribution_method" title="wikilink">moment distribution method</a>, which would change the way engineers in the field performed structural analysis.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The moment distribution method was used to determine the moment distributions in indeterminant concrete structures and allowed for engineers to safely design structures from concrete from the 1930s to 1960.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> In November 1936, Cross applied the same geometric method to solving pipe network flow distribution problems, and published a paper called "Analysis of flow in networks of conduits or conductors."<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="derivation">Derivation</h2>

<p>The Hardy Cross method is an application of <a href="conservation_of_mass" title="wikilink">continuity of flow</a> and <a href="conservation_of_energy" title="wikilink">continuity of potential</a> to iteratively solve for flows in a pipe network.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> In the case of pipe flow, conservation of flow means that the flow in is equal to the flow out at each junction in the pipe. Conservation of potential means that the total directional head loss along any loop in the system is zero (assuming that a head loss counted against the flow is actually a head gain).</p>

<p>Hardy Cross developed two methods for solving flow networks. Each method starts by maintaining either continuity of flow or potential, and then iteratively solves for the other.</p>
<h3 id="assumptions">Assumptions</h3>

<p>The Hardy Cross method assumes that the flow going in and out of the system is known and that the pipe length, diameter, roughness and other key characteristics are also known or can be assumed.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> The method also assumes that the relation between flow rate and head loss is known, but the method does not require any particular relation to be used.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>In the case of water flow through pipes, a number of methods have been developed to determine the relationship between head loss and flow. The Hardy Cross method allows for any of these relationships to be used.</p>

<p>The general relationship between head loss and flow is:</p>

<p>

<math display="block" id="Hardy_Cross_method:0">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>f</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mo>⋅</mo>
    <msup>
     <mi>Q</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>k</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Q</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{f}=k\cdot Q^{n}
  </annotation>
 </semantics>
</math>

</p>

<p>where k is the head loss per unit flow and n is the flow exponent. In most design situations the values that make up k, such as pipe length, diameter, and roughness, are taken to be known or assumed and the value of k can be determined for each pipe in the network. The values that make up k and the value of n change depending on the relation used to determine head loss. However, all relations are compatible with the Hardy Cross method.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Head Loss Equation</p></th>
<th style="text-align: left;">
<p>Relation</p></th>
<th style="text-align: left;">
<p><strong>k</strong></p></th>
<th style="text-align: left;">
<p><strong>n</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Hazen-Williams_equation" title="wikilink">Hazen-Williams equation</a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Hardy_Cross_method:1">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>f</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>L</mi>
    <mo>⋅</mo>
    <mfrac>
     <mrow>
      <mn>10.67</mn>
      <msup>
       <mi>Q</mi>
       <mn>1.85</mn>
      </msup>
     </mrow>
     <mrow>
      <msup>
       <mi>C</mi>
       <mn>1.85</mn>
      </msup>
      <msup>
       <mi>d</mi>
       <mn>4.87</mn>
      </msup>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>L</ci>
     <apply>
      <divide></divide>
      <list>
       <cn type="float">10.67</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Q</ci>
        <cn type="float">1.85</cn>
       </apply>
      </list>
      <list>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>C</ci>
        <cn type="float">1.85</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>d</ci>
        <cn type="float">4.87</cn>
       </apply>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{f}=L\cdot\frac{10.67\quad Q^{1.85}}{C^{1.85}\quad d^{4.87}}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Hardy_Cross_method:2">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>⋅</mo>
   <mfrac>
    <mn>10.67</mn>
    <mrow>
     <msup>
      <mi>C</mi>
      <mn>1.85</mn>
     </msup>
     <msup>
      <mi>d</mi>
      <mn>4.87</mn>
     </msup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>L</ci>
    <apply>
     <divide></divide>
     <cn type="float">10.67</cn>
     <list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>C</ci>
       <cn type="float">1.85</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>d</ci>
       <cn type="float">4.87</cn>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\cdot\frac{10.67}{C^{1.85}\quad d^{4.87}}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><strong>1.85</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Darcy-Weisbach_equation" title="wikilink">Darcy-Weisbach equation</a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Hardy_Cross_method:3">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>f</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mn>8</mn>
     <mi>f</mi>
     <mi>L</mi>
     <msup>
      <mi>Q</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mrow>
     <mi>g</mi>
     <msup>
      <mi>π</mi>
      <mn>2</mn>
     </msup>
     <msup>
      <mi>d</mi>
      <mn>5</mn>
     </msup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <cn type="integer">8</cn>
      <ci>f</ci>
      <ci>L</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Q</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>g</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>π</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>d</ci>
       <cn type="integer">5</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{f}=\frac{8fLQ^{2}}{g\pi^{2}d^{5}}
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Hardy_Cross_method:4">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>⋅</mo>
   <mfrac>
    <mrow>
     <mn>8</mn>
     <mi>f</mi>
    </mrow>
    <mrow>
     <mi>g</mi>
     <msup>
      <mi>π</mi>
      <mn>2</mn>
     </msup>
     <msup>
      <mi>d</mi>
      <mn>5</mn>
     </msup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>L</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <cn type="integer">8</cn>
      <ci>f</ci>
     </apply>
     <apply>
      <times></times>
      <ci>g</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>π</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>d</ci>
       <cn type="integer">5</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\cdot\frac{8f}{g\pi^{2}d^{5}}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><strong>2</strong></p></td>
</tr>
</tbody>
</table>

<p>It is also worth noting that the Hardy Cross method can be used to solve simple circuits and other flow like situations. In the case of simple circuits,</p>

<p>

<math display="block" id="Hardy_Cross_method:5">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>=</mo>
   <mrow>
    <mi>K</mi>
    <mo>⋅</mo>
    <mi>I</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>V</ci>
    <apply>
     <ci>normal-⋅</ci>
     <ci>K</ci>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V=K\cdot I
  </annotation>
 </semantics>
</math>

 is equivalent to</p>

<p>

<math display="block" id="Hardy_Cross_method:6">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>f</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mo>⋅</mo>
    <msup>
     <mi>Q</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>k</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Q</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{f}=k\cdot Q^{n}
  </annotation>
 </semantics>
</math>

. By setting the coefficient k to K, the flow rate Q to I and the exponent n to 1, the Hardy Cross method can be used to solve a simple circuit. However, because the relation between the voltage drop and current is linear, the Hardy Cross method is not necessary and the circuit can be solved using non-iterative methods.</p>
<h3 id="method-of-balancing-heads">Method of balancing heads</h3>

<p>The method of balancing <a href="Hydraulic_head" title="wikilink">heads</a> uses an initial guess that satisfies continuity of flow at each junction and then balances the flows until continuity of potential is also achieved over each loop in the system.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h4 id="proofr-denotes-k">Proof(r denotes k)</h4>

<p>The following proof is taken from Hardy Cross's paper, “Analysis of flow in networks of conduits or conductors.”,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> and can be verified by National Programme on Technology Enhanced Learning Water and Wastewater Engineering page,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> and Fundamentals of Hydraulic Engineering Systems by Robert J. Houghtalen.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>If the initial guess of flow rates in each pipe is correct, the change in head over a loop in the system, 

<math display="inline" id="Hardy_Cross_method:7">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Σ</mi>
   <mi>r</mi>
   <msup>
    <mi>Q</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Σ</ci>
    <ci>r</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Q</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma rQ^{n}
  </annotation>
 </semantics>
</math>

 would be equal to zero. However, if the initial guess is not correct, then the change in head will be non-zero and a change in flow, 

<math display="inline" id="Hardy_Cross_method:8">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta Q
  </annotation>
 </semantics>
</math>


 must be applied. The new flow rate, 

<math display="inline" id="Hardy_Cross_method:9">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>Q</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>Q</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Q</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>Q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=Q_{0}+\Delta Q
  </annotation>
 </semantics>
</math>

 is the sum of the old flow rate and some change in flow rate such that the changed in head over the loop is zero. The sum of the change in head over the new loop will then be 

<math display="inline" id="Hardy_Cross_method:10">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Σ</mi>
    <mi>r</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>Q</mi>
        <mn>0</mn>
       </msub>
       <mo>+</mo>
       <mrow>
        <mi mathvariant="normal">Δ</mi>
        <mi>Q</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Σ</ci>
     <ci>r</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>Q</ci>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma r(Q_{0}+\Delta Q)^{n}=0
  </annotation>
 </semantics>
</math>

.</p>

<p>The value of 

<math display="inline" id="Hardy_Cross_method:11">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Σ</mi>
   <mi>r</mi>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>Q</mi>
       <mn>0</mn>
      </msub>
      <mo>+</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>Q</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Σ</ci>
    <ci>r</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <ci>Q</ci>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma r(Q_{0}+\Delta Q)^{n}
  </annotation>
 </semantics>
</math>

 can be approximated using the <a href="Taylor_expansion" title="wikilink">Taylor expansion</a>.</p>

<p>

<math display="block" id="Hardy_Cross_method:12">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Σ</mi>
    <mi>r</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>Q</mi>
        <mn>0</mn>
       </msub>
       <mo>+</mo>
       <mrow>
        <mi mathvariant="normal">Δ</mi>
        <mi>Q</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Σ</mi>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msubsup>
       <mi>Q</mi>
       <mn>0</mn>
       <mi>n</mi>
      </msubsup>
      <mo>+</mo>
      <mrow>
       <mi>n</mi>
       <msubsup>
        <mi>Q</mi>
        <mn>0</mn>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msubsup>
       <mi mathvariant="normal">Δ</mi>
       <mi>Q</mi>
      </mrow>
      <mo>+</mo>
      <mi mathvariant="normal">…</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>normal-Σ</ci>
      <ci>r</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <times></times>
         <ci>normal-Δ</ci>
         <ci>Q</ci>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Σ</ci>
      <ci>r</ci>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <ci>n</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Q</ci>
          <cn type="integer">0</cn>
         </apply>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-Δ</ci>
        <ci>Q</ci>
       </apply>
       <ci>normal-…</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma r(Q_{0}+\Delta Q)^{n}=\Sigma r(Q_{0}^{n}+nQ_{0}^{n-1}\Delta Q+...)=0
  </annotation>
 </semantics>
</math>

</p>

<p>For a small 

<math display="inline" id="Hardy_Cross_method:13">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta Q
  </annotation>
 </semantics>
</math>


 compared to 

<math display="inline" id="Hardy_Cross_method:14">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{0}
  </annotation>
 </semantics>
</math>

 the additional terms vanish, leaving:</p>

<p>

<math display="block" id="Hardy_Cross_method:15">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Σ</mi>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msubsup>
       <mi>Q</mi>
       <mn>0</mn>
       <mi>n</mi>
      </msubsup>
      <mo>+</mo>
      <mrow>
       <mi>n</mi>
       <msubsup>
        <mi>Q</mi>
        <mn>0</mn>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msubsup>
       <mi mathvariant="normal">Δ</mi>
       <mi>Q</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Σ</ci>
     <ci>r</ci>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-Δ</ci>
       <ci>Q</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma r(Q_{0}^{n}+nQ_{0}^{n-1}\Delta Q)=0
  </annotation>
 </semantics>
</math>

</p>

<p>And solving for 

<math display="inline" id="Hardy_Cross_method:16">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta Q
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Hardy_Cross_method:17">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Σ</mi>
    <mi>r</mi>
    <msubsup>
     <mi>Q</mi>
     <mn>0</mn>
     <mi>n</mi>
    </msubsup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi mathvariant="normal">Σ</mi>
     <mi>n</mi>
     <mi>r</mi>
     <msubsup>
      <mi>Q</mi>
      <mn>0</mn>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mi mathvariant="normal">Δ</mi>
     <mi>Q</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Σ</ci>
     <ci>r</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>normal-Σ</ci>
      <ci>n</ci>
      <ci>r</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-Δ</ci>
      <ci>Q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma rQ_{0}^{n}=-\Sigma nrQ_{0}^{n-1}\Delta Q
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Hardy_Cross_method:18">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>Q</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <mi mathvariant="normal">Σ</mi>
      <mi>r</mi>
      <msubsup>
       <mi>Q</mi>
       <mn>0</mn>
       <mi>n</mi>
      </msubsup>
     </mrow>
     <mrow>
      <mi mathvariant="normal">Σ</mi>
      <mi>n</mi>
      <mi>r</mi>
      <msubsup>
       <mi>Q</mi>
       <mn>0</mn>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>Q</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>normal-Σ</ci>
       <ci>r</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Σ</ci>
       <ci>n</ci>
       <ci>r</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta Q=-\frac{\Sigma rQ_{0}^{n}}{\Sigma nrQ_{0}^{n-1}}
  </annotation>
 </semantics>
</math>

</p>

<p>The change in flow that will balance the head over the loop is approximated by 

<math display="inline" id="Hardy_Cross_method:19">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>Q</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <mi mathvariant="normal">Σ</mi>
      <mi>r</mi>
      <msubsup>
       <mi>Q</mi>
       <mn>0</mn>
       <mi>n</mi>
      </msubsup>
     </mrow>
     <mrow>
      <mi mathvariant="normal">Σ</mi>
      <mi>n</mi>
      <mi>r</mi>
      <msubsup>
       <mi>Q</mi>
       <mn>0</mn>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>Q</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>normal-Σ</ci>
       <ci>r</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Σ</ci>
       <ci>n</ci>
       <ci>r</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta Q=-\frac{\Sigma rQ_{0}^{n}}{\Sigma nrQ_{0}^{n-1}}
  </annotation>
 </semantics>
</math>

. However, this is only an approximation due to the terms that were ignored from the <a href="Taylor_expansion" title="wikilink">Taylor expansion</a>. The change in head over the loop may not be zero, but it will be smaller than the initial guess. Multiple iterations of finding a new 

<math display="inline" id="Hardy_Cross_method:20">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta Q
  </annotation>
 </semantics>
</math>

 will approximate to the correct solution.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h4 id="process">Process</h4>

<p>The method is as follows:</p>
<ol>
<li>Guess the flows in each pipe, making sure that the <em>total in flow</em> is equal to the <em>total out flow</em> at each junction. <em>(The guess doesn't have to be good, but a good guess will reduce the time it takes to find the solution.)</em></li>
<li>Determine each closed loop in the system</li>
<li>For each loop, determine the clockwise <a href="Hydraulic_head" title="wikilink">head losses</a> and counter-clockwise head losses. Head loss in each pipe are calculated using 

<math display="inline" id="Hardy_Cross_method:21">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>f</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>r</mi>
    <msup>
     <mi>Q</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>r</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Q</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{f}=rQ^{n}
  </annotation>
 </semantics>
</math>

. Clockwise head losses are from flows in the clockwise direction and likewise for counter-clockwise.</li>
<li>Determine the total head loss in the loop, 

<math display="inline" id="Hardy_Cross_method:22">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Σ</mi>
   <mi>r</mi>
   <msup>
    <mi>Q</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Σ</ci>
    <ci>r</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Q</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma rQ^{n}
  </annotation>
 </semantics>
</math>

, by subtracting the counter-clockwise head loss from the clockwise head loss.</li>
<li>For each loop, find 

<math display="inline" id="Hardy_Cross_method:23">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Σ</mi>
   <mi>n</mi>
   <mi>r</mi>
   <msup>
    <mi>Q</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Σ</ci>
    <ci>n</ci>
    <ci>r</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Q</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma nrQ^{n-1}
  </annotation>
 </semantics>
</math>


 without reference to direction (all values should be positive).</li>
<li>The change in flow is equal to 

<math display="inline" id="Hardy_Cross_method:24">
 <semantics>
  <mfrac>
   <mrow>
    <mi mathvariant="normal">Σ</mi>
    <mi>r</mi>
    <msup>
     <mi>Q</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mrow>
    <mi mathvariant="normal">Σ</mi>
    <mi>n</mi>
    <mi>r</mi>
    <msup>
     <mi>Q</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>normal-Σ</ci>
     <ci>r</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Q</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Σ</ci>
     <ci>n</ci>
     <ci>r</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Q</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\Sigma rQ^{n}}{\Sigma nrQ^{n-1}}
  </annotation>
 </semantics>
</math>

.</li>
<li>If the change in flow is positive, apply it to all pipes of the loop in the counter-clockwise direction. If the change in flow is negative, apply it to all pipes of the loop in the clockwise direction.</li>
<li>Continue from step 3 until the change in flow is within a satisfactory range.</li>
</ol>
<h3 id="method-of-balancing-flows-section-incomplete">Method of balancing flows (section incomplete)</h3>

<p>The method of balancing flows uses an initial guess that satisfies continuity of potential over each loop and then balances the flows until continuity of flow is also achieved at each junction.</p>
<h4 id="process-1">Process</h4>
<h2 id="advantages-of-the-hardy-cross-method">Advantages of the Hardy Cross method</h2>
<h3 id="simple-math">Simple math</h3>

<p>The Hardy Cross method is useful because it relies on only simple math, circumventing the need to solve a system of equations. Without the Hardy Cross methods, engineers would have to solve complex systems of equations with variable exponents that cannot easily be solved by hand.</p>
<h3 id="self-correcting">Self correcting</h3>

<p>The Hardy Cross method iteratively corrects for the mistakes in the initial guess used to solve the problem.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> Subsequent mistakes in calculation are also iteratively corrected. If the method is followed correctly, the proper flow in each pipe can still be found if small mathematical errors are consistently made in the process. As long as the last few iterations are done with attention to detail, the solution will still be correct. In fact, it is possible to intentionally leave off decimals in the early iterations of the method to run the calculations faster.</p>
<h2 id="example">Example</h2>

<p> The Hardy Cross method can be used to calculate the flow distribution in a pipe network. Consider the example of a simple pipe flow network shown at the right. For this example, the in and out flows will be 10 liters per second. We will consider n to be 2, and the head loss per unit flow <em>r</em>, and initial flow guess for each pipe as follows:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Pipe</p></th>
<th style="text-align: left;">
<p>Q12</p></th>
<th style="text-align: left;">
<p>Q13</p></th>
<th style="text-align: left;">
<p>Q23</p></th>
<th style="text-align: left;">
<p>Q24</p></th>
<th style="text-align: left;">
<p>Q34</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>r</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Q guess (L/s)</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>5</p></td>
</tr>
</tbody>
</table>

<p>We solve the network by method of balancing heads, following the steps outlined in method process above.</p>

<p>1. The initial guesses are set up so that continuity of flow is maintained at each junction in the network.</p>

<p>2. The loops of the system are identified as loop 1-2-3 and loop 2-3-4.</p>

<p>3. The head losses in each pipe are determined.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Loop 1-2-3</p></th>
<th style="text-align: left;">
<p>Q12</p></th>
<th style="text-align: left;">
<p>Q13</p></th>
<th style="text-align: left;">
<p>Q23</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Head loss = 

<math display="inline" id="Hardy_Cross_method:25">
 <semantics>
  <mrow>
   <mi>r</mi>
   <msup>
    <mi>Q</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Q</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   rQ^{2}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>25</p></td>
<td style="text-align: left;">
<p>125</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Direction</p></td>
<td style="text-align: left;">
<p>Clockwise</p></td>
<td style="text-align: left;">
<p>Counter-clockwise</p></td>
<td style="text-align: left;">
<p>Clockwise</p></td>
</tr>
</tbody>
</table>

<p>For loop 1-2-3, the sum of the clockwise head losses is 25 and the sum of the counter-clockwise head losses is 125.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Loop 2-3-4</p></th>
<th style="text-align: left;">
<p>Q23</p></th>
<th style="text-align: left;">
<p>Q24</p></th>
<th style="text-align: left;">
<p>Q34</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Head loss = 

<math display="inline" id="Hardy_Cross_method:26">
 <semantics>
  <mrow>
   <mi>r</mi>
   <msup>
    <mi>Q</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Q</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   rQ^{2}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>125</p></td>
<td style="text-align: left;">
<p>25</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Direction</p></td>
<td style="text-align: left;">
<p>Counter-clockwise</p></td>
<td style="text-align: left;">
<p>Clockwise</p></td>
<td style="text-align: left;">
<p>Counter-clockwise</p></td>
</tr>
</tbody>
</table>

<p>For loop 2-3-4, the sum of the clockwise head losses is 125 and the sum of the counter-clockwise head losses is 25.</p>

<p>4. The total clockwise head loss in loop 1-2-3 is 

<math display="inline" id="Hardy_Cross_method:27">
 <semantics>
  <mrow>
   <mrow>
    <mn>25</mn>
    <mo>-</mo>
    <mn>125</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>100</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <cn type="integer">25</cn>
     <cn type="integer">125</cn>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">100</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   25-125=-100
  </annotation>
 </semantics>
</math>

. The total clockwise head loss in loop 2-3-4 is 

<math display="inline" id="Hardy_Cross_method:28">
 <semantics>
  <mrow>
   <mrow>
    <mn>125</mn>
    <mo>-</mo>
    <mn>25</mn>
   </mrow>
   <mo>=</mo>
   <mn>100</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <cn type="integer">125</cn>
     <cn type="integer">25</cn>
    </apply>
    <cn type="integer">100</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   125-25=100
  </annotation>
 </semantics>
</math>


.</p>

<p>5. The value of 

<math display="inline" id="Hardy_Cross_method:29">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Σ</mi>
   <mi>n</mi>
   <mi>r</mi>
   <msup>
    <mi>Q</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Σ</ci>
    <ci>n</ci>
    <ci>r</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Q</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma nrQ^{n-1}
  </annotation>
 </semantics>
</math>

 is determined for each loop. It is found to be 60 in both loops (due to symmetry), as shown in the figure.</p>

<p>6. The change in flow is found for each loop using the equation 

<math display="inline" id="Hardy_Cross_method:30">
 <semantics>
  <mfrac>
   <mrow>
    <mi mathvariant="normal">Σ</mi>
    <mi>r</mi>
    <msup>
     <mi>Q</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mrow>
    <mi mathvariant="normal">Σ</mi>
    <mi>n</mi>
    <mi>r</mi>
    <msup>
     <mi>Q</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>normal-Σ</ci>
     <ci>r</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Q</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Σ</ci>
     <ci>n</ci>
     <ci>r</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Q</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\Sigma rQ^{n}}{\Sigma nrQ^{n-1}}
  </annotation>
 </semantics>
</math>

. For loop 1-2-3, the change in flow is equal to 

<math display="inline" id="Hardy_Cross_method:31">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mn>100</mn>
     <mo>/</mo>
     <mn>60</mn>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>1.66</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <cn type="integer">100</cn>
      <cn type="integer">60</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="float">1.66</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -100/60=-1.66
  </annotation>
 </semantics>
</math>

 and for loop 2-3-4 the change in flow is equal to 

<math display="inline" id="Hardy_Cross_method:32">
 <semantics>
  <mrow>
   <mrow>
    <mn>100</mn>
    <mo>/</mo>
    <mn>60</mn>
   </mrow>
   <mo>=</mo>
   <mn>1.66</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">100</cn>
     <cn type="integer">60</cn>
    </apply>
    <cn type="float">1.66</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   100/60=1.66
  </annotation>
 </semantics>
</math>

.</p>

<p>7. The change in flow is applied across the loops. For loop 1-2-3, the change in flow is negative so its absolute value is applied in the clockwise direction. For loop 2-3-4, the change in flow is positive so its absolute value is applied in the counter-clockwise direction. For pipe 2-4, which is in both loops, the changes in flow are cumulative.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Pipe</p></th>
<th style="text-align: left;">
<p>Q12</p></th>
<th style="text-align: left;">
<p>Q13</p></th>
<th style="text-align: left;">
<p>Q23</p></th>
<th style="text-align: left;">
<p>Q24</p></th>
<th style="text-align: left;">
<p>Q34</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Q (L/s)</p></td>
<td style="text-align: left;">
<p>6.66</p></td>
<td style="text-align: left;">
<p>3.33</p></td>
<td style="text-align: left;">
<p>3.33</p></td>
<td style="text-align: left;">
<p>3.33</p></td>
<td style="text-align: left;">
<p>6.66</p></td>
</tr>
</tbody>
</table>

<p>The process then repeats from step 3 until the change in flow becomes sufficiently small or goes to zero.</p>

<p>3. The total head loss in Loop 1-2-3 is</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Loop 1-2-3</p></th>
<th style="text-align: left;">
<p>Q12</p></th>
<th style="text-align: left;">
<p>Q13</p></th>
<th style="text-align: left;">
<p>Q23</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Head loss = 

<math display="inline" id="Hardy_Cross_method:33">
 <semantics>
  <mrow>
   <mi>r</mi>
   <msup>
    <mi>Q</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Q</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   rQ^{2}
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p>44.4</p></td>
<td style="text-align: left;">
<p>55.5</p></td>
<td style="text-align: left;">
<p>11.1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Direction</p></td>
<td style="text-align: left;">
<p>Clockwise</p></td>
<td style="text-align: left;">
<p>Counter-clockwise</p></td>
<td style="text-align: left;">
<p>Clockwise</p></td>
</tr>
</tbody>
</table>

<p>Notice that the clockwise head loss is equal to the counter-clockwise head loss. This means that the flow in this loop is balanced and the flow rates are correct. The total head loss in loop 2-3-4 will also be balanced (again due to symmetry).</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Loop 2-3-4</p></th>
<th style="text-align: left;">
<p>Q23</p></th>
<th style="text-align: left;">
<p>Q24</p></th>
<th style="text-align: left;">
<p>Q34</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Head loss = 

<math display="inline" id="Hardy_Cross_method:34">
 <semantics>
  <mrow>
   <mi>r</mi>
   <msup>
    <mi>Q</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Q</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   rQ^{2}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>11.1</p></td>
<td style="text-align: left;">
<p>55.5</p></td>
<td style="text-align: left;">
<p>44.4</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Direction</p></td>
<td style="text-align: left;">
<p>Counter-clockwise</p></td>
<td style="text-align: left;">
<p>Clockwise</p></td>
<td style="text-align: left;">
<p>Counter-clockwise</p></td>
</tr>
</tbody>
</table>

<p>In this case, the method found the correct solution in one iteration. For other networks, it may take multiple iterations until the flows in the pipes are correct or approximately correct.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Moment_distribution_method" title="wikilink">Moment distribution method</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Hydraulic_engineering" title="wikilink">Category:Hydraulic engineering</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15"></li>
</ol>
</section>
</body>
</html>
