   String operations      String operations   In computer science , in the area of formal language theory , frequent use is made of a variety of string functions ; however, the notation used is different from that used on computer programming , and some commonly used functions in the theoretical realm are rarely used when programming. This article defines some of these basic terms.  Strings and languages  A string is a finite sequence of characters. The empty string is denoted by   ε   ε   \varepsilon   . The concatenation of two string   s   s   s   and   t   t   t   is denoted by    s  ⋅  t     normal-⋅  s  t    s\cdot t   , or shorter by    s  t      s  t    st   . Concatenating with the empty string makes no difference     s  ⋅  ε   =  s  =   ε  ⋅  s          normal-⋅  s  ε   s        normal-⋅  ε  s      s\cdot\varepsilon=s=\varepsilon\cdot s   . Concatenation of strings is associative     s  ⋅   (   t  ⋅  u   )    =    (   s  ⋅  t   )   ⋅  u        normal-⋅  s   normal-⋅  t  u     normal-⋅   normal-⋅  s  t   u     s\cdot(t\cdot u)=(s\cdot t)\cdot u   .  For example,      (    ⟨  b  ⟩   ⋅   ⟨  l  ⟩    )   ⋅   (   ε  ⋅   ⟨   a  h   ⟩    )    =    ⟨   b  l   ⟩   ⋅   ⟨   a  h   ⟩    =   ⟨   b  l  a  h   ⟩          normal-⋅   normal-⋅   delimited-⟨⟩  b    delimited-⟨⟩  l     normal-⋅  ε   delimited-⟨⟩    a  h       normal-⋅   delimited-⟨⟩    b  l     delimited-⟨⟩    a  h           delimited-⟨⟩    b  l  a  h       (\langle b\rangle\cdot\langle l\rangle)\cdot(\varepsilon\cdot\langle ah\rangle%
 )=\langle bl\rangle\cdot\langle ah\rangle=\langle blah\rangle   .  A language is a finite or infinite set of strings. Besides the usual set operations like union, intersection etc., concatenation can be applied to languages: if both   S   S   S   and   T   T   T   are languages, their concatenation    S  ⋅  T     normal-⋅  S  T    S\cdot T   is defined as the set of concatenations of any string from   S   S   S   and any string from   T   T   T   , formally     S  ⋅  T   =   {   s  ⋅  t   ∣   s  ∈   S  ∧  t   ∈  T   }        normal-⋅  S  T    conditional-set   normal-⋅  s  t       s    S  t        T       S\cdot T=\{s\cdot t\mid s\in S\land t\in T\}   . Again, the concatenation dot   ⋅   normal-⋅   \cdot   is often omitted for shortness.  The language    {  ε  }     ε    \{\varepsilon\}   consisting of just the empty string is to be distinguished from the empty language    {  }      \{\}   . Concatenating any language with the former doesn't make any change     S  ⋅   {  ε  }    =  S  =    {  ε  }   ⋅  S          normal-⋅  S   ε    S        normal-⋅   ε   S      S\cdot\{\varepsilon\}=S=\{\varepsilon\}\cdot S   , while concatenating with the latter always yields the empty language     S  ⋅   {  }    =   {  }   =    {  }   ⋅  S          normal-⋅  S           normal-⋅   S      S\cdot\{\}=\{\}=\{\}\cdot S   . Concatenation of languages is associative     S  ⋅   (   T  ⋅  U   )    =    (   S  ⋅  T   )   ⋅  U        normal-⋅  S   normal-⋅  T  U     normal-⋅   normal-⋅  S  T   U     S\cdot(T\cdot U)=(S\cdot T)\cdot U   .  For example, abbreviating    D  =   {   ⟨  0  ⟩   ,   ⟨  1  ⟩   ,   ⟨  2  ⟩   ,   ⟨  3  ⟩   ,   ⟨  4  ⟩   ,   ⟨  5  ⟩   ,   ⟨  6  ⟩   ,   ⟨  7  ⟩   ,   ⟨  8  ⟩   ,   ⟨  9  ⟩   }       D    delimited-⟨⟩  0    delimited-⟨⟩  1    delimited-⟨⟩  2    delimited-⟨⟩  3    delimited-⟨⟩  4    delimited-⟨⟩  5    delimited-⟨⟩  6    delimited-⟨⟩  7    delimited-⟨⟩  8    delimited-⟨⟩  9      D=\{\langle 0\rangle,\langle 1\rangle,\langle 2\rangle,\langle 3\rangle,%
 \langle 4\rangle,\langle 5\rangle,\langle 6\rangle,\langle 7\rangle,\langle 8%
 \rangle,\langle 9\rangle\}   , the set of all three-digit decimal numbers is obtained as    D  ⋅  D  ⋅  D     normal-⋅  D  D  D    D\cdot D\cdot D   . The set of all decimal numbers of arbitrary length is an example for an infinite language.  Alphabet of a string  The alphabet of a string is the set of all of the characters that occur in a particular string. If s is a string, its alphabet is denoted by      Alph   (  s  )      Alph  s    \operatorname{Alph}(s)     The alphabet of a language    S   S   S   is the set of all characters that occur in any string of   S   S   S   , formally:     Alph   (  S  )    =    ⋃   s  ∈  S     Alph   (  s  )          Alph  S     subscript     s  S     Alph  s      \operatorname{Alph}(S)=\bigcup_{s\in S}\operatorname{Alph}(s)   .  For example, the set    {   ⟨  a  ⟩   ,   ⟨  c  ⟩   ,   ⟨  o  ⟩   }      delimited-⟨⟩  a    delimited-⟨⟩  c    delimited-⟨⟩  o     \{\langle a\rangle,\langle c\rangle,\langle o\rangle\}   is the alphabet of the string    ⟨   c  a  c  a  o   ⟩     delimited-⟨⟩    c  a  c  a  o     \langle cacao\rangle   , and the above    D   D   D   is the alphabet of the above language    D  ⋅  D  ⋅  D     normal-⋅  D  D  D    D\cdot D\cdot D   as well as of the language of all decimal numbers.  String substitution  Let L be a language , and let Σ be its alphabet. A string substitution or simply a substitution is a mapping f that maps letters in Σ to languages (possibly in a different alphabet). Thus, for example, given a letter a ∈ Σ, one has f ( a )= L a where L a ⊆ Δ * is some language whose alphabet is Δ. This mapping may be extended to strings as   f (ε)=ε   for the empty string ε, and   f ( sa )= f ( s ) f ( a )   for string s ∈ L . String substitutions may be extended to entire languages as 1       f   (  L  )    =    ⋃   s  ∈  L     f   (  s  )           f  L     subscript     s  L      f  s      f(L)=\bigcup_{s\in L}f(s)     Regular languages are closed under string substitution. That is, if each letter of a regular language is substituted by another regular language, the result is still a regular language. 2 Similarly, context-free languages are closed under string substitution. 3 4  A simple example is the conversion f uc (.) to upper case, which may be defined e.g. as follows:      letter   mapped to language   remark       x   f uc ( x )      ‹ a ›   { ‹ A › }   map lower-case char to corresponding upper-case char     ‹ A ›   { ‹ A › }   map upper-case char to itself     ‹ ß ›   { ‹ SS › }   no upper-case char available, map to two-char string     ‹0›   { ε }   map digit to empty string     ‹!›   { }   forbid punctuation, map to empty language     ...    similar for other chars     For the extension of f uc to strings, we have e.g.   f uc (‹Straße›) = {‹S›} ⋅ {‹T›} ⋅ {‹R›} ⋅ {‹A›} ⋅ {‹SS›} ⋅ {‹E›} = {‹STRASSE›},  f uc (‹u2›) = {‹U›} ⋅ {ε} = {‹U›}, and  f uc (‹Go!›) = {‹G›} ⋅ {‹O›} ⋅ {} = {}.   For the extension of f uc to languages, we have e.g.   f uc ({ ‹Straße›, ‹u2›, ‹Go!› }) = { ‹STRASSE› } ∪ { ‹U› } ∪ { } = { ‹STRASSE›, ‹U› }.   Another example is the conversion of an EBCDIC -encoded string to ASCII .  String homomorphism  A string homomorphism (often referred to simply as a homomorphism in formal language theory ) is a string substitution such that each letter is replaced by a single string. That is, f ( a )= s , where s is a string, for each letter a . 5 6  String homomorphisms are monoid morphisms on the free monoid , preserving the binary operation of string concatenation . Given a language L , the set f ( L ) is called the homomorphic image of L . The inverse homomorphic image of a string s is defined as   f −1 ( s ) = { w | f ( w )= s }   while the inverse homomorphic image of a language L is defined as   f −1 ( L ) = { s | f ( s ) ∈ L }   In general, f ( f −1 ( L )) ≠ L , while one does have   f ( f −1 ( L )) ⊆ L    and   L ⊆ f −1 ( f ( L ))   for any language L .  The class of regular languages is closed under homomorphisms and inverse homomorphisms. 7 Similarly, the context-free languages are closed under homomorphisms 8 and inverse homomorphisms. 9  A string homomorphism is said to be ε-free (or e-free) if f ( a ) ≠ ε for all a in the alphabet Σ. Simple single-letter substitution ciphers are examples of (ε-free) string homomorphisms.  An example string homomorphism g uc can also be obtained by defining similar to the above substitution: g uc (‹a›) = ‹A›, ..., g uc (‹0›) = ε, but letting g uc undefined on punctuation chars.  Examples for inverse homomorphic images are   g uc −1 ({ ‹SSS› }) = { ‹sss›, ‹sß›, ‹ßs› }, since g uc (‹sss›) = g uc (‹sß›) = g uc (‹ßs›) = ‹SSS›, and  g uc −1 ({ ‹A›, ‹bb› }) = { ‹a› }, since g uc (‹a›) = ‹A›, while ‹bb› cannot be reached by g uc .   For the latter language, g uc ( g uc −1 ({ ‹A›, ‹bb› })) = g uc ({ ‹a› }) = { ‹A› } ≠ { ‹A›, ‹bb› }. The homomorphism g uc is not ε-free, since it maps e.g. ‹0› to ε.  String projection  If s is a string, and   Σ   normal-Σ   \Sigma   is an alphabet, the string projection of s is the string that results by removing all letters which are not in   Σ   normal-Σ   \Sigma   . It is written as     π  Σ    (  s  )        subscript  π  normal-Σ   s    \pi_{\Sigma}(s)\,   . It is formally defined by removal of letters from the right hand side:        π  Σ    (  s  )    =   {     ε      if  s   =   ε  the empty string          π  Σ    (  t  )        if  s   =   t  a  and  a   ∉  Σ         π  Σ    (  t  )   a       if  s   =   t  a  and  a   ∈  Σ              subscript  π  normal-Σ   s    cases  ε      if  s     ε  the empty string       subscript  π  normal-Σ   t         if  s     t  a  and  a        normal-Σ       subscript  π  normal-Σ   t  a         if  s     t  a  and  a        normal-Σ       \pi_{\Sigma}(s)=\begin{cases}\varepsilon&\mbox{if }s=\varepsilon\mbox{ the %
 empty string}\\
 \pi_{\Sigma}(t)&\mbox{if }s=ta\mbox{ and }a\notin\Sigma\\
 \pi_{\Sigma}(t)a&\mbox{if }s=ta\mbox{ and }a\in\Sigma\end{cases}     Here   ε   ε   \varepsilon   denotes the empty string . The projection of a string is essentially the same as a projection in relational algebra .  String projection may be promoted to the projection of a language . Given a formal language  L , its projection is given by        π  Σ    (  L  )    =   {    π  Σ    (  s  )    |   s  ∈  L   }          subscript  π  normal-Σ   L    conditional-set     subscript  π  normal-Σ   s     s  L      \pi_{\Sigma}(L)=\{\pi_{\Sigma}(s)\ |\ s\in L\}     Right quotient  The right quotient of a letter a from a string s is the truncation of the letter a in the string s , from the right hand side. It is denoted as    s  /  a      s  a    s/a   . If the string does not have a on the right hand side, the result is the empty string. Thus:        (   s  a   )   /  b   =   {     s      if  a   =  b       ε      if  a   ≠  b               s  a   b    cases  s      if  a   b   ε      if  a   b      (sa)/b=\begin{cases}s&\mbox{if }a=b\\
 \varepsilon&\mbox{if }a\neq b\end{cases}     The quotient of the empty string may be taken:       ε  /  a   =  ε        ε  a   ε    \varepsilon/a=\varepsilon     Similarly, given a subset    S  ⊂  M      S  M    S\subset M   of a monoid   M   M   M   , one may define the quotient subset as       S  /  a   =   {   s  ∈   M    |    s  a   ∈  S   }         S  a    conditional-set    s  M       s  a   S      S/a=\{s\in M\ |\ sa\in S\}     Left quotients may be defined similarly, with operations taking place on the left of a string.  Syntactic relation  The right quotient of a subset    S  ⊂  M      S  M    S\subset M   of a monoid   M   M   M   defines an equivalence relation , called the right syntactic relation of S . It is given by        ∼  S    =   {   (  s  ,  t  )   ∈  M  ×   M   |  S  /  s  =  S  /  t  }      fragments   subscript  similar-to  S     fragments  normal-{   fragments  normal-(  s  normal-,  t  normal-)    M   M  normal-|  S   s   S   t  normal-}     \sim_{S}\;\,=\,\{(s,t)\in M\times M\ |\ S/s=S/t\}     The relation is clearly of finite index (has a finite number of equivalence classes) if and only if the family right quotients is finite; that is, if      {   S  /   m    |   m  ∈  M   }     conditional-set    S  m     m  M     \{S/m\ |\ m\in M\}     is finite. In this case, S is a recognizable language , that is, a language that can be recognized by a finite state automaton . This is discussed in greater detail in the article on syntactic monoids .  Right cancellation  The right cancellation of a letter a from a string s is the removal of the first occurrence of the letter a in the string s , starting from the right hand side. It is denoted as    s  ÷  a      s  a    s\div a   and is recursively defined as        (   s  a   )   ÷  b   =   {     s      if  a   =  b         (   s  ÷  b   )   a       if  a   ≠  b               s  a   b    cases  s      if  a   b       s  b   a       if  a   b      (sa)\div b=\begin{cases}s&\mbox{if }a=b\\
 (s\div b)a&\mbox{if }a\neq b\end{cases}     The empty string is always cancellable:       ε  ÷  a   =  ε        ε  a   ε    \varepsilon\div a=\varepsilon     Clearly, right cancellation and projection commute :         π  Σ    (  s  )    ÷  a   =    π  Σ    (   s  ÷  a   )             subscript  π  normal-Σ   s   a      subscript  π  normal-Σ     s  a      \pi_{\Sigma}(s)\div a=\pi_{\Sigma}(s\div a)     Prefixes  The prefixes of a string is the set of all prefixes to a string, with respect to a given language:       Pref  L    (  s  )   =   {   t   |  s  =  t  u  for  t  ,  u  ∈  Alph    (  L  )   *   }      fragments   subscript  Pref  L    fragments  normal-(  s  normal-)     fragments  normal-{  t  normal-|  s   t  u  for  t  normal-,  u   Alph   superscript   fragments  normal-(  L  normal-)     normal-}     \operatorname{Pref}_{L}(s)=\{t\ |\ s=tu\mbox{ for }t,u\in\operatorname{Alph}(L%
 )^{*}\}     here    s  ∈  L      s  L    s\in L   .  The prefix closure of a language is      Pref   (  L  )   =   ⋃   s  ∈  L     Pref  L    (  s  )   =   {   t   |  s  =  t  u  ;  s  ∈  L  ;  t  ,  u  ∈  Alph    (  L  )   *   }      fragments  Pref   fragments  normal-(  L  normal-)     subscript     s  L     subscript  Pref  L    fragments  normal-(  s  normal-)     fragments  normal-{  t  normal-|  s   t  u  normal-;  s   L  normal-;  t  normal-,  u   Alph   superscript   fragments  normal-(  L  normal-)     normal-}     \operatorname{Pref}(L)=\bigcup_{s\in L}\operatorname{Pref}_{L}(s)=\left\{t\ |%
 \ s=tu;s\in L;t,u\in\operatorname{Alph}(L)^{*}\right\}     Example:     L  =    {   a  b  c   }   then   Pref   (  L  )     =   {  ε  ,  a  ,   a  b   ,   a  b  c   }         L       a  b  c    then   Pref  L          ε  a    a  b     a  b  c       L=\left\{abc\right\}\mbox{ then }\operatorname{Pref}(L)=\left\{\varepsilon,a,%
 ab,abc\right\}     A language is called prefix closed if     Pref   (  L  )    =  L       Pref  L   L    \operatorname{Pref}(L)=L   .  The prefix closure operator is idempotent :       Pref   (   Pref   (  L  )    )    =   Pref   (  L  )         Pref   Pref  L     Pref  L     \operatorname{Pref}(\operatorname{Pref}(L))=\operatorname{Pref}(L)     The prefix relation is a binary relation    ⊑   square-image-of-or-equals   \sqsubseteq   such that    s  ⊑  t     square-image-of-or-equals  s  t    s\sqsubseteq t   if and only if    s  ∈    Pref  L    (  t  )        s    subscript  Pref  L   t     s\in\operatorname{Pref}_{L}(t)   . This relation is a particular example of a prefix order .  See also   Comparison of programming languages (string functions)  Levi's lemma  String (computer science) — definition and implementation of more basic operations on strings   Notes  References    (See chapter 3.)   "  Category:Formal languages  Category:Relational algebra  Operations     Hopcroft, Ullman (1979), Sect.3.2, p.60 ↩  Hopcroft, Ullman (1979), Sect.3.2, Theorem 3.4, p.60 ↩  Hopcroft, Ullman (1979), Sect.6.2, Theorem 6.2, p.131 ↩  Although every regular language is also context-free, the previous theorem is not implied by the current one, since the former yields a shaper result for regular languages. ↩  Strictly formally, a homomorphism yields a language consisting of just one string, i.e. f ( a ) = { s }. ↩  Hopcroft, Ullman (1979), Sect.3.2, p.60-61 ↩  Hopcroft, Ullman (1979), Sect.3.2, Theorem 3.5, p.61 ↩  This follows from the above-mentioned closure under arbitrary substitutions. ↩  Hopcroft, Ullman (1979), Sect.6.2, Theorem 6.3, p.132 ↩     