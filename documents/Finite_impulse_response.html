<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="930">Finite impulse response</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Finite impulse response</h1>
<hr/>

<p>In <a href="signal_processing" title="wikilink">signal processing</a>, a <strong>finite impulse response (FIR)</strong> filter is a <a href="filter_(signal_processing)" title="wikilink">filter</a> whose <a href="impulse_response" title="wikilink">impulse response</a> (or response to any finite length input) is of <em>finite</em> duration, because it settles to zero in finite time. This is in contrast to <a href="infinite_impulse_response" title="wikilink">infinite impulse response</a> (IIR) filters, which may have internal feedback and may continue to respond indefinitely (usually decaying).</p>

<p>The <a href="impulse_response" title="wikilink">impulse response</a> (that is, the output in response to a <a href="Kronecker_delta" title="wikilink">Kronecker delta</a> input) of an Nth-order discrete-time FIR filter lasts exactly <em>N</em> + 1 samples (from first nonzero element through last nonzero element) before it then settles to zero.</p>

<p>FIR filters can be <a class="uri" href="discrete-time" title="wikilink">discrete-time</a> or <a class="uri" href="continuous-time" title="wikilink">continuous-time</a>, and <a href="Digital_data" title="wikilink">digital</a> or <a href="analog_circuits" title="wikilink">analog</a>.</p>
<h2 id="definition">Definition</h2>
<figure><b>(Figure)</b>
<figcaption>A direct form discrete-time FIR filter of order <em>N</em>. The top part is an <em>N</em>-stage delay line with <em>N</em> + 1 taps. Each unit delay is a <em>z</em><sup>−1</sup> operator in <a class="uri" href="Z-transform" title="wikilink">Z-transform</a> notation.</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>A lattice-form discrete-time FIR filter of order <em>N</em>. Each unit delay is a <em>z</em><sup>−1</sup> operator in <a class="uri" href="Z-transform" title="wikilink">Z-transform</a> notation.</figcaption>
</figure>

<p>For a <a href="causal_filter" title="wikilink">causal</a> <a class="uri" href="discrete-time" title="wikilink">discrete-time</a> FIR filter of order <em>N</em>, each value of the output sequence is a weighted sum of the most recent input values<strong>:</strong></p>

<p>
<math display="inline" id="Finite_impulse_response:0">
<semantics>
<mrow>
<mi>y</mi>
<mrow>
<mo stretchy="false">[</mo>
<mi>n</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>y</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \displaystyle y[n]
  </annotation>
</semantics>
</math>
</p>

<p>where<strong>:</strong></p>
<ul>
<li>
<math display="inline" id="Finite_impulse_response:1">
<semantics>
<mrow>
<mi>x</mi>
<mrow>
<mo stretchy="false">[</mo>
<mi>n</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>x</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle x[n]
  </annotation>
</semantics>
</math>

 is the input signal,</li>
<li>
<math display="inline" id="Finite_impulse_response:2">
<semantics>
<mrow>
<mi>y</mi>
<mrow>
<mo stretchy="false">[</mo>
<mi>n</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>y</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle y[n]
  </annotation>
</semantics>
</math>

 is the output signal,</li>
<li>
<math display="inline" id="Finite_impulse_response:3">
<semantics>
<mi>N</mi>
<annotation-xml encoding="MathML-Content">
<ci>N</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle N
  </annotation>
</semantics>
</math>

 is the filter order; an 

<math display="inline" id="Finite_impulse_response:4">
<semantics>
<mi>N</mi>
<annotation-xml encoding="MathML-Content">
<ci>N</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle N
  </annotation>
</semantics>
</math>

th-order filter has 

<math display="inline" id="Finite_impulse_response:5">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mpadded width="+1.7pt">
<mi>N</mi>
</mpadded>
<mo>+</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<plus></plus>
<ci>N</ci>
<cn type="float">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle(N\,+\,1)
  </annotation>
</semantics>
</math>

 terms on the right-hand side</li>
<li>
<math display="inline" id="Finite_impulse_response:6">
<semantics>
<msub>
<mi>b</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>b</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle b_{i}
  </annotation>
</semantics>
</math>

 is the value of the impulse response at the <em>i</em>'th instant for 

<math display="inline" id="Finite_impulse_response:7">
<semantics>
<mrow>
<mpadded width="+5pt">
<mn>0</mn>
</mpadded>
<mo rspace="7.5pt">≤</mo>
<mpadded width="+5pt">
<mi>i</mi>
</mpadded>
<mo rspace="7.5pt">≤</mo>
<mi>N</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<leq></leq>
<cn type="float">0</cn>
<ci>i</ci>
</apply>
<apply>
<leq></leq>
<share href="#.cmml">
</share>
<ci>N</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle\ 0\ \leq\ i\ \leq\ N
  </annotation>
</semantics>
</math>

 of an 

<math display="inline" id="Finite_impulse_response:8">
<semantics>
<mi>N</mi>
<annotation-xml encoding="MathML-Content">
<ci>N</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle N
  </annotation>
</semantics>
</math>

th-order FIR filter. If the filter is a direct form FIR filter then 

<math display="inline" id="Finite_impulse_response:9">
<semantics>
<msub>
<mi>b</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>b</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle b_{i}
  </annotation>
</semantics>
</math>

 is also a coefficient of the filter .</li>
</ul>

<p>This computation is also known as discrete <a class="uri" href="convolution" title="wikilink">convolution</a>.</p>

<p>The 

<math display="inline" id="Finite_impulse_response:10">
<semantics>
<mrow>
<mi>x</mi>
<mrow>
<mo stretchy="false">[</mo>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mi>i</mi>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>x</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<apply>
<minus></minus>
<ci>n</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle x[n-i]
  </annotation>
</semantics>
</math>

 in these terms are commonly referred to as <em>s</em>, based on the structure of a <a href="Digital_delay_line" title="wikilink">tapped delay line</a> that in many implementations or block diagrams provides the delayed inputs to the multiplication operations. One may speak of a <em>5th order/6-tap filter</em>, for instance.</p>

<p>The impulse response of the filter as defined is nonzero over a finite duration. Including zeros, the impulse response is the infinite sequence<strong>:</strong></p>

<p>
<math display="block" id="Finite_impulse_response:11">
<semantics>
<mrow>
<mrow>
<mi>h</mi>
<mrow>
<mo stretchy="false">[</mo>
<mi>n</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>i</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mi>N</mi>
</munderover>
<mrow>
<mrow>
<msub>
<mi>b</mi>
<mi>i</mi>
</msub>
<mo>⋅</mo>
<mi>δ</mi>
</mrow>
<mrow>
<mo stretchy="false">[</mo>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mi>i</mi>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo>{</mo>
<mtable displaystyle="true">
<mtr>
<mtd columnalign="left">
<msub>
<mi>b</mi>
<mi>n</mi>
</msub>
</mtd>
<mtd columnalign="left">
<mrow>
<mn>0</mn>
<mo>≤</mo>
<mi>n</mi>
<mo>≤</mo>
<mi>N</mi>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="left">
<mn>0</mn>
</mtd>
<mtd columnalign="left">
<mrow>
<mtext>otherwise</mtext>
<mo>.</mo>
</mrow>
</mtd>
</mtr>
</mtable>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<ci>h</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>n</ci>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>i</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<ci>N</ci>
</apply>
<apply>
<times></times>
<apply>
<ci>normal-⋅</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>b</ci>
<ci>i</ci>
</apply>
<ci>δ</ci>
</apply>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<apply>
<minus></minus>
<ci>n</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<csymbol cd="latexml">cases</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>b</ci>
<ci>n</ci>
</apply>
<apply>
<and></and>
<apply>
<leq></leq>
<cn type="integer">0</cn>
<ci>n</ci>
</apply>
<apply>
<leq></leq>
<share href="#.cmml">
</share>
<ci>N</ci>
</apply>
</apply>
<cn type="integer">0</cn>
<mtext>otherwise</mtext>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   h[n]=\sum_{i=0}^{N}b_{i}\cdot\delta[n-i]=\begin{cases}b_{n}&amp;\scriptstyle 0\leq
n%
\leq N\\
0&amp;\scriptstyle\text{otherwise}.\end{cases}
  </annotation>
</semantics>
</math>
</p>

<p>If an FIR filter is non-causal, the range of nonzero values in its impulse response can start before <em>n</em> = 0, with the defining formula appropriately generalized.</p>
<h2 id="properties">Properties</h2>

<p>An FIR filter has a number of useful properties which sometimes make it preferable to an <a href="infinite_impulse_response" title="wikilink">infinite impulse response</a> (IIR) filter. FIR filters:</p>
<ul>
<li>Require no feedback. This means that any rounding errors are not compounded by summed iterations. The same relative error occurs in each calculation. This also makes implementation simpler.</li>
<li>Are inherently <a href="BIBO_stability" title="wikilink">stable</a>, since the output is a sum of a finite number of finite multiples of the input values, so can be no greater than 

<math display="inline" id="Finite_impulse_response:12">
<semantics>
<mrow>
<mo largeop="true" symmetric="true">∑</mo>
<mrow>
<mo stretchy="false">|</mo>
<msub>
<mi>b</mi>
<mi>i</mi>
</msub>
<mo stretchy="false">|</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<sum></sum>
<apply>
<abs></abs>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>b</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle\sum|b_{i}|
  </annotation>
</semantics>
</math>

 times the largest value appearing in the input.</li>
<li>Can easily be designed to be <a href="linear_phase" title="wikilink">linear phase</a> by making the coefficient sequence symmetric. This property is sometimes desired for phase-sensitive applications, for example data communications, <a href="Audio_crossover" title="wikilink">crossover filters</a>, and <a href="Audio_mastering" title="wikilink">mastering</a>.</li>
</ul>

<p>The main disadvantage of FIR filters is that considerably more computation power in a general purpose processor is required compared to an IIR filter with similar sharpness or <a href="selectivity_(electronic)" title="wikilink">selectivity</a>, especially when low frequency (relative to the sample rate) cutoffs are needed. However many digital signal processors provide specialized hardware features to make FIR filters approximately as efficient as IIR for many applications.</p>
<h2 id="frequency-response">Frequency response</h2>

<p>The filter's effect on the sequence x[n] is described in the frequency domain by the <a href="convolution_theorem" title="wikilink">convolution theorem</a><strong>:</strong></p>

<p>
<math display="block" id="Finite_impulse_response:13">
<semantics>
<mrow>
<munder>
<munder accentunder="true">
<mrow>
<mi class="ltx_font_mathcaligraphic">ℱ</mi>
<mrow>
<mo movablelimits="false" stretchy="false">{</mo>
<mrow>
<mi>x</mi>
<mo movablelimits="false">*</mo>
<mi>h</mi>
</mrow>
<mo movablelimits="false" stretchy="false">}</mo>
</mrow>
</mrow>
<mo movablelimits="false">⏟</mo>
</munder>
<mrow>
<mi>Y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>ω</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</munder>
<mo>=</mo>
<mrow>
<munder>
<munder accentunder="true">
<mrow>
<mi class="ltx_font_mathcaligraphic">ℱ</mi>
<mrow>
<mo movablelimits="false" stretchy="false">{</mo>
<mi>x</mi>
<mo movablelimits="false" stretchy="false">}</mo>
</mrow>
</mrow>
<mo movablelimits="false">⏟</mo>
</munder>
<mrow>
<mi>X</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>ω</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</munder>
<mo>⋅</mo>
<munder>
<munder accentunder="true">
<mrow>
<mi class="ltx_font_mathcaligraphic">ℱ</mi>
<mrow>
<mo movablelimits="false" stretchy="false">{</mo>
<mi>h</mi>
<mo movablelimits="false" stretchy="false">}</mo>
</mrow>
</mrow>
<mo movablelimits="false">⏟</mo>
</munder>
<mrow>
<mi>H</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>ω</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</munder>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<ci>normal-⏟</ci>
<apply>
<times></times>
<ci>ℱ</ci>
<set>
<apply>
<times></times>
<ci>x</ci>
<ci>h</ci>
</apply>
</set>
</apply>
</apply>
<apply>
<times></times>
<ci>Y</ci>
<ci>ω</ci>
</apply>
</apply>
<apply>
<ci>normal-⋅</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<ci>normal-⏟</ci>
<apply>
<times></times>
<ci>ℱ</ci>
<set>
<ci>x</ci>
</set>
</apply>
</apply>
<apply>
<times></times>
<ci>X</ci>
<ci>ω</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<ci>normal-⏟</ci>
<apply>
<times></times>
<ci>ℱ</ci>
<set>
<ci>h</ci>
</set>
</apply>
</apply>
<apply>
<times></times>
<ci>H</ci>
<ci>ω</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \underbrace{\mathcal{F}\{x*h\}}_{Y(\omega)}=\underbrace{\mathcal{F}\{x\}}_{X(%
\omega)}\cdot\underbrace{\mathcal{F}\{h\}}_{H(\omega)}
  </annotation>
</semantics>
</math>

     and     

<math display="inline" id="Finite_impulse_response:14">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>y</mi>
<mrow>
<mo stretchy="false">[</mo>
<mi>n</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mrow>
<mi>x</mi>
<mrow>
<mo stretchy="false">[</mo>
<mi>n</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<mo>*</mo>
<mi>h</mi>
</mrow>
<mrow>
<mo stretchy="false">[</mo>
<mi>n</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msup>
<mi class="ltx_font_mathcaligraphic">ℱ</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mrow>
<mo maxsize="120%" minsize="120%">{</mo>
<mrow>
<mrow>
<mrow>
<mi>X</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>ω</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>⋅</mo>
<mi>H</mi>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>ω</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo maxsize="120%" minsize="120%">}</mo>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<ci>y</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>n</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<times></times>
<apply>
<times></times>
<ci>x</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>n</ci>
</apply>
</apply>
<ci>h</ci>
</apply>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>n</ci>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℱ</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<set>
<apply>
<times></times>
<apply>
<ci>normal-⋅</ci>
<apply>
<times></times>
<ci>X</ci>
<ci>ω</ci>
</apply>
<ci>H</ci>
</apply>
<ci>ω</ci>
</apply>
</set>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   y[n]=x[n]*h[n]=\mathcal{F}^{-1}\big\{X(\omega)\cdot H(\omega)\big\},
  </annotation>
</semantics>
</math>
</p>

<p>where operators 

<math display="inline" id="Finite_impulse_response:15">
<semantics>
<mi class="ltx_font_mathcaligraphic">ℱ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ℱ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Finite_impulse_response:16">
<semantics>
<msup>
<mi class="ltx_font_mathcaligraphic">ℱ</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℱ</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathcal{F}^{-1}
  </annotation>
</semantics>
</math>

 respectively denote the <a href="discrete-time_Fourier_transform" title="wikilink">discrete-time Fourier transform</a> (DTFT) and its inverse. Therefore, the complex-valued, multiplicative function 

<math display="inline" id="Finite_impulse_response:17">
<semantics>
<mrow>
<mi>H</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>ω</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>H</ci>
<ci>ω</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H(\omega)
  </annotation>
</semantics>
</math>

 is the filter's <a href="frequency_response" title="wikilink">frequency response</a>. It is defined by a <a href="Fourier_series" title="wikilink">Fourier series</a><strong>:</strong></p>

<p>
<math display="block" id="Finite_impulse_response:18">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mi>H</mi>
<mrow>
<mn>2</mn>
<mi>π</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>ω</mi>
<mo rspace="7.5pt" stretchy="false">)</mo>
</mrow>
</mrow>
<mover>
<mo movablelimits="false">=</mo>
<mi>def</mi>
</mover>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>n</mi>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</mrow>
<mi mathvariant="normal">∞</mi>
</munderover>
<mrow>
<mrow>
<mi>h</mi>
<mrow>
<mo stretchy="false">[</mo>
<mi>n</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<mo>⋅</mo>
<msup>
<mrow>
<mo>(</mo>
<msup>
<mi>e</mi>
<mrow>
<mi>i</mi>
<mi>ω</mi>
</mrow>
</msup>
<mo>)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mi>n</mi>
</mrow>
</msup>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>n</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mi>N</mi>
</munderover>
<mrow>
<msub>
<mi>b</mi>
<mi>n</mi>
</msub>
<mo>⋅</mo>
<msup>
<mrow>
<mo>(</mo>
<msup>
<mi>e</mi>
<mrow>
<mi>i</mi>
<mi>ω</mi>
</mrow>
</msup>
<mo>)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mi>n</mi>
</mrow>
</msup>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<eq></eq>
<ci>def</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
</apply>
</apply>
<ci>ω</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>n</ci>
<apply>
<minus></minus>
<infinity></infinity>
</apply>
</apply>
</apply>
<infinity></infinity>
</apply>
<apply>
<ci>normal-⋅</ci>
<apply>
<times></times>
<ci>h</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>n</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>ω</ci>
</apply>
</apply>
<apply>
<minus></minus>
<ci>n</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>n</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<ci>N</ci>
</apply>
<apply>
<ci>normal-⋅</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>b</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>ω</ci>
</apply>
</apply>
<apply>
<minus></minus>
<ci>n</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{2\pi}(\omega)\ \stackrel{\mathrm{def}}{=}\sum_{n=-\infty}^{\infty}h[n]\cdot%
\left({e^{i\omega}}\right)^{-n}=\sum_{n=0}^{N}b_{n}\cdot\left({e^{i\omega}}%
\right)^{-n},
  </annotation>
</semantics>
</math>
</p>

<p>where the added subscript denotes 2π-periodicity. Here 

<math display="inline" id="Finite_impulse_response:19">
<semantics>
<mi>ω</mi>
<annotation-xml encoding="MathML-Content">
<ci>ω</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \omega
  </annotation>
</semantics>
</math>

 represents frequency in <a href="Normalized_frequency_(digital_signal_processing)" title="wikilink">normalized units</a> (<em>radians/sample</em>). The substitution 

<math display="inline" id="Finite_impulse_response:20">
<semantics>
<mrow>
<mrow>
<mi>ω</mi>
<mo>=</mo>
<mrow>
<mn>2</mn>
<mi>π</mi>
<mi>f</mi>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>ω</ci>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
<ci>f</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \omega=2\pi f,
  </annotation>
</semantics>
</math>

  favored by many filter design programs, changes the units of frequency 

<math display="inline" id="Finite_impulse_response:21">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mi>f</mi>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<ci>f</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle(f)
  </annotation>
</semantics>
</math>

 to <em>cycles/sample</em> and the periodicity to 1.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>  When the x[n] sequence has a known sampling-rate, 

<math display="inline" id="Finite_impulse_response:22">
<semantics>
<msub>
<mi>f</mi>
<mi>s</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<ci>s</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f_{s}
  </annotation>
</semantics>
</math>

  <em>samples/second</em>,  the substitution 

<math display="inline" id="Finite_impulse_response:23">
<semantics>
<mrow>
<mi>ω</mi>
<mo>=</mo>
<mrow>
<mrow>
<mn>2</mn>
<mi>π</mi>
<mi>f</mi>
</mrow>
<mo>/</mo>
<msub>
<mi>f</mi>
<mi>s</mi>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>ω</ci>
<apply>
<divide></divide>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
<ci>f</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<ci>s</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \omega=2\pi f/f_{s}
  </annotation>
</semantics>
</math>

  changes the units of frequency 

<math display="inline" id="Finite_impulse_response:24">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mi>f</mi>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<ci>f</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle(f)
  </annotation>
</semantics>
</math>

 to <em>cycles/second</em> (<a class="uri" href="hertz" title="wikilink">hertz</a>) and the periodicity to 

<math display="inline" id="Finite_impulse_response:25">
<semantics>
<mrow>
<msub>
<mi>f</mi>
<mi>s</mi>
</msub>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<ci>s</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f_{s}.
  </annotation>
</semantics>
</math>

  The value 

<math display="inline" id="Finite_impulse_response:26">
<semantics>
<mrow>
<mi>ω</mi>
<mo>=</mo>
<mi>π</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>ω</ci>
<ci>π</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \omega=\pi
  </annotation>
</semantics>
</math>

  corresponds to a frequency of 

<math display="inline" id="Finite_impulse_response:27">
<semantics>
<mrow>
<mi>f</mi>
<mo>=</mo>
<mfrac>
<msub>
<mi>f</mi>
<mi>s</mi>
</msub>
<mn>2</mn>
</mfrac>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>f</ci>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<ci>s</ci>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f=\tfrac{f_{s}}{2}
  </annotation>
</semantics>
</math>
<em>Hz</em>  

<math display="inline" id="Finite_impulse_response:28">
<semantics>
<mrow>
<mi></mi>
<mo>=</mo>
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<csymbol cd="latexml">absent</csymbol>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   =\tfrac{1}{2}
  </annotation>
</semantics>
</math>
<em>cycles/sample</em>, which is the <a href="Nyquist_frequency" title="wikilink">Nyquist frequency</a>.</p>
<h2 id="transfer-function">Transfer function</h2>

<p>The frequency response

<math display="inline" id="Finite_impulse_response:29">
<semantics>
<mrow>
<mo rspace="7.5pt">,</mo>
<msub>
<mi>H</mi>
<mrow>
<mn>2</mn>
<mi>π</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>ω</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-,</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
</apply>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">ω</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-,</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   ,\ H_{2\pi}(\omega),
  </annotation>
</semantics>
</math>

  can also be written as 

<math display="inline" id="Finite_impulse_response:30">
<semantics>
<mrow>
<mrow>
<mi>H</mi>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>e</mi>
<mrow>
<mi>i</mi>
<mi>ω</mi>
</mrow>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>H</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>ω</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H(e^{i\omega}),
  </annotation>
</semantics>
</math>

  where function 

<math display="inline" id="Finite_impulse_response:31">
<semantics>
<mi>H</mi>
<annotation-xml encoding="MathML-Content">
<ci>H</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   H
  </annotation>
</semantics>
</math>

 is the <a class="uri" href="Z-transform" title="wikilink">Z-transform</a> of the impulse response<strong>:</strong></p>

<p>
<math display="block" id="Finite_impulse_response:32">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>H</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo rspace="7.5pt" stretchy="false">)</mo>
</mrow>
</mrow>
<mover>
<mo movablelimits="false">=</mo>
<mi>def</mi>
</mover>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>n</mi>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</mrow>
<mi mathvariant="normal">∞</mi>
</munderover>
<mrow>
<mrow>
<mi>h</mi>
<mrow>
<mo stretchy="false">[</mo>
<mi>n</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<mo>⋅</mo>
<msup>
<mi>z</mi>
<mrow>
<mo>-</mo>
<mi>n</mi>
</mrow>
</msup>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<eq></eq>
<ci>def</ci>
</apply>
<apply>
<times></times>
<ci>H</ci>
<ci>z</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>n</ci>
<apply>
<minus></minus>
<infinity></infinity>
</apply>
</apply>
</apply>
<infinity></infinity>
</apply>
<apply>
<ci>normal-⋅</ci>
<apply>
<times></times>
<ci>h</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>n</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<apply>
<minus></minus>
<ci>n</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H(z)\ \stackrel{\mathrm{def}}{=}\sum_{n=-\infty}^{\infty}h[n]\cdot z^{-n}.
  </annotation>
</semantics>
</math>
</p>

<p>z is a complex variable, and H(z) is a surface.  One cycle of the periodic frequency response can be found in the region defined by 

<math display="inline" id="Finite_impulse_response:33">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>z</mi>
<mo>=</mo>
<msup>
<mi>e</mi>
<mrow>
<mi>i</mi>
<mi>ω</mi>
</mrow>
</msup>
</mrow>
<mo rspace="7.5pt">,</mo>
<mrow>
<mrow>
<mo>-</mo>
<mi>π</mi>
</mrow>
<mo>≤</mo>
<mi>ω</mi>
<mo>≤</mo>
<mi>π</mi>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<ci>z</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>ω</ci>
</apply>
</apply>
</apply>
<apply>
<and></and>
<apply>
<leq></leq>
<apply>
<minus></minus>
<ci>π</ci>
</apply>
<ci>ω</ci>
</apply>
<apply>
<leq></leq>
<share href="#.cmml">
</share>
<ci>π</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   z=e^{i\omega},\ \scriptstyle-\pi\leq\omega\leq\pi,
  </annotation>
</semantics>
</math>

  which is the <a href="unit_circle" title="wikilink">unit circle</a> of the z-plane. Filter <a href="transfer_function" title="wikilink">transfer functions</a> are often used to verify the stability of <a href="Infinite_impulse_response" title="wikilink">IIR</a> designs. As we have already noted, FIR designs are inherently stable.</p>
<h2 id="filter-design">Filter design</h2>

<p>An FIR filter is designed by finding the coefficients and filter order that meet certain specifications, which can be in the time-domain (e.g. a <a href="matched_filter" title="wikilink">matched filter</a>) and/or the frequency domain (most common). Matched filters perform a cross-correlation between the input signal and a known pulse-shape. The FIR convolution is a cross-correlation between the input signal and a time-reversed copy of the impulse-response. Therefore, the matched-filter's impulse response is "designed" by sampling the known pulse-shape and using those samples in reverse order as the coefficients of the filter.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>When a particular frequency response is desired, several different design methods are common:</p>
<ol>
<li><a href="#Window_design_method" title="wikilink">Window design method</a></li>
<li>Frequency Sampling method</li>
<li><a href="Least_squares#Weighted_least_squares" title="wikilink">Weighted least squares design</a></li>
<li><a href="Parks-McClellan_method" title="wikilink">Parks-McClellan method</a> (also known as the Equiripple, Optimal, or Minimax method). The <a href="Remez_algorithm" title="wikilink">Remez exchange algorithm</a> is commonly used to find an optimal equiripple set of coefficients. Here the user specifies a desired frequency response, a weighting function for errors from this response, and a filter order <em>N</em>. The algorithm then finds the set of 

<math display="inline" id="Finite_impulse_response:34">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mpadded width="+1.7pt">
<mi>N</mi>
</mpadded>
<mo>+</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<plus></plus>
<ci>N</ci>
<cn type="float">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle(N\,+\,1)
  </annotation>
</semantics>
</math>

 coefficients that minimize the maximum deviation from the ideal. Intuitively, this finds the filter that is as close as you can get to the desired response given that you can use only 

<math display="inline" id="Finite_impulse_response:35">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mpadded width="+1.7pt">
<mi>N</mi>
</mpadded>
<mo>+</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<plus></plus>
<ci>N</ci>
<cn type="float">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle(N\,+\,1)
  </annotation>
</semantics>
</math>

 coefficients. This method is particularly easy in practice since at least one text<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> includes a program that takes the desired filter and <em>N</em>, and returns the optimum coefficients.</li>
<li>Equiripple FIR filters can be designed using the FFT algorithms as well.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The algorithm is iterative in nature. You simply compute the DFT of an initial filter design that you have using the FFT algorithm (if you don't have an initial estimate you can start with h[n]=delta[n]). In the Fourier domain or FFT domain you correct the frequency response according to your desired specs and compute the inverse FFT. In time-domain you retain only N of the coefficients (force the other coefficients to zero). Compute the FFT once again. Correct the frequency response according to specs.</li>
</ol>

<p>Software packages like <a class="uri" href="MATLAB" title="wikilink">MATLAB</a>, <a href="GNU_Octave" title="wikilink">GNU Octave</a>, <a class="uri" href="Scilab" title="wikilink">Scilab</a>, and <a class="uri" href="SciPy" title="wikilink">SciPy</a> provide convenient ways to apply these different methods.</p>
<h3 id="window-design-method">Window design method</h3>

<p>In the window design method, one first designs an ideal IIR filter and then truncates the infinite impulse response by multiplying it with a finite length <a href="window_function" title="wikilink">window function</a>. The result is a finite impulse response filter whose frequency response is modified from that of the IIR filter. Multiplying the infinite impulse by the window function in the time domain results in the frequency response of the IIR being <a class="uri" href="convolved" title="wikilink">convolved</a> with the Fourier transform (or DTFT) of the window function. If the window's main lobe is narrow, the composite frequency response remains close to that of the ideal IIR filter.</p>

<p>The ideal response is usually rectangular, and the corresponding IIR is a <a href="sinc_function" title="wikilink">sinc function</a>. The result of the frequency domain convolution is that the edges of the rectangle are tapered, and ripples appear in the passband and stopband. Working backward, one can specify the slope (or width) of the tapered region (<em><a href="transition_band" title="wikilink">transition band</a></em>) and the height of the ripples, and thereby derive the frequency domain parameters of an appropriate window function. Continuing backward to an impulse response can be done by iterating a filter design program to find the minimum filter order. Another method is to restrict the solution set to the parametric family of Kaiser windows, which provides closed form relationships between the time-domain and frequency domain parameters. In general, that method will not achieve the minimum possible filter order, but it is particularly convenient for automated applications that require dynamic, on-the-fly, filter design.</p>

<p>The window design method is also advantageous for creating efficient <a href="half-band_filter" title="wikilink">half-band filters</a>, because the corresponding sinc function is zero at every other sample point (except the center one). The product with the window function does not alter the zeros, so almost half of the coefficients of the final impulse response are zero. An appropriate implementation of the FIR calculations can exploit that property to double the filter's efficiency.</p>
<h2 id="moving-average-example">Moving average example</h2>

<p>A <a href="moving_average" title="wikilink">moving average</a> filter is a very simple FIR filter. It is sometimes called a <a href="Boxcar_function" title="wikilink">boxcar</a> filter, especially when followed by <a href="Decimation_(signal_processing)" title="wikilink">decimation</a>. The filter coefficients, 

<math display="inline" id="Finite_impulse_response:36">
<semantics>
<mrow>
<msub>
<mi>b</mi>
<mn>0</mn>
</msub>
<mo rspace="4.2pt">,</mo>
<mi mathvariant="normal">…</mi>
<mo rspace="4.2pt">,</mo>
<msub>
<mi>b</mi>
<mi>N</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>b</ci>
<cn type="integer">0</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>b</ci>
<ci>N</ci>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle b_{0},\,\dots,\,b_{N}
  </annotation>
</semantics>
</math>

, are found via the following equation:</p>

<p>
<math display="block" id="Finite_impulse_response:37">
<semantics>
<mrow>
<msub>
<mi>b</mi>
<mi>i</mi>
</msub>
<mo>=</mo>
<mfrac>
<mn>1</mn>
<mrow>
<mi>N</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</mfrac>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>b</ci>
<ci>i</ci>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<plus></plus>
<ci>N</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   b_{i}=\frac{1}{N+1}
  </annotation>
</semantics>
</math>
</p>

<p>To provide a more specific example, we select the filter order:</p>

<p>
<math display="block" id="Finite_impulse_response:38">
<semantics>
<mrow>
<mi>N</mi>
<mo>=</mo>
<mn>2</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>N</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   N=2
  </annotation>
</semantics>
</math>
</p>

<p>The impulse response of the resulting filter is<strong>:</strong></p>

<p>
<math display="block" id="Finite_impulse_response:39">
<semantics>
<mrow>
<mrow>
<mi>h</mi>
<mrow>
<mo stretchy="false">[</mo>
<mi>n</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mfrac>
<mn>1</mn>
<mn>3</mn>
</mfrac>
<mi>δ</mi>
<mrow>
<mo stretchy="false">[</mo>
<mi>n</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<mfrac>
<mn>1</mn>
<mn>3</mn>
</mfrac>
<mi>δ</mi>
<mrow>
<mo stretchy="false">[</mo>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<mfrac>
<mn>1</mn>
<mn>3</mn>
</mfrac>
<mi>δ</mi>
<mrow>
<mo stretchy="false">[</mo>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mn>2</mn>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>h</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>n</ci>
</apply>
</apply>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">3</cn>
</apply>
<ci>δ</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>n</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">3</cn>
</apply>
<ci>δ</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<apply>
<minus></minus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">3</cn>
</apply>
<ci>δ</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<apply>
<minus></minus>
<ci>n</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   h[n]=\frac{1}{3}\delta[n]+\frac{1}{3}\delta[n-1]+\frac{1}{3}\delta[n-2]
  </annotation>
</semantics>
</math>
</p>

<p>The Fig. (a) on the right shows the block diagram of a 2nd-order moving-average filter discussed below. The transfer function is<strong>:</strong></p>

<p>
<math display="block" id="Finite_impulse_response:40">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>H</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mfrac>
<mn>1</mn>
<mn>3</mn>
</mfrac>
<mo>+</mo>
<mrow>
<mfrac>
<mn>1</mn>
<mn>3</mn>
</mfrac>
<msup>
<mi>z</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
<mo>+</mo>
<mrow>
<mfrac>
<mn>1</mn>
<mn>3</mn>
</mfrac>
<msup>
<mi>z</mi>
<mrow>
<mo>-</mo>
<mn>2</mn>
</mrow>
</msup>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mfrac>
<mn>1</mn>
<mn>3</mn>
</mfrac>
<mfrac>
<mrow>
<msup>
<mi>z</mi>
<mn>2</mn>
</msup>
<mo>+</mo>
<mi>z</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
<msup>
<mi>z</mi>
<mn>2</mn>
</msup>
</mfrac>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<ci>H</ci>
<ci>z</ci>
</apply>
<apply>
<plus></plus>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">3</cn>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">3</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">3</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<apply>
<minus></minus>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">3</cn>
</apply>
<apply>
<divide></divide>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<cn type="integer">2</cn>
</apply>
<ci>z</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H(z)=\frac{1}{3}+\frac{1}{3}z^{-1}+\frac{1}{3}z^{-2}=\frac{1}{3}\frac{z^{2}+z+%
1}{z^{2}}.
  </annotation>
</semantics>
</math>
</p>

<p>Fig. (b) on the right shows the corresponding <a href="pole–zero_diagram" title="wikilink">pole–zero diagram</a>. Zero frequency (DC) corresponds to (1,0), positive frequencies advancing counterclockwise around the circle to the Nyquist frequency at (-1,0). Two poles are located at the origin, and two zeros are located at 

<math display="inline" id="Finite_impulse_response:41">
<semantics>
<mrow>
<mpadded width="+2.8pt">
<msub>
<mi>z</mi>
<mn>1</mn>
</msub>
</mpadded>
<mo rspace="5.3pt">=</mo>
<mrow>
<mrow>
<mo>-</mo>
<mpadded width="+1.7pt">
<mstyle scriptlevel="+1">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mstyle>
</mpadded>
</mrow>
<mo rspace="4.2pt">+</mo>
<mrow>
<mi>j</mi>
<mstyle scriptlevel="+1">
<mfrac>
<msqrt>
<mn>3</mn>
</msqrt>
<mn>2</mn>
</mfrac>
</mstyle>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<plus></plus>
<apply>
<minus></minus>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<times></times>
<ci>j</ci>
<apply>
<divide></divide>
<apply>
<root></root>
<cn type="integer">3</cn>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle z_{1}\;=\;-\frac{1}{2}\,+\,j\frac{\sqrt{3}}{2}
  </annotation>
</semantics>
</math>

, 

<math display="inline" id="Finite_impulse_response:42">
<semantics>
<mrow>
<mpadded width="+2.8pt">
<msub>
<mi>z</mi>
<mn>2</mn>
</msub>
</mpadded>
<mo rspace="5.3pt">=</mo>
<mrow>
<mrow>
<mo>-</mo>
<mpadded width="+1.7pt">
<mstyle scriptlevel="+1">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mstyle>
</mpadded>
</mrow>
<mo rspace="4.2pt">-</mo>
<mrow>
<mi>j</mi>
<mstyle scriptlevel="+1">
<mfrac>
<msqrt>
<mn>3</mn>
</msqrt>
<mn>2</mn>
</mfrac>
</mstyle>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<minus></minus>
<apply>
<minus></minus>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<times></times>
<ci>j</ci>
<apply>
<divide></divide>
<apply>
<root></root>
<cn type="integer">3</cn>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle z_{2}\;=\;-\frac{1}{2}\,-\,j\frac{\sqrt{3}}{2}
  </annotation>
</semantics>
</math>

.</p>

<p>The frequency response, in terms of <a href="Normalized_frequency_(digital_signal_processing)" title="wikilink">normalized frequency</a> <em>ω</em>, is<strong>:</strong></p>

<p>
<math display="block" id="Finite_impulse_response:43">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>H</mi>
<mrow>
<mo>(</mo>
<msup>
<mi>e</mi>
<mrow>
<mi>j</mi>
<mi>ω</mi>
</mrow>
</msup>
<mo>)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mfrac>
<mn>1</mn>
<mn>3</mn>
</mfrac>
<mo>+</mo>
<mrow>
<mfrac>
<mn>1</mn>
<mn>3</mn>
</mfrac>
<msup>
<mi>e</mi>
<mrow>
<mo>-</mo>
<mrow>
<mi>j</mi>
<mi>ω</mi>
</mrow>
</mrow>
</msup>
</mrow>
<mo>+</mo>
<mrow>
<mfrac>
<mn>1</mn>
<mn>3</mn>
</mfrac>
<msup>
<mi>e</mi>
<mrow>
<mo>-</mo>
<mrow>
<mi>j</mi>
<mn>2</mn>
<mi>ω</mi>
</mrow>
</mrow>
</msup>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>H</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<times></times>
<ci>j</ci>
<ci>ω</ci>
</apply>
</apply>
</apply>
<apply>
<plus></plus>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">3</cn>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">3</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>j</ci>
<ci>ω</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">3</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>j</ci>
<cn type="integer">2</cn>
<ci>ω</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H\left(e^{j\omega}\right)=\frac{1}{3}+\frac{1}{3}e^{-j\omega}+\frac{1}{3}e^{-j%
2\omega}.
  </annotation>
</semantics>
</math>
</p>

<p>Fig. (c) on the right shows the magnitude and phase components of 

<math display="inline" id="Finite_impulse_response:44">
<semantics>
<mrow>
<mrow>
<mi>H</mi>
<mrow>
<mo>(</mo>
<msup>
<mi>e</mi>
<mrow>
<mi>j</mi>
<mi>ω</mi>
</mrow>
</msup>
<mo>)</mo>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>H</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<times></times>
<ci>j</ci>
<ci>ω</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle H\left(e^{j\omega}\right).
  </annotation>
</semantics>
</math>

  But plots like these can also be generated by doing a <a href="discrete_Fourier_transform" title="wikilink">discrete Fourier transform</a> (DFT) of the impulse response.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a>  And because of symmetry, filter design or viewing software often displays only the [0,π] region. The magnitude plot indicates that the moving-average filter passes low frequencies with a gain near 1 and attenuates high frequencies, and is thus a crude <a href="low-pass_filter" title="wikilink">low-pass filter</a>. The phase plot is linear except for discontinuities at the two frequencies where the magnitude goes to zero. The size of the discontinuities is π, representing a sign reversal. They do not affect the property of linear phase. That fact is illustrated in Fig. (d).</p>
<h2 id="notes">Notes</h2>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Electronic_filter" title="wikilink">Electronic filter</a></li>
<li><a href="Filter_(signal_processing)" title="wikilink">Filter (signal processing)</a></li>
<li><a href="Infinite_impulse_response" title="wikilink">Infinite impulse response (IIR) filter</a></li>
<li><a class="uri" href="Z-transform" title="wikilink">Z-transform</a> (specifically <a href="Z-transform#Linear_constant-coefficient_difference_equation" title="wikilink">Linear constant-coefficient difference equation</a>)</li>
<li><a href="Filter_design" title="wikilink">Filter design</a></li>
<li><a href="Cascaded_integrator–comb_filter" title="wikilink">Cascaded integrator–comb filter</a></li>
<li><a href="Compact_support" title="wikilink">Compact support</a></li>
</ul>
<h2 id="citations">Citations</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://cnx.org/content/col10553/latest/">Notes on the Optimal Design of FIR Filters</a> <a class="uri" href="Connexions" title="wikilink">Connexions</a> online book by John Treichler (2008).</li>
<li><a href="http://dspguru.com/dsp/faqs/fir">FIR FAQ</a> provided by dspguru.com.</li>
<li><a href="http://www.ludd.luth.se/~torger/brutefir.html">BruteFIR; Software for applying long FIR filters to multi-channel digital audio, either offline or in realtime.</a></li>
<li><a href="http://www.nongnu.org/freeverb3/">Freeverb3 Reverb Impulse Response Processor</a></li>
<li>Worked examples and explanation for designing <a href="http://www.labbookpages.co.uk/audio/firWindowing.html">FIR filters using windowing</a>. Includes code examples.</li>
<li><a href="http://www.falstad.com/dfilter/">A JAVA applet with different FIR-filters</a>; the filters are applied to sound and the results can be heard immediately. The source code is also available.</li>
<li><a href="http://signal.ee.bilkent.edu.tr/my_filter.m">Matlab code</a>; Matlab code for "Equiripple FIR filter design by the FFT algorithm" by A. Enis Cetin, O. N. Gerek and Y. Yardimci, IEEE Signal Processing Magazine, 1997.</li>
<li><a href="http://engineerjs.com/doc/signals/filters/tfilter-1/_remezFIRFilter.html">EngineerJS FIR filter designer</a>; Online FIR filter designer tool, based on Parks-McClellan method</li>
</ul>

<p>"</p>

<p><a href="Category:Digital_signal_processing" title="wikilink">Category:Digital signal processing</a> <a href="Category:Filter_theory" title="wikilink">Category:Filter theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">A notable exception is MATLAB, which prefers units of <em>half-cycles/sample</em> = <em>cycles/2-samples</em>, because the Nyquist frequency in those units is 1, a convenient choice for plotting software that displays the interval from 0 to the Nyquist frequency.<a href="#fnref1">↩</a></li>
<li id="fn2">Oppenheim, Alan V., Willsky, Alan S., and Young, Ian T.,1983: Signals and Systems, p. 256 (Englewood Cliffs, New Jersey: Prentice-Hall, Inc.) ISBN 0-13-809731-3<a href="#fnref2">↩</a></li>
<li id="fn3">Rabiner, Lawrence R., and Gold, Bernard, 1975: Theory and Application of Digital Signal Processing (Englewood Cliffs, New Jersey: Prentice-Hall, Inc.) ISBN 0-13-914101-4<a href="#fnref3">↩</a></li>
<li id="fn4">A. E. Cetin, O.N. Gerek, Y. Yardimci, "Equiripple FIR filter design by the FFT algorithm," IEEE Signal Processing Magazine, pp. 60-64, March 1997.<a href="#fnref4">↩</a></li>
<li id="fn5">See <a href="DTFT#Sampling_the_DTFT" title="wikilink">Sampling the DTFT</a>.<a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
