   Rytz's construction      Rytz's construction  table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */     Using the Rytz’s axis construction, it is possible to find the major and minor axis and the vertices of an ellipse , starting from two conjugated diameters . Rytz’s construction is a classical construction of Euclidean geometry , in which only compass and ruler are allowed as aids. The design is named after its inventor David Rytz of Brugg, 1801–1868.  Problem statement  (Figure)  Figure 1: Given sizes and results   Figure 1 shows the given and required quantities. The two conjugate diameters    d  1  ′     superscript   subscript  d  1   normal-′    d_{1}^{\prime}   , and    d  2  ′     superscript   subscript  d  2   normal-′    d_{2}^{\prime}   (blue) are given, and the axes    a   a   a   and   b   b   b   of the ellipse (red) are required. For clarity, the corresponding ellipse   e   e   e   is also shown, however, it is neither given, nor is it a direct result of Rytz's construction. With ruler and compass only a few points of the ellipse can constructed, but not the entire ellipse. Methods of drawing an ellipse usually require the axes of the ellipse to be known.  Conjugate diameters  An ellipse can be seen as an image of the unit circle under an affine transformation .  Figure 1 shows the ellipse   e   e   e   next to the unit circle    k  h     subscript  k  h    k_{h}   . The affine image   α   α   \alpha   , which transforms the unit circle    k  h     subscript  k  h    k_{h}   into the ellipse   e   e   e   is indicated by the dashed arrows. The preimage of an ellipse diameter under the image   α   α   \alpha   is a circle of diameter    k  h     subscript  k  h    k_{h}   .  Construction  (Figure)  Figure 2: Construction   Figure 2 shows the steps of the Rytz’s construction. The conjugate diameters    d  1  ′     superscript   subscript  d  1   normal-′    d_{1}^{\prime}   and    d  2  ′     superscript   subscript  d  2   normal-′    d_{2}^{\prime}   (thick blue lines) are given, which meet at the center   M   M   M   of the ellipse. A point on each conjugate diameter is selected    U  ′     superscript  U  normal-′    U^{\prime}   on    d  1  ′     superscript   subscript  d  1   normal-′    d_{1}^{\prime}   and    V  ′     superscript  V  normal-′    V^{\prime}   on    d  2  ′     superscript   subscript  d  2   normal-′    d_{2}^{\prime}   . The angle    ∠   (    U  ′   M   V  ′    )       normal-∠     superscript  U  normal-′   M   superscript  V  normal-′      \angle(U^{\prime}MV^{\prime})   is either obtuse (     >   90  ∘       absent   superscript  90      >90^{\circ}   ) as shown in the figure, or acute ( ). If the conjugate diameters are standing perpendicular to each other (     =   90  ∘       absent   superscript  90      =90^{\circ}   ), the axes of the ellipse are already found: In this case, they are identical to the given conjugate diameters.  In the first step, the point    U  ′     superscript  U  normal-′    U^{\prime}   is rotated    90  ∘     superscript  90     90^{\circ}   around the center   M   M   M   toward point    V  ′     superscript  V  normal-′    V^{\prime}   . The result is the point    U  r  ′     subscript   superscript  U  normal-′   r    U^{\prime}_{r}   . The points    U  r  ′     subscript   superscript  U  normal-′   r    U^{\prime}_{r}   and    V  ′     superscript  V  normal-′    V^{\prime}   define the line   g   g   g   . The midpoint of the line      U  r  ′    V  ′    ¯     normal-¯     subscript   superscript  U  normal-′   r    superscript  V  normal-′      \overline{U^{\prime}_{r}V^{\prime}}   is   S   S   S   . The next step is drawing a circle   t   t   t   around   S   S   S   so that it passes through the center   M   M   M   of the ellipse. The intersections of the circle with the line   g   g   g   define the points   R   R   R   and   L   L   L   .   R   R   R   and   L   L   L   are selected such that   R   R   R   is located on the same side as    U  r  ′     subscript   superscript  U  normal-′   r    U^{\prime}_{r}   and   L   L   L   is located on the same side as    V  ′     superscript  V  normal-′    V^{\prime}   , as viewed from the point   S   S   S   . Next, you draw from the point   M   M   M   two straight lines, one through   R   R   R   and the other through   L   L   L   . These lines intersect   M   M   M   at a right angle (as Thales' theorem states).  The proposition of the Rytz’s construction is that the directions of the ellipse axes are indicated by the vectors     M  L   ¯     normal-¯    M  L     \overline{ML}   and     M  R   ¯     normal-¯    M  R     \overline{MR}   , and the length of the line      V  ′   R   ¯     normal-¯     superscript  V  normal-′   R     \overline{V^{\prime}R}   is the length of the ellipse’s major axis and the length of the      V  ′   L   ¯     normal-¯     superscript  V  normal-′   L     \overline{V^{\prime}L}   corresponds to the length of the ellipse’s minor axis. In the last step we therefore propose two circles around   M   M   M   with the radii   a   a   a   and   b   b   b   . The major vertices    S  1     subscript  S  1    S_{1}   and    S  2     subscript  S  2    S_{2}   are at a distance   a   a   a   of   M   M   M   on the line through   L   L   L   and the minor vertices    S  3     subscript  S  3    S_{3}   and    S  4     subscript  S  4    S_{4}   are at a distance   b   b   b   of   M   M   M   on the line through   R   R   R   .  Algorithm  The following Python code implements the algorithm described by the construction building steps.  #!/usr/bin/env python  # -*- coding: utf-8 -*-  import numpy as np from cmath import rect class Ellipse( object ): """  Ellipse curve on the complex plane  """  def  __init__ ( self , a, b, angle = 0 , origin = 0 ): self .a = a self .b = b self .angle = angle self .origin = origin @classmethod  def from_conjugate_diameters(cls, para): """  Find the major and minor axes of an ellipse from a parallelogram  determining the conjugate diameters.    Uses Rytz's construction for algorithm:  http://de.wikipedia.org/wiki/Rytzsche_Achsenkonstruktion#Konstruktion  """ c = midpoint(para[ 0 ], para[ 2 ])
         para = para - c
         u, v = para[: 2 ] if is_orthogonal(u, v): return cls(np. abs (u), np. abs (v), np.angle(u), c) # Step 1 ur = rotate_towards(u, v, 0.25 )
         s = midpoint(ur, v) # Step 2 r = rect(np. abs (s), np.angle(ur - s)) + s
         l = rect(np. abs (s), np.angle(v - s)) + s
         
         a = np. abs (v - r)
         b = np. abs (v - l) return cls(a, b, np.angle(l), c) def is_orthogonal(a, b, c = 0 ): """  Return true if two complex points (a, b) are orthogonal from  center point (c).  """  return np. abs (np.angle(a - c) - np.angle(b - c)) == np.pi /  2  def midpoint(a, b): """  Midpoint is the middle point of a line segment.  """  return ((a - b) /  2.0 ) + b def rotate_towards(u, v, tau, center = 0 ): """  Rotate point u tau degrees *towards* v around center.  """ s, t = np.array([u, v]) - center
     sign =  - 1  if (np.angle(s) - np.angle(t)) % pi2 > np.pi else  1  return s * ( - np.exp(pi2 * 1j * tau) * sign) + center  References      "  Category:Euclidean geometry  Category:Descriptive geometry  Category:Articles with example Python code  