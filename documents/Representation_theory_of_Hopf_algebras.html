<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="852">Representation theory of Hopf algebras</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Representation theory of Hopf algebras</h1>
<hr/>

<p>In <a href="abstract_algebra" title="wikilink">abstract algebra</a>, a <strong>representation of a Hopf algebra</strong> is a <a href="algebra_representation" title="wikilink">representation</a> of its underlying <a href="associative_algebra" title="wikilink">associative algebra</a>. That is, a representation of a Hopf algebra <em>H</em> over a field <em>K</em> is a <em>K</em>-<a href="vector_space" title="wikilink">vector space</a> <em>V</em> with an <a href="group_action" title="wikilink">action</a> <em>H</em> × <em>V</em> → <em>V</em> usually denoted by juxtaposition ( that is, the image of (<em>h</em>,<em>v</em>) is written <em>hv</em> ). The vector space <em>V</em> is called an <em>H</em>-module.</p>
<h2 id="properties">Properties</h2>

<p>The module structure of a representation of a Hopf algebra <em>H</em> is simply its structure as a module for the underlying associative algebra. The main use of considering the additional structure of a Hopf algebra is when considering all <em>H</em>-modules as a category. The additional structure is also used to define invariant elements of an <em>H</em>-module <em>V</em>. An element <em>v</em> in <em>V</em> is <a href="Invariant_(mathematics)" title="wikilink">invariant</a> under <em>H</em> if for all <em>h</em> in <em>H</em>, <em>hv</em> = ε(<em>h</em>)<em>v</em>, where ε is the <a class="uri" href="counit" title="wikilink">counit</a> of <em>H</em>. The subset of all invariant elements of <em>V</em> forms a submodule of <em>V</em>.</p>
<h2 id="categories-of-representations-as-a-motivation-for-hopf-algebras">Categories of representations as a motivation for Hopf algebras</h2>

<p>For an associative algebra <em>H</em>, the <a href="tensor_product" title="wikilink">tensor product</a> <em>V</em><sub>1</sub> ⊗ <em>V</em><sub>2</sub> of two <em>H</em>-modules <em>V</em><sub>1</sub> and <em>V</em><sub>2</sub> is a vector space, but not necessarily an <em>H</em>-module. For the tensor product to be a <a href="functor" title="wikilink">functorial</a> product operation on <em>H</em>-modules, there must be a linear binary operation Δ : <em>H</em> → <em>H</em> ⊗ <em>H</em> such that for any <em>v</em> in <em>V</em><sub>1</sub> ⊗ <em>V</em><sub>2</sub> and any <em>h</em> in <em>H</em>,</p>

<p>

<math display="block" id="Representation_theory_of_Hopf_algebras:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mi>v</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>v</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
       <mo>⊗</mo>
       <msub>
        <mi>v</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <msub>
        <mi>h</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
       <msub>
        <mi>v</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
      </mrow>
      <mo>⊗</mo>
      <msub>
       <mi>h</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>2</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </msub>
     </mrow>
     <msub>
      <mi>v</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>2</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>v</ci>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>h</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   hv=\Delta h(v_{(1)}\otimes v_{(2)})=h_{(1)}v_{(1)}\otimes h_{(2)}v_{(2)},
  </annotation>
 </semantics>
</math>

</p>

<p>and for any <em>v</em> in <em>V</em><sub>1</sub> ⊗ <em>V</em><sub>2</sub> and <em>a</em> and <em>b</em> in <em>H</em>,</p>

<p>

<math display="block" id="Representation_theory_of_Hopf_algebras:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>a</mi>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>v</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
       <mo>⊗</mo>
       <msub>
        <mi>v</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>a</mi>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>v</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>a</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>b</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>v</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>a</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>b</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>v</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mn>1</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </msub>
         <mo>⊗</mo>
         <msub>
          <mi>v</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mn>2</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>a</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>v</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
       <mo>⊗</mo>
       <msub>
        <mi>v</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>a</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>b</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>v</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>a</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>b</ci>
        <apply>
         <csymbol cd="latexml">tensor-product</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>v</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>v</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <ci>b</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(ab)(v_{(1)}\otimes v_{(2)})=(ab)v=a[b[v]]=\Delta a[\Delta b(v_{(1)}%
\otimes v_{(2)})]=(\Delta a)(\Delta b)(v_{(1)}\otimes v_{(2)}).
  </annotation>
 </semantics>
</math>

</p>

<p>using sumless <a href="Sweedler's_notation" title="wikilink">Sweedler's notation</a>, which is somewhat like an index free form of <a href="Einstein's_summation_convention" title="wikilink">Einstein's summation convention</a>. This is satisfied if there is a Δ such that Δ(<em>ab</em>) = Δ(<em>a</em>)Δ(<em>b</em>) for all <em>a</em>, <em>b</em> in <em>H</em>.</p>

<p>For the category of <em>H</em>-modules to be a strict <a href="monoidal_category" title="wikilink">monoidal category</a> with respect to ⊗, 

<math display="inline" id="Representation_theory_of_Hopf_algebras:2">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mn>1</mn>
   </msub>
   <mo>⊗</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>V</mi>
      <mn>2</mn>
     </msub>
     <mo>⊗</mo>
     <msub>
      <mi>V</mi>
      <mn>3</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{1}\otimes(V_{2}\otimes V_{3})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Representation_theory_of_Hopf_algebras:3">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>V</mi>
      <mn>1</mn>
     </msub>
     <mo>⊗</mo>
     <msub>
      <mi>V</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊗</mo>
   <msub>
    <mi>V</mi>
    <mn>3</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (V_{1}\otimes V_{2})\otimes V_{3}
  </annotation>
 </semantics>
</math>

 must be equivalent and there must be unit object ε<sub><em>H</em></sub>, called the trivial module, such that ε<sub><em>H</em></sub> ⊗ <em>V</em>, <em>V</em> and <em>V</em> ⊗ ε<sub><em>H</em></sub> are equivalent.</p>

<p>This means that for any <em>v</em> in</p>

<p>

<math display="block" id="Representation_theory_of_Hopf_algebras:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>V</mi>
     <mn>1</mn>
    </msub>
    <mo>⊗</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>V</mi>
       <mn>2</mn>
      </msub>
      <mo>⊗</mo>
      <msub>
       <mi>V</mi>
       <mn>3</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>V</mi>
       <mn>1</mn>
      </msub>
      <mo>⊗</mo>
      <msub>
       <mi>V</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⊗</mo>
    <msub>
     <mi>V</mi>
     <mn>3</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{1}\otimes(V_{2}\otimes V_{3})=(V_{1}\otimes V_{2})\otimes V_{3}
  </annotation>
 </semantics>
</math>

</p>

<p>and for <em>h</em> in <em>H</em>,</p>

<p>

<math display="block" id="Representation_theory_of_Hopf_algebras:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>id</mo>
         <mo>⊗</mo>
         <mi mathvariant="normal">Δ</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>h</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>v</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
       <mo>⊗</mo>
       <msub>
        <mi>v</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
       <mo>⊗</mo>
       <msub>
        <mi>v</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>3</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mrow>
        <mrow>
         <msub>
          <mi>h</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mn>1</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </msub>
         <msub>
          <mi>v</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mn>1</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </msub>
        </mrow>
        <mo>⊗</mo>
        <msub>
         <mi>h</mi>
         <mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mn>2</mn>
           <mo stretchy="false">)</mo>
          </mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mn>1</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </msub>
       </mrow>
       <msub>
        <mi>v</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
      </mrow>
      <mo>⊗</mo>
      <msub>
       <mi>h</mi>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </msub>
     </mrow>
     <msub>
      <mi>v</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>3</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>h</mi>
     <mi>v</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi mathvariant="normal">Δ</mi>
         <mo>⊗</mo>
         <mo>id</mo>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>h</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>v</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
       <mo>⊗</mo>
       <msub>
        <mi>v</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
       <mo>⊗</mo>
       <msub>
        <mi>v</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>3</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>id</ci>
        <ci>normal-Δ</ci>
       </apply>
       <ci>normal-Δ</ci>
       <ci>h</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="latexml">tensor-product</csymbol>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>h</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>v</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>h</ci>
          <apply>
           <times></times>
           <cn type="integer">2</cn>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>normal-Δ</ci>
        <ci>id</ci>
       </apply>
       <ci>normal-Δ</ci>
       <ci>h</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((\operatorname{id}\otimes\Delta)\Delta h)(v_{(1)}\otimes v_{(2)}\otimes v_{(3%
)})=h_{(1)}v_{(1)}\otimes h_{(2)(1)}v_{(2)}\otimes h_{(2)(2)}v_{(3)}=hv=((%
\Delta\otimes\operatorname{id})\Delta h)(v_{(1)}\otimes v_{(2)}\otimes v_{(3)}).
  </annotation>
 </semantics>
</math>

</p>

<p>This will hold for any three <em>H</em>-modules if Δ satisfies</p>

<p>

<math display="block" id="Representation_theory_of_Hopf_algebras:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>id</mo>
       <mo>⊗</mo>
       <mi mathvariant="normal">Δ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>A</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mo>⊗</mo>
       <mo>id</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>A</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>id</ci>
      <ci>normal-Δ</ci>
     </apply>
     <ci>normal-Δ</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>normal-Δ</ci>
      <ci>id</ci>
     </apply>
     <ci>normal-Δ</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\operatorname{id}\otimes\Delta)\Delta A=(\Delta\otimes\operatorname{id})%
\Delta A.
  </annotation>
 </semantics>
</math>

</p>

<p>The trivial module must be one-dimensional, and so an <a href="algebra_homomorphism" title="wikilink">algebra homomorphism</a> ε : <em>H</em> → <em>F</em> may be defined such that <em>hv</em> = ε(<em>h</em>)<em>v</em> for all <em>v</em> in ε<sub><em>H</em></sub>. The trivial module may be identified with <em>F</em>, with 1 being the element such that 1 ⊗ <em>v</em> = <em>v</em> = <em>v</em> ⊗ 1 for all <em>v</em>. It follows that for any <em>v</em> in any <em>H</em>-module <em>V</em>, any <em>c</em> in ε<sub><em>H</em></sub> and any <em>h</em> in <em>H</em>,</p>

<p>

<math display="block" id="Representation_theory_of_Hopf_algebras:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>ε</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>h</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>1</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <msub>
        <mi>h</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>c</mi>
     <mi>v</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <msub>
        <mi>h</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
       <mi>c</mi>
      </mrow>
      <mo>⊗</mo>
      <msub>
       <mi>h</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>2</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </msub>
     </mrow>
     <mi>v</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>c</mi>
       <mo>⊗</mo>
       <mi>v</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>c</mi>
       <mi>v</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>h</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
       <mi>ε</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>h</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>2</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>c</mi>
     <mi>v</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>ε</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>c</ci>
      <ci>v</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>c</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>h</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>c</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>h</ci>
      <apply>
       <times></times>
       <ci>c</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>ε</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>c</ci>
      <ci>v</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\varepsilon(h_{(1)})h_{(2)})cv=h_{(1)}c\otimes h_{(2)}v=h(c\otimes v)=h(cv)=(%
h_{(1)}\varepsilon(h_{(2)}))cv.
  </annotation>
 </semantics>
</math>

</p>

<p>The existence of an algebra homomorphism ε satisfying</p>

<p>

<math display="block" id="Representation_theory_of_Hopf_algebras:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>ε</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>h</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
    <mi>ε</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>2</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>ε</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>h</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>ε</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon(h_{(1)})h_{(2)}=h=h_{(1)}\varepsilon(h_{(2)})
  </annotation>
 </semantics>
</math>

</p>

<p>is a sufficient condition for the existence of the trivial module.</p>

<p>It follows that in order for the category of <em>H</em>-modules to be a monoidal category with respect to the tensor product, it is sufficient for <em>H</em> to have maps Δ and ε satisfying these conditions. This is the motivation for the definition of a <a class="uri" href="bialgebra" title="wikilink">bialgebra</a>, where Δ is called the <a class="uri" href="comultiplication" title="wikilink">comultiplication</a> and ε is called the <a class="uri" href="counit" title="wikilink">counit</a>.</p>

<p>In order for each <em>H</em>-module <em>V</em> to have a <a href="dual_representation" title="wikilink">dual representation</a> <em>V</em> such that the underlying vector spaces are dual and the operation * is functorial over the monoidal category of <em>H</em>-modules, there must be a linear map <em>S</em> : <em>H</em> → <em>H</em> such that for any <em>h</em> in <em>H</em>, <em>x</em> in <em>V</em> and <em>y</em> in <em>V*</em>,</p>

<p>

<math display="block" id="Representation_theory_of_Hopf_algebras:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mrow>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>h</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>h</mi>
      <mi>y</mi>
     </mrow>
     <mo>,</mo>
     <mi>x</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>y</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>h</ci>
      <ci>x</ci>
     </apply>
    </list>
    <list>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>y</ci>
     </apply>
     <ci>x</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle y,S(h)x\rangle=\langle hy,x\rangle.
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Representation_theory_of_Hopf_algebras:10">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mo>⋅</mo>
   <mo>,</mo>
   <mo>⋅</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>normal-⋅</ci>
    <ci>normal-⋅</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\cdot,\cdot\rangle
  </annotation>
 </semantics>
</math>

 is the usual <a class="uri" href="pairing" title="wikilink">pairing</a> of dual vector spaces. If the map 

<math display="inline" id="Representation_theory_of_Hopf_algebras:11">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>V</mi>
     <mo>⊗</mo>
     <msup>
      <mi>V</mi>
      <mo>*</mo>
     </msup>
    </mrow>
    <mo>→</mo>
    <msub>
     <mi>ε</mi>
     <mi>H</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>φ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>V</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>V</ci>
       <times></times>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ε</ci>
      <ci>H</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi:V\otimes V^{*}\rightarrow\varepsilon_{H}
  </annotation>
 </semantics>
</math>

 induced by the pairing is to be an <em>H</em>-homomorphism, then for any <em>h</em> in <em>H</em>, <em>x</em> in <em>V</em> and <em>y</em> in <em>V*</em>,</p>

<p>

<math display="block" id="Representation_theory_of_Hopf_algebras:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>φ</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mi>h</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>x</mi>
         <mo>⊗</mo>
         <mi>y</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>φ</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mi>x</mi>
        <mo>⊗</mo>
        <mi>S</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>h</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>1</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <msub>
        <mi>h</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
       <mi>y</mi>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>φ</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mi>S</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>h</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mn>2</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
        <msub>
         <mi>h</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>1</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </msub>
        <mi>x</mi>
       </mrow>
       <mo>⊗</mo>
       <mi>y</mi>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>h</mi>
     <mi>φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>⊗</mo>
       <mi>y</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>ε</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>h</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>⊗</mo>
       <mi>y</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>φ</ci>
      <apply>
       <times></times>
       <ci>h</ci>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>x</ci>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>φ</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>x</ci>
        <ci>S</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>φ</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <ci>S</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>x</ci>
       </apply>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>φ</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>x</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>ε</ci>
      <ci>h</ci>
      <ci>φ</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>x</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi\left(h(x\otimes y)\right)=\varphi\left(x\otimes S(h_{(1)})h_{(2)}y%
\right)=\varphi\left(S(h_{(2)})h_{(1)}x\otimes y\right)=h\varphi(x\otimes y)=%
\varepsilon(h)\varphi(x\otimes y),
  </annotation>
 </semantics>
</math>

</p>

<p>which is satisfied if</p>

<p>

<math display="block" id="Representation_theory_of_Hopf_algebras:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>ε</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>h</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>2</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>ε</ci>
      <ci>h</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>S</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(h_{(1)})h_{(2)}=\varepsilon(h)=h_{(1)}S(h_{(2)})
  </annotation>
 </semantics>
</math>

</p>

<p>for all <em>h</em> in <em>H</em>.</p>

<p>If there is such a map <em>S</em>, then it is called an <em>antipode</em>, and <em>H</em> is a Hopf algebra. The desire for a monoidal category of modules with functorial tensor products and dual representations is therefore one motivation for the concept of a Hopf algebra.</p>
<h2 id="representations-on-an-algebra">Representations on an algebra</h2>

<p>A Hopf algebra also has representations which carry additional structure, namely they are algebras.</p>

<p>Let <em>H</em> be a Hopf algebra. If <em>A</em> is an <a href="algebra_over_a_field" title="wikilink">algebra</a> with the product operation μ : <em>A</em> ⊗ <em>A</em> → <em>A</em>, and ρ : <em>H</em> ⊗ <em>A</em> → <em>A</em> is a representation of <em>H</em> on <em>A</em>, then ρ is said to be a representation of <em>H</em> on an algebra if μ is <em>H</em>-<a class="uri" href="equivariant" title="wikilink">equivariant</a>. As special cases, Lie algebras, Lie superalgebras and groups can also have representations on an algebra.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Tannaka–Krein_reconstruction_theorem" title="wikilink">Tannaka–Krein reconstruction theorem</a></li>
</ul>

<p>"</p>

<p><a href="Category:Hopf_algebras" title="wikilink">Category:Hopf algebras</a> <a href="Category:Representation_theory" title="wikilink">Category:Representation theory</a></p>
</body>
</html>
