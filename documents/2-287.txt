   Matrix multiplication      Matrix multiplication   In mathematics , matrix multiplication is a binary operation that takes a pair of matrices , and produces another matrix. Numbers such as the real or complex numbers can be multiplied according to elementary arithmetic . On the other hand, matrices are arrays of numbers , so there is no unique way to define "the" multiplication of matrices. As such, in general the term "matrix multiplication" refers to a number of different ways to multiply matrices. The key features of any matrix multiplication include: the number of rows and columns the original matrices have (called the "size", "order" or "dimension" ), and specifying how the entries of the matrices generate the new matrix.  Like vectors , matrices of any size can be multiplied by scalars , which amounts to multiplying every entry of the matrix by the same number. Similar to the entrywise definition of adding or subtracting matrices , multiplication of two matrices of the same size can be defined by multiplying the corresponding entries, and this is known as the Hadamard product . Another definition is the Kronecker product of two matrices, to obtain a block matrix .  One can form many other definitions. However, the most useful definition can be motivated by linear equations and linear transformations on vectors, which have numerous applications in applied mathematics , physics , and engineering . This definition is often called the  matrix product . 1 2 In words, if   𝐀   𝐀   \mathbf{A}   is an    n  ×  m      n  normal-×  m    n×m   matrix and   𝐁   𝐁   \mathbf{B}   is an    m  ×  p      m  normal-×  p    m×p   matrix, their matrix product   𝐀𝐁   𝐀𝐁   \mathbf{AB}   is an    n  ×  p      n  normal-×  p    n×p   matrix, in which the   m   m   m   entries across the rows of   𝐀   𝐀   \mathbf{A}   are multiplied with the   m   m   m   entries down the columns of   𝐁   𝐁   \mathbf{B}   (the precise definition is below ).  This definition is not commutative , although it still retains the associative property and is distributive over entrywise addition of matrices. The identity element of the matrix product is the identity matrix (analogous to multiplying numbers by 1), and a square matrix may have an inverse matrix (analogous to the multiplicative inverse of a number). A consequence of the matrix product is determinant multiplicativity . The matrix product is an important operation in linear transformations , matrix groups , and the theory of group representations and irreps .  Computing matrix products is both a central operation in many numerical algorithms and potentially time consuming, making it one of the most well-studied problems in numerical computing . Various algorithms have been devised for computing    𝐂  =  𝐀𝐁      𝐂  𝐀𝐁    \mathbf{C}=\mathbf{AB}   , especially for large matrices.  This article will use the following notational conventions: matrices are represented by capital letters in bold, e.g.   𝐀   𝐀   \mathbf{A}   , vectors in lowercase bold, e.g.   𝐚   𝐚   \mathbf{a}   , and entries of vectors and matrices are italic (since they are scalars ), e.g.   A   A   A   and   a   a   a   . Index notation is often the clearest way to express definitions, and is used as standard in the literature. The    i  ,  j     i  j    i,j   entry of matrix   𝐀   𝐀   \mathbf{A}   is indicated by or , whereas a numerical label (not matrix entries) on a collection of matrices is subscripted only, e.g. , etc.  Scalar multiplication  The simplest form of multiplication associated with matrices is scalar multiplication, which is a special case of the Kronecker product .  The left scalar multiplication of a matrix   𝐀   𝐀   \mathbf{A}   with a scalar   λ   λ   λ   gives another matrix    λ  𝐀      λ  𝐀    λ\mathbf{A}   of the same size as   𝐀   𝐀   \mathbf{A}   . The entries of    λ  𝐀      λ  𝐀    λ\mathbf{A}   are defined by         (   λ  𝐀   )    i  j    =   λ     (  𝐀  )    i  j       ,       subscript    λ  𝐀     i  j      λ   subscript  𝐀    i  j       (\lambda\mathbf{A})_{ij}=\lambda\left(\mathbf{A}\right)_{ij}\,,     explicitly:        λ  𝐀   =   λ   (      A  11      A  12     ⋯     A   1  m         A  21      A  22     ⋯     A   2  m        ⋮    ⋮    ⋱    ⋮       A   n  1       A   n  2      ⋯     A   n  m       )    =    (      λ   A  11       λ   A  12      ⋯     λ   A   1  m          λ   A  21       λ   A  22      ⋯     λ   A   2  m         ⋮    ⋮    ⋱    ⋮       λ   A   n  1        λ   A   n  2       ⋯     λ   A   n  m        )     .          λ  𝐀     λ     subscript  A  11    subscript  A  12   normal-⋯   subscript  A    1  m       subscript  A  21    subscript  A  22   normal-⋯   subscript  A    2  m      normal-⋮  normal-⋮  normal-⋱  normal-⋮     subscript  A    n  1     subscript  A    n  2    normal-⋯   subscript  A    n  m                λ   subscript  A  11      λ   subscript  A  12    normal-⋯    λ   subscript  A    1  m         λ   subscript  A  21      λ   subscript  A  22    normal-⋯    λ   subscript  A    2  m       normal-⋮  normal-⋮  normal-⋱  normal-⋮      λ   subscript  A    n  1       λ   subscript  A    n  2     normal-⋯    λ   subscript  A    n  m          \lambda\mathbf{A}=\lambda\begin{pmatrix}A_{11}&A_{12}&\cdots&A_{1m}\\
 A_{21}&A_{22}&\cdots&A_{2m}\\
 \vdots&\vdots&\ddots&\vdots\\
 A_{n1}&A_{n2}&\cdots&A_{nm}\\
 \end{pmatrix}=\begin{pmatrix}\lambda A_{11}&\lambda A_{12}&\cdots&\lambda A_{1%
 m}\\
 \lambda A_{21}&\lambda A_{22}&\cdots&\lambda A_{2m}\\
 \vdots&\vdots&\ddots&\vdots\\
 \lambda A_{n1}&\lambda A_{n2}&\cdots&\lambda A_{nm}\\
 \end{pmatrix}\,.     Similarly, the right scalar multiplication of a matrix   𝐀   𝐀   \mathbf{A}   with a scalar   λ   λ   λ   is defined to be         (   𝐀  λ   )    i  j    =     (  𝐀  )    i  j     λ     ,       subscript    𝐀  λ     i  j       subscript  𝐀    i  j    λ     (\mathbf{A}\lambda)_{ij}=\left(\mathbf{A}\right)_{ij}\lambda\,,     explicitly:        𝐀  λ   =    (      A  11      A  12     ⋯     A   1  m         A  21      A  22     ⋯     A   2  m        ⋮    ⋮    ⋱    ⋮       A   n  1       A   n  2      ⋯     A   n  m       )   λ   =    (       A  11   λ       A  12   λ     ⋯      A   1  m    λ         A  21   λ       A  22   λ     ⋯      A   2  m    λ       ⋮    ⋮    ⋱    ⋮        A   n  1    λ       A   n  2    λ     ⋯      A   n  m    λ      )     .          𝐀  λ        subscript  A  11    subscript  A  12   normal-⋯   subscript  A    1  m       subscript  A  21    subscript  A  22   normal-⋯   subscript  A    2  m      normal-⋮  normal-⋮  normal-⋱  normal-⋮     subscript  A    n  1     subscript  A    n  2    normal-⋯   subscript  A    n  m      λ             subscript  A  11   λ      subscript  A  12   λ   normal-⋯     subscript  A    1  m    λ        subscript  A  21   λ      subscript  A  22   λ   normal-⋯     subscript  A    2  m    λ     normal-⋮  normal-⋮  normal-⋱  normal-⋮       subscript  A    n  1    λ      subscript  A    n  2    λ   normal-⋯     subscript  A    n  m    λ        \mathbf{A}\lambda=\begin{pmatrix}A_{11}&A_{12}&\cdots&A_{1m}\\
 A_{21}&A_{22}&\cdots&A_{2m}\\
 \vdots&\vdots&\ddots&\vdots\\
 A_{n1}&A_{n2}&\cdots&A_{nm}\\
 \end{pmatrix}\lambda=\begin{pmatrix}A_{11}\lambda&A_{12}\lambda&\cdots&A_{1m}%
 \lambda\\
 A_{21}\lambda&A_{22}\lambda&\cdots&A_{2m}\lambda\\
 \vdots&\vdots&\ddots&\vdots\\
 A_{n1}\lambda&A_{n2}\lambda&\cdots&A_{nm}\lambda\\
 \end{pmatrix}\,.     When the underlying ring is commutative , for example, the real or complex number  field , these two multiplications are the same, and are simply called scalar multiplication . However, for matrices over a more general ring that are not commutative, such as the quaternions , they may not be equal.  For a real scalar and matrix:       λ  =  2   ,   𝐀  =   (     a    b      c    d     )       formulae-sequence    λ  2     𝐀    a  b    c  d       \lambda=2,\quad\mathbf{A}=\begin{pmatrix}a&b\\
 c&d\\
 \end{pmatrix}          2  𝐀   =   2   (     a    b      c    d     )    =   (       2   ⋅  a       2   ⋅  b         2   ⋅  c       2   ⋅  d      )   =   (       a   ⋅  2       b   ⋅  2         c   ⋅  2       d   ⋅  2      )   =    (     a    b      c    d     )   2   =   𝐀  2.           2  𝐀     2    a  b    c  d             normal-⋅  2  a    normal-⋅  2  b      normal-⋅  2  c    normal-⋅  2  d             normal-⋅  a  2    normal-⋅  b  2      normal-⋅  c  2    normal-⋅  d  2              a  b    c  d    2          𝐀  2.      2\mathbf{A}=2\begin{pmatrix}a&b\\
 c&d\\
 \end{pmatrix}=\begin{pmatrix}2\!\cdot\!a&2\!\cdot\!b\\
 2\!\cdot\!c&2\!\cdot\!d\\
 \end{pmatrix}=\begin{pmatrix}a\!\cdot\!2&b\!\cdot\!2\\
 c\!\cdot\!2&d\!\cdot\!2\\
 \end{pmatrix}=\begin{pmatrix}a&b\\
 c&d\\
 \end{pmatrix}2=\mathbf{A}2.     For quaternion scalars and matrices:       λ  =  i   ,   𝐀  =   (     i    0      0    j     )       formulae-sequence    λ  i     𝐀    i  0    0  j       \lambda=i,\quad\mathbf{A}=\begin{pmatrix}i&0\\
 0&j\\
 \end{pmatrix}           i   (     i    0      0    j     )    =   (      i  2     0      0     i  j      )   =   (      -  1     0      0    k     )   ≠   (      -  1     0      0     -  k      )   =   (      i  2     0      0     j  i      )   =    (     i    0      0    j     )    i     ,          i    i  0    0  j        superscript  i  2   0    0    i  j              1   0    0  k             1   0    0    k             superscript  i  2   0    0    j  i              i  0    0  j    i      i\begin{pmatrix}i&0\\
 0&j\\
 \end{pmatrix}=\begin{pmatrix}i^{2}&0\\
 0&ij\\
 \end{pmatrix}=\begin{pmatrix}-1&0\\
 0&k\\
 \end{pmatrix}\neq\begin{pmatrix}-1&0\\
 0&-k\\
 \end{pmatrix}=\begin{pmatrix}i^{2}&0\\
 0&ji\\
 \end{pmatrix}=\begin{pmatrix}i&0\\
 0&j\\
 \end{pmatrix}i\,,     where    i  ,  j  ,  k     i  j  k    i,j,k   are the quaternion units. The non-commutativity of quaternion multiplication prevents the transition of changing     i  j   =   +  k         i  j     k     ij=+k   to     j  i   =   −  k         j  i     normal-−  k     ji=−k   .  Matrix product (two matrices)  Assume two matrices are to be multiplied (the generalization to any number is discussed below).  General definition of the matrix product  (Figure)  "300px"|thumb|Arithmetic process of multiplying numbers (solid lines) in row   i   i   i   in matrix   𝐀   𝐀   \mathbf{A}    and column   j   j   j   in matrix   𝐁   𝐁   \mathbf{B}    , then adding the terms (dashed lines) to obtain entry    i  j      i  j    ij   in the final matrix.   If   𝐀   𝐀   \mathbf{A}   is an    n  ×  m      n  normal-×  m    n×m   matrix and   𝐁   𝐁   \mathbf{B}   is an    m  ×  p      m  normal-×  p    m×p   matrix,       𝐀  =   (      A  11      A  12     ⋯     A   1  m         A  21      A  22     ⋯     A   2  m        ⋮    ⋮    ⋱    ⋮       A   n  1       A   n  2      ⋯     A   n  m       )    ,   𝐁  =   (      B  11      B  12     ⋯     B   1  p         B  21      B  22     ⋯     B   2  p        ⋮    ⋮    ⋱    ⋮       B   m  1       B   m  2      ⋯     B   m  p       )       formulae-sequence    𝐀     subscript  A  11    subscript  A  12   normal-⋯   subscript  A    1  m       subscript  A  21    subscript  A  22   normal-⋯   subscript  A    2  m      normal-⋮  normal-⋮  normal-⋱  normal-⋮     subscript  A    n  1     subscript  A    n  2    normal-⋯   subscript  A    n  m         𝐁     subscript  B  11    subscript  B  12   normal-⋯   subscript  B    1  p       subscript  B  21    subscript  B  22   normal-⋯   subscript  B    2  p      normal-⋮  normal-⋮  normal-⋱  normal-⋮     subscript  B    m  1     subscript  B    m  2    normal-⋯   subscript  B    m  p         \mathbf{A}=\begin{pmatrix}A_{11}&A_{12}&\cdots&A_{1m}\\
 A_{21}&A_{22}&\cdots&A_{2m}\\
 \vdots&\vdots&\ddots&\vdots\\
 A_{n1}&A_{n2}&\cdots&A_{nm}\\
 \end{pmatrix},\quad\mathbf{B}=\begin{pmatrix}B_{11}&B_{12}&\cdots&B_{1p}\\
 B_{21}&B_{22}&\cdots&B_{2p}\\
 \vdots&\vdots&\ddots&\vdots\\
 B_{m1}&B_{m2}&\cdots&B_{mp}\\
 \end{pmatrix}     the matrix product    𝐀𝐁   𝐀𝐁   \mathbf{AB}   (denoted without multiplication signs or dots) is defined to be the    n  ×  p      n  normal-×  p    n×p   matrix 3 4 5 6      𝐀𝐁  =   (       (  𝐀𝐁  )   11       (  𝐀𝐁  )   12     ⋯      (  𝐀𝐁  )    1  p          (  𝐀𝐁  )   21       (  𝐀𝐁  )   22     ⋯      (  𝐀𝐁  )    2  p        ⋮    ⋮    ⋱    ⋮        (  𝐀𝐁  )    n  1        (  𝐀𝐁  )    n  2      ⋯      (  𝐀𝐁  )    n  p       )       𝐀𝐁     subscript  𝐀𝐁  11    subscript  𝐀𝐁  12   normal-⋯   subscript  𝐀𝐁    1  p       subscript  𝐀𝐁  21    subscript  𝐀𝐁  22   normal-⋯   subscript  𝐀𝐁    2  p      normal-⋮  normal-⋮  normal-⋱  normal-⋮     subscript  𝐀𝐁    n  1     subscript  𝐀𝐁    n  2    normal-⋯   subscript  𝐀𝐁    n  p        \mathbf{A}\mathbf{B}=\begin{pmatrix}\left(\mathbf{AB}\right)_{11}&\left(%
 \mathbf{AB}\right)_{12}&\cdots&\left(\mathbf{AB}\right)_{1p}\\
 \left(\mathbf{AB}\right)_{21}&\left(\mathbf{AB}\right)_{22}&\cdots&\left(%
 \mathbf{AB}\right)_{2p}\\
 \vdots&\vdots&\ddots&\vdots\\
 \left(\mathbf{AB}\right)_{n1}&\left(\mathbf{AB}\right)_{n2}&\cdots&\left(%
 \mathbf{AB}\right)_{np}\\
 \end{pmatrix}     where each    i  ,  j     i  j    i,j   entry is given by multiplying the entries (across row   i   i   i   of   𝐀   𝐀   \mathbf{A}   ) by the entries (down column   j   j   j   of   𝐁   𝐁   \mathbf{B}   ), for    k  =   1  ,  2  ,  …  ,  m       k   1  2  normal-…  m     k=1,2,...,m   , and summing the results over   k   k   k   :         (  𝐀𝐁  )    i  j    =    ∑   k  =  1   m     A   i  k      B   k  j        .       subscript  𝐀𝐁    i  j      superscript   subscript     k  1    m      subscript  A    i  k     subscript  B    k  j        (\mathbf{A}\mathbf{B})_{ij}=\sum_{k=1}^{m}A_{ik}B_{kj}\,.     Thus the product   𝐀𝐁   𝐀𝐁   \mathbf{AB}   is defined only if the number of columns in   𝐀   𝐀   \mathbf{A}   is equal to the number of rows in   𝐁   𝐁   \mathbf{B}   , in this case   m   m   m   . Each entry may be computed one at a time. Sometimes, the summation convention is used as it is understood to sum over the repeated index   k   k   k   . To prevent any ambiguity, this convention will not be used in the article.  Usually the entries are numbers or expressions , but can even be matrices themselves (see block matrix ). The matrix product can still be calculated exactly the same way. See below for details on how the matrix product can be calculated in terms of blocks taking the forms of rows and columns.  Illustration  (Figure)  Matrix multiplication diagram 2.svg   The figure to the right illustrates diagrammatically the product of two matrices   𝐀   𝐀   \mathbf{A}   and   𝐁   𝐁   \mathbf{B}   , showing how each intersection in the product matrix corresponds to a row of   𝐀   𝐀   \mathbf{A}   and a column of   𝐁   𝐁   \mathbf{B}   .         [       \color   B  r  o  w  n   a  11        \color   B  r  o  w  n   a  12        ⋅    ⋅        \color   O  r  a  n  g  e   a  31        \color   O  r  a  n  g  e   a  32        ⋅    ⋅     ]     4  ×  2   matrix      [     ⋅      \color   P  l  u  m   b  12        \color   V  i  o  l  e  t   b  13        ⋅      \color   P  l  u  m   b  22        \color   V  i  o  l  e  t   b  23       ]     2  ×  3   matrix     =    [     ⋅     x  12      x  13       ⋅    ⋅    ⋅      ⋅     x  32      x  33       ⋅    ⋅    ⋅     ]     4  ×  3   matrix               4  2   matrix       \color  B  r  o  w  n   subscript  a  11      \color  B  r  o  w  n   subscript  a  12      normal-⋅  normal-⋅      \color  O  r  a  n  g  e   subscript  a  31      \color  O  r  a  n  g  e   subscript  a  32      normal-⋅  normal-⋅          2  3   matrix     normal-⋅    \color  P  l  u  m   subscript  b  12      \color  V  i  o  l  e  t   subscript  b  13      normal-⋅    \color  P  l  u  m   subscript  b  22      \color  V  i  o  l  e  t   subscript  b  23             4  3   matrix     normal-⋅   subscript  x  12    subscript  x  13     normal-⋅  normal-⋅  normal-⋅    normal-⋅   subscript  x  32    subscript  x  33     normal-⋅  normal-⋅  normal-⋅       \overset{4\times 2\text{ matrix}}{\begin{bmatrix}{\color{Brown}{a_{11}}}&{%
 \color{Brown}{a_{12}}}\\
 \cdot&\cdot\\
 {\color{Orange}{a_{31}}}&{\color{Orange}{a_{32}}}\\
 \cdot&\cdot\\
 \end{bmatrix}}\par
 \overset{2\times 3\text{ matrix}}{\begin{bmatrix}\cdot&{%
 \color{Plum}{b_{12}}}&{\color{Violet}{b_{13}}}\\
 \cdot&{\color{Plum}{b_{22}}}&{\color{Violet}{b_{23}}}\\
 \end{bmatrix}}\par
 =\overset{4\times 3\text{ matrix}}{\begin{bmatrix}\cdot&x_{%
 12}&x_{13}\\
 \cdot&\cdot&\cdot\\
 \cdot&x_{32}&x_{33}\\
 \cdot&\cdot&\cdot\\
 \end{bmatrix}}     The values at the intersections marked with circles are:      x  12     subscript  x  12    \displaystyle x_{12}     Examples of matrix products  Row vector and column vector  If        𝐀  =    (     a    b    c     )     ,   𝐁  =    (     x      y      z     )      ,     formulae-sequence    𝐀    a  b  c       𝐁    x    y    z       \mathbf{A}=\begin{pmatrix}a&b&c\end{pmatrix}\,,\quad\mathbf{B}=\begin{pmatrix}%
 x\\
 y\\
 z\end{pmatrix}\,,     their matrix products are:       𝐀𝐁  =    (     a    b    c     )    (     x      y      z     )    =    a  x   +   b  y   +   c   z      ,        𝐀𝐁      a  b  c      x    y    z              a  x     b  y     c  z       \mathbf{AB}=\begin{pmatrix}a&b&c\end{pmatrix}\begin{pmatrix}x\\
 y\\
 z\end{pmatrix}=ax+by+cz\,,     and       𝐁𝐀  =    (     x      y      z     )    (     a    b    c     )    =    (      x  a      x  b      x  c        y  a      y  b      y  c        z  a      z  b      z  c      )     .        𝐁𝐀      x    y    z      a  b  c              x  a     x  b     x  c       y  a     y  b     y  c       z  a     z  b     z  c        \mathbf{BA}=\begin{pmatrix}x\\
 y\\
 z\end{pmatrix}\begin{pmatrix}a&b&c\end{pmatrix}=\begin{pmatrix}xa&xb&xc\\
 ya&yb&yc\\
 za&zb&zc\end{pmatrix}\,.     Note   𝐀𝐁   𝐀𝐁   \mathbf{AB}   and   𝐁𝐀   𝐁𝐀   \mathbf{BA}   are two different matrices: the first is a    1  ×  1      1  normal-×  1    1×1   matrix while the second is a    3  ×  3      3  normal-×  3    3×3   matrix. Such expressions occur for real-valued Euclidean vectors in Cartesian coordinates , displayed as row and column matrices, in which case   𝐀𝐁   𝐀𝐁   \mathbf{AB}   is the matrix form of their dot product , while   𝐁𝐀   𝐁𝐀   \mathbf{BA}   the matrix form of their dyadic or tensor product.  Square matrix and column vector  If        𝐀  =   (     a    b    c      p    q    r      u    v    w     )    ,   𝐁  =    (     x      y      z     )      ,     formulae-sequence    𝐀    a  b  c    p  q  r    u  v  w       𝐁    x    y    z       \mathbf{A}=\begin{pmatrix}a&b&c\\
 p&q&r\\
 u&v&w\end{pmatrix},\quad\mathbf{B}=\begin{pmatrix}x\\
 y\\
 z\end{pmatrix}\,,     their matrix product is:       𝐀𝐁  =    (     a    b    c      p    q    r      u    v    w     )    (     x      y      z     )    =    (       a  x   +   b  y   +   c  z          p  x   +   q  y   +   r  z          u  x   +   v  y   +   w  z       )     ,        𝐀𝐁      a  b  c    p  q  r    u  v  w      x    y    z                a  x     b  y     c  z          p  x     q  y     r  z          u  x     v  y     w  z         \mathbf{AB}=\begin{pmatrix}a&b&c\\
 p&q&r\\
 u&v&w\end{pmatrix}\begin{pmatrix}x\\
 y\\
 z\end{pmatrix}=\begin{pmatrix}ax+by+cz\\
 px+qy+rz\\
 ux+vy+wz\end{pmatrix}\,,     however   𝐁𝐀   𝐁𝐀   \mathbf{BA}   is not defined.  The product of a square matrix multiplied by a column matrix arises naturally in linear algebra ; for solving linear equations and representing linear transformations . By choosing    a  ,  b  ,  c  ,  p  ,  q  ,  r  ,  u  ,  v  ,  w     a  b  c  p  q  r  u  v  w    a,b,c,p,q,r,u,v,w   in   𝐀   𝐀   \mathbf{A}   appropriately,   𝐀   𝐀   \mathbf{A}   can represent a variety of transformations such as rotations , scaling and reflections , shears , of a geometric shape in space.  Square matrices  If        𝐀  =   (     a    b    c      p    q    r      u    v    w     )    ,   𝐁  =    (     α    β    γ      λ    μ    ν      ρ    σ    τ     )      ,     formulae-sequence    𝐀    a  b  c    p  q  r    u  v  w       𝐁    α  β  γ    λ  μ  ν    ρ  σ  τ       \mathbf{A}=\begin{pmatrix}a&b&c\\
 p&q&r\\
 u&v&w\end{pmatrix},\quad\mathbf{B}=\begin{pmatrix}\alpha&\beta&\gamma\\
 \lambda&\mu&\nu\\
 \rho&\sigma&\tau\\
 \end{pmatrix}\,,     their matrix products are:       𝐀𝐁  =    (     a    b    c      p    q    r      u    v    w     )    (     α    β    γ      λ    μ    ν      ρ    σ    τ     )    =    (       a  α   +   b  λ   +   c  ρ        a  β   +   b  μ   +   c  σ        a  γ   +   b  ν   +   c  τ          p  α   +   q  λ   +   r  ρ        p  β   +   q  μ   +   r  σ        p  γ   +   q  ν   +   r  τ          u  α   +   v  λ   +   w  ρ        u  β   +   v  μ   +   w  σ        u  γ   +   v  ν   +   w  τ       )     ,        𝐀𝐁      a  b  c    p  q  r    u  v  w      α  β  γ    λ  μ  ν    ρ  σ  τ                a  α     b  λ     c  ρ        a  β     b  μ     c  σ        a  γ     b  ν     c  τ          p  α     q  λ     r  ρ        p  β     q  μ     r  σ        p  γ     q  ν     r  τ          u  α     v  λ     w  ρ        u  β     v  μ     w  σ        u  γ     v  ν     w  τ         \mathbf{AB}=\begin{pmatrix}a&b&c\\
 p&q&r\\
 u&v&w\end{pmatrix}\begin{pmatrix}\alpha&\beta&\gamma\\
 \lambda&\mu&\nu\\
 \rho&\sigma&\tau\\
 \end{pmatrix}=\begin{pmatrix}a\alpha+b\lambda+c\rho&a\beta+b\mu+c\sigma&a%
 \gamma+b\nu+c\tau\\
 p\alpha+q\lambda+r\rho&p\beta+q\mu+r\sigma&p\gamma+q\nu+r\tau\\
 u\alpha+v\lambda+w\rho&u\beta+v\mu+w\sigma&u\gamma+v\nu+w\tau\end{pmatrix}\,,     and       𝐁𝐀  =    (     α    β    γ      λ    μ    ν      ρ    σ    τ     )    (     a    b    c      p    q    r      u    v    w     )    =    (       α  a   +   β  p   +   γ  u        α  b   +   β  q   +   γ  v        α  c   +   β  r   +   γ  w          λ  a   +   μ  p   +   ν  u        λ  b   +   μ  q   +   ν  v        λ  c   +   μ  r   +   ν  w          ρ  a   +   σ  p   +   τ  u        ρ  b   +   σ  q   +   τ  v        ρ  c   +   σ  r   +   τ  w       )     .        𝐁𝐀      α  β  γ    λ  μ  ν    ρ  σ  τ      a  b  c    p  q  r    u  v  w                α  a     β  p     γ  u        α  b     β  q     γ  v        α  c     β  r     γ  w          λ  a     μ  p     ν  u        λ  b     μ  q     ν  v        λ  c     μ  r     ν  w          ρ  a     σ  p     τ  u        ρ  b     σ  q     τ  v        ρ  c     σ  r     τ  w         \mathbf{BA}=\begin{pmatrix}\alpha&\beta&\gamma\\
 \lambda&\mu&\nu\\
 \rho&\sigma&\tau\\
 \end{pmatrix}\begin{pmatrix}a&b&c\\
 p&q&r\\
 u&v&w\end{pmatrix}=\begin{pmatrix}\alpha a+\beta p+\gamma u&\alpha b+\beta q+%
 \gamma v&\alpha c+\beta r+\gamma w\\
 \lambda a+\mu p+\nu u&\lambda b+\mu q+\nu v&\lambda c+\mu r+\nu w\\
 \rho a+\sigma p+\tau u&\rho b+\sigma q+\tau v&\rho c+\sigma r+\tau w\end{%
 pmatrix}\,.     In this case, both products   𝐀𝐁   𝐀𝐁   \mathbf{AB}   and   𝐁𝐀   𝐁𝐀   \mathbf{BA}   are defined, and the entries show that   𝐀𝐁   𝐀𝐁   \mathbf{AB}   and   𝐁𝐀   𝐁𝐀   \mathbf{BA}   are not equal in general. Multiplying square matrices which represent linear transformations corresponds to the composite transformation (see below for details).  Row vector, square matrix, and column vector  If        𝐀  =    (     a    b    c     )     ,    𝐁  =    (     α    β    γ      λ    μ    ν      ρ    σ    τ     )     ,   𝐂  =    (     x      y      z     )       ,     formulae-sequence    𝐀    a  b  c      formulae-sequence    𝐁    α  β  γ    λ  μ  ν    ρ  σ  τ       𝐂    x    y    z        \mathbf{A}=\begin{pmatrix}a&b&c\end{pmatrix}\,,\quad\mathbf{B}=\begin{pmatrix}%
 \alpha&\beta&\gamma\\
 \lambda&\mu&\nu\\
 \rho&\sigma&\tau\\
 \end{pmatrix}\,,\quad\mathbf{C}=\begin{pmatrix}x\\
 y\\
 z\end{pmatrix}\,,     their matrix product is:     𝐀𝐁𝐂   𝐀𝐁𝐂   \displaystyle\mathbf{ABC}     however   𝐂𝐁𝐀   𝐂𝐁𝐀   \mathbf{CBA}   is not defined. Note that     𝐀   (  𝐁𝐂  )    =    (  𝐀𝐁  )   𝐂         𝐀  𝐁𝐂     𝐀𝐁  𝐂     \mathbf{A}(\mathbf{BC})=(\mathbf{AB})\mathbf{C}   , this is one of many general properties listed below. Expressions of the form   𝐀𝐁𝐂   𝐀𝐁𝐂   \mathbf{ABC}   occur when calculating the inner product of two vectors displayed as row and column vectors in an arbitrary coordinate system , and the metric tensor in these coordinates written as the square matrix.  Rectangular matrices  If        𝐀  =    (     a    b    c      x    y    z     )     ,   𝐁  =    (     α    ρ      β    σ      γ    τ     )      ,     formulae-sequence    𝐀    a  b  c    x  y  z       𝐁    α  ρ    β  σ    γ  τ       \mathbf{A}=\begin{pmatrix}a&b&c\\
 x&y&z\end{pmatrix}\,,\quad\mathbf{B}=\begin{pmatrix}\alpha&\rho\\
 \beta&\sigma\\
 \gamma&\tau\\
 \end{pmatrix}\,,     their matrix products are:       𝐀𝐁  =    (     a    b    c      x    y    z     )    (     α    ρ      β    σ      γ    τ     )    =    (       a  α   +   b  β   +   c  γ        a  ρ   +   b  σ   +   c  τ          x  α   +   y  β   +   z  γ        x  ρ   +   y  σ   +   z  τ       )     ,        𝐀𝐁      a  b  c    x  y  z      α  ρ    β  σ    γ  τ                a  α     b  β     c  γ        a  ρ     b  σ     c  τ          x  α     y  β     z  γ        x  ρ     y  σ     z  τ         \mathbf{A}\mathbf{B}=\begin{pmatrix}a&b&c\\
 x&y&z\end{pmatrix}\begin{pmatrix}\alpha&\rho\\
 \beta&\sigma\\
 \gamma&\tau\\
 \end{pmatrix}=\begin{pmatrix}a\alpha+b\beta+c\gamma&a\rho+b\sigma+c\tau\\
 x\alpha+y\beta+z\gamma&x\rho+y\sigma+z\tau\\
 \end{pmatrix}\,,     and       𝐁𝐀  =    (     α    ρ      β    σ      γ    τ     )    (     a    b    c      x    y    z     )    =    (       α  a   +   ρ  x        α  b   +   ρ  y        α  c   +   ρ  z          β  a   +   σ  x        β  b   +   σ  y        β  c   +   σ  z          γ  a   +   τ  x        γ  b   +   τ  y        γ  c   +   τ  z       )     .        𝐁𝐀      α  ρ    β  σ    γ  τ      a  b  c    x  y  z                α  a     ρ  x        α  b     ρ  y        α  c     ρ  z          β  a     σ  x        β  b     σ  y        β  c     σ  z          γ  a     τ  x        γ  b     τ  y        γ  c     τ  z         \mathbf{B}\mathbf{A}=\begin{pmatrix}\alpha&\rho\\
 \beta&\sigma\\
 \gamma&\tau\\
 \end{pmatrix}\begin{pmatrix}a&b&c\\
 x&y&z\end{pmatrix}=\begin{pmatrix}\alpha a+\rho x&\alpha b+\rho y&\alpha c+%
 \rho z\\
 \beta a+\sigma x&\beta b+\sigma y&\beta c+\sigma z\\
 \gamma a+\tau x&\gamma b+\tau y&\gamma c+\tau z\end{pmatrix}\,.     Properties of the matrix product (two matrices)  Analogous to numbers (elements of a field ), matrices satisfy the following general properties , although there is one subtlety, due to the nature of matrix multiplication. 7 8  All matrices  Square matrices only  Matrix product (any number)  Matrix multiplication can be extended to the case of more than two matrices, provided that for each sequential pair, their dimensions match.  The product of   n   n   n   matrices with sizes (where are all simply positive integers and the subscripts are labels corresponding to the matrices, nothing more), is the matrix:         ∏   i  =  1   n    𝐀  i    =    𝐀  1    𝐀  2   ⋯    𝐀  n      .        superscript   subscript  product    i  1    n    subscript  𝐀  i       subscript  𝐀  1    subscript  𝐀  2   normal-⋯   subscript  𝐀  n      \prod_{i=1}^{n}\mathbf{A}_{i}=\mathbf{A}_{1}\mathbf{A}_{2}\cdots\mathbf{A}_{n}\,.     In index notation:        (    𝐀  1    𝐀  2   ⋯   𝐀  n    )     i  0    i  n     =    ∑    i  1   =  1    s  1      ∑    i  2   =  1    s  2     ⋯    ∑    i   n  -  1    =  1    s   n  -  1        (   𝐀  1   )     i  0    i  1       (   𝐀  2   )     i  1    i  2       (   𝐀  3   )     i  2    i  3     ⋯    (   𝐀   n  -  1    )     i   n  -  2     i   n  -  1        (   𝐀  n   )     i   n  -  1     i  n               subscript     subscript  𝐀  1    subscript  𝐀  2   normal-⋯   subscript  𝐀  n       subscript  i  0    subscript  i  n       superscript   subscript      subscript  i  1   1     subscript  s  1      superscript   subscript      subscript  i  2   1     subscript  s  2      normal-⋯    superscript   subscript      subscript  i    n  1    1     subscript  s    n  1        subscript   subscript  𝐀  1      subscript  i  0    subscript  i  1      subscript   subscript  𝐀  2      subscript  i  1    subscript  i  2      subscript   subscript  𝐀  3      subscript  i  2    subscript  i  3     normal-⋯   subscript   subscript  𝐀    n  1       subscript  i    n  2     subscript  i    n  1       subscript   subscript  𝐀  n      subscript  i    n  1     subscript  i  n            \left(\mathbf{A}_{1}\mathbf{A}_{2}\cdots\mathbf{A}_{n}\right)_{i_{0}i_{n}}=%
 \sum_{i_{1}=1}^{s_{1}}\sum_{i_{2}=1}^{s_{2}}\cdots\sum_{i_{n-1}=1}^{s_{n-1}}%
 \left(\mathbf{A}_{1}\right)_{i_{0}i_{1}}\left(\mathbf{A}_{2}\right)_{i_{1}i_{2%
 }}\left(\mathbf{A}_{3}\right)_{i_{2}i_{3}}\cdots\left(\mathbf{A}_{n-1}\right)_%
 {i_{n-2}i_{n-1}}\left(\mathbf{A}_{n}\right)_{i_{n-1}i_{n}}     Properties of the matrix product (any number)  The same properties will hold, as long as the ordering of matrices is not changed. Some of the previous properties for more than two matrices generalize as follows.  Examples of chain multiplication  Similarity transformations involving similar matrices are matrix products of the three square matrices, in the form:      𝐁  =    𝐏   -  1    𝐀𝐏       𝐁     superscript  𝐏    1    𝐀𝐏     \mathbf{B}=\mathbf{P}^{-1}\mathbf{A}\mathbf{P}     where   𝐏   𝐏   \mathbf{P}   is the similarity matrix and   𝐀   𝐀   \mathbf{A}   and   𝐁   𝐁   \mathbf{B}   are said to be similar if this relation holds. This product appears frequently in linear algebra and applications, such as diagonalizing square matrices and the equivalence between different matrix representations of the same linear operator .  Operations derived from the matrix product  More operations on square matrices can be defined using the matrix product, such as powers and nth roots by repeated matrix products, the matrix exponential can be defined by a power series , the matrix logarithm is the inverse of matrix exponentiation , and so on.  Powers of matrices  Square matrices can be multiplied by themselves repeatedly in the same way as ordinary numbers, because they always have the same number of rows and columns. This repeated multiplication can be described as a power of the matrix , a special case of the ordinary matrix product. On the contrary, rectangular matrices do not have the same number of rows and columns so they can never be raised to a power. An    n  ×  n      n  normal-×  n    n×n   matrix   𝐀   𝐀   \mathbf{A}   raised to a positive integer   k   k   k   is defined as       𝐀  k   =    𝐀𝐀  ⋯  𝐀     k   times         superscript  𝐀  k      k  times     𝐀𝐀  normal-⋯  𝐀      \mathbf{A}^{k}=\underset{k\mathrm{\,times}}{\mathbf{A}\mathbf{A}\cdots\mathbf{%
 A}}     and the following identities hold, where   λ   λ   λ   is a scalar:  The naive computation of matrix powers is to multiply   k   k   k   times the matrix   𝐀   𝐀   \mathbf{A}   to the result, starting with the identity matrix just like the scalar case. This can be improved using exponentiation by squaring , a method commonly used for scalars. For diagonalizable matrices , an even better method is to use the eigenvalue decomposition of   𝐀   𝐀   \mathbf{A}   . Another method based on the Cayley–Hamilton theorem finds an identity using the matrices' characteristic polynomial , producing a more effective equation for in which a scalar is raised to the required power, rather than an entire matrix .  A special case is the power of a diagonal matrix . Since the product of diagonal matrices amounts to simply multiplying corresponding diagonal elements together, the power   k   k   k   of a diagonal matrix   𝐀   𝐀   \mathbf{A}   will have entries raised to the power. Explicitly;       𝐀  k   =    (      A  11     0    ⋯    0      0     A  22     ⋯    0      ⋮    ⋮    ⋱    ⋮      0    0    ⋯     A   n  n       )   k   =   (      A  11  k     0    ⋯    0      0     A  22  k     ⋯    0      ⋮    ⋮    ⋱    ⋮      0    0    ⋯     A   n  n   k      )          superscript  𝐀  k    superscript     subscript  A  11   0  normal-⋯  0    0   subscript  A  22   normal-⋯  0    normal-⋮  normal-⋮  normal-⋱  normal-⋮    0  0  normal-⋯   subscript  A    n  n      k           superscript   subscript  A  11   k   0  normal-⋯  0    0   superscript   subscript  A  22   k   normal-⋯  0    normal-⋮  normal-⋮  normal-⋱  normal-⋮    0  0  normal-⋯   superscript   subscript  A    n  n    k        \mathbf{A}^{k}=\begin{pmatrix}A_{11}&0&\cdots&0\\
 0&A_{22}&\cdots&0\\
 \vdots&\vdots&\ddots&\vdots\\
 0&0&\cdots&A_{nn}\end{pmatrix}^{k}=\begin{pmatrix}A_{11}^{k}&0&\cdots&0\\
 0&A_{22}^{k}&\cdots&0\\
 \vdots&\vdots&\ddots&\vdots\\
 0&0&\cdots&A_{nn}^{k}\end{pmatrix}     meaning it is easy to raise a diagonal matrix to a power. When raising an arbitrary matrix (not necessarily a diagonal matrix) to a power, it is often helpful to exploit this property by diagonalizing the matrix first.  Applications of the matrix product  Linear transformations  Matrices offer a concise way of representing linear transformations between vector spaces , and matrix multiplication corresponds to the composition of linear transformations. The matrix product of two matrices can be defined when their entries belong to the same ring , and hence can be added and multiplied.  Let    U  ,  V     U  V    U,V   , and   W   W   W   be vector spaces over the same field with given bases ,    S  :   V  →  W      normal-:  S    V  normal-→  W     S:V→W   and    T  :   U  →  V      normal-:  T    U  normal-→  V     T:U→V   be linear transformations and     S  T   :   U  →  W      normal-:    S  T     U  normal-→  W     ST:U→W   be their composition.  Suppose that    𝐀  ,  𝐁     𝐀  𝐁    \mathbf{A},\mathbf{B}   , and   𝐂   𝐂   \mathbf{C}   are the matrices representing the transformations    S  ,  T     S  T    S,T   , and    S  T      S  T    ST   with respect to the given bases.  Then    𝐀𝐁  =  𝐂      𝐀𝐁  𝐂    \mathbf{AB}=\mathbf{C}   , that is, the matrix of the composition (or the product) of linear transformations is the product of their matrices with respect to the given bases.  Linear systems of equations  A system of linear equations with the same number of equations as variables can be solved by collecting the coefficients of the equations into a square matrix, then inverting the matrix equation.  A similar procedure can be used to solve a system of linear differential equations , see also phase plane .  Group theory and representation theory  The inner and outer products  Given two column vectors    𝐚   𝐚   \mathbf{a}   and   𝐛   𝐛   \mathbf{b}   , the Euclidean inner product and outer product are the simplest special cases of the matrix product. 9  Inner product  The inner product of two vectors in matrix form is equivalent to a column vector multiplied on the left by a row vector:      𝐚  ⋅  𝐛     normal-⋅  𝐚  𝐛    \displaystyle\mathbf{a}\cdot\mathbf{b}   where denotes the transpose of a .  The matrix product itself can be expressed in terms of inner product. Suppose that the first    n  ×  m      n  normal-×  m    n×m   matrix A is decomposed into its row vectors  , and the second    m  ×  p      m  normal-×  p    m×p   matrix   𝐁   𝐁   \mathbf{B}   into its column vectors  : 10       𝐀  =   (      A  11      A  12     ⋯     A   1  m         A  21      A  22     ⋯     A   2  m        ⋮    ⋮    ⋱    ⋮       A   n  1       A   n  2      ⋯     A   n  m       )   =   (      𝐚  1        𝐚  2       ⋮       𝐚  n      )    ,        𝐀     subscript  A  11    subscript  A  12   normal-⋯   subscript  A    1  m       subscript  A  21    subscript  A  22   normal-⋯   subscript  A    2  m      normal-⋮  normal-⋮  normal-⋱  normal-⋮     subscript  A    n  1     subscript  A    n  2    normal-⋯   subscript  A    n  m              subscript  𝐚  1      subscript  𝐚  2     normal-⋮     subscript  𝐚  n        \mathbf{A}=\begin{pmatrix}A_{11}&A_{12}&\cdots&A_{1m}\\
 A_{21}&A_{22}&\cdots&A_{2m}\\
 \vdots&\vdots&\ddots&\vdots\\
 A_{n1}&A_{n2}&\cdots&A_{nm}\end{pmatrix}=\begin{pmatrix}\mathbf{a}_{1}\\
 \mathbf{a}_{2}\\
 \vdots\\
 \mathbf{a}_{n}\end{pmatrix},         𝐁  =   (      B  11      B  12     ⋯     B   1  p         B  21      B  22     ⋯     B   2  p        ⋮    ⋮    ⋱    ⋮       B   m  1       B   m  2      ⋯     B   m  p       )   =   (      𝐛  1      𝐛  2     ⋯     𝐛  p      )         𝐁     subscript  B  11    subscript  B  12   normal-⋯   subscript  B    1  p       subscript  B  21    subscript  B  22   normal-⋯   subscript  B    2  p      normal-⋮  normal-⋮  normal-⋱  normal-⋮     subscript  B    m  1     subscript  B    m  2    normal-⋯   subscript  B    m  p              subscript  𝐛  1    subscript  𝐛  2   normal-⋯   subscript  𝐛  p        \mathbf{B}=\begin{pmatrix}B_{11}&B_{12}&\cdots&B_{1p}\\
 B_{21}&B_{22}&\cdots&B_{2p}\\
 \vdots&\vdots&\ddots&\vdots\\
 B_{m1}&B_{m2}&\cdots&B_{mp}\end{pmatrix}=\begin{pmatrix}\mathbf{b}_{1}&\mathbf%
 {b}_{2}&\cdots&\mathbf{b}_{p}\end{pmatrix}     where        𝐚  i   =    (      A   i  1       A   i  2      ⋯     A   i  m       )     ,    𝐛  i   =   (      B   1  i         B   2  i        ⋮       B   m  i       )       formulae-sequence     subscript  𝐚  i      subscript  A    i  1     subscript  A    i  2    normal-⋯   subscript  A    i  m          subscript  𝐛  i      subscript  B    1  i       subscript  B    2  i      normal-⋮     subscript  B    m  i         \mathbf{a}_{i}=\begin{pmatrix}A_{i1}&A_{i2}&\cdots&A_{im}\end{pmatrix}\,,\quad%
 \mathbf{b}_{i}=\begin{pmatrix}B_{1i}\\
 B_{2i}\\
 \vdots\\
 B_{mi}\end{pmatrix}     Then:      𝐀𝐁  =    (      𝐚  1        𝐚  2       ⋮       𝐚  n      )    (      𝐛  1      𝐛  2     …     𝐛  p      )    =   (      (    𝐚  1   ⋅   𝐛  1    )      (    𝐚  1   ⋅   𝐛  2    )     …     (    𝐚  1   ⋅   𝐛  p    )        (    𝐚  2   ⋅   𝐛  1    )      (    𝐚  2   ⋅   𝐛  2    )     …     (    𝐚  2   ⋅   𝐛  p    )       ⋮    ⋮    ⋱    ⋮       (    𝐚  n   ⋅   𝐛  1    )      (    𝐚  n   ⋅   𝐛  2    )     …     (    𝐚  n   ⋅   𝐛  p    )      )         𝐀𝐁       subscript  𝐚  1      subscript  𝐚  2     normal-⋮     subscript  𝐚  n        subscript  𝐛  1    subscript  𝐛  2   normal-…   subscript  𝐛  p              normal-⋅   subscript  𝐚  1    subscript  𝐛  1     normal-⋅   subscript  𝐚  1    subscript  𝐛  2    normal-…   normal-⋅   subscript  𝐚  1    subscript  𝐛  p       normal-⋅   subscript  𝐚  2    subscript  𝐛  1     normal-⋅   subscript  𝐚  2    subscript  𝐛  2    normal-…   normal-⋅   subscript  𝐚  2    subscript  𝐛  p      normal-⋮  normal-⋮  normal-⋱  normal-⋮     normal-⋅   subscript  𝐚  n    subscript  𝐛  1     normal-⋅   subscript  𝐚  n    subscript  𝐛  2    normal-…   normal-⋅   subscript  𝐚  n    subscript  𝐛  p         \mathbf{AB}=\begin{pmatrix}\mathbf{a}_{1}\\
 \mathbf{a}_{2}\\
 \vdots\\
 \mathbf{a}_{n}\end{pmatrix}\begin{pmatrix}\mathbf{b}_{1}&\mathbf{b}_{2}&\dots&%
 \mathbf{b}_{p}\end{pmatrix}=\begin{pmatrix}(\mathbf{a}_{1}\cdot\mathbf{b}_{1})%
 &(\mathbf{a}_{1}\cdot\mathbf{b}_{2})&\dots&(\mathbf{a}_{1}\cdot\mathbf{b}_{p})%
 \\
 (\mathbf{a}_{2}\cdot\mathbf{b}_{1})&(\mathbf{a}_{2}\cdot\mathbf{b}_{2})&\dots&%
 (\mathbf{a}_{2}\cdot\mathbf{b}_{p})\\
 \vdots&\vdots&\ddots&\vdots\\
 (\mathbf{a}_{n}\cdot\mathbf{b}_{1})&(\mathbf{a}_{n}\cdot\mathbf{b}_{2})&\dots&%
 (\mathbf{a}_{n}\cdot\mathbf{b}_{p})\end{pmatrix}     It is also possible to express a matrix product in terms of concatenations of products of matrices and row or column vectors:      𝐀𝐁  =   (      𝐀𝐛  1      𝐀𝐛  2     …     𝐀𝐛  p      )   =   (       𝐚  1   𝐁         𝐚  2   𝐁       ⋮        𝐚  n   𝐁      )         𝐀𝐁     subscript  𝐀𝐛  1    subscript  𝐀𝐛  2   normal-…   subscript  𝐀𝐛  p               subscript  𝐚  1   𝐁        subscript  𝐚  2   𝐁     normal-⋮       subscript  𝐚  n   𝐁        \mathbf{AB}=\begin{pmatrix}\mathbf{A}\mathbf{b}_{1}&\mathbf{A}\mathbf{b}_{2}&%
 \dots&\mathbf{A}\mathbf{b}_{p}\end{pmatrix}=\begin{pmatrix}\mathbf{a}_{1}%
 \mathbf{B}\\
 \mathbf{a}_{2}\mathbf{B}\\
 \vdots\\
 \mathbf{a}_{n}\mathbf{B}\end{pmatrix}     These decompositions are particularly useful for matrices that are envisioned as concatenations of particular types of row vectors or column vectors , e.g. orthogonal matrices (whose rows and columns are unit vectors orthogonal to each other) and Markov matrices (whose rows or columns sum to 1).  Outer product  The outer product (also known as the dyadic product or tensor product ) of two vectors in matrix form is equivalent to a row vector multiplied on the left by a column vector:      𝐚  ⊗  𝐛     tensor-product  𝐚  𝐛    \displaystyle\mathbf{a}\otimes\mathbf{b}     An alternative method is to express the matrix product in terms of the outer product. The decomposition is done the other way around, the first matrix   𝐀   𝐀   \mathbf{A}   is decomposed into column vectors and the second matrix   𝐁   𝐁   \mathbf{B}   into row vectors :     𝐀𝐁   𝐀𝐁   \displaystyle\mathbf{AB}     where this time          𝐚  ¯   i   =    (      A   1  i         A   2  i        ⋮       A   n  i       )     ,     𝐛  ¯   i   =    (      B   i  1       B   i  2      ⋯     B   i  p       )      .     formulae-sequence     subscript   normal-¯  𝐚   i      subscript  A    1  i       subscript  A    2  i      normal-⋮     subscript  A    n  i          subscript   normal-¯  𝐛   i      subscript  B    i  1     subscript  B    i  2    normal-⋯   subscript  B    i  p         \mathbf{\bar{a}}_{i}=\begin{pmatrix}A_{1i}\\
 A_{2i}\\
 \vdots\\
 A_{ni}\end{pmatrix}\,,\quad\mathbf{\bar{b}}_{i}=\begin{pmatrix}B_{i1}&B_{i2}&%
 \cdots&B_{ip}\end{pmatrix}\,.     This method emphasizes the effect of individual column/row pairs on the result, which is a useful point of view with e.g. covariance matrices , where each such pair corresponds to the effect of a single sample point.       (       \color   B  r  o  w  n  1       \color   O  r  a  n  g  e  2       \color   V  i  o  l  e  t  3         \color   B  r  o  w  n  4       \color   O  r  a  n  g  e  5       \color   V  i  o  l  e  t  6         \color   B  r  o  w  n  7       \color   O  r  a  n  g  e  8       \color   V  i  o  l  e  t  9      )    (       \color   B  r  o  w  n  a       \color   B  r  o  w  n  d         \color   O  r  a  n  g  e  b       \color   O  r  a  n  g  e  e         \color   V  i  o  l  e  t  c       \color   V  i  o  l  e  t  f      )           \color  B  r  o  w  n  1     \color  O  r  a  n  g  e  2     \color  V  i  o  l  e  t  3       \color  B  r  o  w  n  4     \color  O  r  a  n  g  e  5     \color  V  i  o  l  e  t  6       \color  B  r  o  w  n  7     \color  O  r  a  n  g  e  8     \color  V  i  o  l  e  t  9         \color  B  r  o  w  n  a     \color  B  r  o  w  n  d       \color  O  r  a  n  g  e  b     \color  O  r  a  n  g  e  e       \color  V  i  o  l  e  t  c     \color  V  i  o  l  e  t  f       \displaystyle\begin{pmatrix}{\color{Brown}1}&{\color{Orange}2}&\par
 {\color{%
 Violet}3}\\
 {\color{Brown}4}&{\color{Orange}5}&\par
 {\color{Violet}6}\\
 {\color{Brown}7}&{\color{Orange}8}&\par
 {\color{Violet}9}\\
 \end{pmatrix}\begin{pmatrix}{\color{Brown}a}&{\color{Brown}d}\\
 {\color{Orange}b}&{\color{Orange}e}\\
 {\color{Violet}c}&{\color{Violet}f}\\
 \end{pmatrix}     Algorithms for efficient matrix multiplication  (Figure)  The bound on   ω   ω   ω   over time.   The running time of square matrix multiplication, if carried out naïvely, is . The running time for multiplying rectangular matrices (one    m  ×  p      m  normal-×  p    m×p   -matrix with one    p  ×  n      p  normal-×  n    p×n   -matrix) is    O   (   m  n  p   )       O    m  n  p     O(mnp)   , however, more efficient algorithms exist, such as Strassen's algorithm , devised by Volker Strassen in 1969 and often referred to as "fast matrix multiplication". It is based on a way of multiplying two    2  ×  2      2  normal-×  2    2×2   -matrices which requires only 7 multiplications (instead of the usual 8), at the expense of several additional addition and subtraction operations. Applying this recursively gives an algorithm with a multiplicative cost of     O   (   n    log  2   7    )    ≈   O   (   n  2.807   )          O   superscript  n    subscript   2   7       O   superscript  n  2.807      O(n^{\log_{2}7})\approx O(n^{2.807})   . Strassen's algorithm is more complex, and the numerical stability is reduced compared to the naïve algorithm. 11 Nevertheless, it appears in several libraries, such as BLAS , where it is significantly more efficient for matrices with dimensions n > 100, 12 and is very useful for large matrices over exact domains such as finite fields, where numerical stability is not an issue.  The current algorithm with the lowest known exponent   k   k   k   is a generalization of the Coppersmith–Winograd algorithm that has an asymptotic complexity of , by François Le Gall. 13 This algorithm, and the Coppersmith–Winograd algorithm on which it is based, are similar to Strassen's algorithm: a way is devised for multiplying two    k  ×  k      k  normal-×  k    k×k   -matrices with fewer than multiplications, and this technique is applied recursively. However, the constant coefficient hidden by the Big O notation is so large that these algorithms are only worthwhile for matrices that are too large to handle on present-day computers. 14 15  Since any algorithm for multiplying two    n  ×  n      n  normal-×  n    n×n   -matrices has to process all -entries, there is an asymptotic lower bound of operations. Raz (2002) proves a lower bound of for bounded coefficient arithmetic circuits over the real or complex numbers.  Cohn et al. (2003, 2005) put methods such as the Strassen and Coppersmith–Winograd algorithms in an entirely different group-theoretic context, by utilising triples of subsets of finite groups which satisfy a disjointness property called the triple product property (TPP) . They show that if families of wreath products of Abelian groups with symmetric groups realise families of subset triples with a simultaneous version of the TPP, then there are matrix multiplication algorithms with essentially quadratic complexity. Most researchers believe that this is indeed the case. 16 However, Alon, Shpilka and Chris Umans have recently shown that some of these conjectures implying fast matrix multiplication are incompatible with another plausible conjecture, the sunflower conjecture . 17  Freivalds' algorithm is a simple Monte Carlo algorithm that given matrices    𝐀  ,  𝐁  ,  𝐂     𝐀  𝐁  𝐂    \mathbf{A},\mathbf{B},\mathbf{C}   verifies in time if    𝐀𝐁  =  𝐂      𝐀𝐁  𝐂    \mathbf{AB}=\mathbf{C}   .  (Figure)  Block matrix multiplication. In the 2D algorithm, each processor is responsible for one submatrix of   𝐂   𝐂   \mathbf{C}   . In the 3D algorithm, every pair of submatrices from   𝐀   𝐀   \mathbf{A}   and   𝐁   𝐁   \mathbf{B}   that is multiplied is assigned to one processor.   Parallel matrix multiplication  Because of the nature of matrix operations and the layout of matrices in memory, it is typically possible to gain substantial performance gains through use of parallelization and vectorization . Several algorithms are possible, among which divide and conquer algorithms based on the block matrix decomposition      𝐂  =   (      𝐂  11      𝐂  12        𝐂  21      𝐂  22      )   =    (      𝐀  11      𝐀  12        𝐀  21      𝐀  22      )    (      𝐁  11      𝐁  12        𝐁  21      𝐁  22      )    =  𝐀𝐁        𝐂     subscript  𝐂  11    subscript  𝐂  12      subscript  𝐂  21    subscript  𝐂  22               subscript  𝐀  11    subscript  𝐀  12      subscript  𝐀  21    subscript  𝐀  22        subscript  𝐁  11    subscript  𝐁  12      subscript  𝐁  21    subscript  𝐁  22           𝐀𝐁     \mathbf{C}=\begin{pmatrix}\mathbf{C}_{11}&\mathbf{C}_{12}\\
 \mathbf{C}_{21}&\mathbf{C}_{22}\\
 \end{pmatrix}=\begin{pmatrix}\mathbf{A}_{11}&\mathbf{A}_{12}\\
 \mathbf{A}_{21}&\mathbf{A}_{22}\\
 \end{pmatrix}\begin{pmatrix}\mathbf{B}_{11}&\mathbf{B}_{12}\\
 \mathbf{B}_{21}&\mathbf{B}_{22}\\
 \end{pmatrix}=\mathbf{A}\mathbf{B}     that also underlies Strassen's algorithm. Here,   𝐀   𝐀   \mathbf{A}   ,   𝐁   𝐁   \mathbf{B}   and   𝐂   𝐂   \mathbf{C}   are presumed to be   n   n   n   by   n   n   n   (square) matrices, and etc. are    n  /  2      n  2    n/2   by    n  /  2      n  2    n/2   submatrices. From this decomposition, one derives 18        (      𝐀  11      𝐀  12        𝐀  21      𝐀  22      )    (      𝐁  11      𝐁  12        𝐁  21      𝐁  22      )    =   (        𝐀  11    𝐁  11    +    𝐀  12    𝐁  21          𝐀  11    𝐁  12    +    𝐀  12    𝐁  22            𝐀  21    𝐁  11    +    𝐀  22    𝐁  21          𝐀  21    𝐁  12    +    𝐀  22    𝐁  22        )            subscript  𝐀  11    subscript  𝐀  12      subscript  𝐀  21    subscript  𝐀  22        subscript  𝐁  11    subscript  𝐁  12      subscript  𝐁  21    subscript  𝐁  22             subscript  𝐀  11    subscript  𝐁  11       subscript  𝐀  12    subscript  𝐁  21          subscript  𝐀  11    subscript  𝐁  12       subscript  𝐀  12    subscript  𝐁  22            subscript  𝐀  21    subscript  𝐁  11       subscript  𝐀  22    subscript  𝐁  21          subscript  𝐀  21    subscript  𝐁  12       subscript  𝐀  22    subscript  𝐁  22         \begin{pmatrix}\mathbf{A}_{11}&\mathbf{A}_{12}\\
 \mathbf{A}_{21}&\mathbf{A}_{22}\\
 \end{pmatrix}\begin{pmatrix}\mathbf{B}_{11}&\mathbf{B}_{12}\\
 \mathbf{B}_{21}&\mathbf{B}_{22}\\
 \end{pmatrix}=\begin{pmatrix}\mathbf{A}_{11}\mathbf{B}_{11}+\mathbf{A}_{12}%
 \mathbf{B}_{21}&\mathbf{A}_{11}\mathbf{B}_{12}+\mathbf{A}_{12}\mathbf{B}_{22}%
 \\
 \mathbf{A}_{21}\mathbf{B}_{11}+\mathbf{A}_{22}\mathbf{B}_{21}&\mathbf{A}_{21}%
 \mathbf{B}_{12}+\mathbf{A}_{22}\mathbf{B}_{22}\\
 \end{pmatrix}     which consists of eight multiplications of pairs of submatrices, which can all be performed in parallel, followed by an addition step. Applying this recursively, and performing the additions in parallel as well, one obtains an algorithm that runs in time on an ideal machine with an infinite number of processors, and has a maximum possible speedup of on any real computer (although the algorithm isn't practical, a more practical variant achieves speedup). 19  It should be noted that some lower time-complexity algorithms on paper may have indirect time complexity costs on real machines.  Communication-avoiding and distributed algorithms  On modern architectures with hierarchical memory, the cost of loading and storing input matrix elements tends to dominate the cost of arithmetic. On a single machine this is the amount of data transferred between RAM and cache, while on a distributed memory multi-node machine it is the amount transferred between nodes; in either case it is called the communication bandwidth . The naïve algorithm using three nested loops uses communication bandwidth.  Cannon's algorithm , also known as the 2D algorithm , partitions each input matrix into a block matrix whose elements are submatrices of size     M   /  3        M   3    \sqrt{M}{/3}   by     M   /  3        M   3    \sqrt{M}{/3}   , where   M   M   M   is the size of fast memory. 20 The naïve algorithm is then used over the block matrices, computing products of submatrices entirely in fast memory. This reduces communication bandwidth to , which is asymptotically optimal (for algorithms performing computation). 21 22  In a distributed setting with   p   p   p   processors arranged in a    p      p    \sqrt{p}   by    p      p    \sqrt{p}   2D mesh, one submatrix of the result can be assigned to each processor, and the product can be computed with each processor transmitting words, which is asymptotically optimal assuming that each node stores the minimum elements. 23 This can be improved by the 3D algorithm, which arranges the processors in a 3D cube mesh, assigning every product of two input submatrices to a single processor. The result submatrices are then generated by performing a reduction over each row. 24 This algorithm transmits words per processor, which is asymptotically optimal. 25 However, this requires replicating each input matrix element times, and so requires a factor of more memory than is needed to store the inputs. This algorithm can be combined with Strassen to further reduce runtime. 26 "2.5D" algorithms provide a continuous tradeoff between memory usage and communication bandwidth. 27 On modern distributed computing environments such as MapReduce , specialized multiplication algorithms have been developed. 28  Matrix multiplication can be done cache-obliviously .  Other forms of multiplication  Some other ways to multiply two matrices are given below; some, in fact, are simpler than the definition above. The Cracovian product is yet another form.  Hadamard product  For two matrices of the same dimensions, there is the Hadamard product , also known as the element-wise product , pointwise product , entrywise product and the Schur product . 29 For two matrices   𝐀   𝐀   \mathbf{A}   and   𝐁   𝐁   \mathbf{B}   of the same dimensions, the Hadamard product    𝐀  ○  𝐁      𝐀  normal-○  𝐁    \mathbf{A}○\mathbf{B}   is a matrix of the same dimensions, the    i  ,  j     i  j    i,j   element of   𝐀   𝐀   \mathbf{A}   is multiplied with the    i  ,  j     i  j    i,j   element of   𝐁   𝐁   \mathbf{B}   , that is:         (   𝐀  ∘  𝐁   )    i  j    =    A   i  j      B   i  j       ,       subscript    𝐀  𝐁     i  j       subscript  A    i  j     subscript  B    i  j       \left(\mathbf{A}\circ\mathbf{B}\right)_{ij}=A_{ij}B_{ij}\,,     displayed fully:       𝐀  ∘  𝐁   =    (      A  11      A  12     ⋯     A   1  m         A  21      A  22     ⋯     A   2  m        ⋮    ⋮    ⋱    ⋮       A   n  1       A   n  2      ⋯     A   n  m       )   ∘   (      B  11      B  12     ⋯     B   1  m         B  21      B  22     ⋯     B   2  m        ⋮    ⋮    ⋱    ⋮       B   n  1       B   n  2      ⋯     B   n  m       )    =   (       A  11    B  11        A  12    B  12      ⋯      A   1  m     B   1  m           A  21    B  21        A  22    B  22      ⋯      A   2  m     B   2  m         ⋮    ⋮    ⋱    ⋮        A   n  1     B   n  1         A   n  2     B   n  2       ⋯      A   n  m     B   n  m        )           𝐀  𝐁        subscript  A  11    subscript  A  12   normal-⋯   subscript  A    1  m       subscript  A  21    subscript  A  22   normal-⋯   subscript  A    2  m      normal-⋮  normal-⋮  normal-⋱  normal-⋮     subscript  A    n  1     subscript  A    n  2    normal-⋯   subscript  A    n  m         subscript  B  11    subscript  B  12   normal-⋯   subscript  B    1  m       subscript  B  21    subscript  B  22   normal-⋯   subscript  B    2  m      normal-⋮  normal-⋮  normal-⋱  normal-⋮     subscript  B    n  1     subscript  B    n  2    normal-⋯   subscript  B    n  m                 subscript  A  11    subscript  B  11       subscript  A  12    subscript  B  12    normal-⋯     subscript  A    1  m     subscript  B    1  m          subscript  A  21    subscript  B  21       subscript  A  22    subscript  B  22    normal-⋯     subscript  A    2  m     subscript  B    2  m       normal-⋮  normal-⋮  normal-⋱  normal-⋮       subscript  A    n  1     subscript  B    n  1        subscript  A    n  2     subscript  B    n  2     normal-⋯     subscript  A    n  m     subscript  B    n  m          \mathbf{A}\circ\mathbf{B}=\begin{pmatrix}A_{11}&A_{12}&\cdots&A_{1m}\\
 A_{21}&A_{22}&\cdots&A_{2m}\\
 \vdots&\vdots&\ddots&\vdots\\
 A_{n1}&A_{n2}&\cdots&A_{nm}\\
 \end{pmatrix}\circ\begin{pmatrix}B_{11}&B_{12}&\cdots&B_{1m}\\
 B_{21}&B_{22}&\cdots&B_{2m}\\
 \vdots&\vdots&\ddots&\vdots\\
 B_{n1}&B_{n2}&\cdots&B_{nm}\\
 \end{pmatrix}=\begin{pmatrix}A_{11}B_{11}&A_{12}B_{12}&\cdots&A_{1m}B_{1m}\\
 A_{21}B_{21}&A_{22}B_{22}&\cdots&A_{2m}B_{2m}\\
 \vdots&\vdots&\ddots&\vdots\\
 A_{n1}B_{n1}&A_{n2}B_{n2}&\cdots&A_{nm}B_{nm}\\
 \end{pmatrix}     This operation is identical to multiplying many ordinary numbers (    m  n      m  n    mn   of them) all at once; thus the Hadamard product is commutative , associative and distributive over entrywise addition. It is also a principal submatrix of the Kronecker product . It appears in lossy compression algorithms such as JPEG .  Frobenius product  The Frobenius inner product , sometimes denoted    𝐀  :  𝐁     normal-:  𝐀  𝐁    \mathbf{A}:\mathbf{B}   , is the component-wise inner product of two matrices as though they are vectors. It is also the sum of the entries of the Hadamard product. Explicitly,       𝐀  :   𝐁  =    ∑   i  ,  j      A   i  j     B   i  j      =   vec    (  𝐀  )   𝖳   vec   (  𝐁  )    =   tr   (    𝐀  𝖳   𝐁   )    =   tr   (   𝐀𝐁  𝖳   )      ,     normal-:  𝐀      𝐁    subscript    i  j       subscript  A    i  j     subscript  B    i  j             vec   superscript  𝐀  𝖳   vec  𝐁          tr     superscript  𝐀  𝖳   𝐁           tr   superscript  𝐀𝐁  𝖳        \mathbf{A}:\mathbf{B}=\sum_{i,j}A_{ij}B_{ij}=\mathrm{vec}(\mathbf{A})^{\mathsf%
 {T}}\mathrm{vec}(\mathbf{B})=\mathrm{tr}(\mathbf{A}^{\mathsf{T}}\mathbf{B})=%
 \mathrm{tr}(\mathbf{A}\mathbf{B}^{\mathsf{T}}),     where "tr" denotes the trace of a matrix and vec denotes vectorization . This inner product induces the Frobenius norm .  Kronecker product  For two matrices   𝐀   𝐀   \mathbf{A}   and   𝐁   𝐁   \mathbf{B}   of any different dimensions    m  ×  n      m  normal-×  n    m×n   and    p  ×  q      p  normal-×  q    p×q   respectively (no constraints on the dimensions of each matrix), the Kronecker product is the matrix        𝐀  ⊗  𝐁   =   (       A  11   𝐁       A  12   𝐁     ⋯      A   1  n    𝐁         A  21   𝐁       A  22   𝐁     ⋯      A   2  n    𝐁       ⋮    ⋮    ⋱    ⋮        A   m  1    𝐁       A   m  2    𝐁     ⋯      A   m  n    𝐁      )    .       tensor-product  𝐀  𝐁        subscript  A  11   𝐁      subscript  A  12   𝐁   normal-⋯     subscript  A    1  n    𝐁        subscript  A  21   𝐁      subscript  A  22   𝐁   normal-⋯     subscript  A    2  n    𝐁     normal-⋮  normal-⋮  normal-⋱  normal-⋮       subscript  A    m  1    𝐁      subscript  A    m  2    𝐁   normal-⋯     subscript  A    m  n    𝐁       \mathbf{A}\otimes\mathbf{B}=\begin{pmatrix}A_{11}\mathbf{B}&A_{12}\mathbf{B}&%
 \cdots&A_{1n}\mathbf{B}\\
 A_{21}\mathbf{B}&A_{22}\mathbf{B}&\cdots&A_{2n}\mathbf{B}\\
 \vdots&\vdots&\ddots&\vdots\\
 A_{m1}\mathbf{B}&A_{m2}\mathbf{B}&\cdots&A_{mn}\mathbf{B}\\
 \end{pmatrix}.   with dimensions    m  p  ×  n  q      m  p  normal-×  n  q    mp×nq   . 30 This is the application of the more general tensor product applied to matrices.  See also   Basic Linear Algebra Subprograms  Composition of relations  Logical matrix  Matrix analysis  Matrix inversion   Notes  References   Henry Cohn, Robert Kleinberg , Balázs Szegedy , and Chris Umans. Group-theoretic Algorithms for Matrix Multiplication. . Proceedings of the 46th Annual Symposium on Foundations of Computer Science , 23–25 October 2005, Pittsburgh, PA, IEEE Computer Society, pp. 379–388.  Henry Cohn, Chris Umans. A Group-theoretic Approach to Fast Matrix Multiplication. . Proceedings of the 44th Annual IEEE Symposium on Foundations of Computer Science , 11–14 October 2003, Cambridge, MA, IEEE Computer Society, pp. 438–449.    Knuth, D.E. , The Art of Computer Programming Volume 2: Seminumerical Algorithms . Addison-Wesley Professional; 3 edition (November 14, 1997). ISBN 978-0-201-89684-8. pp. 501.   .  Ran Raz . On the complexity of matrix product. In Proceedings of the thirty-fourth annual ACM symposium on Theory of computing. ACM Press, 2002. .  Robinson, Sara, Toward an Optimal Algorithm for Matrix Multiplication, SIAM News 38(9), November 2005. PDF  Strassen, Volker, Gaussian Elimination is not Optimal , Numer. Math. 13, p. 354-356, 1969.   Vassilevska Williams, Virginia, Multiplying matrices faster than Coppersmith-Winograd , Manuscript, May 2012. PDF   External links   How to Multiply Matrices  Matrix Multiplication Calculator Online  The Simultaneous Triple Product Property and Group-theoretic Results for the Exponent of Matrix Multiplication  WIMS Online Matrix Multiplier   Linear algebra: matrix operations Multiply or add matrices of a type and with coefficients you choose and see how the result was computed.  Matrix Multiplication in Java – Dr. P. Viry   "  Category:Matrix theory  Category:Bilinear operators  Category:Binary operations  Category:Multiplication  Category:Numerical linear algebra     ↩  ↩  ↩  ↩  ↩  ↩  ↩  ↩  Mathematical methods for physics and engineering, K.F. Riley, M.P. Hobson, S.J. Bence, Cambridge University Press, 2010, ISBN 978-0-521-86153-3 ↩   ↩  Press 2007, p. 108. ↩  . The original algorithm was presented by Don Coppersmith and Shmuel Winograd in 1990, has an asymptotic complexity of . It was improved in 2013 to by Virginia Vassilevska Williams, giving a time only slightly worse than Le Gall's improvement: ↩  ↩  ↩  Robinson, 2005. ↩  Alon , Shpilka, Umans, On Sunflowers and Matrix Multiplication ↩  ↩   Lynn Elliot Cannon, [ http://portal.acm.org/citation.cfm?coll=GUIDE&dl; ;=GUIDE&id;=905686 A cellular computer to implement the Kalman Filter Algorithm] , Technical report, Ph.D. Thesis, Montana State University, 14 July 1969. ↩  ↩  ↩   ↩    ↩  ↩  ↩  . ↩     