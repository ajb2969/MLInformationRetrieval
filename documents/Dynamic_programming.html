<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="288">Dynamic programming</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Dynamic programming</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <a href="computer_science" title="wikilink">computer science</a>, <a class="uri" href="economics" title="wikilink">economics</a>, and <a class="uri" href="bioinformatics" title="wikilink">bioinformatics</a>, <strong>dynamic programming</strong> is a method for solving a complex problem by breaking it down into a collection of simpler subproblems. It is applicable to problems exhibiting the properties of <a href="overlapping_subproblem" title="wikilink">overlapping subproblems</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and <a href="optimal_substructure" title="wikilink">optimal substructure</a> (described below). When applicable, the method takes far less time than other methods that don't take advantage of the subproblem overlap (like <a href="depth-first_search" title="wikilink">depth-first search</a>).</p>

<p>In order to solve a given problem, using a dynamic programming approach, we need to solve different parts of the problem (subproblems), then combine the solutions of the subproblems to reach an overall solution. Often when using a more naive method, many of the subproblems are generated and solved many times. The dynamic programming approach seeks to solve each subproblem only once, thus reducing the number of computations: once the solution to a given subproblem has been computed, it is stored or "<a href="memoization" title="wikilink">memoized</a>": the next time the same solution is needed, it is simply looked up. This approach is especially useful when the number of repeating subproblems <a href="exponential_growth" title="wikilink">grows exponentially</a> as a function of the size of the input.</p>

<p>Dynamic programming algorithms are used for optimization (for example, finding the shortest path between two points, or the fastest way to multiply many matrices). A dynamic programming algorithm will examine the previously solved subproblems and will combine their solutions to give the best solution for the given problem. The alternatives are many, such as using a <a href="greedy_algorithm" title="wikilink">greedy algorithm</a>, which picks the locally optimal choice at each branch in the road. The locally optimal choice may be a poor choice for the overall solution. While a greedy algorithm does not guarantee an optimal solution, it is often faster to calculate. Fortunately, some greedy algorithms (such as <a href="minimum_spanning_tree" title="wikilink">minimum spanning trees</a>) are proven to lead to the optimal solution.</p>

<p>For example, let's say that you have to get from point A to point B as fast as possible, in a given city, during rush hour. A dynamic programming algorithm will look at finding the shortest paths to points close to A, and use those solutions to eventually find the shortest path to B. On the other hand, a greedy algorithm will start you driving immediately and will pick the road that looks the fastest at every intersection. As you can imagine, this strategy might not lead to the fastest arrival time, since you might take some "easy" streets and then find yourself hopelessly stuck in a traffic jam.</p>

<p>Sometimes, applying memoization to a naive basic recursive solution already results in a dynamic programming solution with asymptotically optimal time complexity; however, the optimal solution to some problems requires more sophisticated dynamic programming algorithms. Some of these may be recursive as well but parametrized differently from the naive solution. Others can be more complicated and cannot be implemented as a recursive function with memoization. Examples of these are the two solutions to the Egg Dropping puzzle below.</p>
<h2 id="overview">Overview</h2>

<p> Dynamic programming is both a mathematical optimization method and a computer programming method. In both contexts it refers to simplifying a complicated problem by breaking it down into simpler subproblems in a <a href="Recursion" title="wikilink">recursive</a> manner. While some decision problems cannot be taken apart this way, decisions that span several points in time do often break apart recursively; Bellman called this the "<a href="Bellman_equation#Bellman's_Principle_of_Optimality" title="wikilink">Principle of Optimality</a>". Likewise, in computer science, a problem that can be solved optimally by breaking it into subproblems and then recursively finding the optimal solutions to the subproblems is said to have <a href="optimal_substructure" title="wikilink">optimal substructure</a>.</p>

<p>If subproblems can be nested recursively inside larger problems, so that dynamic programming methods are applicable, then there is a relation between the value of the larger problem and the values of the subproblems.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> In the optimization literature this relationship is called the <a href="Bellman_equation" title="wikilink">Bellman equation</a>.</p>
<h3 id="dynamic-programming-in-mathematical-optimization">Dynamic programming in mathematical optimization</h3>

<p>In terms of <a href="mathematical_optimization" title="wikilink">mathematical optimization</a>, dynamic programming usually refers to simplifying a decision by breaking it down into a sequence of decision steps over time. This is done by defining a sequence of <strong>value functions</strong> <em>V</em><sub>1</sub>, <em>V</em><sub>2</sub>, ..., <em>V</em><sub><em>n</em></sub>, with an argument <em>y</em> representing the <strong><a href="State_variable" title="wikilink">state</a></strong> of the system at times <em>i</em> from 1 to <em>n</em>. The definition of <em>V</em><sub><em>n</em></sub>(<em>y</em>) is the value obtained in state <em>y</em> at the last time <em>n</em>. The values <em>V</em><sub><em>i</em></sub> at earlier times <em>i</em> = <em>n</em> −1, <em>n</em> − 2, ..., 2, 1 can be found by working backwards, using a <a href="Recursion" title="wikilink">recursive</a> relationship called the <a href="Bellman_equation" title="wikilink">Bellman equation</a>. For <em>i</em> = 2, ..., <em>n</em>, <em>V</em><sub><em>i</em>−1</sub> at any state <em>y</em> is calculated from <em>V</em><sub><em>i</em></sub> by maximizing a simple function (usually the sum) of the gain from a decision at time <em>i</em> − 1 and the function <em>V</em><sub><em>i</em></sub> at the new state of the system if this decision is made. Since <em>V</em><sub><em>i</em></sub> has already been calculated for the needed states, the above operation yields <em>V</em><sub><em>i</em>−1</sub> for those states. Finally, <em>V</em><sub>1</sub> at the initial state of the system is the value of the optimal solution. The optimal values of the decision variables can be recovered, one by one, by tracking back the calculations already performed.</p>
<h3 id="dynamic-programming-in-bioinformatics">Dynamic programming in bioinformatics</h3>

<p>Dynamic programming is widely used in bioinformatics for the tasks such as <a href="sequence_alignment" title="wikilink">sequence alignment</a>, protein folding, RNA structure prediction and protein-DNA binding. First dynamic programming algorithms for protein-DNA binding were developed in the 1970s independently by <a href="Charles_DeLisi" title="wikilink">Charles DeLisi</a> in USA<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and <a href="Georgii_Gurskii" title="wikilink">Georgii Gurskii</a> and <a href="Alexander_Zasedatelev" title="wikilink">Alexander Zasedatelev</a> in USSR.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Recently these algorithms have become very popular in bioinformatics and computational biology, particularly in the studies of <a class="uri" href="nucleosome" title="wikilink">nucleosome</a> positioning and <a href="transcription_factor" title="wikilink">transcription factor</a> binding.</p>
<h3 id="dynamic-programming-in-computer-programming">Dynamic programming in computer programming</h3>

<p>There are two key attributes that a problem must have in order for dynamic programming to be applicable: <a href="optimal_substructure" title="wikilink">optimal substructure</a> and <a href="overlapping_subproblem" title="wikilink">overlapping subproblems</a>. If a problem can be solved by combining optimal solutions to <em>non-overlapping</em> subproblems, the strategy is called "<a href="Divide_and_conquer_algorithm" title="wikilink">divide and conquer</a>" instead. This is why <a class="uri" href="mergesort" title="wikilink">mergesort</a> and <a class="uri" href="quicksort" title="wikilink">quicksort</a> are not classified as dynamic programming problems.</p>

<p><em>Optimal substructure</em> means that the solution to a given optimization problem can be obtained by the combination of optimal solutions to its subproblems. Consequently, the first step towards devising a dynamic programming solution is to check whether the problem exhibits such optimal substructure. Such optimal substructures are usually described by means of <a class="uri" href="recursion" title="wikilink">recursion</a>. For example, given a graph <em>G=(V,E)</em>, the shortest path <em>p</em> from a vertex <em>u</em> to a vertex <em>v</em> exhibits optimal substructure: take any intermediate vertex <em>w</em> on this shortest path <em>p</em>. If <em>p</em> is truly the shortest path, then it can be split into subpaths <em>p<sub>1</sub></em> from <em>u</em> to <em>w</em> and <em>p<sub>2</sub></em> from <em>w</em> to <em>v</em> such that these, in turn, are indeed the shortest paths between the corresponding vertices (by the simple cut-and-paste argument described in <em><a href="Introduction_to_Algorithms" title="wikilink">Introduction to Algorithms</a></em>). Hence, one can easily formulate the solution for finding shortest paths in a recursive manner, which is what the <a href="Bellman–Ford_algorithm" title="wikilink">Bellman–Ford algorithm</a> or the <a href="Floyd–Warshall_algorithm" title="wikilink">Floyd–Warshall algorithm</a> does.</p>

<p><em>Overlapping</em> subproblems means that the space of subproblems must be small, that is, any recursive algorithm solving the problem should solve the same subproblems over and over, rather than generating new subproblems. For example, consider the recursive formulation for generating the Fibonacci series: <em>F</em><sub><em>i</em></sub> = <em>F</em><sub><em>i</em>−1</sub> + <em>F</em><sub><em>i</em>−2</sub>, with base case <em>F</em><sub>1</sub> = <em>F</em><sub>2</sub> = 1. Then <em>F</em><sub>43</sub> = <em>F</em><sub>42</sub> + <em>F</em><sub>41</sub>, and <em>F</em><sub>42</sub> = <em>F</em><sub>41</sub> + <em>F</em><sub>40</sub>. Now <em>F</em><sub>41</sub> is being solved in the recursive subtrees of both <em>F</em><sub>43</sub> as well as <em>F</em><sub>42</sub>. Even though the total number of subproblems is actually small (only 43 of them), we end up solving the same problems over and over if we adopt a naive recursive solution such as this. Dynamic programming takes account of this fact and solves each subproblem only once.</p>
<figure><b>(Figure)</b>
<figcaption><strong>Figure 2.</strong> The subproblem graph for the Fibonacci sequence. The fact that it is not a <a href="tree_structure" title="wikilink">tree</a> indicates overlapping subproblems.</figcaption>
</figure>

<p>This can be achieved in either of two ways:</p>
<ul>
<li><em><a href="top-down" title="wikilink">Top-down approach</a></em>: This is the direct fall-out of the recursive formulation of any problem. If the solution to any problem can be formulated recursively using the solution to its subproblems, and if its subproblems are overlapping, then one can easily <a href="memoization" title="wikilink">memoize</a> or store the solutions to the subproblems in a table. Whenever we attempt to solve a new subproblem, we first check the table to see if it is already solved. If a solution has been recorded, we can use it directly, otherwise we solve the subproblem and add its solution to the table.</li>
</ul>
<ul>
<li><em><a href="Top-down_and_bottom-up_design" title="wikilink">Bottom-up approach</a></em>: Once we formulate the solution to a problem recursively as in terms of its subproblems, we can try reformulating the problem in a bottom-up fashion: try solving the subproblems first and use their solutions to build-on and arrive at solutions to bigger subproblems. This is also usually done in a tabular form by iteratively generating solutions to bigger and bigger subproblems by using the solutions to small subproblems. For example, if we already know the values of <em>F</em><sub>41</sub> and <em>F</em><sub>40</sub>, we can directly calculate the value of <em>F</em><sub>42</sub>.</li>
</ul>

<p>Some <a href="programming_language" title="wikilink">programming languages</a> can automatically <a href="memoization" title="wikilink">memoize</a> the result of a function call with a particular set of arguments, in order to speed up <a class="uri" href="call-by-name" title="wikilink">call-by-name</a> evaluation (this mechanism is referred to as <em><a class="uri" href="call-by-need" title="wikilink">call-by-need</a></em>). Some languages make it possible portably (e.g. <a href="Scheme_(programming_language)" title="wikilink">Scheme</a>, <a href="Common_Lisp" title="wikilink">Common Lisp</a> or <a class="uri" href="Perl" title="wikilink">Perl</a>). Some languages have automatic <a class="uri" href="memoization" title="wikilink">memoization</a> built in, such as tabled <a class="uri" href="Prolog" title="wikilink">Prolog</a> and <a href="J_(programming_language)" title="wikilink">J</a>, which supports memoization with the <em>M.</em> adverb.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> In any case, this is only possible for a <a href="referential_transparency_(computer_science)" title="wikilink">referentially transparent</a> function.</p>
<h2 id="example-economic-optimization">Example: Economic optimization</h2>
<h3 id="optimal-consumption-and-saving">Optimal consumption and saving</h3>

<p>A mathematical optimization problem that is often used in teaching dynamic programming to economists (because it can be solved by hand<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a>) concerns a consumer who lives over the periods 

<math display="inline" id="Dynamic_programming:0">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>T</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <ci>T</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=0,1,2,\ldots,T
  </annotation>
 </semantics>
</math>

 and must decide how much to consume and how much to save in each period.</p>

<p>Let 

<math display="inline" id="Dynamic_programming:1">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{t}
  </annotation>
 </semantics>
</math>

 be consumption in period 

<math display="inline" id="Dynamic_programming:2">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, and assume consumption yields <a class="uri" href="utility" title="wikilink">utility</a> 

<math display="inline" id="Dynamic_programming:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>c</mi>
      <mi>t</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>ln</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>c</mi>
      <mi>t</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>u</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <ln></ln>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(c_{t})=\ln(c_{t})
  </annotation>
 </semantics>
</math>

 as long as the consumer lives. Assume the consumer is impatient, so that he <a href="discounting" title="wikilink">discounts</a> future utility by a factor 

<math display="inline" id="Dynamic_programming:4">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 each period, where 

<math display="inline" id="Dynamic_programming:5">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 be <a href="capital_(economics)" title="wikilink">capital</a> in period 

<math display="inline" id="Dynamic_programming:6">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mn>0</mn>
   </msub>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{0}>0
  </annotation>
 </semantics>
</math>

. Assume initial capital is a given amount 

<math display="inline" id="Dynamic_programming:7">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mrow>
     <mi>t</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>A</mi>
     <msubsup>
      <mi>k</mi>
      <mi>t</mi>
      <mi>a</mi>
     </msubsup>
    </mrow>
    <mo>-</mo>
    <msub>
     <mi>c</mi>
     <mi>t</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>k</ci>
        <ci>a</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{t+1}=Ak^{a}_{t}-c_{t}
  </annotation>
 </semantics>
</math>

, and suppose that this period's capital and consumption determine next period's capital as 

<math display="inline" id="Dynamic_programming:8">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Dynamic_programming:9">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mrow>
     <mi>t</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>A</mi>
     <msubsup>
      <mi>k</mi>
      <mi>t</mi>
      <mi>a</mi>
     </msubsup>
    </mrow>
    <mo>-</mo>
    <msub>
     <mi>c</mi>
     <mi>t</mi>
    </msub>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>A</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>k</ci>
         <ci>a</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{t+1}=Ak^{a}_{t}-c_{t}\geq 0
  </annotation>
 </semantics>
</math>

 is a positive constant and 

<math display="inline" id="Dynamic_programming:10">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>T</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <ci>T</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=0,1,2,\ldots,T
  </annotation>
 </semantics>
</math>

 subject to 

<math display="inline" id="Dynamic_programming:11">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>c</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>c</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>c</mi>
    <mi>T</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>T</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{0},c_{1},c_{2},\ldots,c_{T}
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Dynamic_programming:12">
 <semantics>
  <msub>
   <mi>k</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{0}
  </annotation>
 </semantics>
</math>

</p>

<p>Written this way, the problem looks complicated, because it involves solving for all the choice variables 

<math display="inline" id="Dynamic_programming:13">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mi>t</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <ci>t</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{t}(k)
  </annotation>
 </semantics>
</math>

. (Note that 

<math display="inline" id="Dynamic_programming:14">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>T</mi>
    <mo>,</mo>
    <mrow>
     <mi>T</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <ci>T</ci>
     <apply>
      <plus></plus>
      <ci>T</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=0,1,2,\ldots,T,T+1
  </annotation>
 </semantics>
</math>

 is not a choice variable—the consumer's initial capital is taken as given.)</p>

<p>The dynamic programming approach to solving this problem involves breaking it apart into a sequence of smaller decisions. To do so, we define a sequence of <em>value functions</em> 

<math display="inline" id="Dynamic_programming:15">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, for 

<math display="inline" id="Dynamic_programming:16">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 which represent the value of having any amount of capital 

<math display="inline" id="Dynamic_programming:17">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>V</mi>
     <mrow>
      <mi>T</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <apply>
       <plus></plus>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>k</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{T+1}(k)=0
  </annotation>
 </semantics>
</math>

 at each time 

<math display="inline" id="Dynamic_programming:18">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>T</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <ci>T</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=0,1,2,\ldots,T
  </annotation>
 </semantics>
</math>

. Note that 

<math display="block" id="Dynamic_programming:19">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>V</mi>
     <mi>t</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>k</mi>
      <mi>t</mi>
     </msub>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="4.2pt">=</mo>
   <mrow>
    <mrow>
     <mi>max</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mi>ln</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>c</mi>
          <mi>t</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>b</mi>
        <msub>
         <mi>V</mi>
         <mrow>
          <mi>t</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>k</mi>
          <mrow>
           <mi>t</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mtext>subject to</mtext>
    <msub>
     <mi>k</mi>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>A</mi>
     <msubsup>
      <mi>k</mi>
      <mi>t</mi>
      <mi>a</mi>
     </msubsup>
    </mrow>
    <mo>-</mo>
    <msub>
     <mi>c</mi>
     <mi>t</mi>
    </msub>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <max></max>
       <apply>
        <plus></plus>
        <apply>
         <ln></ln>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>c</ci>
          <ci>t</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>b</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>V</ci>
          <apply>
           <plus></plus>
           <ci>t</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>k</ci>
          <apply>
           <plus></plus>
           <ci>t</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <mtext>subject to</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>A</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>k</ci>
         <ci>a</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{t}(k_{t})\,=\,\max\left(\ln(c_{t})+bV_{t+1}(k_{t+1})\right)\text{ subject %
to }k_{t+1}=Ak^{a}_{t}-c_{t}\geq 0
  </annotation>
 </semantics>
</math>

, that is, there is (by assumption) no utility from having capital after death.</p>

<p>The value of any quantity of capital at any previous time can be calculated by <a href="backward_induction" title="wikilink">backward induction</a> using the <a href="Bellman_equation" title="wikilink">Bellman equation</a>. In this problem, for each 

<math display="inline" id="Dynamic_programming:20">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{t}
  </annotation>
 </semantics>
</math>

, the Bellman equation is</p>

<p>

<math display="inline" id="Dynamic_programming:21">
 <semantics>
  <msub>
   <mi>k</mi>
   <mrow>
    <mi>t</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <apply>
     <plus></plus>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{t+1}
  </annotation>
 </semantics>
</math>

</p>

<p>This problem is much simpler than the one we wrote down before, because it involves only two decision variables, 

<math display="inline" id="Dynamic_programming:22">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dynamic_programming:23">
 <semantics>
  <msub>
   <mi>k</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{t}
  </annotation>
 </semantics>
</math>

. Intuitively, instead of choosing his whole lifetime plan at birth, the consumer can take things one step at a time. At time 

<math display="inline" id="Dynamic_programming:24">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{t}
  </annotation>
 </semantics>
</math>

, his current capital 

<math display="inline" id="Dynamic_programming:25">
 <semantics>
  <msub>
   <mi>k</mi>
   <mrow>
    <mi>t</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <apply>
     <plus></plus>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{t+1}
  </annotation>
 </semantics>
</math>

 is given, and he only needs to choose current consumption 

<math display="inline" id="Dynamic_programming:26">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 and saving 

<math display="inline" id="Dynamic_programming:27">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mrow>
     <mi>T</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <apply>
      <plus></plus>
      <ci>T</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{T+1}(k)
  </annotation>
 </semantics>
</math>

.</p>

<p>To actually solve this problem, we work backwards. For simplicity, the current level of capital is denoted as 

<math display="inline" id="Dynamic_programming:28">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mi>T</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <ci>T</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{T}(k)
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Dynamic_programming:29">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mn>0</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{0}(k)
  </annotation>
 </semantics>
</math>

 is already known, so using the Bellman equation once we can calculate 

<math display="inline" id="Dynamic_programming:30">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mrow>
     <mrow>
      <mi>T</mi>
      <mo>-</mo>
      <mi>j</mi>
     </mrow>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <ci>T</ci>
       <ci>j</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{T-j+1}(k)
  </annotation>
 </semantics>
</math>

, and so on until we get to 

<math display="inline" id="Dynamic_programming:31">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mrow>
     <mi>T</mi>
     <mo>-</mo>
     <mi>j</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <apply>
      <minus></minus>
      <ci>T</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{T-j}(k)
  </annotation>
 </semantics>
</math>

, which is the <em>value</em> of the initial decision problem for the whole lifetime. In other words, once we know 

<math display="inline" id="Dynamic_programming:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>ln</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>c</mi>
      <mrow>
       <mi>T</mi>
       <mo>-</mo>
       <mi>j</mi>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>b</mi>
    <msub>
     <mi>V</mi>
     <mrow>
      <mrow>
       <mi>T</mi>
       <mo>-</mo>
       <mi>j</mi>
      </mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>A</mi>
       <msup>
        <mi>k</mi>
        <mi>a</mi>
       </msup>
      </mrow>
      <mo>-</mo>
      <msub>
       <mi>c</mi>
       <mrow>
        <mi>T</mi>
        <mo>-</mo>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <ln></ln>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <apply>
       <minus></minus>
       <ci>T</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>b</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <ci>T</ci>
        <ci>j</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>A</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>k</ci>
        <ci>a</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <apply>
        <minus></minus>
        <ci>T</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ln(c_{T-j})+bV_{T-j+1}(Ak^{a}-c_{T-j})
  </annotation>
 </semantics>
</math>

, we can calculate 

<math display="inline" id="Dynamic_programming:33">
 <semantics>
  <msub>
   <mi>c</mi>
   <mrow>
    <mi>T</mi>
    <mo>-</mo>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <apply>
     <minus></minus>
     <ci>T</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{T-j}
  </annotation>
 </semantics>
</math>

, which is the maximum of 

<math display="inline" id="Dynamic_programming:34">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>A</mi>
     <msup>
      <mi>k</mi>
      <mi>a</mi>
     </msup>
    </mrow>
    <mo>-</mo>
    <msub>
     <mi>c</mi>
     <mrow>
      <mi>T</mi>
      <mo>-</mo>
      <mi>j</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>k</ci>
       <ci>a</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <apply>
       <minus></minus>
       <ci>T</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ak^{a}-c_{T-j}\geq 0
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Dynamic_programming:35">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mi>T</mi>
    <mo>-</mo>
    <mi>j</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <minus></minus>
     <ci>T</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=T-j
  </annotation>
 </semantics>
</math>

 is the choice variable and 

<math display="block" id="Dynamic_programming:36">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>V</mi>
     <mrow>
      <mi>T</mi>
      <mo>-</mo>
      <mi>j</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="4.2pt">=</mo>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mi>j</mi>
      </munderover>
      <mrow>
       <msup>
        <mi>a</mi>
        <mi>i</mi>
       </msup>
       <msup>
        <mi>b</mi>
        <mi>i</mi>
       </msup>
       <mrow>
        <mi>ln</mi>
        <mi>k</mi>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>v</mi>
     <mrow>
      <mi>T</mi>
      <mo>-</mo>
      <mi>j</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <apply>
       <minus></minus>
       <ci>T</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>a</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <ci>j</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>a</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>b</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <ln></ln>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <apply>
       <minus></minus>
       <ci>T</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{T-j}(k)\,=\,a\sum_{i=0}^{j}a^{i}b^{i}\ln k+v_{T-j}
  </annotation>
 </semantics>
</math>

.</p>

<p>Working backwards, it can be shown that the value function at time 

<math display="inline" id="Dynamic_programming:37">
 <semantics>
  <msub>
   <mi>v</mi>
   <mrow>
    <mi>T</mi>
    <mo>-</mo>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <apply>
     <minus></minus>
     <ci>T</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{T-j}
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="inline" id="Dynamic_programming:38">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mi>T</mi>
    <mo>-</mo>
    <mi>j</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <minus></minus>
     <ci>T</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=T-j
  </annotation>
 </semantics>
</math>

</p>

<p>where each 

<math display="block" id="Dynamic_programming:39">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mrow>
      <mi>T</mi>
      <mo>-</mo>
      <mi>j</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="4.2pt">=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mi>j</mi>
      </msubsup>
      <mrow>
       <msup>
        <mi>a</mi>
        <mi>i</mi>
       </msup>
       <msup>
        <mi>b</mi>
        <mi>i</mi>
       </msup>
      </mrow>
     </mrow>
    </mfrac>
    <mi>A</mi>
    <msup>
     <mi>k</mi>
     <mi>a</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <apply>
       <minus></minus>
       <ci>T</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <ci>j</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>a</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>b</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>k</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{T-j}(k)\,=\,\frac{1}{\sum_{i=0}^{j}a^{i}b^{i}}Ak^{a}
  </annotation>
 </semantics>
</math>

 is a constant, and the optimal amount to consume at time 

<math display="block" id="Dynamic_programming:40">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mi>T</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="4.2pt">=</mo>
   <mrow>
    <mi>A</mi>
    <msup>
     <mi>k</mi>
     <mi>a</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>T</ci>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>k</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{T}(k)\,=\,Ak^{a}
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="block" id="Dynamic_programming:41">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mrow>
      <mi>T</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="4.2pt">=</mo>
   <mfrac>
    <mrow>
     <mi>A</mi>
     <msup>
      <mi>k</mi>
      <mi>a</mi>
     </msup>
    </mrow>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <apply>
       <minus></minus>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>k</ci>
       <ci>a</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{T-1}(k)\,=\,\frac{Ak^{a}}{1+ab}
  </annotation>
 </semantics>
</math>

</p>

<p>which can be simplified to</p>

<p>

<math display="block" id="Dynamic_programming:42">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mrow>
      <mi>T</mi>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="4.2pt">=</mo>
   <mfrac>
    <mrow>
     <mi>A</mi>
     <msup>
      <mi>k</mi>
      <mi>a</mi>
     </msup>
    </mrow>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msup>
       <mi>a</mi>
       <mn>2</mn>
      </msup>
      <msup>
       <mi>b</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <apply>
       <minus></minus>
       <ci>T</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>k</ci>
       <ci>a</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{T-2}(k)\,=\,\frac{Ak^{a}}{1+ab+a^{2}b^{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Dynamic_programming:43">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="4.2pt">=</mo>
   <mfrac>
    <mrow>
     <mi>A</mi>
     <msup>
      <mi>k</mi>
      <mi>a</mi>
     </msup>
    </mrow>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msup>
       <mi>a</mi>
       <mn>2</mn>
      </msup>
      <msup>
       <mi>b</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">…</mi>
     <mo>+</mo>
     <mrow>
      <msup>
       <mi>a</mi>
       <mrow>
        <mi>T</mi>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
      </msup>
      <msup>
       <mi>b</mi>
       <mrow>
        <mi>T</mi>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>k</ci>
       <ci>a</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <ci>T</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <apply>
         <minus></minus>
         <ci>T</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{2}(k)\,=\,\frac{Ak^{a}}{1+ab+a^{2}b^{2}+\ldots+a^{T-2}b^{T-2}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Dynamic_programming:44">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="4.2pt">=</mo>
   <mfrac>
    <mrow>
     <mi>A</mi>
     <msup>
      <mi>k</mi>
      <mi>a</mi>
     </msup>
    </mrow>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msup>
       <mi>a</mi>
       <mn>2</mn>
      </msup>
      <msup>
       <mi>b</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">…</mi>
     <mo>+</mo>
     <mrow>
      <msup>
       <mi>a</mi>
       <mrow>
        <mi>T</mi>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
      </msup>
      <msup>
       <mi>b</mi>
       <mrow>
        <mi>T</mi>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msup>
       <mi>a</mi>
       <mrow>
        <mi>T</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <msup>
       <mi>b</mi>
       <mrow>
        <mi>T</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>k</ci>
       <ci>a</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <ci>T</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <apply>
         <minus></minus>
         <ci>T</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <ci>T</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <apply>
         <minus></minus>
         <ci>T</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{1}(k)\,=\,\frac{Ak^{a}}{1+ab+a^{2}b^{2}+\ldots+a^{T-2}b^{T-2}+a^{T-1}b^{T-1}}
  </annotation>
 </semantics>
</math>

 ...</p>

<p>

<math display="block" id="Dynamic_programming:45">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mn>0</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="4.2pt">=</mo>
   <mfrac>
    <mrow>
     <mi>A</mi>
     <msup>
      <mi>k</mi>
      <mi>a</mi>
     </msup>
    </mrow>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msup>
       <mi>a</mi>
       <mn>2</mn>
      </msup>
      <msup>
       <mi>b</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">…</mi>
     <mo>+</mo>
     <mrow>
      <msup>
       <mi>a</mi>
       <mrow>
        <mi>T</mi>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
      </msup>
      <msup>
       <mi>b</mi>
       <mrow>
        <mi>T</mi>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msup>
       <mi>a</mi>
       <mrow>
        <mi>T</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <msup>
       <mi>b</mi>
       <mrow>
        <mi>T</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msup>
       <mi>a</mi>
       <mi>T</mi>
      </msup>
      <msup>
       <mi>b</mi>
       <mi>T</mi>
      </msup>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>k</ci>
       <ci>a</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <ci>T</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <apply>
         <minus></minus>
         <ci>T</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <ci>T</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <apply>
         <minus></minus>
         <ci>T</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <ci>T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <ci>T</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{0}(k)\,=\,\frac{Ak^{a}}{1+ab+a^{2}b^{2}+\ldots+a^{T-2}b^{T-2}+a^{T-1}b^{T-1%
}+a^{T}b^{T}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Dynamic_programming:46">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Dynamic_programming:47">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(n^{2})
  </annotation>
 </semantics>
</math>

</p>

<p>We see that it is optimal to consume a larger fraction of current wealth as one gets older, finally consuming all remaining wealth in period 

<math display="inline" id="Dynamic_programming:48">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(n)
  </annotation>
 </semantics>
</math>

, the last period of life.</p>
<h2 id="examples-computer-algorithms">Examples: Computer algorithms</h2>
<h3 id="dijkstras-algorithm-for-the-shortest-path-problem">Dijkstra's algorithm for the shortest path problem</h3>

<p>From a dynamic programming point of view, <a href="Dijkstra's_algorithm" title="wikilink">Dijkstra's algorithm</a> for the <a href="shortest_path_problem" title="wikilink">shortest path problem</a> is a successive approximation scheme that solves the dynamic programming functional equation for the shortest path problem by the <strong>Reaching</strong> method.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>In fact, Dijkstra's explanation of the logic behind the algorithm,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> namely </p>

<p>is a paraphrasing of <a href="Richard_Bellman" title="wikilink">Bellman's</a> famous <a href="Principle_of_Optimality" title="wikilink">Principle of Optimality</a> in the context of the <a href="shortest_path_problem" title="wikilink">shortest path problem</a>.</p>
<h3 id="fibonacci-sequence">Fibonacci sequence</h3>

<p>Here is a naïve implementation of a function finding the <em>n</em>th member of the <a href="Fibonacci_sequence" title="wikilink">Fibonacci sequence</a>, based directly on the mathematical definition:</p>

<p><code>   </code><strong><code>function</code></strong><code> fib(n)</code><br/>
<code>       </code><strong><code>if</code></strong><code> n </code><code>fib(5)</code><code>, we produce a call tree that calls the function on the same value many different times:</code></p>
<ol>
<li><code>fib(5)</code></li>
<li><code>fib(4) + fib(3)</code></li>
<li><code>(fib(3) + fib(2)) + (fib(2) + fib(1))</code></li>
<li><code>((fib(2) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))</code></li>
<li><code>(((fib(1) + fib(0)) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))</code></li>
</ol>

<p>In particular, <code>fib(2)</code> was calculated three times from scratch. In larger examples, many more values of <code>fib</code>, or <em>subproblems</em>, are recalculated, leading to an exponential time algorithm.</p>

<p>Now, suppose we have a simple <a href="Associative_array" title="wikilink">map</a> object, <em>m</em>, which maps each value of <code>fib</code> that has already been calculated to its result, and we modify our function to use it and update it. The resulting function requires only <a href="Big-O_notation" title="wikilink">O</a>(<em>n</em>) time instead of exponential time (but requires <a href="Big-O_notation" title="wikilink">O</a>(<em>n</em>) space):</p>

<p><code>   </code><strong><code>var</code></strong><code> m := </code><strong><em><code>map</code></em></strong><code>(0 → 0, 1 → 1)</code><br/>
<code>   </code><strong><code>function</code></strong><code> fib(n)</code><br/>
<code>       </code><strong><code>if</code> <em><code>key</code></em></strong><code> n </code><strong><code>is</code> <code>not</code> <code>in</code> <em><code>map</code></em></strong><code> m </code><br/>
<code>           m[n] := fib(n − 1) + fib(n − 2)</code><br/>
<code>       </code><strong><code>return</code></strong><code> m[n]</code></p>

<p>This technique of saving values that have already been calculated is called <em><a class="uri" href="memoization" title="wikilink">memoization</a></em>; this is the top-down approach, since we first break the problem into subproblems and then calculate and store values.</p>

<p>In the <strong>bottom-up</strong> approach, we calculate the smaller values of <code>fib</code> first, then build larger values from them. This method also uses O(<em>n</em>) time since it contains a loop that repeats n − 1 times, but it only takes constant (O(1)) space, in contrast to the top-down approach which requires O(<em>n</em>) space to store the map.</p>

<p><code>   </code><strong><code>function</code></strong><code> fib(n)</code><br/>
<code>       </code><strong><code>if</code></strong><code> n = 0</code><br/>
<code>           </code><strong><code>return</code></strong><code> 0</code><br/>
<code>       </code><strong><code>else</code></strong><br/>
<code>           </code><strong><code>var</code></strong><code> previousFib := 0, currentFib := 1</code><br/>
<code>           </code><strong><code>repeat</code></strong><code> n − 1 </code><strong><code>times</code></strong><code> </code><em><code>//</code> <code>loop</code> <code>is</code> <code>skipped</code> <code>if</code> <code>n</code> <code>=</code> <code>1</code></em><br/>
<code>               </code><strong><code>var</code></strong><code> newFib := previousFib + currentFib</code><br/>
<code>               previousFib := currentFib</code><br/>
<code>               currentFib  := newFib</code><br/>
<code>       </code><strong><code>return</code></strong><code> currentFib</code></p>

<p>In both examples, we only calculate <code>fib(2)</code> one time, and then use it to calculate both <code>fib(4)</code> and <code>fib(3)</code>, instead of computing it every time either of them is evaluated.</p>

<p>Note that the above method actually takes 

<math display="inline" id="Dynamic_programming:49">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(n)
  </annotation>
 </semantics>
</math>

 time for large n because addition of two integers with 

<math display="inline" id="Dynamic_programming:50">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(n)
  </annotation>
 </semantics>
</math>

 bits each takes 

<math display="inline" id="Dynamic_programming:51">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 time. (The <em>n</em><sup>th</sup> fibonacci number has 

<math display="inline" id="Dynamic_programming:52">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>log</mi>
        <mi>n</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n(\log n)^{2})
  </annotation>
 </semantics>
</math>

 bits.) Also, there is a closed form for the Fibonacci sequence, <a href="Jacques_Philippe_Marie_Binet#Binet's_Fibonacci_number_formula" title="wikilink">known as Binet's formula</a>, from which the 

<math display="inline" id="Dynamic_programming:53">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n\log n)
  </annotation>
 </semantics>
</math>

-th term can be <a href="Computational_complexity_of_mathematical_operations" title="wikilink">computed</a> in approximately 

<math display="inline" id="Dynamic_programming:54">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 time, which is more efficient than the above dynamic programming technique. However, the simple recurrence directly gives <a href="Fibonacci_sequence#Matrix_form" title="wikilink">the matrix form</a> that leads to an approximately 

<math display="block" id="Dynamic_programming:55">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mtext>and</mtext>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mtext>and</mtext>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mtext>and</mtext>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <matrix>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
     </matrixrow>
    </matrix>
    <mtext>and</mtext>
    <matrix>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
    </matrix>
    <mtext>and</mtext>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
     </matrixrow>
    </matrix>
    <mtext>and</mtext>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}0&1&0&1\\
1&0&1&0\\
0&1&0&1\\
1&0&1&0\end{bmatrix}\text{ and }\begin{bmatrix}0&0&1&1\\
0&0&1&1\\
1&1&0&0\\
1&1&0&0\end{bmatrix}\text{ and }\begin{bmatrix}1&1&0&0\\
0&0&1&1\\
1&1&0&0\\
0&0&1&1\end{bmatrix}\text{ and }\begin{bmatrix}1&0&0&1\\
0&1&1&0\\
0&1&1&0\\
1&0&0&1\end{bmatrix}.
  </annotation>
 </semantics>
</math>

 algorithm by fast matrix exponentiation.</p>
<h3 id="a-type-of-balanced-01-matrix">A type of balanced 0–1 matrix</h3>

<p>Consider the problem of assigning values, either zero or one, to the positions of an <mtpl></mtpl> matrix, with <mtpl></mtpl> even, so that each row and each column contains exactly <mtpl></mtpl> zeros and <mtpl></mtpl> ones. We ask how many different assignments there are for a given 

<math display="inline" id="Dynamic_programming:56">
 <semantics>
  <msup>
   <mrow>
    <mo>(</mo>
    <mstyle scriptlevel="+1">
     <mtable columnspacing="0.4em" rowspacing="0.2ex">
      <mtr>
       <mtd>
        <mi>n</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mrow>
         <mi>n</mi>
         <mo>/</mo>
         <mn>2</mn>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
    </mstyle>
    <mo>)</mo>
   </mrow>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="latexml">binomial</csymbol>
     <ci>n</ci>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\textstyle\left({{n}\atop{n/2}}\right)}^{n}
  </annotation>
 </semantics>
</math>

. For example, when <mtpl> 4}}</mtpl>, four possible solutions are</p>

<p>

<math display="inline" id="Dynamic_programming:57">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>6</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">6</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=6
  </annotation>
 </semantics>
</math>

</p>

<p>There are at least three possible approaches: <a href="Brute-force_search" title="wikilink">brute force</a>, <a class="uri" href="backtracking" title="wikilink">backtracking</a>, and dynamic programming.</p>

<p>Brute force consists of checking all assignments of zeros and ones and counting those that have balanced rows and columns (<mtpl></mtpl> zeros and <mtpl></mtpl> ones). As there are 

<math display="inline" id="Dynamic_programming:58">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 possible assignments, this strategy is not practical except maybe up to 

<math display="inline" id="Dynamic_programming:59">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n/2
  </annotation>
 </semantics>
</math>

.</p>

<p>Backtracking for this problem consists of choosing some order of the matrix elements and recursively placing ones or zeros, while checking that in every row and column the number of elements that have not been assigned plus the number of ones or zeros are both at least <mtpl></mtpl>. While more sophisticated than brute force, this approach will visit every solution once, making it impractical for <mtpl></mtpl> larger than six, since the number of solutions is already 116,963,796,250 for <mtpl></mtpl> = 10, as we shall see.</p>

<p>Dynamic programming makes it possible to count the number of solutions without visiting them all. Imagine backtracking values for the first row – what information would we require about the remaining rows, in order to be able to accurately count the solutions obtained for each first row value? We consider <mtpl></mtpl> boards, where <mtpl></mtpl>, whose 

<math display="inline" id="Dynamic_programming:60">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n/2
  </annotation>
 </semantics>
</math>

 rows contain 

<math display="inline" id="Dynamic_programming:61">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>n</mi>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>n</mi>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">…</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>n</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <vector>
     <interval closure="open">
      <apply>
       <divide></divide>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
     <interval closure="open">
      <apply>
       <divide></divide>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
     <apply>
      <times></times>
      <ci>normal-…</ci>
      <interval closure="open">
       <apply>
        <divide></divide>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <divide></divide>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f((n/2,n/2),(n/2,n/2),\ldots(n/2,n/2))
  </annotation>
 </semantics>
</math>

 zeros and 

<math display="inline" id="Dynamic_programming:62">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 ones. The function <em>f</em> to which <a class="uri" href="memoization" title="wikilink">memoization</a> is applied maps vectors of <em>n</em> pairs of integers to the number of admissible boards (solutions). There is one pair for each column, and its two components indicate respectively the number of zeros and ones that have yet to be placed in that column. We seek the value of 

<math display="inline" id="Dynamic_programming:63">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 (

<math display="inline" id="Dynamic_programming:64">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mstyle scriptlevel="+1">
    <mtable columnspacing="0.4em" rowspacing="0.2ex">
     <mtr>
      <mtd>
       <mi>n</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd>
       <mrow>
        <mi>n</mi>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mstyle>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">binomial</csymbol>
    <ci>n</ci>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\textstyle\left({{n}\atop{n/2}}\right)}
  </annotation>
 </semantics>
</math>

 arguments or one vector of 

<math display="inline" id="Dynamic_programming:65">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (0,1)
  </annotation>
 </semantics>
</math>

 elements). The process of subproblem creation involves iterating over every one of 

<math display="inline" id="Dynamic_programming:66">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>0</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">1</cn>
    <cn type="integer">0</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1,0)
  </annotation>
 </semantics>
</math>

 possible assignments for the top row of the board, and going through every column, subtracting one from the appropriate element of the pair for that column, depending on whether the assignment for the top row contained a zero or a one at that position. If any one of the results is negative, then the assignment is invalid and does not contribute to the set of solutions (recursion stops). Otherwise, we have an assignment for the top row of the <mtpl></mtpl> board and recursively compute the number of solutions to the remaining <mtpl></mtpl> board, adding the numbers of solutions for every admissible assignment of the top row and returning the sum, which is being memoized. The base case is the trivial subproblem, which occurs for a <mtpl></mtpl> board. The number of solutions for this board is either zero or one, depending on whether the vector is a permutation of <mtpl></mtpl> 

<math display="block" id="Dynamic_programming:67">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mn>90</mn>
   <mo>,</mo>
   <mn>297200</mn>
   <mo>,</mo>
   <mn>116963796250</mn>
   <mo>,</mo>
   <mn>6736218287430460752</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <cn type="integer">1</cn>
    <cn type="float">2</cn>
    <cn type="float">90</cn>
    <cn type="float">297200</cn>
    <cn type="float">116963796250</cn>
    <cn type="float">6736218287430460752</cn>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1,\,2,\,90,\,297200,\,116963796250,\,6736218287430460752,\ldots
  </annotation>
 </semantics>
</math>

 and <mtpl></mtpl> 

<math display="block" id="Dynamic_programming:68">
 <semantics>
  <mrow>
   <mrow>
    <mi>q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>min</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>q</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>B</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>q</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>C</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>q</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>D</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>c</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>q</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <min></min>
      <apply>
       <times></times>
       <ci>q</ci>
       <ci>B</ci>
      </apply>
      <apply>
       <times></times>
       <ci>q</ci>
       <ci>C</ci>
      </apply>
      <apply>
       <times></times>
       <ci>q</ci>
       <ci>D</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q(A)=\min(q(B),q(C),q(D))+c(A)\,
  </annotation>
 </semantics>
</math>

 pairs or not.</p>

<p>For example, in the first two boards shown above the sequences of vectors would be</p>
<pre><code>((2, 2) (2, 2) (2, 2) (2, 2))       ((2, 2) (2, 2) (2, 2) (2, 2))     k = 4
  0      1      0      1              0      0      1      1

((1, 2) (2, 1) (1, 2) (2, 1))       ((1, 2) (1, 2) (2, 1) (2, 1))     k = 3
  1      0      1      0              0      0      1      1

((1, 1) (1, 1) (1, 1) (1, 1))       ((0, 2) (0, 2) (2, 0) (2, 0))     k = 2
  0      1      0      1              1      1      0      0

((0, 1) (1, 0) (0, 1) (1, 0))       ((0, 1) (0, 1) (1, 0) (1, 0))     k = 1
  1      0      1      0              1      1      0      0

((0, 0) (0, 0) (0, 0) (0, 0))       ((0, 0) (0, 0), (0, 0) (0, 0))</code></pre>

<p>The number of solutions  is</p>

<p>

<math display="block" id="Dynamic_programming:69">
 <semantics>
  <mrow>
   <mrow>
    <mi>q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mi mathvariant="normal">∞</mi>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mi>j</mi>
        <mrow>
         <mo><</mo>
         <mrow>
          <mn>1</mn>
          <mtext>or</mtext>
          <mi>j</mi>
         </mrow>
         <mo>></mo>
        </mrow>
        <mi>n</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>c</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>i</mi>
         <mo>,</mo>
         <mi>j</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mi>min</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>q</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>i</mi>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
            <mo>,</mo>
            <mrow>
             <mi>j</mi>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>,</mo>
          <mrow>
           <mi>q</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>i</mi>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
            <mo>,</mo>
            <mi>j</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>,</mo>
          <mrow>
           <mi>q</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>i</mi>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
            <mo>,</mo>
            <mrow>
             <mi>j</mi>
             <mo>+</mo>
             <mn>1</mn>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>c</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>i</mi>
          <mo>,</mo>
          <mi>j</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise.</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>q</ci>
     <interval closure="open">
      <ci>i</ci>
      <ci>j</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <infinity></infinity>
     <apply>
      <times></times>
      <ci>j</ci>
      <apply>
       <csymbol cd="latexml">expectation</csymbol>
       <apply>
        <times></times>
        <cn type="integer">1</cn>
        <mtext>or</mtext>
        <ci>j</ci>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>c</ci>
      <interval closure="open">
       <ci>i</ci>
       <ci>j</ci>
      </interval>
     </apply>
     <apply>
      <eq></eq>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <min></min>
       <apply>
        <times></times>
        <ci>q</ci>
        <interval closure="open">
         <apply>
          <minus></minus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <minus></minus>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </interval>
       </apply>
       <apply>
        <times></times>
        <ci>q</ci>
        <interval closure="open">
         <apply>
          <minus></minus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>j</ci>
        </interval>
       </apply>
       <apply>
        <times></times>
        <ci>q</ci>
        <interval closure="open">
         <apply>
          <minus></minus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <plus></plus>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </interval>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>c</ci>
       <interval closure="open">
        <ci>i</ci>
        <ci>j</ci>
       </interval>
      </apply>
     </apply>
     <mtext>otherwise.</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q(i,j)=\begin{cases}\infty&j<1\text{ or }j>n\\
c(i,j)&i=1\\
\min(q(i-1,j-1),q(i-1,j),q(i-1,j+1))+c(i,j)&\text{otherwise.}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>Links to the MAPLE implementation of the dynamic programming approach may be found among the <a href="Dynamic_programming#External_links" title="wikilink">external links</a>.</p>
<h3 id="checkerboard">Checkerboard</h3>

<p>Consider a <a class="uri" href="checkerboard" title="wikilink">checkerboard</a> with <em>n</em> × <em>n</em> squares and a cost-function <em>c</em>(<em>i</em>, <em>j</em>) which returns a cost associated with square <em>i</em>, <em>j</em> (<em>i</em> being the row, <em>j</em> being the column). For instance (on a 5 × 5 checkerboard),</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>5</p></th>
<th style="text-align: left;">
<p>6</p></th>
<th style="text-align: left;">
<p>7</p></th>
<th style="text-align: left;">
<p>4</p></th>
<th style="text-align: left;">
<p>7</p></th>
<th style="text-align: left;">
<p>8</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>4</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;">
<p>2</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>–</p></td>
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>–</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>–</p></td>
<td style="text-align: left;">
<p>–</p></td>
<td style="text-align: left;">
<p>*5*</p></td>
<td style="text-align: left;">
<p>–</p></td>
<td style="text-align: left;">
<p>–</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>5</p></td>
</tr>
</tbody>
</table>

<p>Thus <em>c</em>(1, 3) = 5</p>

<p>Let us say you had a checker that could start at any square on the first rank (i.e., row) and you wanted to know the shortest path (sum of the costs of the visited squares are at a minimum) to get to the last rank, assuming the checker could move only diagonally left forward, diagonally right forward, or straight forward. That is, a checker on (1,3) can move to (2,2), (2,3) or (2,4).</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>5</p></th>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>x</p></td>
<td style="text-align: left;">
<p>x</p></td>
<td style="text-align: left;">
<p>x</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>o</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>5</p></td>
</tr>
</tbody>
</table>

<p>This problem exhibits <strong>optimal substructure</strong>. That is, the solution to the entire problem relies on solutions to subproblems. Let us define a function <em>q</em>(<em>i</em>, <em>j</em>) as</p>
<dl>
<dd><em>q</em>(<em>i</em>, <em>j</em>) = the minimum cost to reach square (<em>i</em>, <em>j</em>).
</dd>
</dl>

<p>If we can find the values of this function for all the squares at rank <em>n</em>, we pick the minimum and follow that path backwards to get the shortest path.</p>

<p>Note that <em>q</em>(<em>i</em>, <em>j</em>) is equal to the minimum cost to get to any of the three squares below it (since those are the only squares that can reach it) plus <em>c</em>(<em>i</em>, <em>j</em>). For instance:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>5</p></th>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>A</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>B</p></td>
<td style="text-align: left;">
<p>C</p></td>
<td style="text-align: left;">
<p>D</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>5</p></td>
</tr>
</tbody>
</table>

<p>

<math display="inline" id="Dynamic_programming:70">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <msup>
      <mi>k</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>k</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nk^{2})
  </annotation>
 </semantics>
</math>

</p>

<p>Now, let us define <em>q</em>(<em>i</em>, <em>j</em>) in somewhat more general terms:</p>

<p>

<math display="inline" id="Dynamic_programming:71">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>k</mi>
     <mrow>
      <mi>log</mi>
      <mi>k</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>k</ci>
     <apply>
      <log></log>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nk\log k)
  </annotation>
 </semantics>
</math>

</p>

<p>The first line of this equation is there to make the recursive property simpler (when dealing with the edges, so we need only one recursion). The second line says what happens in the last rank, to provide a base case. The third line, the recursion, is the important part. It is similar to the A,B,C,D example. From this definition we can make a straightforward recursive code for <em>q</em>(<em>i</em>, <em>j</em>). In the following pseudocode, <em>n</em> is the size of the board, <code>c(i, j)</code> is the cost-function, and <code>min()</code> returns the minimum of a number of values:</p>

<p><strong><code>function</code></strong><code> minCost(i, j)</code><br/>
<code>    </code><strong><code>if</code></strong><code> j </code><code> n</code><br/>
<code>        </code><strong><code>return</code></strong><code> infinity</code><br/>
<code>    </code><strong><code>else</code> <code>if</code></strong><code> i = 1</code><br/>
<code>        </code><strong><code>return</code></strong><code> c(i, j)</code><br/>
<code>    </code><strong><code>else</code></strong><br/>
<code>        </code><strong><code>return</code></strong><code> </code><strong><code>min</code></strong><code>( minCost(i-1, j-1), minCost(i-1, j), minCost(i-1, j+1) ) + c(i, j)</code></p>

<p>It should be noted that this function only computes the path-cost, not the actual path. We will get to the path soon. This, like the Fibonacci-numbers example, is horribly slow since it wastes time recomputing the same shortest paths over and over. However, we can compute it much faster in a bottom-up fashion if we store path-costs in a two-dimensional array <code>q[i, j]</code> rather than using a function. This avoids recomputation; before computing the cost of a path, we check the array <code>q[i, j]</code> to see if the path cost is already there.</p>

<p>We also need to know what the actual shortest path is. To do this, we use another array <code>p[i, j]</code>, a <em>predecessor array</em>. This array implicitly stores the path to any square <em>s</em> by storing the previous node on the shortest path to <em>s</em>, i.e. the predecessor. To reconstruct the path, we lookup the predecessor of <em>s</em>, then the predecessor of that square, then the predecessor of that square, and so on, until we reach the starting square. Consider the following code:</p>

<p><code> </code><strong><code>function</code></strong><code> computeShortestPathArrays()</code><br/>
<code>     </code><strong><code>for</code></strong><code> x </code><strong><code>from</code></strong><code> 1 </code><strong><code>to</code></strong><code> n</code><br/>
<code>         q[1, x] := c(1, x)</code><br/>
<code>     </code><strong><code>for</code></strong><code> y </code><strong><code>from</code></strong><code> 1 </code><strong><code>to</code></strong><code> n</code><br/>
<code>         q[y, 0]     := infinity</code><br/>
<code>         q[y, n + 1] := infinity</code><br/>
<code>     </code><strong><code>for</code></strong><code> y </code><strong><code>from</code></strong><code> 2 </code><strong><code>to</code></strong><code> n</code><br/>
<code>         </code><strong><code>for</code></strong><code> x </code><strong><code>from</code></strong><code> 1 </code><strong><code>to</code></strong><code> n</code><br/>
<code>             m := min(q[y-1, x-1], q[y-1, x], q[y-1, x+1])</code><br/>
<code>             q[y, x] := m + c(y, x)</code><br/>
<code>             </code><strong><code>if</code></strong><code> m = q[y-1, x-1]</code><br/>
<code>                 p[y, x] := -1</code><br/>
<code>             </code><strong><code>else</code> <code>if</code></strong><code> m = q[y-1, x]</code><br/>
<code>                 p[y, x] :=  0</code><br/>
<code>             </code><strong><code>else</code></strong><br/>
<code>                 p[y, x] :=  1</code></p>

<p>Now the rest is a simple matter of finding the minimum and printing it.</p>

<p><code> </code><strong><code>function</code></strong><code> computeShortestPath()</code><br/>
<code>     computeShortestPathArrays()</code><br/>
<code>     minIndex := 1</code><br/>
<code>     min := q[n, 1]</code><br/>
<code>     </code><strong><code>for</code></strong><code> i </code><strong><code>from</code></strong><code> 2 </code><strong><code>to</code></strong><code> n</code><br/>
<code>         </code><strong><code>if</code></strong><code> q[n, i] </code><code>  Typically, the problem consists of transforming one sequence into another using edit operations that replace, insert, or remove an element.  Each operation has an associated cost, and the goal is to find the </code><a href="edit_distance" title="wikilink"><code>sequence</code> <code>of</code> <code>edits</code> <code>with</code> <code>the</code> <code>lowest</code> <code>total</code> <code>cost</code></a><code>.</code></p>

<p>The problem can be stated naturally as a recursion, a sequence A is optimally edited into a sequence B by either:</p>
<ol>
<li>inserting the first character of B, and performing an optimal alignment of A and the tail of B</li>
<li>deleting the first character of A, and performing the optimal alignment of the tail of A and B</li>
<li>replacing the first character of A with the first character of B, and performing optimal alignments of the tails of A and B.</li>
</ol>

<p>The partial alignments can be tabulated in a matrix, where cell (i,j) contains the cost of the optimal alignment of A[1..i] to B[1..j]. The cost in cell (i,j) can be calculated by adding the cost of the relevant operations to the cost of its neighboring cells, and selecting the optimum.</p>

<p>Different variants exist, see <a href="Smith–Waterman_algorithm" title="wikilink">Smith–Waterman algorithm</a> and <a href="Needleman–Wunsch_algorithm" title="wikilink">Needleman–Wunsch algorithm</a>.</p>
<h3 id="tower-of-hanoi-puzzle">Tower of Hanoi puzzle</h3>

<p>  The <strong><a href="Tower_of_Hanoi" title="wikilink">Tower of Hanoi</a></strong> or <strong>Towers of <a class="uri" href="Hanoi" title="wikilink">Hanoi</a></strong> is a <a href="mathematical_game" title="wikilink">mathematical game</a> or <a class="uri" href="puzzle" title="wikilink">puzzle</a>. It consists of three rods, and a number of disks of different sizes which can slide onto any rod. The puzzle starts with the disks in a neat stack in ascending order of size on one rod, the smallest at the top, thus making a conical shape.</p>

<p>The objective of the puzzle is to move the entire stack to another rod, obeying the following rules:</p>
<ul>
<li>Only one disk may be moved at a time.</li>
<li>Each move consists of taking the upper disk from one of the rods and sliding it onto another rod, on top of the other disks that may already be present on that rod.</li>
<li>No disk may be placed on top of a smaller disk.</li>
</ul>

<p>The dynamic programming solution consists of solving the <a href="Bellman_equation" title="wikilink">functional equation</a></p>
<dl>
<dd>S(n,h,t) = S(n-1,h, not(h,t)) ; S(1,h,t) ; S(n-1,not(h,t),t)
</dd>
</dl>

<p>where n denotes the number of disks to be moved, h denotes the home rod, t denotes the target rod, not(h,t) denotes the third rod (neither h nor t), ";" denotes concatenation, and</p>
<dl>
<dd>S(n, h, t) := solution to a problem consisting of n disks that are to be moved from rod h to rod t.
</dd>
</dl>

<p>Note that for n=1 the problem is trivial, namely S(1,h,t) = "move a disk from rod h to rod t" (there is only one disk left).</p>

<p>The number of moves required by this solution is 2<sup><em>n</em></sup> − 1. If the objective is to <strong>maximize</strong> the number of moves (without cycling) then the dynamic programming <a href="Bellman_equation" title="wikilink">functional equation</a> is slightly more complicated and 3<sup><em>n</em></sup> − 1 moves are required.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h3 id="egg-dropping-puzzle">Egg dropping puzzle</h3>

<p>The following is a description of the instance of this famous <a class="uri" href="puzzle" title="wikilink">puzzle</a> involving n=2 eggs and a building with H=36 floors:<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<dl>
<dd>Suppose that we wish to know which stories in a 36-story building are safe to drop eggs from, and which will cause the eggs to break on landing (using <a href="U.S._English" title="wikilink">U.S. English</a> terminology, in which the first floor is at ground level). We make a few assumptions:
<ul>
<li>An egg that survives a fall can be used again.</li>
<li>A broken egg must be discarded.</li>
<li>The effect of a fall is the same for all eggs.</li>
<li>If an egg breaks when dropped, then it would break if dropped from a higher window.</li>
<li>If an egg survives a fall, then it would survive a shorter fall.</li>
<li>It is not ruled out that the first-floor windows break eggs, nor is it ruled out that eggs can survive the 36th-floor windows.</li>
</ul>
</dd>
</dl>
<dl>
<dd>If only one egg is available and we wish to be sure of obtaining the right result, the experiment can be carried out in only one way. Drop the egg from the first-floor window; if it survives, drop it from the second-floor window. Continue upward until it breaks. In the worst case, this method may require 36 droppings. Suppose 2 eggs are available. What is the least number of egg-droppings that is guaranteed to work in all cases?
</dd>
</dl>

<p>To derive a dynamic programming <a href="Bellman_equation" title="wikilink">functional equation</a> for this puzzle, let the <strong>state</strong> of the dynamic programming model be a pair s = (n,k), where</p>
<dl>
<dd><em>n</em> = number of test eggs available, <em>n</em> = 0, 1, 2, 3, ..., <em>N</em> − 1.
</dd>
<dd><em>k</em> = number of (consecutive) floors yet to be tested, <em>k</em> = 0, 1, 2, ..., <em>H</em> − 1.
</dd>
</dl>

<p>For instance, <em>s</em> = (2,6) indicates that two test eggs are available and 6 (consecutive) floors are yet to be tested. The initial state of the process is <em>s</em> = (<em>N</em>,<em>H</em>) where <em>N</em> denotes the number of test eggs available at the commencement of the experiment. The process terminates either when there are no more test eggs (<em>n</em> = 0) or when <em>k</em> = 0, whichever occurs first. If termination occurs at state <em>s</em> = (0,<em>k</em>) and <em>k</em> &gt; 0, then the test failed.</p>

<p>Now, let</p>
<dl>
<dd><em>W</em>(<em>n</em>,<em>k</em>) = minimum number of trials required to identify the value of the critical floor under the worst-case scenario given that the process is in state <em>s</em> = (<em>n</em>,<em>k</em>).
</dd>
</dl>

<p>Then it can be shown that<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<dl>
<dd><em>W</em>(<em>n</em>,<em>k</em>) = 1 + min{max(<em>W</em>(<em>n</em> − 1, <em>x</em> − 1), <em>W</em>(<em>n</em>,<em>k</em> − <em>x</em>)): <em>x</em> = 1, 2, ..., <em>k</em> }
</dd>
</dl>

<p>with <em>W</em>(<em>n</em>,1) = 1 for all <em>n</em> &gt; 0 and <em>W</em>(1,<em>k</em>) = <em>k</em> for all <em>k</em>. It is easy to solve this equation iteratively by systematically increasing the values of <em>n</em> and <em>k</em>.</p>

<p>An <a href="http://archive.ite.journal.informs.org/Vol4No1/Sniedovich/index.php">interactive online facility</a> is available for experimentation with this model as well as with other versions of this puzzle (e.g. when the objective is to minimize the <strong>expected value</strong> of the number of trials.)<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h4 id="faster-dp-solution-using-a-different-parametrization">Faster DP solution using a different parametrization</h4>

<p>Notice that the above solution takes 

<math display="inline" id="Dynamic_programming:72">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 time with a DP solution. This can be improved to 

<math display="inline" id="Dynamic_programming:73">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>W</ci>
    <interval closure="open">
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W(n-1,x-1)
  </annotation>
 </semantics>
</math>

 time by binary searching on the optimal 

<math display="inline" id="Dynamic_programming:74">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 in the above recurrence, since 

<math display="inline" id="Dynamic_programming:75">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mi>x</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>W</ci>
    <interval closure="open">
     <ci>n</ci>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <ci>x</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W(n,k-x)
  </annotation>
 </semantics>
</math>

 is increasing in 

<math display="inline" id="Dynamic_programming:76">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 while 

<math display="inline" id="Dynamic_programming:77">
 <semantics>
  <mrow>
   <mi>max</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>W</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>W</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>,</mo>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <max></max>
    <apply>
     <times></times>
     <ci>W</ci>
     <interval closure="open">
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>W</ci>
     <interval closure="open">
      <ci>n</ci>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <ci>x</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max(W(n-1,x-1),W(n,k-x))
  </annotation>
 </semantics>
</math>

 is decreasing in 

<math display="inline" id="Dynamic_programming:78">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, thus a local minimum of 

<math display="inline" id="Dynamic_programming:79">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is a global minimum. Also, by storing the optimal 

<math display="inline" id="Dynamic_programming:80">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>k</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nk)
  </annotation>
 </semantics>
</math>

 for each cell in the DP table and referring to its value for the previous cell, the optimal 

<math display="inline" id="Dynamic_programming:81">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 for each cell can be found in constant time, improving it to 

<math display="inline" id="Dynamic_programming:82">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 time. However, there is an even faster solution that involves a different parametrization of the problem:</p>

<p>Let 

<math display="inline" id="Dynamic_programming:83">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mn>37</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <cn type="integer">37</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=37
  </annotation>
 </semantics>
</math>

 be the total number of floors such that the eggs break when dropped from the 

<math display="inline" id="Dynamic_programming:84">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

th floor (The example above is equivalent to taking 

<math display="inline" id="Dynamic_programming:85">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>t</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(t,n)
  </annotation>
 </semantics>
</math>

).</p>

<p>Let 

<math display="inline" id="Dynamic_programming:86">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 be the minimum floor from which the egg must be dropped to be broken.</p>

<p>Let 

<math display="inline" id="Dynamic_programming:87">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 be the maximum number of values of 

<math display="inline" id="Dynamic_programming:88">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 that are distinguishable using 

<math display="inline" id="Dynamic_programming:89">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo>,</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>t</ci>
       <cn type="integer">0</cn>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <cn type="integer">0</cn>
       <ci>n</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(t,0)=f(0,n)=1
  </annotation>
 </semantics>
</math>

 tries and 

<math display="inline" id="Dynamic_programming:90">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <list>
     <ci>t</ci>
     <ci>n</ci>
    </list>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t,n\geq 0
  </annotation>
 </semantics>
</math>

 eggs.</p>

<p>Then 

<math display="inline" id="Dynamic_programming:91">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Dynamic_programming:92">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

.</p>

<p>Let 

<math display="inline" id="Dynamic_programming:93">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 be the floor from which the first egg is dropped in the optimal strategy.</p>

<p>If the first egg broke, 

<math display="inline" id="Dynamic_programming:94">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is from 

<math display="inline" id="Dynamic_programming:95">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t-1
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Dynamic_programming:96">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-1
  </annotation>
 </semantics>
</math>

 and distinguishable using at most 

<math display="inline" id="Dynamic_programming:97">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 tries and 

<math display="inline" id="Dynamic_programming:98">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>a</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a+1
  </annotation>
 </semantics>
</math>

 eggs.</p>

<p>If the first egg did not break, 

<math display="inline" id="Dynamic_programming:99">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is from 

<math display="inline" id="Dynamic_programming:100">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t-1
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Dynamic_programming:101">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 and distinguishable using 

<math display="inline" id="Dynamic_programming:102">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo>,</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>t</ci>
      <ci>n</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <apply>
        <minus></minus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <apply>
        <minus></minus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>n</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(t,n)=f(t-1,n-1)+f(t-1,n)
  </annotation>
 </semantics>
</math>

 tries and 

<math display="inline" id="Dynamic_programming:103">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 eggs.</p>

<p>Therefore, 

<math display="inline" id="Dynamic_programming:104">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>n</ci>
     </interval>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,n)\geq k
  </annotation>
 </semantics>
</math>

.</p>

<p>Then the problem is equivalent to finding the minimum 

<math display="inline" id="Dynamic_programming:105">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo>,</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mn>0</mn>
    <mo>≤</mo>
    <mi>i</mi>
    <mo>≤</mo>
    <mi>n</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>t</ci>
      <ci>i</ci>
     </interval>
    </apply>
    <apply>
     <and></and>
     <apply>
      <leq></leq>
      <cn type="integer">0</cn>
      <ci>i</ci>
     </apply>
     <apply>
      <leq></leq>
      <share href="#.cmml">
      </share>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{f(t,i):0\leq i\leq n\}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Dynamic_programming:106">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

.</p>

<p>To do so, we could compute 

<math display="inline" id="Dynamic_programming:107">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>x</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nx)
  </annotation>
 </semantics>
</math>

 in order of increasing 

<math display="inline" id="Dynamic_programming:108">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=1
  </annotation>
 </semantics>
</math>

, which would take 

<math display="inline" id="Dynamic_programming:109">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <msqrt>
      <mi>k</mi>
     </msqrt>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <root></root>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n\sqrt{k})
  </annotation>
 </semantics>
</math>

 time.</p>

<p>Thus, if we separately handle the case of 

<math display="inline" id="Dynamic_programming:110">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <mo>(</mo>
     <mstyle scriptlevel="+1">
      <mtable columnspacing="0.4em" rowspacing="0.2ex">
       <mtr>
        <mtd>
         <mi>t</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd>
         <mi>i</mi>
        </mtd>
       </mtr>
      </mtable>
     </mstyle>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>t</ci>
      <ci>n</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">binomial</csymbol>
      <ci>t</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(t,n)=\sum_{i=0}^{n}{{\left({{t}\atop{i}}\right)}}
  </annotation>
 </semantics>
</math>

, the algorithm would take 

<math display="inline" id="Dynamic_programming:111">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 time.</p>

<p>But the recurrence relation can in fact be solved, giving 

<math display="inline" id="Dynamic_programming:112">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mstyle scriptlevel="+1">
     <mtable columnspacing="0.4em" rowspacing="0.2ex">
      <mtr>
       <mtd>
        <mi>t</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mrow>
         <mi>i</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
    </mstyle>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mstyle scriptlevel="+1">
      <mtable columnspacing="0.4em" rowspacing="0.2ex">
       <mtr>
        <mtd>
         <mi>t</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd>
         <mi>i</mi>
        </mtd>
       </mtr>
      </mtable>
     </mstyle>
     <mo>)</mo>
    </mrow>
    <mfrac>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mi>i</mi>
     </mrow>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">binomial</csymbol>
     <ci>t</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">binomial</csymbol>
      <ci>t</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\left({{t}\atop{i+1}}\right)}={\left({{t}\atop{i}}\right)}\frac{t-i}{i+1}
  </annotation>
 </semantics>
</math>

, which can be computed in 

<math display="inline" id="Dynamic_programming:113">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>i</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\geq 0
  </annotation>
 </semantics>
</math>

 time using the identity 

<math display="inline" id="Dynamic_programming:114">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>t</ci>
      <ci>n</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>n</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(t,n)\leq f(t+1,n)
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Dynamic_programming:115">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>t</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\geq 0
  </annotation>
 </semantics>
</math>

.</p>

<p>Since 

<math display="inline" id="Dynamic_programming:116">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Dynamic_programming:117">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, we can binary search on 

<math display="inline" id="Dynamic_programming:118">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mi>log</mi>
      <mi>k</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <log></log>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n\log k)
  </annotation>
 </semantics>
</math>

 to find 

<math display="inline" id="Dynamic_programming:119">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mi>i</mi>
    <mi>i</mi>
   </mrow>
   <mo>,</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>i</ci>
     <ci>i</ci>
    </apply>
    <ci>j</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   sii,j
  </annotation>
 </semantics>
</math>

, giving an 

<math display="inline" id="Dynamic_programming:120">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>m</mi>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mn>33</mn>
   </mrow>
   <mo>=</mo>
   <mn>1000</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <times></times>
      <ci>m</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">33</cn>
    </list>
    <cn type="integer">1000</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m1,33=1000
  </annotation>
 </semantics>
</math>

 algorithm. <a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h3 id="matrix-chain-multiplication">Matrix chain multiplication</h3>

<p>Matrix chain multiplication is a well known example that demonstrates utility of dynamic programming. For example, engineering applications often have to multiply a chain of matrices. It is not surprising to find matrices of large dimensions, for example 100×100. Therefore, our task is to multiply matrices A1, A2, .... An. As we know from basic linear algebra, matrix multiplication is not commutative, but is associative; and we can multiply only two matrices at a time. So, we can multiply this chain of matrices in many different ways, for example:</p>
<dl>
<dd>((A<sub>1</sub> × A<sub>2</sub>) × A<sub>3</sub>) × ... A<sub>n</sub>
</dd>
</dl>
<dl>
<dd>A<sub>1</sub>×(((A<sub>2</sub>×A<sub>3</sub>)× ... ) × A<sub>n</sub>)
</dd>
</dl>
<dl>
<dd>(A<sub>1</sub> × A<sub>2</sub>) × (A<sub>3</sub> × ... A<sub>n</sub>)
</dd>
</dl>

<p>and so on. There are numerous ways to multiply this chain of matrices. They will all produce the same final result, however they will take more or less time to compute, based on which particular matrices are multiplied. If matrix A has dimensions m×n and matrix B has dimensions n×q, then matrix C=A×B will have dimensions m×q, and will require m*n*q scalar multiplications (using a simplistic matrix multiplication algorithm for purposes of illustration).</p>

<p>For example, let us multiply matrices A, B and C. Let us assume that their dimensions are m×n, n×p, and p×s, respectively. Matrix A×B×C will be of size m×s and can be calculated in two ways shown below:</p>
<ol>
<li>Ax(B×C) This order of matrix multiplication will require nps + mns scalar multiplications.</li>
<li>(A×B)×C This order of matrix multiplication will require mnp + mps scalar calculations.</li>
</ol>

<p>Let us assume that m = 10, n = 100, p = 10 and s = 1000. So, the first way to multiply the chain will require 1,000,000 + 1,000,000 calculations. The second way will require only 10,000+100,000 calculations. Obviously, the second way is faster, and we should multiply the matrices using that arrangement of parenthesis.</p>

<p>Therefore, our conclusion is that the order of parenthesis matters, and that our task is to find the optimal order of parenthesis.</p>

<p>At this point, we have several choices, one of which is to design a dynamic programming algorithm that will split the problem into overlapping problems and calculate the optimal arrangement of parenthesis. The dynamic programming solution is presented below.</p>

<p>Let's call m[i,j] the minimum number of scalar multiplications needed to multiply a chain of matrices from matrix i to matrix j (i.e. A<sub>i</sub> × .... × A<sub>j</sub>, i.e. i$m i i , j$, the minimum number of calculations to multiply a chain from matrix <em>i</em> to matrix <em>j</em>, and we have recorded the corresponding "split point"

<math display="inline" id="Dynamic_programming:121">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>s</mi>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mn>33</mn>
   </mrow>
   <mo>=</mo>
   <mn>22</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <times></times>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">33</cn>
    </list>
    <cn type="integer">22</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s1,33=22
  </annotation>
 </semantics>
</math>

. For example, if we are multiplying chain A<sub>1</sub>×A<sub>2</sub>×A<sub>3</sub>×A<sub>4</sub>, and it turns out that <span class="LaTeX">$ m 1, 3 3 = 100 0$</span> and <span class="LaTeX">$ s 1, 3 3 = 2 2$</span>, that means that the optimal placement of parenthesis for matrices 1 to 3 is (A1×A2)×A3 and to multiply those matrices will require 100 scalar calculation.</p>

<p>This algorithm will produce "tables" <em>m</em>[, ] and <em>s</em>[, ] that will have entries for all possible values of i and j. The final solution for the entire chain is m[1, n], with corresponding split at s[1, n]. Unraveling the solution will be recursive, starting from the top and continuing until we reach the base case, i.e. multiplication of single matrices.</p>

<p>Therefore, the next step is to actually split the chain, i.e. to place the parenthesis where they (optimally) belong. For this purpose we could use the following algorithm:</p>

<p><code> </code><strong><code>function</code></strong><code> PrintOptimalParenthesis(s, i, j)</code><br/>
<code>     </code><strong><code>if</code></strong><code> i = j</code><br/>
<code>        print "A"i</code><br/>
<code>     </code><strong><code>else</code></strong><br/>
<code>        print "("  PrintOptimalParenthesis(s, i, s[i, j])  PrintOptimalParenthesis(s, s[i, j] + 1, j) ")"</code><br/>
<code>       </code></p>

<p>Of course, this algorithm is not useful for actual multiplication. This algorithm is just a user-friendly way to see what the result looks like.</p>

<p>To actually multiply the matrices using the proper splits, we need the following algorithm:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">   <span class="kw">function</span> <span class="at">MatrixChainMultiply</span>(chain <span class="im">from</span> <span class="dv">1</span> to n)         <span class="co">// returns the final matrix, i.e. A1×A2×... ×An</span>
      <span class="at">OptimalMatrixChainParenthesis</span>(chain <span class="im">from</span> <span class="dv">1</span> to n)  <span class="co">// this will produce s[ . ] and m[ . ] "tables"</span>
      <span class="at">OptimalMatrixMultiplication</span>(s<span class="op">,</span> chain <span class="im">from</span> <span class="dv">1</span> to n)    <span class="co">// actually multiply</span>

   <span class="kw">function</span> <span class="at">OptimalMatrixMultiplication</span>(s<span class="op">,</span> i<span class="op">,</span> j)   <span class="co">// returns the result of multiplying a chain of matrices from Ai to Aj in optimal way</span>
      <span class="cf">if</span> i <span class="op">&lt;</span> j
         <span class="co">// keep on splitting the chain and multiplying the matrices in left and right sides</span>
         LeftSide <span class="op">=</span> <span class="at">OptimalMatrixMultiplication</span>(s<span class="op">,</span> i<span class="op">,</span> s[i<span class="op">,</span> j])  
         RightSide <span class="op">=</span> <span class="at">OptimalMatrixMultiplication</span>(s<span class="op">,</span> s[i<span class="op">,</span> j] <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> j)
         <span class="cf">return</span> <span class="at">MatrixMultiply</span>(LeftSide<span class="op">,</span> RightSide) 
      <span class="cf">else</span> <span class="cf">if</span> i <span class="op">=</span> j
         <span class="cf">return</span> Ai   <span class="co">// matrix at position i</span>
      <span class="cf">else</span> 
         print <span class="st">"error, i &lt;= j must hold"</span>

    <span class="kw">function</span> <span class="at">MatrixMultiply</span>(A<span class="op">,</span> B)    <span class="co">// function that multiplies two matrices</span>
      <span class="cf">if</span> <span class="at">columns</span>(A) <span class="op">=</span> <span class="at">rows</span>(B) 
         <span class="cf">for</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> <span class="at">rows</span>(A)
            <span class="cf">for</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> <span class="at">columns</span>(B)
               C[i<span class="op">,</span> j] <span class="op">=</span> <span class="dv">0</span>
               <span class="cf">for</span> k <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> <span class="at">columns</span>(A)
                   C[i<span class="op">,</span> j] <span class="op">=</span> C[i<span class="op">,</span> j] <span class="op">+</span> A[i<span class="op">,</span> k]<span class="op">*</span>B[k<span class="op">,</span> j] 
               <span class="cf">return</span> C 
      <span class="cf">else</span> 
          print <span class="st">"error, incompatible dimensions."</span></code></pre></div>
<h2 id="history">History</h2>

<p>The term <em>dynamic programming</em> was originally used in the 1940s by <a href="Richard_Bellman" title="wikilink">Richard Bellman</a> to describe the process of solving problems where one needs to find the best decisions one after another. By 1953, he refined this to the modern meaning, referring specifically to nesting smaller decision problems inside larger decisions,<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> and the field was thereafter recognized by the <a class="uri" href="IEEE" title="wikilink">IEEE</a> as a <a href="systems_analysis" title="wikilink">systems analysis</a> and <a class="uri" href="engineering" title="wikilink">engineering</a> topic. Bellman's contribution is remembered in the name of the <a href="Bellman_equation" title="wikilink">Bellman equation</a>, a central result of dynamic programming which restates an optimization problem in <a href="Recursion_(computer_science)" title="wikilink">recursive</a> form.</p>

<p>Bellman explains the reasoning behind the term <em>dynamic programming</em> in his autobiography, <em>Eye of the Hurricane: An Autobiography</em> (1984). He explains:</p>
<dl>
<dd>"I spent the Fall quarter (of 1950) at RAND. My first task was to find a name for multistage decision processes. An interesting question is, Where did the name, dynamic programming, come from? The 1950s were not good years for mathematical research. We had a very interesting gentleman in Washington named <a href="Charles_Erwin_Wilson" title="wikilink">Wilson</a>. He was Secretary of Defense, and he actually had a pathological fear and hatred of the word research. I’m not using the term lightly; I’m using it precisely. His face would suffuse, he would turn red, and he would get violent if people used the term research in his presence. You can imagine how he felt, then, about the term mathematical. The RAND Corporation was employed by the Air Force, and the Air Force had Wilson as its boss, essentially. Hence, I felt I had to do something to shield Wilson and the Air Force from the fact that I was really doing mathematics inside the RAND Corporation. What title, what name, could I choose? In the first place I was interested in planning, in decision making, in thinking. But planning, is not a good word for various reasons. I decided therefore to use the word “programming”. I wanted to get across the idea that this was dynamic, this was multistage, this was time-varying. I thought, let's kill two birds with one stone. Let's take a word that has an absolutely precise meaning, namely dynamic, in the classical physical sense. It also has a very interesting property as an adjective, and that it's impossible to use the word dynamic in a pejorative sense. Try thinking of some combination that will possibly give it a pejorative meaning. It's impossible. Thus, I thought dynamic programming was a good name. It was something not even a Congressman could object to. So I used it as an umbrella for my activities."
</dd>
</dl>

<p>The word <em>dynamic</em> was chosen by Bellman to capture the time-varying aspect of the problems, and because it sounded impressive.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> The word <em>programming</em> referred to the use of the method to find an optimal <em>program</em>, in the sense of a military schedule for training or logistics. This usage is the same as that in the phrases <em><a href="linear_programming" title="wikilink">linear programming</a></em> and <em>mathematical programming</em>, a synonym for <a href="mathematical_optimization" title="wikilink">mathematical optimization</a>.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h2 id="algorithms-that-use-dynamic-programming">Algorithms that use dynamic programming</h2>
<ul>
<li>Recurrent solutions to <a href="lattice_models" title="wikilink">lattice models</a> for protein-DNA binding</li>
<li><a href="Backward_induction" title="wikilink">Backward induction</a> as a solution method for finite-horizon <a class="uri" href="discrete-time" title="wikilink">discrete-time</a> dynamic optimization problems</li>
<li><a href="Method_of_undetermined_coefficients" title="wikilink">Method of undetermined coefficients</a> can be used to solve the <a href="Bellman_equation" title="wikilink">Bellman equation</a> in infinite-horizon, discrete-time, <a href="discounting" title="wikilink">discounted</a>, <a href="Time-invariant_system" title="wikilink">time-invariant</a> dynamic optimization problems</li>
<li>Many <a href="String_(computer_science)" title="wikilink">string</a> algorithms including <a href="longest_common_subsequence_problem" title="wikilink">longest common subsequence</a>, <a href="Longest_increasing_subsequence_problem" title="wikilink">longest increasing subsequence</a>, <a href="Longest_common_substring_problem" title="wikilink">longest common substring</a>, <a href="Levenshtein_distance" title="wikilink">Levenshtein distance</a> (edit distance)</li>
<li>Many algorithmic problems on <a href="undirected_graph" title="wikilink">graphs</a> can be solved efficiently for graphs of bounded <a class="uri" href="treewidth" title="wikilink">treewidth</a> or bounded <a class="uri" href="clique-width" title="wikilink">clique-width</a> by using dynamic programming on a <a href="tree_decomposition" title="wikilink">tree decomposition</a> of the graph.</li>
<li>The <a href="CYK_algorithm" title="wikilink">Cocke–Younger–Kasami (CYK) algorithm</a> which determines whether and how a given string can be generated by a given <a href="context-free_grammar" title="wikilink">context-free grammar</a></li>
<li><a href="Word_wrap" title="wikilink">Knuth's word wrapping algorithm</a> that minimizes raggedness when word wrapping text</li>
<li>The use of <a href="transposition_table" title="wikilink">transposition tables</a> and <a href="refutation_table" title="wikilink">refutation tables</a> in <a href="computer_chess" title="wikilink">computer chess</a></li>
<li>The <a href="Viterbi_algorithm" title="wikilink">Viterbi algorithm</a> (used for <a href="hidden_Markov_model" title="wikilink">hidden Markov models</a>)</li>
<li>The <a href="Earley_algorithm" title="wikilink">Earley algorithm</a> (a type of <a href="chart_parser" title="wikilink">chart parser</a>)</li>
<li>The <a href="Needleman–Wunsch_algorithm" title="wikilink">Needleman–Wunsch</a> and other algorithms used in <a class="uri" href="bioinformatics" title="wikilink">bioinformatics</a>, including <a href="sequence_alignment" title="wikilink">sequence alignment</a>, <a href="structural_alignment" title="wikilink">structural alignment</a>, <a href="RNA_structure" title="wikilink">RNA structure prediction</a></li>
<li><a href="Floyd–Warshall_algorithm" title="wikilink">Floyd's all-pairs shortest path algorithm</a></li>
<li>Optimizing the order for <a href="chain_matrix_multiplication" title="wikilink">chain matrix multiplication</a></li>
<li><a href="Pseudo-polynomial_time" title="wikilink">Pseudo-polynomial time</a> algorithms for the <a href="subset_sum_problem" title="wikilink">subset sum</a> and <a href="Knapsack_problem" title="wikilink">knapsack</a> and <a href="Partition_problem" title="wikilink">partition</a> problems</li>
<li>The <a href="dynamic_time_warping" title="wikilink">dynamic time warping</a> algorithm for computing the global distance between two time series</li>
<li>The <a href="Patricia_Selinger" title="wikilink">Selinger</a> (a.k.a. <a href="IBM_System_R" title="wikilink">System R</a>) algorithm for relational database query optimization</li>
<li><a href="De_Boor_algorithm" title="wikilink">De Boor algorithm</a> for evaluating B-spline curves</li>
<li><a href="Duckworth–Lewis_method" title="wikilink">Duckworth–Lewis method</a> for resolving the problem when games of cricket are interrupted</li>
<li>The value iteration method for solving <a href="Markov_decision_process" title="wikilink">Markov decision processes</a></li>
<li>Some graphic image edge following selection methods such as the "magnet" selection tool in <a class="uri" href="Photoshop" title="wikilink">Photoshop</a></li>
<li>Some methods for solving <a href="interval_scheduling" title="wikilink">interval scheduling</a> problems</li>
<li>Some methods for solving the <a href="travelling_salesman_problem" title="wikilink">travelling salesman problem</a>, either exactly (in <a href="exponential_time" title="wikilink">exponential time</a>) or approximately (e.g. via the <a href="bitonic_tour" title="wikilink">bitonic tour</a>)</li>
<li><a href="Recursive_least_squares" title="wikilink">Recursive least squares</a> method</li>
<li><a href="Beat_(music)" title="wikilink">Beat</a> tracking in <a href="music_information_retrieval" title="wikilink">music information retrieval</a></li>
<li>Adaptive-critic training strategy for <a href="artificial_neural_networks" title="wikilink">artificial neural networks</a></li>
<li>Stereo algorithms for solving the <a href="correspondence_problem" title="wikilink">correspondence problem</a> used in stereo vision</li>
<li><a href="Seam_carving" title="wikilink">Seam carving</a> (content aware image resizing)</li>
<li>The <a href="Bellman–Ford_algorithm" title="wikilink">Bellman–Ford algorithm</a> for finding the shortest distance in a graph</li>
<li>Some approximate solution methods for the <a href="linear_search_problem" title="wikilink">linear search problem</a></li>
<li>Kadane's algorithm for the <a href="maximum_subarray_problem" title="wikilink">maximum subarray problem</a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Convexity_in_economics" title="wikilink">Convexity in economics</a></li>
<li><a href="Greedy_algorithm" title="wikilink">Greedy algorithm</a></li>
<li><a href="Non-convexity_(economics)" title="wikilink">Non-convexity (economics)</a></li>
<li><a href="Stochastic_programming" title="wikilink">Stochastic programming</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>

<p>. An accessible introduction to dynamic programming in economics. The link contains sample programs.</p></li>
<li>

<p>. Includes an extensive bibliography of the literature in the area, up to the year 1954.</p></li>
<li>

<p>. Dover paperback edition (2003), ISBN 0-486-42809-5.</p></li>
<li>

<p>. In two volumes.</p></li>
<li>

<p>. Especially pp. 323–69.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>S. S. Sritharan (1991), "Dynamic Programming of the Navier-Stokes Equations", <em>Systems and Control Letters</em>, 16(4), 299–307.</li>
<li>

<p>.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://20bits.com/articles/introduction-to-dynamic-programming/">An Introduction to Dynamic Programming</a></li>
<li><a href="http://apmonitor.com/do">Dynamic Optimization Online Course</a></li>
<li><a href="http://www.dyna.org">Dyna</a>, a declarative programming language for dynamic programming algorithms</li>
<li>Wagner, David B., 1995, "<a href="http://citeseer.ist.psu.edu/268391.html">Dynamic Programming.</a>" An introductory article on dynamic programming in <a class="uri" href="Mathematica" title="wikilink">Mathematica</a>.</li>
<li><a href="http://www.cse.ohio-state.edu/~gurari/course/cis680/cis680Ch21.html">Ohio State University: CIS 680: class notes on dynamic programming</a>, by Eitan M. Gurari</li>
<li><a href="http://mat.gsia.cmu.edu/classes/dynamic/dynamic.html">A Tutorial on Dynamic programming</a></li>
<li><a href="http://ocw.mit.edu/OcwWeb/Electrical-Engineering-and-Computer-Science/6-046JFall-2005/VideoLectures/detail/embed15.htm">MIT course on algorithms</a> – Includes a video lecture on DP along with lecture notes</li>
<li><a href="http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Dynamic">More DP Notes</a></li>
<li>King, Ian, 2002 (1987), "<a href="http://researchspace.auckland.ac.nz/bitstream/handle/2292/190/230.pdf">A Simple Introduction to Dynamic Programming in Macroeconomic Models.</a>" An introduction to dynamic programming as an important tool in economic theory.</li>
<li>[<a class="uri" href="http://www.topcoder.com/tc?module=Static&amp;d1">http://www.topcoder.com/tc?module=Static&amp;d1;</a>;=tutorials&amp;d2;=dynProg Dynamic Programming: from novice to advanced] A TopCoder.com article by Dumitru on Dynamic Programming</li>
<li><a href="http://bibiserv.techfak.uni-bielefeld.de/adp/">Algebraic Dynamic Programming</a> – a formalized framework for dynamic programming, including an <a href="http://bibiserv.techfak.uni-bielefeld.de/dpcourse">entry-level course</a> to DP, University of Bielefeld</li>
<li>Dreyfus, Stuart, "<a href="http://www.eng.tau.ac.il/~ami/cd/or50/1526-5463-2002-50-01-0048.pdf">Richard Bellman on the birth of Dynamic Programming.</a>"</li>
<li><a href="http://www.avatar.se/lectures/molbioinfo2001/dynprog/dynamic.html">Dynamic programming tutorial</a></li>
<li><a href="http://www.cambridge.org/resources/0521882672/7934_kaeslin_dynpro_new.pdf">A Gentle Introduction to Dynamic Programming and the Viterbi Algorithm</a></li>
<li>Tabled Prolog <a href="http://www.probp.com">BProlog</a> and <a href="http://xsb.sourceforge.net/">XSB</a></li>
<li><a href="http://ifors.org/tutorial/category/dynamic-programming/">Online interactive dynamic programming modules</a> including, shortest path, traveling salesman, knapsack, false coin, egg dropping, bridge and torch, replacement, chained matrix products, and critical path problem.</li>
</ul>

<p>"</p>

<p><a href="Category:Dynamic_programming" title="wikilink"> </a> <a href="Category:Mathematical_optimization" title="wikilink">Category:Mathematical optimization</a> <a href="Category:Optimization_algorithms_and_methods" title="wikilink">Category:Optimization algorithms and methods</a> <a class="uri" href="Category:Equations" title="wikilink">Category:Equations</a> <a href="Category:Systems_engineering" title="wikilink">Category:Systems engineering</a> <a href="Category:Optimal_control" title="wikilink">Category:Optimal control</a> <a href="Category:Operations_research" title="wikilink">Category:Operations research</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">S. Dasgupta, C.H. Papadimitriou, and U.V. Vazirani, <strong>'Algorithms</strong>', p 173, available at <a class="uri" href="http://www.cs.berkeley.edu/~vazirani/algorithms.html">http://www.cs.berkeley.edu/~vazirani/algorithms.html</a><a href="#fnref1">↩</a></li>
<li id="fn2">Cormen, T. H.; Leiserson, C. E.; Rivest, R. L.; Stein, C. (2001), Introduction to Algorithms (2nd ed.), MIT Press &amp; McGraw–Hill, ISBN 0-262-03293-7 . pp. 327–8.<a href="#fnref2">↩</a></li>
<li id="fn3">DeLisi, Biopolymers, 1974, Volume 13, Issue 7, pages 1511–1512, July 1974<a href="#fnref3">↩</a></li>
<li id="fn4">Gurskiĭ GV, Zasedatelev AS, Biofizika, 1978 Sep-Oct;23(5):932-46<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6">Stokey et al., 1989, Chap. 1<a href="#fnref6">↩</a></li>
<li id="fn7"> <a href="http://www.ifors.ms.unimelb.edu.au/tutorial/dijkstra_new/index.html">Online version of the paper with interactive computational modules.</a><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12">Konhauser J.D.E., Velleman, D., and Wagon, S. (1996). <a href="http://www.cambridge.org/uk/catalogue/catalogue.asp?isbn=9780883853252">Which way did the Bicycle Go?</a> Dolciani Mathematical Expositions – No 18. <a href="The_Mathematical_Association_of_America" title="wikilink">The Mathematical Association of America</a>.<a href="#fnref12">↩</a></li>
<li id="fn13">Sniedovich, M. (2003). <a href="http://archive.ite.journal.informs.org/Vol4No1/Sniedovich/index.php">The joy of egg-dropping in Braunschweig and Hong Kong</a>. INFORMS Transactions on Education, 4(1) 48–64.<a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a class="uri" href="http://www.wu-wien.ac.at/usr/h99c/h9951826/bellman_dynprog.pdf">http://www.wu-wien.ac.at/usr/h99c/h9951826/bellman_dynprog.pdf</a><a href="#fnref16">↩</a></li>
<li id="fn17">Eddy, S. R., What is dynamic programming?, Nature Biotechnology, 22, 909–910 (2004).<a href="#fnref17">↩</a></li>
<li id="fn18">Nocedal, J.; Wright, S. J.: Numerical Optimization, page 9, Springer, 2006..<a href="#fnref18">↩</a></li>
</ol>
</section>
</body>

