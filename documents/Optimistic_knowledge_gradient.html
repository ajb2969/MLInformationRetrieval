<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1871">Optimistic knowledge gradient</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Optimistic knowledge gradient</h1>
<hr/>

<p>In <a class="uri" href="statistics" title="wikilink">statistics</a> The <strong>optimistic knowledge gradient</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> is a new approximation policy proposed by Xi Chen, Qihang Lin and Dengyong Zhou in 2013. This policy is created to solve the challenge of computationally intractable of large size of <a href="optimal_computing_budget_allocation" title="wikilink">optimal computing budget allocation</a> problem in binary/multi-class crowd labeling where each label from the crowd has a certain cost.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="motivation">Motivation</h2>

<p>The <a href="optimal_computing_budget_allocation" title="wikilink">optimal computing budget allocation</a> problem is formulated as a Bayesian <a href="Markov_decision_process" title="wikilink">Markov decision process</a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a>(MDP) and is solved by using the <a href="dynamic_programming" title="wikilink">dynamic programming</a> (DP) algorithm where the Optimistic knowledge gradient policy is used to solve the computationally intractable of the <a href="dynamic_programming" title="wikilink">dynamic programming</a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> (DP) algorithm.</p>

<p>Consider a <strong>budget allocation issue</strong> in <a class="uri" href="crowdsourcing" title="wikilink">crowdsourcing</a>. The particular crowdsourcing problem we considering is crowd labeling. Crowd labeling is a large amount of <a class="uri" href="labeling" title="wikilink">labeling</a> tasks which are hard to solve by machine, turn out to easy to solve by human beings, then we just outsourced to an unidentified group of random people in a distributed environment.</p>
<h2 id="methodology">Methodology</h2>

<p>We want to finish this labeling tasks rely on the power of the crowd hopefully. For example, suppose we want to identify a picture according to the people in a picture is adult or not, this is a <a href="Bernoulli_distribution" title="wikilink">Bernoulli</a> labeling problem, and all of us can do in one or two seconds, this is a easy task for human being. However, if we have tens of thousands picture like this, then this is no longer the easy task any more. That's why we need to rely on <a class="uri" href="crowdsourcing" title="wikilink">crowdsourcing</a> framework to make this fast. <a class="uri" href="Crowdsourcing" title="wikilink">Crowdsourcing</a> framework of this consists of two steps. Step one, we just dynamically acquire from the crowd for items. On the other sides, this is dynamic procedure. We don't just send out this picture to everyone and we focus every response, instead, we do this in quantity. We are going to decide which picture we send it in the next, and which worker we are going to hire in the crowd in the next. According to his or her historical labeling results. And each picture can be send to multiple workers and every worker can also work on different pictures. Then after we collect enough number of labels for different picture, we go to the second steps where we want to infer true label of each picture based on the collected labels. So there are multiple ways we can do inference. For instance, the simplest we can do this is just majority vote. The problem is that no free lunch, we have to pays for worker for each label he or she provides and we only have a limited project budget. So the question is how to spend the limited budget in a smart way.</p>
<h2 id="challenging">Challenging</h2>

<p>Before show mathematic model, the paper mentions what kinds of challenging we are facing.</p>
<h3 id="challenging-1">challenging 1</h3>

<p>First of all, the items are very different difficult level to compute label, for example, go back the forward example, some picture are easily to classify, usually you will see very consistent label from the crowd. However, some ambiguous pictures, usually people disagree with each other, and label you receive highly inconsistent. So usually we spend more money on this ambiguous task.</p>
<h3 id="challenging-2">challenging 2</h3>

<p>And another difficulty we often have is that the worker are not perfect, sometimes this worker are not responsible, they just provide the <a class="uri" href="random" title="wikilink">random</a> label, therefore, of course, we would not spend our budget on this no reliable workers. Now the problem is both the difficulty of the pictures and the reliability of the worker we completely unknown at the beginning. We can only estimate them during the procedure. Therefore, we are naturally facing to exploration and exploitation, and our goal is to give a reasonable good policy to spend money to the right way–maximize the overall accuracy of final inferred labels.</p>
<h2 id="mathematical-model">Mathematical model</h2>

<p>For the mathematical model, we have the <em>K</em> items, 

<math display="inline" id="Optimistic_knowledge_gradient:0">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <set>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <ci>k</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=\{1,2,\ldots,k\}
  </annotation>
 </semantics>
</math>

, and total budget is <em>T</em> and we assume each label cost 1 so we are going to have <em>T</em> labels eventually. We assume each items has true label 

<math display="inline" id="Optimistic_knowledge_gradient:1">
 <semantics>
  <msub>
   <mi>Z</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Z</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{i}
  </annotation>
 </semantics>
</math>

which positive or negative, this binomial cases and we can extended to multiple class, labeling cases, this a singular idea. And the positive set 

<math display="inline" id="Optimistic_knowledge_gradient:2">
 <semantics>
  <msup>
   <mi>H</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>H</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{*}
  </annotation>
 </semantics>
</math>

 is defined as the set of items whose true label is positive. And 

<math display="inline" id="Optimistic_knowledge_gradient:3">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}
  </annotation>
 </semantics>
</math>

 also defined a soft-label, 

<math display="inline" id="Optimistic_knowledge_gradient:4">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}
  </annotation>
 </semantics>
</math>

 for each item which number between 0 and 1, and we define 

<math display="inline" id="Optimistic_knowledge_gradient:5">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}
  </annotation>
 </semantics>
</math>

 as underlying probability of being labeled as positive by a member randomly picked from a group of perfect workers.</p>

<p>In this first case, we assume for every worker is perfect, it means they all reliable, but being perfect doesn’t means this worker gives the same answer or right answer. It just means they will try their best to figure out the best answer in their mind, and suppose everyone is perfect worker, just randomly picked one of them, and with 

<math display="inline" id="Optimistic_knowledge_gradient:6">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}
  </annotation>
 </semantics>
</math>

 probability, we going to get a guy who believe this one is positive. That is how we explain 

<math display="inline" id="Optimistic_knowledge_gradient:7">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}
  </annotation>
 </semantics>
</math>

. So we are assume a label 

<math display="inline" id="Optimistic_knowledge_gradient:8">
 <semantics>
  <msub>
   <mi>Y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{i}
  </annotation>
 </semantics>
</math>

 is drawn from Bernoulli(

<math display="inline" id="Optimistic_knowledge_gradient:9">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}
  </annotation>
 </semantics>
</math>

), and 

<math display="inline" id="Optimistic_knowledge_gradient:10">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}
  </annotation>
 </semantics>
</math>

 must be consistent with the true label, which means 

<math display="inline" id="Optimistic_knowledge_gradient:11">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}
  </annotation>
 </semantics>
</math>

 is greater or equal to 0.5 if and only if this item is positive with a true positive label. So our goal is to learn H*, the set of positive items. In other word, we want to make an inferred positive set H based on collected labels to maximize:</p>

<p>

<math display="block" id="Optimistic_knowledge_gradient:12">
 <semantics>
  <mrow>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>k</mi>
   </munderover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <msub>
       <mtext>𝟏</mtext>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>i</mi>
        <mo>∈</mo>
        <mi>H</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msub>
      <msub>
       <mtext>𝟏</mtext>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>i</mi>
        <mo>∈</mo>
        <msup>
         <mi>H</mi>
         <mo>⋆</mo>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mtext>𝟏</mtext>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>i</mi>
        <mo>∉</mo>
        <mi>H</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msub>
      <msub>
       <mtext>𝟏</mtext>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>i</mi>
        <mo>∉</mo>
        <msup>
         <mi>H</mi>
         <mo>⋆</mo>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </msub>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>1</mtext>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">i</csymbol>
        <in></in>
        <csymbol cd="unknown">H</csymbol>
        <ci>normal-)</ci>
       </cerror>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>1</mtext>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">i</csymbol>
        <in></in>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>H</ci>
         <ci>normal-⋆</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>1</mtext>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">i</csymbol>
        <notin></notin>
        <csymbol cd="unknown">H</csymbol>
        <ci>normal-)</ci>
       </cerror>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>1</mtext>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">i</csymbol>
        <notin></notin>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>H</ci>
         <ci>normal-⋆</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{k}(\textbf{1}_{(i\in H)}\textbf{1}_{(i\in H^{\star})}+\textbf{1}_{%
(i\notin H)}\textbf{1}_{(i\notin H^{\star})})
  </annotation>
 </semantics>
</math>

</p>

<p>It can also be written as:</p>

<p>

<math display="block" id="Optimistic_knowledge_gradient:13">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>H</mi>
     <mo>∩</mo>
     <msup>
      <mi>H</mi>
      <mo>⋆</mo>
     </msup>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msup>
      <mi>H</mi>
      <mi>c</mi>
     </msup>
     <mo>∩</mo>
     <msup>
      <mi>H</mi>
      <mrow>
       <mi></mi>
       <mo>⋆</mo>
       <mi>c</mi>
      </mrow>
     </msup>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <abs></abs>
     <apply>
      <intersect></intersect>
      <ci>H</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <ci>normal-⋆</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <ci>c</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <apply>
        <ci>normal-⋆</ci>
        <csymbol cd="latexml">absent</csymbol>
        <ci>c</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |H\cap H^{\star}|+|H^{c}\cap H^{\star c}|
  </annotation>
 </semantics>
</math>

</p>
<h3 id="step1-bayesian-decision-process">step1: Bayesian decision process</h3>

<p>Before show the Bayesian framework, the paper use an example to mention why we choose Bayesian instead of frequency approach, such that we can propose some posterior of prior distribution on the soft-label 

<math display="inline" id="Optimistic_knowledge_gradient:14">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}
  </annotation>
 </semantics>
</math>

. We assume each 

<math display="inline" id="Optimistic_knowledge_gradient:15">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}
  </annotation>
 </semantics>
</math>

 is drawn from a known Beta prior: 

<math display="inline" id="Optimistic_knowledge_gradient:16">
 <semantics>
  <mrow>
   <msub>
    <mi>θ</mi>
    <mi>i</mi>
   </msub>
   <mo>∼</mo>
   <mrow>
    <mi>Beta</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>a</mi>
      <mi>i</mi>
      <mi>o</mi>
     </msubsup>
     <mo>,</mo>
     <msubsup>
      <mi>b</mi>
      <mi>i</mi>
      <mi>o</mi>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>Beta</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <ci>o</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>i</ci>
       </apply>
       <ci>o</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}\sim\mathrm{Beta}(a_{i}^{o},b_{i}^{o})
  </annotation>
 </semantics>
</math>

</p>

<p>And the matrix:</p>

<p>

<math display="block" id="Optimistic_knowledge_gradient:17">
 <semantics>
  <mrow>
   <msup>
    <mi>s</mi>
    <mi>o</mi>
   </msup>
   <mo>=</mo>
   <msubsup>
    <mrow>
     <mo>⟨</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msubsup>
       <mi>a</mi>
       <mi>i</mi>
       <mi>o</mi>
      </msubsup>
      <mo>,</mo>
      <msubsup>
       <mi>b</mi>
       <mi>i</mi>
       <mi>o</mi>
      </msubsup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⟩</mo>
    </mrow>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>k</mi>
   </msubsup>
   <mo>∈</mo>
   <msup>
    <mtext>𝐑</mtext>
    <mrow>
     <mi>k</mi>
     <mo>×</mo>
     <mn>2</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>o</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-⟨⟩</csymbol>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>a</ci>
           <ci>i</ci>
          </apply>
          <ci>o</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>b</ci>
           <ci>i</ci>
          </apply>
          <ci>o</ci>
         </apply>
        </interval>
       </apply>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <mtext>R</mtext>
      <apply>
       <times></times>
       <ci>k</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{o}=\left\langle(a_{i}^{o},b_{i}^{o})\right\rangle_{i=1}^{k}\in\textbf{R}^{k%
\times 2}
  </annotation>
 </semantics>
</math>

</p>

<p>So we know that the Bernoulli conjugate of beta, so once we get a new label for item i, we going to update posterior distribution, the beta distribution by:</p>

<p>

<math display="block" id="Optimistic_knowledge_gradient:18">
 <semantics>
  <mrow>
   <msub>
    <mi>θ</mi>
    <mi>i</mi>
   </msub>
   <mo>∼</mo>
   <mrow>
    <mi>Beta</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>a</mi>
      <mi>i</mi>
      <mi>t</mi>
     </msubsup>
     <mo>,</mo>
     <msubsup>
      <mi>b</mi>
      <mi>i</mi>
      <mi>t</mi>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>Beta</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}\sim\mathrm{Beta}(a_{i}^{t},b_{i}^{t})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Optimistic_knowledge_gradient:19">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>∣</mo>
   <msub>
    <mi>θ</mi>
    <mi>i</mi>
   </msub>
   <mo>∼</mo>
   <mi>Bernoulli</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>θ</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-∣</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <ci>i</ci>
    </apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <csymbol cd="unknown">Bernoulli</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}\mid\theta_{i}\sim\mathrm{Bernoulli}(\theta_{i})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Optimistic_knowledge_gradient:20">
 <semantics>
  <mrow>
   <msub>
    <mi>θ</mi>
    <mi>i</mi>
   </msub>
   <mo>∣</mo>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
   <mo>∼</mo>
   <mi>Beta</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>a</mi>
     <mi>i</mi>
     <mi>t</mi>
    </msubsup>
    <mo>+</mo>
    <mn>1</mn>
    <mo>,</mo>
    <msubsup>
     <mi>b</mi>
     <mi>i</mi>
     <mi>t</mi>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-∣</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <eq></eq>
    <cn type="integer">1</cn>
    <csymbol cd="latexml">similar-to</csymbol>
    <csymbol cd="unknown">Beta</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}\mid y_{i}=1\sim\mathrm{Beta}(a_{i}^{t}+1,b_{i}^{t})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Optimistic_knowledge_gradient:21">
 <semantics>
  <mrow>
   <msub>
    <mi>θ</mi>
    <mi>i</mi>
   </msub>
   <mo>∣</mo>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mo>-</mo>
   <mn>1</mn>
   <mo>∼</mo>
   <mi>Beta</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>a</mi>
     <mi>i</mi>
     <mi>t</mi>
    </msubsup>
    <mo>+</mo>
    <mn>1</mn>
    <mo>,</mo>
    <msubsup>
     <mi>b</mi>
     <mi>i</mi>
     <mi>t</mi>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-∣</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <eq></eq>
    <minus></minus>
    <cn type="integer">1</cn>
    <csymbol cd="latexml">similar-to</csymbol>
    <csymbol cd="unknown">Beta</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}\mid y_{i}=-1\sim\mathrm{Beta}(a_{i}^{t}+1,b_{i}^{t})
  </annotation>
 </semantics>
</math>

</p>

<p>Depending on the label is positive or negative.</p>

<p>Here is the whole procedure in the high level, we have T stage, 

<math display="inline" id="Optimistic_knowledge_gradient:22">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <mi>t</mi>
   <mo>≤</mo>
   <mrow>
    <mi>T</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>t</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <ci>T</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq t\leq T-1
  </annotation>
 </semantics>
</math>

. And in current stage we look at matrix S, which summarized the posterior distribution information for all the 

<math display="inline" id="Optimistic_knowledge_gradient:23">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Optimistic_knowledge_gradient:24">
 <semantics>
  <mrow>
   <msup>
    <mi>s</mi>
    <mi>t</mi>
   </msup>
   <mo>=</mo>
   <msubsup>
    <mrow>
     <mo>⟨</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msubsup>
       <mi>a</mi>
       <mi>i</mi>
       <mi>t</mi>
      </msubsup>
      <mo>,</mo>
      <msubsup>
       <mi>b</mi>
       <mi>i</mi>
       <mi>t</mi>
      </msubsup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⟩</mo>
    </mrow>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>k</mi>
   </msubsup>
   <mo>∈</mo>
   <msup>
    <mtext>𝐑</mtext>
    <mrow>
     <mi>k</mi>
     <mo>×</mo>
     <mn>2</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-⟨⟩</csymbol>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>a</ci>
           <ci>i</ci>
          </apply>
          <ci>t</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>b</ci>
           <ci>i</ci>
          </apply>
          <ci>t</ci>
         </apply>
        </interval>
       </apply>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <mtext>R</mtext>
      <apply>
       <times></times>
       <ci>k</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{t}=\left\langle(a_{i}^{t},b_{i}^{t})\right\rangle_{i=1}^{k}\in\textbf{R}^{k%
\times 2}
  </annotation>
 </semantics>
</math>

</p>

<p>We are going to make a decision, choose the next item to label 

<math display="inline" id="Optimistic_knowledge_gradient:25">
 <semantics>
  <msub>
   <mi>i</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>i</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i_{t}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Optimistic_knowledge_gradient:26">
 <semantics>
  <mrow>
   <msub>
    <mi>i</mi>
    <mi>t</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>i</ci>
     <ci>t</ci>
    </apply>
    <set>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <ci>k</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i_{t}\in\{1,2,\ldots,k\}
  </annotation>
 </semantics>
</math>

.</p>

<p>And depending what the label is positive or negative, we add a matrix to getting a label:</p>

<p>

<math display="block" id="Optimistic_knowledge_gradient:27">
 <semantics>
  <mrow>
   <msub>
    <mi>θ</mi>
    <mi>i</mi>
   </msub>
   <mo>∼</mo>
   <mrow>
    <mi>Beta</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>a</mi>
      <mi>i</mi>
      <mi>t</mi>
     </msubsup>
     <mo>,</mo>
     <msubsup>
      <mi>b</mi>
      <mi>i</mi>
      <mi>t</mi>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>Beta</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}\sim\mathrm{Beta}(a_{i}^{t},b_{i}^{t})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Optimistic_knowledge_gradient:28">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>∣</mo>
   <msub>
    <mi>θ</mi>
    <mi>i</mi>
   </msub>
   <mo>∼</mo>
   <mi>Bernoulli</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>θ</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-∣</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <ci>i</ci>
    </apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <csymbol cd="unknown">Bernoulli</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}\mid\theta_{i}\sim\mathrm{Bernoulli}(\theta_{i})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Optimistic_knowledge_gradient:29">
 <semantics>
  <mrow>
   <msub>
    <mi>θ</mi>
    <mi>i</mi>
   </msub>
   <mo>∣</mo>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
   <mo>∼</mo>
   <mi>Beta</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>a</mi>
     <mi>i</mi>
     <mi>t</mi>
    </msubsup>
    <mo>+</mo>
    <mn>1</mn>
    <mo>,</mo>
    <msubsup>
     <mi>b</mi>
     <mi>i</mi>
     <mi>t</mi>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-∣</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <eq></eq>
    <cn type="integer">1</cn>
    <csymbol cd="latexml">similar-to</csymbol>
    <csymbol cd="unknown">Beta</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}\mid y_{i}=1\sim\mathrm{Beta}(a_{i}^{t}+1,b_{i}^{t})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Optimistic_knowledge_gradient:30">
 <semantics>
  <mrow>
   <msub>
    <mi>θ</mi>
    <mi>i</mi>
   </msub>
   <mo>∣</mo>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mo>-</mo>
   <mn>1</mn>
   <mo>∼</mo>
   <mi>Beta</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>a</mi>
     <mi>i</mi>
     <mi>t</mi>
    </msubsup>
    <mo>+</mo>
    <mn>1</mn>
    <mo>,</mo>
    <msubsup>
     <mi>b</mi>
     <mi>i</mi>
     <mi>t</mi>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-∣</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <eq></eq>
    <minus></minus>
    <cn type="integer">1</cn>
    <csymbol cd="latexml">similar-to</csymbol>
    <csymbol cd="unknown">Beta</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}\mid y_{i}=-1\sim\mathrm{Beta}(a_{i}^{t}+1,b_{i}^{t})
  </annotation>
 </semantics>
</math>

</p>

<p>Above all, this is the whole framework.</p>
<h3 id="step2-inference-on-positive-set">step2: Inference on positive set</h3>

<p>When the <em>t</em> labels are collected, we can make an inference about the positive set <em>H</em><sub><em>t</em></sub> based on posterior distribution given by <em>S</em><sub><em>t</em></sub></p>

<p>

<math display="inline" id="Optimistic_knowledge_gradient:31">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle H_{t}
  </annotation>
 </semantics>
</math>


</p>

<p>So here become the Bernoulli selection problem, we just take to look at the probability of being positive or being negative conditional 

<math display="inline" id="Optimistic_knowledge_gradient:32">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{t}
  </annotation>
 </semantics>
</math>


 to see is greater than 0.5 or not, if it is greater than 0.5, then we prove this item into the current infer positive set 

<math display="inline" id="Optimistic_knowledge_gradient:33">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{t}
  </annotation>
 </semantics>
</math>

 so this is a cost form for current optimal solution 

<math display="inline" id="Optimistic_knowledge_gradient:34">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{t}
  </annotation>
 </semantics>
</math>

 based on the information in 

<math display="inline" id="Optimistic_knowledge_gradient:35">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{t}
  </annotation>
 </semantics>
</math>

.</p>

<p>After know what is optimal solution, then the paper show what is the optimal value. Plug 

<math display="inline" id="Optimistic_knowledge_gradient:36">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 in the optimal function,</p>

<p>

<math display="block" id="Optimistic_knowledge_gradient:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>max</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <max></max>
     <ci>x</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x)=\max(x,1-x)
  </annotation>
 </semantics>
</math>

</p>

<p>This function is just a single function which choose the larger one between the conditional probability of being positive and being negative. Once we get one more label for item i, we take a difference between this value, before and after we get a new label, we can see this conditional probability can actually simplify as follows:</p>

<p>

<math display="inline" id="Optimistic_knowledge_gradient:38">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>s</mi>
     <mi>t</mi>
    </msup>
    <mo>,</mo>
    <msub>
     <mi>i</mi>
     <mi>t</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <msub>
      <mi>i</mi>
      <mi>t</mi>
     </msub>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>i</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>i</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle R(s^{t},i_{t},y_{i_{t}})
  </annotation>
 </semantics>
</math>


</p>

<p>The positive item being positive only depends on the beta posterior, therefore, if only the function of parameter of beta distribution function are <em>a</em> and <em>b</em>, as</p>

<p>

<math display="block" id="Optimistic_knowledge_gradient:39">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>Pr</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msubsup>
        <mi>a</mi>
        <msub>
         <mi>i</mi>
         <mi>t</mi>
        </msub>
        <mrow>
         <mi>t</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msubsup>
       <mo>,</mo>
       <msubsup>
        <mi>b</mi>
        <msub>
         <mi>i</mi>
         <mi>t</mi>
        </msub>
        <mrow>
         <mi>t</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msubsup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>Pr</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msubsup>
        <mi>a</mi>
        <msub>
         <mi>i</mi>
         <mi>t</mi>
        </msub>
        <mi>t</mi>
       </msubsup>
       <mo>,</mo>
       <msubsup>
        <mi>b</mi>
        <msub>
         <mi>i</mi>
         <mi>t</mi>
        </msub>
        <mi>t</mi>
       </msubsup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>h</ci>
     <apply>
      <ci>Pr</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>i</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>i</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>h</ci>
     <apply>
      <ci>Pr</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>i</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>i</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(\Pr(a_{i_{t}}^{t+1},b_{i_{t}}^{t+1}))-h(\Pr(a_{i_{t}}^{t},b_{i_{t}}^{t}))
  </annotation>
 </semantics>
</math>

</p>

<p>One more label for this particular item, we double change the posterior function, so all of this items can be cancel except 1, so this is the change for whole accuracy and we defined as stage-wise reward: improvement the inference accuracy by one more sample. Of course this label have two positive value, we’ve get positive label or negative label, take average for this two, get expect reward. We just choose item to be label such that the expect reward is maximized using <strong>Knowledge Gradient</strong>:</p>

<p>

<math display="inline" id="Optimistic_knowledge_gradient:40">
 <semantics>
  <msub>
   <mi>i</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>i</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle i_{t}
  </annotation>
 </semantics>
</math>


</p>

<p>They are multiple items, let us know how do we break the ties. If we break the tie deterministically, which means we choose the smallest index. We are going to have a problem because this is not consistent which means the positive stage 

<math display="inline" id="Optimistic_knowledge_gradient:41">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{t}
  </annotation>
 </semantics>
</math>

 does not converge to the true positive stage 

<math display="inline" id="Optimistic_knowledge_gradient:42">
 <semantics>
  <msup>
   <mi>H</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>H</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{*}
  </annotation>
 </semantics>
</math>

.</p>

<p>So we can also try to break the ties randomly, it works, however, we will see the performance is almost like uniform sampling, is the best reward. The writer’s policy is kinds of more greedy, instead of choosing the average in stage once reward, we can actually calculate the larger one, the max of the two stage possible reward, so <strong>Optimistic Knowledge Gradient</strong>:</p>

<p>

<math display="block" id="Optimistic_knowledge_gradient:43">
 <semantics>
  <mrow>
   <msub>
    <mi>i</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo movablelimits="false">argmax</mo>
     <mrow>
      <mi>i</mi>
      <mo>∈</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mn>1</mn>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <mi>k</mi>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
    </munder>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>R</mi>
       <mo>+</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>S</mi>
        <mi>t</mi>
       </msup>
       <mo>,</mo>
       <mi>i</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>max</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>S</mi>
        <mi>t</mi>
       </msup>
       <mo>,</mo>
       <mi>i</mi>
       <mo>,</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>S</mi>
        <mi>t</mi>
       </msup>
       <mo>,</mo>
       <mi>i</mi>
       <mo>,</mo>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>i</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>argmax</ci>
       <apply>
        <in></in>
        <ci>i</ci>
        <set>
         <cn type="integer">1</cn>
         <ci>normal-…</ci>
         <ci>k</ci>
        </set>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>R</ci>
        <plus></plus>
       </apply>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>S</ci>
         <ci>t</ci>
        </apply>
        <ci>i</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <max></max>
      <apply>
       <times></times>
       <ci>R</ci>
       <vector>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>S</ci>
         <ci>t</ci>
        </apply>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </vector>
      </apply>
      <apply>
       <times></times>
       <ci>R</ci>
       <vector>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>S</ci>
         <ci>t</ci>
        </apply>
        <ci>i</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </vector>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i_{t}=\operatorname{argmax}\limits_{i\in\{1,\ldots,k\}}(R^{+}(S^{t},i))=\max(R%
(S^{t},i,1),R(S^{t},i,-1))
  </annotation>
 </semantics>
</math>

</p>

<p>And we know under optimistic knowledge gradient, the final inference accuracy converge to 100%. Above is based on every worker is perfect, however, in practice, workers are not always responsible. So if in imperfect workers, we assume K items, 

<math display="inline" id="Optimistic_knowledge_gradient:44">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>i</mi>
   <mo>≤</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq i\leq k
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Optimistic_knowledge_gradient:45">
 <semantics>
  <mrow>
   <msub>
    <mi>θ</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∼</mo>
   <mrow>
    <mi>Bet</mi>
    <mi>a</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>a</mi>
      <mi>i</mi>
      <mi>o</mi>
     </msubsup>
     <mo>,</mo>
     <msubsup>
      <mi>b</mi>
      <mi>i</mi>
      <mi>o</mi>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>i</ci>
     </apply>
     <interval closure="open">
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">similar-to</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>Bet</ci>
      <ci>a</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>i</ci>
        </apply>
        <ci>o</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <ci>i</ci>
        </apply>
        <ci>o</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}\in(0,1)\sim\mathrm{Bet}a(a_{i}^{o},b_{i}^{o})
  </annotation>
 </semantics>
</math>

</p>

<p>The probability of item 

<math display="inline" id="Optimistic_knowledge_gradient:46">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 being labeled as positive by a perfect worker. M workers, 

<math display="inline" id="Optimistic_knowledge_gradient:47">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>j</mi>
   <mo>≤</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>j</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq j\leq M
  </annotation>
 </semantics>
</math>

 , 

<math display="inline" id="Optimistic_knowledge_gradient:48">
 <semantics>
  <mrow>
   <msub>
    <mi>ρ</mi>
    <mi>j</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∼</mo>
   <mrow>
    <mi>Beta</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>c</mi>
      <mi>j</mi>
      <mi>o</mi>
     </msubsup>
     <mo>,</mo>
     <msubsup>
      <mi>d</mi>
      <mi>j</mi>
      <mi>o</mi>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <ci>j</ci>
     </apply>
     <interval closure="open">
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">similar-to</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>Beta</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>c</ci>
         <ci>j</ci>
        </apply>
        <ci>o</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>d</ci>
         <ci>j</ci>
        </apply>
        <ci>o</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{j}\in(0,1)\sim\mathrm{Beta}(c_{j}^{o},d_{j}^{o})
  </annotation>
 </semantics>
</math>

 The probability of worker 

<math display="inline" id="Optimistic_knowledge_gradient:49">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 giving the same label as a perfect worker. Distribution of the label 

<math display="inline" id="Optimistic_knowledge_gradient:50">
 <semantics>
  <msub>
   <mi>Z</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Z</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{ij}
  </annotation>
 </semantics>
</math>

 from worker 

<math display="inline" id="Optimistic_knowledge_gradient:51">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 to item 

<math display="inline" id="Optimistic_knowledge_gradient:52">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Optimistic_knowledge_gradient:53">
 <semantics>
  <mrow>
   <mrow>
    <mi>Pr</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>Z</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mo>∣</mo>
     <msub>
      <mi>θ</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>ρ</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>Pr</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>Z</mi>
         <mrow>
          <mi>i</mi>
          <mi>j</mi>
         </mrow>
        </msub>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mo>∣</mo>
       <mrow>
        <msub>
         <mi>Y</mi>
         <mi>i</mi>
        </msub>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>Pr</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>Y</mi>
         <mi>i</mi>
        </msub>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mi>Pr</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>Z</mi>
         <mrow>
          <mi>i</mi>
          <mi>j</mi>
         </mrow>
        </msub>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mo>∣</mo>
       <mrow>
        <msub>
         <mi>Y</mi>
         <mi>i</mi>
        </msub>
        <mo>=</mo>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>Pr</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>Y</mi>
         <mi>i</mi>
        </msub>
        <mo>=</mo>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>ρ</mi>
     <mi>j</mi>
    </msub>
    <msub>
     <mi>θ</mi>
     <mi>i</mi>
    </msub>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <msub>
       <mi>ρ</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <msub>
       <mi>θ</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>Pr</ci>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Z</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ρ</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <ci>Pr</ci>
        <apply>
         <eq></eq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Z</ci>
          <apply>
           <times></times>
           <ci>i</ci>
           <ci>j</ci>
          </apply>
         </apply>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <eq></eq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Y</ci>
          <ci>i</ci>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <ci>Pr</ci>
        <apply>
         <eq></eq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Y</ci>
          <ci>i</ci>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>Pr</ci>
        <apply>
         <eq></eq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Z</ci>
          <apply>
           <times></times>
           <ci>i</ci>
           <ci>j</ci>
          </apply>
         </apply>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <eq></eq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Y</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <ci>Pr</ci>
        <apply>
         <eq></eq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Y</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ρ</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ρ</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr(Z_{ij}=1\mid\theta_{i},\rho_{j})=\Pr(Z_{ij}=1\mid Y_{i}=1)\Pr(Y_{i}=1)+\Pr%
(Z_{ij}=1\mid Y_{i}=-1)\Pr(Y_{i}=-1)=\rho_{j}\theta_{i}t(1-\rho_{j})(1-\theta_%
{i})
  </annotation>
 </semantics>
</math>

</p>

<p>And the action space is that</p>

<p>

<math display="block" id="Optimistic_knowledge_gradient:54">
 <semantics>
  <mrow>
   <mi>Pr</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Z</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mn>1</mn>
    <mo>∣</mo>
    <msub>
     <mi>θ</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>ρ</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Z</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mn>1</mn>
    <mo>∣</mo>
    <msub>
     <mi>Y</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>Pr</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Y</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>Pr</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Z</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mn>1</mn>
    <mo>∣</mo>
    <msub>
     <mi>Y</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mo>-</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>Pr</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Y</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mo>-</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>ρ</mi>
    <mi>j</mi>
   </msub>
   <msub>
    <mi>θ</mi>
    <mi>i</mi>
   </msub>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>-</mo>
    <msub>
     <mi>ρ</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>-</mo>
    <msub>
     <mi>θ</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>ρ</mi>
    <mi>j</mi>
   </msub>
   <msub>
    <mi>θ</mi>
    <mi>i</mi>
   </msub>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>-</mo>
    <msub>
     <mi>ρ</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>-</mo>
    <msub>
     <mi>θ</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>Pr</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <ci>i</ci>
     </apply>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <ci>Pr</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <ci>i</ci>
     </apply>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <ci>Pr</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <ci>i</ci>
     </apply>
     <eq></eq>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <ci>Pr</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <ci>i</ci>
     </apply>
     <eq></eq>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ρ</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <ci>i</ci>
    </apply>
    <csymbol cd="unknown">t</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">1</cn>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">1</cn>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ρ</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <ci>i</ci>
    </apply>
    <csymbol cd="unknown">t</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">1</cn>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">1</cn>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr(Z_{ij}=1\mid\theta_{i},\rho_{j})=Pr(Z_{ij}=1\mid Y_{i}=1)\Pr(Y_{i}=1)+\Pr(%
Z_{ij}=1\mid Y_{i}=-1)\Pr(Y_{i}=-1)=\rho_{j}\theta_{i}t(1-\rho_{j})(1-\theta_{%
i})=\rho_{j}\theta_{i}t(1-\rho_{j})(1-\theta_{i}),
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Optimistic_knowledge_gradient:55">
 <semantics>
  <mrow>
   <mrow>
    <mo lspace="42.5pt" stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>k</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>×</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>M</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>i</ci>
     <ci>j</ci>
    </interval>
    <apply>
     <times></times>
     <set>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
      <ci>normal-…</ci>
      <ci>k</ci>
     </set>
     <set>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
      <ci>normal-…</ci>
      <ci>M</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \qquad\qquad(i,j)\in\{1,2,\ldots,k\}\times\{1,2,\ldots,M\}
  </annotation>
 </semantics>
</math>

, label matrix

<math display="block" id="Optimistic_knowledge_gradient:56">
 <semantics>
  <mrow>
   <msub>
    <mi>Z</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Z</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <set>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{ij}\in\{-1,1\}
  </annotation>
 </semantics>
</math>

</p>

<p>It is difficult to calculate, so we can use <a href="Variational_Bayesian_methods" title="wikilink">Variational Bayesian methods</a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> of 

<math display="inline" id="Optimistic_knowledge_gradient:57">
 <semantics>
  <mrow>
   <mi>Pr</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>i</mi>
     <mo>∈</mo>
     <msup>
      <mi>H</mi>
      <mo>⋆</mo>
     </msup>
    </mrow>
    <mo>∣</mo>
    <msup>
     <mi>S</mi>
     <mi>t</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>Pr</ci>
    <apply>
     <in></in>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <ci>normal-⋆</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr(i\in H^{\star}\mid S^{t})
  </annotation>
 </semantics>
</math>

</p>
<h2 id="references">References</h2>

<p>"</p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.jmlr.org/papers/volume16/chen15a/chen15a.pdf">1</a> Statistical Decision Making for Optimal Budget Allocation in Crowd Labeling Xi Chen, Qihang Lin, Dengyong Zhou; 16(Jan):1−46, 2015.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="https://www.cs.cmu.edu/~xichen/images/ICML_Crowd_Budget.pdf">2</a> Proceedings of the 30-th International Conference on Machine Learning, Atlanta, Georgia, USA, 2013. JMLR:W&amp;CP; volume 28. Xi Chen, Qihang Lin, Dengyong Zhou<a href="#fnref2">↩</a></li>
<li id="fn3">*<a href="http://www.eecs.umich.edu/~baveja/Papers/Thesis.ps.gz">Learning to Solve Markovian Decision Processes</a> by <a href="http://www.eecs.umich.edu/~baveja/">Satinder P. Singh</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="http://20bits.com/articles/introduction-to-dynamic-programming/">An Introduction to Dynamic Programming</a><a href="#fnref4">↩</a></li>
<li id="fn5">* <a href="http://www.gatsby.ucl.ac.uk/vbayes/">Variational-Bayes Repository</a> A repository of papers, software, and links related to the use of variational methods for approximate Bayesian learning<a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
