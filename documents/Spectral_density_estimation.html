<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="148">Spectral density estimation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Spectral density estimation</h1>
<hr/>

<p>In <a href="statistical_signal_processing" title="wikilink">statistical signal processing</a>, the goal of <strong>spectral density estimation</strong> (SDE) is to <a href="estimation_theory" title="wikilink">estimate</a> the <a href="spectral_density" title="wikilink">spectral density</a> (also known as the <a href="power_spectrum" title="wikilink">power spectral density</a>) of a <a href="random_signal" title="wikilink">random signal</a> from a sequence of time samples of the signal. Intuitively speaking, the spectral density characterizes the <a class="uri" href="frequency" title="wikilink">frequency</a> content of the signal. One purpose of estimating the spectral density is to detect any <a href="Periodic_function" title="wikilink">periodicities</a> in the data, by observing peaks at the frequencies corresponding to these periodicities.</p>

<p>SDE should be distinguished from the field of <em>frequency estimation</em>, which assumes that a signal is composed of a limited (usually small) number of generating frequencies plus noise and seeks to find the location and intensity of the generated frequencies. SDE makes no assumption on the number of components and seeks to estimate the whole generating spectrum.</p>
<h2 id="overview">Overview</h2>

<p> </p>

<p><strong>Spectrum analysis</strong>, also referred to as <a href="frequency_domain" title="wikilink">frequency domain analysis</a> or spectral density estimation, is the technical process of decomposing a complex signal into simpler parts. As described above, many physical processes are best described as a sum of many individual frequency components. Any process that quantifies the various amounts (e.g. amplitudes, powers, intensities, or phases), versus frequency can be called <strong>spectrum analysis</strong>.</p>

<p>Spectrum analysis can be performed on the entire signal. Alternatively, a signal can be broken into short segments (sometimes called <em>frames</em>), and spectrum analysis may be applied to these individual segments. <a href="Periodic_function" title="wikilink">Periodic functions</a> (such as 

<math display="inline" id="Spectral_density_estimation:0">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi>i</mi>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>i</ci>
    <ci>n</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   sin(t)
  </annotation>
 </semantics>
</math>

) are particularly well-suited for this sub-division. General mathematical techniques for analyzing non-periodic functions fall into the category of <a href="Fourier_analysis" title="wikilink">Fourier analysis</a>.</p>

<p>The <a href="Fourier_transform" title="wikilink">Fourier transform</a> of a function produces a frequency spectrum which contains all of the information about the original signal, but in a different form. This means that the original function can be completely reconstructed (<em>synthesized</em>) by an <a href="inverse_Fourier_transform" title="wikilink">inverse Fourier transform</a>. For perfect reconstruction, the spectrum analyzer must preserve both the <a class="uri" href="amplitude" title="wikilink">amplitude</a> and <a href="Phase_(waves)" title="wikilink">phase</a> of each frequency component. These two pieces of information can be represented as a 2-dimensional vector, as a <a href="complex_number" title="wikilink">complex number</a>, or as magnitude (amplitude) and phase in <a href="polar_coordinates" title="wikilink">polar coordinates</a> (i.e., as a <a class="uri" href="phasor" title="wikilink">phasor</a>). A common technique in signal processing is to consider the squared amplitude, or <a href="power_(physics)" title="wikilink">power</a>; in this case the resulting plot is referred to as a <a href="power_spectrum" title="wikilink">power spectrum</a>.</p>

<p>In practice, nearly all software and electronic devices that generate frequency spectra apply a <a href="fast_Fourier_transform" title="wikilink">fast Fourier transform</a> (FFT), which is a specific mathematical approximation to the full integral solution. Formally stated, the FFT is a method for computing the <a href="discrete_Fourier_transform" title="wikilink">discrete Fourier transform</a> of a <a href="Sampling_(signal_processing)" title="wikilink">sampled signal</a>.</p>

<p>Because of reversibility, the Fourier transform is called a <em>representation</em> of the function, in terms of frequency instead of time; thus, it is a <a href="frequency_domain" title="wikilink">frequency domain</a> representation. Linear operations that could be performed in the time domain have counterparts that can often be performed more easily in the frequency domain. Frequency analysis also simplifies the understanding and interpretation of the effects of various time-domain operations, both linear and non-linear. For instance, only <a href="nonlinearity" title="wikilink">non-linear</a> or <a href="Time-variant_system" title="wikilink">time-variant</a> operations can create new frequencies in the frequency spectrum.</p>

<p>The Fourier transform of a <em><a class="uri" href="stochastic" title="wikilink">stochastic</a></em> (random) waveform (<a class="uri" href="noise" title="wikilink">noise</a>) is also random. Some kind of averaging is required in order to create a clear picture of the underlying frequency content (<a href="frequency_distribution" title="wikilink">frequency distribution</a>). Typically, the data is divided into time-segments of a chosen duration, and transforms are performed on each one. Then the magnitude or (usually) squared-magnitude components of the transforms are summed into an average transform. This is a very common operation performed on <a href="sampling_(signal_processing)" title="wikilink">digitally sampled</a> time-domain data, using the <a href="discrete_Fourier_transform" title="wikilink">discrete Fourier transform</a>. This type of processing is called <a href="Welch's_method" title="wikilink">Welch's method</a>. When the result is flat, it is commonly referred to as <a href="white_noise" title="wikilink">white noise</a>. However, such processing techniques often reveal spectral content even among data which appears noisy in the time domain.</p>
<h2 id="periodogram">Periodogram</h2>

<p>Suppose that a signal is sampled at 

<math display="inline" id="Spectral_density_estimation:1">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 different times, with the samples uniformly spaced by 

<math display="inline" id="Spectral_density_estimation:2">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta t
  </annotation>
 </semantics>
</math>

, giving values 

<math display="inline" id="Spectral_density_estimation:3">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}
  </annotation>
 </semantics>
</math>

. Since the power spectral density of a continuous function defined on the entire real line is the modulus squared of its <a href="Fourier_transform" title="wikilink">Fourier transform</a>, the simplest technique to estimate the spectrum is the <em>periodogram</em>, given by the modulus squared of the <a href="discrete_Fourier_transform" title="wikilink">discrete Fourier transform</a>,</p>

<p>

<math display="block" id="Spectral_density_estimation:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>t</mi>
      </mrow>
      <mi>N</mi>
     </mfrac>
     <msup>
      <mrow>
       <mo>|</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>n</mi>
          <mo>=</mo>
          <mn>0</mn>
         </mrow>
         <mrow>
          <mi>N</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </munderover>
        <mrow>
         <msub>
          <mi>x</mi>
          <mi>n</mi>
         </msub>
         <msup>
          <mi>e</mi>
          <mrow>
           <mo>-</mo>
           <mrow>
            <mi>i</mi>
            <mn>2</mn>
            <mi>π</mi>
            <mi>n</mi>
            <mi>f</mi>
           </mrow>
          </mrow>
         </msup>
        </mrow>
       </mrow>
       <mo>|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mn>2</mn>
       <mi mathvariant="normal">Δ</mi>
       <mi>t</mi>
      </mrow>
     </mfrac>
    </mrow>
    <mo><</mo>
    <mi>f</mi>
    <mo>≤</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <mi mathvariant="normal">Δ</mi>
      <mi>t</mi>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>t</ci>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>n</ci>
            <cn type="integer">0</cn>
           </apply>
          </apply>
          <apply>
           <minus></minus>
           <ci>N</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>n</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>e</ci>
           <apply>
            <minus></minus>
            <apply>
             <times></times>
             <ci>i</ci>
             <cn type="integer">2</cn>
             <ci>π</ci>
             <ci>n</ci>
             <ci>f</ci>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <lt></lt>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>normal-Δ</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <ci>f</ci>
     </apply>
     <apply>
      <leq></leq>
      <share href="#.cmml">
      </share>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>normal-Δ</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(f)=\frac{\Delta t}{N}\left|\sum_{n=0}^{N-1}x_{n}e^{-i2\pi nf}\right|^{2},%
\qquad-\frac{1}{2\Delta t}<f\leq\frac{1}{2\Delta t}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Spectral_density_estimation:5">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>2</mn>
     <mi mathvariant="normal">Δ</mi>
     <mi>t</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/(2\Delta t)
  </annotation>
 </semantics>
</math>

 is the <a href="Nyquist_frequency" title="wikilink">Nyquist frequency</a>. The name "periodogram" was coined by <a href="Arthur_Schuster" title="wikilink">Arthur Schuster</a> in 1898.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Despite the simplicity of the periodogram, the method suffers from severe deficiencies. It is an <a href="inconsistent_estimator" title="wikilink">inconsistent estimator</a> because it does not converge to the true spectral density as 

<math display="inline" id="Spectral_density_estimation:6">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>N</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\rightarrow\infty
  </annotation>
 </semantics>
</math>

. It exhibits very high <a href="spectral_leakage" title="wikilink">spectral leakage</a> although this can be reduced by multiplying 

<math display="inline" id="Spectral_density_estimation:7">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}
  </annotation>
 </semantics>
</math>

 by a <a href="window_function" title="wikilink">window function</a>. In the presence of additive noise, the estimate has a positive bias.</p>
<h2 id="techniques">Techniques</h2>

<p>Many different techniques for spectral estimation have been developed to overcome the problems of the naive periodogram. These techniques can generally be divided into <em><a href="non-parametric_statistics" title="wikilink">non-parametric</a></em> and <em><a href="parametric_estimation" title="wikilink">parametric</a></em> methods. The non-parametric approaches explicitly estimate the <a class="uri" href="covariance" title="wikilink">covariance</a> or the spectrum of the process without assuming that the process has any particular structure. The periodogram itself is a non-parametric approach, and is essentially equivalent to the Fourier transform of the biased <a class="uri" href="autocovariance" title="wikilink">autocovariance</a> convolved with a <a href="Fejér_kernel" title="wikilink">Fejér kernel</a>. Some of the most common estimators in use for basic applications (e.g. <a href="Welch's_method" title="wikilink">Welch's method</a>) are non-parametric estimators closely related to the periodogram. By contrast, the parametric approaches assume that the underlying <a href="stationary_process" title="wikilink">stationary stochastic process</a> has a certain structure which can be described using a small number of parameters (for example, using an <a href="Autoregressive_moving_average_model" title="wikilink">auto-regressive or moving average model</a>). In these approaches, the task is to estimate the parameters of the model that describes the stochastic process.</p>

<p>Following is a partial list of non-parametric spectral density estimation techniques:</p>
<ul>
<li>Periodogram, the basic modulus-squared of the discrete Fourier transform</li>
<li><a href="Bartlett's_method" title="wikilink">Bartlett's method</a> is the average of the periodograms taken of multiple segments of the signal to reduce variance of the spectral density estimate</li>
<li><a href="Welch's_method" title="wikilink">Welch's method</a> a windowed version of Bartlett's method that uses overlapping segments</li>
<li><a class="uri" href="Multitaper" title="wikilink">Multitaper</a> is a periodogram-based method that uses multiple tapers, or windows, to form independent estimates of the spectral density to reduce variance of the spectral density estimate</li>
<li><a href="Least-squares_spectral_analysis" title="wikilink">Least-squares spectral analysis</a>, based on <a href="least_squares" title="wikilink">least squares</a> fitting to known frequencies</li>
<li><a href="Non-uniform_discrete_Fourier_transform" title="wikilink">Non-uniform discrete Fourier transform</a> is used when the signal samples are <a href="unevenly_spaced_time_series" title="wikilink">unevenly spaced in time</a></li>
<li><a href="Singular_spectrum_analysis" title="wikilink">Singular spectrum analysis</a> is a nonparametric method that uses a <a href="singular_value_decomposition" title="wikilink">singular value decomposition</a> of the <a href="covariance_matrix" title="wikilink">covariance matrix</a> to estimate the spectral density</li>
<li><a href="Short-time_Fourier_transform" title="wikilink">Short-time Fourier transform</a></li>
</ul>

<p>Below is a partial list of parametric techniques:</p>
<ul>
<li><a href="Autoregressive_model" title="wikilink">Autoregressive model</a> (AR) estimation, which assumes that the <em>n</em>th sample is correlated with the previous <em>p</em> samples.</li>
<li><a href="Moving-average_model" title="wikilink">Moving-average model</a> (MA) estimation, which assumes that the <em>n</em>th sample is correlated with noise terms in the previous <em>p</em> samples.</li>
<li><a href="Autoregressive_moving_average" title="wikilink">Autoregressive moving average</a> (ARMA) estimation, which generalizes the AR and MA models.</li>
<li><a href="Maximum_entropy_spectral_estimation" title="wikilink">Maximum entropy spectral estimation</a> is an <em>all-poles</em> method useful for SDE when singular spectral features, such as sharp peaks, are expected.</li>
</ul>
<h2 id="parametric-estimation">Parametric estimation</h2>

<p>In parametric spectral estimation, one assumes that the signal is modeled by a <a href="stationary_process" title="wikilink">stationary process</a> which has a spectral density function (SDF) 

<math display="inline" id="Spectral_density_estimation:8">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo>;</mo>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mi>p</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <list>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>p</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(f;a_{1},\ldots,a_{p})
  </annotation>
 </semantics>
</math>

 that is a function of the frequency 

<math display="inline" id="Spectral_density_estimation:9">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Spectral_density_estimation:10">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 parameters 

<math display="inline" id="Spectral_density_estimation:11">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mi>p</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>p</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1},\ldots,a_{p}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The estimation problem then becomes one of estimating these parameters.</p>

<p>The most common form of parametric SDF estimate uses as a model an <a href="autoregressive_model" title="wikilink">autoregressive model</a> 

<math display="inline" id="Spectral_density_estimation:12">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>R</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   AR(p)
  </annotation>
 </semantics>
</math>

 of order 

<math display="inline" id="Spectral_density_estimation:13">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

. A signal sequence 

<math display="inline" id="Spectral_density_estimation:14">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>Y</mi>
    <mi>t</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Y</ci>
     <ci>t</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{Y_{t}\}
  </annotation>
 </semantics>
</math>

 obeying a zero mean 

<math display="inline" id="Spectral_density_estimation:15">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>R</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   AR(p)
  </annotation>
 </semantics>
</math>

 process satisfies the equation</p>

<p>

<math display="block" id="Spectral_density_estimation:16">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Y</mi>
     <mi>t</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>ϕ</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>Y</mi>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>ϕ</mi>
       <mn>2</mn>
      </msub>
      <msub>
       <mi>Y</mi>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
      </msub>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>ϕ</mi>
       <mi>p</mi>
      </msub>
      <msub>
       <mi>Y</mi>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mi>p</mi>
       </mrow>
      </msub>
     </mrow>
     <mo>+</mo>
     <msub>
      <mi>ϵ</mi>
      <mi>t</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Y</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Y</ci>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Y</ci>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Y</ci>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <ci>p</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϵ</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{t}=\phi_{1}Y_{t-1}+\phi_{2}Y_{t-2}+\cdots+\phi_{p}Y_{t-p}+\epsilon_{t},
  </annotation>
 </semantics>
</math>

</p>

<p>where the 

<math display="inline" id="Spectral_density_estimation:17">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>ϕ</mi>
    <mi>p</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>p</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{1},\ldots,\phi_{p}
  </annotation>
 </semantics>
</math>

 are fixed coefficients and 

<math display="inline" id="Spectral_density_estimation:18">
 <semantics>
  <msub>
   <mi>ϵ</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϵ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{t}
  </annotation>
 </semantics>
</math>

 is a white noise process with zero mean and <em>innovation variance</em> 

<math display="inline" id="Spectral_density_estimation:19">
 <semantics>
  <msubsup>
   <mi>σ</mi>
   <mi>p</mi>
   <mn>2</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>σ</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}_{p}
  </annotation>
 </semantics>
</math>

. The SDF for this process is</p>

<p>

<math display="block" id="Spectral_density_estimation:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo>;</mo>
       <msub>
        <mi>ϕ</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>ϕ</mi>
        <mi>p</mi>
       </msub>
       <mo>,</mo>
       <msubsup>
        <mi>σ</mi>
        <mi>p</mi>
        <mn>2</mn>
       </msubsup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mfrac>
      <mrow>
       <msubsup>
        <mi>σ</mi>
        <mi>p</mi>
        <mn>2</mn>
       </msubsup>
       <mi mathvariant="normal">Δ</mi>
       <mi>t</mi>
      </mrow>
      <msup>
       <mrow>
        <mo>|</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mrow>
          <msubsup>
           <mo largeop="true" symmetric="true">∑</mo>
           <mrow>
            <mi>k</mi>
            <mo>=</mo>
            <mn>1</mn>
           </mrow>
           <mi>p</mi>
          </msubsup>
          <mrow>
           <msub>
            <mi>ϕ</mi>
            <mi>k</mi>
           </msub>
           <msup>
            <mi>e</mi>
            <mrow>
             <mo>-</mo>
             <mrow>
              <mn>2</mn>
              <mi>i</mi>
              <mi>π</mi>
              <mi>f</mi>
              <mi>k</mi>
              <mi mathvariant="normal">Δ</mi>
              <mi>t</mi>
             </mrow>
            </mrow>
           </msup>
          </mrow>
         </mrow>
        </mrow>
        <mo>|</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mfrac>
    </mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>f</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo><</mo>
     <msub>
      <mi>f</mi>
      <mi>N</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>S</ci>
      <list>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϕ</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϕ</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>σ</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>p</ci>
       </apply>
      </list>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>σ</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>p</ci>
       </apply>
       <ci>normal-Δ</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <sum></sum>
            <apply>
             <eq></eq>
             <ci>k</ci>
             <cn type="integer">1</cn>
            </apply>
           </apply>
           <ci>p</ci>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>ϕ</ci>
            <ci>k</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>e</ci>
            <apply>
             <minus></minus>
             <apply>
              <times></times>
              <cn type="integer">2</cn>
              <ci>i</ci>
              <ci>π</ci>
              <ci>f</ci>
              <ci>k</ci>
              <ci>normal-Δ</ci>
              <ci>t</ci>
             </apply>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <apply>
      <abs></abs>
      <ci>f</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(f;\phi_{1},\ldots,\phi_{p},\sigma^{2}_{p})=\frac{\sigma^{2}_{p}\Delta t}{%
\left|1-\sum_{k=1}^{p}\phi_{k}e^{-2i\pi fk\Delta t}\right|^{2}}\qquad|f|<f_{N},
  </annotation>
 </semantics>
</math>

</p>

<p>with 

<math display="inline" id="Spectral_density_estimation:21">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta t
  </annotation>
 </semantics>
</math>

 the sampling time interval and 

<math display="inline" id="Spectral_density_estimation:22">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>N</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{N}
  </annotation>
 </semantics>
</math>

 the <a href="Nyquist_frequency" title="wikilink">Nyquist frequency</a>.</p>

<p>There are a number of approaches to estimating the parameters 

<math display="inline" id="Spectral_density_estimation:23">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>ϕ</mi>
    <mi>p</mi>
   </msub>
   <mo>,</mo>
   <msubsup>
    <mi>σ</mi>
    <mi>p</mi>
    <mn>2</mn>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>σ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>p</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{1},\ldots,\phi_{p},\sigma^{2}_{p}
  </annotation>
 </semantics>
</math>

 of the 

<math display="inline" id="Spectral_density_estimation:24">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>R</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   AR(p)
  </annotation>
 </semantics>
</math>

 process and thus the spectral density:</p>
<ul>
<li>The <em><a href="Autoregressive_model#Yule-Walker_equations" title="wikilink">Yule-Walker estimators</a></em> are found by recursively solving the Yule-Walker equations for an 

<math display="inline" id="Spectral_density_estimation:25">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>R</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   AR(p)
  </annotation>
 </semantics>
</math>

 process</li>
<li>The <em>Burg estimators</em> are found by treating the Yule-Walker equations as a form of ordinary least squares problem. The Burg estimators are generally considered superior to the Yule-Walker estimators. Burg associated these with <a href="maximum_entropy_spectral_estimation" title="wikilink">maximum entropy spectral estimation</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
<li>The <em>forward-backward least-squares estimators</em> treat the 

<math display="inline" id="Spectral_density_estimation:26">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>R</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   AR(p)
  </annotation>
 </semantics>
</math>

 process as a regression problem and solves that problem using forward-backward method. They are competitive with the Burg estimators.</li>
<li>The <em>maximum likelihood estimators</em> assume the white noise is a <a href="Gaussian_process" title="wikilink">Gaussian process</a> and estimates the parameters using a <a href="maximum_likelihood" title="wikilink">maximum likelihood</a> approach. This involves a nonlinear optimization and is more complex than the first three.</li>
</ul>

<p>Alternative parametric methods include fitting to a <a href="moving_average_model" title="wikilink">moving average model</a> (MA) and to a full <a href="autoregressive_moving_average_model" title="wikilink">autoregressive moving average model</a> (ARMA).</p>
<h2 id="frequency-estimation">Frequency estimation</h2>

<p><strong>Frequency estimation</strong> is the process of <a href="Estimation_theory" title="wikilink">estimating</a> the complex <a class="uri" href="frequency" title="wikilink">frequency</a> components of a <a href="Digital_signal_processing" title="wikilink">signal</a> in the presence of <a class="uri" href="noise" title="wikilink">noise</a> given assumptions about the number of the components.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> This contrasts with the general methods above, which do not make prior assumptions about the components.</p>
<h3 id="finite-number-of-tones">Finite number of tones</h3>

<p>A typical model for a signal 

<math display="inline" id="Spectral_density_estimation:27">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(n)
  </annotation>
 </semantics>
</math>

 consists of a sum of 

<math display="inline" id="Spectral_density_estimation:28">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 complex exponentials in the presence of <a href="white_noise" title="wikilink">white noise</a>, 

<math display="inline" id="Spectral_density_estimation:29">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w(n)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Spectral_density_estimation:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>p</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>A</mi>
       <mi>i</mi>
      </msub>
      <msup>
       <mi>e</mi>
       <mrow>
        <mi>j</mi>
        <mi>n</mi>
        <msub>
         <mi>ω</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </msup>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>w</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>p</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <times></times>
         <ci>j</ci>
         <ci>n</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ω</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>w</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(n)=\sum_{i=1}^{p}A_{i}e^{jn\omega_{i}}+w(n)
  </annotation>
 </semantics>
</math>

. The power spectral density of 

<math display="inline" id="Spectral_density_estimation:31">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(n)
  </annotation>
 </semantics>
</math>

 is composed of 

<math display="inline" id="Spectral_density_estimation:32">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 <a href="impulse_function" title="wikilink">impulse functions</a> in addition to the spectral density function due to noise.</p>

<p>The most common methods for frequency estimation involve identifying the noise <a href="Linear_subspace" title="wikilink">subspace</a> to extract these components. These methods are based on <a href="Eigendecomposition" title="wikilink">eigen decomposition</a> of the <a href="autocorrelation_matrix" title="wikilink">autocorrelation matrix</a> into a signal subspace and a noise subspace. After these subspaces are identified, a frequency estimation function is used to find the component frequencies from the noise subspace. The most popular methods of noise subspace based frequency estimation are <a href="Pisarenko_harmonic_decomposition" title="wikilink">Pisarenko's method</a>, the <a href="multiple_signal_classification" title="wikilink">multiple signal classification</a> (MUSIC) method, the eigenvector method, and the minimum norm method.</p>

<p><a href="Pisarenko_harmonic_decomposition" title="wikilink">Pisarenko's method</a></p>

<p>

<math display="block" id="Spectral_density_estimation:33">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>P</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mi>P</mi>
      <mi>H</mi>
      <mi>D</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>e</mi>
      <mrow>
       <mi>j</mi>
       <mi>ω</mi>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <msup>
        <mi>𝐞</mi>
        <mi>H</mi>
       </msup>
       <msub>
        <mi>𝐯</mi>
        <mrow>
         <mi>m</mi>
         <mi>i</mi>
         <mi>n</mi>
        </mrow>
       </msub>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>P</ci>
      </apply>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>H</ci>
       <ci>D</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>ω</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝐞</ci>
         <ci>H</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐯</ci>
         <apply>
          <times></times>
          <ci>m</ci>
          <ci>i</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{P}_{PHD}(e^{j\omega})=\frac{1}{|\mathbf{e}^{H}\mathbf{v}_{min}|^{2}}
  </annotation>
 </semantics>
</math>

</p>

<p><a href="Multiple_signal_classification" title="wikilink">MUSIC</a></p>

<p>

<math display="block" id="Spectral_density_estimation:34">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>P</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mi>M</mi>
      <mi>U</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>e</mi>
      <mrow>
       <mi>j</mi>
       <mi>ω</mi>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mrow>
        <mi>p</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </mrow>
      <mi>M</mi>
     </msubsup>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <msup>
         <mi>𝐞</mi>
         <mi>H</mi>
        </msup>
        <msub>
         <mi>𝐯</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>P</ci>
      </apply>
      <apply>
       <times></times>
       <ci>M</ci>
       <ci>U</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>ω</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <apply>
          <plus></plus>
          <ci>p</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <ci>M</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>𝐞</ci>
          <ci>H</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐯</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{P}_{MU}(e^{j\omega})=\frac{1}{\sum_{i=p+1}^{M}|\mathbf{e}^{H}\mathbf{v}_{%
i}|^{2}}
  </annotation>
 </semantics>
</math>

,</p>

<p>Eigenvector method</p>

<p>

<math display="block" id="Spectral_density_estimation:35">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>P</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mi>E</mi>
      <mi>V</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>e</mi>
      <mrow>
       <mi>j</mi>
       <mi>ω</mi>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mrow>
        <mi>p</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </mrow>
      <mi>M</mi>
     </msubsup>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <msub>
        <mi>λ</mi>
        <mi>i</mi>
       </msub>
      </mfrac>
      <msup>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <msup>
          <mi>𝐞</mi>
          <mi>H</mi>
         </msup>
         <msub>
          <mi>𝐯</mi>
          <mi>i</mi>
         </msub>
        </mrow>
        <mo stretchy="false">|</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>P</ci>
      </apply>
      <apply>
       <times></times>
       <ci>E</ci>
       <ci>V</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>ω</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <apply>
          <plus></plus>
          <ci>p</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <ci>M</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <abs></abs>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>𝐞</ci>
           <ci>H</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐯</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{P}_{EV}(e^{j\omega})=\frac{1}{\sum_{i=p+1}^{M}\frac{1}{\lambda_{i}}|%
\mathbf{e}^{H}\mathbf{v}_{i}|^{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>Minimum norm method</p>

<p>

<math display="block" id="Spectral_density_estimation:36">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mover accent="true">
       <mi>P</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mrow>
       <mi>M</mi>
       <mi>N</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>e</mi>
       <mrow>
        <mi>j</mi>
        <mi>ω</mi>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <msup>
         <mi>𝐞</mi>
         <mi>H</mi>
        </msup>
        <mi>𝐚</mi>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mfrac>
   </mrow>
   <mo>;</mo>
   <mrow>
    <mi>𝐚</mi>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <msub>
      <mi>𝐏</mi>
      <mi>n</mi>
     </msub>
     <msub>
      <mi>𝐮</mi>
      <mn>1</mn>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>P</ci>
       </apply>
       <apply>
        <times></times>
        <ci>M</ci>
        <ci>N</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <times></times>
        <ci>j</ci>
        <ci>ω</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>𝐞</ci>
          <ci>H</ci>
         </apply>
         <ci>𝐚</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>𝐚</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐏</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐮</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{P}_{MN}(e^{j\omega})=\frac{1}{|\mathbf{e}^{H}\mathbf{a}|^{2}};\mathbf{a}=%
\lambda\mathbf{P}_{n}\mathbf{u}_{1}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="single-tone">Single tone</h3>

<p>If one only wants to estimate the single loudest frequency, one can use a <a href="pitch_detection_algorithm" title="wikilink">pitch detection algorithm</a>. If the dominant frequency changes over time, then the problem becomes the estimation of the <a href="instantaneous_frequency" title="wikilink">instantaneous frequency</a> as defined in the <a href="time–frequency_representation" title="wikilink">time–frequency representation</a>. Methods for instantaneous frequency estimation include those based on the <a href="Wigner-Ville_distribution" title="wikilink">Wigner-Ville distribution</a> and higher order <a href="ambiguity_function" title="wikilink">ambiguity functions</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>If one wants to know <em>all</em> the (possibly complex) frequency components of a received signal (including transmitted signal and noise), one uses a <a href="discrete_Fourier_transform" title="wikilink">discrete Fourier transform</a> or some other <a href="List_of_Fourier-related_transforms" title="wikilink">Fourier-related transform</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Spectrogram" title="wikilink">Spectrogram</a></li>
<li><a href="Time–frequency_analysis" title="wikilink">Time–frequency analysis</a></li>
<li><a href="Time–frequency_representation" title="wikilink">Time–frequency representation</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
</ul>
<ul>
<li>P Stoica and R Moses, Spectral Analysis of Signals. Prentice Hall, NJ, 2005 (Chinese Edition, 2007). <a href="http://user.it.uu.se/%7Eps/SAS-new.pdf">AVAILABLE FOR DOWNLOAD.</a></li>
</ul>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Signal_processing" title="wikilink">Category:Signal processing</a> <a href="Category:Estimation_theory" title="wikilink">Category:Estimation theory</a> <a href="Category:Frequency_domain_analysis" title="wikilink">Category:Frequency domain analysis</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://onlinelibrary.wiley.com/doi/10.1029/TM003i001p00013/pdf">Schuster, A., "On the investigation of hidden periodicities with application to a supposed 26 day period of meteorological phenomena," <em>Terrestrial Magnetism</em>, 3, 13-41, 1898.</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">Burg, J.P. (1967) "Maximum Entropy Spectral Analysis", <em>Proceedings of the 37th Meeting of the Society of Exploration Geophysicists</em>, Oklahoma City, Oklahoma.<a href="#fnref3">↩</a></li>
<li id="fn4">Hayes, Monson H., <em>Statistical Digital Signal Processing and Modeling</em>, John Wiley &amp; Sons, Inc., 1996. ISBN 0-471-59431-8.<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
