<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1017">Universal hashing</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Universal hashing</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>Using <strong>universal hashing</strong> (in a <a href="randomized_algorithm" title="wikilink">randomized algorithm</a> or data structure) refers to selecting a <a href="hash_function" title="wikilink">hash function</a> at random from a family of hash functions with a certain mathematical property (see definition below). This guarantees a low number of collisions in <a href="expected_value" title="wikilink">expectation</a>, even if the data is chosen by an adversary. Many universal families are known (for hashing integers, vectors, strings), and their evaluation is often very efficient. Universal hashing has numerous uses in computer science, for example in implementations of <a href="hash_table" title="wikilink">hash tables</a>, <a href="randomized_algorithm" title="wikilink">randomized algorithms</a>, and <a class="uri" href="cryptography" title="wikilink">cryptography</a>.</p>
<h2 id="introduction">Introduction</h2>

<p>Assume we want to map keys from some universe 

<math display="inline" id="Universal_hashing:0">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 into 

<math display="inline" id="Universal_hashing:1">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 bins (labelled 

<math display="inline" id="Universal_hashing:2">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>m</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>m</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>m</ci>
    </apply>
    <set>
     <cn type="integer">0</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>m</ci>
      <cn type="integer">1</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [m]=\{0,\dots,m-1\}
  </annotation>
 </semantics>
</math>

). The algorithm will have to handle some data set 

<math display="inline" id="Universal_hashing:3">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊆</mo>
   <mi>U</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subseteq U
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Universal_hashing:4">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>S</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <ci>S</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |S|=n
  </annotation>
 </semantics>
</math>

 keys, which is not known in advance. Usually, the goal of hashing is to obtain a low number of collisions (keys from 

<math display="inline" id="Universal_hashing:5">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 that land in the same bin). A deterministic hash function cannot offer any guarantee in an adversarial setting if the size of 

<math display="inline" id="Universal_hashing:6">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 is greater than 

<math display="inline" id="Universal_hashing:7">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>⋅</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>m</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\cdot n
  </annotation>
 </semantics>
</math>

, since the adversary may choose 

<math display="inline" id="Universal_hashing:8">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 to be precisely the <a href="Image_(mathematics)" title="wikilink">preimage</a> of a bin. This means that all data keys land in the same bin, making hashing useless. Furthermore, a deterministic hash function does not allow for <em>rehashing</em>: sometimes the input data turns out to be bad for the hash function (e.g. there are too many collisions), so one would like to change the hash function.</p>

<p>The solution to these problems is to pick a function randomly from a family of hash functions. A family of functions 

<math display="inline" id="Universal_hashing:9">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>h</mi>
    <mo>:</mo>
    <mrow>
     <mi>U</mi>
     <mo>→</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>m</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>h</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>U</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=\{h:U\to[m]\}
  </annotation>
 </semantics>
</math>

 is called a <strong>universal family</strong> if, 

<math display="inline" id="Universal_hashing:10">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo>∈</mo>
   <mi>U</mi>
   <mo rspace="5.8pt">,</mo>
   <mi>x</mi>
   <mo>≠</mo>
   <mi>y</mi>
   <mo rspace="9.1pt">:</mo>
   <msub>
    <mi>Pr</mi>
    <mrow>
     <mi>h</mi>
     <mo>∈</mo>
     <mi>H</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≤</mo>
   <mfrac>
    <mn>1</mn>
    <mi>m</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">y</csymbol>
    <in></in>
    <csymbol cd="unknown">U</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">x</csymbol>
    <neq></neq>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Pr</ci>
     <apply>
      <in></in>
      <ci>h</ci>
      <ci>H</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">h</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">h</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <leq></leq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>m</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x,y\in U,~{}x\neq y:~{}~{}\Pr_{h\in H}[h(x)=h(y)]\leq\frac{1}{m}
  </annotation>
 </semantics>
</math>

.</p>

<p>In other words, any two keys of the universe collide with probability at most 

<math display="inline" id="Universal_hashing:11">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/m
  </annotation>
 </semantics>
</math>

 when the hash function 

<math display="inline" id="Universal_hashing:12">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 is drawn randomly from 

<math display="inline" id="Universal_hashing:13">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

. This is exactly the probability of collision we would expect if the hash function assigned truly random hash codes to every key. Sometimes, the definition is relaxed to allow collision probability 

<math display="inline" id="Universal_hashing:14">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>m</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1/m)
  </annotation>
 </semantics>
</math>

. This concept was introduced by Carter and Wegman<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> in 1977, and has found numerous applications in computer science (see, for example <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a>). If we have an upper bound of 

<math display="inline" id="Universal_hashing:15">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mo><</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>ϵ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon<1
  </annotation>
 </semantics>
</math>

 on the collision probability, we say that we have 

<math display="inline" id="Universal_hashing:16">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

-almost universality.</p>

<p>Many, but not all, universal families have the following stronger <strong>uniform difference property</strong>:</p>

<p>

<math display="block" id="Universal_hashing:17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mi>x</mi>
     </mrow>
     <mo>,</mo>
     <mi>y</mi>
    </mrow>
    <mo>∈</mo>
    <mi>U</mi>
   </mrow>
   <mo rspace="5.8pt">,</mo>
   <mrow>
    <mi>x</mi>
    <mo>≠</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <list>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>x</ci>
      </apply>
      <ci>y</ci>
     </list>
     <ci>U</ci>
    </apply>
    <apply>
     <neq></neq>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x,y\in U,~{}x\neq y
  </annotation>
 </semantics>
</math>

, when 

<math display="inline" id="Universal_hashing:18">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 is drawn randomly from the family 

<math display="inline" id="Universal_hashing:19">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

, the difference 

<math display="inline" id="Universal_hashing:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo rspace="5.8pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo lspace="2.5pt" rspace="5.8pt">mod</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">modulo</csymbol>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x)-h(y)~{}\bmod~{}m
  </annotation>
 </semantics>
</math>

 is uniformly distributed in 

<math display="inline" id="Universal_hashing:21">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>m</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [m]
  </annotation>
 </semantics>
</math>

.</p>

<p>Note that the definition of universality is only concerned with whether 

<math display="inline" id="Universal_hashing:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x)-h(y)=0
  </annotation>
 </semantics>
</math>

, which counts collisions. The uniform difference property is stronger.</p>

<p>(Similarly, a universal family can be XOR universal if 

<math display="inline" id="Universal_hashing:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mi>x</mi>
     </mrow>
     <mo>,</mo>
     <mi>y</mi>
    </mrow>
    <mo>∈</mo>
    <mi>U</mi>
   </mrow>
   <mo rspace="5.8pt">,</mo>
   <mrow>
    <mi>x</mi>
    <mo>≠</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <list>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>x</ci>
      </apply>
      <ci>y</ci>
     </list>
     <ci>U</ci>
    </apply>
    <apply>
     <neq></neq>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x,y\in U,~{}x\neq y
  </annotation>
 </semantics>
</math>

, the value 

<math display="inline" id="Universal_hashing:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊕</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo rspace="5.8pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo lspace="2.5pt" rspace="5.8pt">mod</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">modulo</csymbol>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x)\oplus h(y)~{}\bmod~{}m
  </annotation>
 </semantics>
</math>

 is uniformly distributed in 

<math display="inline" id="Universal_hashing:25">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>m</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [m]
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Universal_hashing:26">
 <semantics>
  <mo>⊕</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">direct-sum</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \oplus
  </annotation>
 </semantics>
</math>

 is the bitwise exclusive or operation. This is only possible if 

<math display="inline" id="Universal_hashing:27">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 is a power of two.)</p>

<p>An even stronger condition is <a href="Pairwise_independent" title="wikilink">pairwise independence</a>: we have this property when 

<math display="inline" id="Universal_hashing:28">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mi>x</mi>
     </mrow>
     <mo>,</mo>
     <mi>y</mi>
    </mrow>
    <mo>∈</mo>
    <mi>U</mi>
   </mrow>
   <mo rspace="5.8pt">,</mo>
   <mrow>
    <mi>x</mi>
    <mo>≠</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <list>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>x</ci>
      </apply>
      <ci>y</ci>
     </list>
     <ci>U</ci>
    </apply>
    <apply>
     <neq></neq>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x,y\in U,~{}x\neq y
  </annotation>
 </semantics>
</math>

 we have the probability that 

<math display="inline" id="Universal_hashing:29">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>x</ci>
    <ci>y</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,y
  </annotation>
 </semantics>
</math>

 will hash to any pair of hash values 

<math display="inline" id="Universal_hashing:30">
 <semantics>
  <mrow>
   <msub>
    <mi>z</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>z</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{1},z_{2}
  </annotation>
 </semantics>
</math>

 is as if they were perfectly random

<math display="block" id="Universal_hashing:31">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>z</mi>
     <mn>1</mn>
    </msub>
    <mo>∧</mo>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>z</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
   <mo>/</mo>
   <msup>
    <mi>m</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">h</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">1</cn>
     </apply>
     <and></and>
     <csymbol cd="unknown">h</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">1</cn>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <cn type="integer">2</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(h(x)=z_{1}\land h(y)=z_{2})=1/m^{2}
  </annotation>
 </semantics>
</math>

. Pairwise independence is sometimes called strong universality.</p>

<p>Another property is uniformity. We say that a family is uniform if all hash values are equally likely

<math display="block" id="Universal_hashing:32">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
   <mo>/</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">h</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">1</cn>
    <divide></divide>
    <csymbol cd="unknown">m</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(h(x)=z)=1/m
  </annotation>
 </semantics>
</math>

 for any hash value 

<math display="inline" id="Universal_hashing:33">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

. Universality does not imply uniformity. However, strong universality does imply uniformity.</p>

<p>Given a family with the uniform distance property, one can produce a pairwise independent or strongly universal hash family by adding a uniformly distributed random constant with values in 

<math display="inline" id="Universal_hashing:34">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>m</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [m]
  </annotation>
 </semantics>
</math>

 to the hash functions. (Similarly, if 

<math display="inline" id="Universal_hashing:35">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 is a power of two, we can achieve pairwise independence from an XOR universal hash family by doing an exclusive or with a uniformly distributed random constant.) Since a shift by a constant is sometimes irrelevant in applications (e.g. hash tables), a careful distinction between the uniform distance property and pairwise independent is sometimes not made.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>For some applications (such as hash tables), it is important for the least significant bits of the hash values to be also universal. When a family is strongly universal, this is guaranteed: if 

<math display="inline" id="Universal_hashing:36">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 is a strongly universal family with 

<math display="inline" id="Universal_hashing:37">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mi>L</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=2^{L}
  </annotation>
 </semantics>
</math>

, then the family made of the functions 

<math display="inline" id="Universal_hashing:38">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
   <msup>
    <mn>2</mn>
    <msup>
     <mi>L</mi>
     <mo>′</mo>
    </msup>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">modulo</csymbol>
    <ci>h</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h\bmod{2^{L^{\prime}}}
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Universal_hashing:39">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>∈</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>h</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h\in H
  </annotation>
 </semantics>
</math>

 is also strongly universal for 

<math display="inline" id="Universal_hashing:40">
 <semantics>
  <mrow>
   <msup>
    <mi>L</mi>
    <mo>′</mo>
   </msup>
   <mo>≤</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>L</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{\prime}\leq L
  </annotation>
 </semantics>
</math>

. Unfortunately, the same is not true of (merely) universal families. For example the family made of the identity function 

<math display="inline" id="Universal_hashing:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>x</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x)=x
  </annotation>
 </semantics>
</math>

 is clearly universal, but the family made of the function 

<math display="inline" id="Universal_hashing:42">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <msup>
     <mn>2</mn>
     <msup>
      <mi>L</mi>
      <mo>′</mo>
     </msup>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>L</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x)=x\bmod{2^{L^{\prime}}}
  </annotation>
 </semantics>
</math>

 fails to be universal.</p>

<p><a class="uri" href="UMAC" title="wikilink">UMAC</a> and <a class="uri" href="Poly1305-AES" title="wikilink">Poly1305-AES</a> and several other <a href="message_authentication_code" title="wikilink">message authentication code</a> algorithms are based on universal hashing.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> In such applications, the software chooses a new hash function for every message, based on a unique nonce for that message.</p>

<p>Several hash table implementations are based on universal hashing. In such applications, typically the software chooses a new hash function only after it notices that "too many" keys have collided; until then, the same hash function continues to be used over and over. (Some collision resolution schemes, such as <a href="dynamic_perfect_hashing" title="wikilink">dynamic perfect hashing</a>, pick a new hash function every time there is a collision. Other collision resolution schemes, such as <a href="cuckoo_hashing" title="wikilink">cuckoo hashing</a> and <a href="2-choice_hashing" title="wikilink">2-choice hashing</a>, allow a number of collisions before picking a new hash function).</p>
<h2 id="mathematical-guarantees">Mathematical guarantees</h2>

<p>For any fixed set 

<math display="inline" id="Universal_hashing:43">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Universal_hashing:44">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 keys, using a universal family guarantees the following properties.</p>
<ol>
<li>For any fixed 

<math display="inline" id="Universal_hashing:45">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Universal_hashing:46">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, the expected number of keys in the bin 

<math display="inline" id="Universal_hashing:47">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x)
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Universal_hashing:48">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>/</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n/m
  </annotation>
 </semantics>
</math>

. When implementing hash tables by <a href="Hash_table#Separate_chaining" title="wikilink">chaining</a>, this number is proportional to the expected running time of an operation involving the key 

<math display="inline" id="Universal_hashing:49">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 (for example a query, insertion or deletion).</li>
<li>The expected number of pairs of keys 

<math display="inline" id="Universal_hashing:50">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>x</ci>
    <ci>y</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,y
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Universal_hashing:51">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Universal_hashing:52">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≠</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\neq y
  </annotation>
 </semantics>
</math>

 that collide (

<math display="inline" id="Universal_hashing:53">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x)=h(y)
  </annotation>
 </semantics>
</math>

) is bounded above by 

<math display="inline" id="Universal_hashing:54">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n(n-1)/2m
  </annotation>
 </semantics>
</math>

, which is of order 

<math display="inline" id="Universal_hashing:55">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>n</mi>
      <mn>2</mn>
     </msup>
     <mo>/</mo>
     <mi>m</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2}/m)
  </annotation>
 </semantics>
</math>

. When the number of bins, 

<math display="inline" id="Universal_hashing:56">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

, is 

<math display="inline" id="Universal_hashing:57">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

, the expected number of collisions is 

<math display="inline" id="Universal_hashing:58">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

. When hashing into 

<math display="inline" id="Universal_hashing:59">
 <semantics>
  <msup>
   <mi>n</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{2}
  </annotation>
 </semantics>
</math>

 bins, there are no collisions at all with probability at least a half.</li>
<li>The expected number of keys in bins with at least 

<math display="inline" id="Universal_hashing:60">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 keys in them is bounded above by 

<math display="inline" id="Universal_hashing:61">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>n</mi>
   </mrow>
   <mo>/</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>/</mo>
         <mi>m</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <divide></divide>
        <ci>n</ci>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2n/(t-2(n/m)+1)
  </annotation>
 </semantics>
</math>

.<ref name="BDP"></ref></li>
</ol>

<p> Thus, if the capacity of each bin is capped to three times the average size (

<math display="inline" id="Universal_hashing:62">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>3</mn>
     <mi>n</mi>
    </mrow>
    <mo>/</mo>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <ci>n</ci>
     </apply>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=3n/m
  </annotation>
 </semantics>
</math>

), the total number of keys in overflowing bins is at most 

<math display="inline" id="Universal_hashing:63">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(m)
  </annotation>
 </semantics>
</math>

. This only holds with a hash family whose collision probability is bounded above by 

<math display="inline" id="Universal_hashing:64">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/m
  </annotation>
 </semantics>
</math>

. If a weaker definition is used, bounding it by 

<math display="inline" id="Universal_hashing:65">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>m</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1/m)
  </annotation>
 </semantics>
</math>

, this result is no longer true.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>As the above guarantees hold for any fixed set 

<math display="inline" id="Universal_hashing:66">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, they hold if the data set is chosen by an adversary. However, the adversary has to make this choice before (or independent of) the algorithm's random choice of a hash function. If the adversary can observe the random choice of the algorithm, randomness serves no purpose, and the situation is the same as deterministic hashing.</p>

<p>The second and third guarantee are typically used in conjunction with <a href="Double_hashing" title="wikilink">rehashing</a>. For instance, a randomized algorithm may be prepared to handle some 

<math display="inline" id="Universal_hashing:67">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 number of collisions. If it observes too many collisions, it chooses another random 

<math display="inline" id="Universal_hashing:68">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 from the family and repeats. Universality guarantees that the number of repetitions is a <a href="Geometric_distribution" title="wikilink">geometric random variable</a>.</p>
<h2 id="constructions">Constructions</h2>

<p>Since any computer data can be represented as one or more machine words, one generally needs hash functions for three types of domains: machine words ("integers"); fixed-length vectors of machine words; and variable-length vectors ("strings").</p>
<h3 id="hashing-integers">Hashing integers</h3>

<p>This section refers to the case of hashing integers that fit in machines words; thus, operations like multiplication, addition, division, etc. are cheap machine-level instructions. Let the universe to be hashed be 

<math display="inline" id="Universal_hashing:69">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>u</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>U</ci>
    <set>
     <cn type="integer">0</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>u</ci>
      <cn type="integer">1</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U=\{0,\dots,u-1\}
  </annotation>
 </semantics>
</math>

.</p>

<p>The original proposal of Carter and Wegman<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> was to pick a prime 

<math display="inline" id="Universal_hashing:70">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>≥</mo>
   <mi>u</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>p</ci>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\geq u
  </annotation>
 </semantics>
</math>

 and define</p>

<p>

<math display="block" id="Universal_hashing:71">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mrow>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>a</mi>
         <mi>x</mi>
        </mrow>
        <mo>+</mo>
        <mi>b</mi>
       </mrow>
       <mo rspace="5.8pt" stretchy="false">)</mo>
      </mrow>
      <mo lspace="2.5pt" rspace="5.8pt">mod</mo>
      <mi>p</mi>
     </mrow>
     <mo rspace="5.8pt" stretchy="false">)</mo>
    </mrow>
    <mo lspace="2.5pt" rspace="5.8pt">mod</mo>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <list>
       <ci>a</ci>
       <ci>b</ci>
      </list>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>x</ci>
       </apply>
       <ci>b</ci>
      </apply>
      <ci>p</ci>
     </apply>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{a,b}(x)=((ax+b)~{}\bmod~{}p)~{}\bmod~{}m
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Universal_hashing:72">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>a</ci>
    <ci>b</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a,b
  </annotation>
 </semantics>
</math>

 are randomly chosen integers modulo 

<math display="inline" id="Universal_hashing:73">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Universal_hashing:74">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>a</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\neq 0
  </annotation>
 </semantics>
</math>

. (This is a single iteration of a <a href="linear_congruential_generator" title="wikilink">linear congruential generator</a>.)</p>

<p>To see that 

<math display="inline" id="Universal_hashing:75">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>h</mi>
     <mrow>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
     </mrow>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <list>
       <ci>a</ci>
       <ci>b</ci>
      </list>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=\{h_{a,b}\}
  </annotation>
 </semantics>
</math>

 is a universal family, note that 

<math display="inline" id="Universal_hashing:76">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x)=h(y)
  </annotation>
 </semantics>
</math>

 only holds when</p>

<p>

<math display="block" id="Universal_hashing:77">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mi>b</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>a</mi>
      <mi>y</mi>
     </mrow>
     <mo>+</mo>
     <mi>b</mi>
     <mo>+</mo>
     <mrow>
      <mi>i</mi>
      <mo>⋅</mo>
      <mi>m</mi>
     </mrow>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>x</ci>
     </apply>
     <ci>b</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>y</ci>
      </apply>
      <ci>b</ci>
      <apply>
       <ci>normal-⋅</ci>
       <ci>i</ci>
       <ci>m</ci>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ax+b\equiv ay+b+i\cdot m\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

</p>

<p>for some integer 

<math display="inline" id="Universal_hashing:78">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 between 

<math display="inline" id="Universal_hashing:79">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 and 

<math display="inline" id="Universal_hashing:80">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>/</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>p</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p/m
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Universal_hashing:81">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≠</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\neq y
  </annotation>
 </semantics>
</math>

, their difference, 

<math display="inline" id="Universal_hashing:82">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>-</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x-y
  </annotation>
 </semantics>
</math>

 is nonzero and has an inverse modulo 

<math display="inline" id="Universal_hashing:83">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

. Solving for 

<math display="inline" id="Universal_hashing:84">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 yields</p>

<p>

<math display="block" id="Universal_hashing:85">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mi>i</mi>
     <mo>⋅</mo>
     <mi>m</mi>
     <mo>⋅</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <mi>y</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>a</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <ci>normal-⋅</ci>
      <ci>i</ci>
      <ci>m</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <ci>y</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\equiv i\cdot m\cdot(x-y)^{-1}\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

.</p>

<p>There are 

<math display="inline" id="Universal_hashing:86">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>p</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p-1
  </annotation>
 </semantics>
</math>

 possible choices for 

<math display="inline" id="Universal_hashing:87">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 (since 

<math display="inline" id="Universal_hashing:88">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=0
  </annotation>
 </semantics>
</math>

 is excluded) and, varying 

<math display="inline" id="Universal_hashing:89">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 in the allowed range, 

<math display="inline" id="Universal_hashing:90">
 <semantics>
  <mrow>
   <mo stretchy="false">⌊</mo>
   <mrow>
    <mi>p</mi>
    <mo>/</mo>
    <mi>m</mi>
   </mrow>
   <mo stretchy="false">⌋</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <floor></floor>
    <apply>
     <divide></divide>
     <ci>p</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lfloor p/m\rfloor
  </annotation>
 </semantics>
</math>

 possible values for the right hand side. Thus the collision probability is</p>

<p>

<math display="block" id="Universal_hashing:91">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⌊</mo>
    <mrow>
     <mi>p</mi>
     <mo>/</mo>
     <mi>m</mi>
    </mrow>
    <mo stretchy="false">⌋</mo>
   </mrow>
   <mo>/</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>p</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <floor></floor>
     <apply>
      <divide></divide>
      <ci>p</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lfloor p/m\rfloor/(p-1)
  </annotation>
 </semantics>
</math>

</p>

<p>which tends to 

<math display="inline" id="Universal_hashing:92">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/m
  </annotation>
 </semantics>
</math>

 for large 

<math display="inline" id="Universal_hashing:93">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 as required.</p>

<p>Another way to see 

<math display="inline" id="Universal_hashing:94">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 is a universal family is via the notion of <a href="statistical_distance" title="wikilink">statistical distance</a>. Write the difference 

<math display="inline" id="Universal_hashing:95">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x)-h(y)
  </annotation>
 </semantics>
</math>

 as</p>

<p>

<math display="block" id="Universal_hashing:96">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>a</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>x</mi>
         <mo>-</mo>
         <mi>y</mi>
        </mrow>
        <mo rspace="5.8pt" stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo lspace="2.5pt" rspace="5.8pt">mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>m</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <apply>
       <times></times>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <ci>y</ci>
       </apply>
      </apply>
      <ci>p</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x)-h(y)\equiv(a(x-y)~{}\bmod~{}p)\;\;(\mathop{{\rm mod}}m)
  </annotation>
 </semantics>
</math>

.</p>

<p>Since 

<math display="inline" id="Universal_hashing:97">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>-</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x-y
  </annotation>
 </semantics>
</math>

 is nonzero and 

<math display="inline" id="Universal_hashing:98">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is uniformly distributed in 

<math display="inline" id="Universal_hashing:99">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mi>p</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">1</cn>
    <ci>normal-…</ci>
    <ci>p</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{1,\dots,p\}
  </annotation>
 </semantics>
</math>

, it follows that 

<math display="inline" id="Universal_hashing:100">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <apply>
     <minus></minus>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(x-y)
  </annotation>
 </semantics>
</math>

 modulo 

<math display="inline" id="Universal_hashing:101">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is also uniformly distributed in 

<math display="inline" id="Universal_hashing:102">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mi>p</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">1</cn>
    <ci>normal-…</ci>
    <ci>p</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{1,\dots,p\}
  </annotation>
 </semantics>
</math>

. The distribution of 

<math display="inline" id="Universal_hashing:103">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="5.8pt" stretchy="false">)</mo>
   </mrow>
   <mo lspace="2.5pt" rspace="5.8pt">mod</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">modulo</csymbol>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (h(x)-h(y))~{}\bmod~{}m
  </annotation>
 </semantics>
</math>

 is thus almost uniform, up to a difference in probability of 

<math display="inline" id="Universal_hashing:104">
 <semantics>
  <mrow>
   <mo>±</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">plus-or-minus</csymbol>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pm 1/p
  </annotation>
 </semantics>
</math>

 between the samples. As a result, the statistical distance to a uniform family is 

<math display="inline" id="Universal_hashing:105">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>m</mi>
     <mo>/</mo>
     <mi>p</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <ci>m</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(m/p)
  </annotation>
 </semantics>
</math>

, which becomes negligible when 

<math display="inline" id="Universal_hashing:106">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>≫</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">much-greater-than</csymbol>
    <ci>p</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\gg m
  </annotation>
 </semantics>
</math>

.</p>

<p>The family of simpler hash functions</p>

<p>

<math display="block" id="Universal_hashing:107">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mi>a</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>a</mi>
       <mpadded width="+3.3pt">
        <mi>x</mi>
       </mpadded>
      </mrow>
      <mo lspace="2.5pt" rspace="5.8pt">mod</mo>
      <mi>p</mi>
     </mrow>
     <mo rspace="5.8pt" stretchy="false">)</mo>
    </mrow>
    <mo lspace="2.5pt" rspace="5.8pt">mod</mo>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>a</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>x</ci>
      </apply>
      <ci>p</ci>
     </apply>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{a}(x)=(ax~{}\bmod~{}p)~{}\bmod~{}m
  </annotation>
 </semantics>
</math>

 is only <em>approximately</em> universal

<math display="block" id="Universal_hashing:108">
 <semantics>
  <mrow>
   <mrow>
    <mi>Pr</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>h</mi>
        <mi>a</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mrow>
       <msub>
        <mi>h</mi>
        <mi>a</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mn>2</mn>
    <mo>/</mo>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <ci>Pr</ci>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>a</ci>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>a</ci>
       </apply>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr\{h_{a}(x)=h_{a}(y)\}\leq 2/m
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Universal_hashing:109">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≠</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\neq y
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Moreover, this analysis is nearly tight; Carter and Wegman <a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> show that 

<math display="inline" id="Universal_hashing:110">
 <semantics>
  <mrow>
   <mrow>
    <mi>Pr</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>h</mi>
        <mi>a</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mrow>
       <msub>
        <mi>h</mi>
        <mi>a</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>m</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mn>2</mn>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>m</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <ci>Pr</ci>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>a</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>a</ci>
       </apply>
       <apply>
        <plus></plus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <ci>m</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr\{h_{a}(1)=h_{a}(m+1)\}\geq 2/(m-1)
  </annotation>
 </semantics>
</math>

 whenever 

<math display="inline" id="Universal_hashing:111">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>p</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo rspace="5.8pt" stretchy="false">)</mo>
    </mrow>
    <mo lspace="2.5pt" rspace="5.8pt">mod</mo>
    <mi>m</mi>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <minus></minus>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>m</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p-1)~{}\bmod~{}m=1
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="avoiding-modular-arithmetic">Avoiding modular arithmetic</h4>

<p>The state of the art for hashing integers is the <strong>multiply-shift</strong> scheme described by Dietzfelbinger et al. in 1997.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> By avoiding modular arithmetic, this method is much easier to implement and also runs significantly faster in practice (usually by at least a factor of four<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a>). The scheme assumes the number of bins is a power of two, 

<math display="inline" id="Universal_hashing:112">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mi>M</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=2^{M}
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Universal_hashing:113">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 be the number of bits in a machine word. Then the hash functions are parametrised over odd positive integers 

<math display="inline" id="Universal_hashing:114">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo><</mo>
   <msup>
    <mn>2</mn>
    <mi>w</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>a</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a<2^{w}
  </annotation>
 </semantics>
</math>

 (that fit in a word of 

<math display="inline" id="Universal_hashing:115">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 bits). To evaluate 

<math display="inline" id="Universal_hashing:116">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>a</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>a</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{a}(x)
  </annotation>
 </semantics>
</math>

, multiply 

<math display="inline" id="Universal_hashing:117">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Universal_hashing:118">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 modulo 

<math display="inline" id="Universal_hashing:119">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>w</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{w}
  </annotation>
 </semantics>
</math>

 and then keep the high order 

<math display="inline" id="Universal_hashing:120">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 bits as the hash code. In mathematical notation, this is</p>

<p>

<math display="block" id="Universal_hashing:121">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mi>a</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>a</mi>
       <mo>⋅</mo>
       <mpadded width="+3.4pt">
        <mi>x</mi>
       </mpadded>
      </mrow>
      <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
      <msup>
       <mn>2</mn>
       <mi>w</mi>
      </msup>
     </mrow>
     <mo rspace="5.9pt" stretchy="false">)</mo>
    </mrow>
    <mi>div</mi>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>w</mi>
      <mo>-</mo>
      <mi>M</mi>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>a</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <apply>
       <ci>normal-⋅</ci>
       <ci>a</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="float">2</cn>
       <ci>w</ci>
      </apply>
     </apply>
     <ci>div</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="float">2</cn>
      <apply>
       <minus></minus>
       <ci>w</ci>
       <ci>M</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{a}(x)=(a\cdot x\,\,\bmod\,2^{w})\,\,\mathrm{div}\,\,2^{w-M}
  </annotation>
 </semantics>
</math>

</p>

<p>and it can be implemented in <a href="C_(programming_language)" title="wikilink">C</a>-like programming languages by</p>

<p>

<math display="block" id="Universal_hashing:122">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mi>a</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>a</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{a}(x)=
  </annotation>
 </semantics>
</math>

 <code>(unsigned) (a*x) &gt;&gt; (w-M)</code></p>

<p>This scheme does <em>not</em> satisfy the uniform difference property and is only <em>

<math display="inline" id="Universal_hashing:123">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mo>/</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">2</cn>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2/m
  </annotation>
 </semantics>
</math>

-almost-universal</em>; for any 

<math display="inline" id="Universal_hashing:124">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≠</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\neq y
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Universal_hashing:125">
 <semantics>
  <mrow>
   <mrow>
    <mi>Pr</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>h</mi>
        <mi>a</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mrow>
       <msub>
        <mi>h</mi>
        <mi>a</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mn>2</mn>
    <mo>/</mo>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <ci>Pr</ci>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>a</ci>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>a</ci>
       </apply>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr\{h_{a}(x)=h_{a}(y)\}\leq 2/m
  </annotation>
 </semantics>
</math>

.</p>

<p>To understand the behavior of the hash function, notice that, if 

<math display="inline" id="Universal_hashing:126">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mi>x</mi>
   </mrow>
   <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
   <msup>
    <mn>2</mn>
    <mi>w</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">modulo</csymbol>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ax\bmod 2^{w}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Universal_hashing:127">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mi>y</mi>
   </mrow>
   <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
   <msup>
    <mn>2</mn>
    <mi>w</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">modulo</csymbol>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ay\bmod 2^{w}
  </annotation>
 </semantics>
</math>

 have the same highest-order 'M' bits, then 

<math display="inline" id="Universal_hashing:128">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
   <msup>
    <mn>2</mn>
    <mi>w</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">modulo</csymbol>
    <apply>
     <times></times>
     <ci>a</ci>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(x-y)\bmod 2^{w}
  </annotation>
 </semantics>
</math>

 has either all 1's or all 0's as its highest order M bits (depending on whether 

<math display="inline" id="Universal_hashing:129">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mi>x</mi>
   </mrow>
   <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
   <msup>
    <mn>2</mn>
    <mi>w</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">modulo</csymbol>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ax\bmod 2^{w}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Universal_hashing:130">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mi>y</mi>
   </mrow>
   <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
   <msup>
    <mn>2</mn>
    <mi>w</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">modulo</csymbol>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ay\bmod 2^{w}
  </annotation>
 </semantics>
</math>

 is larger. Assume that the least significant set bit of 

<math display="inline" id="Universal_hashing:131">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>-</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x-y
  </annotation>
 </semantics>
</math>

 appears on position 

<math display="inline" id="Universal_hashing:132">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>-</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>w</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w-c
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Universal_hashing:133">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is a random odd integer and odd integers have inverses in the <a href="Ring_(mathematics)" title="wikilink">ring</a> 

<math display="inline" id="Universal_hashing:134">
 <semantics>
  <msub>
   <mi>Z</mi>
   <msup>
    <mn>2</mn>
    <mi>w</mi>
   </msup>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Z</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{2^{w}}
  </annotation>
 </semantics>
</math>

, it follows that 

<math display="inline" id="Universal_hashing:135">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
   <msup>
    <mn>2</mn>
    <mi>w</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">modulo</csymbol>
    <apply>
     <times></times>
     <ci>a</ci>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(x-y)\bmod 2^{w}
  </annotation>
 </semantics>
</math>

 will be uniformly distributed among 

<math display="inline" id="Universal_hashing:136">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

-bit integers with the least significant set bit on position 

<math display="inline" id="Universal_hashing:137">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>-</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>w</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w-c
  </annotation>
 </semantics>
</math>

. The probability that these bits are all 0's or all 1's is therefore at most 

<math display="inline" id="Universal_hashing:138">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mo>/</mo>
    <msup>
     <mn>2</mn>
     <mi>M</mi>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mo>/</mo>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>M</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2/2^{M}=2/m
  </annotation>
 </semantics>
</math>

. On the other hand, if 

<math display="inline" id="Universal_hashing:139">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo><</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>c</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c<M
  </annotation>
 </semantics>
</math>

, then higher-order M bits of 

<math display="inline" id="Universal_hashing:140">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
   <msup>
    <mn>2</mn>
    <mi>w</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">modulo</csymbol>
    <apply>
     <times></times>
     <ci>a</ci>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(x-y)\bmod 2^{w}
  </annotation>
 </semantics>
</math>

 contain both 0's and 1's, so it is certain that 

<math display="inline" id="Universal_hashing:141">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x)\neq h(y)
  </annotation>
 </semantics>
</math>

. Finally, if 

<math display="inline" id="Universal_hashing:142">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>c</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=M
  </annotation>
 </semantics>
</math>

 then bit 

<math display="inline" id="Universal_hashing:143">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>-</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>w</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w-M
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Universal_hashing:144">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
   <msup>
    <mn>2</mn>
    <mi>w</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">modulo</csymbol>
    <apply>
     <times></times>
     <ci>a</ci>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(x-y)\bmod 2^{w}
  </annotation>
 </semantics>
</math>

 is 1 and 

<math display="inline" id="Universal_hashing:145">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mi>a</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>h</mi>
     <mi>a</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>a</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>a</ci>
     </apply>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{a}(x)=h_{a}(y)
  </annotation>
 </semantics>
</math>

 if and only if bits 

<math display="inline" id="Universal_hashing:146">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>w</mi>
     <mo>-</mo>
     <mi>M</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <minus></minus>
     <ci>w</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <ci>w</ci>
      <ci>M</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w-1,\ldots,w-M+1
  </annotation>
 </semantics>
</math>

 are also 1, which happens with probability 

<math display="inline" id="Universal_hashing:147">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>M</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mo>/</mo>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <ci>M</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/2^{M-1}=2/m
  </annotation>
 </semantics>
</math>

.</p>

<p>This analysis is tight, as can be shown with the example 

<math display="inline" id="Universal_hashing:148">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>w</mi>
     <mo>-</mo>
     <mi>M</mi>
     <mo>-</mo>
     <mn>2</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <ci>w</ci>
      <ci>M</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=2^{w-M-2}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Universal_hashing:149">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mn>3</mn>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <times></times>
     <cn type="integer">3</cn>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=3x
  </annotation>
 </semantics>
</math>

. To obtain a truly 'universal' hash function, one can use the multiply-add-shift scheme</p>

<p>

<math display="block" id="Universal_hashing:150">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mrow>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>a</mi>
         <mi>x</mi>
        </mrow>
        <mo>+</mo>
        <mi>b</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
      <msup>
       <mn>2</mn>
       <mi>w</mi>
      </msup>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
    <mi>div</mi>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>w</mi>
      <mo>-</mo>
      <mi>M</mi>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <list>
       <ci>a</ci>
       <ci>b</ci>
      </list>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>x</ci>
       </apply>
       <ci>b</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>w</ci>
      </apply>
     </apply>
     <ci>div</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="float">2</cn>
      <apply>
       <minus></minus>
       <ci>w</ci>
       <ci>M</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{a,b}(x)=((ax+b)\bmod 2^{w})\,\mathrm{div}\,2^{w-M}
  </annotation>
 </semantics>
</math>

</p>

<p>which can be implemented in <a href="C_(programming_language)" title="wikilink">C</a>-like programming languages by</p>

<p>

<math display="block" id="Universal_hashing:151">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mrow>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <list>
       <ci>a</ci>
       <ci>b</ci>
      </list>
     </apply>
     <ci>x</ci>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{a,b}(x)=
  </annotation>
 </semantics>
</math>

 <code>(unsigned) (a*x+b) &gt;&gt; (w-M)</code></p>

<p>where 

<math display="inline" id="Universal_hashing:152">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is a random odd positive integer with 

<math display="inline" id="Universal_hashing:153">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo><</mo>
   <msup>
    <mn>2</mn>
    <mi>w</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>a</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a<2^{w}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Universal_hashing:154">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 is a random non-negative integer with 

<math display="inline" id="Universal_hashing:155">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo><</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>w</mi>
     <mo>-</mo>
     <mi>M</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>b</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <ci>w</ci>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b<2^{w-M}
  </annotation>
 </semantics>
</math>

. With these choices of 

<math display="inline" id="Universal_hashing:156">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Universal_hashing:157">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Universal_hashing:158">
 <semantics>
  <mrow>
   <mrow>
    <mi>Pr</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>h</mi>
        <mrow>
         <mi>a</mi>
         <mo>,</mo>
         <mi>b</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mrow>
       <msub>
        <mi>h</mi>
        <mrow>
         <mi>a</mi>
         <mo>,</mo>
         <mi>b</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <ci>Pr</ci>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <list>
         <ci>a</ci>
         <ci>b</ci>
        </list>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <list>
         <ci>a</ci>
         <ci>b</ci>
        </list>
       </apply>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr\{h_{a,b}(x)=h_{a,b}(y)\}\leq 1/m
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Universal_hashing:159">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≢</mo>
   <mrow>
    <mi>y</mi>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <msup>
       <mn>2</mn>
       <mi>w</mi>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-equivalent-to</csymbol>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <ci>y</ci>
     <apply>
      <ci>pmod</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>w</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\not\equiv y\;\;(\mathop{{\rm mod}}2^{w})
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> This differs slightly but importantly from the mistranslation in the English paper.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h3 id="hashing-vectors">Hashing vectors</h3>

<p>This section is concerned with hashing a fixed-length vector of machine words. Interpret the input as a vector 

<math display="inline" id="Universal_hashing:160">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>k</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-¯</ci>
     <ci>x</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{x}=(x_{0},\dots,x_{k-1})
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Universal_hashing:161">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 machine words (integers of 

<math display="inline" id="Universal_hashing:162">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 bits each). If 

<math display="inline" id="Universal_hashing:163">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 is a universal family with the uniform difference property, the following family (dating back to Carter and Wegman<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a>) also has the uniform difference property (and hence is universal):</p>

<p>

<math display="block" id="Universal_hashing:164">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">¯</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </munderover>
      <mrow>
       <msub>
        <mi>h</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo rspace="4.2pt">)</mo>
    </mrow>
    <mo lspace="2.5pt" rspace="5.8pt">mod</mo>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(\bar{x})=\left(\sum_{i=0}^{k-1}h_{i}(x_{i})\right)\,\bmod~{}m
  </annotation>
 </semantics>
</math>

, where each 

<math display="inline" id="Universal_hashing:165">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>i</ci>
    </apply>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{i}\in H
  </annotation>
 </semantics>
</math>

 is chosen independently at random.</p>

<p>If 

<math display="inline" id="Universal_hashing:166">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 is a power of two, one may replace summation by exclusive or.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>In practice, if double-precision arithmetic is available, this is instantiated with the multiply-shift hash family of.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> Initialize the hash function with a vector 

<math display="inline" id="Universal_hashing:167">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>a</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>k</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-¯</ci>
     <ci>a</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{a}=(a_{0},\dots,a_{k-1})
  </annotation>
 </semantics>
</math>

 of random <strong>odd</strong> integers on 

<math display="inline" id="Universal_hashing:168">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2w
  </annotation>
 </semantics>
</math>

 bits each. Then if the number of bins is 

<math display="inline" id="Universal_hashing:169">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mi>M</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=2^{M}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Universal_hashing:170">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>≤</mo>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>M</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\leq w
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Universal_hashing:171">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mover accent="true">
      <mi>a</mi>
      <mo stretchy="false">¯</mo>
     </mover>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">¯</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mo maxsize="120%" minsize="120%">(</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>0</mn>
         </mrow>
         <mrow>
          <mi>k</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </munderover>
        <mrow>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo>⋅</mo>
         <msub>
          <mi>a</mi>
          <mi>i</mi>
         </msub>
        </mrow>
       </mrow>
       <mo maxsize="120%" minsize="120%" rspace="5.8pt">)</mo>
      </mrow>
      <mo lspace="2.5pt" rspace="5.8pt">mod</mo>
      <msup>
       <mn>2</mn>
       <mrow>
        <mn>2</mn>
        <mi>w</mi>
       </mrow>
      </msup>
     </mrow>
     <mo rspace="5.9pt">)</mo>
    </mrow>
    <mi>div</mi>
    <msup>
     <mn>2</mn>
     <mrow>
      <mrow>
       <mn>2</mn>
       <mi>w</mi>
      </mrow>
      <mo>-</mo>
      <mi>M</mi>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>a</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-¯</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>w</ci>
       </apply>
      </apply>
     </apply>
     <ci>div</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="float">2</cn>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>w</ci>
       </apply>
       <ci>M</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{\bar{a}}(\bar{x})=\left(\big(\sum_{i=0}^{k-1}x_{i}\cdot a_{i}\big)~{}\bmod~%
{}2^{2w}\right)\,\,\mathrm{div}\,\,2^{2w-M}
  </annotation>
 </semantics>
</math>

.</p>

<p>It is possible to halve the number of multiplications, which roughly translates to a two-fold speed-up in practice.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> Initialize the hash function with a vector 

<math display="inline" id="Universal_hashing:172">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>a</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>k</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-¯</ci>
     <ci>a</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{a}=(a_{0},\dots,a_{k-1})
  </annotation>
 </semantics>
</math>

 of random <strong>odd</strong> integers on 

<math display="inline" id="Universal_hashing:173">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2w
  </annotation>
 </semantics>
</math>

 bits each. The following hash family is universal:<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>

<p>

<math display="block" id="Universal_hashing:174">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mover accent="true">
      <mi>a</mi>
      <mo stretchy="false">¯</mo>
     </mover>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">¯</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mo maxsize="160%" minsize="160%">(</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>0</mn>
         </mrow>
         <mrow>
          <mo stretchy="false">⌈</mo>
          <mrow>
           <mi>k</mi>
           <mo>/</mo>
           <mn>2</mn>
          </mrow>
          <mo stretchy="false">⌉</mo>
         </mrow>
        </munderover>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mi>x</mi>
            <mrow>
             <mn>2</mn>
             <mi>i</mi>
            </mrow>
           </msub>
           <mo>+</mo>
           <msub>
            <mi>a</mi>
            <mrow>
             <mn>2</mn>
             <mi>i</mi>
            </mrow>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>⋅</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mi>x</mi>
            <mrow>
             <mrow>
              <mn>2</mn>
              <mi>i</mi>
             </mrow>
             <mo>+</mo>
             <mn>1</mn>
            </mrow>
           </msub>
           <mo>+</mo>
           <msub>
            <mi>a</mi>
            <mrow>
             <mrow>
              <mn>2</mn>
              <mi>i</mi>
             </mrow>
             <mo>+</mo>
             <mn>1</mn>
            </mrow>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo maxsize="160%" minsize="160%">)</mo>
      </mrow>
      <mo lspace="2.5pt" rspace="5.8pt">mod</mo>
      <msup>
       <mn>2</mn>
       <mrow>
        <mn>2</mn>
        <mi>w</mi>
       </mrow>
      </msup>
     </mrow>
     <mo rspace="5.9pt">)</mo>
    </mrow>
    <mi>div</mi>
    <msup>
     <mn>2</mn>
     <mrow>
      <mrow>
       <mn>2</mn>
       <mi>w</mi>
      </mrow>
      <mo>-</mo>
      <mi>M</mi>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>a</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-¯</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <ceiling></ceiling>
         <apply>
          <divide></divide>
          <ci>k</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <apply>
           <times></times>
           <cn type="integer">2</cn>
           <ci>i</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <apply>
           <times></times>
           <cn type="integer">2</cn>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <apply>
           <plus></plus>
           <apply>
            <times></times>
            <cn type="integer">2</cn>
            <ci>i</ci>
           </apply>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <apply>
           <plus></plus>
           <apply>
            <times></times>
            <cn type="integer">2</cn>
            <ci>i</ci>
           </apply>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>w</ci>
       </apply>
      </apply>
     </apply>
     <ci>div</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="float">2</cn>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>w</ci>
       </apply>
       <ci>M</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{\bar{a}}(\bar{x})=\left(\Big(\sum_{i=0}^{\lceil k/2\rceil}(x_{2i}+a_{2i})%
\cdot(x_{2i+1}+a_{2i+1})\Big)\bmod~{}2^{2w}\right)\,\,\mathrm{div}\,\,2^{2w-M}
  </annotation>
 </semantics>
</math>

.</p>

<p>If double-precision operations are not available, one can interpret the input as a vector of half-words (

<math display="inline" id="Universal_hashing:175">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>w</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w/2
  </annotation>
 </semantics>
</math>

-bit integers). The algorithm will then use 

<math display="inline" id="Universal_hashing:176">
 <semantics>
  <mrow>
   <mo stretchy="false">⌈</mo>
   <mrow>
    <mi>k</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mo stretchy="false">⌉</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ceiling></ceiling>
    <apply>
     <divide></divide>
     <ci>k</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lceil k/2\rceil
  </annotation>
 </semantics>
</math>

 multiplications, where 

<math display="inline" id="Universal_hashing:177">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 was the number of half-words in the vector. Thus, the algorithm runs at a "rate" of one multiplication per word of input.</p>

<p>The same scheme can also be used for hashing integers, by interpreting their bits as vectors of bytes. In this variant, the vector technique is known as <a href="tabulation_hashing" title="wikilink">tabulation hashing</a> and it provides a practical alternative to multiplication-based universal hashing schemes.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>Strong universality at high speed is also possible.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> Initialize the hash function with a vector 

<math display="inline" id="Universal_hashing:178">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>a</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-¯</ci>
     <ci>a</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>k</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{a}=(a_{0},\dots,a_{k})
  </annotation>
 </semantics>
</math>

 of random integers on 

<math display="inline" id="Universal_hashing:179">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2w
  </annotation>
 </semantics>
</math>

 bits. Compute</p>

<p>

<math display="block" id="Universal_hashing:180">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mover accent="true">
      <mi>a</mi>
      <mo stretchy="false">¯</mo>
     </mover>
    </msub>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>x</mi>
       <mo stretchy="false">¯</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>strong</mi>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>a</mi>
        <mn>0</mn>
       </msub>
       <mo>+</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>0</mn>
         </mrow>
         <mrow>
          <mi>k</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </munderover>
        <mrow>
         <msub>
          <mi>a</mi>
          <mrow>
           <mi>i</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
        </mrow>
       </mrow>
      </mrow>
      <mo lspace="2.5pt" rspace="5.8pt">mod</mo>
      <msup>
       <mn>2</mn>
       <mrow>
        <mn>2</mn>
        <mi>w</mi>
       </mrow>
      </msup>
     </mrow>
     <mo rspace="5.9pt" stretchy="false">)</mo>
    </mrow>
    <mi>div</mi>
    <msup>
     <mn>2</mn>
     <mi>w</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>a</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <ci>x</ci>
      </apply>
      <ci>strong</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">0</cn>
          </apply>
         </apply>
         <apply>
          <minus></minus>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <apply>
           <plus></plus>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>w</ci>
       </apply>
      </apply>
     </apply>
     <ci>div</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="float">2</cn>
      <ci>w</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{\bar{a}}(\bar{x})^{\mathrm{strong}}=(a_{0}+\sum_{i=0}^{k-1}a_{i+1}x_{i}%
\bmod~{}2^{2w})\,\,\mathrm{div}\,\,2^{w}
  </annotation>
 </semantics>
</math>

.</p>

<p>The result is strongly universal on 

<math display="inline" id="Universal_hashing:181">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 bits. Experimentally, it was found to run at 0.2 CPU cycle per byte on recent Intel processors for 

<math display="inline" id="Universal_hashing:182">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>=</mo>
   <mn>32</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>w</ci>
    <cn type="integer">32</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w=32
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="hashing-strings">Hashing strings</h3>

<p>This refers to hashing a <em>variable-sized</em> vector of machine words. If the length of the string can be bounded by a small number, it is best to use the vector solution from above (conceptually padding the vector with zeros up to the upper bound). The space required is the maximal length of the string, but the time to evaluate 

<math display="inline" id="Universal_hashing:183">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(s)
  </annotation>
 </semantics>
</math>

 is just the length of 

<math display="inline" id="Universal_hashing:184">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

. As long as zeroes are forbidden in the string, the zero-padding can be ignored when evaluating the hash function without affecting universality<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a>). Note that if zeroes are allowed in the string, then it might be best to append a fictitious non-zero (e.g., 1) character to all strings prior to padding: this will ensure that universality is not affected.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>

<p>Now assume we want to hash 

<math display="inline" id="Universal_hashing:185">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi mathvariant="normal">ℓ</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-¯</ci>
     <ci>x</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>normal-ℓ</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{x}=(x_{0},\dots,x_{\ell})
  </annotation>
 </semantics>
</math>

, where a good bound on 

<math display="inline" id="Universal_hashing:186">
 <semantics>
  <mi mathvariant="normal">ℓ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-ℓ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

 is not known a priori. A universal family proposed by <a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> treats the string 

<math display="inline" id="Universal_hashing:187">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 as the coefficients of a polynomial modulo a large prime. If 

<math display="inline" id="Universal_hashing:188">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>u</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}\in[u]
  </annotation>
 </semantics>
</math>

, let 

<math display="inline" id="Universal_hashing:189">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>≥</mo>
   <mrow>
    <mi>max</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>m</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>p</ci>
    <apply>
     <max></max>
     <ci>u</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\geq\max\{u,m\}
  </annotation>
 </semantics>
</math>

 be a prime and define:</p>

<p>

<math display="block" id="Universal_hashing:190">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mi>a</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">¯</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>h</mi>
     <mi>int</mi>
    </msub>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mo maxsize="120%" minsize="120%">(</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>0</mn>
         </mrow>
         <mi mathvariant="normal">ℓ</mi>
        </munderover>
        <mrow>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo>⋅</mo>
         <msup>
          <mi>a</mi>
          <mi>i</mi>
         </msup>
        </mrow>
       </mrow>
       <mo maxsize="120%" minsize="120%">)</mo>
      </mrow>
      <mo lspace="2.5pt" rspace="5.8pt">mod</mo>
      <mi>p</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <ci>normal-¯</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>int</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <ci>normal-ℓ</ci>
       </apply>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>a</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{a}(\bar{x})=h_{\mathrm{int}}\left(\big(\sum_{i=0}^{\ell}x_{i}\cdot a^{i}%
\big)\bmod~{}p\right)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Universal_hashing:191">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>p</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>a</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\in[p]
  </annotation>
 </semantics>
</math>

 is uniformly random and 

<math display="inline" id="Universal_hashing:192">
 <semantics>
  <msub>
   <mi>h</mi>
   <mi>int</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <ci>int</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{\mathrm{int}}
  </annotation>
 </semantics>
</math>

 is chosen randomly from a universal family mapping integer domain 

<math display="inline" id="Universal_hashing:193">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>p</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>↦</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>m</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>p</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [p]\mapsto[m]
  </annotation>
 </semantics>
</math>

.</p>

<p>Using properties of modular arithmetic, above can be computed without producing large numbers for large strings as follows:<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>
<div class="sourceCode"><pre class="sourceCode C"><code class="sourceCode c">uint hash(String x, <span class="dt">int</span> a, <span class="dt">int</span> p)
    uint h = INITIAL_VALUE
    <span class="kw">for</span> (uint i=<span class="dv">0</span> ; i &lt; x.length ; ++i)
        h = ((h*a) + x[i]) mod p
    <span class="kw">return</span> h</code></pre></div>

<p>Above algorithm is also known as <em>Multiplicative hash function</em>.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> In practice, the <em>mod</em> operator and the parameter <em>p</em> can be avoided altogether by simply allowing integer to overflow because it is equivalent to <em>mod</em> (<em>Max-Int-Value</em> + 1) in many programming languages. Below table shows values chosen to initialize <em>h</em> and a for some of the popular implementations.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Implementation</p></th>
<th style="text-align: left;">
<p>INITIAL_VALUE</p></th>
<th style="text-align: left;">
<p>a</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Daniel_J._Bernstein" title="wikilink">Bernstein</a>'s hash function <em>djb2</em><a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p></td>
<td style="text-align: left;">
<p>5381</p></td>
<td style="text-align: left;">
<p>33</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>STLPort 4.6.2</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>5</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Brian_Kernighan" title="wikilink">Kernighan</a> and <a href="Dennis_Ritchie" title="wikilink">Ritchie</a>'s hash function<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>31</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><code>java.lang.String.hashCode()</code><a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>31</p></td>
</tr>
</tbody>
</table>

<p>Consider two strings 

<math display="inline" id="Universal_hashing:194">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mo>,</mo>
   <mover accent="true">
    <mi>y</mi>
    <mo stretchy="false">¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <ci>normal-¯</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <ci>y</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{x},\bar{y}
  </annotation>
 </semantics>
</math>

 and let 

<math display="inline" id="Universal_hashing:195">
 <semantics>
  <mi mathvariant="normal">ℓ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-ℓ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

 be length of the longer one; for the analysis, the shorter string is conceptually padded with zeros up to length 

<math display="inline" id="Universal_hashing:196">
 <semantics>
  <mi mathvariant="normal">ℓ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-ℓ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

. A collision before applying 

<math display="inline" id="Universal_hashing:197">
 <semantics>
  <msub>
   <mi>h</mi>
   <mi>int</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <ci>int</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{\mathrm{int}}
  </annotation>
 </semantics>
</math>

 implies that 

<math display="inline" id="Universal_hashing:198">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is a root of the polynomial with coefficients 

<math display="inline" id="Universal_hashing:199">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mo>-</mo>
   <mover accent="true">
    <mi>y</mi>
    <mo stretchy="false">¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <ci>normal-¯</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{x}-\bar{y}
  </annotation>
 </semantics>
</math>

. This polynomial has at most 

<math display="inline" id="Universal_hashing:200">
 <semantics>
  <mi mathvariant="normal">ℓ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-ℓ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

 roots modulo 

<math display="inline" id="Universal_hashing:201">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, so the collision probability is at most 

<math display="inline" id="Universal_hashing:202">
 <semantics>
  <mrow>
   <mi mathvariant="normal">ℓ</mi>
   <mo>/</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>normal-ℓ</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell/p
  </annotation>
 </semantics>
</math>

. The probability of collision through the random 

<math display="inline" id="Universal_hashing:203">
 <semantics>
  <msub>
   <mi>h</mi>
   <mi>int</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <ci>int</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{\mathrm{int}}
  </annotation>
 </semantics>
</math>

 brings the total collision probability to 

<math display="inline" id="Universal_hashing:204">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mi>m</mi>
   </mfrac>
   <mo>+</mo>
   <mfrac>
    <mi mathvariant="normal">ℓ</mi>
    <mi>p</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>m</ci>
    </apply>
    <apply>
     <divide></divide>
     <ci>normal-ℓ</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{m}+\frac{\ell}{p}
  </annotation>
 </semantics>
</math>

. Thus, if the prime 

<math display="inline" id="Universal_hashing:205">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is sufficiently large compared to the length of strings hashed, the family is very close to universal (in <a href="statistical_distance" title="wikilink">statistical distance</a>).</p>
<h4 id="avoiding-modular-arithmetic-1">Avoiding modular arithmetic</h4>

<p>To mitigate the computational penalty of modular arithmetic, two tricks are used in practice:<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>
<ol>
<li>One chooses the prime 

<math display="inline" id="Universal_hashing:206">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 to be close to a power of two, such as a <a href="Mersenne_prime" title="wikilink">Mersenne prime</a>. This allows arithmetic modulo 

<math display="inline" id="Universal_hashing:207">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 to be implemented without division (using faster operations like addition and shifts). For instance, on modern architectures one can work with 

<math display="inline" id="Universal_hashing:208">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mn>61</mn>
    </msup>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <cn type="integer">61</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p=2^{61}-1
  </annotation>
 </semantics>
</math>

, while 

<math display="inline" id="Universal_hashing:209">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

's are 32-bit values.</li>
<li>One can apply vector hashing to blocks. For instance, one applies vector hashing to each 16-word block of the string, and applies string hashing to the 

<math display="inline" id="Universal_hashing:210">
 <semantics>
  <mrow>
   <mo stretchy="false">⌈</mo>
   <mrow>
    <mi>k</mi>
    <mo>/</mo>
    <mn>16</mn>
   </mrow>
   <mo stretchy="false">⌉</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ceiling></ceiling>
    <apply>
     <divide></divide>
     <ci>k</ci>
     <cn type="integer">16</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lceil k/16\rceil
  </annotation>
 </semantics>
</math>

 results. Since the slower string hashing is applied on a substantially smaller vector, this will essentially be as fast as vector hashing.</li>
<li>One chooses a power-of-two as the divisor, allowing arithmetic modulo 

<math display="inline" id="Universal_hashing:211">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>w</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{w}
  </annotation>
 </semantics>
</math>

 to be implemented without division (using faster operations of <a href="bit_masking" title="wikilink">bit masking</a>). The <a href="UMAC#NH_hash-function_family" title="wikilink"> NH hash-function family</a> takes this approach.</li>
</ol>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="K-independent_hashing" title="wikilink">K-independent hashing</a></li>
<li><a href="Rolling_hashing" title="wikilink">Rolling hashing</a></li>
<li><a href="Tabulation_hashing" title="wikilink">Tabulation hashing</a></li>
<li><a href="Min-wise_independence" title="wikilink">Min-wise independence</a></li>
<li><a href="Universal_one-way_hash_function" title="wikilink">Universal one-way hash function</a></li>
<li><a href="Low-discrepancy_sequence" title="wikilink">Low-discrepancy sequence</a></li>
<li><a href="Perfect_hashing" title="wikilink">Perfect hashing</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://opendatastructures.org/versions/edition-0.1e/ods-java/5_1_ChainedHashTable_Hashin.html#SECTION00811000000000000000">Open Data Structures - Section 5.1.1 - Multiplicative Hashing</a></li>
</ul>

<p>"</p>

<p><a href="Category:Cryptographic_hash_functions" title="wikilink">Category:Cryptographic hash functions</a> <a class="uri" href="Category:Hashing" title="wikilink">Category:Hashing</a> <a href="Category:Search_algorithms" title="wikilink">Category:Search algorithms</a> <a href="Category:Computational_complexity_theory" title="wikilink">Category:Computational complexity theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">David Wagner, ed. <a href="https://books.google.com/books?id=11BsCQAAQBAJ">"Advances in Cryptology - CRYPTO 2008"</a>. p. 145.<a href="#fnref4">↩</a></li>
<li id="fn5">Jean-Philippe Aumasson, Willi Meier, Raphael Phan, Luca Henzen. <a href="https://books.google.com/books?id=nhPmBQAAQBAJ">"The Hash Function BLAKE"</a>. 2014. p. 10.<a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15">, section 5.3<a href="#fnref15">↩</a></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18">, Equation 1<a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"></li>
</ol>
</section>
</body>

