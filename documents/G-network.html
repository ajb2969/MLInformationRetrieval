<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="857">G-network</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>G-network</h1>
<hr/>

<p>In <a href="queueing_theory" title="wikilink">queueing theory</a>, a discipline within the mathematical <a href="probability_theory" title="wikilink">theory of probability</a>, a <strong>G-network</strong> (<strong>generalized queueing network</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> or <strong>Gelenbe network</strong><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a>) is an open network of G-queues first introduced by <a href="Erol_Gelenbe" title="wikilink">Erol Gelenbe</a> as a model for queueing systems with specific control functions, such as traffic re-routing or traffic destruction, as well as a model for <a href="neural_networks" title="wikilink">neural networks</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> A G-queue is a network of queues with several types of novel and useful customers:</p>
<ul>
<li><em>positive</em> customers, which arrive from other queues or arrive externally as Poisson arrivals, and obey standard service and routing disciplines as in conventional network models,</li>
<li><em>negative</em> customers, which arrive from another queue, or which arrive externally as Poisson arrivals, and remove (or 'kill') customers in a non-empty queue, representing the need to remove traffic when the network is congested, including the removal of "batches" of customers <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></li>
<li>"triggers", which arrive from other queues or from outside the network, and which displace customers and move them to other queues</li>
</ul>

<p>A <a href="product_form_solution" title="wikilink">product form solution</a> superficially similar in form to <a href="Jackson's_theorem_(queueing_theory)" title="wikilink">Jackson's theorem</a>, but which requires the solution of a system of non-linear equations for the traffic flows, exists for the stationary distribution of G-networks while the traffic equations of a G-network are in fact surprisingly non-linear, and the model does not obey partial balance. This broke previous assumptions that partial balance was a necessary condition for a product form solution. A powerful property of G-networks is that they are universal approximators for continuous and bounded functions, so that they can be used to approximate quite general input-output behaviours.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="definition">Definition</h2>

<p>A network of <em>m</em> interconnected queues is a <em>G-network</em> if</p>
<ol>
<li>each queue has one server, who serves at rate <em>μ<sub>i</sub></em>,</li>
<li>external arrivals of positive customers or of triggers or resets form <a href="Poisson_processes" title="wikilink">Poisson processes</a> of rate 

<math display="inline" id="G-network:0">
 <semantics>
  <msub>
   <mi mathvariant="normal">Λ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Λ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle{\Lambda_{i}}
  </annotation>
 </semantics>
</math>

 for positive customers, while triggers and resets, including negative customers, form a Poisson process of rate 

<math display="inline" id="G-network:1">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle{\lambda_{i}}
  </annotation>
 </semantics>
</math>

,</li>
<li>on completing service a customer moves from queue <em>i</em> to queue <em>j</em> as a positive customer with probability 

<math display="inline" id="G-network:2">
 <semantics>
  <msubsup>
   <mi>p</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
   <mo>+</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle{p_{ij}^{+}}
  </annotation>
 </semantics>
</math>

, as a trigger or reset with probability 

<math display="inline" id="G-network:3">
 <semantics>
  <msubsup>
   <mi>p</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
   <mo>-</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <minus></minus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle{p_{ij}^{-}}
  </annotation>
 </semantics>
</math>

 and departs the network with probability 

<math display="inline" id="G-network:4">
 <semantics>
  <msub>
   <mi>d</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle{d_{i}}
  </annotation>
 </semantics>
</math>

,</li>
<li>on arrival to a queue, a positive customer acts as usual and increases the queue length by 1,</li>
<li>on arrival to a queue, the negative customer reduces the length of the queue by some random number (if there is at least one positive customer present at the queue), while a trigger moves a customer probabilistically to another queue and a reset sets the state of the queue to its steady-state if the queue is empty when the reset arrives. All triggers, negative customers and resets disappear after they have taken their action, so that they are in fact "control" signals in the network,</li>
</ol>
<ul>
<li>note that normal customers leaving a queue can become triggers or resets and negative customers when they visit the next queue.</li>
</ul>

<p>A queue in such a network is known as a <strong>G-queue</strong>.</p>
<h2 id="stationary-distribution">Stationary distribution</h2>

<p>Define the utilization at each node,</p>

<p>

<math display="block" id="G-network:5">
 <semantics>
  <mrow>
   <msub>
    <mi>ρ</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <msubsup>
     <mi>λ</mi>
     <mi>i</mi>
     <mo>+</mo>
    </msubsup>
    <mrow>
     <msub>
      <mi>μ</mi>
      <mi>i</mi>
     </msub>
     <mo>+</mo>
     <msubsup>
      <mi>λ</mi>
      <mi>i</mi>
      <mo>-</mo>
     </msubsup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ρ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>λ</ci>
       <plus></plus>
      </apply>
      <ci>i</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>λ</ci>
        <minus></minus>
       </apply>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{i}=\frac{\lambda^{+}_{i}}{\mu_{i}+\lambda^{-}_{i}}
  </annotation>
 </semantics>
</math>

</p>

<p>where the 

<math display="inline" id="G-network:6">
 <semantics>
  <mrow>
   <msubsup>
    <mi>λ</mi>
    <mi>i</mi>
    <mo>+</mo>
   </msubsup>
   <mo>,</mo>
   <msubsup>
    <mi>λ</mi>
    <mi>i</mi>
    <mo>-</mo>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>λ</ci>
      <plus></plus>
     </apply>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>λ</ci>
      <minus></minus>
     </apply>
     <ci>i</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle{\lambda^{+}_{i},\lambda^{-}_{i}}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="G-network:7">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>m</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle{i=1,\ldots,m}
  </annotation>
 </semantics>
</math>

 satisfy</p>

<p>Then writing (<em>n</em><sub>1</sub>, … ,<em>n</em><sub>m</sub>) for the state of the network (with queue length <em>n</em><sub><em>i</em></sub> at node <em>i</em>), if a unique non-negative solution 

<math display="inline" id="G-network:8">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msubsup>
    <mi>λ</mi>
    <mi>i</mi>
    <mo>+</mo>
   </msubsup>
   <mo>,</mo>
   <msubsup>
    <mi>λ</mi>
    <mi>i</mi>
    <mo>-</mo>
   </msubsup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>λ</ci>
      <plus></plus>
     </apply>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>λ</ci>
      <minus></minus>
     </apply>
     <ci>i</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle{(\lambda^{+}_{i},\lambda^{-}_{i})}
  </annotation>
 </semantics>
</math>

 exists to the above equations () and () such that <em>ρ</em><sub><em>i</em></sub> for all <em>i</em> then the stationary probability distribution π exists and is given by</p>

<p>

<math display="block" id="G-network:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>π</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>n</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>n</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>n</mi>
       <mi>m</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>m</mi>
     </munderover>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <msub>
         <mi>ρ</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <msubsup>
       <mi>ρ</mi>
       <mi>i</mi>
       <msub>
        <mi>n</mi>
        <mi>i</mi>
       </msub>
      </msubsup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>π</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>m</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ρ</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ρ</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(n_{1},n_{2},\ldots,n_{m})=\prod_{i=1}^{m}(1-\rho_{i})\rho_{i}^{n_{i}}.
  </annotation>
 </semantics>
</math>

</p>
<h3 id="proof">Proof</h3>

<p>It is sufficient to show 

<math display="inline" id="G-network:10">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 satisfies the <a href="balance_equation" title="wikilink">global balance equations</a> which, quite differently from Jackson networks are non-linear. We note that the model also allows for multiple classes.</p>

<p>G-networks have been used in a wide range of applications, including to represent Gene Regulatory Networks, the mix of control and payload in packet networks, neural networks, and the representation of colour images and medical images such as Magnetic Resonance Images.</p>
<h2 id="response-time-distribution">Response time distribution</h2>

<p>The response time is the length of time a customer spends in the system. The response time distribution for a single G-queue is known<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> where customers are served using a <a href="first_come_first_served" title="wikilink">FCFS</a> discipline at rate <em>μ</em>, with positive arrivals at rate <em>λ</em><sup>+</sup> and negative arrivals at rate <em>λ</em><sup>−</sup> which kill customers from the end of the queue. The <a href="Laplace_transform" title="wikilink">Laplace transform</a> of response time distribution in this situation is<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>

<math display="block" id="G-network:11">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>W</mi>
     <mo>∗</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mi>μ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mi>ρ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <msup>
      <mi>λ</mi>
      <mo>+</mo>
     </msup>
    </mfrac>
    <mfrac>
     <mrow>
      <mrow>
       <mi>s</mi>
       <mo>+</mo>
       <mi>λ</mi>
       <mo>+</mo>
       <mrow>
        <mi>μ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mi>ρ</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>-</mo>
      <msqrt>
       <mrow>
        <msup>
         <mrow>
          <mo stretchy="false">[</mo>
          <mrow>
           <mi>s</mi>
           <mo>+</mo>
           <mi>λ</mi>
           <mo>+</mo>
           <mrow>
            <mi>μ</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <mn>1</mn>
              <mo>-</mo>
              <mi>ρ</mi>
             </mrow>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mrow>
          <mo stretchy="false">]</mo>
         </mrow>
         <mn>2</mn>
        </msup>
        <mo>-</mo>
        <mrow>
         <mn>4</mn>
         <msup>
          <mi>λ</mi>
          <mo>+</mo>
         </msup>
         <msup>
          <mi>λ</mi>
          <mo>-</mo>
         </msup>
        </mrow>
       </mrow>
      </msqrt>
     </mrow>
     <mrow>
      <mrow>
       <msup>
        <mi>λ</mi>
        <mo>-</mo>
       </msup>
       <mo>-</mo>
       <msup>
        <mi>λ</mi>
        <mo>+</mo>
       </msup>
       <mo>-</mo>
       <mrow>
        <mi>μ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mi>ρ</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mi>s</mi>
      </mrow>
      <mo>+</mo>
      <msqrt>
       <mrow>
        <msup>
         <mrow>
          <mo stretchy="false">[</mo>
          <mrow>
           <mi>s</mi>
           <mo>+</mo>
           <mi>λ</mi>
           <mo>+</mo>
           <mrow>
            <mi>μ</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <mn>1</mn>
              <mo>-</mo>
              <mi>ρ</mi>
             </mrow>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mrow>
          <mo stretchy="false">]</mo>
         </mrow>
         <mn>2</mn>
        </msup>
        <mo>-</mo>
        <mrow>
         <mn>4</mn>
         <msup>
          <mi>λ</mi>
          <mo>+</mo>
         </msup>
         <msup>
          <mi>λ</mi>
          <mo>-</mo>
         </msup>
        </mrow>
       </mrow>
      </msqrt>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>W</ci>
      <ci>normal-∗</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>μ</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>ρ</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>λ</ci>
       <plus></plus>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <ci>s</ci>
        <ci>λ</ci>
        <apply>
         <times></times>
         <ci>μ</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
          <ci>ρ</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <root></root>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="latexml">delimited-[]</csymbol>
           <apply>
            <plus></plus>
            <ci>s</ci>
            <ci>λ</ci>
            <apply>
             <times></times>
             <ci>μ</ci>
             <apply>
              <minus></minus>
              <cn type="integer">1</cn>
              <ci>ρ</ci>
             </apply>
            </apply>
           </apply>
          </apply>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">4</cn>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>λ</ci>
           <plus></plus>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>λ</ci>
           <minus></minus>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>λ</ci>
         <minus></minus>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>λ</ci>
         <plus></plus>
        </apply>
        <apply>
         <times></times>
         <ci>μ</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
          <ci>ρ</ci>
         </apply>
        </apply>
        <ci>s</ci>
       </apply>
       <apply>
        <root></root>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="latexml">delimited-[]</csymbol>
           <apply>
            <plus></plus>
            <ci>s</ci>
            <ci>λ</ci>
            <apply>
             <times></times>
             <ci>μ</ci>
             <apply>
              <minus></minus>
              <cn type="integer">1</cn>
              <ci>ρ</ci>
             </apply>
            </apply>
           </apply>
          </apply>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">4</cn>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>λ</ci>
           <plus></plus>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>λ</ci>
           <minus></minus>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{\ast}(s)=\frac{\mu(1-\rho)}{\lambda^{+}}\frac{s+\lambda+\mu(1-\rho)-\sqrt{[%
s+\lambda+\mu(1-\rho)]^{2}-4\lambda^{+}\lambda^{-}}}{\lambda^{-}-\lambda^{+}-%
\mu(1-\rho)-s+\sqrt{[s+\lambda+\mu(1-\rho)]^{2}-4\lambda^{+}\lambda^{-}}}
  </annotation>
 </semantics>
</math>

 where <em>λ</em> = <em>λ</em><sup>+</sup> + <em>λ</em><sup>−</sup> and <em>ρ</em> = <em>λ</em><sup>+</sup>/(<em>λ</em><sup>−</sup> + <em>μ</em>), requiring <em>ρ</em> </p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Stochastic_processes" title="wikilink">Category:Stochastic processes</a> <a href="Category:Queueing_theory" title="wikilink">Category:Queueing theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"></li>
</ol>
</section>
</body>
</html>
