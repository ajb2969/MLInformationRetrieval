<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1606">Quadratic probing</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Quadratic probing</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p><strong>Quadratic probing</strong> is an open addressing scheme in <a href="computer_programming" title="wikilink">computer programming</a> for resolving collisions in <a href="hash_table" title="wikilink">hash tables</a>—when an incoming data's hash value indicates it should be stored in an already-occupied slot or bucket. Quadratic probing operates by taking the original hash index and adding successive values of an arbitrary <a href="quadratic_polynomial" title="wikilink">quadratic polynomial</a> until an open slot is found.</p>

<p>For a given hash value, the indices generated by <a href="linear_probing" title="wikilink">linear probing</a> are as follows:</p>

<p>

<math display="inline" id="Quadratic_probing:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>H</mi>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>H</mi>
    <mo>+</mo>
    <mn>3</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>H</mi>
    <mo>+</mo>
    <mn>4</mn>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mi>H</mi>
    <mo>+</mo>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <plus></plus>
     <ci>H</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <plus></plus>
     <ci>H</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <ci>H</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <plus></plus>
     <ci>H</ci>
     <cn type="integer">4</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <plus></plus>
     <ci>H</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H+1,H+2,H+3,H+4,...,H+k
  </annotation>
 </semantics>
</math>

</p>

<p>This method results in <a href="primary_clustering" title="wikilink">primary clustering</a>, and as the cluster grows larger, the search for those items hashing within the cluster becomes less efficient.</p>

<p>An example sequence using quadratic probing is:</p>

<p>

<math display="inline" id="Quadratic_probing:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mo>+</mo>
    <msup>
     <mn>1</mn>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>H</mi>
    <mo>+</mo>
    <msup>
     <mn>2</mn>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>H</mi>
    <mo>+</mo>
    <msup>
     <mn>3</mn>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>H</mi>
    <mo>+</mo>
    <msup>
     <mn>4</mn>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mi>H</mi>
    <mo>+</mo>
    <msup>
     <mi>k</mi>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <plus></plus>
     <ci>H</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>H</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>H</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">3</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>H</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">4</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <plus></plus>
     <ci>H</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>k</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H+1^{2},H+2^{2},H+3^{2},H+4^{2},...,H+k^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>Quadratic probing can be a more efficient algorithm in a closed hash table, since it better avoids the clustering problem that can occur with linear probing, although it is not immune. It also provides good memory caching because it preserves some <a href="locality_of_reference" title="wikilink">locality of reference</a>; however, linear probing has greater locality and, thus, better cache performance.</p>

<p>Quadratic probing is used in the <a href="Berkeley_Fast_File_System" title="wikilink">Berkeley Fast File System</a> to allocate free blocks. The allocation routine chooses a new cylinder-group when the current is nearly full using quadratic probing, because of the speed it shows in finding unused cylinder-groups.</p>
<h2 id="quadratic-function">Quadratic function</h2>

<p>Let h(k) be a <a href="hash_function" title="wikilink">hash function</a> that maps an element k to an integer in [0,m-1], where m is the size of the table. Let the i<sup>th</sup> probe position for a value k be given by the function</p>

<p>

<math display="block" id="Quadratic_probing:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo>,</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>h</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>k</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>c</mi>
        <mn>1</mn>
       </msub>
       <mi>i</mi>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>c</mi>
        <mn>2</mn>
       </msub>
       <msup>
        <mi>i</mi>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>m</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <interval closure="open">
      <ci>k</ci>
      <ci>i</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>i</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(k,i)=(h(k)+c_{1}i+c_{2}i^{2})\;\;(\mathop{{\rm mod}}m)
  </annotation>
 </semantics>
</math>

 where c<sub>2</sub> ≠ 0. If c<sub>2</sub> = 0, then h(k,i) degrades to a <a href="linear_probing" title="wikilink">linear probe</a>. For a given <a href="hash_table" title="wikilink">hash table</a>, the values of c<sub>1</sub> and c<sub>2</sub> remain constant.</p>

<p><strong>Examples:</strong></p>
<ul>
<li>If 

<math display="inline" id="Quadratic_probing:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo>,</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>h</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>k</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mi>i</mi>
      <mo>+</mo>
      <msup>
       <mi>i</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>m</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <interval closure="open">
      <ci>k</ci>
      <ci>i</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>k</ci>
      </apply>
      <ci>i</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>i</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(k,i)=(h(k)+i+i^{2})\;\;(\mathop{{\rm mod}}m)
  </annotation>
 </semantics>
</math>

, then the probe sequence will be 

<math display="inline" id="Quadratic_probing:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>6</mn>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>k</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>k</ci>
     </apply>
     <cn type="integer">6</cn>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(k),h(k)+2,h(k)+6,...
  </annotation>
 </semantics>
</math>

</li>
<li>For m = 2<sup>n</sup>, a good choice for the constants are c<sub>1</sub> = c<sub>2</sub> = 1/2, as the values of h(k,i) for i in [0,m-1] are all distinct. This leads to a probe sequence of 

<math display="inline" id="Quadratic_probing:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>3</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>6</mn>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>k</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>k</ci>
     </apply>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>k</ci>
     </apply>
     <cn type="integer">6</cn>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(k),h(k)+1,h(k)+3,h(k)+6,...
  </annotation>
 </semantics>
</math>

 where the values increase by 1, 2, 3, ...</li>
<li>For prime m &gt; 2, most choices of c<sub>1</sub> and c<sub>2</sub> will make h(k,i) distinct for i in [0, (m-1)/2]. Such choices include c<sub>1</sub> = c<sub>2</sub> = 1/2, c<sub>1</sub> = c<sub>2</sub> = 1, and c<sub>1</sub> = 0, c<sub>2</sub> = 1. Because there are only about m/2 distinct probes for a given element, it is difficult to guarantee that insertions will succeed when the load factor is &gt; 1/2.</li>
</ul>
<h2 id="quadratic-probing-insertion">Quadratic probing insertion</h2>

<p>The problem, here, is to insert a key at an available key space in a given Hash Table using quadratic probing.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h3 id="algorithm-to-insert-key-in-hash-table">Algorithm to insert key in hash table</h3>

<p><code>
  1. Get the key k
  2. Set counter j = 0
  3. Compute hash function h[k] = k % SIZE
  4. If hashtable[h[k]] is empty
          (4.1) Insert key k at hashtable[h[k]]
          (4.2) Stop
     Else
         (4.3) The key space at hashtable[h[k]] is occupied, so we need to find the next available key space
         (4.4) Increment j
         (4.5) Compute new hash function h[k] = ( k + j * j ) % SIZE
         (4.6) Repeat Step 4 till j is equal to the SIZE of hash table
  5. The hash table is full
  6. Stop
</code></p>
<h3 id="c-function-for-key-insertion">C function for key insertion</h3>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">
<span class="dt">int</span> quadratic_probing_insert(<span class="dt">int</span> *hashtable, <span class="dt">int</span> key, <span class="dt">int</span> *empty){
    <span class="co">/* hashtable[] is an integer hash table; empty[] is another array which indicates whether the key space is occupied;</span>
<span class="co">       If an empty key space is found, the function returns the index of the bucket where the key is inserted, otherwise it </span>
<span class="co">       returns (-1) if no empty key space is found */</span>

    <span class="dt">int</span> j = <span class="dv">0</span>, hk;
    hk = key  % SIZE;
    <span class="kw">while</span>(j &lt; SIZE) {
        <span class="kw">if</span>(empty[hk] == <span class="dv">1</span>){
            hashtable[hk] = key;
            empty[hk] = <span class="dv">0</span>;
            <span class="kw">return</span> (hk);
        }
        j++;
        hk = (key + j * j) % SIZE;
    }
    <span class="kw">return</span> (-<span class="dv">1</span>);
}</code></pre></div>
<h2 id="quadratic-probing-search">Quadratic probing search</h2>
<h3 id="algorithm-to-search-element-in-hash-table">Algorithm to search element in hash table</h3>

<p><code>
  1. Get the key k to be searched
  2. Set counter j = 0
  3. Compute hash function h[k] = k % SIZE
  4. If the key space at hashtable[h[k]] is occupied
          (4.1) Compare the element at hashtable[h[k]] with the key k.
          (4.2) If they are equal
          (4.2.1) The key is found at the bucket h[k]
          (4.2.2) Stop
     Else
          (4.3) The element might be placed at the next location given by the quadratic function
          (4.4) Increment j
          (4.5) Compute new hash function h[k] = ( k + j * j ) % SIZE
          (4.6) Repeat Step 4 till j is greater than SIZE of hash table
  5. The key was not found in the hash table
  6. Stop <lel>
</lel></code></p>
<h3 id="c-function-for-key-searching">C function for key searching</h3>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> quadratic_probing_search(<span class="dt">int</span> *hashtable, <span class="dt">int</span> key, <span class="dt">int</span> *empty)
{
    <span class="co">/* If the key is found in the hash table, the function returns the index of the hashtable where the key is inserted, otherwise it </span>
<span class="co">       returns (-1) if the key is not found */</span> 

    <span class="dt">int</span> j = <span class="dv">0</span>, hk;
    hk = key  % SIZE;
    <span class="kw">while</span>(j &lt; SIZE) 
    {
        <span class="kw">if</span>((empty[hk] == <span class="dv">0</span>) &amp;&amp; (hashtable[hk] == key))
            <span class="kw">return</span> (hk);
        j++;
        hk = (key + j * j) % SIZE;
    }
    <span class="kw">return</span> (-<span class="dv">1</span>);
}</code></pre></div>
<h2 id="limitations">Limitations</h2>

<p><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> For linear probing it is a bad idea to let the hash table get nearly full, because performance is degraded as the hash table gets filled. In the case of quadratic probing, the situation is even more drastic. With the exception of the triangular number case for a power-of-two-sized hash table, there is no guarantee of finding an empty cell once the table gets more than half full, or even before the table gets half full if the table size is not prime. This is because at most half of the table can be used as alternative locations to resolve collisions. If the hash table size is b (a prime greater than 3), it can be proven that the first 

<math display="inline" id="Quadratic_probing:6">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>b</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b/2
  </annotation>
 </semantics>
</math>

 alternative locations including the initial location h(k) are all distinct and unique. Suppose, we assume two of the alternative locations to be given by 

<math display="inline" id="Quadratic_probing:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mspace width="veryverythickmathspace">
   </mspace>
   <mrow>
    <mo lspace="8.1pt" stretchy="false">(</mo>
    <mrow>
     <mo>mod</mo>
     <mi>b</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">annotated</csymbol>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <ci>pmod</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(k)+x^{2}\;\;(\mathop{{\rm mod}}b)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quadratic_probing:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <msup>
     <mi>y</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mspace width="veryverythickmathspace">
   </mspace>
   <mrow>
    <mo lspace="8.1pt" stretchy="false">(</mo>
    <mrow>
     <mo>mod</mo>
     <mi>b</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">annotated</csymbol>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <ci>pmod</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(k)+y^{2}\;\;(\mathop{{\rm mod}}b)
  </annotation>
 </semantics>
</math>

, where 0 ≤ x, y ≤ (b / 2). If these two locations point to the same key space, but x ≠ y. Then the following would have to be true,</p>

<p><code>   </code>

<math display="inline" id="Quadratic_probing:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>k</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <msup>
      <mi>y</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(k)+x^{2}=h(k)+y^{2}\;\;(\mathop{{\rm mod}}b)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Quadratic_probing:10">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>y</mi>
     <mn>2</mn>
    </msup>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}=y^{2}\;\;(\mathop{{\rm mod}}b)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Quadratic_probing:11">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <msup>
     <mi>y</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <ci>pmod</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}-y^{2}=0\;\;(\mathop{{\rm mod}}b)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Quadratic_probing:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>+</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <ci>pmod</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x-y)(x+y)=0\;\;(\mathop{{\rm mod}}b)
  </annotation>
 </semantics>
</math>

 As b (table size) is a prime greater than 3, either (x - y) or (x + y) has to be equal to zero. Since x and y are unique, (x - y) cannot be zero. Also, since 0 ≤ x, y ≤ (b / 2), (x + y) cannot be zero.</p>

<p>Thus, by contradiction, it can be said that the first (b / 2) alternative locations after h(k) are unique. So an empty key space can always be found as long as at most (b / 2) locations are filled, i.e., the hash table is not more than half full.</p>
<h3 id="alternating-sign">Alternating sign</h3>

<p>If the sign of the offset is alternated (e.g. +1, -4, +9, -16 etc.), and if the number of buckets is a prime number p congruent to 3 modulo 4 (i.e. one of 3, 7, 11, 19, 23, 31 and so on), then the first p offsets will be unique modulo p.</p>

<p>In other words, a permutation of 0 through p-1 is obtained, and, consequently, a free bucket will always be found as long as there exists at least one.</p>

<p>The insertion algorithm only receives a minor modification (but do note that SIZE has to be a suitable prime number as explained above): <code>
 1. Get the key k
 2. Set counter j = 0
 3. Compute hash function h[k] = k % SIZE
 4. If hashtable[h[k]] is empty
         (4.1) Insert key k at hashtable[h[k]]
         (4.2) Stop
    Else
        (4.3) The key space at hashtable[h[k]] is occupied, so we need to find the next available key space
        (4.4) Increment j
        (4.5) Compute new hash function h[k]. If j is odd, then
              h[k] = ( k + j * j ) % SIZE, else h[k] = ( k - j * j ) % SIZE
        (4.6) Repeat Step 4 till j is equal to the SIZE of hash table
 5. The hash table is full
 6. Stop
</code></p>

<p>The search algorithm is modified likewise.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Hash_tables" title="wikilink">Hash tables</a></li>
<li><a href="Hash_collision" title="wikilink">Hash collision</a></li>
<li><a href="Double_hashing" title="wikilink">Double hashing</a></li>
<li><a href="Linear_probing" title="wikilink">Linear probing</a></li>
<li><a href="Hash_function" title="wikilink">Hash function</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://research.cs.vt.edu/AVresearch/hashing/quadratic.php">Tutorial/quadratic probing</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Hashing" title="wikilink">Category:Hashing</a> <a href="Category:Articles_with_example_C_code" title="wikilink">Category:Articles with example C code</a> <a href="Category:Articles_with_example_Java_code" title="wikilink">Category:Articles with example Java code</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>

