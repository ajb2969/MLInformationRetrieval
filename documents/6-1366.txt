   Unifying Theories of Programming      Unifying Theories of Programming   Unifying Theories of Programming ( UTP ) in computer science deals with program semantics . It shows how denotational semantics , operational semantics and algebraic semantics can be combined in a unified framework for the formal specification , design and implementation of programs and computer systems .  The book of this title by C.A.R. Hoare and He Jifeng was published in the Prentice Hall International Series in Computer Science in 1998 and is now freely available on the web. 1  Theories  The semantic foundation of the UTP is the first-order predicate calculus , augmented with fixed point constructs from second-order logic. Following the tradition of Eric Hehner , programs are predicates in the UTP, and there is no distinction between programs and specifications at the semantic level. In the words of Hoare :   A computer program is identified with the strongest predicate describing every relevant observation that can be made of the behaviour of a computer executing that program. 2   In UTP parlance, a theory is a model of a particular programming paradigm. A UTP theory is composed of three ingredients:   an alphabet , which is a set of variable names denoting the attributes of the paradigm that can be observed by an external entity;  a signature , which is the set of programming language constructs intrinsic to the paradigm; and  a collection of healthiness conditions , which define the space of programs that fit within the paradigm. These healthiness conditions are typically expressed as monotonic  idempotent  predicate transformers .   Program refinement is an important concept in the UTP. A program    P  1     subscript  P  1    P_{1}   is refined by    P  2     subscript  P  2    P_{2}   if and only if every observation that can be made of    P  2     subscript  P  2    P_{2}   is also an observation of    P  1     subscript  P  1    P_{1}   . The definition of refinement is common across UTP theories:       P  1   ‚äë   P  2   if and only if   [   P  2   ‚áí   P  1   ]      fragments   subscript  P  1   square-image-of-or-equals   subscript  P  2    if and only if    fragments  normal-[   subscript  P  2   normal-‚áí   subscript  P  1   normal-]     P_{1}\sqsubseteq P_{2}\quad\text{if and only if}\quad\left[P_{2}\Rightarrow P_%
 {1}\right]     where    [  X  ]     delimited-[]  X    \left[X\right]   denotes 3 the universal closure of all variables in the alphabet.  Relations  The most basic UTP theory is the alphabetised predicate calculus, which has no alphabet restrictions or healthiness conditions. The theory of relations is slightly more specialised, since a relation's alphabet may consist of only:   undecorated variables (   v   v   v   ), modelling an observation of the program at the start of its execution; and  primed variables (    v  ‚Ä≤     superscript  v  normal-‚Ä≤    v^{\prime}   ), modelling an observation of the program at a later stage of its execution.   Some common language constructs can be defined in the theory of relations as follows:   The skip statement, which does not alter the program state in any way, is modelled as the relational identity:       ùê¨ùê§ùê¢ùê©  ‚â°   v  ‚Ä≤   =  v        ùê¨ùê§ùê¢ùê©   superscript  v  normal-‚Ä≤        v     \mathbf{skip}\equiv v^{\prime}=v      The assignment of value   E   E   E   to a variable   a   a   a   is modelled as setting    a  ‚Ä≤     superscript  a  normal-‚Ä≤    a^{\prime}   to   E   E   E   and keeping all other variables (denoted by   u   u   u   ) constant:       a  :=  E  ‚â°   a  ‚Ä≤   =   E  ‚àß   u  ‚Ä≤    =  u       assign  a  E        superscript  a  normal-‚Ä≤          E   superscript  u  normal-‚Ä≤         u     a:=E\equiv a^{\prime}=E\land u^{\prime}=u      The sequential composition of two programs is just relational composition of intermediate state:         P  1   ;   P  2    ‚â°    ‚àÉ     v  0   ‚àô   P  1     [    v  0   /   v  ‚Ä≤    ]     ‚àß    P  2    [    v  0   /  v   ]           subscript  P  1    subscript  P  2           normal-‚àô   subscript  v  0    subscript  P  1     delimited-[]     subscript  v  0    superscript  v  normal-‚Ä≤          subscript  P  2    delimited-[]     subscript  v  0   v        P_{1};P_{2}\equiv\exists v_{0}\bullet P_{1}[v_{0}/v^{\prime}]\land P_{2}[v_{0}%
 /v]      Non-deterministic choice between programs is their greatest lower bound:         P  1   ‚äì   P  2    ‚â°    P  1   ‚à®   P  2         square-intersection   subscript  P  1    subscript  P  2       subscript  P  1    subscript  P  2      P_{1}\sqcap P_{2}\equiv P_{1}\lor P_{2}      Conditional choice between programs is written using infix notation:          P  1   ‚óÅ  C   ‚ñ∑   P  2    ‚â°    (   C  ‚àß   P  1    )   ‚à®   (    ¬¨  C   ‚àß   P  2    )         normal-‚ñ∑   normal-‚óÅ   subscript  P  1   C    subscript  P  2        C   subscript  P  1         C    subscript  P  2       P_{1}\triangleleft C\triangleright P_{2}\equiv(C\land P_{1})\lor(\lnot C\land P%
 _{2})      A semantics for recursion is given by the least fixed point     Œº  ùêÖ      Œº  ùêÖ    \mu\mathbf{F}   of a monotonic predicate transformer   ùêÖ   ùêÖ   \mathbf{F}   :          Œº  X   ‚àô  ùêÖ    (  X  )    ‚â°   ‚äì   {  X  ‚à£    ùêÖ   (  X  )    ‚äë  X   }           normal-‚àô    Œº  X   ùêÖ   X    square-intersection   conditional-set  X   square-image-of-or-equals    ùêÖ  X   X       \mu X\bullet\mathbf{F}(X)\equiv\sqcap\left\{X\mid\mathbf{F}(X)\sqsubseteq X\right\}     References  Further reading   Jim Woodcock and Ana Cavalcanti. A tutorial introduction to designs in Unifying Theories of Programming. In Integrated Formal Methods , volume 2999 of Lecture Notes in Computer Science , pages 40‚Äì66. Springer Berlin / Heidelberg, 2004. ISBN 978-3-540-21377-2.  Ana Cavalcanti and Jim Woodcock. A tutorial introduction to CSP in Unifying Theories of Programming. In Refinement Techniques in Software Engineering , volume 3167 of Lecture Notes in Computer Science, pages 220‚Äì268. Springer Berlin / Heidelberg, 2006.   External links   UTP book website   "  Category:1998 books  Category:Computer science books  Category:Formal methods publications     ‚Ü©  C.A.R. Hoare , Programming: Sorcery or science? IEEE Software , 1(2): 5‚Äì16, April 1984. ISSN 0740-7459. doi: 10.1109/MS.1984.234042. ‚Ü©  Edsger W. Dijkstra and Carel S. Scholten . Predicate calculus and program semantics. Texts and Monographs in Computer Science. Springer-Verlag New York, Inc., New York, NY, USA, 1990. ISBN 0-387-96957-8. ‚Ü©     