<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1880">Additive category</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Additive category</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, specifically in <a href="category_theory" title="wikilink">category theory</a>, an <strong>additive category</strong> is a <a href="preadditive_category" title="wikilink">preadditive category</a> <strong>C</strong> admitting all <a class="uri" href="finitary" title="wikilink">finitary</a> <a href="biproduct" title="wikilink">biproducts</a>.</p>
<h2 id="definition">Definition</h2>

<p>A category <strong>C</strong> is preadditive if all its <a href="hom-set" title="wikilink">hom-sets</a> are <a href="Abelian_group" title="wikilink">Abelian groups</a> and composition of <a href="morphism" title="wikilink">morphisms</a> is <a href="bilinear_map" title="wikilink">bilinear</a>; in other words, <strong>C</strong> is <a href="enriched_category" title="wikilink">enriched</a> over the <a href="monoidal_category" title="wikilink">monoidal category</a> of Abelian groups.</p>

<p>In a preadditive category, every finitary <a href="product_(category_theory)" title="wikilink">product</a> (including the empty product, i.e., a <a href="Initial_and_terminal_objects" title="wikilink">final object</a>) is necessarily a <a class="uri" href="coproduct" title="wikilink">coproduct</a> (or <a href="Initial_and_terminal_objects" title="wikilink">initial object</a> in the case of an empty diagram), and hence a <a class="uri" href="biproduct" title="wikilink">biproduct</a>, and conversely every finitary coproduct is necessarily a product (this is a consequence of the definition, not a part of it).</p>

<p>Thus an additive category is equivalently described as a preadditive category admitting all finitary products, or a preadditive category admitting all finitary coproducts.</p>

<p>Another, yet equivalent, way to define an additive category is a category (not assumed to be preadditive) which has a <a href="zero_object" title="wikilink">zero object</a>, finite coproducts and finite products and such that the canonical map from the coproduct to the product</p>

<p>

<math display="block" id="Additive_category:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mrow>
     <mo largeop="true" movablelimits="false" symmetric="true">∐</mo>
     <mi>Y</mi>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>X</mi>
    <mrow>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mi>Y</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>X</ci>
     <apply>
      <csymbol cd="latexml">coproduct</csymbol>
      <ci>Y</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>X</ci>
     <apply>
      <csymbol cd="latexml">product</csymbol>
      <ci>Y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\coprod Y\to X\prod Y
  </annotation>
 </semantics>
</math>

 is an isomorphism. This isomorphism can be used to equip 

<math display="inline" id="Additive_category:1">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mi>o</mi>
   <mi>m</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>o</ci>
    <ci>m</ci>
    <interval closure="open">
     <ci>X</ci>
     <ci>Y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Hom(X,Y)
  </annotation>
 </semantics>
</math>

 with a commutative <a class="uri" href="monoid" title="wikilink">monoid</a> structure. The last requirement is that this is in fact an abelian group. Unlike the afore-mentioned definitions, this definition does not need the auxiliary additive group structure on the Hom sets as a datum, but rather as a property.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Note that the empty biproduct is necessarily a <a href="zero_object" title="wikilink">zero object</a> in the category, and a category admitting all finitary biproducts is often called <strong>semiadditive</strong>. As shown <a href="additive_category#Internal_characterisation_of_the_addition_law" title="wikilink">below</a>, every semiadditive category has a natural addition, and so we can alternatively define an additive category to be a semiadditive category having the property that every morphism has an additive inverse.</p>
<h3 id="generalization">Generalization</h3>

<p>More generally, one also considers additive <a href="preadditive_category#R-linear_categories" title="wikilink">

<math display="inline" id="Additive_category:2">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

-linear categories</a> for a <a href="commutative_ring" title="wikilink">commutative ring</a> 

<math display="inline" id="Additive_category:3">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>


. These are a categories enriched over the monoidal category of <a href="module_category" title="wikilink">

<math display="inline" id="Additive_category:4">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

-modules</a> and admitting all finitary biproducts.</p>
<h2 id="examples">Examples</h2>

<p>The original example of an additive category is the <a href="category_of_abelian_groups" title="wikilink">category of abelian groups</a> <strong>Ab</strong>. The zero object is the <a href="trivial_group" title="wikilink">trivial group</a>, the addition of morphisms is given point-wise, and biproducts are given by <a href="Direct_sum_of_abelian_groups" title="wikilink">direct sums</a>.</p>

<p>More generally, every <a href="module_category" title="wikilink">module category</a> over a <a href="ring_(mathematics)" title="wikilink">ring</a> 

<math display="inline" id="Additive_category:5">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is additive, and so in particular, the <a href="category_of_vector_spaces" title="wikilink">category of vector spaces</a> over a <a href="field_(mathematics)" title="wikilink">field</a> 

<math display="inline" id="Additive_category:6">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 is additive.</p>

<p>The algebra of <a href="matrix_(mathematics)" title="wikilink">matrices</a> over a ring, thought of as a category as described below, is also additive.</p>
<h2 id="internal-characterisation-of-the-addition-law">Internal characterisation of the addition law</h2>

<p>Let <strong>C</strong> be a semiadditive category, so a category having all finitary biproducts. Then every hom-set has an addition, endowing it with the structure of an <a href="Abelian_monoid#Commutative_monoid" title="wikilink">abelian monoid</a>, and such that the composition of morphisms is bilinear.</p>

<p>Moreover, if <strong>C</strong> is additive, then the two additions on hom-sets must agree. In particular, a semiadditive category is additive if and only if every morphism has an additive inverse.</p>

<p>This shows that the addition law for an additive category is <em>internal</em> to that category.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>To define the addition law, we will use the convention that for a biproduct, <em>p</em><sub>k</sub> will denote the projection morphisms, and <em>i</em><sub>k</sub> will denote the injection morphisms.</p>

<p>We first observe that for each object 

<math display="inline" id="Additive_category:7">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 there is a</p>
<ul>
<li><em>diagonal morphism</em> 

<math display="inline" id="Additive_category:8">
 <semantics>
  <mrow>
   <mi mathvariant="normal">∆</mi>
   <mo>:</mo>
   <mrow>
    <mi>A</mi>
    <mi mathvariant="normal">→</mi>
    <mi>A</mi>
    <mi mathvariant="normal">⊕</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>normal-∆</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>normal-→</ci>
     <ci>A</ci>
     <ci>normal-⊕</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ∆:A→A⊕A
  </annotation>
 </semantics>
</math>


 satisfying <mtpl></mtpl> for 

<math display="inline" id="Additive_category:9">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal"></mi>
     <mn>2</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <list>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>normal-</ci>
      <cn type="integer">2</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=1, 2
  </annotation>
 </semantics>
</math>

, and a</li>
<li><em>codiagonal morphism</em> 

<math display="inline" id="Additive_category:10">
 <semantics>
  <mrow>
   <mi mathvariant="normal">∇</mi>
   <mo>:</mo>
   <mrow>
    <mi>A</mi>
    <mi mathvariant="normal">⊕</mi>
    <mi>A</mi>
    <mi mathvariant="normal">→</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>normal-∇</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>normal-⊕</ci>
     <ci>A</ci>
     <ci>normal-→</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ∇:A⊕A→A
  </annotation>
 </semantics>
</math>

 satisfying <mtpl></mtpl> for 

<math display="inline" id="Additive_category:11">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal"></mi>
     <mn>2</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <list>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>normal-</ci>
      <cn type="integer">2</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=1, 2
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>Next, given two morphisms <mtpl></mtpl>, there exists a unique morphism <mtpl></mtpl> such that <mtpl></mtpl> equals <mtpl></mtpl> if 

<math display="inline" id="Additive_category:12">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mi>l</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=l
  </annotation>
 </semantics>
</math>

, and 0 otherwise.</p>

<p>We can therefore define <mtpl></mtpl>.</p>

<p>This addition is both commutative and associative. The associativity can be seen by considering the composition</p>

<p>

<math display="block" id="Additive_category:13">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>A</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mover accent="true">
     <mo>→</mo>
     <mrow>
      <mpadded lspace="10pt" width="+10pt">
       <mi mathvariant="normal">Δ</mi>
      </mpadded>
     </mrow>
    </mover>
   </mpadded>
   <mrow>
    <mi>A</mi>
    <mo>⊕</mo>
    <mi>A</mi>
    <mo>⊕</mo>
    <mpadded width="+5pt">
     <mi>A</mi>
    </mpadded>
   </mrow>
   <mpadded width="+5pt">
    <mover accent="true">
     <mo>→</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <msub>
        <mi>α</mi>
        <mn>1</mn>
       </msub>
      </mpadded>
      <mo rspace="4.2pt">⊕</mo>
      <mpadded width="+1.7pt">
       <msub>
        <mi>α</mi>
        <mn>2</mn>
       </msub>
      </mpadded>
      <mo rspace="4.2pt">⊕</mo>
      <msub>
       <mi>α</mi>
       <mn>3</mn>
      </msub>
     </mrow>
    </mover>
   </mpadded>
   <mrow>
    <mi>B</mi>
    <mo>⊕</mo>
    <mi>B</mi>
    <mo>⊕</mo>
    <mpadded width="+5pt">
     <mi>B</mi>
    </mpadded>
   </mrow>
   <mpadded width="+5pt">
    <mover accent="true">
     <mo>→</mo>
     <mrow>
      <mo lspace="12.5pt">∇</mo>
     </mrow>
    </mover>
   </mpadded>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">Δ</csymbol>
       <ci>normal-</ci>
      </cerror>
      <ci>normal-→</ci>
     </apply>
     <ci>A</ci>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>A</ci>
      <ci>A</ci>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <apply>
       <csymbol cd="latexml">direct-sum</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>B</ci>
      <ci>B</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-∇</ci>
       <ci>normal-</ci>
      </cerror>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\ \xrightarrow{\quad\Delta\quad}\ A\oplus A\oplus A\ \xrightarrow{\alpha_{1}%
\,\oplus\,\alpha_{2}\,\oplus\,\alpha_{3}}\ B\oplus B\oplus B\ \xrightarrow{%
\quad\nabla\quad}\ B
  </annotation>
 </semantics>
</math>

</p>

<p>We have 

<math display="inline" id="Additive_category:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>α</mi>
    <mo>+</mo>
    <mn>0</mn>
   </mrow>
   <mo>=</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <ci>α</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   α+0=α
  </annotation>
 </semantics>
</math>

, using that <mtpl></mtpl>.</p>

<p>It is also bilinear, using for example that 

<math display="inline" id="Additive_category:15">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">∆</mi>
    <mi mathvariant="normal">∘</mi>
    <mi>β</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>β</mi>
      <mi mathvariant="normal">⊕</mi>
      <mi>β</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">∘</mi>
    <mi mathvariant="normal">∆</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-∆</ci>
     <ci>normal-∘</ci>
     <ci>β</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>β</ci>
      <ci>normal-⊕</ci>
      <ci>β</ci>
     </apply>
     <ci>normal-∘</ci>
     <ci>normal-∆</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ∆∘β=(β⊕β)∘∆
  </annotation>
 </semantics>
</math>

 and that <mtpl></mtpl>.</p>

<p>We remark that for a biproduct 

<math display="inline" id="Additive_category:16">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi mathvariant="normal">⊕</mi>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>normal-⊕</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A⊕B
  </annotation>
 </semantics>
</math>

 we have <mtpl></mtpl>. Using this, we can represent any morphism 

<math display="inline" id="Additive_category:17">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi mathvariant="normal">⊕</mi>
   <mi>B</mi>
   <mi mathvariant="normal">→</mi>
   <mi>C</mi>
   <mi mathvariant="normal">⊕</mi>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>normal-⊕</ci>
    <ci>B</ci>
    <ci>normal-→</ci>
    <ci>C</ci>
    <ci>normal-⊕</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A⊕B→C⊕D
  </annotation>
 </semantics>
</math>

 as a matrix.</p>
<h2 id="matrix-representation-of-morphisms">Matrix representation of morphisms</h2>

<p>Given objects <mtpl></mtpl> and <mtpl></mtpl> in an additive category, we can represent morphisms <mtpl></mtpl> as 

<math display="inline" id="Additive_category:18">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>


-by-

<math display="inline" id="Additive_category:19">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 <a href="matrix_(mathematics)" title="wikilink">matrices</a></p>

<p>

<math display="block" id="Additive_category:20">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <msub>
       <mi>f</mi>
       <mn>11</mn>
      </msub>
     </mtd>
     <mtd columnalign="center">
      <msub>
       <mi>f</mi>
       <mn>12</mn>
      </msub>
     </mtd>
     <mtd columnalign="center">
      <mi mathvariant="normal">⋯</mi>
     </mtd>
     <mtd columnalign="center">
      <msub>
       <mi>f</mi>
       <mrow>
        <mn>1</mn>
        <mi>n</mi>
       </mrow>
      </msub>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <msub>
       <mi>f</mi>
       <mn>21</mn>
      </msub>
     </mtd>
     <mtd columnalign="center">
      <msub>
       <mi>f</mi>
       <mn>22</mn>
      </msub>
     </mtd>
     <mtd columnalign="center">
      <mi mathvariant="normal">⋯</mi>
     </mtd>
     <mtd columnalign="center">
      <msub>
       <mi>f</mi>
       <mrow>
        <mn>2</mn>
        <mi>n</mi>
       </mrow>
      </msub>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mi mathvariant="normal">⋮</mi>
     </mtd>
     <mtd columnalign="center">
      <mi mathvariant="normal">⋮</mi>
     </mtd>
     <mtd columnalign="center">
      <mi mathvariant="normal">⋯</mi>
     </mtd>
     <mtd columnalign="center">
      <mi mathvariant="normal">⋮</mi>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <msub>
       <mi>f</mi>
       <mrow>
        <mi>m</mi>
        <mn>1</mn>
       </mrow>
      </msub>
     </mtd>
     <mtd columnalign="center">
      <msub>
       <mi>f</mi>
       <mrow>
        <mi>m</mi>
        <mn>2</mn>
       </mrow>
      </msub>
     </mtd>
     <mtd columnalign="center">
      <mi mathvariant="normal">⋯</mi>
     </mtd>
     <mtd columnalign="center">
      <msub>
       <mi>f</mi>
       <mrow>
        <mi>m</mi>
        <mi>n</mi>
       </mrow>
      </msub>
     </mtd>
    </mtr>
   </mtable>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">11</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">12</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <times></times>
       <cn type="integer">1</cn>
       <ci>n</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">21</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">22</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <ci>normal-⋮</ci>
     <ci>normal-⋮</ci>
     <ci>normal-⋯</ci>
     <ci>normal-⋮</ci>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{pmatrix}f_{11}&f_{12}&\cdots&f_{1n}\\
f_{21}&f_{22}&\cdots&f_{2n}\\
\vdots&\vdots&\cdots&\vdots\\
f_{m1}&f_{m2}&\cdots&f_{mn}\end{pmatrix}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Additive_category:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>f</mi>
      <mrow>
       <mi>k</mi>
       <mi>l</mi>
      </mrow>
     </msub>
     <mo>:=</mo>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>k</mi>
      </msub>
      <mo>∘</mo>
      <mi>f</mi>
      <mo>∘</mo>
      <msub>
       <mi>i</mi>
       <mi>l</mi>
      </msub>
     </mrow>
    </mrow>
    <mo>:</mo>
    <mrow>
     <msub>
      <mi>A</mi>
      <mi>l</mi>
     </msub>
     <mo>→</mo>
     <msub>
      <mi>B</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>k</ci>
       <ci>l</ci>
      </apply>
     </apply>
     <apply>
      <compose></compose>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>k</ci>
      </apply>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>i</ci>
       <ci>l</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>l</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{kl}:=p_{k}\circ f\circ i_{l}\colon A_{l}\to B_{k}.
  </annotation>
 </semantics>
</math>

</p>

<p>Using that <mtpl></mtpl>, it follows that addition and composition of matrices obey the usual rules for <a href="matrix_addition" title="wikilink">matrix addition</a> and <a href="matrix_multiplication" title="wikilink">matrix multiplication</a>.</p>

<p>Thus additive categories can be seen as the most general context in which the algebra of matrices makes sense.</p>

<p>Recall that the morphisms from a single object 

<math display="inline" id="Additive_category:22">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 to itself form the <a href="endomorphism_ring" title="wikilink">endomorphism ring</a> 

<math display="inline" id="Additive_category:23">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mi>n</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>n</ci>
    <ci>d</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   End(A)
  </annotation>
 </semantics>
</math>

. If we denote the 

<math display="inline" id="Additive_category:24">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-fold product of 

<math display="inline" id="Additive_category:25">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 with itself by <mtpl></mtpl>, then morphisms from <mtpl></mtpl> to <mtpl></mtpl> are <em>m</em>-by-<em>n</em> matrices with entries from the ring 

<math display="inline" id="Additive_category:26">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mi>n</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>n</ci>
    <ci>d</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   End(A)
  </annotation>
 </semantics>
</math>

.</p>

<p>Conversely, given any <a href="ring_(mathematics)" title="wikilink">ring</a> 

<math display="inline" id="Additive_category:27">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

, we can form a category 

<math display="inline" id="Additive_category:28">
 <semantics>
  <mrow>
   <mi>𝐌𝐚𝐭</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐌𝐚𝐭</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Mat}(R)
  </annotation>
 </semantics>
</math>

 by taking objects <em>A</em><sub><em>n</em></sub> indexed by the set of <a href="natural_number" title="wikilink">natural numbers</a> (including <a href="0_(number)" title="wikilink">zero</a>) and letting the <a class="uri" href="hom-set" title="wikilink">hom-set</a> of morphisms from <mtpl></mtpl> to <mtpl></mtpl> be the <a href="Set_(mathematics)" title="wikilink">set</a> of 

<math display="inline" id="Additive_category:29">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

-by-

<math display="inline" id="Additive_category:30">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 matrices over 

<math display="inline" id="Additive_category:31">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

, and where composition is given by matrix multiplication. Then 

<math display="inline" id="Additive_category:32">
 <semantics>
  <mrow>
   <mi>𝐌𝐚𝐭</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐌𝐚𝐭</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Mat}(R)
  </annotation>
 </semantics>
</math>

 is an additive category, and <mtpl></mtpl> equals the 

<math display="inline" id="Additive_category:33">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-fold power <mtpl></mtpl>.</p>

<p>This construction should be compared with the result that a ring is a preadditive category with just one object, shown <a href="Preadditive_category#Special_cases" title="wikilink">here</a>.</p>

<p>If we interpret the object <mtpl></mtpl> as the left <a href="module_(mathematics)" title="wikilink">module</a> <mtpl></mtpl>, then this <em>matrix category</em> becomes a <a class="uri" href="subcategory" title="wikilink">subcategory</a> of the category of left modules over 

<math display="inline" id="Additive_category:34">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

.</p>

<p>This may be confusing in the special case where 

<math display="inline" id="Additive_category:35">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Additive_category:36">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is zero, because we usually don't think of <a href="empty_matrix" title="wikilink">matrices with 0 rows or 0 columns</a>. This concept makes sense, however: such matrices have no entries and so are completely determined by their size. While these matrices are rather degenerate, they do need to be included to get an additive category, since an additive category must have a zero object.</p>

<p>Thinking about such matrices can be useful in one way, though: they highlight the fact that given any objects 

<math display="inline" id="Additive_category:37">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Additive_category:38">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 in an additive category, there is exactly one morphism from 

<math display="inline" id="Additive_category:39">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 to 0 (just as there is exactly one 0-by-1 matrix with entries in 

<math display="inline" id="Additive_category:40">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mi>n</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>n</ci>
    <ci>d</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   End(A)
  </annotation>
 </semantics>
</math>

) and exactly one morphism from 0 to 

<math display="inline" id="Additive_category:41">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 (just as there is exactly one 1-by-0 matrix with entries in 

<math display="inline" id="Additive_category:42">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mi>n</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>n</ci>
    <ci>d</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   End(B)
  </annotation>
 </semantics>
</math>

) – this is just what it means to say that <a href="zero_object_(algebra)" title="wikilink">0 is a zero object</a>. Furthermore, the zero morphism from 

<math display="inline" id="Additive_category:43">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Additive_category:44">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is the composition of these morphisms, as can be calculated by multiplying the degenerate matrices.</p>
<h2 id="additive-functors">Additive functors</h2>

<p>Recall that a functor 

<math display="inline" id="Additive_category:45">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>:</mo>
   <mrow>
    <mi>𝐂</mi>
    <mi mathvariant="normal">→</mi>
    <mi>𝐃</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>F</ci>
    <apply>
     <times></times>
     <ci>𝐂</ci>
     <ci>normal-→</ci>
     <ci>𝐃</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F:\mathbf{C}→\mathbf{D}
  </annotation>
 </semantics>
</math>

 between preadditive categories is <em>additive</em> if it is an abelian <a href="group_homomorphism" title="wikilink">group homomorphism</a> on each <a class="uri" href="hom-set" title="wikilink">hom-set</a> in <strong>C</strong>. If the categories are additive, though, then a functor is additive if and only if it preserves all <a class="uri" href="biproduct" title="wikilink">biproduct</a> diagrams.</p>

<p>That is, if 

<math display="inline" id="Additive_category:46">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is a biproduct of <mtpl></mtpl> in <strong>C</strong> with projection morphisms <mtpl></mtpl> and injection morphisms <mtpl></mtpl>, then 

<math display="inline" id="Additive_category:47">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(B)
  </annotation>
 </semantics>
</math>

 should be a biproduct of <mtpl></mtpl> in <strong>D</strong> with projection morphisms <mtpl></mtpl> and injection morphisms <mtpl></mtpl>.</p>

<p>Almost all functors studied between additive categories are additive. In fact, it is a theorem that all <a href="adjoint_functor" title="wikilink">adjoint functors</a> between additive categories must be additive functors (see <a href="Adjoint_functors#Adjoints_preserve_limits" title="wikilink">here</a>), and most interesting functors studied in all of category theory are adjoints.</p>
<h3 id="generalization-1">Generalization</h3>

<p>When considering functors between 

<math display="inline" id="Additive_category:48">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

-linear additive categories, one usually restricts to <a href="preadditive_category#R-linear_categories" title="wikilink">

<math display="inline" id="Additive_category:49">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

-linear functors</a>, so those functors giving an 

<math display="inline" id="Additive_category:50">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

-module homomorphism on each hom-set.</p>
<h2 id="special-cases">Special cases</h2>
<ul>
<li>A <em><a href="pre-abelian_category" title="wikilink">pre-abelian category</a></em> is an additive category in which every morphism has a <a href="kernel_(category_theory)" title="wikilink">kernel</a> and a <a href="cokernel_(category_theory)" title="wikilink">cokernel</a>.</li>
<li>An <em><a href="abelian_category" title="wikilink">abelian category</a></em> is a pre-abelian category such that every <a class="uri" href="monomorphism" title="wikilink">monomorphism</a> and <a class="uri" href="epimorphism" title="wikilink">epimorphism</a> is <a href="normal_monomorphism" title="wikilink">normal</a>.</li>
</ul>

<p>Many commonly studied additive categories are in fact abelian categories; for example, <strong>Ab</strong> is an abelian category. The <a href="free_abelian_group" title="wikilink">free abelian groups</a> provide an example of a category that is additive but not abelian.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="references">References</h2>
<ul>
<li><a href="Nicolae_Popescu" title="wikilink">Nicolae Popescu</a>; 1973; <em>Abelian Categories with Applications to Rings and Modules</em>; Academic Press, Inc. (out of print) goes over all of this very slowly</li>
</ul>

<p>"</p>

<p><a href="Category:Additive_categories" title="wikilink"> </a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Jacob_Lurie" title="wikilink">Jacob Lurie</a>: <em>Higher Algebra</em>, Definition 1.1.2.1, <a class="uri" href="http://www.math.harvard.edu/~lurie/papers/higheralgebra.pdf">http://www.math.harvard.edu/~lurie/papers/higheralgebra.pdf</a><a href="#fnref1">↩</a></li>
<li id="fn2"> Sections 18 and 19 deal with the addition law in semiadditive categories.<a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
