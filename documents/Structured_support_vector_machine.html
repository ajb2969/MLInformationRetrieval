<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1495">Structured support vector machine</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Structured support vector machine</h1>
<hr/>

<p>The <strong>structured support vector machine</strong> is a <a href="machine_learning" title="wikilink">machine learning</a> algorithm that generalizes the <a href="Support_vector_machine" title="wikilink">Support Vector Machine</a> (SVM) classifier. Whereas the SVM classifier supports <a href="binary_classification" title="wikilink">binary classification</a>, <a href="multiclass_classification" title="wikilink">multiclass classification</a> and <a href="Regression_analysis" title="wikilink">regression</a>, the structured SVM allows training of a classifier for general <a href="structured_learning" title="wikilink">structured output labels</a>.</p>

<p>As an example, a sample instance might be a natural language sentence, and the output label is an annotated <a href="parse_tree" title="wikilink">parse tree</a>. Training a classifier consists of showing pairs of correct sample and output label pairs. After training, the structured SVM model allows one to predict for new sample instances the corresponding output label; that is, given a natural language sentence, the classifier can produce the most likely parse tree.</p>
<h2 id="training">Training</h2>

<p>For a set of 

<math display="inline" id="Structured_support_vector_machine:0">
 <semantics>
  <mi mathvariant="normal">â„“</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-â„“</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

 training instances 

<math display="inline" id="Structured_support_vector_machine:1">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ğ’™</mi>
     <mi>n</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>âˆˆ</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ğ’³</mi>
    <mo>Ã—</mo>
    <mi class="ltx_font_mathcaligraphic">ğ’´</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ğ’™</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </interval>
    <apply>
     <times></times>
     <ci>ğ’³</ci>
     <ci>ğ’´</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\boldsymbol{x}_{n},y_{n})\in\mathcal{X}\times\mathcal{Y}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Structured_support_vector_machine:2">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">â€¦</mi>
    <mo>,</mo>
    <mi mathvariant="normal">â„“</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-â€¦</ci>
     <ci>normal-â„“</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=1,\dots,\ell
  </annotation>
 </semantics>
</math>

 from a sample space 

<math display="inline" id="Structured_support_vector_machine:3">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’³</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’³</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{X}
  </annotation>
 </semantics>
</math>

 and label space 

<math display="inline" id="Structured_support_vector_machine:4">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’´</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’´</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{Y}
  </annotation>
 </semantics>
</math>

, the structured SVM minimizes the following regularized risk function.</p>

<p>

<math display="block" id="Structured_support_vector_machine:5">
 <semantics>
  <mrow>
   <munder accentunder="true">
    <mi>min</mi>
    <mo>ğ’˜</mo>
   </munder>
   <mrow>
    <msup>
     <mrow>
      <mo>âˆ¥</mo>
      <mi>ğ’˜</mi>
      <mo>âˆ¥</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <mrow>
     <mi>C</mi>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">âˆ‘</mo>
       <mrow>
        <mi>n</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi mathvariant="normal">â„“</mi>
      </munderover>
      <mrow>
       <munder accentunder="true">
        <mi>max</mi>
        <mrow>
         <mi>y</mi>
         <mo>âˆˆ</mo>
         <mi class="ltx_font_mathcaligraphic">ğ’´</mi>
        </mrow>
       </munder>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mrow>
          <mrow>
           <mi mathvariant="normal">Î”</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>y</mi>
             <mi>n</mi>
            </msub>
            <mo>,</mo>
            <mi>y</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>+</mo>
          <mrow>
           <msup>
            <mi>ğ’˜</mi>
            <mo>â€²</mo>
           </msup>
           <mi mathvariant="normal">Î¨</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>ğ’™</mi>
             <mi>n</mi>
            </msub>
            <mo>,</mo>
            <mi>y</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo>-</mo>
         <mrow>
          <msup>
           <mi>ğ’˜</mi>
           <mo>â€²</mo>
          </msup>
          <mi mathvariant="normal">Î¨</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>ğ’™</mi>
            <mi>n</mi>
           </msub>
           <mo>,</mo>
           <msub>
            <mi>y</mi>
            <mi>n</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <ci>ğ’˜</ci>
     <min></min>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>ğ’˜</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <ci>C</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-â„“</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <apply>
          <in></in>
          <ci>y</ci>
          <ci>ğ’´</ci>
         </apply>
         <max></max>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <plus></plus>
          <apply>
           <times></times>
           <ci>normal-Î”</ci>
           <interval closure="open">
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>y</ci>
             <ci>n</ci>
            </apply>
            <ci>y</ci>
           </interval>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>ğ’˜</ci>
            <ci>normal-â€²</ci>
           </apply>
           <ci>normal-Î¨</ci>
           <interval closure="open">
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>ğ’™</ci>
             <ci>n</ci>
            </apply>
            <ci>y</ci>
           </interval>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>ğ’˜</ci>
           <ci>normal-â€²</ci>
          </apply>
          <ci>normal-Î¨</ci>
          <interval closure="open">
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>ğ’™</ci>
            <ci>n</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>y</ci>
            <ci>n</ci>
           </apply>
          </interval>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underset{\boldsymbol{w}}{\min}\quad\|\boldsymbol{w}\|^{2}+C\sum_{n=1}^{\ell}%
\underset{y\in\mathcal{Y}}{\max}\left(\Delta(y_{n},y)+\boldsymbol{w}^{\prime}%
\Psi(\boldsymbol{x}_{n},y)-\boldsymbol{w}^{\prime}\Psi(\boldsymbol{x}_{n},y_{n%
})\right)
  </annotation>
 </semantics>
</math>

 The function is convex in 

<math display="inline" id="Structured_support_vector_machine:6">
 <semantics>
  <mi>ğ’˜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’˜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{w}
  </annotation>
 </semantics>
</math>

 because the maximum of a set of affine functions is convex. The function 

<math display="inline" id="Structured_support_vector_machine:7">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Î”</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">ğ’´</mi>
     <mo>Ã—</mo>
     <mi class="ltx_font_mathcaligraphic">ğ’´</mi>
    </mrow>
    <mo>â†’</mo>
    <msub>
     <mi>â„</mi>
     <mo>+</mo>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>normal-Î”</ci>
    <apply>
     <ci>normal-â†’</ci>
     <apply>
      <times></times>
      <ci>ğ’´</ci>
      <ci>ğ’´</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>â„</ci>
      <plus></plus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta:\mathcal{Y}\times\mathcal{Y}\to\mathbb{R}_{+}
  </annotation>
 </semantics>
</math>

 measures a distance in label space and is an arbitrary function (not necessarily a <a href="Metric_(mathematics)" title="wikilink">metric</a>) satisfying 

<math display="inline" id="Structured_support_vector_machine:8">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Î”</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â‰¥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>normal-Î”</ci>
     <interval closure="open">
      <ci>y</ci>
      <ci>z</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(y,z)\geq 0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Structured_support_vector_machine:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Î”</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mpadded width="+5.6pt">
      <mn>0</mn>
     </mpadded>
     <mrow>
      <mo>âˆ€</mo>
      <mi>y</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>z</mi>
    <mo>âˆˆ</mo>
    <mi class="ltx_font_mathcaligraphic">ğ’´</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>normal-Î”</ci>
      <interval closure="open">
       <ci>y</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>z</ci>
     <ci>ğ’´</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(y,y)=0\;\;\forall y,z\in\mathcal{Y}
  </annotation>
 </semantics>
</math>

. The function 

<math display="inline" id="Structured_support_vector_machine:10">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Î¨</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">ğ’³</mi>
     <mo>Ã—</mo>
     <mi class="ltx_font_mathcaligraphic">ğ’´</mi>
    </mrow>
    <mo>â†’</mo>
    <msup>
     <mi>â„</mi>
     <mi>d</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>normal-Î¨</ci>
    <apply>
     <ci>normal-â†’</ci>
     <apply>
      <times></times>
      <ci>ğ’³</ci>
      <ci>ğ’´</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>â„</ci>
      <ci>d</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi:\mathcal{X}\times\mathcal{Y}\to\mathbb{R}^{d}
  </annotation>
 </semantics>
</math>

 is a feature function, extracting some feature vector from a given sample and label. The design of this function depends very much on the application.</p>

<p>Because the regularized risk function above is non-differentiable, it is often reformulated in terms of a <a href="quadratic_program" title="wikilink">quadratic program</a> by introducing one slack variable 

<math display="inline" id="Structured_support_vector_machine:11">
 <semantics>
  <msub>
   <mi>Î¾</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Î¾</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{n}
  </annotation>
 </semantics>
</math>

 for each sample, each representing the value of the maximum. The standard structured SVM primal formulation is given as follows.</p>

<p>

<math display="block" id="Structured_support_vector_machine:12">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="center">
     <munder accentunder="true">
      <mi>min</mi>
      <mrow>
       <mi>ğ’˜</mi>
       <mo>,</mo>
       <mi>ğƒ</mi>
      </mrow>
     </munder>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <msup>
       <mrow>
        <mo>âˆ¥</mo>
        <mi>ğ’˜</mi>
        <mo>âˆ¥</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mrow>
       <mi>C</mi>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">âˆ‘</mo>
         <mrow>
          <mi>n</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi mathvariant="normal">â„“</mi>
        </munderover>
        <msub>
         <mi>Î¾</mi>
         <mi>n</mi>
        </msub>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mtext>s.t.</mtext>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mrow>
        <mrow>
         <mrow>
          <msup>
           <mi>ğ’˜</mi>
           <mo>â€²</mo>
          </msup>
          <mi mathvariant="normal">Î¨</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>ğ’™</mi>
            <mi>n</mi>
           </msub>
           <mo>,</mo>
           <msub>
            <mi>y</mi>
            <mi>n</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>-</mo>
         <mrow>
          <msup>
           <mi>ğ’˜</mi>
           <mo>â€²</mo>
          </msup>
          <mi mathvariant="normal">Î¨</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>ğ’™</mi>
            <mi>n</mi>
           </msub>
           <mo>,</mo>
           <mi>y</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>+</mo>
        <msub>
         <mi>Î¾</mi>
         <mi>n</mi>
        </msub>
       </mrow>
       <mo>â‰¥</mo>
       <mrow>
        <mi mathvariant="normal">Î”</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>y</mi>
          <mi>n</mi>
         </msub>
         <mo>,</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo rspace="22.5pt">,</mo>
      <mrow>
       <mrow>
        <mi>n</mi>
        <mo>=</mo>
        <mrow>
         <mn>1</mn>
         <mo>,</mo>
         <mi mathvariant="normal">â€¦</mi>
         <mo>,</mo>
         <mi mathvariant="normal">â„“</mi>
        </mrow>
       </mrow>
       <mo rspace="12.5pt">,</mo>
       <mrow>
        <mrow>
         <mo>âˆ€</mo>
         <mi>y</mi>
        </mrow>
        <mo>âˆˆ</mo>
        <mi class="ltx_font_mathcaligraphic">ğ’´</mi>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <list>
       <ci>ğ’˜</ci>
       <ci>ğƒ</ci>
      </list>
      <min></min>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <ci>ğ’˜</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <ci>C</ci>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>normal-â„“</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Î¾</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <mtext>s.t.</mtext>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <geq></geq>
       <apply>
        <plus></plus>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>ğ’˜</ci>
           <ci>normal-â€²</ci>
          </apply>
          <ci>normal-Î¨</ci>
          <interval closure="open">
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>ğ’™</ci>
            <ci>n</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>y</ci>
            <ci>n</ci>
           </apply>
          </interval>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>ğ’˜</ci>
           <ci>normal-â€²</ci>
          </apply>
          <ci>normal-Î¨</ci>
          <interval closure="open">
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>ğ’™</ci>
            <ci>n</ci>
           </apply>
           <ci>y</ci>
          </interval>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Î¾</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>normal-Î”</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>n</ci>
         </apply>
         <ci>y</ci>
        </interval>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <list>
         <cn type="integer">1</cn>
         <ci>normal-â€¦</ci>
         <ci>normal-â„“</ci>
        </list>
       </apply>
       <apply>
        <in></in>
        <apply>
         <csymbol cd="latexml">for-all</csymbol>
         <ci>y</ci>
        </apply>
        <ci>ğ’´</ci>
       </apply>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{cl}\underset{\boldsymbol{w},\boldsymbol{\xi}}{\min}&\|%
\boldsymbol{w}\|^{2}+C\sum_{n=1}^{\ell}\xi_{n}\\
\textrm{s.t.}&\boldsymbol{w}^{\prime}\Psi(\boldsymbol{x}_{n},y_{n})-%
\boldsymbol{w}^{\prime}\Psi(\boldsymbol{x}_{n},y)+\xi_{n}\geq\Delta(y_{n},y),%
\qquad n=1,\dots,\ell,\quad\forall y\in\mathcal{Y}\end{array}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="inference">Inference</h2>

<p>At test time, only a sample 

<math display="inline" id="Structured_support_vector_machine:13">
 <semantics>
  <mrow>
   <mi>ğ’™</mi>
   <mo>âˆˆ</mo>
   <mi class="ltx_font_mathcaligraphic">ğ’³</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ğ’™</ci>
    <ci>ğ’³</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{x}\in\mathcal{X}
  </annotation>
 </semantics>
</math>

 is known, and a prediction function 

<math display="inline" id="Structured_support_vector_machine:14">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ğ’³</mi>
    <mo>â†’</mo>
    <mi class="ltx_font_mathcaligraphic">ğ’´</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-â†’</ci>
     <ci>ğ’³</ci>
     <ci>ğ’´</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\mathcal{X}\to\mathcal{Y}
  </annotation>
 </semantics>
</math>

 maps it to a predicted label from the label space 

<math display="inline" id="Structured_support_vector_machine:15">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’´</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’´</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{Y}
  </annotation>
 </semantics>
</math>

. For structured SVMs, given the vector 

<math display="inline" id="Structured_support_vector_machine:16">
 <semantics>
  <mi>ğ’˜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’˜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{w}
  </annotation>
 </semantics>
</math>

 obtained from training, the prediction function is the following.</p>

<p>

<math display="block" id="Structured_support_vector_machine:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ğ’™</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder accentunder="true">
     <mtext>argmax</mtext>
     <mrow>
      <mi>y</mi>
      <mo>âˆˆ</mo>
      <mi class="ltx_font_mathcaligraphic">ğ’´</mi>
     </mrow>
    </munder>
    <mrow>
     <msup>
      <mi>ğ’˜</mi>
      <mo>â€²</mo>
     </msup>
     <mi mathvariant="normal">Î¨</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ğ’™</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>ğ’™</ci>
    </apply>
    <list>
     <apply>
      <apply>
       <in></in>
       <ci>y</ci>
       <ci>ğ’´</ci>
      </apply>
      <mtext>argmax</mtext>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ğ’˜</ci>
       <ci>normal-â€²</ci>
      </apply>
      <ci>normal-Î¨</ci>
      <interval closure="open">
       <ci>ğ’™</ci>
       <ci>y</ci>
      </interval>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\boldsymbol{x})=\underset{y\in\mathcal{Y}}{\textrm{argmax}}\quad\boldsymbol{%
w}^{\prime}\Psi(\boldsymbol{x},y)
  </annotation>
 </semantics>
</math>

</p>

<p>Therefore, the maximizer over the label space is the predicted label. Solving for this maximizer is the so-called inference problem and similar to making a maximum a-posteriori (MAP) prediction in probabilistic models. Depending on the structure of the function 

<math display="inline" id="Structured_support_vector_machine:18">
 <semantics>
  <mi mathvariant="normal">Î¨</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Î¨</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi
  </annotation>
 </semantics>
</math>

, solving for the maximizer can be a hard problem.</p>
<h2 id="separation">Separation</h2>

<p>The above quadratic program involves a very large, possibly infinite number of linear inequality constraints. In general, the number of inequalities is too large to be optimized over explicitly. Instead the problem is solved by using <a href="delayed_constraint_generation" title="wikilink">delayed constraint generation</a> where only a finite and small subset of the constraints is used. Optimizing over a subset of the constraints enlarges the <a href="feasible_set" title="wikilink">feasible set</a> and will yield a solution which provides a lower bound on the objective. To test whether the solution 

<math display="inline" id="Structured_support_vector_machine:19">
 <semantics>
  <mi>ğ’˜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’˜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{w}
  </annotation>
 </semantics>
</math>

 violates constraints of the complete set inequalities, a <a class="uri" href="separation" title="wikilink">separation</a> problem needs to be solved. As the inequalities decompose over the samples, for each sample 

<math display="inline" id="Structured_support_vector_machine:20">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>ğ’™</mi>
    <mi>n</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ’™</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\boldsymbol{x}_{n},y_{n})
  </annotation>
 </semantics>
</math>

 the following problem needs to be solved.</p>

<p>

<math display="block" id="Structured_support_vector_machine:21">
 <semantics>
  <mrow>
   <msubsup>
    <mi>y</mi>
    <mi>n</mi>
    <mo>*</mo>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <munder accentunder="true">
     <mtext>argmax</mtext>
     <mrow>
      <mi>y</mi>
      <mo>âˆˆ</mo>
      <mi class="ltx_font_mathcaligraphic">ğ’´</mi>
     </mrow>
    </munder>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi mathvariant="normal">Î”</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>y</mi>
          <mi>n</mi>
         </msub>
         <mo>,</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <msup>
         <mi>ğ’˜</mi>
         <mo>â€²</mo>
        </msup>
        <mi mathvariant="normal">Î¨</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>ğ’™</mi>
          <mi>n</mi>
         </msub>
         <mo>,</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <msup>
        <mi>ğ’˜</mi>
        <mo>â€²</mo>
       </msup>
       <mi mathvariant="normal">Î¨</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>ğ’™</mi>
         <mi>n</mi>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>y</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <msub>
       <mi>Î¾</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
     <times></times>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <in></in>
       <ci>y</ci>
       <ci>ğ’´</ci>
      </apply>
      <mtext>argmax</mtext>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>normal-Î”</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>n</ci>
         </apply>
         <ci>y</ci>
        </interval>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ğ’˜</ci>
         <ci>normal-â€²</ci>
        </apply>
        <ci>normal-Î¨</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ğ’™</ci>
          <ci>n</ci>
         </apply>
         <ci>y</ci>
        </interval>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ğ’˜</ci>
        <ci>normal-â€²</ci>
       </apply>
       <ci>normal-Î¨</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ğ’™</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>n</ci>
        </apply>
       </interval>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Î¾</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n}^{*}=\underset{y\in\mathcal{Y}}{\textrm{argmax}}\left(\Delta(y_{n},y)+%
\boldsymbol{w}^{\prime}\Psi(\boldsymbol{x}_{n},y)-\boldsymbol{w}^{\prime}\Psi(%
\boldsymbol{x}_{n},y_{n})-\xi_{n}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>The right hand side objective to be maximized is composed of the constant 

<math display="inline" id="Structured_support_vector_machine:22">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mrow>
     <msup>
      <mi>ğ’˜</mi>
      <mo>â€²</mo>
     </msup>
     <mi mathvariant="normal">Î¨</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>ğ’™</mi>
       <mi>n</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>-</mo>
   <msub>
    <mi>Î¾</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ğ’˜</ci>
       <ci>normal-â€²</ci>
      </apply>
      <ci>normal-Î¨</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ğ’™</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>n</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Î¾</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\boldsymbol{w}^{\prime}\Psi(\boldsymbol{x}_{n},y_{n})-\xi_{n}
  </annotation>
 </semantics>
</math>

 and a term dependent on the variables optimized over, namely 

<math display="inline" id="Structured_support_vector_machine:23">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Î”</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <msup>
     <mi>ğ’˜</mi>
     <mo>â€²</mo>
    </msup>
    <mi mathvariant="normal">Î¨</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ğ’™</mi>
      <mi>n</mi>
     </msub>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>normal-Î”</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ğ’˜</ci>
      <ci>normal-â€²</ci>
     </apply>
     <ci>normal-Î¨</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ğ’™</ci>
       <ci>n</ci>
      </apply>
      <ci>y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(y_{n},y)+\boldsymbol{w}^{\prime}\Psi(\boldsymbol{x}_{n},y)
  </annotation>
 </semantics>
</math>

. If the achieved right hand side objective is smaller or equal to zero, no violated constraints for this sample exist. If it is strictly larger than zero, the most violated constraint with respect to this sample has been identified. The problem is enlarged by this constraint and resolved. The process continues until no violated inequalities can be identified.</p>

<p>If the constants are dropped from the above problem, we obtain the following problem to be solved.</p>

<p>

<math display="block" id="Structured_support_vector_machine:24">
 <semantics>
  <mrow>
   <msubsup>
    <mi>y</mi>
    <mi>n</mi>
    <mo>*</mo>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <munder accentunder="true">
     <mtext>argmax</mtext>
     <mrow>
      <mi>y</mi>
      <mo>âˆˆ</mo>
      <mi class="ltx_font_mathcaligraphic">ğ’´</mi>
     </mrow>
    </munder>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Î”</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>y</mi>
         <mi>n</mi>
        </msub>
        <mo>,</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msup>
        <mi>ğ’˜</mi>
        <mo>â€²</mo>
       </msup>
       <mi mathvariant="normal">Î¨</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>ğ’™</mi>
         <mi>n</mi>
        </msub>
        <mo>,</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
     <times></times>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <in></in>
       <ci>y</ci>
       <ci>ğ’´</ci>
      </apply>
      <mtext>argmax</mtext>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>normal-Î”</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>n</ci>
        </apply>
        <ci>y</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ğ’˜</ci>
        <ci>normal-â€²</ci>
       </apply>
       <ci>normal-Î¨</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ğ’™</ci>
         <ci>n</ci>
        </apply>
        <ci>y</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n}^{*}=\underset{y\in\mathcal{Y}}{\textrm{argmax}}\left(\Delta(y_{n},y)+%
\boldsymbol{w}^{\prime}\Psi(\boldsymbol{x}_{n},y)\right)
  </annotation>
 </semantics>
</math>

</p>

<p>This problem looks very similar to the inference problem. The only difference is the addition of the term 

<math display="inline" id="Structured_support_vector_machine:25">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Î”</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Î”</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(y_{n},y)
  </annotation>
 </semantics>
</math>

. Most often, it is chosen such that it has a natural decomposition in label space. In that case, the influence of 

<math display="inline" id="Structured_support_vector_machine:26">
 <semantics>
  <mi mathvariant="normal">Î”</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Î”</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

 can be encoded into the inference problem and solving for the most violating constraint is equivalent to solving the inference problem.</p>
<h2 id="references">References</h2>
<ul>
<li>Ioannis Tsochantaridis, <a href="Thorsten_Joachims" title="wikilink">Thorsten Joachims</a>, Thomas Hofmann and Yasemin Altun (2005), <a href="http://www.jmlr.org/papers/volume6/tsochantaridis05a/tsochantaridis05a.pdf">Large Margin Methods for Structured and Interdependent Output Variables</a>, JMLR, Vol. 6, pages 1453-1484.</li>
<li>Thomas Finley and Thorsten Joachims (2008), <a href="http://icml2008.cs.helsinki.fi/papers/279.pdf">Training Structural SVMs when Exact Inference is Intractable</a>, ICML 2008.</li>
<li>Sunita Sarawagi and Rahul Gupta (2008), <a href="http://icml2008.cs.helsinki.fi/papers/402.pdf">Accurate Max-margin Training for Structured Output Spaces</a>, ICML 2008.</li>
<li>GÃ¶khan BakIr, Ben Taskar, Thomas Hofmann, Bernhard SchÃ¶lkopf, Alex Smola and SVN Vishwanathan (2007), [<a class="uri" href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&amp;tid">http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&amp;tid;</a>;=11332 Predicting Structured Data], MIT Press.</li>
<li>VojtÄ›ch Franc and Bogdan Savchynskyy <a href="http://www.jmlr.org/papers/volume9/franc08a/franc08a.pdf">Discriminative Learning of Max-Sum Classifiers</a>, Journal of Machine Learning Research, 9(Jan):67â€”104, 2008, Microtome Publishing</li>
<li>Kevin Murphy <a href="http://www.cs.ubc.ca/~murphyk/MLbook/pml-print3-ch19.pdf">1</a> Machine Learning, Mit Press</li>
</ul>

<p>"</p>

<p><a href="Category:Structured_prediction" title="wikilink">Category:Structured prediction</a> <a href="Category:Support_vector_machines" title="wikilink">Category:Support vector machines</a></p>
</body>
</html>
