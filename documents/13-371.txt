   Simulation algorithms for coupled DEVS      Simulation algorithms for coupled DEVS   Given a coupled DEVS model, simulation algorithms are methods to generate the model's legal behaviors, which are a set of trajectories not to reach illegal states. (see behavior of a Coupled DEVS model.) [Zeigler84 ] originally introduced the algorithms that handle time variables related to lifespan      t  s   ∈   [  0  ,  ∞  ]        subscript  t  s    0      t_{s}\in[0,\infty]   and elapsed time      t  e   ∈   [  0  ,  ∞  )        subscript  t  e    0      t_{e}\in[0,\infty)   by introducing two other time variables, last event time ,     t  l   ∈   [  0  ,  ∞  )        subscript  t  l    0      t_{l}\in[0,\infty)   , and next event time      t  n   ∈   [  0  ,  ∞  ]        subscript  t  n    0      t_{n}\in[0,\infty]   with the following relations:         t   e   =   t  -   t  l         subscript  t  e     t   subscript  t  l      \,t_{e}=t-t_{l}      and         t   s   =    t  n   -   t  l         subscript  t  s      subscript  t  n    subscript  t  l      \,t_{s}=t_{n}-t_{l}      where    t  ∈   [  0  ,  ∞  )       t   0      t\in[0,\infty)   denotes the current time . And the remaining time ,         t   r   =    t  s   -   t  e         subscript  t  r      subscript  t  s    subscript  t  e      \,t_{r}=t_{s}-t_{e}      is equivalently computed as         t   r   =    t  n   -  t        subscript  t  r      subscript  t  n   t     \,t_{r}=t_{n}-t      , apparently     t  r   ∈   [  0  ,  ∞  ]        subscript  t  r    0      t_{r}\in[0,\infty]   . Based on these relationships, the algorithms to simulate the behavior of a given Coupled DEVS are written as follows.  Algorithms  DEVS-coordinator  Variables:  parent // parent coordinator       t  l     subscript  t  l    t_{l}    : // time of last event       t  n     subscript  t  n    t_{n}    : // time of next event       N  =   (  X  ,  Y  ,  D  ,   {   M  i   }   ,   C   x  x    ,   C   y  x    ,   C   y  y    ,   S  e  l  e  c  t   )       N   X  Y  D    subscript  M  i     subscript  C    x  x     subscript  C    y  x     subscript  C    y  y      S  e  l  e  c  t      N=(X,Y,D,\{M_{i}\},C_{xx},C_{yx},C_{yy},Select)    // the associated Coupled  DEVS model  when receive init-message(Time t )  for each     i  ∈  D      i  D    i\in D    do  send init-message( t ) to child    i   i   i          t  l   ←   max   {    t   l  i    :   i  ∈  D    }       normal-←   subscript  t  l      normal-:   subscript  t    l  i      i  D       t_{l}\leftarrow\max\{t_{li}:i\in D\}   ;        t  n   ←   min   {    t   n  i    :   i  ∈  D    }       normal-←   subscript  t  n      normal-:   subscript  t    n  i      i  D       t_{n}\leftarrow\min\{t_{ni}:i\in D\}    ;  when receive star-message(Time t )  if     t  ≠   t  n       t   subscript  t  n     t\neq t_{n}    then  error: bad synchronization;         i  *   ←   S  e  l  e  c  t   (   {   i  ∈  D   :    t   n  i    =   t  n    }   )     ;     normal-←   superscript  i      S  e  l  e  c  t   conditional-set    i  D      subscript  t    n  i     subscript  t  n        i^{*}\leftarrow Select(\{i\in D:t_{ni}=t_{n}\});     send star-message( t )to     i  *     superscript  i     i^{*}          t  l   ←   max   {    t   l  i    :   i  ∈  D    }       normal-←   subscript  t  l      normal-:   subscript  t    l  i      i  D       t_{l}\leftarrow\max\{t_{li}:i\in D\}   ;        t  n   ←   min   {    t   n  i    :   i  ∈  D    }       normal-←   subscript  t  n      normal-:   subscript  t    n  i      i  D       t_{n}\leftarrow\min\{t_{ni}:i\in D\}    ;  when receive x-message(     x  ∈  X      x  X    x\in X    , Time t )  if     (   t  l   ≤  t     fragments  normal-(   subscript  t  l    t    (t_{l}\leq t    and     t  ≤   t  n   )     fragments  t    subscript  t  n   normal-)    t\leq t_{n})    == false then  error: bad synchronization;  for each      (  x  ,   x  i   )   ∈   C   x  x         x   subscript  x  i     subscript  C    x  x      (x,x_{i})\in C_{xx}    do  send x-message(     x  i     subscript  x  i    x_{i}    , t ) to child    i   i   i          t  l   ←   max   {    t   l  i    :   i  ∈  D    }       normal-←   subscript  t  l      normal-:   subscript  t    l  i      i  D       t_{l}\leftarrow\max\{t_{li}:i\in D\}   ;        t  n   ←   min   {    t   n  i    :   i  ∈  D    }       normal-←   subscript  t  n      normal-:   subscript  t    n  i      i  D       t_{n}\leftarrow\min\{t_{ni}:i\in D\}    ;  when receive y-message(      y  i   ∈   Y  i        subscript  y  i    subscript  Y  i     y_{i}\in Y_{i}    , Time t )  for each      (   y  i   ,   x  i   )   ∈   C   y  x          subscript  y  i    subscript  x  i     subscript  C    y  x      (y_{i},x_{i})\in C_{yx}    do  send x-message(     x  i     subscript  x  i    x_{i}    , t ) to child    i   i   i     if       C   y  y     (   y  i   )    ≠  ϕ         subscript  C    y  y     subscript  y  i    ϕ    C_{yy}(y_{i})\neq\phi    then  send y-message(      C   y  y     (   y  i   )        subscript  C    y  y     subscript  y  i     C_{yy}(y_{i})    , t ) to parent;        t  l   ←   max   {    t   l  i    :   i  ∈  D    }       normal-←   subscript  t  l      normal-:   subscript  t    l  i      i  D       t_{l}\leftarrow\max\{t_{li}:i\in D\}    ;        t  n   ←   min   {    t   n  i    :   i  ∈  D    }       normal-←   subscript  t  n      normal-:   subscript  t    n  i      i  D       t_{n}\leftarrow\min\{t_{ni}:i\in D\}    ;  See also   Coupled DEVS  Behavior of Coupled DEVS  Simulation Algorithms for Atomic DEVS   References   [Zeigler84]  [ZKP00]   "  Category:Algorithms   