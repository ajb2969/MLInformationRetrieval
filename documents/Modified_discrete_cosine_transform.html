<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1240">Modified discrete cosine transform</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Modified discrete cosine transform</h1>
<hr/>

<p>The <strong>modified discrete cosine transform (MDCT)</strong> is a <a href="lapped_transform" title="wikilink">lapped transform</a> based on the type-IV <a href="discrete_cosine_transform" title="wikilink">discrete cosine transform</a> (DCT-IV), with the additional property of being <em>lapped</em>: it is designed to be performed on consecutive blocks of a larger <a class="uri" href="dataset" title="wikilink">dataset</a>, where subsequent blocks are overlapped so that the last half of one block coincides with the first half of the next block. This overlapping, in addition to the energy-compaction qualities of the DCT, makes the MDCT especially attractive for signal compression applications, since it helps to avoid <a href="compression_artifact" title="wikilink">artifacts</a> stemming from the block boundaries. As a result of these advantages, the MDCT is employed in most modern lossy audio formats, including <a class="uri" href="MP3" title="wikilink">MP3</a>, <a href="Dolby_AC-3" title="wikilink">AC-3</a>, <a class="uri" href="Vorbis" title="wikilink">Vorbis</a>, <a href="Windows_Media_Audio" title="wikilink">Windows Media Audio</a>, <a class="uri" href="ATRAC" title="wikilink">ATRAC</a>, <a href="cook_codec" title="wikilink">Cook</a>, and <a href="advanced_audio_coding" title="wikilink">AAC</a>.</p>

<p>The MDCT was proposed by Princen, Johnson, and Bradley<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> in 1987, following earlier (1986) work by Princen and Bradley<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> to develop the MDCT's underlying principle of <strong>time-domain aliasing cancellation</strong> (TDAC), described below. (There also exists an analogous transform, the MDST, based on the <a href="discrete_sine_transform" title="wikilink">discrete sine transform</a>, as well as other, rarely used, forms of the MDCT based on different types of DCT or DCT/DST combinations.)</p>

<p>In MP3, the MDCT is not applied to the audio signal directly, but rather to the output of a 32-band <a href="polyphase_quadrature_filter" title="wikilink">polyphase quadrature filter</a> (PQF) bank. The output of this MDCT is postprocessed by an alias reduction formula to reduce the typical aliasing of the PQF filter bank. Such a combination of a filter bank with an MDCT is called a <em>hybrid</em> filter bank or a <em>subband</em> MDCT. AAC, on the other hand, normally uses a pure MDCT; only the (rarely used) <a href="MPEG-4_AAC-SSR" title="wikilink">MPEG-4 AAC-SSR</a> variant (by <a class="uri" href="Sony" title="wikilink">Sony</a>) uses a four-band PQF bank followed by an MDCT. Similar to MP3, <a class="uri" href="ATRAC" title="wikilink">ATRAC</a> uses stacked <a href="quadrature_mirror_filter" title="wikilink">quadrature mirror filters</a> (QMF) followed by an MDCT.</p>
<h2 id="definition">Definition</h2>

<p>As a lapped transform, the MDCT is a bit unusual compared to other Fourier-related transforms in that it has half as many outputs as inputs (instead of the same number). In particular, it is a <a href="linear_function" title="wikilink">linear function</a> 

<math display="inline" id="Modified_discrete_cosine_transform:0">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>ùêë</mi>
     <mrow>
      <mn>2</mn>
      <mi>N</mi>
     </mrow>
    </msup>
    <mo>‚Üí</mo>
    <msup>
     <mi>ùêë</mi>
     <mi>N</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>F</ci>
    <apply>
     <ci>normal-‚Üí</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ùêë</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>N</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ùêë</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\colon\mathbf{R}^{2N}\to\mathbf{R}^{N}
  </annotation>
 </semantics>
</math>

 (where <strong>R</strong> denotes the set of <a href="real_number" title="wikilink">real numbers</a>). The 2<em>N</em> real numbers <em>x</em><sub>0</sub>, ..., <em>x</em><sub>2<em>N</em>-1</sub> are transformed into the <em>N</em> real numbers <em>X</em><sub>0</sub>, ..., <em>X</em><sub><em>N</em>-1</sub> according to the formula:</p>

<p>

<math display="block" id="Modified_discrete_cosine_transform:1">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mrow>
       <mn>2</mn>
       <mi>N</mi>
      </mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mi>cos</mi>
      <mrow>
       <mo>[</mo>
       <mrow>
        <mfrac>
         <mi>œÄ</mi>
         <mi>N</mi>
        </mfrac>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mfrac>
           <mn>1</mn>
           <mn>2</mn>
          </mfrac>
          <mo>+</mo>
          <mfrac>
           <mi>N</mi>
           <mn>2</mn>
          </mfrac>
         </mrow>
         <mo>)</mo>
        </mrow>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mi>k</mi>
          <mo>+</mo>
          <mfrac>
           <mn>1</mn>
           <mn>2</mn>
          </mfrac>
         </mrow>
         <mo>)</mo>
        </mrow>
       </mrow>
       <mo>]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>N</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <cos></cos>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <ci>œÄ</ci>
         <ci>N</ci>
        </apply>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <divide></divide>
          <ci>N</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{k}=\sum_{n=0}^{2N-1}x_{n}\cos\left[\frac{\pi}{N}\left(n+\frac{1}{2}+\frac{N%
}{2}\right)\left(k+\frac{1}{2}\right)\right]
  </annotation>
 </semantics>
</math>

</p>

<p>(The normalization coefficient in front of this transform, here unity, is an arbitrary convention and differs between treatments. Only the product of the normalizations of the MDCT and the IMDCT, below, is constrained.)</p>
<h3 id="inverse-transform">Inverse transform</h3>

<p>The inverse MDCT is known as the <strong>IMDCT</strong>. Because there are different numbers of inputs and outputs, at first glance it might seem that the MDCT should not be invertible. However, perfect invertibility is achieved by <em>adding</em> the overlapped IMDCTs of subsequent overlapping blocks, causing the errors to <em>cancel</em> and the original data to be retrieved; this technique is known as <em>time-domain aliasing cancellation</em> (<strong>TDAC</strong>).</p>

<p>The IMDCT transforms <em>N</em> real numbers <em>X</em><sub>0</sub>, ..., <em>X</em><sub><em>N</em>-1</sub> into 2<em>N</em> real numbers <em>y</em><sub>0</sub>, ..., <em>y</em><sub>2<em>N</em>-1</sub> according to the formula:</p>

<p>

<math display="block" id="Modified_discrete_cosine_transform:2">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>N</mi>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </munderover>
     <mrow>
      <msub>
       <mi>X</mi>
       <mi>k</mi>
      </msub>
      <mrow>
       <mi>cos</mi>
       <mrow>
        <mo>[</mo>
        <mrow>
         <mfrac>
          <mi>œÄ</mi>
          <mi>N</mi>
         </mfrac>
         <mrow>
          <mo>(</mo>
          <mrow>
           <mi>n</mi>
           <mo>+</mo>
           <mfrac>
            <mn>1</mn>
            <mn>2</mn>
           </mfrac>
           <mo>+</mo>
           <mfrac>
            <mi>N</mi>
            <mn>2</mn>
           </mfrac>
          </mrow>
          <mo>)</mo>
         </mrow>
         <mrow>
          <mo>(</mo>
          <mrow>
           <mi>k</mi>
           <mo>+</mo>
           <mfrac>
            <mn>1</mn>
            <mn>2</mn>
           </mfrac>
          </mrow>
          <mo>)</mo>
         </mrow>
        </mrow>
        <mo>]</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <cos></cos>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <ci>œÄ</ci>
          <ci>N</ci>
         </apply>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <divide></divide>
           <ci>N</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
         <apply>
          <plus></plus>
          <ci>k</ci>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n}=\frac{1}{N}\sum_{k=0}^{N-1}X_{k}\cos\left[\frac{\pi}{N}\left(n+\frac{1}{%
2}+\frac{N}{2}\right)\left(k+\frac{1}{2}\right)\right]
  </annotation>
 </semantics>
</math>

</p>

<p>(Like for the <a href="Discrete_cosine_transform#DCT-IV" title="wikilink">DCT-IV</a>, an orthogonal transform, the inverse has the same form as the forward transform.)</p>

<p>In the case of a windowed MDCT with the usual window normalization (see below), the normalization coefficient in front of the IMDCT should be multiplied by 2 (i.e., becoming 2/<em>N</em>).</p>
<h3 id="computation">Computation</h3>

<p>Although the direct application of the MDCT formula would require O(<em>N</em><sup>2</sup>) operations, it is possible to compute the same thing with only O(<em>N</em> log <em>N</em>) complexity by recursively factorizing the computation, as in the <a href="fast_Fourier_transform" title="wikilink">fast Fourier transform</a> (FFT). One can also compute MDCTs via other transforms, typically a DFT (FFT) or a DCT, combined with O(<em>N</em>) pre- and post-processing steps. Also, as described below, any algorithm for the DCT-IV immediately provides a method to compute the MDCT and IMDCT of even size.</p>
<h2 id="window-functions">Window functions</h2>

<p>In typical signal-compression applications, the transform properties are further improved by using a <a href="window_function" title="wikilink">window function</a> <em>w</em><sub><em>n</em></sub> (<em>n</em> = 0, ..., 2<em>N</em>-1) that is multiplied with <em>x</em><sub><em>n</em></sub> and <em>y</em><sub><em>n</em></sub> in the MDCT and IMDCT formulas, above, in order to avoid discontinuities at the <em>n</em> = 0 and 2<em>N</em> boundaries by making the function go smoothly to zero at those points. (That is, we window the data <em>before</em> the MDCT and <em>after</em> the IMDCT.) In principle, <em>x</em> and <em>y</em> could have different window functions, and the window function could also change from one block to the next (especially for the case where data blocks of different sizes are combined), but for simplicity we consider the common case of identical window functions for equal-sized blocks.</p>

<p>The transform remains invertible (that is, TDAC works), for a symmetric window <em>w</em><sub><em>n</em></sub> = <em>w</em><sub>2<em>N</em>-1-<em>n</em></sub>, as long as <em>w</em> satisfies the <a href="Princen-Bradley_condition" title="wikilink">Princen-Bradley condition</a>:</p>

<p>

<math display="block" id="Modified_discrete_cosine_transform:3">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>w</mi>
     <mi>n</mi>
     <mn>2</mn>
    </msubsup>
    <mo>+</mo>
    <msubsup>
     <mi>w</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mi>N</mi>
     </mrow>
     <mn>2</mn>
    </msubsup>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>n</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <ci>N</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{n}^{2}+w_{n+N}^{2}=1
  </annotation>
 </semantics>
</math>

.</p>

<p>various window functions are used. A window that produces a form known as a modulated lapped transform<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> is given by</p>

<p>

<math display="block" id="Modified_discrete_cosine_transform:4">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>sin</mi>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mfrac>
       <mi>œÄ</mi>
       <mrow>
        <mn>2</mn>
        <mi>N</mi>
       </mrow>
      </mfrac>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mfrac>
         <mn>1</mn>
         <mn>2</mn>
        </mfrac>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <sin></sin>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>œÄ</ci>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>N</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{n}=\sin\left[\frac{\pi}{2N}\left(n+\frac{1}{2}\right)\right]
  </annotation>
 </semantics>
</math>

</p>

<p>and is used for MP3 and MPEG-2 AAC, and</p>

<p>

<math display="block" id="Modified_discrete_cosine_transform:5">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>sin</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mfrac>
       <mi>œÄ</mi>
       <mn>2</mn>
      </mfrac>
      <mrow>
       <msup>
        <mi>sin</mi>
        <mn>2</mn>
       </msup>
       <mrow>
        <mo>[</mo>
        <mrow>
         <mfrac>
          <mi>œÄ</mi>
          <mrow>
           <mn>2</mn>
           <mi>N</mi>
          </mrow>
         </mfrac>
         <mrow>
          <mo>(</mo>
          <mrow>
           <mi>n</mi>
           <mo>+</mo>
           <mfrac>
            <mn>1</mn>
            <mn>2</mn>
           </mfrac>
          </mrow>
          <mo>)</mo>
         </mrow>
        </mrow>
        <mo>]</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <sin></sin>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>œÄ</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <sin></sin>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <ci>œÄ</ci>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>N</ci>
         </apply>
        </apply>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{n}=\sin\left(\frac{\pi}{2}\sin^{2}\left[\frac{\pi}{2N}\left(n+\frac{1}{2}%
\right)\right]\right)
  </annotation>
 </semantics>
</math>

</p>

<p>for Vorbis. AC-3 uses a <a href="Kaiser-Bessel_derived_(KBD)_window" title="wikilink">Kaiser-Bessel derived (KBD) window</a>, and MPEG-4 AAC can also use a KBD window.</p>

<p>Note that windows applied to the MDCT are different from windows used for some other types of signal analysis, since they must fulfill the Princen-Bradley condition. One of the reasons for this difference is that MDCT windows are applied twice, for both the MDCT (analysis) and the IMDCT (synthesis).</p>
<h2 id="relationship-to-dct-iv-and-origin-of-tdac">Relationship to DCT-IV and Origin of TDAC</h2>

<p>As can be seen by inspection of the definitions, for <strong>even</strong> <em>N</em> the MDCT is essentially equivalent to a DCT-IV, where the input is shifted by <em>N</em>/2 and two <em>N</em>-blocks of data are transformed at once. By examining this equivalence more carefully, important properties like TDAC can be easily derived.</p>

<p>In order to define the precise relationship to the DCT-IV, one must realize that the DCT-IV corresponds to alternating even/odd boundary conditions: even at its left boundary (around <em>n</em>=‚àí1/2), odd at its right boundary (around <em>n</em>=<em>N</em>‚àí1/2), and so on (instead of periodic boundaries as for a <a href="discrete_Fourier_transform" title="wikilink">DFT</a>). This follows from the identities 

<math display="inline" id="Modified_discrete_cosine_transform:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>cos</mi>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mfrac>
       <mi>œÄ</mi>
       <mi>N</mi>
      </mfrac>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mrow>
         <mrow>
          <mo>-</mo>
          <mi>n</mi>
         </mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo>+</mo>
        <mfrac>
         <mn>1</mn>
         <mn>2</mn>
        </mfrac>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mfrac>
         <mn>1</mn>
         <mn>2</mn>
        </mfrac>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>cos</mi>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mfrac>
       <mi>œÄ</mi>
       <mi>N</mi>
      </mfrac>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mfrac>
         <mn>1</mn>
         <mn>2</mn>
        </mfrac>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mfrac>
         <mn>1</mn>
         <mn>2</mn>
        </mfrac>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <cos></cos>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>œÄ</ci>
       <ci>N</ci>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <apply>
         <minus></minus>
         <ci>n</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <cos></cos>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>œÄ</ci>
       <ci>N</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cos\left[\frac{\pi}{N}\left(-n-1+\frac{1}{2}\right)\left(k+\frac{1}{2}\right)%
\right]=\cos\left[\frac{\pi}{N}\left(n+\frac{1}{2}\right)\left(k+\frac{1}{2}%
\right)\right]
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Modified_discrete_cosine_transform:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>cos</mi>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mfrac>
       <mi>œÄ</mi>
       <mi>N</mi>
      </mfrac>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mrow>
         <mrow>
          <mn>2</mn>
          <mi>N</mi>
         </mrow>
         <mo>-</mo>
         <mi>n</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo>+</mo>
        <mfrac>
         <mn>1</mn>
         <mn>2</mn>
        </mfrac>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mfrac>
         <mn>1</mn>
         <mn>2</mn>
        </mfrac>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>cos</mi>
     <mrow>
      <mo>[</mo>
      <mrow>
       <mfrac>
        <mi>œÄ</mi>
        <mi>N</mi>
       </mfrac>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mfrac>
          <mn>1</mn>
          <mn>2</mn>
         </mfrac>
        </mrow>
        <mo>)</mo>
       </mrow>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mi>k</mi>
         <mo>+</mo>
         <mfrac>
          <mn>1</mn>
          <mn>2</mn>
         </mfrac>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
      <mo>]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <cos></cos>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>œÄ</ci>
       <ci>N</ci>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>N</ci>
        </apply>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <cos></cos>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <ci>œÄ</ci>
        <ci>N</ci>
       </apply>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cos\left[\frac{\pi}{N}\left(2N-n-1+\frac{1}{2}\right)\left(k+\frac{1}{2}%
\right)\right]=-\cos\left[\frac{\pi}{N}\left(n+\frac{1}{2}\right)\left(k+\frac%
{1}{2}\right)\right]
  </annotation>
 </semantics>
</math>

. Thus, if its inputs are an array <em>x</em> of length <em>N</em>, we can imagine extending this array to (<em>x</em>, ‚àí<em>x</em><sub><em>R</em></sub>, ‚àí<em>x</em>, <em>x</em><sub><em>R</em></sub>, ...) and so on, where <em>x</em><sub><em>R</em></sub> denotes <em>x</em> in reverse order.</p>

<p>Consider an MDCT with 2<em>N</em> inputs and <em>N</em> outputs, where we divide the inputs into four blocks (<em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>) each of size <em>N</em>/2. If we shift these to the right by <em>N</em>/2 (from the +<em>N</em>/2 term in the MDCT definition), then (<em>b</em>, <em>c</em>, <em>d</em>) extend past the end of the <em>N</em> DCT-IV inputs, so we must "fold" them back according to the boundary conditions described above.</p>
<dl>
<dd>Thus, the MDCT of 2<em>N</em> inputs (<em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>) is <em>exactly</em> equivalent to a DCT-IV of the <em>N</em> inputs: (‚àí<em>c</em><sub><em>R</em></sub>‚àí<em>d</em>, <em>a</em>‚àí<em>b</em><sub><em>R</em></sub>), where <em>R</em> denotes reversal as above.
</dd>
</dl>

<p>(In this way, any algorithm to compute the DCT-IV can be trivially applied to the MDCT.)</p>

<p>Similarly, the IMDCT formula above is precisely 1/2 of the DCT-IV (which is its own inverse), where the output is extended (via the boundary conditions) to a length 2<em>N</em> and shifted back to the left by <em>N</em>/2. The inverse DCT-IV would simply give back the inputs (‚àí<em>c</em><sub><em>R</em></sub>‚àí<em>d</em>, <em>a</em>‚àí<em>b</em><sub><em>R</em></sub>) from above. When this is extended via the boundary conditions and shifted, one obtains:</p>
<dl>
<dd>IMDCT(MDCT(<em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>)) = (<em>a</em>‚àí<em>b</em><sub><em>R</em></sub>, <em>b</em>‚àí<em>a</em><sub><em>R</em></sub>, <em>c</em>+<em>d</em><sub><em>R</em></sub>, <em>d</em>+<em>c</em><sub><em>R</em></sub>) / 2.
</dd>
</dl>

<p>Half of the IMDCT outputs are thus redundant, as <em>b</em>‚àí<em>a</em><sub><em>R</em></sub> = ‚àí(<em>a</em>‚àí<em>b</em><sub><em>R</em></sub>)<sub><em>R</em></sub>, and likewise for the last two terms. If we group the input into bigger blocks <em>A</em>,<em>B</em> of size <em>N</em>, where <em>A</em>=(<em>a</em>, <em>b</em>) and <em>B</em>=(<em>c</em>, <em>d</em>), we can write this result in a simpler way:</p>
<dl>
<dd>IMDCT(MDCT(<em>A</em>, <em>B</em>)) = (<em>A</em>‚àí<em>A</em><sub><em>R</em></sub>, <em>B</em>+<em>B</em><sub><em>R</em></sub>) / 2
</dd>
</dl>

<p>One can now understand how TDAC works. Suppose that one computes the MDCT of the subsequent, 50% overlapped, 2<em>N</em> block (<em>B</em>, <em>C</em>). The IMDCT will then yield, analogous to the above: (<em>B</em>‚àí<em>B</em><sub><em>R</em></sub>, <em>C</em>+<em>C</em><sub><em>R</em></sub>) / 2. When this is added with the previous IMDCT result in the overlapping half, the reversed terms cancel and one obtains simply <em>B</em>, recovering the original data.</p>
<h3 id="origin-of-tdac">Origin of TDAC</h3>

<p>The origin of the term "time-domain aliasing cancellation" is now clear. The use of input data that extend beyond the boundaries of the logical DCT-IV causes the data to be <em>aliased</em> in the same way that frequencies beyond the <a href="Nyquist_frequency" title="wikilink">Nyquist frequency</a> are <a href="aliasing" title="wikilink">aliased</a> to lower frequencies, except that this aliasing occurs in the time domain instead of the frequency domain: we cannot distinguish the contributions of <em>a</em> and of <em>b</em><sub><em>R</em></sub> to the MDCT of (<em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>), or equivalently, to the result of IMDCT(MDCT(<em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>)) = (<em>a</em>‚àí<em>b</em><sub><em>R</em></sub>, <em>b</em>‚àí<em>a</em><sub><em>R</em></sub>, <em>c</em>+<em>d</em><sub><em>R</em></sub>, <em>d</em>+<em>c</em><sub><em>R</em></sub>) / 2. The combinations <em>c</em>‚àí<em>d</em><sub><em>R</em></sub> and so on, have precisely the right signs for the combinations to cancel when they are added.</p>

<p>For <strong>odd</strong> <em>N</em> (which are rarely used in practice), <em>N</em>/2 is not an integer so the MDCT is not simply a shift permutation of a DCT-IV. In this case, the additional shift by half a sample means that the MDCT/IMDCT becomes equivalent to the DCT-III/II, and the analysis is analogous to the above.</p>
<h3 id="smoothness-and-discontinuities">Smoothness and discontinuities</h3>

<p>We have seen above that the MDCT of 2<em>N</em> inputs (<em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>) is equivalent to a DCT-IV of the <em>N</em> inputs (‚àí<em>c</em><sub><em>R</em></sub>‚àí<em>d</em>, <em>a</em>‚àí<em>b</em><sub><em>R</em></sub>). The DCT-IV is designed for the case where the function at the right boundary is odd, and therefore the values near the right boundary are close to 0. If the input signal is smooth, this is the case: the rightmost components of <em>a</em> and <em>b</em><sub><em>R</em></sub> are consecutive in the input sequence (<em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>), and therefore their difference is small. Let us look at the middle of the interval: if we rewrite the above expression as (‚àí<em>c</em><sub><em>R</em></sub>‚àí<em>d</em>, <em>a</em>‚àí<em>b</em><sub><em>R</em></sub>) = (‚àí<em>d</em>, <em>a</em>)‚àí(<em>b</em>,<em>c</em>)<sub><em>R</em></sub>, the second term, (<em>b</em>,<em>c</em>)<sub><em>R</em></sub>, gives a smooth transition in the middle. However, in the first term, (‚àí<em>d</em>, <em>a</em>), there is a potential discontinuitiy where the right end of ‚àí<em>d</em> meets the left end of <em>a</em>. This is the reason for using a window function that reduces the components near the boundaries of the input sequence (<em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>) towards 0.</p>
<h3 id="tdac-for-the-windowed-mdct">TDAC for the windowed MDCT</h3>

<p>Above, the TDAC property was proved for the ordinary MDCT, showing that adding IMDCTs of subsequent blocks in their overlapping half recovers the original data. The derivation of this inverse property for the windowed MDCT is only slightly more complicated.</p>

<p>Consider to overlapping consecutive sets of 2<em>N</em> inputs (<em>A</em>,<em>B</em>) and (<em>B</em>,<em>C</em>), for blocks <em>A</em>,<em>B</em>,<em>C</em> of size <em>N</em>. Recall from above that when 

<math display="inline" id="Modified_discrete_cosine_transform:8">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>A</mi>
   <mo>,</mo>
   <mi>B</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>A</ci>
    <ci>B</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A,B)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Modified_discrete_cosine_transform:9">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>B</mi>
   <mo>,</mo>
   <mi>C</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>B</ci>
    <ci>C</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (B,C)
  </annotation>
 </semantics>
</math>

 are MDCTed, IMDCTed, and added in their overlapping half, we obtain 

<math display="inline" id="Modified_discrete_cosine_transform:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>B</mi>
       <mo>+</mo>
       <msub>
        <mi>B</mi>
        <mi>R</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>B</mi>
       <mo>-</mo>
       <msub>
        <mi>B</mi>
        <mi>R</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <ci>B</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <ci>R</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>B</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <ci>R</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (B+B_{R})/2+(B-B_{R})/2=B
  </annotation>
 </semantics>
</math>

, the original data.</p>

<p>Now we suppose that we multiply <em>both</em> the MDCT inputs <em>and</em> the IMDCT outputs by a window function of length 2<em>N</em>. As above, we assume a symmetric window function, which is therefore of the form 

<math display="inline" id="Modified_discrete_cosine_transform:11">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>W</mi>
   <mo>,</mo>
   <msub>
    <mi>W</mi>
    <mi>R</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>W</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <ci>R</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (W,W_{R})
  </annotation>
 </semantics>
</math>

 where <em>W</em> is a length-<em>N</em> vector and <em>R</em> denotes reversal as before. Then the Princen-Bradley condition can be written as 

<math display="inline" id="Modified_discrete_cosine_transform:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>W</mi>
    <mo>+</mo>
    <msubsup>
     <mi>W</mi>
     <mi>R</mi>
     <mn>2</mn>
    </msubsup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <ci>W</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <ci>R</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <vector>
     <cn type="integer">1</cn>
     <cn type="integer">1</cn>
     <ci>normal-‚Ä¶</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W+W_{R}^{2}=(1,1,\ldots)
  </annotation>
 </semantics>
</math>

, with the squares and additions performed elementwise.</p>

<p>Therefore, instead of MDCTing 

<math display="inline" id="Modified_discrete_cosine_transform:13">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>A</mi>
   <mo>,</mo>
   <mi>B</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>A</ci>
    <ci>B</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A,B)
  </annotation>
 </semantics>
</math>

, we now MDCT 

<math display="inline" id="Modified_discrete_cosine_transform:14">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>W</mi>
    <mi>A</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>W</mi>
     <mi>R</mi>
    </msub>
    <mi>B</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <times></times>
     <ci>W</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <ci>R</ci>
     </apply>
     <ci>B</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (WA,W_{R}B)
  </annotation>
 </semantics>
</math>

 (with all multiplications performed elementwise). When this is IMDCTed and multiplied again (elementwise) by the window function, the last-<em>N</em> half becomes:</p>

<p>

<math display="block" id="Modified_discrete_cosine_transform:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>W</mi>
     <mi>R</mi>
    </msub>
    <mo>‚ãÖ</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>W</mi>
        <mi>R</mi>
       </msub>
       <mi>B</mi>
      </mrow>
      <mo>+</mo>
      <msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>W</mi>
          <mi>R</mi>
         </msub>
         <mi>B</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>R</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>W</mi>
     <mi>R</mi>
    </msub>
    <mo>‚ãÖ</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>W</mi>
        <mi>R</mi>
       </msub>
       <mi>B</mi>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>W</mi>
       <msub>
        <mi>B</mi>
        <mi>R</mi>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msubsup>
      <mi>W</mi>
      <mi>R</mi>
      <mn>2</mn>
     </msubsup>
     <mi>B</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>W</mi>
     <msub>
      <mi>W</mi>
      <mi>R</mi>
     </msub>
     <msub>
      <mi>B</mi>
      <mi>R</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-‚ãÖ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <ci>R</ci>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>W</ci>
         <ci>R</ci>
        </apply>
        <ci>B</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>W</ci>
          <ci>R</ci>
         </apply>
         <ci>B</ci>
        </apply>
        <ci>R</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>normal-‚ãÖ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <ci>R</ci>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>W</ci>
         <ci>R</ci>
        </apply>
        <ci>B</ci>
       </apply>
       <apply>
        <times></times>
        <ci>W</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>B</ci>
         <ci>R</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>W</ci>
         <ci>R</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>B</ci>
      </apply>
      <apply>
       <times></times>
       <ci>W</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>W</ci>
        <ci>R</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <ci>R</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{R}\cdot(W_{R}B+(W_{R}B)_{R})=W_{R}\cdot(W_{R}B+WB_{R})=W_{R}^{2}B+WW_{R}B_{R}
  </annotation>
 </semantics>
</math>

. (Note that we no longer have the multiplication by 1/2, because the IMDCT normalization differs by a factor of 2 in the windowed case.)</p>

<p>Similarly, the windowed MDCT and IMDCT of 

<math display="inline" id="Modified_discrete_cosine_transform:16">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>B</mi>
   <mo>,</mo>
   <mi>C</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>B</ci>
    <ci>C</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (B,C)
  </annotation>
 </semantics>
</math>

 yields, in its first-<em>N</em> half:</p>

<p>

<math display="block" id="Modified_discrete_cosine_transform:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>W</mi>
    <mo>‚ãÖ</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>W</mi>
       <mi>B</mi>
      </mrow>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>W</mi>
        <mi>R</mi>
       </msub>
       <msub>
        <mi>B</mi>
        <mi>R</mi>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>W</mi>
      <mn>2</mn>
     </msup>
     <mi>B</mi>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>W</mi>
     <msub>
      <mi>W</mi>
      <mi>R</mi>
     </msub>
     <msub>
      <mi>B</mi>
      <mi>R</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-‚ãÖ</ci>
     <ci>W</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>W</ci>
       <ci>B</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>W</ci>
        <ci>R</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <ci>R</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>W</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>B</ci>
     </apply>
     <apply>
      <times></times>
      <ci>W</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <ci>R</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>R</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W\cdot(WB-W_{R}B_{R})=W^{2}B-WW_{R}B_{R}
  </annotation>
 </semantics>
</math>

.</p>

<p>When we add these two halves together, we obtain:</p>

<p>

<math display="block" id="Modified_discrete_cosine_transform:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msubsup>
         <mi>W</mi>
         <mi>R</mi>
         <mn>2</mn>
        </msubsup>
        <mi>B</mi>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>W</mi>
        <msub>
         <mi>W</mi>
         <mi>R</mi>
        </msub>
        <msub>
         <mi>B</mi>
         <mi>R</mi>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msup>
         <mi>W</mi>
         <mn>2</mn>
        </msup>
        <mi>B</mi>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>W</mi>
        <msub>
         <mi>W</mi>
         <mi>R</mi>
        </msub>
        <msub>
         <mi>B</mi>
         <mi>R</mi>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msubsup>
        <mi>W</mi>
        <mi>R</mi>
        <mn>2</mn>
       </msubsup>
       <mo>+</mo>
       <msup>
        <mi>W</mi>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mi>B</mi>
    </mrow>
    <mo>=</mo>
    <mi>B</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>W</ci>
          <ci>R</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <ci>B</ci>
       </apply>
       <apply>
        <times></times>
        <ci>W</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>W</ci>
         <ci>R</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>B</ci>
         <ci>R</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>W</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>B</ci>
       </apply>
       <apply>
        <times></times>
        <ci>W</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>W</ci>
         <ci>R</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>B</ci>
         <ci>R</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>W</ci>
         <ci>R</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>W</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (W_{R}^{2}B+WW_{R}B_{R})+(W^{2}B-WW_{R}B_{R})=\left(W_{R}^{2}+W^{2}\right)B=B,
  </annotation>
 </semantics>
</math>

</p>

<p>recovering the original data.</p>
<h2 id="see-also">See also</h2>

<p>Other overlapping windowed Fourier transforms include:</p>
<ul>
<li><a href="Modulated_complex_lapped_transform" title="wikilink">Modulated complex lapped transform</a></li>
<li><a href="Short-time_Fourier_transform" title="wikilink">Short-time Fourier transform</a></li>
<li><a href="Welch's_method" title="wikilink">Welch's method</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Henrique S. Malvar, <em>Signal Processing with Lapped Transforms</em> (Artech House: Norwood MA, 1992).</li>
<li>A. W. Johnson and A. B. Bradley, "Adaptive transform coding incorporating time domain aliasing cancellation," <em>Speech Comm.</em> <strong>6</strong>, 299-308 (1987).</li>
<li>For algorithms, see e.g.:
<ul>
<li>Chi-Min Liu and Wen-Chieh Lee, "<a href="http://wenchiehlee1020.googlepages.com/AES-paper-vol.47.PDF">A unified fast algorithm for cosine modulated filterbanks in current audio standards</a>", <em>J. Audio Engineering</em> <strong>47</strong> (12), 1061-1075 (1999).</li>
<li>V. Britanak and K. R. Rao, "A new fast algorithm for the unified forward and inverse MDCT/MDST computation," <em>Signal Processing</em> <strong>82</strong>, 433-459 (2002)</li>
<li>Vladimir Nikolajevic and Gerhard Fettweis, "Computation of forward and inverse MDCT using Clenshaw's recurrence formula," <em>IEEE Trans. Sig. Proc.</em> <strong>51</strong> (5), 1439-1444 (2003)</li>
<li>Che-Hong Chen, Bin-Da Liu, and Jar-Ferr Yang, "Recursive architectures for realizing modified discrete cosine transform and its inverse," <em>IEEE Trans. Circuits Syst. II: Analog Dig. Sig. Proc.</em> <strong>50</strong> (1), 38-45 (2003)</li>
<li>J.S. Wu, H.Z. Shu, L. Senhadji, and L.M. Luo, "Mixed-radix algorithm for the computation of forward and inverse MDCTs," <em>IEEE Trans. Circuits Syst. I: Reg. Papers</em> <strong>56</strong> (4), 784-794 (2009)</li>
<li>V. Britanak, "A survey of efficient MDCT implementations in MP3 audio coding standard: retrospective and state-of-the-art," <em>Signal. Process.</em> <strong>91</strong> (4), 624-672(2011)</li>
<li>...and references thereof.</li>
</ul></li>
</ul>

<p>"</p>

<p><a href="Category:Fourier_analysis" title="wikilink">Category:Fourier analysis</a> <a href="Category:Discrete_transforms" title="wikilink">Category:Discrete transforms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">J. P. Princen, A. W. Johnson und A. B. Bradley: <em>Subband/transform coding using filter bank designs based on time domain aliasing cancellation</em>, IEEE Proc. Intl. Conference on Acoustics, Speech, and Signal Processing (ICASSP), 2161‚Äì2164, 1987. Initial description of what is now called the MDCT.<a href="#fnref1">‚Ü©</a></li>
<li id="fn2">John P. Princen, Alan B. Bradley: <em>Analysis/synthesis filter bank design based on time domain aliasing cancellation</em>, IEEE Trans. Acoust. Speech Signal Processing, <em>ASSP-34</em> (5), 1153‚Äì1161, 1986. Described a precursor to the MDCT using a combination of discrete cosine and sine transforms.<a href="#fnref2">‚Ü©</a></li>
<li id="fn3">H. S. Malvar, "Lapped Transforms for Efficient Transform/Subband Coding", <em>IEEE Trans. on Acoustics, Speech, and Signal Processing</em>, vol. 38, no. 6, pp. 969‚Äì978 (Equation 22), June 1990.<a href="#fnref3">‚Ü©</a></li>
<li id="fn4">H. S. Malvar, "Modulated QMF Filter Banks with Perfect Reconstruction", <em>Electronics Letters</em>, vol. 26, no. 13, pp. 906‚Äì907 (Equation 13), June 1990.<a href="#fnref4">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
