<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1173">K-approximation of k-hitting set</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>K-approximation of k-hitting set</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, <strong>k-approximation of k-hitting set</strong> is an <a href="approximation_algorithm" title="wikilink">approximation algorithm</a> for weighted <a href="hitting_set" title="wikilink">hitting set</a>. The input is a <a href="Collection_(computing)" title="wikilink">collection</a> <em>S</em> of <a href="subset" title="wikilink">subsets</a> of some universe <em>T</em> and a <a href="Map_(mathematics)" title="wikilink">mapping</a> <em>W</em> from <em>T</em> to non-negative numbers called the weights of the elements of <em>T</em>. In <strong>k-hitting set</strong> the size of the sets in <em>S</em> cannot be larger than <em>k</em>. That is, 

<math display="inline" id="K-approximation_of_k-hitting_set:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>i</mi>
    </mrow>
    <mo>∈</mo>
    <mi>S</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>i</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>≤</mo>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>i</ci>
     </apply>
     <ci>S</ci>
    </apply>
    <apply>
     <leq></leq>
     <apply>
      <abs></abs>
      <ci>i</ci>
     </apply>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall i\in S:|i|\leq k
  </annotation>
 </semantics>
</math>

. The problem is now to pick some subset <em>T</em>' of <em>T</em> such that every set in <em>S</em> contains some element of <em>T</em>', and such that the total weight of all elements in <em>T</em>' is as small as possible.</p>
<h2 id="the-algorithm">The algorithm</h2>

<p>For each set 

<math display="inline" id="K-approximation_of_k-hitting_set:1">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 in <em>S</em> is maintained a <em>price</em>, 

<math display="inline" id="K-approximation_of_k-hitting_set:2">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{j}
  </annotation>
 </semantics>
</math>

, which is initially 0. For an element <em>a</em> in <em>T</em>, let <em>S</em>(<em>a</em>) be the collection of sets from <em>S</em> containing <em>a</em>. During the algorithm the following invariant is kept</p>

<p>

<math display="block" id="K-approximation_of_k-hitting_set:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mi>a</mi>
     </mrow>
     <mo>∈</mo>
     <mi>T</mi>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>∈</mo>
        <mrow>
         <mi>S</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>a</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </munder>
      <msub>
       <mi>p</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo>≤</mo>
     <mrow>
      <mi>W</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>a</ci>
     </apply>
     <ci>T</ci>
    </apply>
    <apply>
     <leq></leq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>j</ci>
        <apply>
         <times></times>
         <ci>S</ci>
         <ci>a</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>W</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall a\in T:\sum_{j\in S(a)}p_{j}\leq W(a).\,
  </annotation>
 </semantics>
</math>

</p>

<p>We say that an element, <em>a</em>, from <em>T</em> is <em>tight</em> if 

<math display="inline" id="K-approximation_of_k-hitting_set:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mrow>
      <mi>j</mi>
      <mo>∈</mo>
      <mrow>
       <mi>S</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msub>
    <msub>
     <mi>p</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>W</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <apply>
       <in></in>
       <ci>j</ci>
       <apply>
        <times></times>
        <ci>S</ci>
        <ci>a</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>W</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{j\in S(a)}p_{j}=W(a)
  </annotation>
 </semantics>
</math>

. The main part of the algorithm consists of a loop: As long as there is a set in <em>S</em> that contains an element from <em>T</em> which is not tight, the price of this set is increased as much as possible without violating the invariant above. When this loop exits, all sets contain some tight element. Pick all the tight elements to be the hitting set.</p>
<h2 id="correctness">Correctness</h2>

<p>The algorithm always terminates because in each iteration of the loop the price of some set in <em>S</em> is increased enough to make one more element from <em>T</em> tight. If it cannot increase any price, it exits. It runs in polynomial time because the loop will not make more iterations than the number of elements in the union of all the sets of <em>S</em>. It returns a hitting set, because when the loop exits, all sets in <em>S</em> contain a tight element from <em>T</em>, and the set of these tight elements are returned.</p>

<p>Note that for any hitting set <em>T*</em> and any prices 

<math display="inline" id="K-approximation_of_k-hitting_set:5">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>S</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <apply>
      <abs></abs>
      <ci>S</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1},\ldots,p_{|S|}
  </annotation>
 </semantics>
</math>

 where the invariant from the algorithm is true, the total weight of the hitting set is an upper limit to the sum over all members of <em>T*</em> of the sum of the prices of sets containing this element, that is

<math display="block" id="K-approximation_of_k-hitting_set:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mrow>
      <mi>a</mi>
      <mo>∈</mo>
      <msup>
       <mi>T</mi>
       <mo>*</mo>
      </msup>
     </mrow>
    </msub>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mrow>
      <mi>j</mi>
      <mo>∈</mo>
      <mrow>
       <mi>S</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msub>
    <msub>
     <mi>p</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mrow>
      <mi>a</mi>
      <mo>∈</mo>
      <msup>
       <mi>T</mi>
       <mo>*</mo>
      </msup>
     </mrow>
    </msub>
    <mi>W</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <apply>
       <in></in>
       <ci>a</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>T</ci>
        <times></times>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <apply>
       <in></in>
       <ci>j</ci>
       <apply>
        <times></times>
        <ci>S</ci>
        <ci>a</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <apply>
       <in></in>
       <ci>a</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>T</ci>
        <times></times>
       </apply>
      </apply>
     </apply>
     <ci>W</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{a\in T^{*}}\Sigma_{j\in S(a)}p_{j}\leq\Sigma_{a\in T^{*}}W(a)
  </annotation>
 </semantics>
</math>

. This follows from the invariant property. Further, since the price of every set must occur at least once on the left hand side, we get 

<math display="inline" id="K-approximation_of_k-hitting_set:7">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mrow>
      <mi>j</mi>
      <mo>∈</mo>
      <mi>S</mi>
     </mrow>
    </msub>
    <msub>
     <mi>p</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mrow>
      <mi>a</mi>
      <mo>∈</mo>
      <msup>
       <mi>T</mi>
       <mo>*</mo>
      </msup>
     </mrow>
    </msub>
    <mi>W</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <apply>
       <in></in>
       <ci>j</ci>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <apply>
       <in></in>
       <ci>a</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>T</ci>
        <times></times>
       </apply>
      </apply>
     </apply>
     <ci>W</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{j\in S}p_{j}\leq\Sigma_{a\in T^{*}}W(a)
  </annotation>
 </semantics>
</math>

. Especially, this property is true for the optimal hitting set.</p>

<p>Further, for the hitting set <em>H</em> returned from the algorithm above, we have 

<math display="inline" id="K-approximation_of_k-hitting_set:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mrow>
      <mi>a</mi>
      <mo>∈</mo>
      <mi>H</mi>
     </mrow>
    </msub>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mrow>
      <mi>j</mi>
      <mo>∈</mo>
      <mrow>
       <mi>S</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msub>
    <msub>
     <mi>p</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mrow>
      <mi>a</mi>
      <mo>∈</mo>
      <mi>H</mi>
     </mrow>
    </msub>
    <mi>W</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <apply>
       <in></in>
       <ci>a</ci>
       <ci>H</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <apply>
       <in></in>
       <ci>j</ci>
       <apply>
        <times></times>
        <ci>S</ci>
        <ci>a</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <apply>
       <in></in>
       <ci>a</ci>
       <ci>H</ci>
      </apply>
     </apply>
     <ci>W</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{a\in H}\Sigma_{j\in S(a)}p_{j}=\Sigma_{a\in H}W(a)
  </annotation>
 </semantics>
</math>

. Since any price 

<math display="inline" id="K-approximation_of_k-hitting_set:9">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{j}
  </annotation>
 </semantics>
</math>

 can appear at most <em>k</em> times in the left-hand side (since subsets of <em>S</em> can contain no more than <em>k</em> element from <em>T</em>) we get 

<math display="inline" id="K-approximation_of_k-hitting_set:10">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mrow>
      <mi>a</mi>
      <mo>∈</mo>
      <mi>H</mi>
     </mrow>
    </msub>
    <mi>W</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mi>k</mi>
     <mo>⋅</mo>
     <msub>
      <mi mathvariant="normal">Σ</mi>
      <mrow>
       <mi>j</mi>
       <mo>∈</mo>
       <mi>S</mi>
      </mrow>
     </msub>
    </mrow>
    <msub>
     <mi>p</mi>
     <mi>j</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <apply>
       <in></in>
       <ci>a</ci>
       <ci>H</ci>
      </apply>
     </apply>
     <ci>W</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <ci>k</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Σ</ci>
       <apply>
        <in></in>
        <ci>j</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{a\in H}W(a)\leq k\cdot\Sigma_{j\in S}p_{j}
  </annotation>
 </semantics>
</math>

 Combined with the previous paragraph we get 

<math display="inline" id="K-approximation_of_k-hitting_set:11">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mrow>
      <mi>a</mi>
      <mo>∈</mo>
      <mi>H</mi>
     </mrow>
    </msub>
    <mi>W</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mi>k</mi>
     <mo>⋅</mo>
     <msub>
      <mi mathvariant="normal">Σ</mi>
      <mrow>
       <mi>a</mi>
       <mo>∈</mo>
       <msup>
        <mi>T</mi>
        <mo>*</mo>
       </msup>
      </mrow>
     </msub>
    </mrow>
    <mi>W</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <apply>
       <in></in>
       <ci>a</ci>
       <ci>H</ci>
      </apply>
     </apply>
     <ci>W</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <ci>k</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Σ</ci>
       <apply>
        <in></in>
        <ci>a</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>T</ci>
         <times></times>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>W</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{a\in H}W(a)\leq k\cdot\Sigma_{a\in T^{*}}W(a)
  </annotation>
 </semantics>
</math>

, where <em>T*</em> is the optimal hitting set. This is exactly the guarantee that it is a k-approximation algorithm.</p>
<h2 id="relation-to-linear-programming">Relation to linear programming</h2>

<p>This algorithm is an instance of the <a href="primal-dual_method" title="wikilink">primal-dual method</a>, also called <strong>the pricing method</strong>. The intuition is that it is <a href="duality_(mathematics)" title="wikilink">dual</a> to a <a href="linear_programming" title="wikilink">linear programming</a> algorithm. For an explanation see <a class="uri" href="http://algo.inria.fr/seminars/sem00-01/vazirani.html">http://algo.inria.fr/seminars/sem00-01/vazirani.html</a>.</p>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li></li>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Approximation_algorithms" title="wikilink">Category:Approximation algorithms</a></p>
</body>
</html>
