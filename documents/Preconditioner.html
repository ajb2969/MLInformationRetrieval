<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="89">Preconditioner</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Preconditioner</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <strong>preconditioning</strong> is the application of a transformation, called the <strong>preconditioner</strong>, that conditions a given problem into a form that is more suitable for numerical solving methods. Preconditioning is typically related to reducing a <a href="condition_number" title="wikilink">condition number</a> of the problem. The preconditioned problem is then usually solved by an <a href="iterative_method" title="wikilink">iterative method</a>.</p>
<h2 id="preconditioning-for-linear-systems">Preconditioning for linear systems</h2>

<p>In <a href="linear_algebra" title="wikilink">linear algebra</a> and <a href="numerical_analysis" title="wikilink">numerical analysis</a>, a <strong>preconditioner</strong> 

<math display="inline" id="Preconditioner:0">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 of a matrix 

<math display="inline" id="Preconditioner:1">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is a matrix such that 

<math display="inline" id="Preconditioner:2">
 <semantics>
  <mrow>
   <msup>
    <mi>P</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}A
  </annotation>
 </semantics>
</math>

 has a smaller <a href="condition_number" title="wikilink">condition number</a> than 

<math display="inline" id="Preconditioner:3">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. It is also common to call 

<math display="inline" id="Preconditioner:4">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <msup>
    <mi>P</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=P^{-1}
  </annotation>
 </semantics>
</math>

 the preconditioner, rather than 

<math display="inline" id="Preconditioner:5">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, since 

<math display="inline" id="Preconditioner:6">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 itself is rarely explicitly available. In modern preconditioning, the application of 

<math display="inline" id="Preconditioner:7">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <msup>
    <mi>P</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=P^{-1}
  </annotation>
 </semantics>
</math>

, i.e., multiplication of a column vector, or a block of column vectors, by 

<math display="inline" id="Preconditioner:8">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <msup>
    <mi>P</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=P^{-1}
  </annotation>
 </semantics>
</math>

, is commonly performed by rather sophisticated computer software packages in a <a href="Matrix-free_methods" title="wikilink">matrix-free fashion</a>, i.e., where neither 

<math display="inline" id="Preconditioner:9">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, nor 

<math display="inline" id="Preconditioner:10">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <msup>
    <mi>P</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=P^{-1}
  </annotation>
 </semantics>
</math>

 (and often not even 

<math display="inline" id="Preconditioner:11">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

) are explicitly available in a matrix form.</p>

<p>Preconditioners are useful in <a href="iterative_methods" title="wikilink">iterative methods</a> to solve a linear system 

<math display="inline" id="Preconditioner:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>x</ci>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ax=b
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Preconditioner:13">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 since the <a href="rate_of_convergence" title="wikilink">rate of convergence</a> for most iterative linear solvers increases as the <a href="condition_number" title="wikilink">condition number</a> of a matrix decreases as a result of preconditioning. Preconditioned iterative solvers typically outperform direct solvers, e.g., <a href="Gaussian_elimination" title="wikilink">Gaussian elimination</a>, for large, especially for <a href="sparse_matrix" title="wikilink">sparse</a>, matrices. Iterative solvers can be used as <a href="matrix-free_methods" title="wikilink">matrix-free methods</a>, i.e. become the only choice if the coefficient matrix 

<math display="inline" id="Preconditioner:14">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is not stored explicitly, but is accessed by evaluating matrix-vector products.</p>
<h3 id="description">Description</h3>

<p>Instead of solving the original linear system above, one may solve either the right preconditioned system:</p>

<p>

<math display="block" id="Preconditioner:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <msup>
     <mi>P</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>P</mi>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   AP^{-1}Px=b
  </annotation>
 </semantics>
</math>

</p>

<p>via solving</p>

<p>

<math display="block" id="Preconditioner:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <msup>
     <mi>P</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>y</ci>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   AP^{-1}y=b
  </annotation>
 </semantics>
</math>

</p>

<p>for 

<math display="inline" id="Preconditioner:17">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="Preconditioner:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Px=y
  </annotation>
 </semantics>
</math>

</p>

<p>for 

<math display="inline" id="Preconditioner:19">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

; or the left preconditioned system:</p>

<p>

<math display="block" id="Preconditioner:20">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>P</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>A</mi>
       <mi>x</mi>
      </mrow>
      <mo>-</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>x</ci>
      </apply>
      <ci>b</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}(Ax-b)=0
  </annotation>
 </semantics>
</math>

</p>

<p>both of which give the same solution as the original system so long as the preconditioner matrix 

<math display="inline" id="Preconditioner:21">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is <a class="uri" href="nonsingular" title="wikilink">nonsingular</a>. The left preconditioning is more common.</p>

<p>The goal of this preconditioned system is to reduce the <a href="condition_number" title="wikilink">condition number</a> of the left or right preconditioned system matrix 

<math display="inline" id="Preconditioner:22">
 <semantics>
  <mrow>
   <msup>
    <mi>P</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}A
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Preconditioner:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <msup>
     <mi>P</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   AP^{-1},
  </annotation>
 </semantics>
</math>

 respectively. The preconditioned matrix 

<math display="inline" id="Preconditioner:24">
 <semantics>
  <mrow>
   <msup>
    <mi>P</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}A
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Preconditioner:25">
 <semantics>
  <mrow>
   <mi>A</mi>
   <msup>
    <mi>P</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   AP^{-1}
  </annotation>
 </semantics>
</math>

 is almost never explicitly formed. Only the action of applying the preconditioner solve operation 

<math display="inline" id="Preconditioner:26">
 <semantics>
  <msup>
   <mi>P</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>P</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}
  </annotation>
 </semantics>
</math>

 to a given vector need to be computed in iterative methods.</p>

<p>Typically there is a trade-off in the choice of 

<math display="inline" id="Preconditioner:27">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

. Since the operator 

<math display="inline" id="Preconditioner:28">
 <semantics>
  <msup>
   <mi>P</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>P</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}
  </annotation>
 </semantics>
</math>

 must be applied at each step of the iterative linear solver, it should have a small cost (computing time) of applying the 

<math display="inline" id="Preconditioner:29">
 <semantics>
  <msup>
   <mi>P</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>P</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}
  </annotation>
 </semantics>
</math>

 operation. The cheapest preconditioner would therefore be 

<math display="inline" id="Preconditioner:30">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=I
  </annotation>
 </semantics>
</math>

 since then 

<math display="inline" id="Preconditioner:31">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>P</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>=</mo>
    <mi>I</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}=I.
  </annotation>
 </semantics>
</math>

 Clearly, this results in the original linear system and the preconditioner does nothing. At the other extreme, the choice 

<math display="inline" id="Preconditioner:32">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=A
  </annotation>
 </semantics>
</math>

 gives 

<math display="inline" id="Preconditioner:33">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>P</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mi>A</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>A</mi>
     <msup>
      <mi>P</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>=</mo>
    <mi>I</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>P</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>A</ci>
     </apply>
     <apply>
      <times></times>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>P</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}A=AP^{-1}=I,
  </annotation>
 </semantics>
</math>

 which has optimal <a href="condition_number" title="wikilink">condition number</a> of 1, requiring a single iteration for convergence; however in this case 

<math display="inline" id="Preconditioner:34">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>P</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>=</mo>
    <msup>
     <mi>A</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}=A^{-1},
  </annotation>
 </semantics>
</math>

 and applying the preconditioner is as difficult as solving the original system. One therefore chooses 

<math display="inline" id="Preconditioner:35">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 as somewhere between these two extremes, in an attempt to achieve a minimal number of linear iterations while keeping the operator 

<math display="inline" id="Preconditioner:36">
 <semantics>
  <msup>
   <mi>P</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>P</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}
  </annotation>
 </semantics>
</math>

 as simple as possible. Some examples of typical preconditioning approaches are detailed below.</p>
<h3 id="preconditioned-iterative-methods">Preconditioned iterative methods</h3>

<p>Preconditioned iterative methods for 

<math display="inline" id="Preconditioner:37">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mi>x</mi>
    </mrow>
    <mo>-</mo>
    <mi>b</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>x</ci>
     </apply>
     <ci>b</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ax-b=0
  </annotation>
 </semantics>
</math>

 are, in most cases, mathematically equivalent to standard iterative methods applied to the preconditioned system 

<math display="inline" id="Preconditioner:38">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>P</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>A</mi>
       <mi>x</mi>
      </mrow>
      <mo>-</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>x</ci>
      </apply>
      <ci>b</ci>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}(Ax-b)=0.
  </annotation>
 </semantics>
</math>

 For example, the standard <a href="Richardson_iteration" title="wikilink">Richardson iteration</a> for solving 

<math display="inline" id="Preconditioner:39">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mi>x</mi>
    </mrow>
    <mo>-</mo>
    <mi>b</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>x</ci>
     </apply>
     <ci>b</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ax-b=0
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="block" id="Preconditioner:40">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐱</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>𝐱</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>γ</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>A</mi>
         <msub>
          <mi>𝐱</mi>
          <mi>n</mi>
         </msub>
        </mrow>
        <mo>-</mo>
        <mi>𝐛</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">,</mo>
   <mrow>
    <mi>n</mi>
    <mo>≥</mo>
    <mn>0.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>A</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐱</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <ci>𝐛</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <ci>n</ci>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{n+1}=\mathbf{x}_{n}-\gamma_{n}(A\mathbf{x}_{n}-\mathbf{b}),\ n\geq
0.
  </annotation>
 </semantics>
</math>

</p>

<p>Applied to the preconditioned system 

<math display="inline" id="Preconditioner:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>P</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>A</mi>
        <mi>x</mi>
       </mrow>
       <mo>-</mo>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>x</ci>
      </apply>
      <ci>b</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}(Ax-b)=0,
  </annotation>
 </semantics>
</math>

 it turns into a preconditioned method</p>

<p>

<math display="block" id="Preconditioner:42">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐱</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>𝐱</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>γ</mi>
       <mi>n</mi>
      </msub>
      <msup>
       <mi>P</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>A</mi>
         <msub>
          <mi>𝐱</mi>
          <mi>n</mi>
         </msub>
        </mrow>
        <mo>-</mo>
        <mi>𝐛</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">,</mo>
   <mrow>
    <mi>n</mi>
    <mo>≥</mo>
    <mn>0.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>P</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>A</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐱</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <ci>𝐛</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <ci>n</ci>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{n+1}=\mathbf{x}_{n}-\gamma_{n}P^{-1}(A\mathbf{x}_{n}-\mathbf{b}),%
\ n\geq 0.
  </annotation>
 </semantics>
</math>

</p>

<p>Examples of popular preconditioned <a href="iterative_methods" title="wikilink">iterative methods</a> for linear systems include the <a href="preconditioned_conjugate_gradient_method" title="wikilink">preconditioned conjugate gradient method</a>, the <a href="biconjugate_gradient_method" title="wikilink">biconjugate gradient method</a>, and <a href="generalized_minimal_residual_method" title="wikilink">generalized minimal residual method</a>. Iterative methods, which use scalar products to compute the iterative parameters, require corresponding changes in the scalar product together with substituting 

<math display="inline" id="Preconditioner:43">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>P</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>A</mi>
       <mi>x</mi>
      </mrow>
      <mo>-</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>x</ci>
      </apply>
      <ci>b</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}(Ax-b)=0
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Preconditioner:44">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mi>x</mi>
    </mrow>
    <mo>-</mo>
    <mi>b</mi>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>x</ci>
     </apply>
     <ci>b</ci>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ax-b=0.
  </annotation>
 </semantics>
</math>

</p>
<h3 id="geometric-interpretation">Geometric interpretation</h3>

<p>For a <a href="Symmetric_matrix" title="wikilink">symmetric</a> <a href="Positive-definite_matrix" title="wikilink">positive definite</a> matrix 

<math display="inline" id="Preconditioner:45">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 the preconditioner 

<math display="inline" id="Preconditioner:46">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is typically chosen to be symmetric positive definite as well. The preconditioned operator 

<math display="inline" id="Preconditioner:47">
 <semantics>
  <mrow>
   <msup>
    <mi>P</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}A
  </annotation>
 </semantics>
</math>

 is then also symmetric positive definite, but with respect to the 

<math display="inline" id="Preconditioner:48">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

-based <a href="scalar_product" title="wikilink">scalar product</a>. In this case, the desired effect in applying a preconditioner is to make the <a href="quadratic_form" title="wikilink">quadratic form</a> of the preconditioned operator 

<math display="inline" id="Preconditioner:49">
 <semantics>
  <mrow>
   <msup>
    <mi>P</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}A
  </annotation>
 </semantics>
</math>

 with respect to the 

<math display="inline" id="Preconditioner:50">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

-based <a href="scalar_product" title="wikilink">scalar product</a> to be nearly spherical <a href="http://www.cs.cmu.edu/~quake-papers/painless-conjugate-gradient.pdf">1</a>.</p>
<h3 id="variable-and-non-linear-preconditioning">Variable and non-linear preconditioning</h3>

<p>Denoting 

<math display="inline" id="Preconditioner:51">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <msup>
    <mi>P</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=P^{-1}
  </annotation>
 </semantics>
</math>

, we highlight that preconditioning is practically implemented as multiplying some vector 

<math display="inline" id="Preconditioner:52">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Preconditioner:53">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

, i.e., computing the product 

<math display="inline" id="Preconditioner:54">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mi>r</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Tr.
  </annotation>
 </semantics>
</math>

 In many applications, 

<math display="inline" id="Preconditioner:55">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is not given as a matrix, but rather as an operator 

<math display="inline" id="Preconditioner:56">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(r)
  </annotation>
 </semantics>
</math>

 acting on the vector 

<math display="inline" id="Preconditioner:57">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

. Some popular preconditioners, however, change with 

<math display="inline" id="Preconditioner:58">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 and the dependence on 

<math display="inline" id="Preconditioner:59">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 may not be linear. Typical examples involve using non-linear <a href="iterative_methods" title="wikilink">iterative methods</a>, e.g., the <a href="conjugate_gradient_method" title="wikilink">conjugate gradient method</a>, as a part of the preconditioner construction. Such preconditioners may be practically very efficient, however, their behavior is hard to predict theoretically.</p>
<h3 id="spectrally-equivalent-preconditioning">Spectrally equivalent preconditioning</h3>

<p>The most common use of preconditioning is for iterative solution of linear systems resulting from approximations of <a href="partial_differential_equations" title="wikilink">partial differential equations</a>. The better the approximation quality, the larger the matrix size is. In such a case, the goal of optimal preconditioning is, on the one side, to make the spectral condition number of 

<math display="inline" id="Preconditioner:60">
 <semantics>
  <mrow>
   <msup>
    <mi>P</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}A
  </annotation>
 </semantics>
</math>

 to be bounded from above by a constant independent of the matrix size, which is called <em>spectrally equivalent</em> preconditioning by <a href="Evgenii_Georgievich_D'yakonov" title="wikilink">D'yakonov</a>. On the other hand, the cost of application of the 

<math display="inline" id="Preconditioner:61">
 <semantics>
  <msup>
   <mi>P</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>P</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}
  </annotation>
 </semantics>
</math>

 should ideally be proportional (also independent of the matrix size) to the cost of multiplication of 

<math display="inline" id="Preconditioner:62">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 by a vector.</p>
<h3 id="examples">Examples</h3>
<h4 id="jacobi-or-diagonal-preconditioner">Jacobi (or diagonal) preconditioner</h4>

<p>The <strong>Jacobi preconditioner</strong> is one of the simplest forms of preconditioning, in which the preconditioner is chosen to be the diagonal of the matrix 

<math display="inline" id="Preconditioner:63">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mo>=</mo>
    <mrow>
     <mi>diag</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <times></times>
     <ci>diag</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=\mathrm{diag}(A).
  </annotation>
 </semantics>
</math>

 Assuming 

<math display="inline" id="Preconditioner:64">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mrow>
     <mi>i</mi>
     <mi>i</mi>
    </mrow>
   </msub>
   <mo>≠</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mrow>
     <mo>∀</mo>
     <mi>i</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <list>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>i</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{ii}\neq 0,\forall i
  </annotation>
 </semantics>
</math>

, we get 

<math display="inline" id="Preconditioner:65">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>P</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
    <mo>=</mo>
    <mfrac>
     <msub>
      <mi>δ</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <msub>
      <mi>A</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}_{ij}=\frac{\delta_{ij}}{A_{ij}}.
  </annotation>
 </semantics>
</math>

 It is efficient for <a href="Diagonally_dominant_matrix" title="wikilink">diagonally dominant matrices</a> 

<math display="inline" id="Preconditioner:66">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="spai">SPAI</h4>

<p>The <strong>Sparse Approximate Inverse</strong> preconditioner minimises 

<math display="inline" id="Preconditioner:67">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mrow>
       <mi>A</mi>
       <mi>T</mi>
      </mrow>
      <mo>-</mo>
      <mi>I</mi>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mi>F</mi>
   </msub>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>T</ci>
      </apply>
      <ci>I</ci>
     </apply>
    </apply>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|AT-I\|_{F},
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Preconditioner:68">
 <semantics>
  <mrow>
   <mo>∥</mo>
   <mo>⋅</mo>
   <msub>
    <mo>∥</mo>
    <mi>F</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">parallel-to</csymbol>
    <ci>normal-⋅</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">parallel-to</csymbol>
     <ci>F</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\cdot\|_{F}
  </annotation>
 </semantics>
</math>

 is the Frobenius matrix norm and 

<math display="inline" id="Preconditioner:69">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <msup>
    <mi>P</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=P^{-1}
  </annotation>
 </semantics>
</math>

 is from some suitably constrained set of sparse matrices. Under the Frobenius norm, this reduces to solving numerous independent least-squares problems (one for every column). The entries in 

<math display="inline" id="Preconditioner:70">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 must be restricted to some sparsity pattern or the problem becomes as hard and time consuming as finding the exact inverse of 

<math display="inline" id="Preconditioner:71">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. This method, as well as means to select sparsity patterns, were introduced by [M.J. Grote, T. Huckle, SIAM J. Sci. Comput . 18 (1997) 838–853].</p>
<h4 id="other-preconditioners">Other preconditioners</h4>
<ul>
<li><a href="Incomplete_Cholesky_factorization" title="wikilink">Incomplete Cholesky factorization</a></li>
<li><a href="Incomplete_LU_factorization" title="wikilink">Incomplete LU factorization</a></li>
<li><a href="Successive_over-relaxation" title="wikilink">Successive over-relaxation</a>
<ul>
<li><a href="Symmetric_successive_over-relaxation" title="wikilink">Symmetric successive over-relaxation</a></li>
</ul></li>
<li><a class="uri" href="Multigrid#Multigrid_preconditioning" title="wikilink">Multigrid#Multigrid_preconditioning</a></li>
</ul>
<h3 id="external-links">External links</h3>
<ul>
<li><a href="http://www.math-linux.com/spip.php?article55">Preconditioned Conjugate Gradient</a> – math-linux.com</li>
<li><a href="http://www.netlib.org/linalg/html_templates/Templates.html">Templates for the Solution of Linear Systems: Building Blocks for Iterative Methods</a></li>
</ul>
<h2 id="preconditioning-for-eigenvalue-problems">Preconditioning for eigenvalue problems</h2>

<p>Eigenvalue problems can be framed in several alternative ways, each leading to its own preconditioning. The traditional preconditioning is based on the so-called <em>spectral transformations.</em> Knowing (approximately) the targeted eigenvalue, one can compute the corresponding eigenvector by solving the related homogeneous linear system, thus allowing to use preconditioning for linear system. Finally, formulating the eigenvalue problem as optimization of the <a href="Rayleigh_quotient" title="wikilink">Rayleigh quotient</a> brings preconditioned optimization techniques to the scene.</p>
<h3 id="spectral-transformations">Spectral transformations</h3>

<p>By analogy with linear systems, for an <a class="uri" href="eigenvalue" title="wikilink">eigenvalue</a> problem 

<math display="inline" id="Preconditioner:72">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ax=\lambda x
  </annotation>
 </semantics>
</math>

 one may be tempted to replace the matrix 

<math display="inline" id="Preconditioner:73">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 with the matrix 

<math display="inline" id="Preconditioner:74">
 <semantics>
  <mrow>
   <msup>
    <mi>P</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}A
  </annotation>
 </semantics>
</math>

 using a preconditioner 

<math display="inline" id="Preconditioner:75">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

. However, this makes sense only if the seeking <a class="uri" href="eigenvectors" title="wikilink">eigenvectors</a> of 

<math display="inline" id="Preconditioner:76">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Preconditioner:77">
 <semantics>
  <mrow>
   <msup>
    <mi>P</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}A
  </annotation>
 </semantics>
</math>

 are the same. This is the case for spectral transformations.</p>

<p>The most popular spectral transformation is the so-called <em>shift-and-invert</em> transformation, where for a given scalar 

<math display="inline" id="Preconditioner:78">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

, called the <em>shift</em>, the original eigenvalue problem 

<math display="inline" id="Preconditioner:79">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ax=\lambda x
  </annotation>
 </semantics>
</math>

 is replaced with the shift-and-invert problem 

<math display="inline" id="Preconditioner:80">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mo>-</mo>
       <mrow>
        <mi>α</mi>
        <mi>I</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>μ</mi>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <ci>A</ci>
       <apply>
        <times></times>
        <ci>α</ci>
        <ci>I</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>μ</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A-\alpha I)^{-1}x=\mu x
  </annotation>
 </semantics>
</math>

. The eigenvectors are preserved, and one can solve the shift-and-invert problem by an iterative solver, e.g., the <a href="power_iteration" title="wikilink">power iteration</a>. This gives the <a href="Inverse_iteration" title="wikilink">Inverse iteration</a>, which normally converges to the eigenvector, corresponding to the eigenvalue closest to the shift 

<math display="inline" id="Preconditioner:81">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

. The <a href="Rayleigh_quotient_iteration" title="wikilink">Rayleigh quotient iteration</a> is a shift-and-invert method with a variable shift.</p>

<p>Spectral transformations are specific for eigenvalue problems and have no analogs for linear systems. They require accurate numerical calculation of the transformation involved, which becomes the main bottleneck for large problems.</p>
<h3 id="general-preconditioning">General preconditioning</h3>

<p>To make a close connection to linear systems, let us suppose that the targeted eigenvalue 

<math display="inline" id="Preconditioner:82">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mo>⋆</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <ci>normal-⋆</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{\star}
  </annotation>
 </semantics>
</math>

 is known (approximately). Then one can compute the corresponding eigenvector from the homogeneous linear system 

<math display="inline" id="Preconditioner:83">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mo>⋆</mo>
       </msub>
       <mi>I</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>A</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>normal-⋆</ci>
       </apply>
       <ci>I</ci>
      </apply>
     </apply>
     <ci>x</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A-\lambda_{\star}I)x=0
  </annotation>
 </semantics>
</math>

. Using the concept of left preconditioning for linear systems, we obtain 

<math display="inline" id="Preconditioner:84">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mo>⋆</mo>
       </msub>
       <mi>I</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <apply>
      <minus></minus>
      <ci>A</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>normal-⋆</ci>
       </apply>
       <ci>I</ci>
      </apply>
     </apply>
     <ci>x</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(A-\lambda_{\star}I)x=0
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Preconditioner:85">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is the preconditioner, which we can try to solve using the <a href="Richardson_iteration" title="wikilink">Richardson iteration</a></p>

<p>

<math display="block" id="Preconditioner:86">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐱</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>𝐱</mi>
    <mi>n</mi>
   </msub>
   <mo>-</mo>
   <msub>
    <mi>γ</mi>
    <mi>n</mi>
   </msub>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>-</mo>
    <msub>
     <mi>λ</mi>
     <mo>⋆</mo>
    </msub>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
   <mi>𝐱</mi>
   <msub>
    <mi></mi>
    <mi>n</mi>
   </msub>
   <mo rspace="7.5pt">,</mo>
   <mi>n</mi>
   <mo>≥</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐱</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐱</ci>
     <ci>n</ci>
    </apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>γ</ci>
     <ci>n</ci>
    </apply>
    <csymbol cd="unknown">T</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <ci>normal-⋆</ci>
     </apply>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
    <csymbol cd="unknown">x</csymbol>
    <apply>
     <ci>n</ci>
    </apply>
    <ci>normal-,</ci>
    <csymbol cd="unknown">n</csymbol>
    <geq></geq>
    <cn type="float">0.</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{n+1}=\mathbf{x}_{n}-\gamma_{n}T(A-\lambda_{\star}I))\mathbf{x}_{n}%
,\ n\geq 0.
  </annotation>
 </semantics>
</math>

</p>
<h4 id="the-ideal-preconditioning">The <em>ideal</em> preconditioning</h4>

<p>The <a href="Moore–Penrose_pseudoinverse" title="wikilink">Moore–Penrose pseudoinverse</a> 

<math display="inline" id="Preconditioner:87">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mo>⋆</mo>
       </msub>
       <mi>I</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <ci>A</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>normal-⋆</ci>
       </apply>
       <ci>I</ci>
      </apply>
     </apply>
     <plus></plus>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=(A-\lambda_{\star}I)^{+}
  </annotation>
 </semantics>
</math>

 is the preconditioner, which makes the <a href="Richardson_iteration" title="wikilink">Richardson iteration</a> above converge in one step with 

<math display="inline" id="Preconditioner:88">
 <semantics>
  <mrow>
   <msub>
    <mi>γ</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>γ</ci>
     <ci>n</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma_{n}=1
  </annotation>
 </semantics>
</math>

, since 

<math display="inline" id="Preconditioner:89">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mo>-</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mo>-</mo>
       <mrow>
        <msub>
         <mi>λ</mi>
         <mo>⋆</mo>
        </msub>
        <mi>I</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mo>⋆</mo>
       </msub>
       <mi>I</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>I</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <ci>A</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <ci>normal-⋆</ci>
        </apply>
        <ci>I</ci>
       </apply>
      </apply>
      <plus></plus>
     </apply>
     <apply>
      <minus></minus>
      <ci>A</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>normal-⋆</ci>
       </apply>
       <ci>I</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I-(A-\lambda_{\star}I)^{+}(A-\lambda_{\star}I)
  </annotation>
 </semantics>
</math>

, denoted by 

<math display="inline" id="Preconditioner:90">
 <semantics>
  <msub>
   <mi>P</mi>
   <mo>⋆</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>normal-⋆</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{\star}
  </annotation>
 </semantics>
</math>

, is the orthogonal projector on the eigenspace, corresponding to 

<math display="inline" id="Preconditioner:91">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mo>⋆</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <ci>normal-⋆</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{\star}
  </annotation>
 </semantics>
</math>

. The choice 

<math display="inline" id="Preconditioner:92">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mo>⋆</mo>
       </msub>
       <mi>I</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <ci>A</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>normal-⋆</ci>
       </apply>
       <ci>I</ci>
      </apply>
     </apply>
     <plus></plus>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=(A-\lambda_{\star}I)^{+}
  </annotation>
 </semantics>
</math>

 is impractical for three independent reasons. First, 

<math display="inline" id="Preconditioner:93">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mo>⋆</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <ci>normal-⋆</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{\star}
  </annotation>
 </semantics>
</math>

 is actually not known, although it can be replaced with its approximation 

<math display="inline" id="Preconditioner:94">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>λ</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>⋆</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-~</ci>
     <ci>λ</ci>
    </apply>
    <ci>normal-⋆</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{\lambda}_{\star}
  </annotation>
 </semantics>
</math>

. Second, the exact <a href="Moore–Penrose_pseudoinverse" title="wikilink">Moore–Penrose pseudoinverse</a> requires the knowledge of the eigenvector, which we are trying to find. This can be somewhat circumvented by the use of the <a href="Jacobi–Davidson_preconditioner" title="wikilink">Jacobi–Davidson preconditioner</a> 

<math display="inline" id="Preconditioner:95">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>I</mi>
      <mo>-</mo>
      <msub>
       <mover accent="true">
        <mi>P</mi>
        <mo stretchy="false">~</mo>
       </mover>
       <mo>⋆</mo>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mo>-</mo>
       <mrow>
        <msub>
         <mover accent="true">
          <mi>λ</mi>
          <mo stretchy="false">~</mo>
         </mover>
         <mo>⋆</mo>
        </msub>
        <mi>I</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>I</mi>
      <mo>-</mo>
      <msub>
       <mover accent="true">
        <mi>P</mi>
        <mo stretchy="false">~</mo>
       </mover>
       <mo>⋆</mo>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>I</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>P</ci>
       </apply>
       <ci>normal-⋆</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <ci>A</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-~</ci>
          <ci>λ</ci>
         </apply>
         <ci>normal-⋆</ci>
        </apply>
        <ci>I</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>I</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>P</ci>
       </apply>
       <ci>normal-⋆</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=(I-\tilde{P}_{\star})(A-\tilde{\lambda}_{\star}I)^{-1}(I-\tilde{P}_{\star})
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Preconditioner:96">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>P</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>⋆</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-~</ci>
     <ci>P</ci>
    </apply>
    <ci>normal-⋆</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{P}_{\star}
  </annotation>
 </semantics>
</math>

 approximates 

<math display="inline" id="Preconditioner:97">
 <semantics>
  <msub>
   <mi>P</mi>
   <mo>⋆</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>normal-⋆</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{\star}
  </annotation>
 </semantics>
</math>

. Last, but not least, this approach requires accurate numerical solution of linear system with the system matrix 

<math display="inline" id="Preconditioner:98">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>A</mi>
    <mo>-</mo>
    <mrow>
     <msub>
      <mover accent="true">
       <mi>λ</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mo>⋆</mo>
     </msub>
     <mi>I</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>A</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-~</ci>
       <ci>λ</ci>
      </apply>
      <ci>normal-⋆</ci>
     </apply>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A-\tilde{\lambda}_{\star}I)
  </annotation>
 </semantics>
</math>

, which becomes as expensive for large problems as the shift-and-invert method above. If the solution is not accurate enough, step two may be redundant.</p>
<h4 id="practical-preconditioning">Practical preconditioning</h4>

<p>Let us first replace the theoretical value 

<math display="inline" id="Preconditioner:99">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mo>⋆</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <ci>normal-⋆</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{\star}
  </annotation>
 </semantics>
</math>

 in the <a href="Richardson_iteration" title="wikilink">Richardson iteration</a> above with its current approximation 

<math display="inline" id="Preconditioner:100">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{n}
  </annotation>
 </semantics>
</math>

 to obtain a practical algorithm</p>

<p>

<math display="block" id="Preconditioner:101">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐱</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>𝐱</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>γ</mi>
       <mi>n</mi>
      </msub>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mo>-</mo>
        <mrow>
         <msub>
          <mi>λ</mi>
          <mi>n</mi>
         </msub>
         <mi>I</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>𝐱</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">,</mo>
   <mrow>
    <mi>n</mi>
    <mo>≥</mo>
    <mn>0.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>n</ci>
       </apply>
       <ci>T</ci>
       <apply>
        <minus></minus>
        <ci>A</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>λ</ci>
          <ci>n</ci>
         </apply>
         <ci>I</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐱</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <ci>n</ci>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{n+1}=\mathbf{x}_{n}-\gamma_{n}T(A-\lambda_{n}I)\mathbf{x}_{n},\ n%
\geq 0.
  </annotation>
 </semantics>
</math>

</p>

<p>A popular choice is 

<math display="inline" id="Preconditioner:102">
 <semantics>
  <mrow>
   <msub>
    <mi>λ</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>ρ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>ρ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{n}=\rho(x_{n})
  </annotation>
 </semantics>
</math>

 using the <a href="Rayleigh_quotient" title="wikilink">Rayleigh quotient</a> function 

<math display="inline" id="Preconditioner:103">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>⋅</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ρ</ci>
    <ci>normal-⋅</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(\cdot)
  </annotation>
 </semantics>
</math>

. Practical preconditioning may be as trivial as just using 

<math display="inline" id="Preconditioner:104">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>d</mi>
      <mi>i</mi>
      <mi>a</mi>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>i</ci>
      <ci>a</ci>
      <ci>g</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=(diag(A))^{-1}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Preconditioner:105">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>d</mi>
       <mi>i</mi>
       <mi>a</mi>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>A</mi>
         <mo>-</mo>
         <mrow>
          <msub>
           <mi>λ</mi>
           <mi>n</mi>
          </msub>
          <mi>I</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>i</ci>
      <ci>a</ci>
      <ci>g</ci>
      <apply>
       <minus></minus>
       <ci>A</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <ci>n</ci>
        </apply>
        <ci>I</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=(diag(A-\lambda_{n}I))^{-1}.
  </annotation>
 </semantics>
</math>

 For some classes of eigenvalue problems the efficiency of 

<math display="inline" id="Preconditioner:106">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>≈</mo>
   <msup>
    <mi>A</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\approx A^{-1}
  </annotation>
 </semantics>
</math>

 has been demonstrated, both numerically and theoretically. The choice 

<math display="inline" id="Preconditioner:107">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>≈</mo>
   <msup>
    <mi>A</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\approx A^{-1}
  </annotation>
 </semantics>
</math>

 allows one to easily utilize for eigenvalue problems the vast variety of preconditioners developed for linear systems.</p>

<p>Due to the changing value 

<math display="inline" id="Preconditioner:108">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{n}
  </annotation>
 </semantics>
</math>

, a comprehensive theoretical convergence analysis is much more difficult, compared to the linear systems case, even for the simplest methods, such as the <a href="Richardson_iteration" title="wikilink">Richardson iteration</a>.</p>
<h3 id="external-links-1">External links</h3>
<ul>
<li><a href="http://www.cs.ucdavis.edu/~bai/ET/contents.html">Templates for the Solution of Algebraic Eigenvalue Problems: a Practical Guide</a></li>
</ul>
<h2 id="preconditioning-in-optimization">Preconditioning in optimization</h2>

<p> In <a href="optimization_(mathematics)" title="wikilink">optimization</a>, preconditioning is typically used to accelerate <a href="First-order_approximation" title="wikilink">first-order</a> <a href="optimization_(mathematics)" title="wikilink">optimization</a> <a class="uri" href="algorithms" title="wikilink">algorithms</a>.</p>
<h3 id="description-1">Description</h3>

<p>For example, to find a <a href="local_minimum" title="wikilink">local minimum</a> of a real-valued function 

<math display="inline" id="Preconditioner:109">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\mathbf{x})
  </annotation>
 </semantics>
</math>

 using <a href="gradient_descent" title="wikilink">gradient descent</a>, one takes steps proportional to the <em>negative</em> of the <a class="uri" href="gradient" title="wikilink">gradient</a> 

<math display="inline" id="Preconditioner:110">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mrow>
    <mrow>
     <mo>∇</mo>
     <mi>F</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐚</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <apply>
      <ci>normal-∇</ci>
      <ci>F</ci>
     </apply>
     <ci>𝐚</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\nabla F(\mathbf{a})
  </annotation>
 </semantics>
</math>

 (or of the approximate gradient) of the function at the current point:</p>

<p>

<math display="block" id="Preconditioner:111">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐱</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>𝐱</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>γ</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo>∇</mo>
       <mi>F</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>𝐱</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">,</mo>
   <mrow>
    <mi>n</mi>
    <mo>≥</mo>
    <mn>0.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <ci>normal-∇</ci>
        <ci>F</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐱</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <ci>n</ci>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{n+1}=\mathbf{x}_{n}-\gamma_{n}\nabla F(\mathbf{x}_{n}),\ n\geq 0.
  </annotation>
 </semantics>
</math>

</p>

<p>The preconditioner is applied to the gradient:</p>

<p>

<math display="block" id="Preconditioner:112">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐱</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>𝐱</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>γ</mi>
       <mi>n</mi>
      </msub>
      <msup>
       <mi>P</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mrow>
       <mo>∇</mo>
       <mi>F</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>𝐱</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">,</mo>
   <mrow>
    <mi>n</mi>
    <mo>≥</mo>
    <mn>0.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>P</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <ci>normal-∇</ci>
        <ci>F</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐱</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <ci>n</ci>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{n+1}=\mathbf{x}_{n}-\gamma_{n}P^{-1}\nabla F(\mathbf{x}_{n}),\ n%
\geq 0.
  </annotation>
 </semantics>
</math>

</p>

<p>Preconditioning here can be viewed as changing the geometry of the vector space with the goal to make the level sets look like circles. In this case the preconditioned gradient aims closer to the point of the extrema as on the figure, which speeds up the convergence.</p>
<h3 id="connection-to-linear-systems">Connection to linear systems</h3>

<p>The minimum of a quadratic function</p>

<p>

<math display="block" id="Preconditioner:113">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <msup>
      <mi>𝐱</mi>
      <mi>T</mi>
     </msup>
     <mi>A</mi>
     <mi>𝐱</mi>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msup>
      <mi>𝐱</mi>
      <mi>T</mi>
     </msup>
     <mi>𝐛</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>𝐱</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐱</ci>
       <ci>T</ci>
      </apply>
      <ci>A</ci>
      <ci>𝐱</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐱</ci>
       <ci>T</ci>
      </apply>
      <ci>𝐛</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\mathbf{x})=\frac{1}{2}\mathbf{x}^{T}A\mathbf{x}-\mathbf{x}^{T}\mathbf{b}
  </annotation>
 </semantics>
</math>

,</p>

<p>where 

<math display="inline" id="Preconditioner:114">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Preconditioner:115">
 <semantics>
  <mi>𝐛</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐛</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{b}
  </annotation>
 </semantics>
</math>

 are real column-vectors and 

<math display="inline" id="Preconditioner:116">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is a real <a href="Symmetric_matrix" title="wikilink">symmetric</a> <a href="positive-definite_matrix" title="wikilink">positive-definite matrix</a>, is exactly the solution of the linear equation 

<math display="inline" id="Preconditioner:117">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>𝐱</mi>
   </mrow>
   <mo>=</mo>
   <mi>𝐛</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>𝐱</ci>
    </apply>
    <ci>𝐛</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\mathbf{x}=\mathbf{b}
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Preconditioner:118">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∇</mo>
     <mi>F</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mi>𝐱</mi>
    </mrow>
    <mo>-</mo>
    <mi>𝐛</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-∇</ci>
      <ci>F</ci>
     </apply>
     <ci>𝐱</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>𝐱</ci>
     </apply>
     <ci>𝐛</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla F(\mathbf{x})=A\mathbf{x}-\mathbf{b}
  </annotation>
 </semantics>
</math>

, the preconditioned <a href="gradient_descent" title="wikilink">gradient descent</a> method of minimizing 

<math display="inline" id="Preconditioner:119">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\mathbf{x})
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="block" id="Preconditioner:120">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐱</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>𝐱</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>γ</mi>
       <mi>n</mi>
      </msub>
      <msup>
       <mi>P</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>A</mi>
         <msub>
          <mi>𝐱</mi>
          <mi>n</mi>
         </msub>
        </mrow>
        <mo>-</mo>
        <mi>𝐛</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">,</mo>
   <mrow>
    <mi>n</mi>
    <mo>≥</mo>
    <mn>0.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>P</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>A</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐱</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <ci>𝐛</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <ci>n</ci>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{n+1}=\mathbf{x}_{n}-\gamma_{n}P^{-1}(A\mathbf{x}_{n}-\mathbf{b}),%
\ n\geq 0.
  </annotation>
 </semantics>
</math>

</p>

<p>This is the preconditioned <a href="Richardson_iteration" title="wikilink">Richardson iteration</a> for solving a <a href="system_of_linear_equations" title="wikilink">system of linear equations</a>.</p>
<h3 id="connection-to-eigenvalue-problems">Connection to eigenvalue problems</h3>

<p>The minimum of the <a href="Rayleigh_quotient" title="wikilink">Rayleigh quotient</a></p>

<p>

<math display="block" id="Preconditioner:121">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ρ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝐱</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <msup>
       <mi>𝐱</mi>
       <mi>T</mi>
      </msup>
      <mi>A</mi>
      <mi>𝐱</mi>
     </mrow>
     <mrow>
      <msup>
       <mi>𝐱</mi>
       <mi>T</mi>
      </msup>
      <mi>𝐱</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ρ</ci>
     <ci>𝐱</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐱</ci>
       <ci>T</ci>
      </apply>
      <ci>A</ci>
      <ci>𝐱</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐱</ci>
       <ci>T</ci>
      </apply>
      <ci>𝐱</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(\mathbf{x})=\frac{\mathbf{x}^{T}A\mathbf{x}}{\mathbf{x}^{T}\mathbf{x}},
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Preconditioner:122">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 is a real non-zero column-vector and 

<math display="inline" id="Preconditioner:123">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is a real <a href="Symmetric_matrix" title="wikilink">symmetric</a> <a href="positive-definite_matrix" title="wikilink">positive-definite matrix</a>, is the smallest <a class="uri" href="eigenvalue" title="wikilink">eigenvalue</a> of 

<math display="inline" id="Preconditioner:124">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, while the minimizer is the corresponding <a class="uri" href="eigenvector" title="wikilink">eigenvector</a>. Since 

<math display="inline" id="Preconditioner:125">
 <semantics>
  <mrow>
   <mrow>
    <mo>∇</mo>
    <mi>ρ</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-∇</ci>
     <ci>ρ</ci>
    </apply>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla\rho(\mathbf{x})
  </annotation>
 </semantics>
</math>

 is proportional to 

<math display="inline" id="Preconditioner:126">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>𝐱</mi>
   </mrow>
   <mo>-</mo>
   <mrow>
    <mi>ρ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>𝐱</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>𝐱</ci>
    </apply>
    <apply>
     <times></times>
     <ci>ρ</ci>
     <ci>𝐱</ci>
     <ci>𝐱</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\mathbf{x}-\rho(\mathbf{x})\mathbf{x}
  </annotation>
 </semantics>
</math>

, the preconditioned <a href="gradient_descent" title="wikilink">gradient descent</a> method of minimizing 

<math display="inline" id="Preconditioner:127">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ρ</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(\mathbf{x})
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="block" id="Preconditioner:128">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐱</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>𝐱</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>γ</mi>
       <mi>n</mi>
      </msub>
      <msup>
       <mi>P</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>A</mi>
         <msub>
          <mi>𝐱</mi>
          <mi>n</mi>
         </msub>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>ρ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>𝐱</mi>
           <mi>𝐧</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
         <msub>
          <mi>𝐱</mi>
          <mi>𝐧</mi>
         </msub>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">,</mo>
   <mrow>
    <mi>n</mi>
    <mo>≥</mo>
    <mn>0.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>P</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>A</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐱</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>ρ</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐱</ci>
          <ci>𝐧</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐱</ci>
          <ci>𝐧</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <ci>n</ci>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{n+1}=\mathbf{x}_{n}-\gamma_{n}P^{-1}(A\mathbf{x}_{n}-\rho(\mathbf{%
x_{n}})\mathbf{x_{n}}),\ n\geq 0.
  </annotation>
 </semantics>
</math>

</p>

<p>This is an analog of preconditioned <a href="Richardson_iteration" title="wikilink">Richardson iteration</a> for solving eigenvalue problems.</p>
<h3 id="variable-preconditioning">Variable preconditioning</h3>

<p>In many cases, it may be beneficial to change the preconditioner at some or even every step of an <a href="iterative_algorithm" title="wikilink">iterative algorithm</a> in order to accommodate for a changing shape of the level sets, as in</p>

<p>

<math display="block" id="Preconditioner:129">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐱</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>𝐱</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>γ</mi>
       <mi>n</mi>
      </msub>
      <msubsup>
       <mi>P</mi>
       <mi>n</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
      <mrow>
       <mo>∇</mo>
       <mi>F</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>𝐱</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">,</mo>
   <mrow>
    <mi>n</mi>
    <mo>≥</mo>
    <mn>0.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <ci>normal-∇</ci>
        <ci>F</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐱</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <ci>n</ci>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{n+1}=\mathbf{x}_{n}-\gamma_{n}P_{n}^{-1}\nabla F(\mathbf{x}_{n}),%
\ n\geq 0.
  </annotation>
 </semantics>
</math>

</p>

<p>One should have in mind, however, that constructing an efficient preconditioner is very often computationally expensive. The increased cost of updating the preconditioner can easily override the positive effect of faster convergence.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_linear_algebra" title="wikilink">Category:Numerical linear algebra</a></p>
</body>
</html>
