<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="608">Bounded quantifier</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Bounded quantifier</h1>
<hr/>

<p>In the study of formal theories in <a href="mathematical_logic" title="wikilink">mathematical logic</a>, <strong>bounded quantifiers</strong> are often added to a language in addition to the standard quantifiers "∀" and "∃". Bounded quantifiers differ from "∀" and "∃" in that bounded quantifiers restrict the range of the quantified variable. The study of bounded quantifiers is motivated by the fact that determining whether a <a href="Sentence_(mathematical_logic)" title="wikilink">sentence</a> with only bounded quantifiers is true is often not as difficult as determining whether an arbitrary sentence is true.</p>

<p>Examples of bounded quantifiers in the context of real analysis include "∀<em>x</em>&gt;0", "∃<em>y</em>0" says "for all <em>x</em> where <em>x</em> is larger than 0", "∃<em>y</em> says "every positive number is the square of a negative number".</p>
<h2 id="bounded-quantifiers-in-arithmetic">Bounded quantifiers in arithmetic</h2>

<p>Suppose that <em>L</em> is the language of <a href="Peano_arithmetic" title="wikilink">Peano arithmetic</a> (the language of <a href="second-order_arithmetic" title="wikilink">second-order arithmetic</a> or arithmetic in all finite types would work as well). There are two types of bounded quantifiers

<math display="block" id="Bounded_quantifier:0">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>n</mi>
   </mrow>
   <mo><</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>n</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall n<t
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bounded_quantifier:1">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mi>n</mi>
   </mrow>
   <mo><</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <exists></exists>
     <ci>n</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists n<t
  </annotation>
 </semantics>
</math>

. These quantifiers bind the number variable <em>n</em> and contain a numeric term <em>t</em> which may not mention <em>n</em> but which may have other free variables. (By "numeric terms" here we mean terms such as "1 + 1", "2", "2 × 3", "<em>m</em> + 3", etc.)</p>

<p>These quantifiers are defined by the following rules (

<math display="inline" id="Bounded_quantifier:2">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 denotes formulas):</p>

<p>

<math display="block" id="Bounded_quantifier:3">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mi>n</mi>
   <mo><</mo>
   <mpadded width="+1.7pt">
    <mi>t</mi>
   </mpadded>
   <mi>ϕ</mi>
   <mo>⇔</mo>
   <mo>∃</mo>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo><</mo>
    <mi>t</mi>
    <mo>∧</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <exists></exists>
    <csymbol cd="unknown">n</csymbol>
    <lt></lt>
    <csymbol cd="unknown">t</csymbol>
    <csymbol cd="unknown">ϕ</csymbol>
    <ci>normal-⇔</ci>
    <exists></exists>
    <csymbol cd="unknown">n</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <lt></lt>
     <csymbol cd="unknown">t</csymbol>
     <and></and>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists n<t\,\phi\Leftrightarrow\exists n(n<t\land\phi)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Bounded_quantifier:4">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>n</mi>
   <mo><</mo>
   <mpadded width="+1.7pt">
    <mi>t</mi>
   </mpadded>
   <mi>ϕ</mi>
   <mo>⇔</mo>
   <mo>∀</mo>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo><</mo>
    <mi>t</mi>
    <mo>→</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <lt></lt>
    <csymbol cd="unknown">t</csymbol>
    <csymbol cd="unknown">ϕ</csymbol>
    <ci>normal-⇔</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <lt></lt>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall n<t\,\phi\Leftrightarrow\forall n(n<t\rightarrow\phi)
  </annotation>
 </semantics>
</math>

</p>

<p>There are several motivations for these quantifiers.</p>
<ul>
<li>In applications of the language to <a href="recursion_theory" title="wikilink">recursion theory</a>, such as the <a href="arithmetical_hierarchy" title="wikilink">arithmetical hierarchy</a>, bounded quantifiers add no complexity. If 

<math display="inline" id="Bounded_quantifier:5">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 is a decidable predicate then 

<math display="inline" id="Bounded_quantifier:6">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mi>n</mi>
   </mrow>
   <mo><</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>t</mi>
    </mpadded>
    <mi>ϕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <exists></exists>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>ϕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists n<t\,\phi
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bounded_quantifier:7">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>n</mi>
   </mrow>
   <mo><</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>t</mi>
    </mpadded>
    <mi>ϕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>ϕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall n<t\,\phi
  </annotation>
 </semantics>
</math>

 are decidable as well.</li>
<li>In applications to the study of <a href="Peano_Arithmetic" title="wikilink">Peano Arithmetic</a>, formulas are sometimes provable with bounded quantifiers but unprovable with unbounded quantifiers.</li>
</ul>

<p>For example, there is a definition of primality using only bounded quantifiers. A number <em>n</em> is prime if and only if there are not two numbers strictly less than <em>n</em> whose product is <em>n</em>. There is no quantifier-free definition of primality in the language 

<math display="inline" id="Bounded_quantifier:8">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mo>+</mo>
   <mo>,</mo>
   <mo>×</mo>
   <mo>,</mo>
   <mo><</mo>
   <mo>,</mo>
   <mo>=</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
    <plus></plus>
    <times></times>
    <lt></lt>
    <eq></eq>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle 0,1,+,\times,<,=\rangle
  </annotation>
 </semantics>
</math>

, however. The fact that there is a bounded quantifier formula defining primality shows that the primality of each number can be computably decided.</p>

<p>In general, a relation on natural numbers is definable by a bounded formula if and only if it is computable in the linear-time hierarchy, which is defined similarly to the <a href="polynomial_hierarchy" title="wikilink">polynomial hierarchy</a>, but with linear time bounds instead of polynomial. Consequently, all predicates definable by a bounded formula are <a href="ELEMENTARY" title="wikilink">Kalmár elementary</a>, <a href="context-sensitive_grammar" title="wikilink">context-sensitive</a>, and <a href="primitive_recursive" title="wikilink">primitive recursive</a>.</p>

<p>In the <a href="arithmetical_hierarchy" title="wikilink">arithmetical hierarchy</a>, an arithmetical formula which contains only bounded quantifiers is called 

<math display="inline" id="Bounded_quantifier:9">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mn>0</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{0}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Bounded_quantifier:10">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Δ</mi>
   <mn>0</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Δ</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{0}_{0}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Bounded_quantifier:11">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Π</mi>
   <mn>0</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Π</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi^{0}_{0}
  </annotation>
 </semantics>
</math>

. The superscript 0 is sometimes omitted.</p>
<h2 id="bounded-quantifiers-in-set-theory">Bounded quantifiers in set theory</h2>

<p>Suppose that <em>L</em> is the language 

<math display="inline" id="Bounded_quantifier:12">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mo>∈</mo>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mo>=</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <in></in>
    <ci>normal-…</ci>
    <eq></eq>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\in,\ldots,=\rangle
  </annotation>
 </semantics>
</math>

 of the <a href="Zermelo–Fraenkel_set_theory" title="wikilink">Zermelo–Fraenkel set theory</a>, where the ellipsis may be replaced by term-forming operations such as a symbol for the powerset operation. There are two bounded quantifiers

<math display="block" id="Bounded_quantifier:13">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>x</mi>
   </mrow>
   <mo>∈</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>x</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\in t
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bounded_quantifier:14">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mi>x</mi>
   </mrow>
   <mo>∈</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <exists></exists>
     <ci>x</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x\in t
  </annotation>
 </semantics>
</math>

. These quantifiers bind the set variable <em>x</em> and contain a term <em>t</em> which may not mention <em>x</em> but which may have other free variables.</p>

<p>The semantics of these quantifiers is determined by the following rules:</p>

<p>

<math display="block" id="Bounded_quantifier:15">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mi>x</mi>
   <mo>∈</mo>
   <mpadded width="+5pt">
    <mi>t</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⇔</mo>
   <mo>∃</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>t</mi>
    <mo>∧</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <exists></exists>
    <csymbol cd="unknown">x</csymbol>
    <in></in>
    <csymbol cd="unknown">t</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⇔</ci>
    <exists></exists>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">t</csymbol>
     <and></and>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x\in t\ (\phi)\Leftrightarrow\exists x(x\in t\land\phi)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Bounded_quantifier:16">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mo>∈</mo>
   <mpadded width="+5pt">
    <mi>t</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⇔</mo>
   <mo>∀</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>t</mi>
    <mo>→</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <in></in>
    <csymbol cd="unknown">t</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⇔</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\in t\ (\phi)\Leftrightarrow\forall x(x\in t\rightarrow\phi)
  </annotation>
 </semantics>
</math>

</p>

<p>A ZF formula which contains only bounded quantifiers is called 

<math display="inline" id="Bounded_quantifier:17">
 <semantics>
  <msub>
   <mi mathvariant="normal">Σ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Σ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{0}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Bounded_quantifier:18">
 <semantics>
  <msub>
   <mi mathvariant="normal">Δ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Δ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta_{0}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Bounded_quantifier:19">
 <semantics>
  <msub>
   <mi mathvariant="normal">Π</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Π</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{0}
  </annotation>
 </semantics>
</math>

. This forms the basis of the <a href="Levy_hierarchy" title="wikilink">Levy hierarchy</a>, which is defined analogously with the arithmetical hierarchy.</p>

<p>Bounded quantifiers are important in <a href="Kripke-Platek_set_theory" title="wikilink">Kripke-Platek set theory</a> and <a href="constructive_set_theory" title="wikilink">constructive set theory</a>, where only <a href="axiom_schema_of_predicative_separation" title="wikilink">Δ<sub>0</sub> separation</a> is included. That is, it includes separation for formulas with only bounded quantifiers, but not separation for other formulas. In KP the motivation is the fact that whether a set <em>x</em> satisfies a bounded quantifier formula only depends on the collection of sets that are close in rank to <em>x</em> (as the powerset operation can only be applied finitely many times to form a term). In constructive set theory, it is motivated on <a href="impredicativity" title="wikilink">predicative</a> grounds.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Subtyping" title="wikilink">Subtyping</a> — bounded quantification in <a href="type_theory" title="wikilink">type theory</a></li>
<li><a href="System_F-sub" title="wikilink">System F<sub>&lt;:&gt;<!--:--></sub></a> — a <a href="System_F" title="wikilink">polymorphic</a> <a href="typed_lambda_calculus" title="wikilink">typed lambda calculus</a> with bounded quantification</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Quantification" title="wikilink">Category:Quantification</a> <a href="Category:Proof_theory" title="wikilink">Category:Proof theory</a> <a href="Category:Computability_theory" title="wikilink">Category:Computability theory</a></p>
</body>
</html>
