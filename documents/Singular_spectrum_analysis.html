<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1946">Singular spectrum analysis</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Singular spectrum analysis</h1>
<hr/>

<p>In <a href="time_series_analysis" title="wikilink">time series analysis</a>, <strong>singular spectrum analysis</strong> (SSA) is a <a href="nonparametric_statistics" title="wikilink">nonparametric</a> spectral estimation method. It combines elements of classical <a href="time_series" title="wikilink">time series</a> analysis, <a href="multivariate_statistics" title="wikilink">multivariate statistics</a>, multivariate geometry, <a href="dynamical_systems" title="wikilink">dynamical systems</a> and <a href="signal_processing" title="wikilink">signal processing</a>. Its roots lie in the classical Karhunen (1946)‚ÄìLo√®ve (1945, 1978) <a href="spectral_decomposition" title="wikilink">spectral decomposition</a> of <a href="time_series" title="wikilink">time series</a> and <a href="random_fields" title="wikilink">random fields</a> and in the Ma√±√© (1981)‚ÄìTakens (1981) <a href="Takens'_theorem" title="wikilink">embedding theorem</a>. SSA can be an aid in the <a href="decomposition_of_time_series" title="wikilink">decomposition of time series</a> into a sum of components, each having a meaningful interpretation. The name "singular spectrum analysis" relates to the spectrum of <a href="eigenvalue" title="wikilink">eigenvalues</a> in a <a href="singular_value_decomposition" title="wikilink">singular value decomposition</a> of a <a href="covariance_matrix" title="wikilink">covariance matrix</a>, and not directly to a <a href="frequency_domain_decomposition" title="wikilink">frequency domain decomposition</a>.</p>
<h2 id="brief-history">Brief history</h2>

<p>The origins of SSA and, more generally, of subspace-based methods for signal processing, go back to the eighteenth century (<a href="Prony's_method" title="wikilink">Prony's method</a>). A key development was the formulation of the <a href="spectral_decomposition" title="wikilink">spectral decomposition</a> of the covariance operator of stochastic processes by <a href="Kari_Karhunen" title="wikilink">Kari Karhunen</a> and <a href="Michel_Lo√®ve" title="wikilink">Michel Lo√®ve</a> in the late 1940s (Lo√®ve, 1945; Karhunen, 1947).</p>

<p>Broomhead and King (1986a, b) and Fraedrich (1986) proposed to use SSA and multichannel SSA (M-SSA) in the context of nonlinear dynamics for the purpose of reconstructing the <a class="uri" href="attractor" title="wikilink">attractor</a> of a system from measured time series. These authors provided an extension and a more robust application of the idea of reconstructing dynamics from a single time series based on the <a href="Takens'_theorem" title="wikilink">embedding theorem</a>. Several other authors had already applied simple versions of M-SSA to meteorological and ecological data sets (Colebrook, 1978; Barnett and Hasselmann, 1979; Weare and Nasstrom, 1982).</p>

<p>Ghil, Vautard and their colleagues (Vautard and Ghil, 1989; Ghil and Vautard, 1991; Vautard et al., 1992; Ghil et al., 2002) noticed the analogy between the trajectory matrix of Broomhead and King, on the one hand, and the <a href="Karhunen‚ÄìLoeve_theorem" title="wikilink">Karhunen‚ÄìLoeve decomposition</a> (<a href="Principal_component_analysis" title="wikilink">Principal component analysis</a> in the time domain), on the other. Thus, SSA can be used as a time-and-frequency domain method for <a href="time_series" title="wikilink">time series</a> analysis ‚Äî independently from <a class="uri" href="attractor" title="wikilink">attractor</a> reconstruction and including cases in which the latter may fail. The survey paper of Ghil et al. (2002) is the basis of the <a href="#Singular_spectrum_analysis_(SSA)" title="wikilink">#Singular spectrum analysis (SSA)</a> section of this article. A crucial result of the work of these authors is that SSA can robustly recover the "skeleton" of an attractor, including in the presence of noise. This skeleton is formed by the least unstable periodic orbits, which can be identified in the eigenvalue spectra of SSA and M-SSA. The identification and detailed description of these orbits can provide highly useful pointers to the underlying nonlinear dynamics.</p>

<p>The so-called ‚ÄòCaterpillar‚Äô methodology is a version of SSA that was developed in the former Soviet Union, independently of the mainstream SSA work in the West. This methodology became known in the rest of the world more recently (Danilov and Zhigljavsky, Eds., 1997; Golyandina et al., 2001; Zhigljavsky, Ed., 2010; Golyandina and Zhigljavsky, 2013). ‚ÄòCaterpillar-SSA‚Äô emphasizes the concept of separability, a concept that leads, for example, to specific recommendations concerning the choice of SSA parameters. This method is thoroughly described in <a href="#SSA_as_a_model-free_tool" title="wikilink">#SSA as a model-free tool</a> section of this article.</p>
<h2 id="methodology">Methodology</h2>

<p>In practice, SSA is a nonparametric spectral estimation method based on embedding a <a href="time_series" title="wikilink">time series</a> 

<math display="inline" id="Singular_spectrum_analysis:0">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>X</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>t</mi>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo>,</mo>
     <mi>N</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <eq></eq>
     <ci>t</ci>
     <list>
      <cn type="integer">1</cn>
      <ci>normal-‚Ä¶</ci>
      <ci>N</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{X(t):t=1,\ldots,N\}
  </annotation>
 </semantics>
</math>

 in a vector space of dimension 

<math display="inline" id="Singular_spectrum_analysis:1">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

. SSA proceeds by diagonalizing the 

<math display="inline" id="Singular_spectrum_analysis:2">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>√ó</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\times M
  </annotation>
 </semantics>
</math>

 lag-covariance matrix 

<math display="inline" id="Singular_spectrum_analysis:3">
 <semantics>
  <msub>
   <mtext>ùêÇ</mtext>
   <mi>X</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>C</mtext>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\textbf{C}}_{X}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Singular_spectrum_analysis:4">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(t)
  </annotation>
 </semantics>
</math>

 to obtain <a href="spectral_decomposition_(Matrix)" title="wikilink">spectral information</a> on the time series, assumed to be <a href="Stationary_process" title="wikilink">stationary</a> in the weak sense. The matrix 

<math display="inline" id="Singular_spectrum_analysis:5">
 <semantics>
  <msub>
   <mtext>ùêÇ</mtext>
   <mi>X</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>C</mtext>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\textbf{C}}_{X}
  </annotation>
 </semantics>
</math>

 can be estimated directly from the data as a Toeplitz matrix with constant diagonals (Vautard and Ghil, 1989), i.e., its entries 

<math display="inline" id="Singular_spectrum_analysis:6">
 <semantics>
  <msub>
   <mi>c</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{ij}
  </annotation>
 </semantics>
</math>

 depend only on the lag 

<math display="inline" id="Singular_spectrum_analysis:7">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mi>i</mi>
    <mo>-</mo>
    <mi>j</mi>
   </mrow>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <minus></minus>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |i-j|
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Singular_spectrum_analysis:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <mi>i</mi>
         <mo>-</mo>
         <mi>j</mi>
        </mrow>
        <mo stretchy="false">|</mo>
       </mrow>
      </mrow>
     </mfrac>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
       <mrow>
        <mi>t</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mrow>
        <mi>N</mi>
        <mo>-</mo>
        <mrow>
         <mo stretchy="false">|</mo>
         <mrow>
          <mi>i</mi>
          <mo>-</mo>
          <mi>j</mi>
         </mrow>
         <mo stretchy="false">|</mo>
        </mrow>
       </mrow>
      </munderover>
      <mrow>
       <mi>X</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>X</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>t</mi>
         <mo>+</mo>
         <mrow>
          <mo stretchy="false">|</mo>
          <mrow>
           <mi>i</mi>
           <mo>-</mo>
           <mi>j</mi>
          </mrow>
          <mo stretchy="false">|</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <apply>
        <abs></abs>
        <apply>
         <minus></minus>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <apply>
         <abs></abs>
         <apply>
          <minus></minus>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>t</ci>
       <ci>X</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <apply>
         <abs></abs>
         <apply>
          <minus></minus>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{ij}=\frac{1}{N-|i-j|}\sum_{t=1}^{N-|i-j|}X(t)X(t+|i-j|).
  </annotation>
 </semantics>
</math>

</p>

<p>An alternative way to compute 

<math display="inline" id="Singular_spectrum_analysis:9">
 <semantics>
  <msub>
   <mtext>ùêÇ</mtext>
   <mi>X</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>C</mtext>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\textbf{C}}_{X}
  </annotation>
 </semantics>
</math>

, is by using the 

<math display="inline" id="Singular_spectrum_analysis:10">
 <semantics>
  <mrow>
   <msup>
    <mi>N</mi>
    <mo>‚Ä≤</mo>
   </msup>
   <mo>√ó</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>N</ci>
     <ci>normal-‚Ä≤</ci>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N^{\prime}\times M
  </annotation>
 </semantics>
</math>

 "trajectory matrix" 

<math display="inline" id="Singular_spectrum_analysis:12">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 that is formed by 

<math display="inline" id="Singular_spectrum_analysis:13">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\it X(t)}
  </annotation>
 </semantics>
</math>

 lag-shifted copies of 

<math display="inline" id="Singular_spectrum_analysis:14">
 <semantics>
  <mrow>
   <msup>
    <mi>N</mi>
    <mo>‚Ä≤</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mi>M</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>N</ci>
     <ci>normal-‚Ä≤</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <ci>M</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N^{\prime}=N-M+1
  </annotation>
 </semantics>
</math>

, which are 

<math display="block" id="Singular_spectrum_analysis:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mtext>ùêÇ</mtext>
     <mi>X</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <msup>
       <mi>N</mi>
       <mo>‚Ä≤</mo>
      </msup>
     </mfrac>
     <msup>
      <mtext>ùêÉ</mtext>
      <mi mathvariant="normal">t</mi>
     </msup>
     <mtext>ùêÉ</mtext>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext>C</mtext>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>N</ci>
       <ci>normal-‚Ä≤</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <mtext>D</mtext>
      <ci>normal-t</ci>
     </apply>
     <mtext>D</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\textbf{C}}_{X}=\frac{1}{N^{\prime}}{\textbf{D}}^{\rm t}{\textbf{D}}.
  </annotation>
 </semantics>
</math>

 long; then</p>

<p>

<math display="inline" id="Singular_spectrum_analysis:16">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

</p>

<p>The 

<math display="inline" id="Singular_spectrum_analysis:17">
 <semantics>
  <msub>
   <mtext>ùêÑ</mtext>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>E</mtext>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\textbf{E}}_{k}
  </annotation>
 </semantics>
</math>

 eigenvectors 

<math display="inline" id="Singular_spectrum_analysis:18">
 <semantics>
  <msub>
   <mtext>ùêÇ</mtext>
   <mi>X</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>C</mtext>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\textbf{C}}_{X}
  </annotation>
 </semantics>
</math>

 of the lag-covariance matrix 

<math display="inline" id="Singular_spectrum_analysis:19">
 <semantics>
  <msub>
   <mi>Œª</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Œª</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{k}
  </annotation>
 </semantics>
</math>

 are called temporal <a href="Empirical_orthogonal_functions" title="wikilink">empirical orthogonal functions (EOFs)</a>. The eigenvalues 

<math display="inline" id="Singular_spectrum_analysis:20">
 <semantics>
  <msub>
   <mtext>ùêÇ</mtext>
   <mi>X</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>C</mtext>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\textbf{C}}_{X}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Singular_spectrum_analysis:21">
 <semantics>
  <msub>
   <mtext>ùêÑ</mtext>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>E</mtext>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\textbf{E}}_{k}
  </annotation>
 </semantics>
</math>

 account for the partial variance in the direction 

<math display="inline" id="Singular_spectrum_analysis:22">
 <semantics>
  <msub>
   <mtext>ùêÇ</mtext>
   <mi>X</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>C</mtext>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\textbf{C}}_{X}
  </annotation>
 </semantics>
</math>

 and the sum of the eigenvalues, i.e., the trace of 

<math display="inline" id="Singular_spectrum_analysis:23">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(t)
  </annotation>
 </semantics>
</math>

, gives the total variance of the original time series 

<math display="inline" id="Singular_spectrum_analysis:24">
 <semantics>
  <msubsup>
   <mi>Œª</mi>
   <mi>k</mi>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Œª</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda^{1/2}_{k}
  </annotation>
 </semantics>
</math>

. The name of the method derives from the singular values 

<math display="inline" id="Singular_spectrum_analysis:25">
 <semantics>
  <mrow>
   <msub>
    <mtext>ùêÇ</mtext>
    <mi>X</mi>
   </msub>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>C</mtext>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\textbf{C}}_{X}.
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Singular_spectrum_analysis:26">
 <semantics>
  <msub>
   <mtext>ùêÄ</mtext>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>A</mtext>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\textbf{A}}_{k}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="decomposition-and-reconstruction">Decomposition and reconstruction</h3>

<p>Projecting the time series onto each EOF yields the corresponding temporal principal components (PCs) 

<math display="block" id="Singular_spectrum_analysis:27">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>A</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>M</mi>
     </munderover>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>t</mi>
         <mo>+</mo>
         <mi>j</mi>
        </mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>E</mi>
       <mi>k</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>j</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>k</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>M</ci>
     </apply>
     <apply>
      <times></times>
      <ci>X</ci>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <ci>j</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>k</ci>
      </apply>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{k}(t)=\sum_{j=1}^{M}X(t+j-1)E_{k}(j).
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="inline" id="Singular_spectrum_analysis:28">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

</p>

<p>An oscillatory mode is characterized by a pair of nearly equal SSA eigenvalues and associated PCs that are in approximate phase quadrature (Ghil et al., 2002). Such a pair can represent efficiently a nonlinear, anharmonic oscillation. This is due to the fact that a single pair of data-adaptive SSA eigenmodes often will capture better the basic periodicity of an oscillatory mode than methods with fixed <a href="basis_function" title="wikilink">basis functions</a>, such as the <a href="sine" title="wikilink">sines</a> and <a href="cosine" title="wikilink">cosines</a> used in the <a href="Fourier_transform" title="wikilink">Fourier transform</a>.</p>

<p>The window width 

<math display="inline" id="Singular_spectrum_analysis:29">
 <semantics>
  <msub>
   <mi>Œª</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Œª</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{k}
  </annotation>
 </semantics>
</math>

 determines the longest periodicity captured by SSA. Signal-to-noise separation can be obtained by merely inspecting the slope break in a "scree diagram" of eigenvalues 

<math display="inline" id="Singular_spectrum_analysis:30">
 <semantics>
  <msubsup>
   <mi>Œª</mi>
   <mi>k</mi>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Œª</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda^{1/2}_{k}
  </annotation>
 </semantics>
</math>

 or singular values 

<math display="inline" id="Singular_spectrum_analysis:31">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 vs. 

<math display="inline" id="Singular_spectrum_analysis:32">
 <semantics>
  <mrow>
   <msup>
    <mi>k</mi>
    <mo>*</mo>
   </msup>
   <mo>=</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <times></times>
    </apply>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{*}=S
  </annotation>
 </semantics>
</math>

. The point 

<math display="inline" id="Singular_spectrum_analysis:33">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 at which this break occurs should not be confused with a "dimension" 

<math display="inline" id="Singular_spectrum_analysis:34">
 <semantics>
  <msub>
   <mtext>ùêë</mtext>
   <mi>K</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>R</mtext>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\textbf{R}}_{K}
  </annotation>
 </semantics>
</math>

 of the underlying deterministic dynamics (Vautard and Ghil, 1989).</p>

<p>A Monte-Carlo test (Allen and Robertson, 1996) can be applied to ascertain the statistical significance of the oscillatory pairs detected by SSA. The entire time series or parts of it that correspond to trends, oscillatory modes or noise can be reconstructed by using linear combinations of the PCs and EOFs, which provide the reconstructed components (RCs) 

<math display="block" id="Singular_spectrum_analysis:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>K</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <msub>
       <mi>M</mi>
       <mi>t</mi>
      </msub>
     </mfrac>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
       <mrow>
        <mi>k</mi>
        <mo>‚àà</mo>
        <mtext>ùêæ</mtext>
       </mrow>
      </munder>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
        <mrow>
         <mi>j</mi>
         <mo>=</mo>
         <msub>
          <mi>L</mi>
          <mi>t</mi>
         </msub>
        </mrow>
        <msub>
         <mi>U</mi>
         <mi>t</mi>
        </msub>
       </munderover>
       <mrow>
        <msub>
         <mi>A</mi>
         <mi>k</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <mi>t</mi>
           <mo>-</mo>
           <mi>j</mi>
          </mrow>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <msub>
         <mi>E</mi>
         <mi>k</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>j</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>K</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>k</ci>
        <mtext>K</mtext>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>j</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>L</ci>
           <ci>t</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>U</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <plus></plus>
         <apply>
          <minus></minus>
          <ci>t</ci>
          <ci>j</ci>
         </apply>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>E</ci>
         <ci>k</ci>
        </apply>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{K}(t)=\frac{1}{M_{t}}\sum_{k\in{\textit{K}}}\sum_{j={L_{t}}}^{U_{t}}A_{k}(t%
-j+1)E_{k}(j);
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="inline" id="Singular_spectrum_analysis:36">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

</p>

<p>here 

<math display="inline" id="Singular_spectrum_analysis:37">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{t}
  </annotation>
 </semantics>
</math>

 is the set of EOFs on which the reconstruction is based. The values of the normalization factor 

<math display="inline" id="Singular_spectrum_analysis:38">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{t}
  </annotation>
 </semantics>
</math>

, as well as of the lower and upper bound of summation 

<math display="inline" id="Singular_spectrum_analysis:39">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{t}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Singular_spectrum_analysis:40">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

, differ between the central part of the time series and the vicinity of its endpoints (Ghil et al., 2002).</p>
<h3 id="multivariate-extension">Multivariate extension</h3>

<p>Multi-channel SSA (or M-SSA) is a natural extension of SSA to an 

<math display="inline" id="Singular_spectrum_analysis:41">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

-channel time series of vectors or maps with 

<math display="inline" id="Singular_spectrum_analysis:42">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <msub>
     <mi>X</mi>
     <mi>l</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>l</mi>
     <mo>=</mo>
     <mrow>
      <mn>1</mn>
      <mo>,</mo>
      <mi mathvariant="normal">‚Ä¶</mi>
      <mo>,</mo>
      <mi>L</mi>
     </mrow>
    </mrow>
    <mo>;</mo>
    <mrow>
     <mi>t</mi>
     <mo>=</mo>
     <mrow>
      <mn>1</mn>
      <mo>,</mo>
      <mi mathvariant="normal">‚Ä¶</mi>
      <mo>,</mo>
      <mi>N</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>l</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <ci>l</ci>
      <list>
       <cn type="integer">1</cn>
       <ci>normal-‚Ä¶</ci>
       <ci>L</ci>
      </list>
     </apply>
     <apply>
      <eq></eq>
      <ci>t</ci>
      <list>
       <cn type="integer">1</cn>
       <ci>normal-‚Ä¶</ci>
       <ci>N</ci>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{X_{l}(t):l=1,\dots,L;t=1,\dots,N\}
  </annotation>
 </semantics>
</math>

 data points 

<math display="inline" id="Singular_spectrum_analysis:43">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

. In the meteorological literature, extended EOF (EEOF) analysis is often assumed to be synonymous with M-SSA. The two methods are both extensions of classical <a href="Principal_components_analysis" title="wikilink">principal component analysis (PCA)</a> but they differ in emphasis: EEOF analysis typically utilizes a number 

<math display="inline" id="Singular_spectrum_analysis:44">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 of spatial channels much greater than the number 

<math display="inline" id="Singular_spectrum_analysis:45">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>‚â§</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>L</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\leq M
  </annotation>
 </semantics>
</math>

 of temporal lags, thus limiting the temporal and spectral information. In M-SSA, on the other hand, one usually chooses 

<math display="inline" id="Singular_spectrum_analysis:46">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

. Often M-SSA is applied to a few leading PCs of the spatial data, with 

<math display="inline" id="Singular_spectrum_analysis:48">
 <semantics>
  <msub>
   <mtext>ùêÇ</mtext>
   <mi>X</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>C</mtext>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\textbf{C}}_{X}
  </annotation>
 </semantics>
</math>

 chosen large enough to extract detailed temporal and spectral information from the multivariate time series (Ghil et al., 2002).</p>

<p>Recently, Groth and Ghil (2011) have demonstrated that a classical M-SSA analysis suffers from a degeneracy problem, namely the EOFs do not separate well between distinct oscillations when the corresponding eigenvalues are similar in size. This problem is a shortcoming of principal component analysis in general, not just of M-SSA in particular. In order to reduce mixture effects and to improve the physical interpretation, Groth and Ghil (2011) have proposed a subsequent <a href="Varimax_rotation" title="wikilink">VARIMAX rotation</a> of the spatio-temporal EOFs (ST-EOFs) of the M-SSA. To avoid a loss of spectral properties (Plaut and Vautard 1994), they have introduced a slight modification of the <a href="Varimax_rotation" title="wikilink">common VARIMAX rotation</a> that does take the spatio-temporal structure of ST-EOFs into account.</p>

<p>MSSA has two forecasting approaches known as recurrent and vector. The discrepancies between these two approaches are attributable to the organization of the single trajectory matrix 

<math display="inline" id="Singular_spectrum_analysis:49">
 <semantics>
  <msub>
   <mtext>ùêÑ</mtext>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>E</mtext>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\textbf{E}}_{k}
  </annotation>
 </semantics>
</math>

 of each series into the block trajectory matrix in the multivariate case. Two trajectory matrices can be organized as either vertical (VMSSA) or horizontal (HMSSA) as was recently introduced in Hassani and Mahmoudvand (2013), and it was shown that these constructions lead to better forecasts. Accordingly, we have four different forecasting algorithms that can be exploited in this version of MSSA (Hassani and Mahmoudvand, 2013).</p>
<h3 id="prediction">Prediction</h3>

<p>In this subsection, we focus on phenomena that exhibit a significant oscillatory component: repetition increases understanding and hence confidence in a prediction method that is closely connected with such understanding.</p>

<p>Singular spectrum analysis (SSA) and the maximum entropy method (MEM) have been combined to predict a variety of phenomena in meteorology, oceanography and climate dynamics (Ghil et al., 2002, and references therein). First, the ‚Äúnoise‚Äù is filtered out by projecting the time series onto a subset of leading EOFs obtained by SSA; the selected subset should include statistically significant, oscillatory modes. Experience shows that this approach works best when the partial variance associated with the pairs of RCs that capture these modes is large (Ghil and Jiang, 1998).</p>

<p>The prefiltered RCs are then extrapolated by least-square fitting to an <a href="autoregressive_model" title="wikilink">autoregressive model</a> <em>AR</em>[<em>p</em>], whose coefficients give the MEM spectrum of the remaining ‚Äúsignal‚Äù. Finally, the extended RCs are used in the SSA reconstruction process to produce the forecast values. The reason why this approach ‚Äì via SSA prefiltering, AR extrapolation of the RCs, and SSA reconstruction ‚Äì works better than the customary AR-based prediction is explained by the fact that the individual RCs are narrow-band signals, unlike the original, noisy time series <em>X</em>(<em>t</em>) (Penland et al., 1991; Keppenne and Ghil, 1993). In fact, the optimal order <em>p</em> obtained for the individual RCs is considerably lower than the one given by the standard Akaike information criterion (AIC) or similar ones.</p>
<h3 id="spatio-temporal-gap-filling">Spatio-temporal gap filling</h3>

<p>The gap-filling version of SSA can be used to analyze data sets that are <a href="unevenly_spaced_time_series" title="wikilink">unevenly sampled</a> or contain <a href="missing_data" title="wikilink">missing data</a> (Kondrashov and Ghil, 2006; Kondrashov et al. 2010). For a univariate time series, the SSA gap filling procedure utilizes temporal correlations to fill in the missing points. For a multivariate data set, gap filling by M-SSA takes advantage of both spatial and temporal correlations. In either case: (i) estimates of missing data points are produced iteratively, and are then used to compute a self-consistent lag-covariance matrix 

<math display="inline" id="Singular_spectrum_analysis:50">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 and its EOFs 

<math display="inline" id="Singular_spectrum_analysis:51">
 <semantics>
  <mrow>
   <mi>ùïè</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>N</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ùïè</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>N</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{X}=(x_{1},\ldots,x_{N})
  </annotation>
 </semantics>
</math>

; and (ii) <a href="cross-validation_(statistics)" title="wikilink">cross-validation</a> is used to optimize the window width 

<math display="inline" id="Singular_spectrum_analysis:52">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 and the number of leading SSA modes to fill the gaps with the iteratively estimated "signal," while the noise is discarded.</p>
<h2 id="ssa-as-a-model-free-tool">SSA as a model-free tool</h2>

<p>The areas where SSA can be applied are very broad: climatology, marine science, geophysics, engineering, image processing, medicine, econometrics among them. Hence different modifications of SSA have been proposed and different methodologies of SSA are used in practical applications such as <a href="trend_estimation" title="wikilink">trend</a> extraction, <a href="periodic_function" title="wikilink">periodicity</a> detection, <a href="seasonal_adjustment" title="wikilink">seasonal adjustment</a>, <a class="uri" href="smoothing" title="wikilink">smoothing</a>, <a href="noise_reduction" title="wikilink">noise reduction</a> (Golyandina et all, 2001).</p>
<h3 id="basic-ssa">Basic SSA</h3>

<p>SSA can be used as a model-free technique so that it can be applied to arbitrary time series including non-stationary time series. The basic aim of SSA is to decompose the time series into the sum of interpretable components such as trend, periodic components and noise with no a-priori assumptions about the parametric form of these components.</p>

<p>Consider a real-valued time series 

<math display="inline" id="Singular_spectrum_analysis:53">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 of length 

<math display="inline" id="Singular_spectrum_analysis:54">
 <semantics>
  <mi>ùïè</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùïè</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{X}
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Singular_spectrum_analysis:55">
 <semantics>
  <mrow>
   <mpadded width="-1.7pt">
    <mi>L</mi>
   </mpadded>
   <mo rspace="0.8pt">√ó</mo>
   <mi>K</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\!\times\!K
  </annotation>
 </semantics>
</math>

 

<math display="block" id="Singular_spectrum_analysis:56">
 <semantics>
  <mrow>
   <mi>ùêó</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>:</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>:</mo>
    <msub>
     <mi>X</mi>
     <mi>K</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>j</mi>
     </mrow>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mrow>
     <mi>L</mi>
     <mo>,</mo>
     <mi>K</mi>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>x</mi>
        <msub>
         <mo>;</mo>
         <mn>2</mn>
        </msub>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>x</mi>
        <msub>
         <mo>;</mo>
         <mn>3</mn>
        </msub>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">‚Ä¶</mi>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>x</mi>
        <msub>
         <mo>;</mo>
         <mi>K</mi>
        </msub>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>x</mi>
        <msub>
         <mo>;</mo>
         <mn>3</mn>
        </msub>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>x</mi>
        <msub>
         <mo>;</mo>
         <mn>4</mn>
        </msub>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">‚Ä¶</mi>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>x</mi>
        <msub>
         <mo>;</mo>
         <mrow>
          <mi>K</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>x</mi>
        <mn>3</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>x</mi>
        <msub>
         <mo>;</mo>
         <mn>4</mn>
        </msub>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>x</mi>
        <msub>
         <mo>;</mo>
         <mn>5</mn>
        </msub>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">‚Ä¶</mi>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>x</mi>
        <msub>
         <mo>;</mo>
         <mrow>
          <mi>K</mi>
          <mo>+</mo>
          <mn>2</mn>
         </mrow>
        </msub>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">‚ãÆ</mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">‚ãÆ</mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">‚ãÆ</mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">‚ã±</mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">‚ãÆ</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>x</mi>
        <mi>L</mi>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>x</mi>
        <msub>
         <mo>;</mo>
         <mrow>
          <mi>L</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>x</mi>
        <msub>
         <mo>;</mo>
         <mrow>
          <mi>L</mi>
          <mo>+</mo>
          <mn>2</mn>
         </mrow>
        </msub>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">‚Ä¶</mi>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>x</mi>
        <msub>
         <mo>;</mo>
         <mi>N</mi>
        </msub>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">X</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-:</ci>
     <ci>normal-‚Ä¶</ci>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>K</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <apply>
       <eq></eq>
       <list>
        <ci>i</ci>
        <ci>j</ci>
       </list>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <list>
      <ci>L</ci>
      <ci>K</ci>
     </list>
    </apply>
    <eq></eq>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-;</ci>
        <cn type="integer">2</cn>
       </apply>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-;</ci>
        <cn type="integer">3</cn>
       </apply>
      </cerror>
      <ci>normal-‚Ä¶</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-;</ci>
        <ci>K</ci>
       </apply>
      </cerror>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-;</ci>
        <cn type="integer">3</cn>
       </apply>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-;</ci>
        <cn type="integer">4</cn>
       </apply>
      </cerror>
      <ci>normal-‚Ä¶</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-;</ci>
        <apply>
         <plus></plus>
         <ci>K</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </cerror>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-;</ci>
        <cn type="integer">4</cn>
       </apply>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-;</ci>
        <cn type="integer">5</cn>
       </apply>
      </cerror>
      <ci>normal-‚Ä¶</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-;</ci>
        <apply>
         <plus></plus>
         <ci>K</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </cerror>
     </matrixrow>
     <matrixrow>
      <ci>normal-‚ãÆ</ci>
      <ci>normal-‚ãÆ</ci>
      <ci>normal-‚ãÆ</ci>
      <ci>normal-‚ã±</ci>
      <ci>normal-‚ãÆ</ci>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>L</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-;</ci>
        <apply>
         <plus></plus>
         <ci>L</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-;</ci>
        <apply>
         <plus></plus>
         <ci>L</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </cerror>
      <ci>normal-‚Ä¶</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-;</ci>
        <ci>N</ci>
       </apply>
      </cerror>
     </matrixrow>
    </matrix>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{X}=[X_{1}:\ldots:X_{K}]=(x_{ij})_{i,j=1}^{L,K}=\begin{bmatrix}x_{1}&x;%
_{2}&x;_{3}&\ldots&x;_{K}\\
x_{2}&x;_{3}&x;_{4}&\ldots&x;_{K+1}\\
x_{3}&x;_{4}&x;_{5}&\ldots&x;_{K+2}\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
x_{L}&x;_{L+1}&x;_{L+2}&\ldots&x;_{N}\\
\end{bmatrix}
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="main-algorithm-of-ssa">Main algorithm of SSA</h4>

<p><strong>1st step: Embedding.</strong></p>

<p>Form the <em>trajectory matrix</em> of the series 

<math display="inline" id="Singular_spectrum_analysis:57">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mrow>
       <mrow>
        <mi>i</mi>
        <mo>+</mo>
        <mi>L</mi>
       </mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">T</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>‚â§</mo>
    <mi>i</mi>
    <mo>‚â§</mo>
    <mi>K</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>i</ci>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-,</ci>
      <ci>normal-‚Ä¶</ci>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <ci>L</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-T</ci>
    </apply>
    <ci>italic-</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">1</cn>
     <leq></leq>
     <csymbol cd="unknown">i</csymbol>
     <leq></leq>
     <csymbol cd="unknown">K</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}=(x_{i},\ldots,x_{i+L-1})^{\mathrm{T}}\;\quad(1\leq i\leq K)
  </annotation>
 </semantics>
</math>

, which is the 

<math display="inline" id="Singular_spectrum_analysis:58">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 matrix</p>

<p>

<math display="inline" id="Singular_spectrum_analysis:59">
 <semantics>
  <mi>ùêó</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêó</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{X}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Singular_spectrum_analysis:60">
 <semantics>
  <mi>ùêó</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêó</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{X}
  </annotation>
 </semantics>
</math>

 are <em>lagged vectors</em> of size 

<math display="inline" id="Singular_spectrum_analysis:61">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{ij}
  </annotation>
 </semantics>
</math>


. The matrix 

<math display="inline" id="Singular_spectrum_analysis:62">
 <semantics>
  <mrow>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mi>j</mi>
   </mrow>
   <mo rspace="4.2pt">=</mo>
   <mi>const</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
    <ci>const</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i+j=\,{\rm const}
  </annotation>
 </semantics>
</math>

 is a <a href="Hankel_matrix" title="wikilink">Hankel matrix</a> which means that 

<math display="inline" id="Singular_spectrum_analysis:63">
 <semantics>
  <mi>ùêó</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêó</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{X}
  </annotation>
 </semantics>
</math>

 has equal elements 

<math display="inline" id="Singular_spectrum_analysis:64">
 <semantics>
  <mrow>
   <mi>ùêí</mi>
   <mo>=</mo>
   <msup>
    <mi>ùêóùêó</mi>
    <mi mathvariant="normal">T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ùêí</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ùêóùêó</ci>
     <ci>normal-T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}=\mathbf{X}\mathbf{X}^{\mathrm{T}}
  </annotation>
 </semantics>
</math>

 on the anti-diagonals 

<math display="inline" id="Singular_spectrum_analysis:65">
 <semantics>
  <mrow>
   <msub>
    <mi>Œª</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">‚Ä¶</mi>
   <mo>,</mo>
   <msub>
    <mi>Œª</mi>
    <mi>L</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Œª</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-‚Ä¶</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Œª</ci>
     <ci>L</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{1},\ldots,\lambda_{L}
  </annotation>
 </semantics>
</math>

.</p>

<p><strong>2nd step: <a href="Singular_Value_Decomposition" title="wikilink">Singular Value Decomposition</a> (SVD).</strong></p>

<p>Perform the singular value decomposition (SVD) of the trajectory matrix 

<math display="inline" id="Singular_spectrum_analysis:66">
 <semantics>
  <mi>ùêí</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêí</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}
  </annotation>
 </semantics>
</math>


. Set 

<math display="inline" id="Singular_spectrum_analysis:67">
 <semantics>
  <mrow>
   <msub>
    <mi>Œª</mi>
    <mn>1</mn>
   </msub>
   <mo>‚â•</mo>
   <mi mathvariant="normal">‚Ä¶</mi>
   <mo>‚â•</mo>
   <msub>
    <mi>Œª</mi>
    <mi>L</mi>
   </msub>
   <mo>‚â•</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Œª</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-‚Ä¶</ci>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Œª</ci>
      <ci>L</ci>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{1}\geq\ldots\geq\lambda_{L}\geq 0
  </annotation>
 </semantics>
</math>

 and denote by 

<math display="inline" id="Singular_spectrum_analysis:68">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">‚Ä¶</mi>
   <mo>,</mo>
   <msub>
    <mi>U</mi>
    <mi>L</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-‚Ä¶</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>L</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{1},\ldots,U_{L}
  </annotation>
 </semantics>
</math>

 the <em>eigenvalues</em> of 

<math display="inline" id="Singular_spectrum_analysis:69">
 <semantics>
  <mi>ùêí</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêí</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}
  </annotation>
 </semantics>
</math>

 taken in the decreasing order of magnitude (

<math display="inline" id="Singular_spectrum_analysis:70">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mrow>
    <mo>rank</mo>
    <mi>ùêó</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>max</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>i</mi>
     <mo rspace="7.5pt">,</mo>
     <mrow>
      <mrow>
       <mpadded width="+5pt">
        <mtext>such that</mtext>
       </mpadded>
       <msub>
        <mi>Œª</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo>></mo>
      <mn>0</mn>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>d</ci>
     <apply>
      <ci>rank</ci>
      <ci>ùêó</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <max></max>
      <ci>i</ci>
      <apply>
       <gt></gt>
       <apply>
        <times></times>
        <mtext>such that</mtext>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Œª</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=\mathop{\mathrm{rank}}\mathbf{X}=\max\{i,\ \mbox{such that}\ \lambda_{i}>0\}
  </annotation>
 </semantics>
</math>

) and by 

<math display="inline" id="Singular_spectrum_analysis:71">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>d</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=L
  </annotation>
 </semantics>
</math>


 the orthonormal system of the <em>eigenvectors</em> of the matrix 

<math display="inline" id="Singular_spectrum_analysis:72">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>ùêó</mi>
      <mi mathvariant="normal">T</mi>
     </msup>
     <msub>
      <mi>U</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>/</mo>
    <msqrt>
     <msub>
      <mi>Œª</mi>
      <mi>i</mi>
     </msub>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ùêó</ci>
       <ci>normal-T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <root></root>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Œª</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{i}=\mathbf{X}^{\mathrm{T}}U_{i}/\sqrt{\lambda_{i}}
  </annotation>
 </semantics>
</math>

 corresponding to these eigenvalues.</p>

<p>Set 

<math display="inline" id="Singular_spectrum_analysis:73">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo>,</mo>
     <mi>d</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-‚Ä¶</ci>
     <ci>d</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i=1,\ldots,d)
  </annotation>
 </semantics>
</math>

 (note that 

<math display="inline" id="Singular_spectrum_analysis:74">
 <semantics>
  <mi>ùêó</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêó</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{X}
  </annotation>
 </semantics>
</math>

 for a typical real-life series) and 

<math display="block" id="Singular_spectrum_analysis:75">
 <semantics>
  <mrow>
   <mrow>
    <mi>ùêó</mi>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>ùêó</mi>
      <mn>1</mn>
     </msub>
     <mo>+</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo>+</mo>
     <msub>
      <mi>ùêó</mi>
      <mi>d</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ùêó</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùêó</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùêó</ci>
      <ci>d</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{X}=\mathbf{X}_{1}+\ldots+\mathbf{X}_{d},
  </annotation>
 </semantics>
</math>

 

<math display="block" id="Singular_spectrum_analysis:76">
 <semantics>
  <mrow>
   <msub>
    <mi>ùêó</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msqrt>
     <msub>
      <mi>Œª</mi>
      <mi>i</mi>
     </msub>
    </msqrt>
    <msub>
     <mi>U</mi>
     <mi>i</mi>
    </msub>
    <msubsup>
     <mi>V</mi>
     <mi>i</mi>
     <mi mathvariant="normal">T</mi>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ùêó</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <root></root>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Œª</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{X}_{i}=\sqrt{\lambda_{i}}U_{i}V_{i}^{\mathrm{T}}
  </annotation>
 </semantics>
</math>

. In this notation, the SVD of the trajectory matrix 

<math display="inline" id="Singular_spectrum_analysis:77">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msqrt>
    <msub>
     <mi>Œª</mi>
     <mi>i</mi>
    </msub>
   </msqrt>
   <mo>,</mo>
   <msub>
    <mi>U</mi>
    <mi>i</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>V</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <root></root>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Œª</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <ci>i</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\sqrt{\lambda_{i}},U_{i},V_{i})
  </annotation>
 </semantics>
</math>

 can be written as</p>

<p>

<math display="inline" id="Singular_spectrum_analysis:78">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="inline" id="Singular_spectrum_analysis:79">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{i}
  </annotation>
 </semantics>
</math>

 are matrices having rank 1; these are called <em>elementary matrices</em>. The collection 

<math display="inline" id="Singular_spectrum_analysis:80">
 <semantics>
  <mi>ùêó</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêó</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{X}
  </annotation>
 </semantics>
</math>

 will be called the 

<math display="inline" id="Singular_spectrum_analysis:81">
 <semantics>
  <msqrt>
   <msub>
    <mi>Œª</mi>
    <mi>i</mi>
   </msub>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Œª</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{\lambda_{i}}
  </annotation>
 </semantics>
</math>


th <em>eigentriple</em> (abbreviated as ET) of the SVD. Vectors 

<math display="inline" id="Singular_spectrum_analysis:82">
 <semantics>
  <mi>ùêó</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêó</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{X}
  </annotation>
 </semantics>
</math>

 are the left singular vectors of the matrix 

<math display="inline" id="Singular_spectrum_analysis:83">
 <semantics>
  <mrow>
   <mrow>
    <msqrt>
     <msub>
      <mi>Œª</mi>
      <mi>i</mi>
     </msub>
    </msqrt>
    <msub>
     <mi>V</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>ùêó</mi>
     <mi mathvariant="normal">T</mi>
    </msup>
    <msub>
     <mi>U</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <root></root>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Œª</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ùêó</ci>
      <ci>normal-T</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{\lambda_{i}}V_{i}=\mathbf{X}^{\mathrm{T}}U_{i}
  </annotation>
 </semantics>
</math>

, numbers 

<math display="inline" id="Singular_spectrum_analysis:84">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mi mathvariant="normal">‚Ä¶</mi>
   <mo>,</mo>
   <mi>d</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">1</cn>
    <ci>normal-‚Ä¶</ci>
    <ci>d</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{1,\ldots,d\}
  </annotation>
 </semantics>
</math>

 are the singular values and provide the singular spectrum of 

<math display="inline" id="Singular_spectrum_analysis:85">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

; this gives the name to SSA. Vectors 

<math display="inline" id="Singular_spectrum_analysis:86">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">‚Ä¶</mi>
   <mo>,</mo>
   <msub>
    <mi>I</mi>
    <mi>m</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-‚Ä¶</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>m</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{1},\ldots,I_{m}
  </annotation>
 </semantics>
</math>


 are called vectors of principal components (PCs).</p>

<p><strong>3rd step: Eigentriple grouping.</strong></p>

<p>Partition the set of indices 

<math display="inline" id="Singular_spectrum_analysis:87">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>i</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msub>
     <mi>i</mi>
     <mi>p</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>I</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>i</ci>
      <ci>p</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I=\{i_{1},\ldots,i_{p}\}
  </annotation>
 </semantics>
</math>

 into 

<math display="inline" id="Singular_spectrum_analysis:88">
 <semantics>
  <msub>
   <mi>ùêó</mi>
   <mi>I</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ùêó</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{X}_{I}
  </annotation>
 </semantics>
</math>

 disjoint subsets 

<math display="inline" id="Singular_spectrum_analysis:89">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

.</p>

<p>Let 

<math display="inline" id="Singular_spectrum_analysis:90">
 <semantics>
  <mrow>
   <msub>
    <mi>ùêó</mi>
    <mi>I</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>ùêó</mi>
     <msub>
      <mi>i</mi>
      <mn>1</mn>
     </msub>
    </msub>
    <mo>+</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>+</mo>
    <msub>
     <mi>ùêó</mi>
     <msub>
      <mi>i</mi>
      <mi>p</mi>
     </msub>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ùêó</ci>
     <ci>I</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùêó</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùêó</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>i</ci>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{X}_{I}=\mathbf{X}_{i_{1}}+\ldots+\mathbf{X}_{i_{p}}
  </annotation>
 </semantics>
</math>

. Then the resultant matrix 

<math display="inline" id="Singular_spectrum_analysis:91">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>I</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msub>
     <mi>I</mi>
     <mi>m</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>I</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>m</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I=I_{1},\ldots,I_{m}
  </annotation>
 </semantics>
</math>


 corresponding to the group 

<math display="inline" id="Singular_spectrum_analysis:92">
 <semantics>
  <mi>ùêó</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêó</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{X}
  </annotation>
 </semantics>
</math>

 is defined as 

<math display="block" id="Singular_spectrum_analysis:93">
 <semantics>
  <mrow>
   <mrow>
    <mi>ùêó</mi>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>ùêó</mi>
      <msub>
       <mi>I</mi>
       <mn>1</mn>
      </msub>
     </msub>
     <mo>+</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo>+</mo>
     <msub>
      <mi>ùêó</mi>
      <msub>
       <mi>I</mi>
       <mi>m</mi>
      </msub>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ùêó</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùêó</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùêó</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{X}=\mathbf{X}_{I_{1}}+\ldots+\mathbf{X}_{I_{m}}.
  </annotation>
 </semantics>
</math>

. The resultant matrices are computed for the groups 

<math display="inline" id="Singular_spectrum_analysis:94">
 <semantics>
  <msub>
   <mi>ùêó</mi>
   <msub>
    <mi>I</mi>
    <mi>j</mi>
   </msub>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ùêó</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{X}_{I_{j}}
  </annotation>
 </semantics>
</math>

 and the grouped SVD expansion of 

<math display="inline" id="Singular_spectrum_analysis:95">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 can now be written as</p>

<p>

<math display="inline" id="Singular_spectrum_analysis:96">
 <semantics>
  <msub>
   <mi>ùêó</mi>
   <msub>
    <mi>I</mi>
    <mi>k</mi>
   </msub>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ùêó</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{X}_{I_{k}}
  </annotation>
 </semantics>
</math>


</p>

<p><strong>4th step: Diagonal averaging.</strong></p>

<p>Each matrix 

<math display="inline" id="Singular_spectrum_analysis:97">
 <semantics>
  <mrow>
   <msup>
    <mover accent="true">
     <mi>ùïè</mi>
     <mo>~</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mover accent="true">
      <mi>x</mi>
      <mo>~</mo>
     </mover>
     <mn>1</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msubsup>
     <mover accent="true">
      <mi>x</mi>
      <mo>~</mo>
     </mover>
     <mi>N</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>ùïè</ci>
     </apply>
     <ci>k</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>x</ci>
       </apply>
       <ci>k</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>x</ci>
       </apply>
       <ci>k</ci>
      </apply>
      <ci>N</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widetilde{\mathbb{X}}^{(k)}=(\widetilde{x}^{(k)}_{1},\ldots,\widetilde{x}^{(k%
)}_{N})
  </annotation>
 </semantics>
</math>

 of the grouped decomposition is hankelized and then the obtained Hankel matrix is transformed into a new series of length 

<math display="inline" id="Singular_spectrum_analysis:98">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">‚Ä¶</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>N</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-‚Ä¶</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>N</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\ldots,x_{N}
  </annotation>
 </semantics>
</math>

 using the one-to-one correspondence between Hankel matrices and time series. Diagonal averaging applied to a resultant matrix 

<math display="inline" id="Singular_spectrum_analysis:99">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 produces a <em>reconstructed series</em> 

<math display="block" id="Singular_spectrum_analysis:100">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
    <mrow>
     <mi>k</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>m</mi>
   </munderover>
   <msubsup>
    <mover accent="true">
     <mi>x</mi>
     <mo>~</mo>
    </mover>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>m</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-~</ci>
       <ci>x</ci>
      </apply>
      <ci>k</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <ci></ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <cn type="integer">2</cn>
     <ci>normal-,</ci>
     <ci>normal-‚Ä¶</ci>
     <ci>normal-,</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}=\sum\limits_{k=1}^{m}\widetilde{x}^{(k)}_{n}\ \ (n=1,2,\ldots,N).
  </annotation>
 </semantics>
</math>

. In this way, the initial series 

<math display="inline" id="Singular_spectrum_analysis:101">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>


 is decomposed into a sum of 

<math display="inline" id="Singular_spectrum_analysis:102">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>‚Üí</mo>
   <mi mathvariant="normal">‚àû</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-‚Üí</ci>
    <ci>N</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\rightarrow\infty
  </annotation>
 </semantics>
</math>

 reconstructed subseries:</p>

<p>

<math display="inline" id="Singular_spectrum_analysis:103">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

</p>

<p>This decomposition is the main result of the SSA algorithm. The decomposition is meaningful if each reconstructed subseries could be classified as a part of either trend or some periodic component or noise.</p>
<h4 id="theory-of-ssa-separability">Theory of SSA separability</h4>

<p>The two main questions which the theory of SSA attempts to answer are: (a) what time series components can be separated by SSA, and (b) how to choose the window length 

<math display="inline" id="Singular_spectrum_analysis:104">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 and make proper grouping for extraction of a desirable component. Many theoretical results can be found in Golyandina et al. (2001, Ch. 1 and 6).</p>

<p>Trend (which is defined as a slowly varying component of the time series), periodic components and noise are asymptotically separable as 

<math display="inline" id="Singular_spectrum_analysis:105">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

. In practice 

<math display="inline" id="Singular_spectrum_analysis:106">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>


 is fixed and one is interested in approximate separability between time series components. A number of indicators of approximate separability can be used, see Golyandina et al. (2001, Ch. 1). The window length 

<math display="inline" id="Singular_spectrum_analysis:107">
 <semantics>
  <mrow>
   <mi>œÄ</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>œÄ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi/2
  </annotation>
 </semantics>
</math>

 determines the resolution of the method: larger values of 

<math display="inline" id="Singular_spectrum_analysis:108">
 <semantics>
  <mi>ùïè</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùïè</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{X}
  </annotation>
 </semantics>
</math>

 provide more refined decomposition into elementary components and therefore better separability. The window length 

<math display="inline" id="Singular_spectrum_analysis:109">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 determines the longest periodicity captured by SSA. Trends can be extracted by grouping of eigentriples with slowly varying eigenvectors. A sinusoid with frequency smaller than 0.5 produces two approximately equal eigenvalues and two sine-wave eigenvectors with the same frequencies and 

<math display="inline" id="Singular_spectrum_analysis:110">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">‚àë</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>d</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>b</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mi>k</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>d</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}=\sum_{k=1}^{d}b_{k}x_{n-k}
  </annotation>
 </semantics>
</math>

-shifted phases.</p>

<p>Separation of two time series components can be considered as extraction of one component in the presence of perturbation by the other component. SSA perturbation theory is developed in Nekrutkin (2010) and Hassani et al. (2011).</p>
<h3 id="forecasting-by-ssa">Forecasting by SSA</h3>

<p>If for some series 

<math display="inline" id="Singular_spectrum_analysis:111">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>></mo>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>L</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L>d
  </annotation>
 </semantics>
</math>


 the SVD step in Basic SSA gives 

<math display="inline" id="Singular_spectrum_analysis:112">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">‚Ä¶</mi>
   <mo>,</mo>
   <msub>
    <mi>U</mi>
    <mi>d</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-‚Ä¶</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>d</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{1},\ldots,U_{d}
  </annotation>
 </semantics>
</math>

'' (Golyandina et al., 2001, Ch.5). The subspace spanned by the 

<math display="inline" id="Singular_spectrum_analysis:113">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 leading eigenvectors is called <a href="signal_subspace" title="wikilink">signal subspace</a>. This subspace is used for estimating the signal parameters in <a href="signal_processing" title="wikilink">signal processing</a>, e.g. <a href="Estimation_of_signal_parameters_via_rotational_invariance_techniques" title="wikilink">ESPRIT</a> for high-resolution frequency estimation. Also, this subspace determines the <a href="recurrence_relation" title="wikilink">linear homogeneous recurrence relation</a> (LRR) governing the series, which can be used for forecasting. Continuation of the series by the LRR is similar to forward <a href="linear_prediction" title="wikilink">linear prediction</a> in signal processing.</p>

<p>Let the series be governed by the minimal LRR 

<math display="inline" id="Singular_spectrum_analysis:114">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">‚àë</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mrow>
      <mi>L</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mi>k</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>L</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}=\sum_{k=1}^{L-1}a_{k}x_{n-k}
  </annotation>
 </semantics>
</math>

. Let us choose 

<math display="inline" id="Singular_spectrum_analysis:115">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>L</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="normal">T</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <ci>L</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
    </vector>
    <ci>normal-T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a_{L-1},\ldots,a_{1})^{\mathrm{T}}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Singular_spectrum_analysis:116">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">‚Ä¶</mi>
   <mo>,</mo>
   <msub>
    <mi>U</mi>
    <mi>d</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-‚Ä¶</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>d</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{1},\ldots,U_{d}
  </annotation>
 </semantics>
</math>


 be the eigenvectors (left singular vectors of the 

<math display="inline" id="Singular_spectrum_analysis:117">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mi>x</mi>
   </msub>
   <mo>√ó</mo>
   <msub>
    <mi>L</mi>
    <mi>y</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{x}\times L_{y}
  </annotation>
 </semantics>
</math>

-trajectory matrix), which are provided by the SVD step of SSA. Then this series is governed by an LRR 

<math display="inline" id="Singular_spectrum_analysis:118">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>s</mi>
     <mi>n</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>e</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}=s_{n}+e_{n}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Singular_spectrum_analysis:119">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">‚àë</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>r</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>s</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mi>k</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>r</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{n}=\sum_{k=1}^{r}a_{k}s_{n-k}
  </annotation>
 </semantics>
</math>

 are expressed through 

<math display="inline" id="Singular_spectrum_analysis:120">
 <semantics>
  <msub>
   <mi>e</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{n}
  </annotation>
 </semantics>
</math>

 (Golyandina et al., 2001, Ch.5), and can be continued by the same LRR.</p>

<p>This provides the basis for SSA recurrent and vector forecasting algorithms (Golyandina et al., 2001, Ch.2). In practice, the signal is corrupted by a perturbation, e.g., by noise, and its subspace is estimated by SSA approximately. Thus, SSA forecasting can be applied for forecasting of a time series component that is approximately governed by an LRR and is approximately separated from the residual.</p>
<h3 id="multivariate-extension-1">Multivariate extension</h3>

<p>Multi-channel, Multivariate SSA (or M-SSA) is a natural extension of SSA to for analyzing multivariate time series, where the size of different univariate series does not have to be the same. The trajectory matrix of multi-channel time series consists of stacked trajectory matrices of separate times series. The rest of the algorithm is the same as in the univariate case. System of series can be forecasted analogously to SSA recurrent and vector algorithms (Golyandina and Stepanov, 2005). MSSA has many applications. It is especially popular in analyzing and forecasting economic and financial time series with short and long series length (Patterson et al., 2011, Hassani et al., 2012, Hassani and Mahmoudvand, 2013). Other multivariate extension is 2D-SSA that can be applied to two-dimensional data like digital images (Golyandina and Usevich, 2010). The analogue of trajectory matrix is constructed by moving 2D windows of size 

<math display="inline" id="Singular_spectrum_analysis:121">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>r</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>k</mi>
      </msub>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mi>k</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>e</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>r</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}=\sum_{k=1}^{r}a_{k}x_{n-k}+e_{n}
  </annotation>
 </semantics>
</math>


.</p>
<h4 id="mssa-and-causality">MSSA and causality</h4>

<p>A question that frequently arises in time series analysis is whether one economic variable can help in predicting another economic variable. One way to address this question was proposed by Granger (1969), in which he formalized the causality concept. A comprehensive causality test based on MSSA has recently introduced for causality measurement. The test is based on the forecasting accuracy and predictability of the direction of change of the MSSA algorithms (Hassani et al., 2011 and Hassani et al.,2012).</p>
<h4 id="mssa-and-emh">MSSA and EMH</h4>

<p>The MSSA forecasting results can be used in examining the efficient market hypothesis controversy (EMH). The EMH suggests that the information contained in the price series of an asset is reflected ‚Äúinstantly, fully, and perpetually‚Äù in the asset‚Äôs current price. Since the price series and the information contained in it are available to all market participants, no one can benefit by attempting to take advantage of the information contained in the price history of an asset by trading in the markets. This is evaluated using two series with different series length in a multivariate system in SSA analysis (Hassani et al. 2010).</p>
<h4 id="mssa-ssa-and-unit-root">MSSA, SSA and Unit Root</h4>

<p>SSA's applicability to any kind of stationary or deterministically trending series has been extented to the case of a series with a stochastic trend, also known as a series with a unit root. In Hassani and Thomakos (2010) and Thomakos (2010) the basic theory on the properties and application of SSA in the case of series of a unit root is given, along with several examples. It is shown that SSA in such series produces a special kind of filter, whose form and spectral properties are derived, and that forecasting the single reconstructed component reduces to a moving average. SSA in unit roots thus provides an `optimizing' non-parametric framework for smoothing series with a unit root. This line of work is also extended to the case of two series, both of which have a unit root but are cointegrated. The application of SSA in this bivariate framework produces a smoothed series of the common root component.</p>
<h3 id="gap-filling">Gap-filling</h3>

<p>The gap-filling versions of SSA can be used to analyze data sets that are unevenly sampled or contain <a href="missing_data" title="wikilink">missing data</a> (Schoellhamer, 2001; Golyandina and Osipov, 2007).</p>

<p>Schoellhamer (2001) shows that the straightforward idea to formally calculate approximate inner products omitting unknown terms is workable for long stationary time series. Golyandina and Osipov (2007) uses the idea of filling in missing entries in vectors taken from the given subspace. The recurrent and vector SSA forecasting can be considered as particular cases of filling in algorithms described in the paper.</p>
<h3 id="detection-of-structural-changes">Detection of structural changes</h3>

<p>SSA can be effectively used as a non-parametric method of time series monitoring and <a href="change_detection" title="wikilink">change detection</a>. To do that, SSA performs the subspace tracking in the following way. SSA is applied sequentially to the initial parts of the series, constructs the corresponding signal subspaces and checks the distances between these subspaces and the lagged vectors formed from the few most recent observations. If these distances become too large, a structural change is suspected to have occurred in the series (Golyandina et al., 2001, Ch.3; Moskvina and Zhigljavsky, 2003).</p>

<p>In this way, SSA could be used for <a href="change_detection" title="wikilink">change detection</a> not only in trends but also in the variability of the series, in the mechanism that determines dependence between different series and even in the noise structure. The method have proved to be useful in different engineering problems (e.g. Mohammad and Nishida (2011) in robotics).</p>
<h3 id="relation-between-ssa-and-other-methods">Relation between SSA and other methods</h3>

<p><strong>SSA and <a href="Autoregressive" title="wikilink">Autoregression</a>.</strong> Typical model for SSA is 

<math display="inline" id="Singular_spectrum_analysis:122">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>/</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>k</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k/N
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Singular_spectrum_analysis:123">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">‚àë</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>r</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>s</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mi>k</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>r</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{n}=\sum_{k=1}^{r}a_{k}s_{n-k}
  </annotation>
 </semantics>
</math>

 (signal satisfying an LRR) and 

<math display="inline" id="Singular_spectrum_analysis:124">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">‚àë</mo>
     <mi>k</mi>
    </msub>
    <mrow>
     <msub>
      <mi>C</mi>
      <mi>k</mi>
     </msub>
     <msubsup>
      <mi>œÅ</mi>
      <mi>k</mi>
      <mi>n</mi>
     </msubsup>
     <msup>
      <mi>e</mi>
      <mrow>
       <mi>i</mi>
       <mn>2</mn>
       <mi>œÄ</mi>
       <msub>
        <mi>œâ</mi>
        <mi>k</mi>
       </msub>
       <mi>n</mi>
      </mrow>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>œÅ</ci>
        <ci>k</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <cn type="integer">2</cn>
        <ci>œÄ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>œâ</ci>
         <ci>k</ci>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{n}=\sum_{k}C_{k}\rho_{k}^{n}e^{i2\pi\omega_{k}n}
  </annotation>
 </semantics>
</math>

 is noise. The model of AR is 

<math display="inline" id="Singular_spectrum_analysis:125">
 <semantics>
  <msub>
   <mi>œâ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>œâ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{k}
  </annotation>
 </semantics>
</math>

. Despite these two models look similar they are very different. SSA considers AR as a noise component only. AR(1), which is red noise, is typical model of noise for Monte-Carlo SSA (Allen and Smith,1996 ).</p>

<p><strong>SSA and spectral <a href="Fourier_Analysis" title="wikilink">Fourier Analysis</a>.</strong> In contrast with Fourier analysis with fixed basis of sine and cosine functions, SSA uses an adaptive basis generated by the time series itself. As a result, the underlying model in SSA is more general and SSA can extract amplitude-modulated sine wave components with frequencies different from 

<math display="inline" id="Singular_spectrum_analysis:126">
 <semantics>
  <msub>
   <mi>œÅ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>œÅ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{k}
  </annotation>
 </semantics>
</math>


. SSA-related methods like <a href="Estimation_of_signal_parameters_via_rotational_invariance_techniques" title="wikilink">ESPRIT</a> can estimate frequencies with higher resolution than spectral <a href="Fourier_analysis" title="wikilink">Fourier analysis</a>.</p>

<p><strong>SSA and <a href="recurrence_relation" title="wikilink">Linear Recurrence Relations</a>.</strong> Let the signal be modeled by a series, which satisfies a linear recurrence relation 

<math display="inline" id="Singular_spectrum_analysis:127">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{k}
  </annotation>
 </semantics>
</math>

; that is, a series that can be represented as sums of products of exponential, polynomial and sine wave functions. This includes the <em>sum of dumped sinusoids model</em> whose complex-valued form is 

<math display="inline" id="Singular_spectrum_analysis:128">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{k}
  </annotation>
 </semantics>
</math>

. SSA-related methods allow <a href="frequency_estimation" title="wikilink">estimation of frequencies</a> 

<math display="inline" id="Singular_spectrum_analysis:129">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 and exponential factors 

<math display="inline" id="Singular_spectrum_analysis:130">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 (Golyandina and Zhigljavsky, 2013, Sect 3.8). Coefficients 

<math display="inline" id="Singular_spectrum_analysis:131">
 <semantics>
  <mrow>
   <mo>span</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>U</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msub>
     <mi>U</mi>
     <mi>r</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>span</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>r</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathop{\mathrm{span}}(U_{1},\ldots,U_{r})
  </annotation>
 </semantics>
</math>


 can be estimated by the <a href="least_squares" title="wikilink">least squares</a> method. Extension of the model, where 

<math display="inline" id="Singular_spectrum_analysis:132">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>s</mi>
     <mi>n</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>e</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}=s_{n}+e_{n}
  </annotation>
 </semantics>
</math>

 are replaced by polynomials of 

<math display="inline" id="Singular_spectrum_analysis:133">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">‚àë</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>r</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>s</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mi>k</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>r</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{n}=\sum_{k=1}^{r}a_{k}s_{n-k}
  </annotation>
 </semantics>
</math>

, can be also considered within the SSA-related methods (Badeau et al., 2008).</p>

<p><strong>SSA and <a href="Signal_subspace" title="wikilink">Signal Subspace</a> methods.</strong> SSA can be considered as a subspace-based method, since it allows estimation of the signal subspace of dimension 

<math display="inline" id="Singular_spectrum_analysis:134">
 <semantics>
  <msub>
   <mi>e</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{n}
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Singular_spectrum_analysis:135">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

.</p>

<p><strong>SSA and <a href="State_Space_Model" title="wikilink">State Space Models</a>.</strong> The main model behind SSA is 

<math display="inline" id="Singular_spectrum_analysis:136">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>u</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo>,</mo>
     <msub>
      <mi>u</mi>
      <mi>L</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-‚Ä¶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>L</ci>
      </apply>
     </vector>
     <ci>normal-T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{i}=(u_{1},\ldots,u_{L})^{\mathrm{T}}
  </annotation>
 </semantics>
</math>


, where 

<math display="inline" id="Singular_spectrum_analysis:137">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>L</mi>
   </mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>L</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2L-1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Singular_spectrum_analysis:138">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>x</mi>
    <mo>~</mo>
   </mover>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-~</ci>
     <ci>x</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widetilde{x}_{s}
  </annotation>
 </semantics>
</math>

 is noise. Formally, this model belongs to the general class of state space models. The specifics of SSA is in the facts that parameter estimation is a problem of secondary importance in SSA and the data analysis procedures in SSA are nonlinear as they are based on the SVD of either trajectory or lag-covariance matrix.</p>

<p><strong>SSA and <a href="Independent_Component_Analysis" title="wikilink">Independent Component Analysis</a> (ICA).</strong> SSA is used in <a href="blind_source_separation" title="wikilink">blind source separation</a> by ICA as a preprocessing step (Pietil√§ et al., 2006). On the other hand, ICA can be used as a replacement of the SVD step in the SSA algorithm for achieving better separability (Golyandina and Zhigljavsky, 2013, Sect. 2.5.4).</p>

<p><strong>SSA and <a href="Regression_analysis" title="wikilink">Regression</a>.</strong> SSA is able to extract polynomial and exponential trends. However, unlike regression, SSA does not assume any parametric model which may give significant advantage when an exploratory data analysis is performed with no obvious model in hand (Golyandina et al., 2001, Ch.1).</p>

<p><strong>SSA and <a href="Linear_filters" title="wikilink">Linear Filters</a>.</strong> The reconstruction of the series by SSA can be considered as adaptive linear filtration. If the window length 

<math display="inline" id="Singular_spectrum_analysis:139">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>‚â§</mo>
   <mi>s</mi>
   <mo>‚â§</mo>
   <mi>K</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <ci>L</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\leq s\leq K
  </annotation>
 </semantics>
</math>

 is small, then each eigenvector <span class="LaTeX">$U_i=(u_1, \ldots, u_L)^\mathrm{T}$</span> generates a linear filter of width <span class="LaTeX">$2L-1$</span> for reconstruction of the middle of the series <span class="LaTeX">$\widetilde{x}_s$</span>, <span class="LaTeX">$L\le s\le K$</span>. The filtration is non-causal. However, the so-called Last-point SSA can be used as a causal filter (Golyandina and Zhigljavsky 2013, Sect. 3.9).</p>

<p><strong>SSA and <a href="Density_Estimation" title="wikilink">Density Estimation</a>.</strong> Since SSA can be used as a method of data smoothing it can be used as a method of non-parametric density estimation (Golyandina et al., 2012).</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Multitaper" title="wikilink">Multitaper method</a></li>
<li><a href="Short-time_Fourier_transform" title="wikilink">Short-time Fourier transform</a></li>
<li><a href="Spectral_density_estimation" title="wikilink">Spectral density estimation</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Akaike, H. (1969): "Fitting autoregressive models for prediction, " <em>Ann. Inst. Stat. Math.,</em> 21, 243‚Äì247.</li>
</ul>
<ul>
<li>Allen, M.R., and A.W. Robertson (1996): "Distinguishing modulated oscillations from coloured noise in multivariate datasets", <em>Clim. Dyn.</em>, 12, 775‚Äì-784.</li>
</ul>
<ul>
<li>Allen, M.R. and L.A. Smith (1996) "Monte Carlo SSA: detecting irregular oscillations in the presence of colored noise". <em>Journal of Climate</em>, 9 (12), 3373‚Äì3404.</li>
</ul>
<ul>
<li>Badeau, R., G. Richard, and B. David (2008): "Performance of ESPRIT for Estimating Mixtures of Complex Exponentials Modulated by Polynomials". <em>IEEE Transactions on signal processing</em>, 56(2), 492‚Äì504.</li>
</ul>
<ul>
<li>Barnett, T. P., and K. Hasselmann (1979): "Techniques of linear prediction, with application to oceanic and atmospheric fields in the tropical Pacific, " <em>Rev. Geophys.,</em> 17, 949‚Äì968.</li>
</ul>
<ul>
<li>Bozzo, E., R. Carniel and D. Fasino (2010): "Relationship between singular spectrum analysis and Fourier analysis: Theory and application to the monitoring of volcanic activity", <em>Comput. Math. Appl.</em> 60(3), 812‚Äì820</li>
</ul>
<ul>
<li>Broomhead, D.S., and G.P. King (1986a): "Extracting qualitative dynamics from experimental data", <em>Physica D</em>, 20, 217‚Äì236.</li>
</ul>
<ul>
<li>Broomhead, D.S., and G. P. King (1986b): "On the qualitative analysis of experimental dynamical systems". <em>Nonlinear Phenomena and Chaos</em>, Sarkar S (Ed.), Adam Hilger, Bristol, 113-‚Äì144.</li>
</ul>
<ul>
<li>Colebrook, J. M., (1978): "Continuous plankton records: Zooplankton and environment, Northeast Atlantic and North Sea," <em>Oceanol. Acta</em>, 1, 9‚Äì23.</li>
</ul>
<ul>
<li>Danilov, D. and Zhigljavsky, A. (Eds.) (1997):<a href="http://www.gistatgroup.com/cat/books.html"><em>Principal Components of Time Series: the Caterpillar method</em></a>, University of St. Petersburg Press. (In Russian.)</li>
</ul>
<ul>
<li>Elsner, J.B. and Tsonis, A.A. (1996): <em>Singular Spectrum Analysis. A New Tool in Time Series Analysis</em>, Plenum Press.</li>
</ul>
<ul>
<li>Fraedrich, K. (1986) "Estimating dimensions of weather and climate attractors". <em>J. Atmos. Sci.</em> 43, 419‚Äì432.</li>
</ul>
<ul>
<li>Ghil, M., and R. Vautard (1991): "Interdecadal oscillations and the warming trend in global temperature time series", <em>Nature</em>, 350, 324‚Äì327.</li>
</ul>
<ul>
<li>Ghil, M. and Jiang, N. (1998): "Recent forecast skill for the El Nin ÃÉo/Southern Oscillation ", <em>Geophys. Res. Lett.</em>, 25, 171‚Äì174, 1998.</li>
</ul>
<ul>
<li>Ghil, M., R. M. Allen, M. D. Dettinger, K. Ide, D. Kondrashov, et al. (2002) <a href="http://www.atmos.ucla.edu/tcd/PREPRINTS/2000RG.pdf">"Advanced spectral methods for climatic time series"</a>, <em>Rev. Geophys.</em> 40(1), 3.1‚Äì3.41.</li>
</ul>
<ul>
<li>Golyandina, N., V. Nekrutkin and A. Zhigljavsky (2001): <a href="http://www.amazon.com/dp/1584881941"><em>Analysis of Time Series Structure: SSA and related techniques</em></a>. Chapman and Hall/CRC. ISBN 1-58488-194-1.</li>
</ul>
<ul>
<li>Golyandina, N., and E. Osipov (2007) "The ‚ÄòCaterpillar‚Äô-SSA method for analysis of time series with missing values", <em>J. Stat. Plan. Inference</em> 137(8), 2642‚Äì2653.</li>
</ul>
<ul>
<li>Golyandina, N., A. Pepelyshev and A. Steland (2012): "New approaches to nonparametric density estimation and selection of smoothing parameters", <em>Comput. Stat. Data Anal.</em> 56(7), 2206‚Äì2218.</li>
</ul>
<ul>
<li>Golyandina, N. and D. Stepanov (2005): <a href="http://www.gistatgroup.com/gus/mssa2.pdf">"SSA-based approaches to analysis and forecast of multidimensional time series"</a>. In: <em>Proceedings of the 5th St.Petersburg Workshop on Simulation, June 26-July 2, 2005</em>, St. Petersburg State University, St. Petersburg, pp.¬†293‚Äì298.</li>
</ul>
<ul>
<li>Golyandina, N. and K. Usevich (2010): "2D-extension of Singular Spectrum Analysis: algorithm and elements of theory". In: <em>Matrix Methods: Theory, Algorithms and Applications</em> (Eds. V.Olshevsky and E.Tyrtyshnikov). World Scientific Publishing, 449‚Äì473.</li>
</ul>
<ul>
<li>Golyandina, N., and A. Zhigljavsky (2013) <a href="http://www.amazon.com/dp/3642349129"><em>Singular Spectrum Analysis for time series</em></a>. Springer Briefs in Statistics, Springer, ISBN 978-3-642-34912-6.</li>
</ul>
<ul>
<li>Groth, A., and M. Ghil (2011): "Multivariate singular spectrum analysis and the road to phase synchronization", <em>Phys Rev E</em> 84(3 Pt 2), 036206.</li>
</ul>
<ul>
<li>Harris, T. and H. Yan (2010): "Filtering and frequency interpretations of singular spectrum analysis". <em>Physica D</em> 239, 1958‚Äì1967.</li>
</ul>
<ul>
<li>Hassani, H.and D. Thomakos, (2010): "A Review on Singular Spectrum Analysis for Economic and Financial Time Series". <em>Statistics and Its Interface</em> 3(3), 377-397.</li>
</ul>
<ul>
<li>Hassani, H., A. Soofi and A. Zhigljavsky (2011): "Predicting Daily Exchange Rate with Singular Spectrum Analysis".<em>Nonlinear Analysis: Real World Applications</em> 11, 2023-2034.</li>
</ul>
<ul>
<li>Hassani, H., Z. Xu and A. Zhigljavsky (2011): "Singular spectrum analysis based on the perturbation theory". <em>Nonlinear Analysis: Real World Applications</em> 12 (5), 2752-2766.</li>
</ul>
<ul>
<li>Hassani, H., S. Heravi and A. Zhigljavsky (2012): " Forecasting UK industrial production with multivariate singular spectrum analysis". <em>Journal of Forecasting</em> 10.1002/for.2244</li>
</ul>
<ul>
<li>Hassani, H., A. Zhigljavsky., K. Patterson and A. Soofi (2011): " A comprehensive causality test based on the singular spectrum analysis". In: Illari, P.M., Russo, F., Williamson, J. (eds.) <em>Causality in Science</em>, 1st edn., p.¬†379. Oxford University Press, London.</li>
</ul>
<ul>
<li>Hassani, H., and Mahmoudvand, R. (2013). Multivariate Singular Spectrum Analysis: A General View and New Vector Forecasting Approach;. '' International Journal of Energy and Statistics'' 1(1), 55-83.</li>
</ul>
<ul>
<li>Keppenne, C. L. and M. Ghil (1993): "Adaptive filtering and prediction of noisy multivariate signals: An application to subannual variability in atmospheric angular momentum," <em>Intl. J. Bifurcation &amp; Chaos</em>, 3, 625‚Äì634.</li>
</ul>
<ul>
<li>Kondrashov, D., and M. Ghil (2006): <a href="http://www.nonlin-processes-geophys.net/13/151/2006/npg-13-151-2006.html">"Spatio-temporal filling of missing points in geophysical data sets"</a>, <em>Nonlin. Processes Geophys.</em>, 13, 151‚Äì159.</li>
</ul>
<ul>
<li>Kondrashov, D., Y. Shprits, M. Ghil, 2010: " Gap Filling of Solar Wind Data by Singular Spectrum Analysis," <em>Geophys. Res. Lett</em>, 37, L15101,</li>
</ul>
<ul>
<li>Mohammad, Y., and T. Nishida (2011) "On comparing SSA-based change point discovery algorithms". <em>IEEE SII</em>, 938‚Äì945.</li>
</ul>
<ul>
<li>Moskvina, V., and A. Zhigljavsky (2003) "An algorithm based on singular spectrum analysis for change-point detection". Commun Stat Simul Comput 32, 319‚Äì352.</li>
</ul>
<ul>
<li>Nekrutkin, V. (2010) "Perturbation expansions of signal subspaces for long signals". <em>J. Stat. Interface</em> 3, 297‚Äì319.</li>
</ul>
<ul>
<li>Patterson, K., H. Hassani, S. Heravi and A. Zhigljavsky (2011) "Multivariate singular spectrum analysis for forecasting revisions to real-time data". <em>Journal of Applied Statistics</em> 38 (10), 2183-2211.</li>
</ul>
<ul>
<li>Penland, C., Ghil, M., and Weickmann, K. M. (1991): "Adaptive filtering and maximum entropy spectra, with application to changes in atmospheric angular momentum," <em>J. Geophys. Res.</em>, 96, 22659‚Äì22671.</li>
</ul>
<ul>
<li>Pietil√§, A., M. El-Segaier, R. Vig√°rio and E. Pesonen (2006) "Blind source separation of cardiac murmurs from heart recordings". In: Rosca J, et al. (eds) <em>Independent Component Analysis and Blind Signal Separation, Lecture Notes in Computer Science</em>, vol 3889, Springer, pp 470‚Äì477.</li>
</ul>
<ul>
<li>de Prony, G. (1795) "Essai exp√©rimental et analytique sur les lois de la dilatabilit√© des fluides √©lastiques et sur celles de la force expansive de la vapeur de l‚Äôeau et la vapeur de l‚Äôalkool √† diff√©rentes temp√©ratures". <em>J. de l‚ÄôEcole Polytechnique</em>, 1(2), 24‚Äì76.</li>
</ul>
<ul>
<li>Schoellhamer, D. (2001) "Singular spectrum analysis for time series with missing data". <em>Geophys. Res. Lett.</em> 28(16), 3187‚Äì3190.</li>
</ul>
<ul>
<li>Thomakos, D. (2010) "Median Unbiased Optimal Smoothing and Trend. Extraction". <em>Journal of Modern Applied Statistical Methods</em> 9,144-159.</li>
</ul>
<ul>
<li>Vautard, R., and M. Ghil (1989): "Singular spectrum analysis in nonlinear dynamics, with applications to paleoclimatic time series", <em>Physica D</em>, 35, 395‚Äì424.</li>
</ul>
<ul>
<li>Vautard, R., Yiou, P., and M. Ghil (1992): "Singular-spectrum analysis: A toolkit for short, noisy chaotic signals", <em>Physica D</em>, 58, 95-126.</li>
</ul>
<ul>
<li>Weare, B. C., and J. N. Nasstrom (1982): "Examples of extended empirical orthogonal function analyses," <em>Mon. Weather Rev.</em>, 110, 784‚Äì812.</li>
</ul>
<ul>
<li>Zhigljavsky, A. (Guest Editor) (2010) "Special issue on theory and practice in singular spectrum analysis of time series". <em>Stat. Interface</em> 3(3)</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.atmos.ucla.edu/tcd/ssa">Singular Spectrum Analysis‚ÄìMulti-taper Method (SSA-MTM) Toolkit</a> freeware from UCLA.</li>
<li><a href="http://www.spectraworks.com/web/welcome.html">kSpectra Toolkit for Mac OS X from SpectraWorks.</a></li>
<li><a href="http://www.math.uni-bremen.de/~theodore/ssawiki/">Yet another SSAwiki page.</a></li>
<li><a href="http://www.gistatgroup.com/cat/">Caterpillar-SSA</a> Papers and software from Gistat Group.</li>
<li><a href="http://cran.r-project.org/web/packages/Rssa/index.html">Efficient implementation of SSA in R</a></li>
<li><a href="http://r-forge.r-project.org/projects/simsalabim/">SSA and Phase Synchronisation in R</a></li>
<li><a href="http://www.scribd.com/doc/106788415/Singular-Spectrum-Analysis-Demo-With-VBA">Singular Spectrum Analysis Excel Demo With VBA</a></li>
</ul>

<p>"</p>

<p><a href="Category:Time_series_analysis" title="wikilink">Category:Time series analysis</a> <a href="Category:Signal_processing" title="wikilink">Category:Signal processing</a> <a href="Category:Time_domain_analysis" title="wikilink">Category:Time domain analysis</a></p>
</body>
</html>
