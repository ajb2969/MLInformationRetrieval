   Bidirectional search      Bidirectional search   Bidirectional search is a graph search algorithm that finds a shortest path from an initial vertex to a goal vertex in a directed graph . It runs two simultaneous searches: one forward from the initial state, and one backward from the goal, stopping when the two meet in the middle. The reason for this approach is that in many cases it is faster: for instance, in a simplified model of search problem complexity in which both searches expand a tree with branching factor  b , and the distance from start to goal is d , each of the two searches has complexity O ( b d /2 ) (in Big O notation ), and the sum of these two search times is much less than the O ( b d ) complexity that would result from a single search from the beginning to the goal.  As in A* search, bi-directional search can be guided by a heuristic estimate of the remaining distance to the goal (in the forward tree) or from the start (in the backward tree).  was the first one to design and implement a bi-directional heuristic search algorithm. Andrew Goldberg and others explained the correct termination conditions for the bidirectional version of Dijkstra’s Algorithm . 1  Description  A Bidirectional Heuristic Search is a state space search from some state   s   s   s   to another state   t   t   t   , searching from   s   s   s   to   t   t   t   and from   t   t   t   to   s   s   s   simultaneously (or quasi-simultaneously if done on a sequential machine). It returns a valid list of operators that if applied to   s   s   s   will give us   t   t   t   .  While it may seem as though the operators have to be invertible for the reverse search, it is only necessary to be able to find, given any node   n   n   n   , the set of parent nodes of   n   n   n   such that there exists some valid operator from each of the parent nodes to   n   n   n   . This has often been likened to a one-way street in the route-finding domain: it is not necessary to be able to travel down both directions, but it is necessary when standing at the end of the street to determine the beginning of the street as a possible route.  Similarly, for those edges that have inverse arcs (i.e. arcs going in both directions) it is not necessary that each direction be of equal cost. The reverse search will always use the inverse cost (i.e. the cost of the arc in the forward direction). More formally, if   n   n   n   is a node with parent   p   p   p   , then      k  1    (  p  ,  n  )    =    k  2    (  n  ,  p  )           subscript  k  1    p  n       subscript  k  2    n  p      k_{1}(p,n)=k_{2}(n,p)   , defined as being the cost from   p   p   p   to   n   n   n   .(Auer Kaindl 2004)  Terminology and notation      b   b   b   : the branching factor of a search tree     k   (  n  ,  m  )       k   n  m     k(n,m)   : the cost associated with moving from node   n   n   n   to node   m   m   m        g   (  n  )       g  n    g(n)   : the cost from the root to the node   n   n   n        h   (  n  )       h  n    h(n)   : the heuristic estimate of the distance between the node   n   n   n   and the goal    s   s   s   : the start state    t   t   t   : the goal state (sometimes   g   g   g   , not to be confused with the function)    d   d   d   : the current search direction. By convention,   d   d   d   is equal to 1 for the forward direction and 2 for the backward direction (Kwa 1989)     d  ′     superscript  d  normal-′    d^{\prime}   : the opposite search direction (i.e.     d  ′   =   3  -  d        superscript  d  normal-′     3  d     d^{\prime}=3-d   )     T  R  E   E  d       T  R  E   subscript  E  d     TREE_{d}   : the search tree in direction d. If    d  =  1      d  1    d=1   , the root is   s   s   s   , if    d  =  2      d  2    d=2   , the root is   t   t   t        O  P  E   N  d       O  P  E   subscript  N  d     OPEN_{d}   : the leaves of    T  R  E   E  d       T  R  E   subscript  E  d     TREE_{d}   (sometimes referred to as    F  R  I  N  G   E  d       F  R  I  N  G   subscript  E  d     FRINGE_{d}   ). It is from this set that a node is chosen for expansion. In bidirectional search, these are sometimes called the search 'frontiers' or 'wavefronts', referring to how they appear when a search is represented graphically. In this metaphor, a 'collision' occurs when, during the expansion phase, a node from one wavefront is found to have successors in the opposing wavefront.     C  L  O  S  E   D  d       C  L  O  S  E   subscript  D  d     CLOSED_{d}   : the non-leaf nodes of    T  R  E   E  d       T  R  E   subscript  E  d     TREE_{d}   . This set contains the nodes already visited by the search   Approaches for Bidirectional Heuristic Search  Bidirectional algorithms can be broadly split into three categories: Front-to-Front, Front-to-Back (or Front-to-End), and Perimeter Search (Kaindl Kainz 1997). These differ by the function used to calculate the heuristic.  Front-to-Back  Front-to-Back algorithms calculate the   h   h   h   value of a node   n   n   n   by using the heuristic estimate between   n   n   n   and the root of the opposite search tree,   s   s   s   or   t   t   t   .  Front-to-Back is the most actively researched of the three categories. The current best algorithm (at least in the Fifteen puzzle domain) is the BiMAX-BS*F algorithm, created by Auer and Kaindl (Auer, Kaindl 2004).  Front-to-Front  Front-to-Front algorithms calculate the   h   h   h   value of a node   n   n   n   by using the heuristic estimate between   n   n   n   and some subset of    O  P  E   N  d  ′       O  P  E   superscript   subscript  N  d   normal-′     OPEN_{d}^{\prime}   . The canonical example is that of the BHFFA (Bidirectional Heuristic Front-to-Front Algorithm) (de Champeaux 1977/1983), where the   h   h   h   function is defined as the minimum of all heuristic estimates between the current node and the nodes on the opposing front. Or, formally:        h  d    (  n  )    =    min  i    {   H   (  n  ,   o  i   )    |    o  i   ∈   O  P  E   N   d  ′      }           subscript  h  d   n     subscript   i     H   n   subscript  o  i        subscript  o  i     O  P  E   subscript  N   superscript  d  normal-′         h_{d}(n)=\min_{i}\left\{H(n,o_{i})|o_{i}\in OPEN_{d^{\prime}}\right\}     where    H   (  n  ,  o  )       H   n  o     H(n,o)   returns an admissible (i.e. not overestimating) heuristic estimate of the distance between nodes   n   n   n   and   o   o   o   .  Front-to-Front suffers from being excessively computationally demanding. Every time a node   n   n   n   is put into the open list, its    f  =   g  +  h       f    g  h     f=g+h   value must be calculated. This involves calculating a heuristic estimate from   n   n   n   to every node in the opposing    O  P  E  N      O  P  E  N    OPEN   set, as described above. The    O  P  E  N      O  P  E  N    OPEN   sets increase in size exponentially for all domains with    b  >  1      b  1    b>1   .  References    .   .   .   .   "  Category:Graph algorithms  Category:Search algorithms     Efficient Point-to-Point Shortest Path Algorithms ↩     