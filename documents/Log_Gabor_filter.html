<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1378">Log Gabor filter</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Log Gabor filter</h1>
<hr/>

<p>In signal processing it is useful to simultaneously analyze the space and frequency characteristics of a signal. While the <a href="Fourier_transform" title="wikilink">Fourier transform</a> gives the frequency information of the signal, it is not localized. This means that we cannot determine which part of a (perhaps long) signal produced a particular frequency. It is possible to use a <a href="short_time_Fourier_transform" title="wikilink">short time Fourier transform</a> for this purpose, however the short time Fourier transform limits the basis functions to be sinusoidal. To provide a more flexible space-frequency signal decomposition several filters (including wavelets) have been proposed. The Log-Gabor<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> filter is one such filter that is an improvement upon the original <a href="Gabor_filter" title="wikilink">Gabor filter</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The advantage of this filter over the many alternatives is that it better fits the statistics of natural images compared with <a href="Gabor_filter" title="wikilink">Gabor filters</a> and other <a class="uri" href="wavelet" title="wikilink">wavelet</a> filters.</p>
<h2 id="applications">Applications</h2>

<p>The Log-Gabor filter is able to describe a signal in terms of the local frequency responses. Because this is a fundamental signal analysis technique, it has many applications in signal processing. Indeed any application that uses Gabor filters, or other wavelet basis functions may benefit from the Log-Gabor filter. However there may not be any benefit depending on the particulars of the design problem. Nevertheless, the Log-Gabor filter has been shown to be particularly useful in image processing applications, because it has been shown to better capture the statistics of natural images.</p>

<p>In image processing, there are a few low-level examples of the use of Log-Gabor filters. <a href="Edge_detection" title="wikilink">Edge detection</a> is one such primitive operation, where the edges of the image are labeled. Because edges appear in the frequency domain as high frequencies, it is natural to use a filter such as the Log-Gabor to pick out these edges.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> These detected edges can be used as the input to a segmentation algorithm or a recognition algorithm. A related problem is corner detection. In corner detection the goal is to find points in the image that are corners. Corners are useful to find because they represent stable locations that can be used for image matching problems. The corner can be described in terms of localized frequency information by using a Log-Gabor filter.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>In <a href="pattern_recognition" title="wikilink">pattern recognition</a>, the input image must be transformed into a feature representation that is easier for a classification algorithm to separate classes. Features formed from the response of Log-Gabor filters may form a good set of features for some applications because it can locally represent frequency information. For example the filter has been successfully used in face expression classification.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> There is some evidence that the human visual system processes visual information in a similar way.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>There are a host of other applications that require localized frequency information. The Log-Gabor filter has been used in applications such as image enhancement,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> speech analysis,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> and image denoising <a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> among others.</p>
<h2 id="existing-approaches">Existing Approaches</h2>

<p>There are several existing approaches for computing localized frequency information. These approaches are advantageous because unlike the Fourier transform, these filters can more easily represent discontinuities in the signal. For example, the Fourier transform can represent an edge, but only by using an infinite number of sine waves.</p>
<h3 id="gabor-filters">Gabor filters</h3>

<p>When considering filters that extract local frequency information, there is a relationship between the frequency resolution and the time/space resolution. When more samples are taken the resolution of the frequency information is higher, however the time/space resolution will be lower. Likewise taking only a few samples means a higher spatial/temporal resolution, but this is at the cost of less frequency resolution. A good filter should be able to obtain the maximum frequency resolution given a set time/space resolution, and vice versa. The <a href="Gabor_filter" title="wikilink">Gabor filter</a> achieves this bound.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Because of this, the Gabor filter is a good method for simultaneously localizing spatial/temporal and frequency information. A Gabor filter in the space (or time) domain is formulated as a Gaussian envelope multiplied by a complex exponential. It was found that the cortical responses in the human visual system can be modeled by the Gabor filter.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> The Gabor filter was modified by Morlet to form an orthonormal continuous wavelet transform.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>Although the Gabor filter achieves a sense of optimality in terms of the space-frequency tradeoff, in certain applications it might not be an ideal filter. At certain bandwidths, the Gabor filter has a non-zero DC component. This means that the response of the filter depends on the mean value of the signal. If the output of the filter is to be used for an application such as pattern recognition, this DC component is undesirable because it gives a feature that changes with the average value. As we will soon see, the Log-Gabor filter does not exhibit this problem. Also the original Gabor filter has an infinite length impulse response. Finally, the original Gabor filter, while optimum in the sense of uncertainty, does not properly fit the statistics of natural images. As shown in,<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> it is better to choose a filter with a longer sloping tail in an image coding task.</p>

<p>In certain applications, other decompositions have advantages. Although there are many such decompositions possible, here we briefly present two popular methods: mexican hat wavelets and the steerable pyramid.</p>
<h3 id="mexican-hat-wavelet">Mexican Hat Wavelet</h3>

<p>The Ricker <a class="uri" href="wavelet" title="wikilink">wavelet</a>, commonly called the <a href="mexican_hat_wavelet" title="wikilink">mexican hat wavelet</a> is another type of filter that is used to model data. In multiple dimensions this becomes the <a href="Laplacian_of_a_Gaussian" title="wikilink">Laplacian of a Gaussian</a> function. For reasons of computational complexity, the Laplacian of a Gaussian function is often simplified as a <a href="difference_of_Gaussians" title="wikilink">difference of Gaussians</a>. This difference of Gaussian function has found use in several computer vision applications such as keypoint detection.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> The disadvantage of the Mexican hat wavelet is that it exhibits some aliasing and does not represent oblique orientations well.</p>
<h3 id="steerable-pyramid">Steerable pyramid</h3>

<p>The <a href="steerable_pyramid" title="wikilink">steerable pyramid</a> decomposition <a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> was presented as an alternative to the Morlet (Gabor) and Ricket wavelets. This decomposition ignores the orthogonality constraint of the wavelet formulation, and by doing this is able to construct a set of filters which are both translation and rotation independent. The disadvantage of the steerable pyramid decomposition is that it is overcomplete. This means that more filters than truly necessary are used to describe the signal.</p>
<h2 id="definition">Definition</h2>

<p>Field introduced the Log-Gabor filter and showed that it is able to better encode natural images compared with the original Gabor filter.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> Additionally, the Log-Gabor filter does not have the same DC problem as the original Gabor filter. A one dimensional Log-Gabor function has the frequency response:</p>
<div align="center">

<p>

<math display="inline" id="Log_Gabor_filter:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mrow>
       <mo>-</mo>
       <msup>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mi>log</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>f</mi>
            <mo>/</mo>
            <msub>
             <mi>f</mi>
             <mn>0</mn>
            </msub>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
      <mrow>
       <mn>2</mn>
       <msup>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mi>log</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>σ</mi>
            <mo>/</mo>
            <msub>
             <mi>f</mi>
             <mn>0</mn>
            </msub>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <exp></exp>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <log></log>
         <apply>
          <divide></divide>
          <ci>f</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <cn type="integer">0</cn>
          </apply>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <log></log>
         <apply>
          <divide></divide>
          <ci>σ</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <cn type="integer">0</cn>
          </apply>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(f)=\exp\left(\frac{-\left(\log(f/f_{0})\right)^{2}}{2\left(\log(\sigma/f_{0}%
)\right)^{2}}\right)
  </annotation>
 </semantics>
</math>

</p>
</div>

<p>where 

<math display="inline" id="Log_Gabor_filter:1">
 <semantics>
  <msub>
   <mi>f</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{0}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Log_Gabor_filter:2">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 are the parameters of the filter. 

<math display="inline" id="Log_Gabor_filter:3">
 <semantics>
  <msub>
   <mi>f</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{0}
  </annotation>
 </semantics>
</math>

 will give the center frequency of the filter. 

<math display="inline" id="Log_Gabor_filter:4">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 affects the bandwidth of the filter. It is useful to maintain the same shape while the frequency parameter is varied. To do this, the ratio 

<math display="inline" id="Log_Gabor_filter:5">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>/</mo>
   <msub>
    <mi>f</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>σ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma/f_{0}
  </annotation>
 </semantics>
</math>

 should remain constant. The following figure shows the frequency response of the Gabor compared with the Log-Gabor:</p>

<p><a href="File:Log-vs-gabor.png" title="wikilink">thumb|center|upright=3.0|<strong>Difference in frequency domain between Gabor and Log-Gabor filters.</strong> The Gabor filter has a non-zero response at DC frequency, whereas the Log-Gabor always is zero. Because of this, the Gabor filter tends to over-represents lower frequencies. This is particularly evident in the log domain.</a></p>

<p>Because of the zero at the DC value, it is not possible to derive an analytic expression for the filter in the space domain. In practice the filter is first designed in the frequency domain, and then an inverse Fourier transform gives the time domain impulse response.</p>
<h2 id="dimensional-log-gabor-filter">2-dimensional Log-Gabor filter</h2>

<p>Like the Gabor filter, the log-Gabor filter has seen great popularity in image processing. Because of this it is useful to consider the 2-dimensional extension of the log-Gabor filter. With this added dimension the filter is not only designed for a particular frequency, but also is designed for a particular orientation. The orientation component is a Gaussian distance function according to the angle in polar coordinates (see <a href="http://www.csse.uwa.edu.au/~pk/research/matlabfns/PhaseCongruency/Docs/convexpl.html">1</a>):</p>
<div align="center">

<p>

<math display="inline" id="Log_Gabor_filter:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo>,</mo>
     <mi>θ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mrow>
        <mo>-</mo>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>log</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>f</mi>
             <mo>/</mo>
             <msub>
              <mi>f</mi>
              <mn>0</mn>
             </msub>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mrow>
       <mrow>
        <mn>2</mn>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>log</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <msub>
              <mi>σ</mi>
              <mi>f</mi>
             </msub>
             <mo>/</mo>
             <msub>
              <mi>f</mi>
              <mn>0</mn>
             </msub>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mrow>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mrow>
        <mo>-</mo>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>θ</mi>
           <mo>-</mo>
           <msub>
            <mi>θ</mi>
            <mn>0</mn>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mrow>
       <mrow>
        <mn>2</mn>
        <msubsup>
         <mi>σ</mi>
         <mi>θ</mi>
         <mn>2</mn>
        </msubsup>
       </mrow>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <interval closure="open">
      <ci>f</ci>
      <ci>θ</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <exp></exp>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <log></log>
          <apply>
           <divide></divide>
           <ci>f</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>f</ci>
            <cn type="integer">0</cn>
           </apply>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <log></log>
          <apply>
           <divide></divide>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>σ</ci>
            <ci>f</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>f</ci>
            <cn type="integer">0</cn>
           </apply>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <exp></exp>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <minus></minus>
          <ci>θ</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>θ</ci>
           <cn type="integer">0</cn>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>σ</ci>
          <ci>θ</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(f,\theta)=\exp\left(\frac{-(\log(f/f_{0}))^{2}}{2(\log(\sigma_{f}/f_{0}))^{2%
}}\right)\exp\left(\frac{-(\theta-\theta_{0})^{2}}{2\sigma_{\theta}^{2}}\right)
  </annotation>
 </semantics>
</math>

</p>
</div>

<p>where here there are now four parameters

<math display="block" id="Log_Gabor_filter:7">
 <semantics>
  <msub>
   <mi>f</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{0}
  </annotation>
 </semantics>
</math>

 the center frequency, 

<math display="inline" id="Log_Gabor_filter:8">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{f}
  </annotation>
 </semantics>
</math>

 the width parameter for the frequency, 

<math display="inline" id="Log_Gabor_filter:9">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{0}
  </annotation>
 </semantics>
</math>

 the center orientation, and 

<math display="inline" id="Log_Gabor_filter:10">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>θ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{\theta}
  </annotation>
 </semantics>
</math>

 the width parameter of the orientation. An example of this filter is shown below.</p>
<figure><b>(Figure)</b>
<figcaption><strong>Construction of two-dimensional Log Gabor filter.</strong> The two dimensional filter consists of a component based on frequency (a) and a component based on orientation (b). The two components are combined to form the final component (c).</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption><strong>Difference in spatial domain between Gabor and Log-Gabor filters.</strong> In the spatial domain the response of Gabor and Log-Gabor filters are nearly identical. On the left is the real part and on the right is the imaginary part of the impulse response.</figcaption>
</figure>

<p>The bandwidth in the frequency is given by:</p>
<div align="center">

<p>

<math display="inline" id="Log_Gabor_filter:11">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <msqrt>
     <mrow>
      <mn>2</mn>
      <mo>/</mo>
      <mrow>
       <mi>log</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>2</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msqrt>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mi>log</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>σ</mi>
          <mi>f</mi>
         </msub>
         <mo>/</mo>
         <msub>
          <mi>f</mi>
          <mn>0</mn>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>B</ci>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <root></root>
      <apply>
       <divide></divide>
       <cn type="integer">2</cn>
       <apply>
        <log></log>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <log></log>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>σ</ci>
         <ci>f</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B=2\sqrt{2/\log(2)}\left(\|\log(\sigma_{f}/f_{0})\|\right)
  </annotation>
 </semantics>
</math>

</p>
</div>

<p>The angular bandwidth is given by:</p>
<div align="center">

<p>

<math display="inline" id="Log_Gabor_filter:12">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mi>θ</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <msub>
     <mi>σ</mi>
     <mi>θ</mi>
    </msub>
    <msqrt>
     <mrow>
      <mn>2</mn>
      <mrow>
       <mi>log</mi>
       <mn>2</mn>
      </mrow>
     </mrow>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>θ</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>θ</ci>
     </apply>
     <apply>
      <root></root>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <log></log>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{\theta}=2\sigma_{\theta}\sqrt{2\log 2}
  </annotation>
 </semantics>
</math>

</p>
</div>

<p>In many practical applications, a set of filters are designed to form a <a href="filter_bank" title="wikilink">filter bank</a>. Because the filters do not form a set of orthogonal basis, the design of the filter bank is somewhat of an art and may depend upon the particular task at hand. The necessary parameters that must be chosen are: the minimum and maximum frequencies, the filter bandwidth, the number of orientations, the angular bandwidth, the filter scaling and the number of scales.</p>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.csse.uwa.edu.au/~pk/research/matlabfns/PhaseCongruency/Docs/convexpl.html">2</a></li>
<li><a href="https://pythonhosted.org/LogGabor/">3</a></li>
</ul>

<p>"</p>

<p><a href="Category:Signal_processing" title="wikilink">Category:Signal processing</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">D. J. Field. Relations between the statistics of natural images and the response properties of cortical cells. J. Opt. Soc. Am. A, 1987, pp. 2379-2394.<a href="#fnref1">↩</a></li>
<li id="fn2">D. Gabor. Theory of communication. J. Inst. Electr. Eng. 93, 1946.<a href="#fnref2">↩</a></li>
<li id="fn3">Z. Xiao, C. Guo, Y. Ming, and L. Qiang. Research on log Gabor wavelet and its application in image edge detection. In International Conference on Signal Processing volume 1, pages 592–595 Aug 2002.<a href="#fnref3">↩</a></li>
<li id="fn4">X. Gao, F. Sattar, and R. Venkateswarlu. Multiscale corner detection of gray level images based on log-Gabor wavelet transform. IEEE Transactions on Circuits and Systems for Video Technology, 17(7):868–875, July 2007.<a href="#fnref4">↩</a></li>
<li id="fn5">N. Rose. Facial expression classification using Gabor and log-Gabor filters. In International Conference on Automatic Face and Gesture Recognition (FGR), pages 346–350, April 2006.<a href="#fnref5">↩</a></li>
<li id="fn6">J. G. Daugman. Uncertainty relation for resolution in space, spatial frequency, and orientation optimized by two-dimensional visual cortical filters. Journal of the Optical Society of America, 1985, pp. 1160-9.<a href="#fnref6">↩</a></li>
<li id="fn7">W. Wang, J. Li, F. Huang, and H. Feng. Design and implementation of log-Gabor filter in fingerprint image enhancement. Pattern Recognition Letters, 2008. pp. 301–308.<a href="#fnref7">↩</a></li>
<li id="fn8">L. He, M. Lech, N. Maddage, and N. Allen. Stress and emotion recognition using log-Gabor filter analysis of speech spectrograms. Affective Computing and Intelligent Interaction, 2009, pp. 1-6<a href="#fnref8">↩</a></li>
<li id="fn9">P. Kovesi. Phase preserving denoising of images. The Australian Pattern Recognition Society Conference: DICTA’99, 1999, pp. 212-217.<a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12">Andrew B. Watson. The cortex transform: rapid computation of simulated neural images. Journal of Computer Vision, Graphics, and Image Processing. 1987. pp. 311-327.<a href="#fnref12">↩</a></li>
<li id="fn13">A. Grossmann and J. Morlet. Decomposition of Hardy functions into square integrable wavelets of constant shape. SIAM Journal on Mathe- matical Analysis, 1984, pp. 723-736.<a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15">D. G. Lowe. Distinctive image features from scale-invariant keypoints. International Journal of Computer Vision, 2004, pp. 91-110.<a href="#fnref15">↩</a></li>
<li id="fn16">E. P. Simoncelli and W. T. Freeman. The steerable pyramid: A flexible architecture for multi-scale derivative computation. IEEE Int’l Conf on Image Processing, 1995. pp. 444 - 447<a href="#fnref16">↩</a></li>
<li id="fn17"></li>
</ol>
</section>
</body>
</html>
