   List decoding      List decoding   In computer science , particularly in coding theory , list decoding is an alternative to unique decoding of error-correcting codes for large error rates. The notion was proposed by Elias in the 1950s. The main idea behind list decoding is that the decoding algorithm instead of outputting a single possible message outputs a list of possibilities one of which is correct. This allows for handling a greater number of errors than that allowed by unique decoding.  The unique decoding model in coding theory , which is constrained to output a single valid codeword from the received word could not tolerate greater fraction of errors. This resulted in a gap between the error-correction performance for stochastic noise models (proposed by Shannon ) and the adversarial noise model (considered by Richard Hamming ). Since the mid 90s, significant algorithmic progress by the coding theory community has bridged this gap. Much of this progress is based on a relaxed error-correction model called list decoding, wherein the decoder outputs a list of codewords for worst-case pathological error patterns where the actual transmitted codeword is included in the output list. In case of typical error patterns though, the decoder outputs a unique single codeword, given a received word, which is almost always the case (However, this is not known to be true for all codes). The improvement here is significant in that the error-correction performance doubles. This is because now the decoder is not confined by the half-the-minimum distance barrier. This model is very appealing because having a list of codewords is certainly better than just giving up. The notion of list-decoding has many interesting applications in complexity theory .  The way the channel noise is modeled plays a crucial role in that it governs the rate at which reliable communication is possible. There are two main schools of thought in modeling the channel behavior:   Probabilistic noise model studied by Shannon in which the channel noise is modeled precisely in the sense that the probabilistic behavior of the channel is well known and the probability of occurrence of too many or too few errors is low  Worst-case or adversarial noise model considered by Hamming in which the channel acts as an adversary that arbitrarily corrupts the codeword subject to a bound on the total number of errors.   The highlight of list-decoding is that even under adversarial noise conditions, it is possible to achieve the information-theoretic optimal trade-off between rate and fraction of errors that can be corrected. Hence, in a sense this is like improving the error-correction performance to that possible in case of a weaker, stochastic noise model.  Mathematical formulation  Let   ùíû   ùíû   \mathcal{C}   be a     (  n  ,  k  ,  d  )   q     subscript   n  k  d   q    (n,k,d)_{q}   error-correcting code; in other words,   ùíû   ùíû   \mathcal{C}   is a code of length   n   n   n   , dimension   k   k   k   and minimum distance   d   d   d   over an alphabet   Œ£   normal-Œ£   \Sigma   of size   q   q   q   . The list-decoding problem can now be formulated as follows:  Input: Received word    x  ‚àà   Œ£  n       x   superscript  normal-Œ£  n     x\in\Sigma^{n}   , error bound    e   e   e     Output: A list of all codewords      x  1   ,   x  2   ,  ‚Ä¶  ,   x  m    ‚àà  ùíû        subscript  x  1    subscript  x  2   normal-‚Ä¶   subscript  x  m    ùíû    x_{1},x_{2},\ldots,x_{m}\in\mathcal{C}   whose hamming distance from   x   x   x   is at most   e   e   e   .  Motivation for list decoding  Given a received word   y   y   y   , which is a noisy version of some transmitted codeword   c   c   c   , the decoder tries to output the transmitted codeword by placing its bet on a codeword that is ‚Äúnearest‚Äù to the received word. The Hamming distance between two codewords is used as a metric in finding the nearest codeword, given the received word by the decoder. If   d   d   d   is the minimum Hamming distance of a code   ùíû   ùíû   \mathcal{C}   , then there exists two codewords    c  1     subscript  c  1    c_{1}   and    c  2     subscript  c  2    c_{2}   that differ in exactly   d   d   d   positions. Now, in the case where the received word   y   y   y   is equidistant from the codewords    c  1     subscript  c  1    c_{1}   and    c  2     subscript  c  2    c_{2}   , unambiguous decoding becomes impossible as the decoder cannot decide which one of    c  1     subscript  c  1    c_{1}   and    c  2     subscript  c  2    c_{2}   to output as the original transmitted codeword. As a result, the half-the minimum distance acts as a combinatorial barrier beyond which unambiguous error-correction is impossible, if we only insist on unique decoding. However, received words such as   y   y   y   considered above occur only in the worst-case and if one looks at the way Hamming balls are packed in high-dimensional space, even for error patterns   e   e   e   beyond half-the minimum distance, there is only a single codeword   c   c   c   within Hamming distance   e   e   e   from the received word. This claim has been shown to hold with high probability for a random code picked from a natural ensemble and more so for the case of Reed‚ÄìSolomon codes which is well studied and quite ubiquitous in the real world applications. In fact, Shannon‚Äôs proof of the capacity theorem for q -ary symmetric channels can be viewed in light of the above claim for random codes.  Under the mandate of list-decoding, for worst-case errors, the decoder is allowed to output a small list of codewords. With some context specific or side information, it may be possible to prune the list and recover the original transmitted codeword. Hence, in general, this seems to be a stronger error-recovery model than unique decoding.  List-decoding potential  For a polynomial-time list-decoding algorithm to exist, we need the combinatorial guarantee that any Hamming ball of radius    p  n      p  n    pn   around a received word   r   r   r   (where   p   p   p   is the fraction of errors in terms of the block length   n   n   n   ) has a small number of codewords. This is because the list size itself is clearly a lower bound on the running time of the algorithm. Hence, we require the list size to be a polynomial in the block length   n   n   n   of the code. A combinatorial consequence of this requirement is that it imposes an upper bound on the rate of a code. List decoding promises to meet this upper bound. It has been shown non-constructively that codes of rate   R   R   R   exist that can be list decoded up to a fraction of errors approaching    1  -  R      1  R    1-R   . The quantity    1  -  R      1  R    1-R   is referred to in the literature as the list-decoding capacity. This is a substantial gain compared to the unique decoding model as we now have the potential to correct twice as many errors. Naturally, we need to have at least a fraction   R   R   R   of the transmitted symbols to be correct in order to recover the message. This is an information-theoretic lower bound on the number of correct symbols required to perform decoding and with list decoding, we can potentially achieve this information-theoretic limit. However, to realize this potential, we need explicit codes (codes that can be constructed in polynomial time) and efficient algorithms to perform encoding and decoding.  Definitions of list decoding  ( p , L )-list-decodability  For any error fraction    0  ‚â§  p  ‚â§  1        0  p       1     0\leq p\leq 1   and an integer    L  ‚â•  1      L  1    L\geq 1   , a code    ùíû  ‚äÜ   Œ£  n       ùíû   superscript  normal-Œ£  n     \mathcal{C}\subseteq\Sigma^{n}   is said to be list decodable up to a fraction   p   p   p   of errors with list size at most   L   L   L   . In other words, if for every    y  ‚àà   Œ£  n       y   superscript  normal-Œ£  n     y\in\Sigma^{n}   , the number of codewords    c  ‚àà  C      c  C    c\in C   within Hamming distance    p  n      p  n    pn   from   y   y   y   is at most   L   L   L   , then the code   ùíû   ùíû   \mathcal{C}   is said to be (   p   p   p   ,   L   L   L   )-list-decodable.  Combinatorics of list decoding  The relation between list decodability of a code and other fundamental parameters such as minimum distance and rate have been fairly well studied. It has been shown that every code can be list decoded using small lists beyond half the minimum distance up to a bound called the Johnson radius. This is quite significant because it proves the existence of (   p   p   p   ,   L   L   L   )-list-decodable codes of good rate with a list-decoding radius much larger than    d  /  2      d  2    d/2   . In other words, the Johnson bound rules out the possibility of having a large number of codewords in a Hamming ball of radius slightly greater than    d  /  2      d  2    d/2   which means that it is possible to correct far more errors with list decoding.  List-decoding capacity  Below,      H  q    (  p  )    =    p    log  q    (   q  -  1   )     -   p    log  q   p    -    (   1  -  p   )     log  q    (   1  -  p   )             subscript  H  q   p       p    subscript   q     q  1       p    subscript   q   p        1  p     subscript   q     1  p        {H_{q}}(p)=p{\log_{q}}(q-1)-p{\log_{q}}p-(1-p){\log_{q}}\left({1-p}\right)   is the q-ary entropy function (defined for    q  ‚â•  2      q  2    q\geq 2   ).  Theorem (list-decoding capacity)  Let    0  ‚â§  p  ‚â§   1  -   1  /  q          0  p         1    1  q       0\leq p\leq 1-1/q   ,    œµ  ‚â•  0      œµ  0    \epsilon\geq 0   , and   n   n   n   , then the following two statements hold for large enough block length    R  ‚â§   1  -    H  q    (  p  )    -  œµ       R    1     subscript  H  q   p   œµ     R\leq 1-H_{q}(p)-\epsilon   .  i) If   p   p   p   , then there exists a (    O   (   1  /  œµ   )       O    1  œµ     O(1/\epsilon)   ,    R  ‚â•    1  -    H  q    (  p  )     +  œµ       R      1     subscript  H  q   p    œµ     R\geq 1-H_{q}(p)+\epsilon   )-list decodable code.  ii) If   p   p   p   , then every (   L   L   L   ,    L  =   q   Œ©   (  n  )         L   superscript  q    normal-Œ©  n      L=q^{\Omega(n)}   )-list-decodable code has   q   q   q   .  What this means is that for rates approaching the channel capacity, there exists list decodable codes with polynomial sized lists enabling efficient decoding algorithms whereas for rates exceeding the channel capacity, the list size becomes exponential which rules out the existence of efficient decoding algorithms.  The proof for list-decoding capacity is a significant one in that it exactly matches the capacity of a    q  S   C  p       q  S   subscript  C  p     qSC_{p}   -ary symmetric channel    B  S   C  p       B  S   subscript  C  p     BSC_{p}   . In fact, the term "list-decoding capacity" should actually be read as the capacity of an adversarial channel under list decoding. Also, the proof for list-decoding capacity is an important result that pin points the optimal trade-off between rate of a code and the fraction of errors that can be corrected under list decoding.  Sketch of proof  The idea behind the proof is similar to that of Shannon's proof for capacity of the binary symmetric channel    p   p   p   where a random code is picked and showing that it is (   L   L   L   ,    R  ‚â§   1  -    H  q    (  p  )    -   1  /  L        R    1     subscript  H  q   p     1  L      R\leq 1-H_{q}(p)-1/L   )-list-decodable with high probability as long as the rate   L   L   L   . For rates exceeding the above quantity, it can be shown that the list size    y  ‚àà    [  q  ]   n       y   superscript   delimited-[]  q   n     y\in[q]^{n}   becomes super-polynomially large.  A "bad" event is defined as one in which, given a received word    L  +  1      L  1    L+1   and      m  0   ,  ‚Ä¶  ,   m  L    ‚àà    [  q  ]   k         subscript  m  0   normal-‚Ä¶   subscript  m  L     superscript   delimited-[]  q   k     m_{0},\dots,m_{L}\in[q]^{k}   messages     ùíû   (   m  i   )    ‚àà   B   (  y  ,   p  n   )          ùíû   subscript  m  i      B   y    p  n       \mathcal{C}(m_{i})\in B(y,pn)   , it so happens that    0  ‚â§  i  ‚â§  L        0  i       L     0\leq i\leq L   , for every   p   p   p   where    B   (  y  ,   p  n   )       B   y    p  n      B(y,pn)   is the fraction of errors that we wish to correct and    p  n      p  n    pn   is the Hamming ball of radius   y   y   y   with the received word    ùíû   (   m  i   )       ùíû   subscript  m  i     \mathcal{C}(m_{i})   as the center.  Now, the probability that a codeword     m  i   ‚àà    [  q  ]   k        subscript  m  i    superscript   delimited-[]  q   k     m_{i}\in[q]^{k}   associated with a fixed message    B   (  y  ,   p  n   )       B   y    p  n      B(y,pn)   lies in a Hamming ball      Pr   [    C   (   m  i   )    ‚àà   B   (  y  ,   p  n   )     ]    =     Vol  q    (  y  ,   p  n   )    /   q  n    ‚â§   q   -   n   (   1  -    H  q    (  p  )     )       ,         Pr      C   subscript  m  i      B   y    p  n            subscript  Vol  q    y    p  n      superscript  q  n          superscript  q      n    1     subscript  H  q   p          \Pr[C(m_{i})\in B(y,pn)]=\mathrm{Vol}_{q}(y,pn)/q^{n}\leq q^{-n(1-H_{q}(p))},   is given by      V  o   l  q    (  y  ,   p  n   )       V  o   subscript  l  q    y    p  n      Vol_{q}(y,pn)     where the quantity    p  n      p  n    pn   is the volume of a Hamming ball of radius   y   y   y   with the received word    q    H  q    (  p  )       superscript  q     subscript  H  q   p     q^{H_{q}(p)}   as the center. The inequality in the above relation follows from the upper bound on the volume of a Hamming ball. The quantity   p   p   p   gives a very good estimate on the volume of a Hamming ball of radius     [  q  ]   n     superscript   delimited-[]  q   n    [q]^{n}   centered around any word in    (  y  ,   m  0   ,  ‚Ä¶  ,   m  L   )     y   subscript  m  0   normal-‚Ä¶   subscript  m  L     (y,m_{0},\dots,m_{L})   . Put another way, the volume of a Hamming ball is translation invariant. To continue with the proof sketch, we conjure the union bound in probability theory which tells us that the probability of a bad event happening for a given    q   -   n   (   L  +  1   )    (   1  -    H  q    (  p  )     )        superscript  q      n    L  1     1     subscript  H  q   p        q^{-n(L+1)(1-H_{q}(p))}   is upper bounded by the quantity   1   1   1   .  With the above in mind, the probability of "any" bad event happening can be shown to be less than    y  ‚àà    [  q  ]   n       y   superscript   delimited-[]  q   n     y\in[q]^{n}   . To show this, we work our way over all possible received words   L   L   L   and every possible subset of     [  q  ]   k     superscript   delimited-[]  q   k    [q]^{k}   messages in    y  ‚àà    [  q  ]   n       y   superscript   delimited-[]  q   n     y\in[q]^{n}   .  Now turning to the proof of part (ii), we need to show that there are super-polynomially many codewords around every    |   ùíû  ‚à©   B   (  y  ,   p  n   )     |        ùíû    B   y    p  n        |\mathcal{C}\cap B(y,pn)|   when the rate exceeds the list-decoding capacity. We need to show that    R  ‚â•    1  -    H  q    (  p  )     +  œµ       R      1     subscript  H  q   p    œµ     R\geq 1-H_{q}(p)+\epsilon   is super-polynomially large if the rate    c  ‚àà  ùíû      c  ùíû    c\in\mathcal{C}   . Fix a codeword    y  ‚àà    [  q  ]   n       y   superscript   delimited-[]  q   n     y\in[q]^{n}   . Now, for every     Pr   [   c  ‚àà   B   (  y  ,   p  n   )     ]    =   Pr   [   y  ‚àà   B   (  c  ,   p  n   )     ]         Pr    c    B   y    p  n        Pr    y    B   c    p  n         \Pr[c\in B(y,pn)]=\Pr[y\in B(c,pn)]\,   picked at random, we have     y   y   y     since Hamming balls are translation invariant. From the definition of the volume of a Hamming ball and the fact that     [  q  ]   n     superscript   delimited-[]  q   n    [q]^{n}   is chosen uniformly at random from     Pr   [   c  ‚àà   B   (  y  ,   p  n   )     ]    =   Pr   [   y  ‚àà   B   (  c  ,   p  n   )     ]    =    Vol   (  y  ,   p  n   )    /   q  n    ‚â•    q    -   n   (   1  -    H  q    (  p  )     )     -   o   (  n  )              Pr    c    B   y    p  n        Pr    y    B   c    p  n                Vol   y    p  n      superscript  q  n          superscript  q        n    1     subscript  H  q   p        o  n        \Pr[c\in B(y,pn)]=\Pr[y\in B(c,pn)]=\mathrm{Vol}(y,pn)/q^{n}\geq q^{-n(1-H_{q}%
 (p))-o(n)}\,   we also have      X  c     subscript  X  c    X_{c}     Let us now define an indicator variable      X  c   =   1  if  c   ‚àà   B   (  y  ,   p  n   )     ,         subscript  X  c     1  if  c          B   y    p  n        X_{c}=1\text{ if }c\in B(y,pn),   such that      E   [   |   B   (  y  ,   p  n   )    |   ]       E   delimited-[]      B   y    p  n         \displaystyle E[|B(y,pn)|]     0 otherwise.  Taking the expectation of the volume of a Hamming ball we have      1  -    1  -  Œ¥        1      1  Œ¥      1-\sqrt{1-\delta}     Therefore, by the probabilistic method, we have shown that if the rate exceeds the list-decoding capacity, then the list size becomes super-polynomially large. This completes the proof sketch for the list-decoding capacity.  List-decoding algorithms  In the period from 1995 to 2007, the coding theory community developed progressivly more efficient list-decoding algorithms. Algorithms for Reed‚ÄìSolomon codes that can decode up to the Johnson radius which is   Œ¥   Œ¥   \delta   exist where    Œ¥  =   1  -  R       Œ¥    1  R     \delta=1-R   is the normalised distance or relative distance. However, for Reed-Solomon codes,    1  -   R       1    R     1-\sqrt{R}   which means a fraction    1  -    2  R        1      2  R      1-\sqrt{2R}   of errors can be corrected. Some of the most prominent list-decoding algorithms are the following:   Sudan '95 ‚Äì The first known non-trivial list-decoding algorithm for Reed‚ÄìSolomon codes that achieved efficient list decoding up to    1  -   R       1    R     1-\sqrt{R}   errors developed by Madhu Sudan .    Guruswami‚ÄìSudan '98 ‚Äì An improvement on the above algorithm for list decoding Reed‚ÄìSolomon codes up to    1  -   R       1    R     1-\sqrt{R}   errors by Madhu Sudan and his then doctoral student Venkatesan Guruswami .    Parvaresh‚ÄìVardy '05 ‚Äì In a breakthrough paper, Farzad Parvaresh and Alexander Vardy presented codes that can be list decoded beyond the   R   R   R   radius for low rates    m  ‚â•  1      m  1    m\geq 1   . Their codes are variants of Reed-Solomon codes which are obtained by evaluating   1   1   1   correlated polynomials instead of just    1  -  R  -  œµ      1  R  œµ    1-R-\epsilon   as in the case of usual Reed-Solomon codes.    Guruswami‚ÄìRudra '06 - In yet another breakthrough, Venkatesan Guruswami and Atri Rudra give explicit codes that achieve list-decoding capacity, that is, they can be list decoded up to the radius    œµ  >  0      œµ  0    \epsilon>0   for any     [  n  ,   k  +  1   ]   q     subscript   n    k  1    q    [n,k+1]_{q}   . In other words, this is error-correction with optimal redundancy. This answered a question that had been open for about 50 years. This work has been invited to the Research Highlights section of the Communications of the ACM (which is ‚Äúdevoted to the most important research results published in Computer Science in recent years‚Äù) and was mentioned in an article titled ‚ÄúCoding and Computing Join Forces‚Äù in the Sep 21, 2007 issue of the Science magazine. The codes that they are give are called folded Reed-Solomon codes which are nothing but plain Reed-Solomon codes but viewed as a code over a larger alphabet by careful bundling of codeword symbols.   Because of their ubiquity and the nice algebraic properties they possess, list-decoding algorithms for Reed‚ÄìSolomon codes were a main focus of researchers. The list-decoding problem for Reed‚ÄìSolomon codes can be formulated as follows:  Input : For an    (   Œ±  i   ,   y  i   )      subscript  Œ±  i    subscript  y  i     (\alpha_{i},y_{i})   Reed-Solomon code, we are given the pair    1  ‚â§  i  ‚â§  n        1  i       n     1\leq i\leq n   for    y  i     subscript  y  i    y_{i}   , where   i   i   i   is the    Œ±  i     subscript  Œ±  i    \alpha_{i}   th bit of the received word and the    F  q     subscript  F  q    F_{q}   's are distinct points in the finite field    e  =   n  -  t       e    n  t     e=n-t   and an error parameter     P   (  X  )    ‚àà    F  q    [  X  ]          P  X      subscript  F  q    delimited-[]  X      P(X)\in F_{q}[X]   .  Output : The goal is to find all the polynomials   k   k   k   of degree at most     p   (   Œ±  i   )    =   y  i         p   subscript  Œ±  i     subscript  y  i     p(\alpha_{i})=y_{i}   which is the message length such that   t   t   t   for at least   i   i   i   values of   t   t   t   . Here, we would like to have    Q   (  X  ,  Y  )       Q   X  Y     Q(X,Y)   as small as possible so that greater number of errors can be tolerated.  With the above formulation, the general structure of list-decoding algorithms for Reed-Solomon codes is as follows:  Step 1 : (Interpolation) Find a non-zero bivariate polynomial     Q   (   Œ±  i   ,   y  i   )    =  0        Q    subscript  Œ±  i    subscript  y  i     0    Q(\alpha_{i},y_{i})=0   such that    1  ‚â§  i  ‚â§  n        1  i       n     1\leq i\leq n   for   k   k   k   .  Step 2 : (Root finding/Factorization) Output all degree    p   (  X  )       p  X    p(X)   polynomials    Y  -   p   (  X  )        Y    p  X     Y-p(X)   such that    Q   (  X  ,  Y  )       Q   X  Y     Q(X,Y)   is a factor of     Q   (  X  ,   p   (  X  )    )    =  0        Q   X    p  X     0    Q(X,p(X))=0   i.e.     p   (   Œ±  i   )    =   y  i         p   subscript  Œ±  i     subscript  y  i     p(\alpha_{i})=y_{i}   . For each of these polynomials, check if   t   t   t   for at least    i  ‚àà   [  n  ]       i   delimited-[]  n     i\in[n]   values of    p   (  X  )       p  X    p(X)   . If so, include such a polynomial $p(X)$ in the output list.  Given the fact that bivariate polynomials can be factored efficiently, the above algorithm runs in polynomial time.  Applications in complexity theory and cryptography  Algorithms developed for list decoding of several interesting code families have found interesting applications in computational complexity and the field of cryptography . Following is a sample list of applications outside of coding theory:   Construction of hard-core predicates from one-way permutations .  Predicting witnesses for NP-search problems.  Amplifying hardness of Boolean functions.  Average case hardness of permanent of random matrices.  Extractors and Pseudorandom generators .  Efficient traitor tracing.   External links   A Survey on list decoding by Madhu Sudan  Notes from a course taught by Madhu Sudan  Notes from a course taught by Luca Trevisan  Notes from a course taught by Venkatesan Guruswami  Notes from a course taught by Atri Rudra  P. Elias, "List decoding for noisy channels," Technical Report 335, Research Laboratory of Electronics, MIT, 1957.  P. Elias, "Error-correcting codes for list decoding," IEEE Transactions on Information Theory, vol. 37, pp.¬†5‚Äì12, 1991.  J. M. Wozencraft, "List decoding," Quarterly Progress Report, Research Laboratory of Electronics, MIT, vol. 48, pp.¬†90‚Äì95, 1958.  Venkatesan Guruswami 's PhD thesis  [ http://www.nowpublishers.com/product.aspx?product=TCS&doi; ;=0400000007 Algorithmic Results in List Decoding]  Folded Reed‚ÄìSolomon code   "  Category:Coding theory  Category:Error detection and correction  Category:Computational complexity theory   