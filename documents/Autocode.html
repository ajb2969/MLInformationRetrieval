<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1087">Autocode</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Autocode</h1>
<hr/>

<p><strong>Autocode</strong> is the name of a family of "simplified coding systems", later called <a href="high-level_programming_language" title="wikilink">programming languages</a>, devised in the 1950s and 1960s for a series of <a href="digital_computer" title="wikilink">digital computers</a> at the Universities of <a href="University_of_Manchester" title="wikilink">Manchester</a>, <a href="University_of_Cambridge" title="wikilink">Cambridge</a> and <a href="University_of_London" title="wikilink">London</a>. Autocode was a generic term; the autocodes for different machines were not necessarily closely related as are, for example, the different versions of the single language <a class="uri" href="FORTRAN" title="wikilink">FORTRAN</a>.</p>

<p>In the 1960s, <a href="high-level_programming_languages" title="wikilink">high-level programming languages</a> using a <a class="uri" href="compiler" title="wikilink">compiler</a> were commonly called <strong>autocodes</strong>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Examples of autocodes are <a class="uri" href="COBOL" title="wikilink">COBOL</a> and <a class="uri" href="Fortran" title="wikilink">Fortran</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="glennies-autocode">Glennie's Autocode</h2>

<p>The first autocode and its compiler were developed by <a href="Alick_Glennie" title="wikilink">Alick Glennie</a> in 1952 for the <a href="Manchester_Mark_1" title="wikilink">Mark 1</a> computer at the University of Manchester and is considered by some to be the first <a href="compiler" title="wikilink">compiled</a> programming language. His main goal was to make the programming of Mark 1 machine, known for its particularly abstruse machine code, comprehensible. Although the resulting language was much clearer than the machine code, it was still very machine dependent. <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Below is an example of Glennie's Autocode function which calculates the formula

<math display="block" id="Autocode:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msqrt>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>t</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </msqrt>
    <mo>+</mo>
    <mrow>
     <mn>5</mn>
     <msup>
      <mi>t</mi>
      <mn>3</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <root></root>
      <apply>
       <abs></abs>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">5</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>t</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(t)=\sqrt{|t|}+5t^{3}
  </annotation>
 </semantics>
</math>

. The example omits necessary scaling instruction needed to place integers into variables and assumes that results of multiplication fit into lower accumulator.</p>

<p><code>c@VA t@IC x@½C y@RC z@NC</code><br/>
<code>INTEGERS +5 →c           # Put 5 into c</code><br/>
<code>      →t                 # Load argument from lower accumulator to variable t</code><br/>
<code>   +t     TESTA Z        # Put |t| into lower accumulator</code><br/>
<code>   -t</code><br/>
<code>          ENTRY Z</code><br/>
<code>SUBROUTINE 6 →z          # Run square root subroutine on lower accumulator</code><br/>
<code>                         # value and put the result into z</code><br/>
<code>  +tt →y →x              # Calculate t^3 and put it into x </code><br/>
<code>  +tx →y →x</code><br/>
<code>+z+cx   CLOSE WRITE 1    # Put z + (c * x) into lower accumulator and return</code></p>

<p>User's manual of Glennie's Autocode Compiler mentioned that "the loss of efficiency is no more than 10%". <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Autocode's impact on other Manchester's users programming habits was negligible. It wasn't even mentioned in Brooker's 1958 paper called "The Autocode Programs developed for the Manchester University Computers". This was probably caused by the fact that the language did not try to solve the severe problems plaguing the programmers then: numerical analysis, scaling and two-level storage. Improvement in notation was not considered important enough. <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="mark-1-autocode">Mark 1 Autocode</h2>

<p>The second autocode for the Mark 1 was planned in 1954 and developed by <a href="Tony_Brooker" title="wikilink">R. A. Brooker</a> in 1955 and was called the "Mark 1 Autocode". The language was nearly machine-independent and had floating-point arithmetic, unlike the first one. On the other hand it allowed only one operation per line, offered few mnemonic names and had no way define user subroutines. <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>An example code which loads array of size 11 of floating-point numbers from the input would look like this</p>

<p><code>1     n1 = 1         </code><br/>
<code>     vn1 = I         reads input into v[n[1]]</code><br/>
<code>      n1 = n1 + 1</code><br/>
<code>   j1,11 ≥ n1        jumps to 1 if n[1] ≤ 11</code></p>

<p>Brooker's Autocode removed two main difficulties of Mark 1's programmer: scaling and management of two-level storage. Unlike its predecessor it was heavily used. <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="later-autocodes">Later Autocodes</h2>

<p>Brooker also developed an autocode for the <a href="Ferranti_Mercury" title="wikilink">Ferranti Mercury</a> in the 1950s in conjunction with the University of Manchester. <em>Mercury Autocode</em> had a limited repertoire of <a href="Variable_(programming)" title="wikilink">variables</a> a-z and a'-z' and, in some ways resembled early versions of the later <a href="Dartmouth_BASIC" title="wikilink">Dartmouth BASIC</a> language. It pre-dated <a class="uri" href="ALGOL" title="wikilink">ALGOL</a>, having no concept of <a href="Call_stack" title="wikilink">stacks</a> and hence no <a class="uri" href="recursion" title="wikilink">recursion</a> or <a href="dynamic_memory_allocation" title="wikilink">dynamically-allocated</a> <a href="Array_data_structure" title="wikilink">arrays</a>. In order to overcome the relatively small store size available on Mercury, large programs were written as distinct "chapters", each of which constituted an <a href="Overlay_(programming)" title="wikilink">overlay</a>. Some skill was required to minimise time-consuming transfers of control between chapters. This concept of overlays from <a href="drum_memory" title="wikilink">drum</a> under user control became common until <a href="virtual_memory" title="wikilink">virtual memory</a> became available in later machines. Slightly different dialects of Mercury Autocode were implemented for the <a href="Atlas_Computer_(Manchester)" title="wikilink">Ferranti Atlas</a> (distinct from the later <a href="Atlas_Autocode" title="wikilink">Atlas Autocode</a>) and the <a href="ICT_1301" title="wikilink">ICT 1300</a> and <a href="ICT_1900_series" title="wikilink">1900</a> range.</p>

<p>The version for the <a href="EDSAC" title="wikilink">EDSAC 2</a> was devised by <a href="David_Hartley_(computer_scientist)" title="wikilink">David Hartley</a> of <a href="University_of_Cambridge_Mathematical_Laboratory" title="wikilink">University of Cambridge Mathematical Laboratory</a> in 1961. Known as EDSAC 2 Autocode, it was a straight development from Mercury Autocode adapted for local circumstances, and was noted for its object code optimisation and source-language diagnostics which were advanced for the time. A version was developed for the successor <a href="Titan_(computer)" title="wikilink">Titan</a> (the prototype Atlas 2 computer) as a temporary stop-gap while a more substantially advanced language known as <a href="CPL_(programming_language)" title="wikilink">CPL</a> was being developed. CPL was never completed but did give rise to <a class="uri" href="BCPL" title="wikilink">BCPL</a> (developed by M. Richards), which in turn led to <a href="B_(programming_language)" title="wikilink">B</a> and ultimately <a href="C_(programming_language)" title="wikilink">C</a>. A contemporary but separate thread of development, <a href="Atlas_Autocode" title="wikilink">Atlas Autocode</a> was developed for the University of Manchester <a href="Atlas_Computer_(Manchester)" title="wikilink">Atlas 1</a> machine.</p>
<h2 id="references">References</h2>
<h2 id="sources">Sources</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li>Knuth, Donald E.; Pardo, Luis Trabb (1976). "Early development of programming languages". Stanford University, Computer Science Department.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://ecosse.org/jack/history/autocodes/">The Autocodes: a User's Perspective</a></li>
</ul>

<p>"</p>

<p><a href="Category:Procedural_programming_languages" title="wikilink">Category:Procedural programming languages</a> <a href="Category:University_of_Cambridge_Computer_Laboratory" title="wikilink">Category:University of Cambridge Computer Laboratory</a> <a href="Category:Programming_languages_created_in_the_1950s" title="wikilink">Category:Programming languages created in the 1950s</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">Knuth, p. 42-43<a href="#fnref3">↩</a></li>
<li id="fn4">Knuth, p. 48<a href="#fnref4">↩</a></li>
<li id="fn5">Knuth, p. 48-49<a href="#fnref5">↩</a></li>
<li id="fn6">Knuth, p. 63-64<a href="#fnref6">↩</a></li>
<li id="fn7">Knuth, p. 65<a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
