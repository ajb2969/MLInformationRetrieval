<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="991">Trapdoor function</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Trapdoor function</h1>
<hr/>

<p>A <strong>trapdoor function</strong> is a <a href="function_(mathematics)" title="wikilink">function</a> that is easy to compute in one direction, yet difficult to compute in the opposite direction (finding its <a href="Inverse_function" title="wikilink">inverse</a>) without special information, called the "trapdoor". Trapdoor functions are widely used in <a class="uri" href="cryptography" title="wikilink">cryptography</a>.</p>

<p>In mathematical terms, if <em>f</em> is a trapdoor function, then there exists some secret information <em>y</em>, such that given <em>f</em>(<em>x</em>) and <em>y</em>, it is easy to compute <em>x</em>. Consider a <a class="uri" href="padlock" title="wikilink">padlock</a> and its key. It is trivial to change the padlock from open to closed without using the key, by pushing the shackle into the lock mechanism. Opening the padlock easily, however, requires the key to be used. Here the key is the trapdoor.</p>

<p>An example of a simple mathematical trapdoor is "6895601 is the product of two prime numbers. What are those numbers?" A typical solution would be to try dividing 6895601 by several prime numbers until finding the answer. However, if one is told that 1931 is one of the numbers, one can find the answer by entering "6895601 ÷ 1931" into any calculator. This example is not a sturdy trapdoor function – modern computers can guess all of the possible answers within a second – but this sample problem could be improved by <a href="Integer_factorization" title="wikilink">using the product of two much larger primes</a>.</p>

<p>Trapdoor functions came to prominence in <a class="uri" href="cryptography" title="wikilink">cryptography</a> in the mid-1970s with the publication of <a href="Asymmetric_key_algorithm" title="wikilink">asymmetric (or public-key) encryption</a> techniques by <a href="Whitfield_Diffie" title="wikilink">Diffie</a>, <a href="Martin_Hellman" title="wikilink">Hellman</a>, and <a href="Ralph_Merkle" title="wikilink">Merkle</a>. Indeed,  coined the term. Several function classes have been proposed, and it soon became obvious that trapdoor functions are harder to find than was initially thought. For example, an early suggestion was to use schemes based on the <a href="subset_sum_problem" title="wikilink">subset sum problem</a>. This turned out – rather quickly – to be unsuitable.</p>

<p>, the best known trapdoor function (family) candidates are the <a href="RSA_(algorithm)" title="wikilink">RSA</a> and <a href="Rabin_cryptosystem" title="wikilink">Rabin</a> families of functions. Both are written as exponentiation modulo a composite number, and both are related to the problem of <a href="prime_factorization" title="wikilink">prime factorization</a>.</p>

<p>Functions related to the hardness of the <a href="discrete_logarithm_problem" title="wikilink">discrete logarithm problem</a> (either modulo a prime or in a group defined over an <a href="Elliptic_curve_cryptography" title="wikilink">elliptic curve</a>) are <em>not</em> known to be trapdoor functions, because there is no known "trapdoor" information about the group that enables the efficient computation of discrete logarithms.</p>

<p>A trapdoor in cryptography has the very specific aforementioned meaning and is not to be confused with a <a href="Backdoor_(computing)" title="wikilink">backdoor</a> (these are frequently used interchangeably, which is incorrect). A backdoor is a deliberate mechanism that is added to a cryptographic algorithm (e.g., a key pair generation algorithm, digital signing algorithm, etc.) or operating system, for example, that permits one or more unauthorized parties to bypass or subvert the security of the system in some fashion.</p>
<h2 id="example">Example</h2>

<p>In this example, having the inverse of 

<math display="inline" id="Trapdoor_function:0">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 modulo 

<math display="inline" id="Trapdoor_function:1">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(n)
  </annotation>
 </semantics>
</math>

 is the trapdoor:</p>

<p>

<math display="block" id="Trapdoor_function:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mi>e</mi>
    </msup>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>e</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=x^{e}\mod n
  </annotation>
 </semantics>
</math>

</p>

<p>If the factorization is known, 

<math display="inline" id="Trapdoor_function:3">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(n)
  </annotation>
 </semantics>
</math>

 can be computed, so then the inverse of 

<math display="inline" id="Trapdoor_function:4">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 can be computed, and then given 

<math display="inline" id="Trapdoor_function:5">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 we can find 

<math display="inline" id="Trapdoor_function:6">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="One-way_function" title="wikilink">One-way function</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Theory_of_cryptography" title="wikilink">Category:Theory of cryptography</a> <a class="uri" href="Category:Cryptography" title="wikilink">Category:Cryptography</a> <a href="Category:Cryptographic_primitives" title="wikilink">Category:Cryptographic primitives</a></p>
</body>
</html>
