<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="411">Implementation of mathematics in set theory</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Implementation of mathematics in set theory</h1>
<hr/>

<p>This article examines the implementation of mathematical concepts in <a href="set_theory" title="wikilink">set theory</a>. The implementation of a number of basic mathematical concepts is carried out in parallel in <a class="uri" href="ZFC" title="wikilink">ZFC</a> (the dominant set theory) and in <a href="New_Foundations" title="wikilink">NFU</a>, the version of Quine's <a href="New_Foundations" title="wikilink">New Foundations</a> shown to be consistent by <a href="R._B._Jensen" title="wikilink">R. B. Jensen</a> in 1969 (here understood to include at least axioms of Infinity and Choice).</p>

<p>What is said here applies also to two families of set theories: on the one hand, a range of theories including <a href="Zermelo_set_theory" title="wikilink">Zermelo set theory</a> near the lower end of the scale and going up to ZFC extended with <a href="large_cardinal_property" title="wikilink">large cardinal</a> hypotheses such as "there is a <a href="measurable_cardinal" title="wikilink">measurable cardinal</a>"; and on the other hand a hierarchy of extensions of NFU which is surveyed in the <a href="New_Foundations" title="wikilink">New Foundations</a> article. These correspond to different general views of what the set-theoretical universe is like, and it is the approaches to implementation of mathematical concepts under these two general views that are being compared and contrasted.</p>

<p>It is not the primary aim of this article to say anything about the relative merits of these theories as foundations for mathematics. The reason for the use of two different set theories is to illustrate that multiple approaches to the implementation of mathematics are feasible. Precisely because of this approach, this article is not a source of "official" definitions for any mathematical concept.</p>
<h2 id="preliminaries">Preliminaries</h2>

<p>The following sections carry out certain constructions in the two theories <a class="uri" href="ZFC" title="wikilink">ZFC</a> and <a href="New_Foundations" title="wikilink">NFU</a> and compare the resulting implementations of certain mathematical structures (such as the natural numbers).</p>

<p>Mathematical theories prove theorems (and nothing else). So saying that a theory allows the construction of a certain object means that it is a theorem of that theory that that object exists. This is a statement about a definition of the form "the x such that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:0">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 exists", where 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:1">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 is a formula of our language: the theory proves the existence of "the x such that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:2">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

" just in case it is a theorem that "there is one and only one x such that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:3">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>


". (See <a href="Bertrand_Russell" title="wikilink">Bertrand Russell</a>'s <a href="theory_of_descriptions" title="wikilink">theory of descriptions</a>.) Loosely, the theory "defines" or "constructs" this object in this case. If the statement is not a theorem, the theory cannot show that the object exists; if the statement is provably false in the theory, it proves that the object cannot exist; loosely, the object cannot be constructed.</p>

<p>ZFC and NFU share the language of set theory, so the same formal definitions "the x such that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:4">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

" can be contemplated in the two theories. A specific form of definition in the language of set theory is set-builder notation

<math display="block" id="Implementation_of_mathematics_in_set_theory:5">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>x</mi>
   <mo>∣</mo>
   <mi>ϕ</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <ci>x</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x\mid\phi\}
  </annotation>
 </semantics>
</math>

 means "the set A such that for all x, 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>A</mi>
   </mrow>
   <mo>↔</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <in></in>
     <ci>x</ci>
     <ci>A</ci>
    </apply>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in A\leftrightarrow\phi
  </annotation>
 </semantics>
</math>

" (A cannot be free in 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:7">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

). This notation admits certain conventional extensions

<math display="block" id="Implementation_of_mathematics_in_set_theory:8">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>B</mi>
   </mrow>
   <mo>∣</mo>
   <mi>ϕ</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <in></in>
     <ci>x</ci>
     <ci>B</ci>
    </apply>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x\in B\mid\phi\}
  </annotation>
 </semantics>
</math>

 is synonymous with 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:9">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>x</mi>
   <mo>∣</mo>
   <mrow>
    <mi>x</mi>
    <mo>∈</mo>
    <mrow>
     <mi>B</mi>
     <mo>∧</mo>
     <mi>ϕ</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <ci>x</ci>
    <apply>
     <in></in>
     <ci>x</ci>
     <apply>
      <and></and>
      <ci>B</ci>
      <ci>ϕ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x\mid x\in B\wedge\phi\}
  </annotation>
 </semantics>
</math>

; 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:10">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∣</mo>
   <mi>ϕ</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{f(x_{1},\ldots,x_{n})\mid\phi\}
  </annotation>
 </semantics>
</math>

 is defined as 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:11">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>z</mi>
   <mo>∣</mo>
   <mo>∃</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mpadded width="+1.7pt">
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo>=</mo>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-{</ci>
    <csymbol cd="unknown">z</csymbol>
    <ci>normal-∣</ci>
    <exists></exists>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-,</ci>
    <ci>normal-…</ci>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">z</csymbol>
     <eq></eq>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <ci>normal-…</ci>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-}</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{z\mid\exists x_{1},\ldots,x_{n}\,(z=f(x_{1},\dots,x_{n})\wedge\phi)\}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:12">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{1},\ldots,x_{n})
  </annotation>
 </semantics>
</math>

 is an expression already defined.</p>

<p>Expressions definable in set-builder notation make sense in both ZFC and NFU: it may be that both theories prove that a given definition succeeds, or that neither do (the expression 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:13">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>x</mi>
   <mo>∣</mo>
   <mrow>
    <mi>x</mi>
    <mo>∉</mo>
    <mi>x</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <ci>x</ci>
    <apply>
     <notin></notin>
     <ci>x</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x\mid x\not\in x\}
  </annotation>
 </semantics>
</math>


 fails to refer to anything in <em>any</em> set theory with classical logic; in class theories like <a href="Von_Neumann–Bernays–Gödel_set_theory" title="wikilink">NBG</a> this notation does refer to a class, but it is defined differently), or that one does and the other doesn't. Further, an object defined in the same way in ZFC and NFU may turn out to have different properties in the two theories (or there may be a difference in what can be proved where there is no provable difference between their properties).</p>

<p>Further, set theory imports concepts from other branches of mathematics (in intention, <em>all</em> branches of mathematics). In some cases, there are different ways to import the concepts into ZFC and NFU. For example, the usual definition of the first infinite ordinal 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:14">
 <semantics>
  <mi>ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega
  </annotation>
 </semantics>
</math>

 in ZFC is not suitable for NFU because the object (defined in purely set theoretical language as the set of all finite von Neumann ordinals) cannot be shown to exist in NFU. The usual definition of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:15">
 <semantics>
  <mi>ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega
  </annotation>
 </semantics>
</math>

 in NFU is (in purely set theoretical language) the set of all infinite well-orderings all of whose proper initial segments are finite, an object which can be shown not to exist in ZFC. In the case of such imported objects, there may be different definitions, one for use in ZFC and related theories, and one for use in NFU and related theories. For such "implementations" of imported mathematical concepts to make sense, it is necessary to be able to show that the two parallel interpretations have the expected properties: for example, the implementations of the natural numbers in ZFC and NFU are different, but both are implementations of the same mathematical structure, because both include definitions for all the primitives of Peano arithmetic and satisfy (the translations of) the Peano axioms. It is then possible to compare what happens in the two theories as when only set theoretical language is in use, as long as the definitions appropriate to ZFC are understood to be used in the <a class="uri" href="ZFC" title="wikilink">ZFC</a> context and the definitions appropriate to NFU are understood to be used in the NFU context.</p>

<p>Whatever is proven to exist in a theory clearly provably exists in any extension of that theory; moreover, analysis of the proof that an object exists in a given theory may show that it exists in weaker versions of that theory (one may consider <a href="Zermelo_set_theory" title="wikilink">Zermelo set theory</a> instead of <a class="uri" href="ZFC" title="wikilink">ZFC</a> for much of what is done in this article, for example).</p>
<h2 id="empty-set-singleton-unordered-pairs-and-tuples">Empty set, singleton, unordered pairs and tuples</h2>

<p>These constructions appear first because they are the simplest constructions in set theory, not because they are the first constructions that come to mind in mathematics (though the notion of finite set is certainly fundamental!) Even though NFU also allows the construction of set <a href="Urelement" title="wikilink">ur-elements</a> yet to become members of a set, the <a href="empty_set" title="wikilink">empty set</a> is the unique <em>set</em> with no members:</p>

<p>

<math display="block" id="Implementation_of_mathematics_in_set_theory:16">
 <semantics>
  <mrow>
   <mi mathvariant="normal">∅</mi>
   <mover accent="true">
    <mo>=</mo>
    <mrow>
     <mi>def</mi>
     <mo>.</mo>
    </mrow>
   </mover>
   <mrow>
    <mo>{</mo>
    <mi>x</mi>
    <mo>:</mo>
    <mrow>
     <mi>x</mi>
     <mo>≠</mo>
     <mi>x</mi>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <emptyset></emptyset>
    <apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">def</csymbol>
      <ci>normal-.</ci>
     </cerror>
     <eq></eq>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>x</ci>
     <apply>
      <neq></neq>
      <ci>x</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left.\varnothing\right.\overset{\mathrm{def.}}{=}\left\{x:x\neq x\right\}
  </annotation>
 </semantics>
</math>

 For each object 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:17">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, there is a set 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:18">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>x</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>x</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x\}
  </annotation>
 </semantics>
</math>


 with 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:19">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 as its only element:</p>

<p>

<math display="block" id="Implementation_of_mathematics_in_set_theory:20">
 <semantics>
  <mrow>
   <mrow>
    <mo>{</mo>
    <mi>x</mi>
    <mo>}</mo>
   </mrow>
   <mover accent="true">
    <mo>=</mo>
    <mrow>
     <mi>def</mi>
     <mo>.</mo>
    </mrow>
   </mover>
   <mrow>
    <mo>{</mo>
    <mi>y</mi>
    <mo>:</mo>
    <mrow>
     <mi>y</mi>
     <mo>=</mo>
     <mi>x</mi>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <set>
     <ci>x</ci>
    </set>
    <apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">def</csymbol>
      <ci>normal-.</ci>
     </cerror>
     <eq></eq>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>y</ci>
     <apply>
      <eq></eq>
      <ci>y</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{x\right\}\overset{\mathrm{def.}}{=}\left\{y:y=x\right\}
  </annotation>
 </semantics>
</math>

 For objects 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:21">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:22">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

, there is a set 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:23">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>x</ci>
    <ci>y</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x,y\}
  </annotation>
 </semantics>
</math>


 containing 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:24">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:25">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 as its only elements:</p>

<p>

<math display="block" id="Implementation_of_mathematics_in_set_theory:26">
 <semantics>
  <mrow>
   <mrow>
    <mo>{</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>}</mo>
   </mrow>
   <mover accent="true">
    <mo>=</mo>
    <mrow>
     <mi>def</mi>
     <mo>.</mo>
    </mrow>
   </mover>
   <mrow>
    <mo>{</mo>
    <mi>z</mi>
    <mo>:</mo>
    <mrow>
     <mi>z</mi>
     <mo>=</mo>
     <mrow>
      <mi>x</mi>
      <mo>∨</mo>
      <mi>z</mi>
     </mrow>
     <mo>=</mo>
     <mi>y</mi>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <set>
     <ci>x</ci>
     <ci>y</ci>
    </set>
    <apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">def</csymbol>
      <ci>normal-.</ci>
     </cerror>
     <eq></eq>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>z</ci>
     <apply>
      <and></and>
      <apply>
       <eq></eq>
       <ci>z</ci>
       <apply>
        <or></or>
        <ci>x</ci>
        <ci>z</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <share href="#.cmml">
       </share>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{x,y\right\}\overset{\mathrm{def.}}{=}\left\{z:z=x\vee z=y\right\}
  </annotation>
 </semantics>
</math>

 The union of two sets is defined in the usual way:</p>

<p>

<math display="block" id="Implementation_of_mathematics_in_set_theory:27">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∪</mo>
   <mrow>
    <mi>y</mi>
    <mover accent="true">
     <mo>=</mo>
     <mrow>
      <mi>def</mi>
      <mo>.</mo>
     </mrow>
    </mover>
    <mrow>
     <mo>{</mo>
     <mi>z</mi>
     <mo>:</mo>
     <mrow>
      <mi>z</mi>
      <mo>∈</mo>
      <mrow>
       <mi>x</mi>
       <mo>∨</mo>
       <mi>z</mi>
      </mrow>
      <mo>∈</mo>
      <mi>y</mi>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>x</ci>
    <apply>
     <times></times>
     <ci>y</ci>
     <apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">def</csymbol>
       <ci>normal-.</ci>
      </cerror>
      <eq></eq>
     </apply>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <ci>z</ci>
      <apply>
       <and></and>
       <apply>
        <in></in>
        <ci>z</ci>
        <apply>
         <or></or>
         <ci>x</ci>
         <ci>z</ci>
        </apply>
       </apply>
       <apply>
        <in></in>
        <share href="#.cmml">
        </share>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left.x\cup y\right.\overset{\mathrm{def.}}{=}\left\{z:z\in x\vee z\in y\right\}
  </annotation>
 </semantics>
</math>

 This is a recursive definition of unordered 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:28">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


-tuples for any concrete 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:29">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 (finite sets given as lists of their elements:)</p>

<p>

<math display="block" id="Implementation_of_mathematics_in_set_theory:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>{</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>}</mo>
    </mrow>
    <mover accent="true">
     <mo>=</mo>
     <mrow>
      <mi>def</mi>
      <mo>.</mo>
     </mrow>
    </mover>
    <mrow>
     <mo>{</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>}</mo>
    </mrow>
   </mrow>
   <mo>∪</mo>
   <mrow>
    <mo>{</mo>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <apply>
     <times></times>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </set>
     <apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">def</csymbol>
       <ci>normal-.</ci>
      </cerror>
      <eq></eq>
     </apply>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </set>
    </apply>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{x_{1},\ldots,x_{n},x_{n+1}\right\}\overset{\mathrm{def.}}{=}\left\{x_{1%
},\ldots,x_{n}\right\}\cup\left\{x_{n+1}\right\}
  </annotation>
 </semantics>
</math>

 In <a href="New_Foundations" title="wikilink">NFU</a>, all the set definitions given work by stratified comprehension; in <a class="uri" href="ZFC" title="wikilink">ZFC</a>, the existence of the unordered pair is given by the axiom of Pairing, the existence of the empty set follows by Separation from the existence of any set, and the boolean union of two sets exists by the axioms of Pairing and Union (

<math display="inline" id="Implementation_of_mathematics_in_set_theory:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>∪</mo>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋃</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <union></union>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <union></union>
     <set>
      <ci>x</ci>
      <ci>y</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\cup y=\bigcup\{x,y\}
  </annotation>
 </semantics>
</math>

).</p>
<h2 id="ordered-pair">Ordered pair</h2>

<p>First, consider the <strong>ordered pair</strong>. The reason that this comes first is technical: ordered pairs are needed to implement <a href="Relation_(mathematics)" title="wikilink">relations</a> and <a href="Function_(mathematics)" title="wikilink">functions</a> which are needed to implementat other concepts which may seem to be prior. The first definition of the ordered pair was the definition 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:32">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mover accent="true">
    <mo>=</mo>
    <mo>def</mo>
   </mover>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>x</mi>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">∅</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>y</mi>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
    <apply>
     <ci>def</ci>
     <eq></eq>
    </apply>
    <set>
     <set>
      <set>
       <ci>x</ci>
      </set>
      <emptyset></emptyset>
     </set>
     <set>
      <set>
       <ci>y</ci>
      </set>
     </set>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)\overset{\mathrm{def}}{=}\{\{\{x\},\emptyset\},\{\{y\}\}\}
  </annotation>
 </semantics>
</math>

 proposed by <a href="Norbert_Wiener" title="wikilink">Norbert Wiener</a> in 1914 in the context of the type theory of <a href="Principia_Mathematica" title="wikilink">Principia Mathematica</a>. Wiener observed that this allowed the elimination of types of n-ary relations for 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:33">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>></mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n>1
  </annotation>
 </semantics>
</math>


 from the system of that work. It is more usual now to use the definition 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:34">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mover accent="true">
    <mo>=</mo>
    <mrow>
     <mi>def</mi>
     <mo>.</mo>
    </mrow>
   </mover>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>x</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
    <apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">def</csymbol>
      <ci>normal-.</ci>
     </cerror>
     <eq></eq>
    </apply>
    <set>
     <set>
      <ci>x</ci>
     </set>
     <set>
      <ci>x</ci>
      <ci>y</ci>
     </set>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)\overset{\mathrm{def.}}{=}\{\{x\},\{x,y\}\}
  </annotation>
 </semantics>
</math>

, due to <a href="Kazimierz_Kuratowski" title="wikilink">Kuratowski</a>. Either of these definitions works in either <a class="uri" href="ZFC" title="wikilink">ZFC</a> or <a href="New_Foundations" title="wikilink">NFU</a>. In NFU, the Kuratowski pair has a technical disadvantage: it is two types higher than its projections. It is common to postulate the existence of a type-level ordered pair (a pair 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:35">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>

 which is the same type as its <a href="Projection_(mathematics)" title="wikilink">projections</a>) in NFU. It is convenient to use the Kuratowski pair in both systems until the use of type-level pairs can be formally justified. The internal details of these definitions have nothing to do with their actual mathematical function. For any notion 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:36">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>

 of ordered pair, the things that matter are that it satisfy the defining condition:</p>
<ul>
<li>

<math display="inline" id="Implementation_of_mathematics_in_set_theory:37">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo>,</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≡</mo>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mi>z</mi>
    <mo>∧</mo>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
     <interval closure="open">
      <ci>z</ci>
      <ci>w</ci>
     </interval>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <ci>x</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <and></and>
      <ci>z</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)=(z,w)\equiv x=z\wedge y=w
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>…and that it be reasonably easy to collect ordered pairs into sets.</p>
<h2 id="relations">Relations</h2>

<p><a href="Relation_(mathematics)" title="wikilink">Relations</a> are sets whose members are all <a href="ordered_pair" title="wikilink">ordered pairs</a>. Where possible, a relation 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:38">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>


 (understood as a <a href="binary_predicate" title="wikilink">binary predicate</a>) is implemented as 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:39">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∣</mo>
   <mrow>
    <mi>x</mi>
    <mi>R</mi>
    <mi>y</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>R</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(x,y)\mid xRy\}
  </annotation>
 </semantics>
</math>

 (which may be written as 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:40">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>z</mi>
   <mo>∣</mo>
   <mrow>
    <msub>
     <mi>π</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>R</mi>
    <msub>
     <mi>π</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <ci>z</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>z</ci>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{z\mid\pi_{1}(z)R\pi_{2}(z)\}
  </annotation>
 </semantics>
</math>

). Where 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:41">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is a set of ordered pairs, read 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:42">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mi>R</mi>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>R</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   xRy
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:43">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(x,y\right)\in R
  </annotation>
 </semantics>
</math>


.</p>

<p>In <a class="uri" href="ZFC" title="wikilink">ZFC</a>, some relations (such as the general equality relation or subset relation on sets) are 'too large' to be sets (but may be harmlessly reified as <a href="proper_class" title="wikilink">proper classes</a>). In <a href="New_Foundations" title="wikilink">NFU</a>, some relations (such as the membership relation) are not sets because their definitions are not stratified: in 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:44">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∣</mo>
   <mrow>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>y</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
    <apply>
     <in></in>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(x,y)\mid x\in y\}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:45">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:46">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 would need to have the same type (because they appear as projections of the same pair), but also successive types (because 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:47">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is considered as an element of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:48">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>


).</p>
<h3 id="related-definitions">Related definitions</h3>

<p>Let 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:49">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:50">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 be given <a href="binary_relation" title="wikilink">binary relations</a>. Then the following concepts are useful:</p>

<p>The <strong><a href="inverse_relation" title="wikilink">converse</a></strong> of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:51">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is the relation 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:52">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mrow>
    <mo>(</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo>)</mo>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>x</mi>
    <mi>R</mi>
    <mi>y</mi>
   </mrow>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <interval closure="open">
     <ci>y</ci>
     <ci>x</ci>
    </interval>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>R</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{\left(y,x\right):xRy\right\}
  </annotation>
 </semantics>
</math>

.</p>

<p>The <strong>domain</strong> of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:53">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>


 is the set 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:54">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mi>x</mi>
   <mo>:</mo>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mi>x</mi>
       <mi>R</mi>
       <mi>y</mi>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <ci>x</ci>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>y</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>R</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{x:\exists y\left(xRy\right)\right\}
  </annotation>
 </semantics>
</math>

.</p>

<p>The <strong>range</strong> of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:55">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is the domain of the converse of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:56">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

.</p>

<p>The <strong>field</strong> of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:57">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is the <a href="union_(set_theory)" title="wikilink">union</a> of the domain and range of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:58">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>


.</p>

<p>The <strong><a class="uri" href="preimage" title="wikilink">preimage</a></strong> of a member 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:59">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 of the field of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:60">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is the set 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:61">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mi>y</mi>
   <mo>:</mo>
   <mrow>
    <mi>y</mi>
    <mi>R</mi>
    <mi>x</mi>
   </mrow>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <ci>y</ci>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>R</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{y:yRx\right\}
  </annotation>
 </semantics>
</math>

 (used in the definition of 'well-founded' below.)</p>

<p>The <strong>downward closure</strong> of a member 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:62">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 of the field of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:63">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>


 is the smallest set 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:64">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 containing 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:65">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, and containing each 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:66">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mi>R</mi>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>z</ci>
    <ci>R</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   zRy
  </annotation>
 </semantics>
</math>

 for each 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:67">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>∈</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in D
  </annotation>
 </semantics>
</math>

 (i.e., including the preimage of each of its elements with respect to 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:68">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>


 as a subset.)</p>

<p>The <strong><a href="relation_composition" title="wikilink">relative product</a></strong> 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:69">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo stretchy="false">|</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">R</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">S</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R|S
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:70">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:71">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is the relation 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:72">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mrow>
    <mo>(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>z</mi>
    <mo>)</mo>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>y</mi>
     </mpadded>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mi>x</mi>
        <mi>R</mi>
        <mi>y</mi>
       </mrow>
       <mo>∧</mo>
       <mrow>
        <mi>y</mi>
        <mi>S</mi>
        <mi>z</mi>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <interval closure="open">
     <ci>x</ci>
     <ci>z</ci>
    </interval>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>y</ci>
      <apply>
       <and></and>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>R</ci>
        <ci>y</ci>
       </apply>
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>S</ci>
        <ci>z</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{\left(x,z\right):\exists y\,\left(xRy\wedge ySz\right)\right\}
  </annotation>
 </semantics>
</math>

.</p>

<p>In <a class="uri" href="ZFC" title="wikilink">ZFC</a>, one proves that these notions all generate or apply to sets via the <a class="uri" href="ZFC" title="wikilink">ZFC</a> axioms of <em><a href="axiom_of_union" title="wikilink">union</a></em>, <em><a href="axiom_of_separation" title="wikilink">separation</a></em>, and <em><a href="axiom_of_power_set" title="wikilink">power set</a></em>. In <a href="New_Foundations" title="wikilink">NFU</a>, it is easy to check that these definitions give rise to stratified formulas.</p>

<p>Notice that the range and codomain of a relation are not distinguished: this could be done by representing a relation 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:73">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>


 with codomain 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:74">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:75">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mi>R</mi>
   <mo>,</mo>
   <mi>B</mi>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>R</ci>
    <ci>B</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(R,B\right)
  </annotation>
 </semantics>
</math>

, but our development will not require this.</p>

<p>In <a class="uri" href="ZFC" title="wikilink">ZFC</a>, any relation whose domain is a subset of a set 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:76">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and whose range is a subset of a set 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:77">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 will be a set, since the <a href="cartesian_product" title="wikilink">cartesian product</a> 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:78">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>×</mo>
    <mi>B</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mrow>
     <mo>(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo>)</mo>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mi>a</mi>
     <mo>∈</mo>
     <mrow>
      <mi>A</mi>
      <mo>∧</mo>
      <mi>b</mi>
     </mrow>
     <mo>∈</mo>
     <mi>B</mi>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
     <apply>
      <and></and>
      <apply>
       <in></in>
       <ci>a</ci>
       <apply>
        <and></and>
        <ci>A</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <apply>
       <in></in>
       <share href="#.cmml">
       </share>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\times B=\left\{\left(a,b\right):a\in A\wedge b\in B\right\}
  </annotation>
 </semantics>
</math>


 is a set (being a subclass of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:79">
 <semantics>
  <mrow>
   <mpadded width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒫</mi>
   </mpadded>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mi>A</mi>
     <mo>∪</mo>
     <mi>B</mi>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒫</ci>
    <apply>
     <union></union>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}\!\left(A\cup B\right)
  </annotation>
 </semantics>
</math>

), and <em>Separation</em> provides for the existence of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:80">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>)</mo>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mi>A</mi>
     <mo>×</mo>
     <mi>B</mi>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>x</mi>
    <mi>R</mi>
    <mi>y</mi>
   </mrow>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <in></in>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>R</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{\left(x,y\right)\in A\times B:xRy\right\}
  </annotation>
 </semantics>
</math>

. In <a href="New_Foundations" title="wikilink">NFU</a>, some relations with global scope (such as equality and subset) can be implemented as sets. In NFU, bear in mind that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:81">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:82">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 are three types lower than 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:83">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>


 in 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:84">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mi>R</mi>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>R</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   xRy
  </annotation>
 </semantics>
</math>

 (one type lower if a type-level ordered pair is used).</p>
<h3 id="properties-and-kinds-of-relations">Properties and kinds of relations</h3>

<p>Let 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:85">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 be some <a href="binary_relation" title="wikilink">binary relation</a>. 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:86">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is:</p>
<ul>
<li><strong><a href="Reflexive_relation" title="wikilink">Reflexive</a></strong> if 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:87">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mi>R</mi>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>R</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   xRx
  </annotation>
 </semantics>
</math>

 for every 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:88">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


 in the field of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:89">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li><strong><a href="Symmetric_relation" title="wikilink">Symmetric</a></strong> if 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:90">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mpadded width="+1.7pt">
    <mi>y</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mi>R</mi>
    <mi>y</mi>
    <mo>→</mo>
    <mi>y</mi>
    <mi>R</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">y</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">R</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="unknown">R</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x,y\,(xRy\to yRx)
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li><strong><a href="Transitive_relation" title="wikilink">Transitive</a></strong> if 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:91">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo>,</mo>
   <mpadded width="+1.7pt">
    <mi>z</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mi>R</mi>
    <mi>y</mi>
    <mo>∧</mo>
    <mi>y</mi>
    <mi>R</mi>
    <mi>z</mi>
    <mo>→</mo>
    <mi>x</mi>
    <mi>R</mi>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">z</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">R</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <and></and>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="unknown">R</csymbol>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">R</csymbol>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x,y,z\,(xRy\wedge yRz\rightarrow xRz)
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li><strong><a href="Antisymmetric_relation" title="wikilink">Antisymmetric</a></strong> if 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:92">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mpadded width="+1.7pt">
    <mi>y</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mi>R</mi>
    <mi>y</mi>
    <mo>∧</mo>
    <mi>y</mi>
    <mi>R</mi>
    <mi>x</mi>
    <mo>→</mo>
    <mi>x</mi>
    <mo>=</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">y</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">R</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <and></and>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="unknown">R</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x,y\,(xRy\wedge yRx\rightarrow x=y)
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li><strong><a href="Well-founded_relation" title="wikilink">Well-founded</a></strong> if for every set 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:93">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>


 which meets the field of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:94">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:95">
 <semantics>
  <mrow>
   <mrow>
    <mo lspace="7.5pt">∃</mo>
    <mi>x</mi>
   </mrow>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <exists></exists>
     <ci>x</ci>
    </apply>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \exists x\in S
  </annotation>
 </semantics>
</math>

 whose preimage under 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:96">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 does not meet 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:97">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li><strong>Extensional</strong> if for every 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:98">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>x</ci>
    <ci>y</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,y
  </annotation>
 </semantics>
</math>


 in the field of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:99">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:100">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=y
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:101">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:102">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 have the same preimage under 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:103">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>


.</li>
</ul>

<p>Relations having certain combinations of the above properties have standard names. 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:104">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is:</p>
<ul>
<li>An <strong><a href="equivalence_relation" title="wikilink">equivalence relation</a></strong> if 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:105">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is reflexive, symmetric, and transitive.</li>
</ul>
<ul>
<li>A <strong><a href="partial_order" title="wikilink">partial order</a></strong> if 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:106">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is reflexive, antisymmetric, and transitive.</li>
</ul>
<ul>
<li>A <strong><a href="linear_order" title="wikilink">linear order</a></strong> if 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:107">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is a partial order and for every 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:108">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>x</ci>
    <ci>y</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,y
  </annotation>
 </semantics>
</math>


 in the field of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:109">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

, either 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:110">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mi>R</mi>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>R</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   xRy
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:111">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mi>R</mi>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <ci>R</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   yRx
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li>A <strong><a class="uri" href="well-ordering" title="wikilink">well-ordering</a></strong> if 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:112">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is a linear order and well-founded.</li>
</ul>
<ul>
<li>A <strong>set picture</strong> if 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:113">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>


 is well-founded and extensional, and the field of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:114">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 either equals the downward closure of one of its members (called its <em>top element</em>), or is empty.</li>
</ul>
<h2 id="functions">Functions</h2>

<p>A <a href="function_(set_theory)" title="wikilink">functional relation</a> is a <a href="binary_predicate" title="wikilink">binary predicate</a> 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:115">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:116">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo>,</mo>
   <mpadded width="+1.7pt">
    <mi>z</mi>
   </mpadded>
   <mrow>
    <mo>(</mo>
    <mi>x</mi>
    <mi>F</mi>
    <mi>y</mi>
    <mo>∧</mo>
    <mi>x</mi>
    <mi>F</mi>
    <mi>z</mi>
    <mo>→</mo>
    <mi>y</mi>
    <mo>=</mo>
    <mi>z</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">z</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <and></and>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">y</csymbol>
     <eq></eq>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x,y,z\,\left(xFy\wedge xFz\to y=z\right)
  </annotation>
 </semantics>
</math>

. Such a <a href="Relation_(mathematics)" title="wikilink">relation</a> (<a href="Predicate_(logic)" title="wikilink">predicate</a>) is implemented as a relation (set) exactly as described in the previous section. So the predicate 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:117">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is implemented by the set 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:118">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mrow>
    <mo>(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>)</mo>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>x</mi>
    <mi>F</mi>
    <mi>y</mi>
   </mrow>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>F</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{\left(x,y\right):xFy\right\}
  </annotation>
 </semantics>
</math>


. A set of ordered pairs 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:119">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is a function if and only if 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:120">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo>,</mo>
   <mpadded width="+1.7pt">
    <mi>z</mi>
   </mpadded>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>F</mi>
    <mo>∧</mo>
    <mrow>
     <mo>(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo>)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>F</mi>
    <mo>→</mo>
    <mi>y</mi>
    <mo>=</mo>
    <mi>z</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">z</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">F</csymbol>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">y</csymbol>
     <eq></eq>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x,y,z\,\left(\left(x,y\right)\in F\wedge\left(x,z\right)\in F\to y=z\right)
  </annotation>
 </semantics>
</math>

. It is therefore possible to define this function 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:121">
 <semantics>
  <mrow>
   <mpadded width="-1.7pt">
    <mi>F</mi>
   </mpadded>
   <mrow>
    <mo>(</mo>
    <mi>x</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\!\left(x\right)
  </annotation>
 </semantics>
</math>

 as the unique object 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:122">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:123">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mi>F</mi>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>F</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   xFy
  </annotation>
 </semantics>
</math>


 – i.e.

<math display="block" id="Implementation_of_mathematics_in_set_theory:124">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:125">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

-related to 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:126">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 such that the relation 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:127">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 holds between 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:128">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:129">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 – or as the unique object 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:130">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:131">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(x,y\right)\in F
  </annotation>
 </semantics>
</math>

. The presence in both theories of functional predicates which are not sets makes it useful to allow the notation 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:132">
 <semantics>
  <mrow>
   <mpadded width="-1.7pt">
    <mi>F</mi>
   </mpadded>
   <mrow>
    <mo>(</mo>
    <mi>x</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\!\left(x\right)
  </annotation>
 </semantics>
</math>

 both for sets 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:133">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>


 and for important functional predicates. As long as one does not quantify over functions in the latter sense, all such uses are in principle eliminable.</p>

<p>In <a href="New_Foundations" title="wikilink">NFU</a>, 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:134">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 has the same type as 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:135">
 <semantics>
  <mrow>
   <mpadded width="-1.7pt">
    <mi>F</mi>
   </mpadded>
   <mrow>
    <mo>(</mo>
    <mi>x</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\!\left(x\right)
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:136">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is three types higher than 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:137">
 <semantics>
  <mrow>
   <mpadded width="-1.7pt">
    <mi>F</mi>
   </mpadded>
   <mrow>
    <mo>(</mo>
    <mi>x</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\!\left(x\right)
  </annotation>
 </semantics>
</math>

 (one type higher, if a type-level ordered pair is used). To solve this problem, one could define 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:138">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo>[</mo>
    <mi>A</mi>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\left[A\right]
  </annotation>
 </semantics>
</math>


 as 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:139">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mi>y</mi>
   <mo>:</mo>
   <mo>∃</mo>
   <mpadded width="+1.7pt">
    <mi>x</mi>
   </mpadded>
   <mrow>
    <mo>(</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>A</mi>
    <mo>∧</mo>
    <mi>y</mi>
    <mo>=</mo>
    <mpadded width="-1.7pt">
     <mi>F</mi>
    </mpadded>
    <mrow>
     <mo>(</mo>
     <mi>x</mi>
     <mo>)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-{</ci>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-:</ci>
    <exists></exists>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">A</csymbol>
     <and></and>
     <csymbol cd="unknown">y</csymbol>
     <eq></eq>
     <csymbol cd="unknown">F</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-}</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{y:\exists x\,\left(x\in A\wedge y=F\!\left(x\right)\right)\right\}
  </annotation>
 </semantics>
</math>

 for any set 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:140">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, but this is more conveniently written as 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:141">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mrow>
    <mpadded width="-1.7pt">
     <mi>F</mi>
    </mpadded>
    <mrow>
     <mo>(</mo>
     <mi>x</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>A</mi>
   </mrow>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <in></in>
     <ci>x</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{F\!\left(x\right):x\in A\right\}
  </annotation>
 </semantics>
</math>

. Then, if 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:142">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is a set and 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:143">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>


 is any functional relation, the '<a href="axiom_of_replacement" title="wikilink">axiom of replacement</a>' assures that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:144">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo>[</mo>
    <mi>A</mi>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\left[A\right]
  </annotation>
 </semantics>
</math>

 is a set in <a class="uri" href="ZFC" title="wikilink">ZFC</a>. In NFU, 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:145">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo>[</mo>
    <mi>A</mi>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\left[A\right]
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:146">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 now have the same type, and 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:147">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is two types higher than 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:148">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo>[</mo>
    <mi>A</mi>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\left[A\right]
  </annotation>
 </semantics>
</math>


 (the same type, if a type-level ordered pair is used).</p>

<p>The function 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:149">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="-1.7pt">
     <mi>I</mi>
    </mpadded>
    <mrow>
     <mo>(</mo>
     <mi>x</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>I</ci>
     <ci>x</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I\!\left(x\right)=x
  </annotation>
 </semantics>
</math>

 is not a set in <a class="uri" href="ZFC" title="wikilink">ZFC</a> because it is 'too large.' 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:150">
 <semantics>
  <mrow>
   <mpadded width="-1.7pt">
    <mi>I</mi>
   </mpadded>
   <mrow>
    <mo>(</mo>
    <mi>x</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I\!\left(x\right)
  </annotation>
 </semantics>
</math>

 is, however, a set in NFU. The function (predicate) 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:151">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="-1.7pt">
     <mi>S</mi>
    </mpadded>
    <mrow>
     <mo>(</mo>
     <mi>x</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mi>x</mi>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>x</ci>
    </apply>
    <set>
     <ci>x</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\!\left(x\right)=\left\{x\right\}
  </annotation>
 </semantics>
</math>

 is neither a function nor a set in either theory; in ZFC, this is true because such a set would be too large, and, in NFU, this is true because its definition would not be <a href="Stratified_formula#In_set_theory" title="wikilink">stratified</a>. Moreover, 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:152">
 <semantics>
  <mrow>
   <mpadded width="-1.7pt">
    <mi>S</mi>
   </mpadded>
   <mrow>
    <mo>(</mo>
    <mi>x</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\!\left(x\right)
  </annotation>
 </semantics>
</math>

 can be proved not to exist in NFU (see the resolution of Cantor's paradox in <a href="New_Foundations" title="wikilink">New Foundations</a>.)</p>
<h3 id="operations-on-functions">Operations on functions</h3>

<p>Let 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:153">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:154">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 be arbitrary functions. The <strong><a href="function_composition" title="wikilink">composition</a></strong> of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:155">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:156">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:157">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>∘</mo>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <ci>g</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\circ f
  </annotation>
 </semantics>
</math>

, is defined as the relative product 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:158">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>∣</mo>
   <mi>g</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">g</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\mid g
  </annotation>
 </semantics>
</math>


, but only if this results in a function such that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:159">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>∘</mo>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <ci>g</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\circ f
  </annotation>
 </semantics>
</math>

 is also a function, with 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:160">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>g</mi>
      <mo>∘</mo>
      <mi>f</mi>
     </mrow>
     <mo rspace="0.8pt">)</mo>
    </mrow>
    <mrow>
     <mo>(</mo>
     <mi>x</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="-1.7pt">
     <mi>g</mi>
    </mpadded>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mpadded width="-1.7pt">
       <mi>f</mi>
      </mpadded>
      <mrow>
       <mo>(</mo>
       <mi>x</mi>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <compose></compose>
      <ci>g</ci>
      <ci>f</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(g\circ f\right)\!\left(x\right)=g\!\left(f\!\left(x\right)\right)
  </annotation>
 </semantics>
</math>

, if the range of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:161">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is a subset of the domain of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:162">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

. The <strong><a href="inverse_function" title="wikilink">inverse</a></strong> of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:163">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:164">
 <semantics>
  <mrow>
   <msup>
    <mi>f</mi>
    <mo>(</mo>
   </msup>
   <mo>-</mo>
   <mn>1</mn>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <ci>normal-(</ci>
    </apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\left(}-1\right)
  </annotation>
 </semantics>
</math>

, is defined as the <a href="inverse_relation" title="wikilink">converse</a> of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:165">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 if this is a function. Given any set 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:166">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, the identity function 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:167">
 <semantics>
  <msub>
   <mi>i</mi>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>i</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i_{A}
  </annotation>
 </semantics>
</math>

 is the set 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:168">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mrow>
    <mo>(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo>)</mo>
   </mrow>
   <mo>∣</mo>
   <mrow>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>A</mi>
   </mrow>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <interval closure="open">
     <ci>x</ci>
     <ci>x</ci>
    </interval>
    <apply>
     <in></in>
     <ci>x</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{\left(x,x\right)\mid x\in A\right\}
  </annotation>
 </semantics>
</math>


, and this is a set in both <a class="uri" href="ZFC" title="wikilink">ZFC</a> and <a href="New_Foundations" title="wikilink">NF</a> for different reasons.</p>
<h3 id="special-kinds-of-function">Special kinds of function</h3>

<p>A function is an <strong><a href="Injective_function" title="wikilink">injection</a></strong> and <strong><a href="bijection" title="wikilink">one-to-one</a></strong> if it has an inverse function.</p>

<p>If 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:169">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:170">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 are sets, 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:171">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is a <strong>function from 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:172">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:173">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>


</strong> if 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:174">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is a function whose domain is 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:175">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, and whose range is included in 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:176">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

.</p>

<p>If 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:177">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is a function from 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:178">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>


 to 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:179">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:180">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is a:</p>
<ul>
<li><strong><a href="Injective_function" title="wikilink">Injection</a></strong> from 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:181">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:182">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 if the <a href="image_(mathematics)" title="wikilink">images</a> under 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:183">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>


 of distinct members of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:184">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 are distinct members of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:185">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

.</li>
<li><strong><a class="uri" href="Surjection" title="wikilink">Surjection</a></strong> from 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:186">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:187">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 if the range of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:188">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>


 is 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:189">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

.</li>
<li><strong><a class="uri" href="Bijection" title="wikilink">Bijection</a></strong> from 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:190">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:191">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:192">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is both an injection and a surjection.</li>
</ul>

<p>This terminology adjusts for the fact that a function, as defined above, does not determine its codomain.</p>
<h2 id="size-of-sets">Size of sets</h2>

<p>In both <a class="uri" href="ZFC" title="wikilink">ZFC</a> and <a href="New_Foundations" title="wikilink">NFU</a>, two sets <em>A</em> and <em>B</em> are the same size (or are <strong>equinumerous</strong>) if and only if there is a <a href="Bijective_function" title="wikilink">bijection</a> <em>f</em> from <em>A</em> to <em>B</em>. This can be written as 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:193">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>B</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <ci>A</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A|=|B|
  </annotation>
 </semantics>
</math>


, but note that (for the moment) this expresses a relation between <em>A</em> and <em>B</em> rather than a relation between yet-undefined objects 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:194">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>A</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A|
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:195">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>B</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |B|
  </annotation>
 </semantics>
</math>

. Denote this relation by 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:196">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∼</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\sim B
  </annotation>
 </semantics>
</math>

 in contexts such as the actual definition of the cardinals where even the appearance of presupposing abstract cardinals should be avoided.</p>

<p>Similarly, define 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:197">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>B</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <ci>A</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A|\leq|B|
  </annotation>
 </semantics>
</math>

 as holding if and only if there is an <a href="Injective_function" title="wikilink">injection</a> from <em>A</em> to <em>B</em>.</p>

<p>It is straightforward to show that the relation of equinumerousness is an equivalence relation: equinumerousness of <em>A</em> with <em>A</em> is witnessed by 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:198">
 <semantics>
  <msub>
   <mi>i</mi>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>i</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i_{A}
  </annotation>
 </semantics>
</math>


; if <em>f</em> witnesses 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:199">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>B</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <ci>A</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A|=|B|
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:200">
 <semantics>
  <msup>
   <mi>f</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>f</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{-1}
  </annotation>
 </semantics>
</math>

 witnesses 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:201">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>B</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <ci>B</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |B|=|A|
  </annotation>
 </semantics>
</math>

; if <em>f</em> witnesses 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:202">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>B</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <ci>A</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A|=|B|
  </annotation>
 </semantics>
</math>

 and <em>g</em> witnesses 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:203">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>B</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>C</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <ci>B</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>C</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |B|=|C|
  </annotation>
 </semantics>
</math>


, then 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:204">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>∘</mo>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <ci>g</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\circ f
  </annotation>
 </semantics>
</math>

 witnesses 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:205">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>C</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <ci>A</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>C</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A|=|C|
  </annotation>
 </semantics>
</math>

.</p>

<p>It can be shown that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:206">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>B</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <ci>A</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A|\leq|B|
  </annotation>
 </semantics>
</math>

 is a linear order on abstract cardinals, but not on sets. Reflexivity is obvious and transitivity is proven just as for equinumerousness. The <a href="Cantor–Bernstein–Schroeder_theorem" title="wikilink">Schröder–Bernstein theorem</a>, provable in <a class="uri" href="ZFC" title="wikilink">ZFC</a> and <a href="New_Foundations" title="wikilink">NFU</a> in an entirely standard way, establishes that</p>
<ul>
<li>

<math display="inline" id="Implementation_of_mathematics_in_set_theory:207">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>B</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>B</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>B</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <abs></abs>
      <ci>A</ci>
     </apply>
     <apply>
      <and></and>
      <apply>
       <abs></abs>
       <ci>B</ci>
      </apply>
      <apply>
       <abs></abs>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <abs></abs>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <abs></abs>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <abs></abs>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A|\leq|B|\wedge|B|\leq|A|\rightarrow|A|=|B|
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>(this establishes antisymmetry on cardinals), and</p>
<ul>
<li>

<math display="inline" id="Implementation_of_mathematics_in_set_theory:208">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>B</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>∨</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>B</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <abs></abs>
      <ci>A</ci>
     </apply>
     <apply>
      <or></or>
      <apply>
       <abs></abs>
       <ci>B</ci>
      </apply>
      <apply>
       <abs></abs>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <abs></abs>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A|\leq|B|\vee|B|\leq|A|
  </annotation>
 </semantics>
</math>


</li>
</ul>

<p>follows in a standard way in either theory from the <a href="axiom_of_choice" title="wikilink">axiom of choice</a>.</p>
<h2 id="finite-sets-and-natural-numbers">Finite sets and natural numbers</h2>

<p>Natural numbers can be considered either as finite ordinals or finite cardinals. Here consider them as finite cardinal numbers. This is the first place where a major difference between the implementations in <a class="uri" href="ZFC" title="wikilink">ZFC</a> and <a href="New_Foundations" title="wikilink">NFU</a> becomes evident.</p>

<p>The Axiom of Infinity of ZFC tells us that there is a set <em>A</em> which contains 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:209">
 <semantics>
  <mi mathvariant="normal">∅</mi>
  <annotation-xml encoding="MathML-Content">
   <emptyset></emptyset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \emptyset
  </annotation>
 </semantics>
</math>

 and contains 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:210">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>y</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>y</ci>
    <set>
     <ci>y</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\cup\{y\}
  </annotation>
 </semantics>
</math>

 for each 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:211">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>∈</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in A
  </annotation>
 </semantics>
</math>

. This set <em>A</em> is not uniquely determined (it can be made larger while preserving this closure property): the set <em>N</em> of natural numbers is</p>
<ul>
<li>

<math display="inline" id="Implementation_of_mathematics_in_set_theory:212">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>A</mi>
   <mo>∣</mo>
   <mo>∀</mo>
   <mpadded width="+1.7pt">
    <mi>B</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">∅</mi>
    <mo>∈</mo>
    <mi>B</mi>
    <mo>∧</mo>
    <mo>∀</mo>
    <mpadded width="+1.7pt">
     <mi>y</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>∈</mo>
     <mi>B</mi>
     <mo>→</mo>
     <mi>y</mi>
     <mo>∪</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>y</mi>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo>∈</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-{</ci>
    <csymbol cd="unknown">x</csymbol>
    <in></in>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-∣</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">B</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <emptyset></emptyset>
     <in></in>
     <csymbol cd="unknown">B</csymbol>
     <and></and>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <in></in>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">y</csymbol>
      <union></union>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-{</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-}</ci>
      </cerror>
      <in></in>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-}</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x\in A\mid\forall B\,(\emptyset\in B\wedge\forall y\,(y\in B\rightarrow y%
\cup\{y\}\in B)\rightarrow x\in B)\}
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>which is the intersection of all sets which contain the empty set and are closed under the "successor" operation 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:213">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>↦</mo>
   <mrow>
    <mi>y</mi>
    <mo>∪</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>y</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>y</ci>
    <apply>
     <union></union>
     <ci>y</ci>
     <set>
      <ci>y</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\mapsto y\cup\{y\}
  </annotation>
 </semantics>
</math>


.</p>

<p>In ZFC, a set 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:214">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is finite if and only if there is 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:215">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>∈</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>n</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\in N
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:216">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>n</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <ci>n</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |n|=|A|
  </annotation>
 </semantics>
</math>

: further, define 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:217">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>A</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A|
  </annotation>
 </semantics>
</math>

 as this <em>n</em> for finite <em>A</em>. (It can be proved that no two distinct natural numbers are the same size).</p>

<p>The usual operations of arithmetic can be defined recursively and in a style very similar to that in which the set of natural numbers itself is defined. For example, + (the addition operation on natural numbers) can be defined as the smallest set which contains 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:218">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi mathvariant="normal">∅</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>x</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <interval closure="open">
     <ci>x</ci>
     <emptyset></emptyset>
    </interval>
    <ci>x</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((x,\emptyset),x)
  </annotation>
 </semantics>
</math>


 for each natural number 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:219">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and contains 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:220">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mrow>
     <mi>y</mi>
     <mo>∪</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>y</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>z</mi>
    <mo>∪</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>z</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <interval closure="open">
     <ci>x</ci>
     <apply>
      <union></union>
      <ci>y</ci>
      <set>
       <ci>y</ci>
      </set>
     </apply>
    </interval>
    <apply>
     <union></union>
     <ci>z</ci>
     <set>
      <ci>z</ci>
     </set>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((x,y\cup\{y\}),z\cup\{z\})
  </annotation>
 </semantics>
</math>

 whenever it contains 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:221">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>z</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
    <ci>z</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((x,y),z)
  </annotation>
 </semantics>
</math>

.</p>

<p>In NFU, it is not obvious that this approach can be used, since the successor operation 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:222">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>y</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>y</ci>
    <set>
     <ci>y</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\cup\{y\}
  </annotation>
 </semantics>
</math>

 is unstratified and so the set <em>N</em> as defined above cannot be shown to exist in NFU (it is interesting to note that it is consistent for the set of finite von Neumann ordinals to exist in NFU, but this strengthens the theory, as the existence of this set implies the Axiom of Counting (for which see below or the <a href="New_Foundations" title="wikilink">New Foundations</a> article)).</p>

<p>The standard definition of the natural numbers, which is actually the oldest <a href="set-theoretic_definition_of_natural_numbers" title="wikilink">set-theoretic definition of natural numbers</a>, is as equivalence classes of finite sets under equinumerousness. Essentially the same definition is appropriate to <a href="New_Foundations" title="wikilink">NFU</a> (this is not the usual definition, but the results are the same): define <em>Fin</em>, the set of finite sets, as</p>

<p>

<math display="block" id="Implementation_of_mathematics_in_set_theory:223">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>A</mi>
   <mo>∣</mo>
   <mo>∀</mo>
   <mpadded width="+1.7pt">
    <mi>F</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">∅</mi>
    <mo>∈</mo>
    <mi>F</mi>
    <mo>∧</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mpadded width="+1.7pt">
     <mi>y</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>∈</mo>
     <mi>F</mi>
     <mo>→</mo>
     <mi>x</mi>
     <mo>∪</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>y</mi>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo>∈</mo>
     <mi>F</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>A</mi>
    <mo>∈</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-{</ci>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-∣</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">F</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <emptyset></emptyset>
     <in></in>
     <csymbol cd="unknown">F</csymbol>
     <and></and>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">y</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <in></in>
      <csymbol cd="unknown">F</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">x</csymbol>
      <union></union>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-{</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-}</ci>
      </cerror>
      <in></in>
      <csymbol cd="unknown">F</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">A</csymbol>
     <in></in>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-}</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{A\mid\forall F\,(\emptyset\in F\wedge\forall x,y\,(x\in F\rightarrow x\cup\{%
y\}\in F)\rightarrow A\in F)\}
  </annotation>
 </semantics>
</math>

 For any set 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:224">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∈</mo>
   <mrow>
    <mi>F</mi>
    <mi>i</mi>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>i</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in Fin
  </annotation>
 </semantics>
</math>

, define 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:225">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>A</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A|
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:226">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>B</mi>
   <mo>∣</mo>
   <mrow>
    <mi>A</mi>
    <mo>∼</mo>
    <mi>B</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <ci>B</ci>
    <apply>
     <csymbol cd="latexml">similar-to</csymbol>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{B\mid A\sim B\}
  </annotation>
 </semantics>
</math>

. Define <em>N</em> as the set 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:227">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>∣</mo>
   <mrow>
    <mi>A</mi>
    <mo>∈</mo>
    <mrow>
     <mi>F</mi>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <abs></abs>
     <ci>A</ci>
    </apply>
    <apply>
     <in></in>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>i</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{|A|\mid A\in Fin\}
  </annotation>
 </semantics>
</math>

.</p>

<p>The Axiom of Infinity of NFU can be expressed as 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:228">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>∉</mo>
   <mrow>
    <mi>F</mi>
    <mi>i</mi>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>V</ci>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>i</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\not\in Fin
  </annotation>
 </semantics>
</math>


: this is enough to establish that each natural number has a nonempty successor (the successor of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:229">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>A</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A|
  </annotation>
 </semantics>
</math>

 being 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:230">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mi>A</mi>
    <mo>∪</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>x</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <union></union>
     <ci>A</ci>
     <set>
      <ci>x</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A\cup\{x\}|
  </annotation>
 </semantics>
</math>

 for any 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:231">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∉</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>x</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\not\in A
  </annotation>
 </semantics>
</math>

) which is the hard part of showing that the Peano axioms of arithmetic are satisfied.</p>

<p>The operations of arithmetic can be defined in a style similar to the style given above (using the definition of successor just given). They can also be defined in a natural set theoretical way: if A and B are disjoint finite sets, define |A|+|B| as 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:232">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mi>A</mi>
    <mo>∪</mo>
    <mi>B</mi>
   </mrow>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <union></union>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A\cup B|
  </annotation>
 </semantics>
</math>

. More formally, define <em>m+n</em> for <em>m</em> and <em>n</em> in <em>N</em> as</p>

<p>

<math display="block" id="Implementation_of_mathematics_in_set_theory:233">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>A</mi>
   <mo>∣</mo>
   <mo>∃</mo>
   <mi>B</mi>
   <mo>,</mo>
   <mpadded width="+1.7pt">
    <mi>C</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>∈</mo>
    <mi>m</mi>
    <mo>∧</mo>
    <mi>C</mi>
    <mo>∈</mo>
    <mi>n</mi>
    <mo>∧</mo>
    <mi>B</mi>
    <mo>∩</mo>
    <mi>C</mi>
    <mo>=</mo>
    <mi mathvariant="normal">∅</mi>
    <mo>∧</mo>
    <mi>A</mi>
    <mo>=</mo>
    <mi>B</mi>
    <mo>∪</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-{</ci>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-∣</ci>
    <exists></exists>
    <csymbol cd="unknown">B</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">C</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <in></in>
     <csymbol cd="unknown">m</csymbol>
     <and></and>
     <csymbol cd="unknown">C</csymbol>
     <in></in>
     <csymbol cd="unknown">n</csymbol>
     <and></and>
     <csymbol cd="unknown">B</csymbol>
     <intersect></intersect>
     <csymbol cd="unknown">C</csymbol>
     <eq></eq>
     <emptyset></emptyset>
     <and></and>
     <csymbol cd="unknown">A</csymbol>
     <eq></eq>
     <csymbol cd="unknown">B</csymbol>
     <union></union>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-}</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{A\mid\exists B,C\,(B\in m\wedge C\in n\wedge B\cap C=\emptyset\wedge A=B\cup
C)\}
  </annotation>
 </semantics>
</math>

 (But note that this style of definition is feasible for the ZFC numerals as well, but more circuitous: the form of the <a href="New_Foundations" title="wikilink">NFU</a> definition facilitates set manipulations while the form of the ZFC definition facilitates recursive definitions, but either theory supports either style of definition).</p>

<p>The two implementations are quite different. In ZFC, choose a representative of each finite cardinality (the equivalence classes themselves are too large to be sets); in NFU the equivalence classes themselves are sets, and are thus an obvious choice for objects to stand in for the cardinalities. However, the arithmetic of the two theories is identical: the same abstraction is implemented by these two superficially different approaches.</p>
<h2 id="equivalence-relations-and-partitions">Equivalence relations and partitions</h2>

<p>A general technique for implementing abstractions in set theory is the use of equivalence classes. If an equivalence relation <em>R</em> tells us that elements of its field <em>A</em> are alike in some particular respect, then for any set <em>x</em>, regard the set 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:234">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>R</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>y</mi>
     <mo>∈</mo>
     <mi>A</mi>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <mi>x</mi>
     <mi>R</mi>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>x</ci>
     </apply>
     <ci>R</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>y</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>R</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x]_{R}=\{y\in A\mid xRy\}
  </annotation>
 </semantics>
</math>

 as representing an abstraction from the set <em>x</em> respecting just those features (identify elements of <em>A</em> <a href="up_to" title="wikilink">up to</a> <em>R</em>).</p>

<p>For any set <em>A</em>, a set 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:235">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is a <strong>partition</strong> of <em>A</em> if all elements of <em>P</em> are nonempty, any two distinct elements of <em>P</em> are disjoint, and 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:236">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋃</mo>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <union></union>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\bigcup P
  </annotation>
 </semantics>
</math>

.</p>

<p>For every equivalence relation <em>R</em> with field <em>A</em>, 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:237">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>R</mi>
   </msub>
   <mo>∣</mo>
   <mrow>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>A</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>x</ci>
     </apply>
     <ci>R</ci>
    </apply>
    <apply>
     <in></in>
     <ci>x</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{[x]_{R}\mid x\in A\}
  </annotation>
 </semantics>
</math>

 is a partition of <em>A</em>. Moreover, each partition <em>P</em> of <em>A</em> determines an equivalence relation 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:238">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∣</mo>
   <mo>∃</mo>
   <mi>A</mi>
   <mo>∈</mo>
   <mpadded width="+1.7pt">
    <mi>P</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>A</mi>
    <mo>∧</mo>
    <mi>y</mi>
    <mo>∈</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-{</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-∣</ci>
    <exists></exists>
    <csymbol cd="unknown">A</csymbol>
    <in></in>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">A</csymbol>
     <and></and>
     <csymbol cd="unknown">y</csymbol>
     <in></in>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-}</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(x,y)\mid\exists A\in P\,(x\in A\wedge y\in A)\}
  </annotation>
 </semantics>
</math>


.</p>

<p>This technique has limitations in both <a class="uri" href="ZFC" title="wikilink">ZFC</a> and <a href="New_Foundations" title="wikilink">NFU</a>. In ZFC, since the universe is not a set, it seems possible to abstract features only from elements of small domains. This can be circumvented using a trick due to <a href="Dana_Scott" title="wikilink">Dana Scott</a>: if <em>R</em> is an equivalence relation on the universe, define 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:239">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>R</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>x</ci>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x]_{R}
  </annotation>
 </semantics>
</math>

 as the set of all <em>y</em> such that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:240">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mi>R</mi>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <ci>R</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   yRx
  </annotation>
 </semantics>
</math>

 and the <a href="rank_(set_theory)" title="wikilink">rank</a> of <em>y</em> is less than or equal to the rank of any 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:241">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mi>R</mi>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>z</ci>
    <ci>R</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   zRx
  </annotation>
 </semantics>
</math>

. This works because the ranks are sets. Of course, there still may be a proper class of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:242">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>R</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>x</ci>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x]_{R}
  </annotation>
 </semantics>
</math>

's. In NFU, the main difficulty is that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:243">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>R</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>x</ci>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x]_{R}
  </annotation>
 </semantics>
</math>


 is one type higher than x, so for example the "map" 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:244">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>↦</mo>
   <msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>R</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>x</ci>
     </apply>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\mapsto[x]_{R}
  </annotation>
 </semantics>
</math>

 is not in general a (set) function (though 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:245">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>↦</mo>
   <msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>R</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <set>
     <ci>x</ci>
    </set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>x</ci>
     </apply>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x\}\mapsto[x]_{R}
  </annotation>
 </semantics>
</math>

 is a set). This can be circumvented by the use of the Axiom of Choice to select a representative from each equivalence class to replace 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:246">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>R</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>x</ci>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x]_{R}
  </annotation>
 </semantics>
</math>

, which will be at the same type as <em>x</em>, or by choosing a canonical representative if there is a way to do this without invoking Choice (the use of representatives is hardly unknown in ZFC, either). In NFU, the use of equivalence class constructions to abstract properties of general sets is more common, as for example in the definitions of cardinal and ordinal number below.</p>
<h2 id="ordinal-numbers">Ordinal numbers</h2>

<p>Two well-orderings 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:247">
 <semantics>
  <msub>
   <mi>W</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:248">
 <semantics>
  <msub>
   <mi>W</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{2}
  </annotation>
 </semantics>
</math>


 are <strong>similar</strong> and write 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:249">
 <semantics>
  <mrow>
   <msub>
    <mi>W</mi>
    <mn>1</mn>
   </msub>
   <mo>∼</mo>
   <msub>
    <mi>W</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{1}\sim W_{2}
  </annotation>
 </semantics>
</math>

 just in case there is a bijection <em>f</em> from the field of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:250">
 <semantics>
  <msub>
   <mi>W</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{1}
  </annotation>
 </semantics>
</math>

 to the field of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:251">
 <semantics>
  <msub>
   <mi>W</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{2}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:252">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <msub>
     <mi>W</mi>
     <mn>1</mn>
    </msub>
    <mi>y</mi>
   </mrow>
   <mo>↔</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>W</mi>
     <mn>2</mn>
    </msub>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <times></times>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>f</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   xW_{1}y\leftrightarrow f(x)W_{2}f(y)
  </annotation>
 </semantics>
</math>

 for all <em>x</em> and <em>y</em>.</p>

<p>Similarity is shown to be an equivalence relation in much the same way that equinumerousness was shown to be an equivalence relation above.</p>

<p>In <a href="New_Foundations" title="wikilink">New Foundations</a> (NFU), the <strong>order type</strong> of a well-ordering <em>W</em> is the set of all well-orderings which are similar to <em>W</em>. The set of <strong>ordinal numbers</strong> is the set of all order types of well-orderings.</p>

<p>This does not work in <a class="uri" href="ZFC" title="wikilink">ZFC</a>, because the equivalence classes are too large. It would be formally possible to use <a href="Scott's_trick" title="wikilink">Scott's trick</a> to define the ordinals in essentially the same way, but a device of <a href="von_Neumann" title="wikilink">von Neumann</a> is more commonly used.</p>

<p>For any partial order 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:253">
 <semantics>
  <mo>≤</mo>
  <annotation-xml encoding="MathML-Content">
   <leq></leq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq
  </annotation>
 </semantics>
</math>


, the corresponding <strong>strict partial order</strong> \{(x,y) \mid x \leq y \wedge x \neq y\}. Strict linear orders and strict well-orderings are defined similarly.</p>

<p>A set <em>A</em> is said to be <strong>transitive</strong> if 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:254">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋃</mo>
    <mi>A</mi>
   </mrow>
   <mo>⊆</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <union></union>
     <ci>A</ci>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigcup A\subseteq A
  </annotation>
 </semantics>
</math>

: each element of an element of <em>A</em> is also an element of <em>A</em>. A <strong>(von Neumann) ordinal</strong> is a transitive set on which membership is a strict well-ordering.</p>

<p>In ZFC, the order type of a well-ordering <em>W</em> is then defined as the unique von Neumann ordinal which is equinumerous with the field of <em>W</em> and membership on which is isomorphic to the strict well-ordering associated with <em>W</em>. (the equinumerousness condition distinguishes between well-orderings with fields of size 0 and 1, whose associated strict well-orderings are indistinguishable).</p>

<p>In ZFC there cannot be a set of all ordinals. In fact, the von Neumann ordinals are an inconsistent totality in any set theory: it can be shown with modest set theoretical assumptions that every element of a von Neumann ordinal is a von Neumann ordinal and the von Neumann ordinals are strictly well-ordered by membership. It follows that the class of von Neumann ordinals would be a von Neumann ordinal if it were a set: but it would then be an element of itself, which contradicts the fact that membership is a strict well-ordering of the von Neumann ordinals.</p>

<p>The existence of order types for all well-orderings is not a theorem of <a href="Zermelo_set_theory" title="wikilink">Zermelo set theory</a>: it requires the <a href="Axiom_of_replacement" title="wikilink">Axiom of replacement</a>. Even Scott's trick cannot be used in Zermelo set theory without an additional assumption (such as the assumption that every set belongs to a <a href="rank_(set_theory)" title="wikilink">rank</a> which is a set, which does not essentially strengthen Zermelo set theory but is not a theorem of that theory).</p>

<p>In NFU, the collection of all ordinals is a set by stratified comprehension. The Burali-Forti paradox is evaded in an unexpected way. There is a natural order on the ordinals defined by 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:255">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>≤</mo>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>α</ci>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\leq\beta
  </annotation>
 </semantics>
</math>

 if and only if some (and so any) 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:256">
 <semantics>
  <mrow>
   <msub>
    <mi>W</mi>
    <mn>1</mn>
   </msub>
   <mo>∈</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{1}\in\alpha
  </annotation>
 </semantics>
</math>

 is similar to an initial segment of some (and so any) 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:257">
 <semantics>
  <mrow>
   <msub>
    <mi>W</mi>
    <mn>2</mn>
   </msub>
   <mo>∈</mo>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{2}\in\beta
  </annotation>
 </semantics>
</math>

. Further, it can be shown that this natural order is a well-ordering of the ordinals and so must have an order type 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:258">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>


. It would seem that the order type of the ordinals less than 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:259">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 with the natural order would be 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:260">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

, contradicting the fact that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:261">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 is the order type of the entire natural order on the ordinals (and so not of any of its proper initial segments). But this relies on one's intuition (correct in ZFC) that the order type of the natural order on the ordinals less than 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:262">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:263">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>


 for any ordinal 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:264">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

. This assertion is unstratified, because the type of the second 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:265">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is four higher than the type of the first (two higher if a type level pair is used). The assertion which is true and provable in NFU is that the order type of the natural order on the ordinals less than 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:266">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:267">
 <semantics>
  <mrow>
   <msup>
    <mi>T</mi>
    <mn>4</mn>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <cn type="integer">4</cn>
    </apply>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{4}(\alpha)
  </annotation>
 </semantics>
</math>

 for any ordinal 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:268">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>


, where 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:269">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(\alpha)
  </annotation>
 </semantics>
</math>

 is the order type of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:270">
 <semantics>
  <mrow>
   <msup>
    <mi>W</mi>
    <mi>ι</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>x</mi>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>y</mi>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <mi>x</mi>
     <mi>W</mi>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>W</ci>
     <ci>ι</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <interval closure="open">
      <set>
       <ci>x</ci>
      </set>
      <set>
       <ci>y</ci>
      </set>
     </interval>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>W</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{\iota}=\{(\{x\},\{y\})\mid xWy\}
  </annotation>
 </semantics>
</math>

 for any 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:271">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mo>∈</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>W</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W\in\alpha
  </annotation>
 </semantics>
</math>

 (it is easy to show that this does not depend on the choice of W; note that T raises type by one). Thus the order type of the ordinals less than 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:272">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 with the natural order is 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:273">
 <semantics>
  <mrow>
   <msup>
    <mi>T</mi>
    <mn>4</mn>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Ω</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <cn type="integer">4</cn>
    </apply>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{4}(\Omega)
  </annotation>
 </semantics>
</math>


, and 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:274">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>T</mi>
     <mn>4</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">Ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <cn type="integer">4</cn>
     </apply>
     <ci>normal-Ω</ci>
    </apply>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{4}(\Omega)<\Omega
  </annotation>
 </semantics>
</math>

. All uses of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:275">
 <semantics>
  <msup>
   <mi>T</mi>
   <mn>4</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>T</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{4}
  </annotation>
 </semantics>
</math>

 here can be replaced with 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:276">
 <semantics>
  <msup>
   <mi>T</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>T</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{2}
  </annotation>
 </semantics>
</math>

 if a type-level pair is used.</p>

<p>This shows that the T operation is nontrivial, which has a number of consequences. It follows immediately that the singleton map 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:277">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>↦</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>x</ci>
    <set>
     <ci>x</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\mapsto\{x\}
  </annotation>
 </semantics>
</math>

 is not a set, as otherwise restrictions of this map would establish the similarity of <em>W</em> and 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:278">
 <semantics>
  <msup>
   <mi>W</mi>
   <mi>ι</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>W</ci>
    <ci>ι</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{\iota}
  </annotation>
 </semantics>
</math>


 for any well-ordering <em>W</em>. T is (externally) bijective and order-preserving. Because of this, the fact 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:279">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>T</mi>
     <mn>4</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">Ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <cn type="integer">4</cn>
     </apply>
     <ci>normal-Ω</ci>
    </apply>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{4}(\Omega)<\Omega
  </annotation>
 </semantics>
</math>

 establishes that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:280">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mo>></mo>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">Ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mrow>
    <msup>
     <mi>T</mi>
     <mn>2</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">Ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">…</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <gt></gt>
     <ci>normal-Ω</ci>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>normal-Ω</ci>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>T</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-Ω</ci>
      <ci>normal-…</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega>T(\Omega)>T^{2}(\Omega)\ldots
  </annotation>
 </semantics>
</math>

 is a "descending sequence" in the ordinals which cannot be a set.</p>

<p>Ordinals fixed by T are called <strong>Cantorian</strong> ordinals, and ordinals which dominate only cantorian ordinals (which are easily shown to be cantorian themselves) are said to be <strong>strongly cantorian</strong>. There can be no set of cantorian ordinals or set of strongly cantorian ordinals.</p>
<h3 id="digression-von-neumann-ordinals-in-nfu">Digression: von Neumann ordinals in NFU</h3>

<p>It is possible to reason about von Neumann ordinals in <a href="New_Foundations" title="wikilink">NFU</a>. Recall that a von Neumann ordinal is a transitive set <em>A</em> such that the restriction of membership to <em>A</em> is a strict well-ordering. This is quite a strong condition in the NFU context, since the membership relation involves a difference of type. A von Neumann ordinal <em>A</em> is not an ordinal in the sense of NFU, but 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:281">
 <semantics>
  <mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">⌈</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <in></in>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⌈</ci>
     <csymbol cd="unknown">A</csymbol>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in\lceil A
  </annotation>
 </semantics>
</math>

 belongs to an ordinal 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:282">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 which may be termed the order type of (membership on) <em>A</em>. It is easy to show that the order type of a von Neumann ordinal <em>A</em> is cantorian: for any well-ordering <em>W</em> of order type 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:283">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>


, the induced well-ordering of initial segments of <em>W</em> by inclusion has order type 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:284">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(\alpha)
  </annotation>
 </semantics>
</math>

 (it is one type higher, thus the application of T): but the order types of the well-ordering of a von Neumann ordinal <em>A</em> by membership and the well-ordering of its initial segments by inclusion are clearly the same because the two well-orderings are actually the same relation, so the order type of <em>A</em> is fixed under T. Moreover, the same argument applies to any smaller ordinal (which will be the order type of an initial segment of <em>A</em>, also a von Neumann ordinal) so the order type of any von Neumann ordinal is strongly cantorian.</p>

<p>The only von Neumann ordinals which can be shown to exist in NFU without additional assumptions are the concrete finite ones. However, the application of a permutation method can convert any model of NFU to a model in which every strongly cantorian ordinal is the order type of a von Neumann ordinal. This suggests that the concept "strongly cantorian ordinal of NFU" might be a better analogue to "ordinal of ZFC" than is the apparent analogue "ordinal of NFU".</p>
<h2 id="cardinal-numbers">Cardinal numbers</h2>

<p>Cardinal numbers are defined in <a href="New_Foundations" title="wikilink">NFU</a> in a way which generalizes the definition of natural number: for any set <em>A</em>, 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:285">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <msub>
    <mo>=</mo>
    <mi>def</mi>
   </msub>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>B</mi>
    <mo>∣</mo>
    <mrow>
     <mi>B</mi>
     <mo>∼</mo>
     <mi>A</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <eq></eq>
     <ci>def</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>A</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>B</ci>
     <apply>
      <csymbol cd="latexml">similar-to</csymbol>
      <ci>B</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A|=_{\mathrm{def}}\{B\mid B\sim A\}
  </annotation>
 </semantics>
</math>

.</p>

<p>In <a class="uri" href="ZFC" title="wikilink">ZFC</a>, these equivalence classes are too large as usual. Scott's trick could be used (and indeed is used in <a href="Zermelo–Fraenkel_set_theory" title="wikilink">ZF</a>), 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:286">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>A</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A|
  </annotation>
 </semantics>
</math>

 is usually defined as the smallest order type (here a von Neumann ordinal) of a well-ordering of <em>A</em> (that every set can be well-ordered follows from the Axiom of Choice in the usual way in both theories).</p>

<p>The natural order on cardinal numbers is seen to be a well-ordering: that it is reflexive, antisymmetric (on abstract cardinals, which are now available) and transitive has been shown above. That it is a linear order follows from the Axiom of Choice: well-order two sets and an initial segment of one well-ordering will be isomorphic to the other, so one set will have cardinality smaller than that of the other. That it is a well-ordering follows from the Axiom of Choice in a similar way.</p>

<p>With each infinite cardinal, many order types are associated for the usual reasons (in either set theory).</p>

<p>Cantor's theorem shows (in both theories) that there are nontrivial distinctions between infinite cardinal numbers. In <a class="uri" href="ZFC" title="wikilink">ZFC</a>, one proves 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:287">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>A</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo><</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <abs></abs>
     <ci>A</ci>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A|<|P(A)|.
  </annotation>
 </semantics>
</math>

 In <a href="New_Foundations" title="wikilink">NFU</a>, the usual form of Cantor's theorem is false (consider the case A=V), but Cantor's theorem is an ill-typed statement. The correct form of the theorem in <a href="New_Foundations" title="wikilink">NFU</a> is 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:288">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>P</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo><</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |P_{1}(A)|<|P(A)|
  </annotation>
 </semantics>
</math>


, where 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:289">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{1}(A)
  </annotation>
 </semantics>
</math>

 is the set of one-element subsets of A. 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:290">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>P</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>V</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo><</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>V</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>V</ci>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |P_{1}(V)|<|P(V)|
  </annotation>
 </semantics>
</math>

 shows that there are "fewer" singletons than sets (the obvious bijection 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:291">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>↦</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>x</ci>
    <set>
     <ci>x</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\mapsto\{x\}
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:292">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{1}(V)
  </annotation>
 </semantics>
</math>

 to <em>V</em> has already been seen not to be a set). It is actually provable in NFU + Choice that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:293">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>P</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>V</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo><</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>V</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≪</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>V</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>V</ci>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>V</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">much-less-than</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <abs></abs>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |P_{1}(V)|<|P(V)|\ll|V|
  </annotation>
 </semantics>
</math>


 (where 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:294">
 <semantics>
  <mo>≪</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">much-less-than</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ll
  </annotation>
 </semantics>
</math>

 signals the existence of many intervening cardinals; there are many, many urelements!). Define a type-raising T operation on cardinals analogous to the T operation on ordinals

<math display="block" id="Implementation_of_mathematics_in_set_theory:295">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>A</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>P</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <apply>
      <abs></abs>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(|A|)=|P_{1}(A)|
  </annotation>
 </semantics>
</math>

; this is an external endomorphism of the cardinals just as the T operation on ordinals is an external endomorphism of the ordinals.</p>

<p>A set <em>A</em> is said to be <strong>cantorian</strong> just in case 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:296">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>P</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>A</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <abs></abs>
      <ci>A</ci>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>T</ci>
      <apply>
       <abs></abs>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A|=|P_{1}(A)|=T(|A|)
  </annotation>
 </semantics>
</math>

; the cardinal 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:297">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>A</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A|
  </annotation>
 </semantics>
</math>

 is also said to be a cantorian cardinal. A set <em>A</em> is said to be <strong>strongly cantorian</strong> (and its cardinal to be strongly cantorian as well) just in case the restriction of the singleton map to <em>A</em> (

<math display="inline" id="Implementation_of_mathematics_in_set_theory:298">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>↦</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>x</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">⌈</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">maps-to</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⌈</ci>
     <csymbol cd="unknown">A</csymbol>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x\mapsto\{x\})\lceil A
  </annotation>
 </semantics>
</math>


) is a set. Well-orderings of strongly cantorian sets are always strongly cantorian ordinals; this is not always true of well-orderings of cantorian sets (though the shortest well-ordering of a cantorian set will be cantorian). A cantorian set is a set which satisfies the usual form of Cantor's theorem.</p>

<p>The operations of cardinal arithmetic are defined in a set-theoretically motivated way in both theories. 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:299">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>A</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>B</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>C</mi>
     <mo>∪</mo>
     <mi>D</mi>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <mi>C</mi>
     <mo>∼</mo>
     <mrow>
      <mi>A</mi>
      <mo>∧</mo>
      <mi>D</mi>
     </mrow>
     <mo>∼</mo>
     <mrow>
      <mrow>
       <mi>B</mi>
       <mo>∧</mo>
       <mi>C</mi>
      </mrow>
      <mo>∩</mo>
      <mi>D</mi>
     </mrow>
     <mo>=</mo>
     <mi mathvariant="normal">∅</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <abs></abs>
      <ci>A</ci>
     </apply>
     <apply>
      <abs></abs>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <union></union>
      <ci>C</ci>
      <ci>D</ci>
     </apply>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="latexml">similar-to</csymbol>
       <ci>C</ci>
       <apply>
        <and></and>
        <ci>A</ci>
        <ci>D</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">similar-to</csymbol>
       <share href="#.cmml">
       </share>
       <apply>
        <intersect></intersect>
        <apply>
         <and></and>
         <ci>B</ci>
         <ci>C</ci>
        </apply>
        <ci>D</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <share href="#.cmml">
       </share>
       <emptyset></emptyset>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A|+|B|=\{C\cup D\mid C\sim A\wedge D\sim B\wedge C\cap D=\emptyset\}
  </annotation>
 </semantics>
</math>

. One would like to define 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:300">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>⋅</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>B</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <abs></abs>
     <ci>A</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A|\cdot|B|
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:301">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mi>A</mi>
    <mo>×</mo>
    <mi>B</mi>
   </mrow>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A\times B|
  </annotation>
 </semantics>
</math>

, and one does this in <a class="uri" href="ZFC" title="wikilink">ZFC</a>, but there is an obstruction in <a href="New_Foundations" title="wikilink">NFU</a> when using the Kuratowski pair: one defines 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:302">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>⋅</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>B</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <abs></abs>
     <ci>A</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A|\cdot|B|
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:303">
 <semantics>
  <mrow>
   <msup>
    <mi>T</mi>
    <mrow>
     <mo>-</mo>
     <mn>2</mn>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>A</mi>
      <mo>×</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <apply>
      <minus></minus>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{-2}(|A\times B|)
  </annotation>
 </semantics>
</math>


 because of the type displacement of 2 between the pair and its projections, which implies a type displacement of two between a cartesian product and its factors. It is straightforward to prove that the product always exists (but requires attention because the inverse of T is not total).</p>

<p>Defining the exponential operation on cardinals requires T in an essential way: if 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:304">
 <semantics>
  <msup>
   <mi>B</mi>
   <mi>A</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>B</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{A}
  </annotation>
 </semantics>
</math>

 was defined as the collection of functions from <em>A</em> to <em>B</em>, this is three types higher than <em>A</em> or <em>B</em>, so it is reasonable to define 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:305">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>B</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <abs></abs>
     <ci>B</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |B|^{|A|}
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:306">
 <semantics>
  <mrow>
   <msup>
    <mi>T</mi>
    <mrow>
     <mo>-</mo>
     <mn>3</mn>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <msup>
      <mi>B</mi>
      <mi>A</mi>
     </msup>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <apply>
      <minus></minus>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{-3}(|B^{A}|)
  </annotation>
 </semantics>
</math>

 so that it is the same type as <em>A</em> or <em>B</em> (

<math display="inline" id="Implementation_of_mathematics_in_set_theory:307">
 <semantics>
  <msup>
   <mi>T</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>T</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{-1}
  </annotation>
 </semantics>
</math>

 replaces 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:308">
 <semantics>
  <msup>
   <mi>T</mi>
   <mrow>
    <mo>-</mo>
    <mn>3</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>T</ci>
    <apply>
     <minus></minus>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{-3}
  </annotation>
 </semantics>
</math>


 with type-level pairs). An effect of this is that the exponential operation is partial: for example, 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:309">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>V</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <abs></abs>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{|V|}
  </annotation>
 </semantics>
</math>

 is undefined. In <a class="uri" href="ZFC" title="wikilink">ZFC</a> one defines 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:310">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>B</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <abs></abs>
     <ci>B</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |B|^{|A|}
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:311">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <msup>
    <mi>B</mi>
    <mi>A</mi>
   </msup>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>B</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |B^{A}|
  </annotation>
 </semantics>
</math>

 without difficulty.</p>

<p>The exponential operation is total and behaves exactly as expected on cantorian cardinals, since T fixes such cardinals and it is easy to show that a function space between cantorian sets is cantorian (as are power sets, cartesian products, and other usual type constructors). This offers further encouragement to the view that the "standard" cardinalities in <a href="New_Foundations" title="wikilink">NFU</a> are the cantorian (indeed, the strongly cantorian) cardinalities, just as the "standard" ordinals seem to be the strongly cantorian ordinals.</p>

<p>Now the usual theorems of cardinal arithmetic with the axiom of choice can be proved, including 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:312">
 <semantics>
  <mrow>
   <mrow>
    <mi>κ</mi>
    <mo>⋅</mo>
    <mi>κ</mi>
   </mrow>
   <mo>=</mo>
   <mi>κ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <ci>κ</ci>
     <ci>κ</ci>
    </apply>
    <ci>κ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa\cdot\kappa=\kappa
  </annotation>
 </semantics>
</math>

. From the case 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:313">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>V</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>V</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>V</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <abs></abs>
      <ci>V</ci>
     </apply>
     <apply>
      <abs></abs>
      <ci>V</ci>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |V|\cdot|V|=|V|
  </annotation>
 </semantics>
</math>


 the existence of a type level ordered pair can be derived

<math display="block" id="Implementation_of_mathematics_in_set_theory:314">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>V</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>V</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>T</mi>
     <mrow>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>V</mi>
       <mo>×</mo>
       <mi>V</mi>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <abs></abs>
      <ci>V</ci>
     </apply>
     <apply>
      <abs></abs>
      <ci>V</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>V</ci>
       <ci>V</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |V|\cdot|V|=T^{-2}(|V\times V|)
  </annotation>
 </semantics>
</math>

 is equal to 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:315">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>V</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |V|
  </annotation>
 </semantics>
</math>

 just in case 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:316">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>V</mi>
     <mo>×</mo>
     <mi>V</mi>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>T</mi>
     <mn>2</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>V</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msubsup>
      <mi>P</mi>
      <mn>1</mn>
      <mn>2</mn>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>V</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>V</ci>
       <ci>V</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>T</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <abs></abs>
       <ci>V</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>V</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |V\times V|=T^{2}(|V|)=|P_{1}^{2}(V)|
  </annotation>
 </semantics>
</math>

, which would be witnessed by a one-to-one correspondence between Kuratowski pairs 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:317">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>a</ci>
    <ci>b</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b)
  </annotation>
 </semantics>
</math>

 and double singletons 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:318">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>c</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <set>
     <ci>c</ci>
    </set>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\{c\}\}
  </annotation>
 </semantics>
</math>


: redefine 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:319">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>a</ci>
    <ci>b</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b)
  </annotation>
 </semantics>
</math>

 as the <em>c</em> such that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:320">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>c</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <set>
     <ci>c</ci>
    </set>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\{c\}\}
  </annotation>
 </semantics>
</math>

 is associated with the Kuratowski 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:321">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>a</ci>
    <ci>b</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b)
  </annotation>
 </semantics>
</math>

: this is a type-level notion of ordered pair.</p>
<h2 id="the-axiom-of-counting-and-subversion-of-stratification">The Axiom of Counting and subversion of stratification</h2>

<p>So there are two different implementations of the natural numbers in <a href="New_Foundations" title="wikilink">NFU</a> (though they are the same in <a class="uri" href="ZFC" title="wikilink">ZFC</a>): finite ordinals and finite cardinals. Each of these supports a T operation in <a href="New_Foundations" title="wikilink">NFU</a> (basically the same operation). It is easy to prove that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:322">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(n)
  </annotation>
 </semantics>
</math>

 is a natural number if n is a natural number in <a href="New_Foundations" title="wikilink">NFU</a> + Infinity + Choice (and so 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:323">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>N</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |N|
  </annotation>
 </semantics>
</math>


 and the first infinite ordinal 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:324">
 <semantics>
  <mi>ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega
  </annotation>
 </semantics>
</math>

 are cantorian) but it is not possible to prove in this theory that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:325">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>n</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(n)=n
  </annotation>
 </semantics>
</math>

. However, common sense indicates that this should be true, and so it can be adopted as an axiom:</p>
<ul>
<li><strong>Rosser's Axiom of Counting</strong>: For each natural number <em>n</em>, 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:326">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>n</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(n)=n
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>One natural consequence of this axiom (and indeed its original formulation) is</p>
<ul>
<li>

<math display="inline" id="Implementation_of_mathematics_in_set_theory:327">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <set>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>n</ci>
     </set>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\{1,\ldots,n\}|=n
  </annotation>
 </semantics>
</math>

 for each natural number <em>n</em>.</li>
</ul>

<p>All that can be proved in <a href="New_Foundations" title="wikilink">NFU</a> without Counting is 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:328">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>T</mi>
     <mn>2</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <set>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>n</ci>
     </set>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\{1,\ldots,n\}|=T^{2}(n)
  </annotation>
 </semantics>
</math>


.</p>

<p>A consequence of Counting is that <em>N</em> is a strongly cantorian set (again, this is an equivalent assertion).</p>
<h3 id="properties-of-strongly-cantorian-sets">Properties of strongly cantorian sets</h3>

<p>The type of any variable restricted to a strongly cantorian set <em>A</em> can be raised or lowered as desired by replacing references to 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:329">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∈</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>a</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\in A
  </annotation>
 </semantics>
</math>

 with references to 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:330">
 <semantics>
  <mrow>
   <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋃</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigcup f(a)
  </annotation>
 </semantics>
</math>

 (type of <em>a</em> raised; this presupposes that it is known that <em>a</em> is a set; otherwise one must say "the element of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:331">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(a)
  </annotation>
 </semantics>
</math>

" to get this effect) or 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:332">
 <semantics>
  <mrow>
   <msup>
    <mi>f</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>a</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <set>
     <ci>a</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{-1}(\{a\})
  </annotation>
 </semantics>
</math>

 (type of a lowered) where 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:333">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>a</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>a</ci>
    </apply>
    <set>
     <ci>a</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(a)=\{a\}
  </annotation>
 </semantics>
</math>


 for all 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:334">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∈</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>a</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\in A
  </annotation>
 </semantics>
</math>

, so it is not necessary to assign types to such variables for purposes of stratification.</p>

<p>Any subset of a strongly cantorian set is strongly cantorian. The power set of a strongly cantorian set is strongly cantorian. The cartesian product of two strongly cantorian sets is strongly cantorian.</p>

<p>Introducing the Axiom of Counting means that types need not be assigned to variables restricted to <em>N</em> or to <em>P</em>(<em>N</em>), <em>R</em> (the set of reals) or indeed any set ever considered in classical mathematics outside of set theory.</p>

<p>There are no analogous phenomena in <a class="uri" href="ZFC" title="wikilink">ZFC</a>. See the main <a href="New_Foundations" title="wikilink">New Foundations</a> article for stronger axioms that can be adjoined to NFU to enforce "standard" behavior of familiar mathematical objects.</p>
<h2 id="familiar-number-systems-positive-rationals-magnitudes-and-reals">Familiar number systems: positive rationals, magnitudes, and reals</h2>

<p>Represent <strong>positive fractions</strong> as pairs of positive natural numbers (0 is excluded)

<math display="block" id="Implementation_of_mathematics_in_set_theory:335">
 <semantics>
  <mfrac>
   <mi>p</mi>
   <mi>q</mi>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{p}{q}
  </annotation>
 </semantics>
</math>

 is represented by the pair 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:336">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>q</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>p</ci>
    <ci>q</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,q)
  </annotation>
 </semantics>
</math>

. To make 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:337">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mi>p</mi>
     <mi>q</mi>
    </mfrac>
    <mo>=</mo>
    <mfrac>
     <mi>r</mi>
     <mi>s</mi>
    </mfrac>
   </mrow>
   <mo>↔</mo>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mi>s</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>q</mi>
     <mi>r</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <ci>p</ci>
      <ci>q</ci>
     </apply>
     <apply>
      <divide></divide>
      <ci>r</ci>
      <ci>s</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <times></times>
      <ci>q</ci>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{p}{q}=\frac{r}{s}\leftrightarrow ps=qr
  </annotation>
 </semantics>
</math>

, introduce the relation 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:338">
 <semantics>
  <mo>∼</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">similar-to</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sim
  </annotation>
 </semantics>
</math>


 defined by 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:339">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo>,</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∼</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>r</mi>
     <mo>,</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>↔</mo>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mi>s</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>q</mi>
     <mi>r</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <csymbol cd="latexml">similar-to</csymbol>
     <interval closure="open">
      <ci>p</ci>
      <ci>q</ci>
     </interval>
     <interval closure="open">
      <ci>r</ci>
      <ci>s</ci>
     </interval>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <times></times>
      <ci>q</ci>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,q)\sim(r,s)\leftrightarrow ps=qr
  </annotation>
 </semantics>
</math>

. It is provable that this is an equivalence relation: define <strong>positive rational numbers</strong> as equivalence classes of pairs of positive natural numbers under this relation. Arithmetic operations on positive rational numbers and the order relation on positive rationals are defined just as in elementary school and proved (with some effort) to have the expected properties.</p>

<p>Represent <strong>magnitudes</strong> (positive reals) as nonempty proper initial segments of the positive rationals with no largest element. The operations of addition and multiplication on magnitudes are implemented by elementwise addition of the positive rational elements of the magnitudes. Order is implemented as set inclusion.</p>

<p>Represent <strong>real numbers</strong> as differences 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:340">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>-</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>m</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m-n
  </annotation>
 </semantics>
</math>

 of magnitudes: formally speaking, a real number is an equivalence class of pairs 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:341">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>m</mi>
   <mo>,</mo>
   <mi>n</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>m</ci>
    <ci>n</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (m,n)
  </annotation>
 </semantics>
</math>

 of magnitudes under the equivalence relation 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:342">
 <semantics>
  <mo>∼</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">similar-to</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sim
  </annotation>
 </semantics>
</math>

 defined by 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:343">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∼</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>r</mi>
     <mo>,</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>↔</mo>
   <mrow>
    <mrow>
     <mi>m</mi>
     <mo>+</mo>
     <mi>s</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mi>r</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <csymbol cd="latexml">similar-to</csymbol>
     <interval closure="open">
      <ci>m</ci>
      <ci>n</ci>
     </interval>
     <interval closure="open">
      <ci>r</ci>
      <ci>s</ci>
     </interval>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <ci>m</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (m,n)\sim(r,s)\leftrightarrow m+s=n+r
  </annotation>
 </semantics>
</math>


. The operations of addition and multiplication on real numbers are defined just as one would expect from the algebraic rules for adding and multiplying differences. The treatment of order is also as in elementary algebra.</p>

<p>This is the briefest sketch of the constructions. Note that the constructions are exactly the same in <a class="uri" href="ZFC" title="wikilink">ZFC</a> and in <a href="New_Foundations" title="wikilink">NFU</a>, except for the difference in the constructions of the natural numbers: since all variables are restricted to strongly cantorian sets, there is no need to worry about stratification restrictions. Without the Axiom of Counting, it might be necessary to introduce some applications of T in a full discussion of these constructions.</p>
<h2 id="operations-on-indexed-families-of-sets">Operations on indexed families of sets</h2>

<p>In this class of constructions it appears that <a class="uri" href="ZFC" title="wikilink">ZFC</a> has an advantage over <a href="New_Foundations" title="wikilink">NFU</a>: though the constructions are clearly feasible in <a href="New_Foundations" title="wikilink">NFU</a>, they are more complicated than in ZFC for reasons having to do with stratification.</p>

<p>Throughout this section assume a type-level ordered pair. Define 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:344">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1},x_{2},\ldots,x_{n})
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:345">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1},(x_{2},\ldots,x_{n}))
  </annotation>
 </semantics>
</math>

. The definition of the general <em>n</em>-tuple using the Kuratowski pair is trickier, as one needs to keep the types of all the projections the same, and the type displacement between the <em>n</em>-tuple and its projections increases as <em>n</em> increases. Here, the <em>n</em>-tuple has the same type as each of its projections.</p>

<p>General cartesian products are defined similarly

<math display="block" id="Implementation_of_mathematics_in_set_theory:346">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
    <mo>×</mo>
    <msub>
     <mi>A</mi>
     <mn>2</mn>
    </msub>
    <mo>×</mo>
    <mi mathvariant="normal">…</mi>
    <mo>×</mo>
    <msub>
     <mi>A</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
    <mo>×</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>A</mi>
       <mn>2</mn>
      </msub>
      <mo>×</mo>
      <mi mathvariant="normal">…</mi>
      <mo>×</mo>
      <msub>
       <mi>A</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{1}\times A_{2}\times\ldots\times A_{n}=A_{1}\times(A_{2}\times\ldots\times A%
_{n})
  </annotation>
 </semantics>
</math>

</p>

<p>The definitions are the same in ZFC but without any worries about stratification (the grouping given here is opposite to that more usually used, but this is easily corrected for).</p>

<p>Now consider the infinite cartesian product 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:347">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Π</mi>
    <mrow>
     <mi>i</mi>
     <mo>∈</mo>
     <mi>I</mi>
    </mrow>
   </msub>
   <msub>
    <mi>A</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Π</ci>
     <apply>
      <in></in>
      <ci>i</ci>
      <ci>I</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{i\in I}A_{i}
  </annotation>
 </semantics>
</math>

. In ZFC, this is defined as the set of all functions <em>f</em> with domain <em>I</em> such that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:348">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi>A</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(i)\in A_{i}
  </annotation>
 </semantics>
</math>


 (where <em>A</em> is implicitly understood as a function taking each <em>i</em> to 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:349">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}
  </annotation>
 </semantics>
</math>

).</p>

<p>In NFU, this is requires attention to type. Given a set <em>I</em> and set valued function <em>A</em> whose value at 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:350">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>i</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>i</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{i\}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:351">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{1}(I)
  </annotation>
 </semantics>
</math>

 is written 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:352">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}
  </annotation>
 </semantics>
</math>

, Define 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:353">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Π</mi>
    <mrow>
     <mi>i</mi>
     <mo>∈</mo>
     <mi>I</mi>
    </mrow>
   </msub>
   <msub>
    <mi>A</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Π</ci>
     <apply>
      <in></in>
      <ci>i</ci>
      <ci>I</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{i\in I}A_{i}
  </annotation>
 </semantics>
</math>


 as the set of all functions <em>f</em> with domain <em>I</em> such that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:354">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi>A</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(i)\in A_{i}
  </annotation>
 </semantics>
</math>

: notice that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:355">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi>A</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>i</mi>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>A</ci>
      <set>
       <ci>i</ci>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(i)\in A_{i}=A(\{i\})
  </annotation>
 </semantics>
</math>

 is stratified because of our convention that <em>A</em> is a function with values at singletons of the indices. Note that the very largest families of sets (which cannot be indexed by sets of singletons) will not have cartesian products under this definition. Note further that the sets 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:356">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}
  </annotation>
 </semantics>
</math>

 are at the same type as the index set <em>I</em> (since one type higher than its elements); the product, as a set of functions with domain <em>I</em> (so at the same type as <em>I</em>) is one type higher (assuming a type-level ordered pair).</p>

<p>Now consider the product 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:357">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Π</mi>
    <mrow>
     <mi>i</mi>
     <mo>∈</mo>
     <mi>I</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Π</ci>
     <apply>
      <in></in>
      <ci>i</ci>
      <ci>I</ci>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{i\in I}|A_{i}|
  </annotation>
 </semantics>
</math>

 of the cardinals of these sets. The cardinality |

<math display="inline" id="Implementation_of_mathematics_in_set_theory:358">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Π</mi>
    <mrow>
     <mi>i</mi>
     <mo>∈</mo>
     <mi>I</mi>
    </mrow>
   </msub>
   <msub>
    <mi>A</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Π</ci>
     <apply>
      <in></in>
      <ci>i</ci>
      <ci>I</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{i\in I}A_{i}
  </annotation>
 </semantics>
</math>


| is one type higher than the cardinals 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:359">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <msub>
    <mi>A</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A_{i}|
  </annotation>
 </semantics>
</math>

, so the correct definition of the infinite product of cardinals is 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:360">
 <semantics>
  <mrow>
   <msup>
    <mi>T</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <msub>
       <mi mathvariant="normal">Π</mi>
       <mrow>
        <mi>i</mi>
        <mo>∈</mo>
        <mi>I</mi>
       </mrow>
      </msub>
      <msub>
       <mi>A</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Π</ci>
       <apply>
        <in></in>
        <ci>i</ci>
        <ci>I</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{-1}(|\Pi_{i\in I}A_{i}|)
  </annotation>
 </semantics>
</math>

 (because the inverse of T is not total, it is possible that this may not exist).</p>

<p>Repeat this for disjoint unions of families of sets and sums of families of cardinals. Again, let <em>A</em> be a set-valued function with domain 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:361">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{1}(I)
  </annotation>
 </semantics>
</math>

: write 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:362">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:363">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>i</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <set>
     <ci>i</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(\{i\})
  </annotation>
 </semantics>
</math>


. The disjoint union 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:364">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Σ</mi>
    <mrow>
     <mi>i</mi>
     <mo>∈</mo>
     <mi>I</mi>
    </mrow>
   </msub>
   <msub>
    <mi>A</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <apply>
      <in></in>
      <ci>i</ci>
      <ci>I</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{i\in I}A_{i}
  </annotation>
 </semantics>
</math>

 is the set 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:365">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∣</mo>
   <mrow>
    <mi>a</mi>
    <mo>∈</mo>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <interval closure="open">
     <ci>i</ci>
     <ci>a</ci>
    </interval>
    <apply>
     <in></in>
     <ci>a</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(i,a)\mid a\in A_{i}\}
  </annotation>
 </semantics>
</math>

. This set is at the same type as the sets 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:366">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}
  </annotation>
 </semantics>
</math>

.</p>

<p>The correct definition of the sum 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:367">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Σ</mi>
    <mrow>
     <mi>i</mi>
     <mo>∈</mo>
     <mi>I</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <apply>
      <in></in>
      <ci>i</ci>
      <ci>I</ci>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{i\in I}|A_{i}|
  </annotation>
 </semantics>
</math>

 is thus 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:368">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mrow>
      <mi>i</mi>
      <mo>∈</mo>
      <mi>I</mi>
     </mrow>
    </msub>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <apply>
       <in></in>
       <ci>i</ci>
       <ci>I</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\Sigma_{i\in I}A_{i}|
  </annotation>
 </semantics>
</math>


, since there is no type displacement.</p>

<p>It is possible to extend these definitions to handle index sets which are not sets of singletons, but this introduces an additional type level and is not needed for most purposes.</p>

<p>In ZFC, define the disjoint union 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:369">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Σ</mi>
    <mrow>
     <mi>i</mi>
     <mo>∈</mo>
     <mi>I</mi>
    </mrow>
   </msub>
   <msub>
    <mi>A</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <apply>
      <in></in>
      <ci>i</ci>
      <ci>I</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{i\in I}A_{i}
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:370">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∣</mo>
   <mrow>
    <mi>a</mi>
    <mo>∈</mo>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <interval closure="open">
     <ci>i</ci>
     <ci>a</ci>
    </interval>
    <apply>
     <in></in>
     <ci>a</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(i,a)\mid a\in A_{i}\}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:371">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}
  </annotation>
 </semantics>
</math>

 abbreviates 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:372">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(i)
  </annotation>
 </semantics>
</math>

.</p>

<p>Permutation methods can be used to show relative consistency with NFU of the assertion that for every strongly cantorian set A there is a set <em>I</em> of the same size whose elements are self-singletons

<math display="block" id="Implementation_of_mathematics_in_set_theory:373">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>i</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <set>
     <ci>i</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=\{i\}
  </annotation>
 </semantics>
</math>

 for each <em>i</em> in <em>I</em>.</p>
<h2 id="the-cumulative-hierarchy">The cumulative hierarchy</h2>

<p>In <a class="uri" href="ZFC" title="wikilink">ZFC</a>, define the <em>cumulative hierarchy</em> as the ordinal-indexed sequence of sets satisfying the following conditions

<math display="block" id="Implementation_of_mathematics_in_set_theory:374">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mi mathvariant="normal">∅</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <cn type="integer">0</cn>
    </apply>
    <emptyset></emptyset>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{0}=\emptyset
  </annotation>
 </semantics>
</math>

; 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:375">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mrow>
     <mi>α</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>V</mi>
      <mi>α</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <apply>
      <plus></plus>
      <ci>α</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>α</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{\alpha+1}=P(V_{\alpha})
  </annotation>
 </semantics>
</math>

; 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:376">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mi>λ</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋃</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <msub>
      <mi>V</mi>
      <mi>β</mi>
     </msub>
     <mo>∣</mo>
     <mrow>
      <mi>β</mi>
      <mo><</mo>
      <mi>λ</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <ci>λ</ci>
    </apply>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>β</ci>
      </apply>
      <apply>
       <lt></lt>
       <ci>β</ci>
       <ci>λ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{\lambda}=\bigcup\{V_{\beta}\mid\beta<\lambda\}
  </annotation>
 </semantics>
</math>

 for limit ordinals 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:377">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

. This is an example of a construction by <a href="transfinite_recursion" title="wikilink">transfinite recursion</a>. The rank of a set <em>A</em> is said to be 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:378">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>


 if and only if 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:379">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∈</mo>
   <mrow>
    <msub>
     <mi>V</mi>
     <mrow>
      <mi>α</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>V</mi>
     <mi>α</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>A</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <apply>
       <plus></plus>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>α</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in V_{\alpha+1}-V_{\alpha}
  </annotation>
 </semantics>
</math>

. The existence of the ranks as sets depends on the axiom of replacement at each limit step (the hierarchy cannot be constructed in <a href="Zermelo_set_theory" title="wikilink">Zermelo set theory</a>); by the axiom of foundation, every set belongs to some rank.</p>

<p>The cardinal 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:380">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>V</mi>
      <mrow>
       <mi>ω</mi>
       <mo>+</mo>
       <mi>α</mi>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <apply>
       <plus></plus>
       <ci>ω</ci>
       <ci>α</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |P(V_{\omega+\alpha})|
  </annotation>
 </semantics>
</math>

 is called 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:381">
 <semantics>
  <msub>
   <mi mathvariant="normal">ℶ</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-ℶ</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beth_{\alpha}
  </annotation>
 </semantics>
</math>

.</p>

<p>This construction cannot be carried out in <a href="New_Foundations" title="wikilink">NFU</a> because the power set operation is not a set function in <a href="New_Foundations" title="wikilink">NFU</a> (

<math display="inline" id="Implementation_of_mathematics_in_set_theory:382">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(A)
  </annotation>
 </semantics>
</math>

 is one type higher than A for purposes of stratification).</p>

<p>The sequence of cardinals 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:383">
 <semantics>
  <msub>
   <mi mathvariant="normal">ℶ</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-ℶ</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beth_{\alpha}
  </annotation>
 </semantics>
</math>


 can be implemented in NFU. Recall that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:384">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <abs></abs>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{|A|}
  </annotation>
 </semantics>
</math>

 is defined as 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:385">
 <semantics>
  <mrow>
   <msup>
    <mi>T</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <msup>
      <mrow>
       <mo stretchy="false">{</mo>
       <mn>0</mn>
       <mo>,</mo>
       <mn>1</mn>
       <mo stretchy="false">}</mo>
      </mrow>
      <mi>A</mi>
     </msup>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{-1}(|\{0,1\}^{A}|)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:386">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{0,1\}
  </annotation>
 </semantics>
</math>

 is a convenient set of size 2, and 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:387">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <msup>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">}</mo>
     </mrow>
     <mi>A</mi>
    </msup>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\{0,1\}^{A}|=|P(A)|
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:388">
 <semantics>
  <mi mathvariant="normal">ℶ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-ℶ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beth
  </annotation>
 </semantics>
</math>


 be the smallest set of cardinals which contains 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:389">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>N</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |N|
  </annotation>
 </semantics>
</math>

 (the cardinality of the set of natural numbers), contains the cardinal 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:390">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <abs></abs>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{|A|}
  </annotation>
 </semantics>
</math>

 whenever it contains 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:391">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>A</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A|
  </annotation>
 </semantics>
</math>

, and which is closed under suprema of sets of cardinals.</p>

<p>A convention for ordinal indexing of any well-ordering 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:392">
 <semantics>
  <msub>
   <mi>W</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{\alpha}
  </annotation>
 </semantics>
</math>

 is defined as the element <em>x</em> of the field of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:393">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>


 such that the order type of the restriction of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:394">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:395">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>y</mi>
   <mo>∣</mo>
   <mrow>
    <mi>y</mi>
    <mi>W</mi>
    <mi>x</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <ci>y</ci>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>W</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{y\mid yWx\}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:396">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

; then define 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:397">
 <semantics>
  <msub>
   <mi mathvariant="normal">ℶ</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-ℶ</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beth_{\alpha}
  </annotation>
 </semantics>
</math>

 as the element with index 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:398">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>


 in the natural order on the elements of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:399">
 <semantics>
  <mi mathvariant="normal">ℶ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-ℶ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beth
  </annotation>
 </semantics>
</math>

. The cardinal 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:400">
 <semantics>
  <msub>
   <mi mathvariant="normal">ℵ</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-ℵ</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \aleph_{\alpha}
  </annotation>
 </semantics>
</math>

 is the element with index 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:401">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 in the natural order on all infinite cardinals (which is a well-ordering, see above). Note that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:402">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">ℵ</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>N</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-ℵ</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <abs></abs>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \aleph_{0}=|N|
  </annotation>
 </semantics>
</math>

 follows immediately from this definition. In all these constructions, notice that the type of the index 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:403">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>


 is two higher (with type-level ordered pair) than the type of 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:404">
 <semantics>
  <msub>
   <mi>W</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{\alpha}
  </annotation>
 </semantics>
</math>

.</p>

<p>Each set <em>A</em> of ZFC has a transitive closure 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:405">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>C</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   TC(A)
  </annotation>
 </semantics>
</math>

 (the intersection of all transitive sets which contains <em>A</em>). By the axiom of foundation, the restriction of the membership relation to the transitive closure of <em>A</em> is a <a href="well-founded_relation" title="wikilink">well-founded relation</a>. The relation 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:406">
 <semantics>
  <mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">⌈</mo>
    <mi>T</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <in></in>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⌈</ci>
     <csymbol cd="unknown">T</csymbol>
     <csymbol cd="unknown">C</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in\lceil TC(A)
  </annotation>
 </semantics>
</math>

 is either empty or has <em>A</em> as its top element, so this relation is a <em>set picture</em>. It can be proved in ZFC that every set picture is isomorphic to some 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:407">
 <semantics>
  <mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">⌈</mo>
    <mi>T</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <in></in>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⌈</ci>
     <csymbol cd="unknown">T</csymbol>
     <csymbol cd="unknown">C</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in\lceil TC(A)
  </annotation>
 </semantics>
</math>

.</p>

<p>This suggests that (an initial segment of) the cumulative hierarchy can be studied by considering the isomorphism classes of set pictures. These isomorphism classes are sets and make up a set in <a href="New_Foundations" title="wikilink">NFU</a>. There is a natural set relation analogous to membership on isomorphism classes of set pictures: if 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:408">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


 is a set picture, write 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:409">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>x</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x]
  </annotation>
 </semantics>
</math>

 for its isomorphism class and define 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:410">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>x</ci>
    </apply>
    <ci>E</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x]E[y]
  </annotation>
 </semantics>
</math>

 as holding if 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:411">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>x</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x]
  </annotation>
 </semantics>
</math>

 is the isomorphism class of the restriction of <em>y</em> to the downward closure of one of the elements of the preimage under <em>y</em> of the top element of <em>y</em>. The relation E is a set relation, and it is straightforward to prove that it is well-founded and extensional. If the definition of E is confusing, it can be deduced from the observation that it is induced by precisely the relationship which holds between the set picture associated with <em>A</em> and the set picture associated with <em>B</em> when 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:412">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∈</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in B
  </annotation>
 </semantics>
</math>

 in the usual set theory.</p>

<p>There is a T operation on isomorphism classes of set pictures analogous to the T operation on ordinals: if <em>x</em> is a set picture, so is 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:413">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mi>ι</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>a</mi>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>b</mi>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <mi>x</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>ι</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <interval closure="open">
      <set>
       <ci>a</ci>
      </set>
      <set>
       <ci>b</ci>
      </set>
     </interval>
     <apply>
      <in></in>
      <interval closure="open">
       <ci>a</ci>
       <ci>b</ci>
      </interval>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\iota}=\{(\{a\},\{b\})\mid(a,b)\in x\}
  </annotation>
 </semantics>
</math>


. Define 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:414">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T([x])
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:415">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <msup>
    <mi>x</mi>
    <mi>ι</mi>
   </msup>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>ι</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x^{\iota}]
  </annotation>
 </semantics>
</math>

. It is easy to see that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:416">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>y</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>↔</mo>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>x</mi>
       <mo stretchy="false">]</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>y</mi>
       <mo stretchy="false">]</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>x</ci>
     </apply>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>T</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>T</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x]E[y]\leftrightarrow T([x])=T([y])
  </annotation>
 </semantics>
</math>

.</p>

<p>An axiom of extensionality for this simulated set theory follows from E's extensionality. From its well-foundedness follows an axiom of foundation. There remains the question of what comprehension axiom E may have. Consider any collection of set pictures 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:417">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msup>
    <mi>x</mi>
    <mi>ι</mi>
   </msup>
   <mo>∣</mo>
   <mrow>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>S</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>ι</ci>
    </apply>
    <apply>
     <in></in>
     <ci>x</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x^{\iota}\mid x\in S\}
  </annotation>
 </semantics>
</math>

 (collection of set pictures whose fields are made up entirely of singletons). Since each 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:418">
 <semantics>
  <msup>
   <mi>x</mi>
   <mi>ι</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>ι</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\iota}
  </annotation>
 </semantics>
</math>


 is one type higher than x (using a type-level ordered pair), replacing each element 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:419">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>a</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>a</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a\}
  </annotation>
 </semantics>
</math>

 of the field of each 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:420">
 <semantics>
  <msup>
   <mi>x</mi>
   <mi>ι</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>ι</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\iota}
  </annotation>
 </semantics>
</math>

 in the collection with 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:421">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>a</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <set>
     <ci>a</ci>
    </set>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,\{a\})
  </annotation>
 </semantics>
</math>

 results in a collection of set pictures isomorphic to the original collection but with their fields disjoint. The union of these set pictures with a new top element yields a set picture whose isomorphism type will have as its preimages under E exactly the elements of the original collection. That is, for any collection of isomorphism types 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:422">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <msup>
     <mi>x</mi>
     <mi>ι</mi>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>ι</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>T</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x^{\iota}]=T([x])
  </annotation>
 </semantics>
</math>

, there is an isomorphism type 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:423">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>y</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [y]
  </annotation>
 </semantics>
</math>


 whose preimage under E is exactly this collection.</p>

<p>In particular, there will be an isomorphism type <em>[v]</em> whose preimage under E is the collection of <em>all</em> <em>T</em>[<em>x</em>]'s (including <em>T</em>[<em>v</em>]). Since <em>T</em>[<em>v</em>] <em>E</em> <em>v</em> and E is well-founded, 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:424">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>v</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <ci>T</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>v</ci>
     </apply>
    </apply>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T[v]\neq v
  </annotation>
 </semantics>
</math>

. This resembles the resolution of the Burali–Forti paradox discussed above and in the <a href="New_Foundations" title="wikilink">New Foundations</a> article, and is in fact the local resolution of <a href="Mirimanoff's_paradox" title="wikilink">Mirimanoff's paradox</a> of the set of all well-founded sets.</p>

<p>There are ranks of isomorphism classes of set pictures just as there are ranks of sets in the usual set theory. For any collection of set pictures <em>A</em>, define <em>S</em>(<em>A</em>) as the set of all isomorphism classes of set pictures whose preimage under E is a subset of A; call A a "complete" set if every subset of <em>A</em> is a preimage under E. The collection of "ranks" is the smallest collection containing the empty set and closed under the S operation (which is a kind of power set construction) and under unions of its subcollections. It is straightforward to prove (much as in the usual set theory) that the ranks are well-ordered by inclusion, and so the ranks have an index in this well-order: refer to the rank with index 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:425">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:426">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{\alpha}
  </annotation>
 </semantics>
</math>

. It is provable that 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:427">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>R</mi>
     <mi>α</mi>
    </msub>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi mathvariant="normal">ℶ</mi>
    <mi>α</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>α</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-ℶ</ci>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |R_{\alpha}|=\beth_{\alpha}
  </annotation>
 </semantics>
</math>

 for complete ranks 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:428">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{\alpha}
  </annotation>
 </semantics>
</math>


. The union of the complete ranks (which will be the first incomplete rank) with the relation E looks like an initial segment of the universe of Zermelo-style set theory (not necessarily like the full universe of <a class="uri" href="ZFC" title="wikilink">ZFC</a> because it may not be large enough). It is provable that if 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:429">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{\alpha}
  </annotation>
 </semantics>
</math>

 is the first incomplete rank, then 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:430">
 <semantics>
  <msub>
   <mi>R</mi>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>α</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{T(\alpha)}
  </annotation>
 </semantics>
</math>

 is a complete rank and thus 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:431">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>α</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>α</ci>
    </apply>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(\alpha)<\alpha
  </annotation>
 </semantics>
</math>

. So there is a "rank of the cumulative hierarchy" with an "external automorphism" T moving the rank downward, exactly the condition on a nonstandard model of a rank in the cumulative hierarchy under which a model of NFU is constructed in the <a href="New_Foundations" title="wikilink">New Foundations</a> article. There are technical details to verify, but there is an interpretation not only of a fragment of <a class="uri" href="ZFC" title="wikilink">ZFC</a> but of <a href="New_Foundations" title="wikilink">NFU</a> itself in this structure, with 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:432">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <msub>
    <mo>∈</mo>
    <mrow>
     <mi>N</mi>
     <mi>F</mi>
     <mi>U</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <in></in>
     <apply>
      <times></times>
      <ci>N</ci>
      <ci>F</ci>
      <ci>U</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x]\in_{NFU}[y]
  </annotation>
 </semantics>
</math>

 defined as 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:433">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>x</mi>
       <mo stretchy="false">]</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>y</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>y</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi>R</mi>
    <mrow>
     <mrow>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>α</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <and></and>
     <apply>
      <times></times>
      <ci>T</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>x</ci>
      </apply>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>y</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>α</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T([x])E[y]\wedge[y]\in R_{T(\alpha)+1}
  </annotation>
 </semantics>
</math>


: this "relation" 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:434">
 <semantics>
  <msub>
   <mi>E</mi>
   <mrow>
    <mi>N</mi>
    <mi>F</mi>
    <mi>U</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>F</ci>
     <ci>U</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{NFU}
  </annotation>
 </semantics>
</math>

 is not a set relation but has the same type displacement between its arguments as the usual membership relation 

<math display="inline" id="Implementation_of_mathematics_in_set_theory:435">
 <semantics>
  <mo>∈</mo>
  <annotation-xml encoding="MathML-Content">
   <in></in>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in
  </annotation>
 </semantics>
</math>

.</p>

<p>So there is a natural construction inside NFU of the cumulative hierarchy of sets which internalizes the natural construction of a model of NFU in Zermelo-style set theory.</p>

<p>Under the Axiom of Cantorian Sets described in the <a href="New_Foundations" title="wikilink">New Foundations</a> article, the strongly cantorian part of the set of isomorphism classes of set pictures with the E relation as membership becomes a (proper class) model of ZFC (in which there are <em>n</em>-<a href="Mahlo_cardinals" title="wikilink">Mahlo cardinals</a> for each <em>n</em>; this extension of NFU is strictly stronger than ZFC). This is a proper class model because the strongly cantorian isomorphism classes do not make up a set.</p>

<p>Permutation methods can be used to create from any model of NFU a model in which every strongly cantorian isomorphism type of set pictures is actually realized as the restriction of the true membership relation to the transitive closure of a set.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Axiomatic_set_theory" title="wikilink">Axiomatic set theory</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li><a href="Keith_Devlin" title="wikilink">Keith Devlin</a>, 1994. <em>The Joy of Sets</em>, 2nd ed. Springer-Verlag.</li>
<li>Holmes, Randall, 1998. <em><a href="http://math.boisestate.edu/~holmes/holmes/head.pdf">Elementary Set Theory with a Universal Set</a></em>. Academia-Bruylant. The publisher has graciously consented to permit diffusion of this introduction to NFU via the web. Copyright is reserved.</li>
<li>Potter, Michael, 2004. <em>Set Theory and its Philosophy</em>, 2nd ed. Oxford Univ. Press.</li>
<li>Suppes, Patrick, 1972. <em>Axiomatic Set Theory</em>. Dover.</li>
<li>Tourlakis, George, 2003. <em>Lectures in Logic and Set Theory, Vol. 2</em>. Cambridge Univ. Press.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://us.metamath.org/">Metamath:</a> A web site devoted to an ongoing derivation of mathematics from the axioms of ZFC and <a href="first-order_logic" title="wikilink">first-order logic</a>.</li>
<li><a href="Stanford_Encyclopedia_of_Philosophy" title="wikilink">Stanford Encyclopedia of Philosophy</a>:
<ul>
<li><a href="http://plato.stanford.edu/entries/quine-nf">Quine's New Foundations</a> -- by Thomas Forster.</li>
<li><a href="http://setis.library.usyd.edu.au/stanford/entries/settheory-alternative/">Alternative axiomatic set theories</a> -- by Randall Holmes.</li>
</ul></li>
<li>Randall Holmes: <a href="http://math.boisestate.edu/~holmes/holmes/nf.html">New Foundations Home Page</a></li>
</ul>

<p>"</p>

<p><a href="Category:Mathematical_logic" title="wikilink">Category:Mathematical logic</a> <a href="Category:Set_theory" title="wikilink">Category:Set theory</a> <a href="Category:Formalism_(deductive)" title="wikilink">Category:Formalism (deductive)</a> <a href="Category:Large-scale_mathematical_formalization_projects" title="wikilink">Category:Large-scale mathematical formalization projects</a></p>
</body>
</html>
