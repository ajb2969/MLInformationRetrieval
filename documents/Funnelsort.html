<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1034">Funnelsort</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Funnelsort</h1>
<hr/>

<p><strong>Funnelsort</strong> is a <a href="comparison_sort" title="wikilink">comparison-based</a> <a href="sorting_algorithm" title="wikilink">sorting algorithm</a>. It was introduced by Frigo, Leiserson, Prokop, and Ramachandran in 1999 in the context of the <a href="Cache-oblivious_algorithm" title="wikilink">cache oblivious model</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> In the external memory model, the number of memory transfers it needs to perform a sort of 

<math display="inline" id="Funnelsort:0">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 items on a machine with cache of size 

<math display="inline" id="Funnelsort:1">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

 and cache lines of length 

<math display="inline" id="Funnelsort:2">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Funnelsort:3">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mfrac>
      <mi>N</mi>
      <mi>L</mi>
     </mfrac>
     <mrow>
      <msub>
       <mi>log</mi>
       <mi>Z</mi>
      </msub>
      <mi>N</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>N</ci>
      <ci>L</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <ci>Z</ci>
      </apply>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\frac{N}{L}\log_{Z}N)
  </annotation>
 </semantics>
</math>

, under the tall cache assumption that 

<math display="inline" id="Funnelsort:4">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Ω</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>L</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Z</ci>
    <apply>
     <times></times>
     <ci>normal-Ω</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z=\Omega(L^{2})
  </annotation>
 </semantics>
</math>

. This number of memory transfers has been shown to be asymptotically optimal for comparison sorts. Funnelsort also achieves the asymptotically optimal runtime complexity of 

<math display="inline" id="Funnelsort:5">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mrow>
      <mi>log</mi>
      <mi>N</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <apply>
      <log></log>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(N\log N)
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="algorithm">Algorithm</h2>
<h3 id="basic-overview">Basic Overview</h3>

<p>Funnelsort operates on a contiguous array of 

<math display="inline" id="Funnelsort:6">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 elements. To sort the elements, it performs the following:</p>
<ol>
<li>Split the input into 

<math display="inline" id="Funnelsort:7">
 <semantics>
  <msup>
   <mi>N</mi>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>3</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>N</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N^{1/3}
  </annotation>
 </semantics>
</math>

 arrays of size 

<math display="inline" id="Funnelsort:8">
 <semantics>
  <msup>
   <mi>N</mi>
   <mrow>
    <mn>2</mn>
    <mo>/</mo>
    <mn>3</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>N</ci>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N^{2/3}
  </annotation>
 </semantics>
</math>

, and sort the arrays recursively.</li>
<li>Merge the 

<math display="inline" id="Funnelsort:9">
 <semantics>
  <msup>
   <mi>N</mi>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>3</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>N</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N^{1/3}
  </annotation>
 </semantics>
</math>

 sorted sequences using a 

<math display="inline" id="Funnelsort:10">
 <semantics>
  <msup>
   <mi>N</mi>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>3</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>N</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N^{1/3}
  </annotation>
 </semantics>
</math>

-merger. (This process will be described in more detail.)</li>
</ol>

<p>Funnelsort is similar to <a href="merge_sort" title="wikilink">merge sort</a> in that some number of subarrays are recursively sorted, after which a merging step combines the subarrays into one sorted array. Merging is performed by a device called a k-merger, which is described in the section below.</p>
<h3 id="k-mergers">k-mergers</h3>

<p>A k-merger takes 

<math display="inline" id="Funnelsort:11">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 sorted sequences. Upon one invocation of a k-merger, it outputs the first 

<math display="inline" id="Funnelsort:12">
 <semantics>
  <msup>
   <mi>k</mi>
   <mn>3</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{3}
  </annotation>
 </semantics>
</math>

 elements of the sorted sequence obtained by merging the k input sequences.</p>

<p>At the top level, funnelsort uses a 

<math display="inline" id="Funnelsort:13">
 <semantics>
  <msup>
   <mi>N</mi>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>3</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>N</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N^{1/3}
  </annotation>
 </semantics>
</math>

-merger on 

<math display="inline" id="Funnelsort:14">
 <semantics>
  <msup>
   <mi>N</mi>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>3</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>N</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N^{1/3}
  </annotation>
 </semantics>
</math>

 sequences of length 

<math display="inline" id="Funnelsort:15">
 <semantics>
  <msup>
   <mi>N</mi>
   <mrow>
    <mn>2</mn>
    <mo>/</mo>
    <mn>3</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>N</ci>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N^{2/3}
  </annotation>
 </semantics>
</math>

, and invokes this merger once.</p>

<p>The k-merger is built recursively out of 

<math display="inline" id="Funnelsort:16">
 <semantics>
  <msqrt>
   <mi>k</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{k}
  </annotation>
 </semantics>
</math>

-mergers. It consists of 

<math display="inline" id="Funnelsort:17">
 <semantics>
  <msqrt>
   <mi>k</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{k}
  </annotation>
 </semantics>
</math>

 input 

<math display="inline" id="Funnelsort:18">
 <semantics>
  <msqrt>
   <mi>k</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{k}
  </annotation>
 </semantics>
</math>

-mergers 

<math display="inline" id="Funnelsort:19">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>I</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>I</mi>
    <msqrt>
     <mi>k</mi>
    </msqrt>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <apply>
      <root></root>
      <ci>k</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{1},I_{2},\ldots,I_{\sqrt{k}}
  </annotation>
 </semantics>
</math>

, and a single output 

<math display="inline" id="Funnelsort:20">
 <semantics>
  <msqrt>
   <mi>k</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{k}
  </annotation>
 </semantics>
</math>

-merger 

<math display="inline" id="Funnelsort:21">
 <semantics>
  <mi>O</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>O</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O
  </annotation>
 </semantics>
</math>

. The k inputs are separated into 

<math display="inline" id="Funnelsort:22">
 <semantics>
  <msqrt>
   <mi>k</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{k}
  </annotation>
 </semantics>
</math>

 sets of 

<math display="inline" id="Funnelsort:23">
 <semantics>
  <msqrt>
   <mi>k</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{k}
  </annotation>
 </semantics>
</math>

 inputs each. Each of these sets is an input to one of the input mergers. The output of each input merger is connected to a buffer, a <a href="FIFO_(computing_and_electronics)" title="wikilink">FIFO</a> <a href="Queue_(data_structure)" title="wikilink">queue</a> that can hold 

<math display="inline" id="Funnelsort:24">
 <semantics>
  <mrow>
   <mn>2</mn>
   <msup>
    <mi>k</mi>
    <mrow>
     <mn>3</mn>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <apply>
      <divide></divide>
      <cn type="integer">3</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2k^{3/2}
  </annotation>
 </semantics>
</math>

 elements. The buffers are implemented as <a href="Circular_buffer" title="wikilink">circular queues</a>. The outputs of the 

<math display="inline" id="Funnelsort:25">
 <semantics>
  <msqrt>
   <mi>k</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{k}
  </annotation>
 </semantics>
</math>

 buffers are connected to the inputs of the output merger 

<math display="inline" id="Funnelsort:26">
 <semantics>
  <mi>O</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>O</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O
  </annotation>
 </semantics>
</math>

. Finally, the output of 

<math display="inline" id="Funnelsort:27">
 <semantics>
  <mi>O</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>O</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O
  </annotation>
 </semantics>
</math>

 is the output of the entire k-merger.</p>

<p>In this construction, any input merger only outputs 

<math display="inline" id="Funnelsort:28">
 <semantics>
  <msup>
   <mi>k</mi>
   <mrow>
    <mn>3</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <apply>
     <divide></divide>
     <cn type="integer">3</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{3/2}
  </annotation>
 </semantics>
</math>

 items at once, but the buffer it outputs to has double the space. This is done so that an input merger can be called only when its buffer does not have enough items, but that when it is called, it outputs a lot of items at once (namely, 

<math display="inline" id="Funnelsort:29">
 <semantics>
  <msup>
   <mi>k</mi>
   <mrow>
    <mn>3</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <apply>
     <divide></divide>
     <cn type="integer">3</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{3/2}
  </annotation>
 </semantics>
</math>

 of them).</p>

<p>A k-merger works recursively in the following way. To output 

<math display="inline" id="Funnelsort:30">
 <semantics>
  <msup>
   <mi>k</mi>
   <mn>3</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{3}
  </annotation>
 </semantics>
</math>

 elements, it recursively invokes its output merger 

<math display="inline" id="Funnelsort:31">
 <semantics>
  <msup>
   <mi>k</mi>
   <mrow>
    <mn>3</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <apply>
     <divide></divide>
     <cn type="integer">3</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{3/2}
  </annotation>
 </semantics>
</math>

 times. However, before it makes a call to O, it checks all of its buffers, filling each of them that are less than half full. To fill the i-th buffer, it recursively invokes the corresponding input merger 

<math display="inline" id="Funnelsort:32">
 <semantics>
  <msub>
   <mi>I</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{i}
  </annotation>
 </semantics>
</math>

 once. If this cannot be done (due to the merger running out of inputs), this step is skipped. Since this call outputs 

<math display="inline" id="Funnelsort:33">
 <semantics>
  <msup>
   <mi>k</mi>
   <mrow>
    <mn>3</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <apply>
     <divide></divide>
     <cn type="integer">3</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{3/2}
  </annotation>
 </semantics>
</math>

 elements, the buffer contains at least 

<math display="inline" id="Funnelsort:34">
 <semantics>
  <msup>
   <mi>k</mi>
   <mrow>
    <mn>3</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <apply>
     <divide></divide>
     <cn type="integer">3</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{3/2}
  </annotation>
 </semantics>
</math>

 elements. At the end of all these operations, the k-merger has output the first 

<math display="inline" id="Funnelsort:35">
 <semantics>
  <msup>
   <mi>k</mi>
   <mn>3</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{3}
  </annotation>
 </semantics>
</math>

 of its input elements, in sorted order.</p>
<h2 id="analysis">Analysis</h2>

<p>Most of the analysis of this algorithm revolves around analyzing the space and cache miss complexity of the k-merger.</p>

<p>The first important bound is that a k-merger can be fit in 

<math display="inline" id="Funnelsort:36">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>k</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(k^{2})
  </annotation>
 </semantics>
</math>

 space. To see this, we let 

<math display="inline" id="Funnelsort:37">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(k)
  </annotation>
 </semantics>
</math>

 denote the space needed for a k-merger. To fit the 

<math display="inline" id="Funnelsort:38">
 <semantics>
  <msup>
   <mi>k</mi>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{1/2}
  </annotation>
 </semantics>
</math>

 buffers of size 

<math display="inline" id="Funnelsort:39">
 <semantics>
  <mrow>
   <mn>2</mn>
   <msup>
    <mi>k</mi>
    <mrow>
     <mn>3</mn>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <apply>
      <divide></divide>
      <cn type="integer">3</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2k^{3/2}
  </annotation>
 </semantics>
</math>

 takes 

<math display="inline" id="Funnelsort:40">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>k</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(k^{2})
  </annotation>
 </semantics>
</math>

 space. To fit the 

<math display="inline" id="Funnelsort:41">
 <semantics>
  <mrow>
   <msqrt>
    <mi>k</mi>
   </msqrt>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <root></root>
     <ci>k</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{k}+1
  </annotation>
 </semantics>
</math>

 smaller buffers takes 

<math display="inline" id="Funnelsort:42">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msqrt>
      <mi>k</mi>
     </msqrt>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msqrt>
     <mi>k</mi>
    </msqrt>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <plus></plus>
     <apply>
      <root></root>
      <ci>k</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <ci>S</ci>
    <apply>
     <root></root>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\sqrt{k}+1)S(\sqrt{k})
  </annotation>
 </semantics>
</math>

 space. Thus, the space satisfies the recurrence 

<math display="inline" id="Funnelsort:43">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msqrt>
         <mi>k</mi>
        </msqrt>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msqrt>
        <mi>k</mi>
       </msqrt>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>O</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>k</mi>
        <mn>2</mn>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <apply>
        <root></root>
        <ci>k</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <ci>S</ci>
      <apply>
       <root></root>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>k</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(k)=(\sqrt{k}+1)S(\sqrt{k})+O(k^{2}).
  </annotation>
 </semantics>
</math>

 This recurrence has solution 

<math display="inline" id="Funnelsort:44">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>k</mi>
       <mn>2</mn>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>k</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(k)=O(k^{2}).
  </annotation>
 </semantics>
</math>

</p>

<p>It follows that there is a positive constant 

<math display="inline" id="Funnelsort:45">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 such that a problem of size at most 

<math display="inline" id="Funnelsort:46">
 <semantics>
  <mrow>
   <mi>α</mi>
   <msqrt>
    <mi>Z</mi>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>α</ci>
    <apply>
     <root></root>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\sqrt{Z}
  </annotation>
 </semantics>
</math>

 fits entirely in cache, meaning that it incurs no additional cache misses.</p>

<p>Letting 

<math display="inline" id="Funnelsort:47">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mi>M</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>M</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{M}(k)
  </annotation>
 </semantics>
</math>

 denote the number of cache misses incurred by a call to a k-merger, one can show that 

<math display="inline" id="Funnelsort:48">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mi>M</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msup>
          <mi>k</mi>
          <mn>3</mn>
         </msup>
         <mrow>
          <msub>
           <mi>log</mi>
           <mi>Z</mi>
          </msub>
          <mi>k</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>/</mo>
       <mi>L</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>M</ci>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>k</ci>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <ci>Z</ci>
        </apply>
        <ci>k</ci>
       </apply>
      </apply>
      <ci>L</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{M}(k)=O((k^{3}\log_{Z}k)/L).
  </annotation>
 </semantics>
</math>

 This is done by an induction argument. It has 

<math display="inline" id="Funnelsort:49">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>≤</mo>
   <mrow>
    <mi>α</mi>
    <msqrt>
     <mi>Z</mi>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>α</ci>
     <apply>
      <root></root>
      <ci>Z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\leq\alpha\sqrt{Z}
  </annotation>
 </semantics>
</math>

 as a base case. For larger k, we can bound the number of times a 

<math display="inline" id="Funnelsort:50">
 <semantics>
  <msqrt>
   <mi>k</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{k}
  </annotation>
 </semantics>
</math>

-merger is called. The output merger is called exactly 

<math display="inline" id="Funnelsort:51">
 <semantics>
  <msup>
   <mi>k</mi>
   <mrow>
    <mn>3</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <apply>
     <divide></divide>
     <cn type="integer">3</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{3/2}
  </annotation>
 </semantics>
</math>

 times. The total number of calls on input mergers is at most 

<math display="inline" id="Funnelsort:52">
 <semantics>
  <mrow>
   <msup>
    <mi>k</mi>
    <mrow>
     <mn>3</mn>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </msup>
   <mo>+</mo>
   <mrow>
    <mn>2</mn>
    <msqrt>
     <mi>k</mi>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <apply>
      <divide></divide>
      <cn type="integer">3</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <root></root>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{3/2}+2\sqrt{k}
  </annotation>
 </semantics>
</math>

. This gives a total bound of 

<math display="inline" id="Funnelsort:53">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <msup>
     <mi>k</mi>
     <mrow>
      <mn>3</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mn>2</mn>
    <msqrt>
     <mi>k</mi>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>k</ci>
      <apply>
       <divide></divide>
       <cn type="integer">3</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <root></root>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2k^{3/2}+2\sqrt{k}
  </annotation>
 </semantics>
</math>

 recursive calls. In addition, the algorithm checks every buffer to see if needs to be filled. This is done on 

<math display="inline" id="Funnelsort:54">
 <semantics>
  <msqrt>
   <mi>k</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{k}
  </annotation>
 </semantics>
</math>

 buffers every step for 

<math display="inline" id="Funnelsort:55">
 <semantics>
  <msup>
   <mi>k</mi>
   <mrow>
    <mn>3</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <apply>
     <divide></divide>
     <cn type="integer">3</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{3/2}
  </annotation>
 </semantics>
</math>

 steps, leading to a max of 

<math display="inline" id="Funnelsort:56">
 <semantics>
  <msup>
   <mi>k</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{2}
  </annotation>
 </semantics>
</math>

 cache misses for all the checks.</p>

<p>This leads to the recurrence 

<math display="inline" id="Funnelsort:57">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Q</mi>
     <mi>M</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mn>2</mn>
        <msup>
         <mi>k</mi>
         <mrow>
          <mn>3</mn>
          <mo>/</mo>
          <mn>2</mn>
         </mrow>
        </msup>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mn>2</mn>
        <msqrt>
         <mi>k</mi>
        </msqrt>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>Q</mi>
      <mi>M</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msqrt>
       <mi>k</mi>
      </msqrt>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <msup>
     <mi>k</mi>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>M</ci>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>k</ci>
         <apply>
          <divide></divide>
          <cn type="integer">3</cn>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <root></root>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>M</ci>
      </apply>
      <apply>
       <root></root>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>k</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{M}(k)\leq(2k^{3/2}+2\sqrt{k})Q_{M}(\sqrt{k})+k^{2}
  </annotation>
 </semantics>
</math>

, which can be shown to have the solution given above.</p>

<p>Finally, the total cache misses 

<math display="inline" id="Funnelsort:58">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(N)
  </annotation>
 </semantics>
</math>

 for the entire sort can be analyzed. It satisfies the recurrence 

<math display="inline" id="Funnelsort:59">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>N</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>N</mi>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>3</mn>
       </mrow>
      </msup>
      <mi>Q</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>N</mi>
        <mrow>
         <mn>2</mn>
         <mo>/</mo>
         <mn>3</mn>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>Q</mi>
       <mi>M</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>N</mi>
        <mrow>
         <mn>1</mn>
         <mo>/</mo>
         <mn>3</mn>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>N</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>N</ci>
       <apply>
        <divide></divide>
        <cn type="integer">2</cn>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>M</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>N</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(N)=N^{1/3}Q(N^{2/3})+Q_{M}(N^{1/3}).
  </annotation>
 </semantics>
</math>

 This can be shown to have solution 

<math display="inline" id="Funnelsort:60">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>N</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>N</mi>
         <mo>/</mo>
         <mi>L</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <msub>
         <mi>log</mi>
         <mi>Z</mi>
        </msub>
        <mi>N</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>N</ci>
       <ci>L</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <ci>Z</ci>
       </apply>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(N)=O((N/L)\log_{Z}N).
  </annotation>
 </semantics>
</math>

</p>
<h2 id="lazy-funnelsort">Lazy Funnelsort</h2>

<p>The <strong>lazy funnelsort</strong> is a modification of the funnelsort, introduced by Brodal and Fagerberg in 2002.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The modification is that when a merger is invoked, it does not have to fill each of its buffers. Instead, it lazily fills a buffer only when it is empty. This modification has the same asymptotic runtime and memory transfers as the original funnelsort, but has applications in cache-oblivious algorithms for problems in computational geometry in a method known as distribution sweeping.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Sorting_algorithms" title="wikilink">Category:Sorting algorithms</a> <a href="Category:Comparison_sorts" title="wikilink">Category:Comparison sorts</a> <a href="Category:External_memory_algorithms" title="wikilink">Category:External memory algorithms</a> <a href="Category:Analysis_of_algorithms" title="wikilink">Category:Analysis of algorithms</a> <a href="Category:Cache_(computing)" title="wikilink">Category:Cache (computing)</a> <a href="Category:Models_of_computation" title="wikilink">Category:Models of computation</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">M. Frigo, C.E. Leiserson, H. Prokop, and S. Ramachandran. Cache-oblivious algorithms. In <em>Proceedings of the 40th IEEE Symposium on Foundations of Computer Science</em> (FOCS 99), pp. 285-297. 1999. <a href="http://ieeexplore.ieee.org/iel5/6604/17631/00814600.pdf?arnumber=814600">Extended abstract at IEEE</a>, <a href="http://citeseer.ist.psu.edu/307799.html">at Citeseer</a>.<a href="#fnref1">↩</a></li>
<li id="fn2">Harald Prokop. <a href="http://supertech.csail.mit.edu/papers/Prokop99.pdf">Cache-Oblivious Algorithms</a>. Masters thesis, MIT. 1999.<a href="#fnref2">↩</a></li>
<li id="fn3">. See also the <a href="http://www.cs.au.dk/~gerth/papers/brics-rs-02-18.pdf">longer technical report</a>.<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
