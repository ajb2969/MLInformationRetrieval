   Pushdown automaton      Pushdown automaton   In computer science , a pushdown automaton ( PDA ) is a type of automaton that employs a stack .  Pushdown automata are used in theories about what can be computed by machines. They are more capable than finite-state machines but less capable than Turing machines . Deterministic pushdown automata can recognize all deterministic context-free languages while nondeterministic ones can recognize all context-free languages . Mainly the former are used in parser design.  The term "pushdown" refers to the fact that the stack can be regarded as being "pushed down" like a tray dispenser at a cafeteria, since the operations never work on elements other than the top element. A stack automaton , by contrast, does allow access to and operations on deeper elements. Stack automata can recognize a strictly larger set of languages than pushdown automata. 1 A nested stack automaton allows full access, and also allows stacked values to be entire sub-stacks rather than just single finite symbols.  The remainder of this article describes the nondeterministic pushdown automaton.  Operation  Pushdown automata differ from finite state machines in two ways:   They can use the top of the stack to decide which transition to take.  They can manipulate the stack as part of performing a transition.   Pushdown automata choose a transition by indexing a table by input signal, current state, and the symbol at the top of the stack. This means that those three parameters completely determine the transition path that is chosen. Finite state machines just look at the input signal and the current state: they have no stack to work with. Pushdown automata add the stack as a parameter for choice.  Pushdown automata can also manipulate the stack, as part of performing a transition. Finite state machines choose a new state, the result of following the transition. The manipulation can be to push a particular symbol to the top of the stack, or to pop off the top of the stack. The automaton can alternatively ignore the stack, and leave it as it is. The choice of manipulation (or no manipulation) is determined by the transition table.  Put together: Given an input signal, current state, and stack symbol, the automaton can follow a transition to another state, and optionally manipulate (push or pop) the stack.  In general, pushdown automata may have several computations on a given input string, some of which may be halting in accepting configurations. If only one computation exists for all accepted strings, the result is a deterministic pushdown automaton (DPDA) and the language of these strings is a deterministic context-free language . Not all context-free languages are deterministic. 2 As a consequence of the above the DPDA is a strictly weaker variant of the PDA and there exists no algorithm for converting a PDA to an equivalent DPDA, if such a DPDA exists.  If we allow a finite automaton access to two stacks instead of just one, we obtain a more powerful device, equivalent in power to a Turing machine . A linear bounded automaton is a device which is more powerful than a pushdown automaton but less so than a Turing machine.  Relation to backtracking  Nondeterministic PDAs are able to handle situations where more than one choice of action is available. In principle it is enough to create in every such case new automaton instances that will handle the extra choices. The problem with this approach is that in practice most of these instances fail. This can severely affect the automaton's performance as the execution of multiple instances is a costly operation. Situations such as these can be identified in the design phase of the automaton by examining the grammar the automaton uses. This makes possible the use of backtracking in every such case in order to improve the performance of pushdown automaton.  Formal definition  We use standard formal language notation    Γ  *     superscript  normal-Γ     \Gamma^{*}   denotes the set of strings over alphabet   Γ   normal-Γ   \Gamma   and   ε   ε   \varepsilon   denotes the empty string .  A PDA is formally defined as a 7-tuple:      M  =   (  Q  ,  Σ  ,  Γ  ,  δ  ,   q  0   ,  Z  ,  F  )       M   Q  normal-Σ  normal-Γ  δ   subscript  q  0   Z  F     M=(Q,\ \Sigma,\ \Gamma,\ \delta,\ q_{0},\ Z,\ F)   where       Q    Q   \,Q   is a finite set of states      Σ    normal-Σ   \,\Sigma   is a finite set which is called the input alphabet      Γ    normal-Γ   \,\Gamma   is a finite set which is called the stack alphabet      δ    δ   \,\delta   is a finite subset of    Q  ×   (   Σ  ∪   {  ε  }    )   ×  Γ  ×  Q  ×   Γ  *       Q    normal-Σ   ε    normal-Γ  Q   superscript  normal-Γ      Q\times(\Sigma\cup\{\varepsilon\})\times\Gamma\times Q\times\Gamma^{*}   , the transition relation .        q   0   ∈  Q       subscript  q  0   Q    \,q_{0}\in\,Q   is the start state       Z   ∈  Γ      Z  normal-Γ    \ Z\in\,\Gamma   is the initial stack symbol      F  ⊆  Q      F  Q    F\subseteq Q   is the set of accepting states   An element     (  p  ,  a  ,  A  ,  q  ,  α  )   ∈  δ       p  a  A  q  α   δ    (p,a,A,q,\alpha)\in\delta   is a transition of   M   M   M   . It has the intended meaning that   M   M   M   , in state    p  ∈  Q      p  Q    p\in Q   , with    a  ∈   Σ  ∪   {  ε  }        a    normal-Σ   ε      a\in\Sigma\cup\{\varepsilon\}   on the input and with    A  ∈  Γ      A  normal-Γ    A\in\Gamma   as topmost stack symbol, may read   a   a   a   , change the state to   q   q   q   , pop   A   A   A   , replacing it by pushing    α  ∈   Γ  *       α   superscript  normal-Γ      \alpha\in\Gamma^{*}   . The    (   Σ  ∪   {  ε  }    )      normal-Σ   ε     (\Sigma\cup\{\varepsilon\})   component of the transition relation is used to formalize that the PDA can either read a letter from the input, or proceed leaving the input untouched.  In many texts the transition relation is replaced by an (equivalent) formalization, where       δ    δ   \,\delta   is the transition function , mapping    Q  ×   (   Σ  ∪   {  ε  }    )   ×  Γ      Q    normal-Σ   ε    normal-Γ    Q\times(\Sigma\cup\{\varepsilon\})\times\Gamma   into finite subsets of    Q  ×   Γ  *       Q   superscript  normal-Γ      Q\times\Gamma^{*}   .   Here    δ   (  p  ,  a  ,  A  )       δ   p  a  A     \delta(p,a,A)   contains all possible actions in state   p   p   p   with   A   A   A   on the stack, while reading   a   a   a   on the input. One writes     (  q  ,  α  )   ∈   δ   (  p  ,  a  ,  A  )         q  α     δ   p  a  A      (q,\alpha)\in\delta(p,a,A)   for the function precisely when     (  p  ,  a  ,  A  ,  q  ,  α  )   ∈  δ       p  a  A  q  α   δ    (p,a,A,q,\alpha)\in\delta   for the relation. Note that finite in this definition is essential.  ''' Computations '''  In order to formalize the semantics of the pushdown automaton a description of the current situation is introduced. Any 3-tuple     (  p  ,  w  ,  β  )   ∈   Q  ×   Σ  *   ×   Γ  *         p  w  β     Q   superscript  normal-Σ     superscript  normal-Γ       (p,w,\beta)\in Q\times\Sigma^{*}\times\Gamma^{*}   is called an instantaneous description (ID) of   M   M   M   , which includes the current state, the part of the input tape that has not been read, and the contents of the stack (topmost symbol written first). The transition relation   δ   δ   \delta   defines the step-relation    ⊢  M     subscript  proves  M    \vdash_{M}   of   M   M   M   on instantaneous descriptions. For instruction     (  p  ,  a  ,  A  ,  q  ,  α  )   ∈  δ       p  a  A  q  α   δ    (p,a,A,q,\alpha)\in\delta   there exists a step     (  p  ,  a  x  ,  A  γ  )    ⊢  M    (  q  ,  x  ,  α  γ  )      fragments   fragments  normal-(  p  normal-,  a  x  normal-,  A  γ  normal-)    subscript  proves  M    fragments  normal-(  q  normal-,  x  normal-,  α  γ  normal-)     (p,ax,A\gamma)\vdash_{M}(q,x,\alpha\gamma)   , for every    x  ∈   Σ  *       x   superscript  normal-Σ      x\in\Sigma^{*}   and every    γ  ∈   Γ  *       γ   superscript  normal-Γ      \gamma\in\Gamma^{*}   .  In general pushdown automata are nondeterministic meaning that in a given instantaneous description    (  p  ,  w  ,  β  )     p  w  β    (p,w,\beta)   there may be several possible steps. Any of these steps can be chosen in a computation. With the above definition in each step always a single symbol (top of the stack) is popped, replacing it with as many symbols as necessary. As a consequence no step is defined when the stack is empty.  Computations of the pushdown automaton are sequences of steps. The computation starts in the initial state    q  0     subscript  q  0    q_{0}   with the initial stack symbol   Z   Z   Z   on the stack, and a string   w   w   w   on the input tape, thus with initial description    (   q  0   ,  w  ,  Z  )      subscript  q  0   w  Z    (q_{0},w,Z)   . There are two modes of accepting. The pushdown automaton either accepts by final state, which means after reading its input the automaton reaches an accepting state (in   F   F   F   ), or it accepts by empty stack (   ε   ε   \varepsilon   ), which means after reading its input the automaton empties its stack. The first acceptance mode uses the internal memory (state), the second the external memory (stack).  Formally one defines       L   (  M  )   =   {  w  ∈   Σ  *   |   (   q  0   ,  w  ,  Z  )    ⊢  M  *    (  f  ,  ε  ,  γ  )       fragments  L   fragments  normal-(  M  normal-)     fragments  normal-{  w    superscript  normal-Σ    normal-|   fragments  normal-(   subscript  q  0   normal-,  w  normal-,  Z  normal-)    superscript   subscript  proves  M      fragments  normal-(  f  normal-,  ε  normal-,  γ  normal-)      L(M)=\{w\in\Sigma^{*}|(q_{0},w,Z)\vdash_{M}^{*}(f,\varepsilon,\gamma)   with    f  ∈  F      f  F    f\in F   and    γ  ∈   Γ  *   }     fragments  γ    superscript  normal-Γ    normal-}    \gamma\in\Gamma^{*}\}   (final state)      N   (  M  )   =   {  w  ∈   Σ  *   |   (   q  0   ,  w  ,  Z  )    ⊢  M  *    (  q  ,  ε  ,  ε  )       fragments  N   fragments  normal-(  M  normal-)     fragments  normal-{  w    superscript  normal-Σ    normal-|   fragments  normal-(   subscript  q  0   normal-,  w  normal-,  Z  normal-)    superscript   subscript  proves  M      fragments  normal-(  q  normal-,  ε  normal-,  ε  normal-)      N(M)=\{w\in\Sigma^{*}|(q_{0},w,Z)\vdash_{M}^{*}(q,\varepsilon,\varepsilon)   with    q  ∈  Q  }     fragments  q   Q  normal-}    q\in Q\}   (empty stack)   Here    ⊢  M  *     superscript   subscript  proves  M      \vdash_{M}^{*}   represents the reflexive and transitive closure of the step relation    ⊢  M     subscript  proves  M    \vdash_{M}   meaning any number of consecutive steps (zero, one or more).  For each single pushdown automaton these two languages need to have no relation: they may be equal but usually this is not the case. A specification of the automaton should also include the intended mode of acceptance. Taken over all pushdown automata both acceptance conditions define the same family of languages.  Theorem. For each pushdown automaton   M   M   M   one may construct a pushdown automaton    M  ′     superscript  M  normal-′    M^{\prime}   such that     L   (  M  )    =   N   (   M  ′   )          L  M     N   superscript  M  normal-′      L(M)=N(M^{\prime})   , and vice versa, for each pushdown automaton   M   M   M   one may construct a pushdown automaton    M  ′     superscript  M  normal-′    M^{\prime}   such that     N   (  M  )    =   L   (   M  ′   )          N  M     L   superscript  M  normal-′      N(M)=L(M^{\prime})     Example  The following is the formal description of the PDA which recognizes the language    {    0  n    1  n    ∣   n  ≥  0   }     conditional-set     superscript  0  n    superscript  1  n      n  0     \{0^{n}1^{n}\mid n\geq 0\}   by final state:      M  =   (  Q  ,  Σ  ,  Γ  ,  δ  ,  p  ,  Z  ,  F  )       M   Q  normal-Σ  normal-Γ  δ  p  Z  F     M=(Q,\ \Sigma,\ \Gamma,\ \delta,\ p,\ Z,\ F)   , where  states:     Q  =   {  p  ,  q  ,  r  }       Q   p  q  r     Q=\{p,q,r\}     input alphabet:     Σ  =   {  0  ,  1  }       normal-Σ   0  1     \Sigma=\{0,1\}     stack alphabet:     Γ  =   {  A  ,  Z  }       normal-Γ   A  Z     \Gamma=\{A,Z\}     start state:      q  0   =  p       subscript  q  0   p    q_{0}=p     start stack symbol:    Z   Z   Z     accepting states:     F  =   {  r  }       F   r     F=\{r\}     The transition relation   δ   δ   \delta   consists of the following six instructions:      (  p  ,  0  ,  Z  ,  p  ,   A  Z   )     p  0  Z  p    A  Z     (p,0,Z,p,AZ)   ,    (  p  ,  0  ,  A  ,  p  ,   A  A   )     p  0  A  p    A  A     (p,0,A,p,AA)   ,    (  p  ,  ϵ  ,  Z  ,  q  ,  Z  )     p  ϵ  Z  q  Z    (p,\epsilon,Z,q,Z)   ,    (  p  ,  ϵ  ,  A  ,  q  ,  A  )     p  ϵ  A  q  A    (p,\epsilon,A,q,A)   ,    (  q  ,  1  ,  A  ,  q  ,  ϵ  )     q  1  A  q  ϵ    (q,1,A,q,\epsilon)   , and    (  q  ,  ϵ  ,  Z  ,  r  ,  Z  )     q  ϵ  Z  r  Z    (q,\epsilon,Z,r,Z)   .  In words, the first two instructions say that in state   p   p   p   any time the symbol   0   0    is read, one   A   A   A   is pushed onto the stack. Pushing symbol   A   A   A   on top of another   A   A   A   is formalized as replacing top   A   A   A   by    A  A      A  A    AA   (and similarly for pushing symbol   A   A   A   on top of a   Z   Z   Z   ).  The third and fourth instructions say that, at any moment the automaton may move from state   p   p   p   to state   q   q   q   .  The fifth instruction says that in state   q   q   q   , for each symbol   1   1   1   read, one   A   A   A   is popped.  Finally, the sixth instruction says that the machine may move from state   q   q   q   to accepting state   r   r   r   only when the stack consists of a single   Z   Z   Z   .  There seems to be no generally used representation for PDA. Here we have depicted the instruction    (  p  ,  a  ,  A  ,  q  ,  α  )     p  a  A  q  α    (p,a,A,q,\alpha)   by an edge from state   p   p   p   to state   q   q   q   labelled by    a  ;   A  /  α      a    A  α     a;A/\alpha   (read   a   a   a   ; replace   A   A   A   by   α   α   \alpha   ).  Understanding the computation process  The following illustrates how the above PDA computes on different input strings. The subscript   M   M   M   from the step symbol   ⊢   proves   \vdash   is here omitted.  (a) Input string = 0011. There are various computations, depending on the moment the move from state   p   p   p   to state   q   q   q   is made. Only one of these is accepting.   (i)     (  p  ,  0011  ,  Z  )   ⊢   (  q  ,  0011  ,  Z  )   ⊢   (  r  ,  0011  ,  Z  )        proves   p  0011  Z    q  0011  Z     proves     r  0011  Z      (p,0011,Z)\vdash(q,0011,Z)\vdash(r,0011,Z)   . The final state is accepting, but the input is not accepted this way as it has not been read.    (ii)     (  p  ,  0011  ,  Z  )   ⊢   (  p  ,  011  ,   A  Z   )   ⊢   (  q  ,  011  ,   A  Z   )        proves   p  0011  Z    p  011    A  Z      proves     q  011    A  Z       (p,0011,Z)\vdash(p,011,AZ)\vdash(q,011,AZ)   . No further steps possible.    (iii)     (  p  ,  0011  ,  Z  )   ⊢   (  p  ,  011  ,   A  Z   )   ⊢   (  p  ,  11  ,   A  A  Z   )   ⊢   (  q  ,  11  ,   A  A  Z   )        proves   p  0011  Z    p  011    A  Z      proves     p  11    A  A  Z      proves     q  11    A  A  Z       (p,0011,Z)\vdash(p,011,AZ)\vdash(p,11,AAZ)\vdash(q,11,AAZ)       ⊢   (  q  ,  1  ,  A  Z  )   ⊢   (  q  ,  ϵ  ,  Z  )      fragments  proves   fragments  normal-(  q  normal-,  1  normal-,  A  Z  normal-)   proves   fragments  normal-(  q  normal-,  ϵ  normal-,  Z  normal-)     \vdash(q,1,AZ)\vdash(q,\epsilon,Z)        ⊢   (  r  ,  ϵ  ,  Z  )      proves  absent   r  ϵ  Z     \vdash(r,\epsilon,Z)   . Accepting computation: ends in accepting state, while complete input has been read.   (b) Input string = 00111. Again there are various computations. None of these is accepting.   (i)     (  p  ,  00111  ,  Z  )   ⊢   (  q  ,  00111  ,  Z  )   ⊢   (  r  ,  00111  ,  Z  )        proves   p  00111  Z    q  00111  Z     proves     r  00111  Z      (p,00111,Z)\vdash(q,00111,Z)\vdash(r,00111,Z)   . The final state is accepting, but the input is not accepted this way as it has not been read.    (ii)     (  p  ,  00111  ,  Z  )   ⊢   (  p  ,  0111  ,   A  Z   )   ⊢   (  q  ,  0111  ,   A  Z   )        proves   p  00111  Z    p  0111    A  Z      proves     q  0111    A  Z       (p,00111,Z)\vdash(p,0111,AZ)\vdash(q,0111,AZ)   . No further steps possible.    (iii)     (  p  ,  00111  ,  Z  )   ⊢   (  p  ,  0111  ,   A  Z   )   ⊢   (  p  ,  111  ,   A  A  Z   )   ⊢   (  q  ,  111  ,   A  A  Z   )        proves   p  00111  Z    p  0111    A  Z      proves     p  111    A  A  Z      proves     q  111    A  A  Z       (p,00111,Z)\vdash(p,0111,AZ)\vdash(p,111,AAZ)\vdash(q,111,AAZ)       ⊢   (  q  ,  11  ,  A  Z  )   ⊢   (  q  ,  1  ,  Z  )      fragments  proves   fragments  normal-(  q  normal-,  11  normal-,  A  Z  normal-)   proves   fragments  normal-(  q  normal-,  1  normal-,  Z  normal-)     \vdash(q,11,AZ)\vdash(q,1,Z)        ⊢   (  r  ,  1  ,  Z  )      proves  absent   r  1  Z     \vdash(r,1,Z)   . The final state is accepting, but the input is not accepted this way as it has not been (completely) read.   PDA and context-free languages  Every context-free grammar can be transformed into an equivalent nondeterministic pushdown automaton. The derivation process of the grammar is simulated in a leftmost way. Where the grammar rewrites a nonterminal, the PDA takes the topmost nonterminal from its stack and replaces it by the right-hand part of a grammatical rule (expand). Where the grammar generates a terminal symbol, the PDA reads a symbol from input when it is the topmost symbol on the stack (match). In a sense the stack of the PDA contains the unprocessed data of the grammar, corresponding to a pre-order traversal of a derivation tree.  Technically, given a context-free grammar, the PDA is constructed as follows.       (  1  ,  ε  ,  A  ,  1  ,  α  )     1  ε  A  1  α    (1,\varepsilon,A,1,\alpha)   for each rule    A  →  α     normal-→  A  α    A\to\alpha   ( expand )      (  1  ,  a  ,  a  ,  1  ,  ε  )     1  a  a  1  ε    (1,a,a,1,\varepsilon)   for each terminal symbol   a   a   a   ( match )   As a result we obtain a single state pushdown automata, the state here is   1   1   1   , accepting the context-free language by empty stack. Its initial stack symbol equals the axiom of the context-free grammar.  The converse, finding a grammar for a given PDA, is not that easy. The trick is to code two states of the PDA into the nonterminals of the grammar.  Theorem. For each pushdown automaton   M   M   M   one may construct a context-free grammar   G   G   G   such that     N   (  M  )    =   L   (  G  )          N  M     L  G     N(M)=L(G)   .  Generalized pushdown automaton (GPDA)  A GPDA is a PDA which writes an entire string of some known length to the stack or removes an entire string from the stack in one step.  A GPDA is formally defined as a 6-tuple:      M  =   (  Q  ,  Σ  ,  Γ  ,  δ  ,   q  0   ,  F  )       M   Q  normal-Σ  normal-Γ  δ   subscript  q  0   F     M=(Q,\ \Sigma,\ \Gamma,\ \delta,\ q_{0},\ F)   where Q,    Σ    normal-Σ   \Sigma\,   ,    Γ    normal-Γ   \Gamma\,   , q 0 and F are defined the same way as a PDA.      δ    δ   \,\delta        Q  ×   Σ  ϵ   ×   Γ  *    ⟶   P   (   Q  ×   Γ  *    )       normal-⟶    Q   subscript  normal-Σ  ϵ    superscript  normal-Γ       P    Q   superscript  normal-Γ        Q\times\Sigma_{\epsilon}\times\Gamma^{*}\longrightarrow P(Q\times\Gamma^{*})   is the transition function.  Computation rules for a GPDA are the same as a PDA except that the a i+1 's and b i+1 's are now strings instead of symbols.  GPDA's and PDA's are equivalent in that if a language is recognized by a PDA, it is also recognized by a GPDA and vice versa.  One can formulate an analytic proof for the equivalence of GPDA's and PDA's using the following simulation:  Let   δ   δ   \delta   (q 1 , w, x 1 x 2 ...x m )   ⟶   normal-⟶   \longrightarrow   (q 2 , y 1 y 2 ...y n ) be a transition of the GPDA  where      q  1   ,   q  2    ∈  Q        subscript  q  1    subscript  q  2    Q    q_{1},q_{2}\in Q   ,    w  ∈   Σ  ϵ       w   subscript  normal-Σ  ϵ     w\in\Sigma_{\epsilon}   ,      x  1   ,   x  2   ,  …  ,   x  m    ∈   Γ  *         subscript  x  1    subscript  x  2   normal-…   subscript  x  m     superscript  normal-Γ      x_{1},x_{2},\ldots,x_{m}\in\Gamma^{*}   ,    m  ≥  0      m  0    m\geq 0   ,      y  1   ,   y  2   ,  …  ,   y  n    ∈   Γ  *         subscript  y  1    subscript  y  2   normal-…   subscript  y  n     superscript  normal-Γ      y_{1},y_{2},\ldots,y_{n}\in\Gamma^{*}   ,    n  ≥  0      n  0    n\geq 0   .  Construct the following transitions for the PDA:        δ    ′      superscript  δ   normal-′     \delta^{{}^{\prime}}   (q 1 , w, x 1 )   ⟶   normal-⟶   \longrightarrow   (p 1 ,   ϵ   ϵ   \epsilon   )           δ    ′      superscript  δ   normal-′     \delta^{{}^{\prime}}   (p 1 ,   ϵ   ϵ   \epsilon   , x 2 )   ⟶   normal-⟶   \longrightarrow   (p 2 ,   ϵ   ϵ   \epsilon   )          ⋮   normal-⋮   \vdots              δ    ′      superscript  δ   normal-′     \delta^{{}^{\prime}}   (p m-1 ,   ϵ   ϵ   \epsilon   , x m )   ⟶   normal-⟶   \longrightarrow   (p m ,   ϵ   ϵ   \epsilon   )           δ    ′      superscript  δ   normal-′     \delta^{{}^{\prime}}   (p m ,   ϵ   ϵ   \epsilon   ,   ϵ   ϵ   \epsilon   )   ⟶   normal-⟶   \longrightarrow   (p m+1 , y n )           δ    ′      superscript  δ   normal-′     \delta^{{}^{\prime}}   (p m+1 ,   ϵ   ϵ   \epsilon   ,   ϵ   ϵ   \epsilon   )   ⟶   normal-⟶   \longrightarrow   (p m+2 , y n-1 )          ⋮   normal-⋮   \vdots              δ    ′      superscript  δ   normal-′     \delta^{{}^{\prime}}   (p m+n-1 ,   ϵ   ϵ   \epsilon   ,   ϵ   ϵ   \epsilon   )   ⟶   normal-⟶   \longrightarrow   (q 2 , y 1 )     Stack automaton  As a generalization of pushdown automata, Ginsburg, Greibach, and Harrison (1967) investigated stack automata , which may additionally step left or right in the input string (surrounded by special endmarker symbols to prevent slipping out), and step up or down in the stack in read-only mode. 3 4 A stack automaton is called nonerasing if it never pops from the stack. The class of languages accepted by nondeterministic, nonerasing stack automata is NSPACE ( n 2 ), which is a superset of the context-sensitive languages . 5 The class of languages accepted by deterministic, nonerasing stack automata is DSPACE ( n ⋅log( n )). 6  See also   Stack machine  Context-free grammar  Finite automaton  Counter automaton   References      Section 2.2: Pushdown Automata, pp. 101–114.  Jean-Michel Autebert, Jean Berstel, Luc Boasson, Context-Free Languages and Push-Down Automata , in: G. Rozenberg, A. Salomaa (eds.), Handbook of Formal Languages, Vol. 1, Springer-Verlag, 1997, 111-174.   External links   JFLAP , simulator for several types of automata including nondeterministic pushdown automata   "  Category:Automata theory  Category:Models of computation      Here: Sect.6.4.3, p.249: The set of even-length palindromes of bits can't be recognized by a deterministic PDA, but is a context-free language , with the grammar  S → ε | 0 S 0 | 1 S 1. ↩  ↩  ↩  ↩      