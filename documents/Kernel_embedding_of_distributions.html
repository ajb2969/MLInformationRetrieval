<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="717">Kernel embedding of distributions</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Kernel embedding of distributions</h1><hr/>

<p>In <a href="machine_learning" title="wikilink">machine learning</a>, the <strong>kernel embedding of distributions</strong> (also called the <strong>kernel mean</strong> or <strong>mean map</strong>) comprises a class of <a class="uri" href="nonparametric" title="wikilink">nonparametric</a> methods in which a <a href="probability_distribution" title="wikilink">probability distribution</a> is represented as an element of a <a href="reproducing_kernel_Hilbert_space" title="wikilink">reproducing kernel Hilbert space</a> (RKHS).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> A generalization of the individual data-point feature mapping done in classical <a href="kernel_methods" title="wikilink">kernel methods</a>, the embedding of distributions into infinite-dimensional feature spaces can preserve all of the statistical features of arbitrary distributions, while allowing one to compare and manipulate distributions using Hilbert space operations such as <a href="inner_product" title="wikilink">inner products</a>, distances, <a href="projection_(linear_algebra)" title="wikilink">projections</a>, <a href="linear_transformation" title="wikilink">linear transformations</a>, and <a href="spectral_theory" title="wikilink">spectral analysis</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> This <a href="machine_learning" title="wikilink">learning</a> framework is very general and can be applied to distributions over any space 

<math display="inline" id="Kernel_embedding_of_distributions:0">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 on which a sensible <a href="kernel_function" title="wikilink">kernel function</a> (measuring similarity between elements of 

<math display="inline" id="Kernel_embedding_of_distributions:1">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

) may be defined. For example, various kernels have been proposed for learning from data which are: <a href="Vector_(mathematics_and_physics)" title="wikilink">vectors</a> in 

<math display="inline" id="Kernel_embedding_of_distributions:2">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mi>d</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{d}
  </annotation>
 </semantics>
</math>

, discrete classes/categories, <a href="string_(computer_science)" title="wikilink">strings</a>, <a href="graph_(mathematics)" title="wikilink">graphs</a>/<a href="network_theory" title="wikilink">networks</a>, images, <a href="time_series" title="wikilink">time series</a>, <a href="manifold" title="wikilink">manifolds</a>, <a href="dynamical_systems" title="wikilink">dynamical systems</a>, and other structured objects.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The theory behind kernel embeddings of distributions has been primarily developed by <a href="http://alex.smola.org/">Alex Smola</a>, <a href="http://www.cc.gatech.edu/~lsong/">Le Song</a>, <a href="http://www.gatsby.ucl.ac.uk/~gretton/">Arthur Gretton</a>, and <a href="Bernhard_Schölkopf" title="wikilink">Bernhard Schölkopf</a>.</p>

<p>The analysis of distributions is fundamental in <a href="machine_learning" title="wikilink">machine learning</a> and <a class="uri" href="statistics" title="wikilink">statistics</a>, and many algorithms in these fields rely on information theoretic approaches such as <a class="uri" href="entropy" title="wikilink">entropy</a>, <a href="mutual_information" title="wikilink">mutual information</a>, or <a href="Kullback–Leibler_divergence" title="wikilink">Kullback–Leibler divergence</a>. However, to estimate these quantities, one must first either perform density estimation, or employ sophisticated space-partitioning/bias-correction strategies which are typically infeasible for high-dimensional data.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Commonly, methods for modeling complex distributions rely on parametric assumptions that may be unfounded or computationally challenging (e.g. <a href="Mixture_model#Gaussian_mixture_model" title="wikilink">Gaussian mixture models</a>), while nonparametric methods like <a href="kernel_density_estimation" title="wikilink">kernel density estimation</a> (Note: the smoothing kernels in this context have a different interpretation than the kernels discussed here) or <a href="characteristic_function_(probability_theory)" title="wikilink">characteristic function</a> representation (via the <a href="Fourier_transform" title="wikilink">Fourier transform</a> of the distribution) break down in high-dimensional settings.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Methods based on the kernel embedding of distributions sidestep these problems and also possess the following advantages:<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<ol>
<li>Data may be modeled without restrictive assumptions about the form of the distributions and relationships between variables</li>
<li>Intermediate density estimation is not needed</li>
<li>Practitioners may specify the properties of a distribution most relevant for their problem (incorporating prior knowledge via choice of the kernel)</li>
<li>If a <em>characteristic</em> kernel is used, then the embedding can uniquely preserve all information about a distribution, while thanks to the <a href="kernel_trick" title="wikilink">kernel trick</a>, computations on the potentially infinite-dimensional RKHS can be implemented in practice as simple <a href="Gramian_matrix" title="wikilink">Gram</a> matrix operations</li>
<li>Dimensionality-independent rates of convergence for the empirical kernel mean (estimated using samples from the distribution) to the kernel embedding of the true underlying distribution can be proven.</li>
<li>Learning algorithms based on this framework exhibit good generalization ability and finite sample convergence, while often being simpler and more effective than information theoretic methods</li>
</ol>

<p>Thus, learning via the kernel embedding of distributions offers a principled drop-in replacement for information theoretic approaches and is a framework which not only subsumes many popular methods in machine learning and statistics as special cases, but also can lead to entirely new learning algorithms.</p>
<h2 id="definitions">Definitions</h2>

<p>Let 

<math display="inline" id="Kernel_embedding_of_distributions:3">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>


 denote a random variable with domain 

<math display="inline" id="Kernel_embedding_of_distributions:4">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 and distribution 

<math display="inline" id="Kernel_embedding_of_distributions:5">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X)
  </annotation>
 </semantics>
</math>

. Given a kernel 

<math display="inline" id="Kernel_embedding_of_distributions:6">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 on 

<math display="inline" id="Kernel_embedding_of_distributions:7">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mo>×</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega\times\Omega
  </annotation>
 </semantics>
</math>

, the <a href="Reproducing_kernel_Hilbert_space#Moore-Aronszajn_Theorem" title="wikilink">Moore-Aronszajn Theorem</a> asserts the existence of a RKHS 

<math display="inline" id="Kernel_embedding_of_distributions:8">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>


 (a <a href="Hilbert_space" title="wikilink">Hilbert space</a> of functions 

<math display="inline" id="Kernel_embedding_of_distributions:9">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi mathvariant="normal">Ω</mi>
    <mo>↦</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <ci>normal-Ω</ci>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\Omega\mapsto\mathbb{R}
  </annotation>
 </semantics>
</math>

 equipped with inner products 

<math display="inline" id="Kernel_embedding_of_distributions:10">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mo>⋅</mo>
    <mo>,</mo>
    <mo>⋅</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <list>
     <ci>normal-⋅</ci>
     <ci>normal-⋅</ci>
    </list>
    <ci>ℋ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\cdot,\cdot\rangle_{\mathcal{H}}
  </annotation>
 </semantics>
</math>

 and norms 

<math display="inline" id="Kernel_embedding_of_distributions:11">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mo stretchy="false">|</mo>
   <mo>⋅</mo>
   <mo stretchy="false">|</mo>
   <msub>
    <mo stretchy="false">|</mo>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <ci>normal-|</ci>
    <ci>normal-⋅</ci>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-|</ci>
     <ci>ℋ</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ||\cdot||_{\mathcal{H}}
  </annotation>
 </semantics>
</math>

) in which the element 

<math display="inline" id="Kernel_embedding_of_distributions:12">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>k</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mo>⋅</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>normal-⋅</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ k(x,\cdot)
  </annotation>
 </semantics>
</math>

 satisfies the reproducing property 

<math display="inline" id="Kernel_embedding_of_distributions:13">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>f</mi>
      <mo>,</mo>
      <mrow>
       <mi>k</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mo>⋅</mo>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi class="ltx_font_mathcaligraphic">ℋ</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>∀</mo>
      <mi>f</mi>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>x</mi>
    </mrow>
    <mo>∈</mo>
    <mi mathvariant="normal">Ω</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <list>
        <ci>f</ci>
        <apply>
         <times></times>
         <ci>k</ci>
         <interval closure="open">
          <ci>x</ci>
          <ci>normal-⋅</ci>
         </interval>
        </apply>
       </list>
       <ci>ℋ</ci>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <ci>f</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <ci>ℋ</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>x</ci>
     </apply>
     <ci>normal-Ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle f,k(x,\cdot)\rangle_{\mathcal{H}}=f(x)\ \forall f\in\mathcal{H},%
\forall x\in\Omega
  </annotation>
 </semantics>
</math>


. One may alternatively consider 

<math display="inline" id="Kernel_embedding_of_distributions:14">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>k</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mo>⋅</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>normal-⋅</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ k(x,\cdot)
  </annotation>
 </semantics>
</math>

 an implicit feature mapping 

<math display="inline" id="Kernel_embedding_of_distributions:15">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(x)
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Kernel_embedding_of_distributions:16">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Kernel_embedding_of_distributions:17">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>

 (which is therefore also called the feature space), so that 

<math display="inline" id="Kernel_embedding_of_distributions:18">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="5pt" width="+5pt">
     <mi>k</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <msup>
      <mi>x</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>x</mi>
        <mo>′</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>k</ci>
     <interval closure="open">
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>normal-′</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <list>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </list>
     <ci>ℋ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ k(x,x^{\prime})=\langle\phi(x),\phi(x^{\prime})\rangle_{\mathcal{H}}
  </annotation>
 </semantics>
</math>


 can be viewed as a measure of similarity between points 

<math display="inline" id="Kernel_embedding_of_distributions:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>,</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
    </list>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,x^{\prime}\in\Omega
  </annotation>
 </semantics>
</math>

. While the similarity measure is linear in the feature space, it may be highly nonlinear in the original space depending on the choice of kernel.</p>
<h3 id="kernel-embedding">Kernel embedding</h3>

<p>The kernel embedding of the distribution 

<math display="inline" id="Kernel_embedding_of_distributions:20">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X)
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Kernel_embedding_of_distributions:21">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>

 (also called the <strong>kernel mean</strong> or <strong>mean map</strong>) is given by:<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:22">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mi>X</mi>
   </msub>
   <mo>:=</mo>
   <mrow>
    <msub>
     <mi>𝔼</mi>
     <mi>X</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>k</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo>,</mo>
       <mo>⋅</mo>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝔼</mi>
     <mi>X</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi mathvariant="normal">Ω</mi>
    </msub>
    <mrow>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">d</mi>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝔼</ci>
       <ci>X</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>k</ci>
        <interval closure="open">
         <ci>X</ci>
         <ci>normal-⋅</ci>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝔼</ci>
       <ci>X</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>ϕ</ci>
        <ci>X</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Ω</ci>
      </apply>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <ci>x</ci>
       <ci>normal-d</ci>
       <ci>P</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{X}:=\mathbb{E}_{X}[k(X,\cdot)]=\mathbb{E}_{X}[\phi(X)]=\int_{\Omega}\phi(%
x)\ \mathrm{d}P(x)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>A kernel is <em>characteristic</em> if the mean embedding 

<math display="inline" id="Kernel_embedding_of_distributions:23">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mtext>family of distributions over</mtext>
      <mi mathvariant="normal">Ω</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>↦</mo>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>μ</ci>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <set>
      <apply>
       <times></times>
       <mtext>family of distributions over</mtext>
       <ci>normal-Ω</ci>
      </apply>
     </set>
     <ci>ℋ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu:\{\text{family of distributions over }\Omega\}\mapsto\mathcal{H}
  </annotation>
 </semantics>
</math>


 is injective.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Each distribution can thus be uniquely represented in the RKHS and all statistical features of distributions are preserved by the kernel embedding if a characteristic kernel is used.</p>
<h3 id="empirical-kernel-embedding">Empirical kernel embedding</h3>

<p>Given 

<math display="inline" id="Kernel_embedding_of_distributions:24">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 training examples 

<math display="inline" id="Kernel_embedding_of_distributions:25">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x_{1},\dots,x_{n}\}
  </annotation>
 </semantics>
</math>

 drawn <a href="Independent_and_identically_distributed_random_variables" title="wikilink">independently and identically distributed</a> (i.i.d.) from 

<math display="inline" id="Kernel_embedding_of_distributions:26">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, the kernel embedding of 

<math display="inline" id="Kernel_embedding_of_distributions:27">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 can be empirically estimated as</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:28">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>μ</mi>
     <mo>^</mo>
    </mover>
    <mi>X</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>n</mi>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>μ</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\mu}_{X}=\frac{1}{n}\sum_{i=1}^{n}\phi(x_{i})
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
</dl>
<h3 id="joint-distribution-embedding">Joint distribution embedding</h3>

<p>If 

<math display="inline" id="Kernel_embedding_of_distributions:29">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 denotes another random variable (for simplicity, assume the domain of 

<math display="inline" id="Kernel_embedding_of_distributions:30">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 is also 

<math display="inline" id="Kernel_embedding_of_distributions:31">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 with the same kernel 

<math display="inline" id="Kernel_embedding_of_distributions:32">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 which satisfies 

<math display="inline" id="Kernel_embedding_of_distributions:33">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>ϕ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⊗</mo>
      <mi>ϕ</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>ϕ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>x</mi>
         <mo>′</mo>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⊗</mo>
      <mi>ϕ</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>y</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>k</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <msup>
        <mi>x</mi>
        <mo>′</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⊗</mo>
     <mi>k</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>,</mo>
     <msup>
      <mi>y</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <ci>ϕ</ci>
        <ci>x</ci>
       </apply>
       <ci>ϕ</ci>
      </apply>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <ci>ϕ</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
       <ci>ϕ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </list>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <times></times>
       <ci>k</ci>
       <interval closure="open">
        <ci>x</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <ci>normal-′</ci>
        </apply>
       </interval>
      </apply>
      <ci>k</ci>
     </apply>
     <interval closure="open">
      <ci>y</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>normal-′</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\phi(x)\otimes\phi(y),\phi(x^{\prime})\otimes\phi(y^{\prime})\rangle=k(%
x,x^{\prime})\otimes k(y,y^{\prime})
  </annotation>
 </semantics>
</math>


), then the <a href="Joint_probability_distribution" title="wikilink">joint distribution</a> 

<math display="inline" id="Kernel_embedding_of_distributions:34">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <interval closure="open">
     <ci>X</ci>
     <ci>Y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X,Y)
  </annotation>
 </semantics>
</math>

 can be mapped into a <a href="tensor_product" title="wikilink">tensor product</a> feature space 

<math display="inline" id="Kernel_embedding_of_distributions:35">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   <mo>⊗</mo>
   <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <ci>ℋ</ci>
    <ci>ℋ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}\otimes\mathcal{H}
  </annotation>
 </semantics>
</math>

 via <a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:36">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mrow>
     <mi>X</mi>
     <mi>Y</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝔼</mi>
     <mrow>
      <mi>X</mi>
      <mi>Y</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>ϕ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>X</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>⊗</mo>
       <mi>ϕ</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mi mathvariant="normal">Ω</mi>
      <mo>×</mo>
      <mi mathvariant="normal">Ω</mi>
     </mrow>
    </msub>
    <mrow>
     <mrow>
      <mrow>
       <mi>ϕ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⊗</mo>
      <mi>ϕ</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">d</mi>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒞</ci>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>Y</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝔼</ci>
       <apply>
        <times></times>
        <ci>X</ci>
        <ci>Y</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="latexml">tensor-product</csymbol>
         <apply>
          <times></times>
          <ci>ϕ</ci>
          <ci>X</ci>
         </apply>
         <ci>ϕ</ci>
        </apply>
        <ci>Y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <times></times>
        <ci>normal-Ω</ci>
        <ci>normal-Ω</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <apply>
         <times></times>
         <ci>ϕ</ci>
         <ci>x</ci>
        </apply>
        <ci>ϕ</ci>
       </apply>
       <ci>y</ci>
       <ci>normal-d</ci>
       <ci>P</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}_{XY}=\mathbb{E}_{XY}[\phi(X)\otimes\phi(Y)]=\int_{\Omega\times%
\Omega}\phi(x)\otimes\phi(y)\ \mathrm{d}P(x,y)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>By the equivalence between a <a class="uri" href="tensor" title="wikilink">tensor</a> and a <a href="linear_map" title="wikilink">linear map</a>, this joint embedding may be interpreted as an uncentered <a class="uri" href="cross-covariance" title="wikilink">cross-covariance</a> operator 

<math display="inline" id="Kernel_embedding_of_distributions:37">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mrow>
     <mi>X</mi>
     <mi>Y</mi>
    </mrow>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
    <mo>↦</mo>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝒞</ci>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <ci>ℋ</ci>
     <ci>ℋ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}_{XY}:\mathcal{H}\mapsto\mathcal{H}
  </annotation>
 </semantics>
</math>

 from which the cross-covariance of mean-zero functions 

<math display="inline" id="Kernel_embedding_of_distributions:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>,</mo>
    <mi>g</mi>
   </mrow>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>f</ci>
     <ci>g</ci>
    </list>
    <ci>ℋ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f,g\in\mathcal{H}
  </annotation>
 </semantics>
</math>


 can be computed as <a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:39">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mtext>Cov</mtext>
     <mrow>
      <mi>X</mi>
      <mi>Y</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <msub>
     <mi>𝔼</mi>
     <mrow>
      <mi>X</mi>
      <mi>Y</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>f</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi class="ltx_font_mathcaligraphic">𝒞</mi>
       <mrow>
        <mi>X</mi>
        <mi>Y</mi>
       </mrow>
      </msub>
      <mi>g</mi>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>f</mi>
      <mo>⊗</mo>
      <mi>g</mi>
     </mrow>
     <mo>,</mo>
     <msub>
      <mi class="ltx_font_mathcaligraphic">𝒞</mi>
      <mrow>
       <mi>X</mi>
       <mi>Y</mi>
      </mrow>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">ℋ</mi>
     <mo>⊗</mo>
     <mi class="ltx_font_mathcaligraphic">ℋ</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>Cov</mtext>
       <apply>
        <times></times>
        <ci>X</ci>
        <ci>Y</ci>
       </apply>
      </apply>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>X</ci>
       </apply>
       <apply>
        <times></times>
        <ci>g</ci>
        <ci>Y</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝔼</ci>
       <apply>
        <times></times>
        <ci>X</ci>
        <ci>Y</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>X</ci>
        <ci>g</ci>
        <ci>Y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <ci>f</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝒞</ci>
         <apply>
          <times></times>
          <ci>X</ci>
          <ci>Y</ci>
         </apply>
        </apply>
        <ci>g</ci>
       </apply>
      </list>
      <ci>ℋ</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>f</ci>
        <ci>g</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝒞</ci>
        <apply>
         <times></times>
         <ci>X</ci>
         <ci>Y</ci>
        </apply>
       </apply>
      </list>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>ℋ</ci>
       <ci>ℋ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Cov}_{XY}(f(X),g(Y)):=\mathbb{E}_{XY}[f(X)g(Y)]=\langle f,\mathcal{C}_{%
XY}g\rangle_{\mathcal{H}}=\langle f\otimes g,\mathcal{C}_{XY}\rangle_{\mathcal%
{H}\otimes\mathcal{H}}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Given 

<math display="inline" id="Kernel_embedding_of_distributions:40">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 pairs of training examples 

<math display="inline" id="Kernel_embedding_of_distributions:41">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
    <ci>normal-…</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </interval>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(x_{1},y_{1}),\dots,(x_{n},y_{n})\}
  </annotation>
 </semantics>
</math>

 drawn i.i.d. from 

<math display="inline" id="Kernel_embedding_of_distributions:42">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, we can also empirically estimate the joint distribution kernel embedding via</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:43">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     <mo>^</mo>
    </mover>
    <mrow>
     <mi>X</mi>
     <mi>Y</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>n</mi>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <mrow>
       <mrow>
        <mi>ϕ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>⊗</mo>
       <mi>ϕ</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>𝒞</ci>
     </apply>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <apply>
         <times></times>
         <ci>ϕ</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <ci>ϕ</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\mathcal{C}}_{XY}=\frac{1}{n}\sum_{i=1}^{n}\phi(x_{i})\otimes\phi(y_{%
i})
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
</dl>
<h3 id="conditional-distribution-embedding">Conditional distribution embedding</h3>

<p>Given a <a href="conditional_distribution" title="wikilink">conditional distribution</a> 

<math display="inline" id="Kernel_embedding_of_distributions:44">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo>∣</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(Y\mid X)
  </annotation>
 </semantics>
</math>

, one can define the corresponding RKHS embedding as <a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:45">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mrow>
     <mi>Y</mi>
     <mo>∣</mo>
     <mi>x</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>𝔼</mi>
    <mrow>
     <mi>Y</mi>
     <mo>∣</mo>
     <mi>x</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mo largeop="true" symmetric="true">∫</mo>
    <mi mathvariant="normal">Ω</mi>
   </msub>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="normal">d</mi>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>∣</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">Y</csymbol>
      <ci>normal-∣</ci>
      <csymbol cd="unknown">x</csymbol>
     </cerror>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝔼</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">Y</csymbol>
      <ci>normal-∣</ci>
      <csymbol cd="unknown">x</csymbol>
     </cerror>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">Y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <int></int>
     <ci>normal-Ω</ci>
    </apply>
    <csymbol cd="unknown">ϕ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{Y\mid x}=\mathbb{E}_{Y\mid x}[\phi(Y)]=\int_{\Omega}\phi(y)\ \mathrm{d}P(%
y\mid x)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Note that the embedding of 

<math display="inline" id="Kernel_embedding_of_distributions:46">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo>∣</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(Y\mid X)
  </annotation>
 </semantics>
</math>

 thus defines a family of points in the RKHS indexed by the values 

<math display="inline" id="Kernel_embedding_of_distributions:47">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 taken by conditioning variable 

<math display="inline" id="Kernel_embedding_of_distributions:48">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>


. By fixing 

<math display="inline" id="Kernel_embedding_of_distributions:49">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 to a particular value, we obtain a single element in 

<math display="inline" id="Kernel_embedding_of_distributions:50">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>

, and thus it is natural to define the operator</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:51">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mrow>
     <mi>Y</mi>
     <mo>∣</mo>
     <mi>X</mi>
    </mrow>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
    <mo>↦</mo>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝒞</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">Y</csymbol>
      <ci>normal-∣</ci>
      <csymbol cd="unknown">X</csymbol>
     </cerror>
    </apply>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <ci>ℋ</ci>
     <ci>ℋ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}_{Y\mid X}:\mathcal{H}\mapsto\mathcal{H}
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Kernel_embedding_of_distributions:52">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mrow>
     <mi>Y</mi>
     <mo>∣</mo>
     <mi>X</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     <mrow>
      <mi>Y</mi>
      <mi>X</mi>
     </mrow>
    </msub>
    <msubsup>
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     <mrow>
      <mi>X</mi>
      <mi>X</mi>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝒞</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">Y</csymbol>
      <ci>normal-∣</ci>
      <csymbol cd="unknown">X</csymbol>
     </cerror>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒞</ci>
      <apply>
       <times></times>
       <ci>Y</ci>
       <ci>X</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝒞</ci>
       <apply>
        <times></times>
        <ci>X</ci>
        <ci>X</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}_{Y\mid X}=\mathcal{C}_{YX}\mathcal{C}_{XX}^{-1}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>which given the feature mapping of 

<math display="inline" id="Kernel_embedding_of_distributions:53">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


 outputs the conditional embedding of 

<math display="inline" id="Kernel_embedding_of_distributions:54">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 given 

<math display="inline" id="Kernel_embedding_of_distributions:55">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=x
  </annotation>
 </semantics>
</math>

. Assuming that for all 

<math display="inline" id="Kernel_embedding_of_distributions:56">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mo>∈</mo>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   </mrow>
   <mo rspace="7.5pt">:</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>𝔼</mi>
      <mrow>
       <mi>Y</mi>
       <mo>∣</mo>
       <mi>X</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>Y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <in></in>
     <ci>g</ci>
     <ci>ℋ</ci>
    </apply>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝔼</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">Y</csymbol>
        <ci>normal-∣</ci>
        <csymbol cd="unknown">X</csymbol>
       </cerror>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>g</ci>
        <ci>Y</ci>
       </apply>
      </apply>
     </apply>
     <ci>ℋ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\in\mathcal{H}:\ \mathbb{E}_{Y\mid X}[g(Y)]\in\mathcal{H}
  </annotation>
 </semantics>
</math>

, it can be shown that <a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:57">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mrow>
     <mi>Y</mi>
     <mo>∣</mo>
     <mi>x</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     <mrow>
      <mi>Y</mi>
      <mo>∣</mo>
      <mi>X</mi>
     </mrow>
    </msub>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">Y</csymbol>
      <ci>normal-∣</ci>
      <csymbol cd="unknown">x</csymbol>
     </cerror>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒞</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">Y</csymbol>
       <ci>normal-∣</ci>
       <csymbol cd="unknown">X</csymbol>
      </cerror>
     </apply>
     <ci>ϕ</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{Y\mid x}=\mathcal{C}_{Y\mid X}\phi(x)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>This assumption is always true for finite domains with characteristic kernels, but may not necessarily hold for continuous domains.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Nevertheless, even in cases where the assumption fails, 

<math display="inline" id="Kernel_embedding_of_distributions:58">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mrow>
     <mi>Y</mi>
     <mo>∣</mo>
     <mi>X</mi>
    </mrow>
   </msub>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝒞</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">Y</csymbol>
      <ci>normal-∣</ci>
      <csymbol cd="unknown">X</csymbol>
     </cerror>
    </apply>
    <ci>ϕ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}_{Y\mid X}\phi(x)
  </annotation>
 </semantics>
</math>


 may still be used to approximate the conditional kernel embedding 

<math display="inline" id="Kernel_embedding_of_distributions:59">
 <semantics>
  <msub>
   <mi>μ</mi>
   <mrow>
    <mi>Y</mi>
    <mo>∣</mo>
    <mi>x</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>μ</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">x</csymbol>
    </cerror>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{Y\mid x}
  </annotation>
 </semantics>
</math>

, and in practice, the inversion operator is replaced with a regularized version of itself 

<math display="inline" id="Kernel_embedding_of_distributions:60">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi class="ltx_font_mathcaligraphic">𝒞</mi>
      <mrow>
       <mi>X</mi>
       <mi>X</mi>
      </mrow>
     </msub>
     <mo>+</mo>
     <mrow>
      <mi>λ</mi>
      <mi>𝐈</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒞</ci>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>X</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>𝐈</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathcal{C}_{XX}+\lambda\mathbf{I})^{-1}
  </annotation>
 </semantics>
</math>

 (where 

<math display="inline" id="Kernel_embedding_of_distributions:61">
 <semantics>
  <mi>𝐈</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐈</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{I}
  </annotation>
 </semantics>
</math>

 denotes the <a href="identity_matrix" title="wikilink">identity matrix</a>).</p>

<p>Given training examples 

<math display="inline" id="Kernel_embedding_of_distributions:62">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
    <ci>normal-…</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </interval>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(x_{1},y_{1}),\dots,(x_{n},y_{n})\}
  </annotation>
 </semantics>
</math>

, the empirical kernel conditional embedding operator may be estimated as <a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:63">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>C</mi>
     <mo>^</mo>
    </mover>
    <mrow>
     <mi>Y</mi>
     <mo>∣</mo>
     <mi>X</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>𝚽</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>𝐊</mi>
       <mo>+</mo>
       <mrow>
        <mi>λ</mi>
        <mi>𝐈</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <msup>
     <mi>𝚼</mi>
     <mi>T</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>C</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">Y</csymbol>
      <ci>normal-∣</ci>
      <csymbol cd="unknown">X</csymbol>
     </cerror>
    </apply>
    <apply>
     <times></times>
     <ci>𝚽</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <ci>𝐊</ci>
       <apply>
        <times></times>
        <ci>λ</ci>
        <ci>𝐈</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝚼</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{C}_{Y\mid X}=\boldsymbol{\Phi}(\mathbf{K}+\lambda\mathbf{I})^{-1}%
\boldsymbol{\Upsilon}^{T}
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
</dl>

<p>where 

<math display="inline" id="Kernel_embedding_of_distributions:64">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝚽</mi>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>y</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>𝚼</mi>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>𝚽</ci>
     <vector>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <eq></eq>
     <ci>𝚼</ci>
     <vector>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\Phi}=\left(\phi(y_{i}),\dots,(y_{n})\right),\boldsymbol{\Upsilon}%
=\left(\phi(x_{i}),\dots,(x_{n})\right)
  </annotation>
 </semantics>
</math>

 are implicitly formed feature matrices, 

<math display="inline" id="Kernel_embedding_of_distributions:65">
 <semantics>
  <mrow>
   <mi>𝐊</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>𝚼</mi>
     <mi>T</mi>
    </msup>
    <mi>𝚼</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐊</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝚼</ci>
      <ci>T</ci>
     </apply>
     <ci>𝚼</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{K}=\boldsymbol{\Upsilon}^{T}\boldsymbol{\Upsilon}
  </annotation>
 </semantics>
</math>

 is the Gram matrix for samples of 

<math display="inline" id="Kernel_embedding_of_distributions:66">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Kernel_embedding_of_distributions:67">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 is a <a href="Regularization_(mathematics)" title="wikilink">regularization</a> parameter needed to avoid <a class="uri" href="overfitting" title="wikilink">overfitting</a>.</p>

<p>Thus, the empirical estimate of the kernel conditional embedding is given by a weighted sum of samples of 

<math display="inline" id="Kernel_embedding_of_distributions:68">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>


 in the feature space:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:69">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>μ</mi>
     <mo>^</mo>
    </mover>
    <mrow>
     <mi>Y</mi>
     <mo>∣</mo>
     <mi>x</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>β</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>𝚽</mi>
    <mi>𝜷</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>μ</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">Y</csymbol>
       <ci>normal-∣</ci>
       <csymbol cd="unknown">x</csymbol>
      </cerror>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>β</ci>
        <ci>i</ci>
       </apply>
       <ci>x</ci>
       <ci>ϕ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>𝚽</ci>
      <ci>𝜷</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\mu}_{Y\mid x}=\sum_{i=1}^{n}\beta_{i}(x)\phi(y_{i})=\boldsymbol{\Phi%
}\boldsymbol{\beta}(x)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Kernel_embedding_of_distributions:70">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝜷</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>𝐊</mi>
       <mo>+</mo>
       <mrow>
        <mi>λ</mi>
        <mi>𝐈</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <msub>
     <mi>𝐊</mi>
     <mi>x</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝜷</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <ci>𝐊</ci>
       <apply>
        <times></times>
        <ci>λ</ci>
        <ci>𝐈</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐊</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\beta}(x)=(\mathbf{K}+\lambda\mathbf{I})^{-1}\mathbf{K}_{x}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Kernel_embedding_of_distributions:71">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐊</mi>
    <mi>x</mi>
   </msub>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>k</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mi>k</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo>,</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mi>T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐊</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <vector>
      <apply>
       <times></times>
       <ci>k</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>x</ci>
       </interval>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <ci>k</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <ci>x</ci>
       </interval>
      </apply>
     </vector>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{K}_{x}=\left(k(x_{1},x),\dots,k(x_{n},x)\right)^{T}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<h2 id="properties">Properties</h2>
<ul>
<li>The expectation of any function 

<math display="inline" id="Kernel_embedding_of_distributions:72">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 in the RKHS can be computed as an inner product with the kernel embedding:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:73">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝔼</mi>
     <mi>X</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>f</mi>
     <mo>,</mo>
     <msub>
      <mi>μ</mi>
      <mi>X</mi>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔼</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>X</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <list>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <ci>X</ci>
      </apply>
     </list>
     <ci>ℋ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}_{X}[f(X)]=\langle f,\mu_{X}\rangle_{\mathcal{H}}
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
</dl>
<ul>
<li>In the presence of large sample sizes, manipulations of the 

<math display="inline" id="Kernel_embedding_of_distributions:74">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times n
  </annotation>
 </semantics>
</math>

 Gram matrix may be computationally demanding. Through use of a low-rank approximation of the Gram matrix (such as the <a href="incomplete_Cholesky_factorization" title="wikilink">incomplete Cholesky factorization</a>), running time and memory requirements of kernel-embedding-based learning algorithms can be drastically reduced without suffering much loss in approximation accuracy.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></li>
</ul>
<h3 id="convergence-of-empirical-kernel-mean-to-the-true-distribution-embedding">Convergence of empirical kernel mean to the true distribution embedding</h3>
<ul>
<li>If 

<math display="inline" id="Kernel_embedding_of_distributions:75">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is defined such that 

<math display="inline" id="Kernel_embedding_of_distributions:76">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>f</ci>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\in[0,1]
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Kernel_embedding_of_distributions:77">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>f</ci>
    <ci>ℋ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\in\mathcal{H}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Kernel_embedding_of_distributions:78">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo fence="true">||</mo>
     <mi>f</mi>
     <mo fence="true">||</mo>
    </mrow>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   </msub>
   <mo>≤</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>f</ci>
     </apply>
     <ci>ℋ</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ||f||_{\mathcal{H}}\leq 1
  </annotation>
 </semantics>
</math>


 (as is the case for the widely used <a href="radial_basis_function" title="wikilink">radial basis function</a> kernels), then with probability at least 

<math display="inline" id="Kernel_embedding_of_distributions:79">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="float">1</cn>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ 1-\delta
  </annotation>
 </semantics>
</math>

:<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><br/>


<math display="inline" id="Kernel_embedding_of_distributions:80">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo fence="true">||</mo>
     <mrow>
      <msub>
       <mi>μ</mi>
       <mi>X</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mover accent="true">
        <mi>μ</mi>
        <mo>^</mo>
       </mover>
       <mi>X</mi>
      </msub>
     </mrow>
     <mo fence="true">||</mo>
    </mrow>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>sup</mo>
     <mrow>
      <mi>f</mi>
      <mo>∈</mo>
      <mrow>
       <mi class="ltx_font_mathcaligraphic">ℬ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo>,</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msub>
    <mrow>
     <mo>|</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>𝔼</mi>
        <mi>X</mi>
       </msub>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>X</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mi>n</mi>
       </mfrac>
       <mrow>
        <msubsup>
         <mo largeop="true" symmetric="true">∑</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>n</mi>
        </msubsup>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mi>i</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
     <mo>|</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mn>2</mn>
      <mi>n</mi>
     </mfrac>
     <msub>
      <mi>𝔼</mi>
      <mi>X</mi>
     </msub>
     <mrow>
      <mo>[</mo>
      <msqrt>
       <mrow>
        <mtext>tr</mtext>
        <mi>K</mi>
       </mrow>
      </msqrt>
      <mo>]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <msqrt>
     <mfrac>
      <mrow>
       <mi>log</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>2</mn>
         <mo>/</mo>
         <mi>δ</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mn>2</mn>
       <mi>n</mi>
      </mrow>
     </mfrac>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>μ</ci>
         <ci>X</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-^</ci>
          <ci>μ</ci>
         </apply>
         <ci>X</ci>
        </apply>
       </apply>
      </apply>
      <ci>ℋ</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">supremum</csymbol>
       <apply>
        <in></in>
        <ci>f</ci>
        <apply>
         <times></times>
         <ci>ℬ</ci>
         <interval closure="open">
          <cn type="integer">0</cn>
          <cn type="integer">1</cn>
         </interval>
        </apply>
       </apply>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝔼</ci>
          <ci>X</ci>
         </apply>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <times></times>
           <ci>f</ci>
           <ci>X</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <ci>n</ci>
         </apply>
         <apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <sum></sum>
            <apply>
             <eq></eq>
             <ci>i</ci>
             <cn type="integer">1</cn>
            </apply>
           </apply>
           <ci>n</ci>
          </apply>
          <apply>
           <times></times>
           <ci>f</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>i</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">2</cn>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝔼</ci>
        <ci>X</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <root></root>
         <apply>
          <times></times>
          <mtext>tr</mtext>
          <ci>K</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <root></root>
       <apply>
        <divide></divide>
        <apply>
         <log></log>
         <apply>
          <divide></divide>
          <cn type="integer">2</cn>
          <ci>δ</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ||\mu_{X}-\widehat{\mu}_{X}||_{\mathcal{H}}=\sup_{f\in\mathcal{B}(0,1)}\left|%
\mathbb{E}_{X}[f(X)]-\frac{1}{n}\sum_{i=1}^{n}f(x_{i})\right|\leq\frac{2}{n}%
\mathbb{E}_{X}\left[\sqrt{\text{tr}K}\right]+\sqrt{\frac{\log(2/\delta)}{2n}}
  </annotation>
 </semantics>
</math>

<br/>
 where 

<math display="inline" id="Kernel_embedding_of_distributions:81">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℬ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ℬ</ci>
    <interval closure="open">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}(0,1)
  </annotation>
 </semantics>
</math>

 denotes the unit ball in 

<math display="inline" id="Kernel_embedding_of_distributions:82">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Kernel_embedding_of_distributions:83">
 <semantics>
  <mi>𝐊</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐊</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{K}
  </annotation>
 </semantics>
</math>


 is the Gram matrix whose 

<math display="inline" id="Kernel_embedding_of_distributions:84">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>,</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>i</ci>
    <ci>j</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i,j
  </annotation>
 </semantics>
</math>

th entry is 

<math display="inline" id="Kernel_embedding_of_distributions:85">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(x_{i},x_{j})
  </annotation>
 </semantics>
</math>

.</li>
<li>The rate of convergence (in RKHS norm) of the empirical kernel embedding to its distribution counterpart is 

<math display="inline" id="Kernel_embedding_of_distributions:86">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{-1/2})
  </annotation>
 </semantics>
</math>

 and does <em>not</em> depend on the dimension of 

<math display="inline" id="Kernel_embedding_of_distributions:87">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

.</li>
<li>Statistics based on kernel embeddings thus avoid the <a href="curse_of_dimensionality" title="wikilink">curse of dimensionality</a>, and though the true underlying distribution is unknown in practice, one can (with high probability) obtain an approximation within 

<math display="inline" id="Kernel_embedding_of_distributions:88">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{-1/2})
  </annotation>
 </semantics>
</math>


 of the true kernel embedding based on a finite sample of size 

<math display="inline" id="Kernel_embedding_of_distributions:89">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

.</li>
<li>For the embedding of conditional distributions, the empirical estimate can be seen as a <em>weighted</em> average of feature mappings (where the weights 

<math display="inline" id="Kernel_embedding_of_distributions:90">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>i</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{i}(x)
  </annotation>
 </semantics>
</math>

 depend on the value of the conditioning variable and capture the effect of the conditioning on the kernel embedding). In this case, the empirical estimate converges to the conditional distribution RKHS embedding with rate 

<math display="inline" id="Kernel_embedding_of_distributions:91">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo>(</mo>
    <msup>
     <mi>n</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>4</mn>
      </mrow>
     </mrow>
    </msup>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">4</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(n^{-1/4}\right)
  </annotation>
 </semantics>
</math>

 if the regularization parameter 

<math display="inline" id="Kernel_embedding_of_distributions:92">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 is decreased as 

<math display="inline" id="Kernel_embedding_of_distributions:93">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo>(</mo>
    <msup>
     <mi>n</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </mrow>
    </msup>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(n^{-1/2}\right)
  </annotation>
 </semantics>
</math>


, though faster rates of convergence may be achieved by placing additional assumptions on the joint distribution.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></li>
</ul>
<h3 id="universal-kernels">Universal kernels</h3>
<ul>
<li>Letting 

<math display="inline" id="Kernel_embedding_of_distributions:94">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒳</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>𝒳</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(\mathcal{X})
  </annotation>
 </semantics>
</math>

 denote the space of <a href="Continuous_function" title="wikilink">continuous</a> <a href="Bounded_function" title="wikilink">bounded</a> functions on <a href="Compact_space" title="wikilink">compact</a> domain 

<math display="inline" id="Kernel_embedding_of_distributions:95">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒳</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒳</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{X}
  </annotation>
 </semantics>
</math>

, we call a kernel 

<math display="inline" id="Kernel_embedding_of_distributions:96">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 <em>universal</em> if 

<math display="inline" id="Kernel_embedding_of_distributions:97">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mo>⋅</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>normal-⋅</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(x,\cdot)
  </annotation>
 </semantics>
</math>

 is continuous for all 

<math display="inline" id="Kernel_embedding_of_distributions:98">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


 and the RKHS induced by 

<math display="inline" id="Kernel_embedding_of_distributions:99">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is <a href="Dense_set" title="wikilink">dense</a> in 

<math display="inline" id="Kernel_embedding_of_distributions:100">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒳</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>𝒳</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(\mathcal{X})
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li>If 

<math display="inline" id="Kernel_embedding_of_distributions:101">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 induces a strictly positive definite kernel matrix for any set of distinct points, then it is a universal kernel.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> For example, the widely used Gaussian RBF kernel</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:102">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <msup>
      <mi>x</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mrow>
         <mn>2</mn>
         <msup>
          <mi>σ</mi>
          <mn>2</mn>
         </msup>
        </mrow>
       </mfrac>
       <msup>
        <mrow>
         <mo fence="true">||</mo>
         <mrow>
          <mi>x</mi>
          <mo>-</mo>
          <msup>
           <mi>x</mi>
           <mo>′</mo>
          </msup>
         </mrow>
         <mo fence="true">||</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>k</ci>
     <interval closure="open">
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>normal-′</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <exp></exp>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>σ</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <apply>
          <minus></minus>
          <ci>x</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>x</ci>
           <ci>normal-′</ci>
          </apply>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(x,x^{\prime})=\exp\left(-\frac{1}{2\sigma^{2}}||x-x^{\prime}||^{2}\right)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>on compact subsets of 

<math display="inline" id="Kernel_embedding_of_distributions:103">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mi>d</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{d}
  </annotation>
 </semantics>
</math>


 is universal.</p>
<ul>
<li>If 

<math display="inline" id="Kernel_embedding_of_distributions:104">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is universal, then it is <em>characteristic</em>, i.e. the kernel embedding is one-to-one.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></li>
</ul>
<h3 id="parameter-selection-for-conditional-distribution-kernel-embeddings">Parameter selection for conditional distribution kernel embeddings</h3>
<ul>
<li>The empirical kernel conditional distribution embedding operator 

<math display="inline" id="Kernel_embedding_of_distributions:105">
 <semantics>
  <msub>
   <mover accent="true">
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo>^</mo>
   </mover>
   <mrow>
    <mi>Y</mi>
    <mo stretchy="false">|</mo>
    <mi>X</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>𝒞</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">X</csymbol>
    </cerror>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\mathcal{C}}_{Y|X}
  </annotation>
 </semantics>
</math>

 can alternatively be viewed as the solution of the following regularized least squares (function-valued) regression problem <a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:106">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>min</mi>
     <mrow>
      <mi class="ltx_font_mathcaligraphic">𝒞</mi>
      <mo>:</mo>
      <mrow>
       <mi class="ltx_font_mathcaligraphic">ℋ</mi>
       <mo>↦</mo>
       <mi class="ltx_font_mathcaligraphic">ℋ</mi>
      </mrow>
     </mrow>
    </msub>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <msubsup>
      <mrow>
       <mo fence="true">||</mo>
       <mrow>
        <mrow>
         <mi>ϕ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>y</mi>
           <mi>i</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi class="ltx_font_mathcaligraphic">𝒞</mi>
         <mi>ϕ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mi>i</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo fence="true">||</mo>
      </mrow>
      <mi class="ltx_font_mathcaligraphic">ℋ</mi>
      <mn>2</mn>
     </msubsup>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>λ</mi>
    <msubsup>
     <mrow>
      <mo fence="true">||</mo>
      <mi class="ltx_font_mathcaligraphic">𝒞</mi>
      <mo fence="true">||</mo>
     </mrow>
     <mrow>
      <mi>H</mi>
      <mi>S</mi>
     </mrow>
     <mn>2</mn>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <apply>
       <ci>normal-:</ci>
       <ci>𝒞</ci>
       <apply>
        <csymbol cd="latexml">maps-to</csymbol>
        <ci>ℋ</ci>
        <ci>ℋ</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <ci>ϕ</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>y</ci>
            <ci>i</ci>
           </apply>
          </apply>
          <apply>
           <times></times>
           <ci>𝒞</ci>
           <ci>ϕ</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>i</ci>
           </apply>
          </apply>
         </apply>
        </apply>
        <ci>ℋ</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <ci>𝒞</ci>
       </apply>
       <apply>
        <times></times>
        <ci>H</ci>
        <ci>S</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min_{\mathcal{C}:\mathcal{H}\mapsto\mathcal{H}}\sum_{i=1}^{n}||\phi(y_{i})-%
\mathcal{C}\phi(x_{i})||_{\mathcal{H}}^{2}+\lambda||\mathcal{C}||_{HS}^{2}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Kernel_embedding_of_distributions:107">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mo stretchy="false">|</mo>
   <mo>⋅</mo>
   <mo stretchy="false">|</mo>
   <msub>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>H</mi>
     <mi>S</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <ci>normal-|</ci>
    <ci>normal-⋅</ci>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-|</ci>
     <apply>
      <times></times>
      <ci>H</ci>
      <ci>S</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ||\cdot||_{HS}
  </annotation>
 </semantics>
</math>

 is the <a href="Hilbert–Schmidt_operator" title="wikilink">Hilbert-Schmidt norm</a>.
</dd>
</dl>
</dd>
</dl>
<ul>
<li>One can thus select the regularization parameter 

<math display="inline" id="Kernel_embedding_of_distributions:108">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>


 by performing <a href="cross-validation_(statistics)" title="wikilink">cross-validation</a> based on the squared loss function of the regression problem.</li>
</ul>
<h2 id="rules-of-probability-as-operations-in-the-rkhs">Rules of probability as operations in the RKHS</h2>

<p>This section illustrates how basic probabilistic rules may be reformulated as (multi)linear algebraic operations in the kernel embedding framework and is primarily based on the work of Song et al.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> The following notation is adopted:</p>
<ul>
<li>

<math display="inline" id="Kernel_embedding_of_distributions:109">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <interval closure="open">
      <ci>X</ci>
      <ci>Y</ci>
     </interval>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X,Y)=
  </annotation>
 </semantics>
</math>

 joint distribution over random variables 

<math display="inline" id="Kernel_embedding_of_distributions:110">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>,</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>X</ci>
    <ci>Y</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X,Y
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Kernel_embedding_of_distributions:111">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi mathvariant="normal">Ω</mi>
    </msub>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo>,</mo>
      <mrow>
       <mi mathvariant="normal">d</mi>
       <mi>y</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Ω</ci>
      </apply>
      <apply>
       <times></times>
       <ci>P</ci>
       <interval closure="open">
        <ci>X</ci>
        <apply>
         <times></times>
         <ci>normal-d</ci>
         <ci>y</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <csymbol cd="latexml">absent</csymbol>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X)=\int_{\Omega}P(X,\mathrm{d}y)=
  </annotation>
 </semantics>
</math>

 marginal distribution of 

<math display="inline" id="Kernel_embedding_of_distributions:112">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

; 

<math display="inline" id="Kernel_embedding_of_distributions:113">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>Y</ci>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(Y)=
  </annotation>
 </semantics>
</math>


 marginal distribution of 

<math display="inline" id="Kernel_embedding_of_distributions:114">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Kernel_embedding_of_distributions:115">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo>∣</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo>,</mo>
      <mi>Y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>P</ci>
      <interval closure="open">
       <ci>X</ci>
       <ci>Y</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <eq></eq>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(Y\mid X)=\frac{P(X,Y)}{P(X)}=
  </annotation>
 </semantics>
</math>

 conditional distribution of 

<math display="inline" id="Kernel_embedding_of_distributions:116">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 given 

<math display="inline" id="Kernel_embedding_of_distributions:117">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 with corresponding conditional embedding operator 

<math display="inline" id="Kernel_embedding_of_distributions:118">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   <mrow>
    <mi>Y</mi>
    <mo>∣</mo>
    <mi>X</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝒞</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">X</csymbol>
    </cerror>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}_{Y\mid X}
  </annotation>
 </semantics>
</math>


</li>
<li>

<math display="inline" id="Kernel_embedding_of_distributions:119">
 <semantics>
  <mrow>
   <mrow>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>π</ci>
     <ci>Y</ci>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(Y)=
  </annotation>
 </semantics>
</math>

 prior distribution over 

<math display="inline" id="Kernel_embedding_of_distributions:120">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Kernel_embedding_of_distributions:121">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is used to distinguish distributions which incorporate the prior from distributions 

<math display="inline" id="Kernel_embedding_of_distributions:122">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 which do not rely on the prior</li>
</ul>

<p>In practice, all embeddings are empirically estimated from data 

<math display="inline" id="Kernel_embedding_of_distributions:123">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
    <ci>normal-…</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </interval>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(x_{1},y_{1}),\dots,(x_{n},y_{n})\}
  </annotation>
 </semantics>
</math>


 and it assumed that a set of samples 

<math display="inline" id="Kernel_embedding_of_distributions:124">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mover accent="true">
     <mi>y</mi>
     <mo>~</mo>
    </mover>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mover accent="true">
     <mi>y</mi>
     <mo>~</mo>
    </mover>
    <mover accent="true">
     <mi>n</mi>
     <mo>~</mo>
    </mover>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>y</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <ci>normal-~</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\widetilde{y}_{1},\dots,\widetilde{y}_{\widetilde{n}}\}
  </annotation>
 </semantics>
</math>

 may be used to estimate the kernel embedding of the prior distribution 

<math display="inline" id="Kernel_embedding_of_distributions:125">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(Y)
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="kernel-sum-rule">Kernel sum rule</h3>

<p>In probability theory, the marginal distribution of 

<math display="inline" id="Kernel_embedding_of_distributions:126">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 can be computed by integrating out 

<math display="inline" id="Kernel_embedding_of_distributions:127">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 from the joint density (including the prior distribution on 

<math display="inline" id="Kernel_embedding_of_distributions:128">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>


)</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:129">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mo largeop="true" symmetric="true">∫</mo>
    <mi mathvariant="normal">Ω</mi>
   </msub>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>∣</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="normal">d</mi>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <int></int>
     <ci>normal-Ω</ci>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">π</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X)=\int_{\Omega}P(X\mid Y)\mathrm{d}\pi(Y)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>The analog of this rule in the kernel embedding framework states that 

<math display="inline" id="Kernel_embedding_of_distributions:130">
 <semantics>
  <msubsup>
   <mi>μ</mi>
   <mi>X</mi>
   <mi>π</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <ci>X</ci>
    </apply>
    <ci>π</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{X}^{\pi}
  </annotation>
 </semantics>
</math>

, the RKHS embedding of 

<math display="inline" id="Kernel_embedding_of_distributions:131">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X)
  </annotation>
 </semantics>
</math>

, can be computed via</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:132">
 <semantics>
  <mrow>
   <msubsup>
    <mi>μ</mi>
    <mi>X</mi>
    <mi>π</mi>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝔼</mi>
     <mi>Y</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <msub>
       <mi class="ltx_font_mathcaligraphic">𝒞</mi>
       <mrow>
        <mi>X</mi>
        <mo>∣</mo>
        <mi>Y</mi>
       </mrow>
      </msub>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     <mrow>
      <mi>X</mi>
      <mo>∣</mo>
      <mi>Y</mi>
     </mrow>
    </msub>
    <msub>
     <mi>𝔼</mi>
     <mi>Y</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     <mrow>
      <mi>X</mi>
      <mo>∣</mo>
      <mi>Y</mi>
     </mrow>
    </msub>
    <msubsup>
     <mi>μ</mi>
     <mi>Y</mi>
     <mi>π</mi>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <ci>X</ci>
      </apply>
      <ci>π</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝔼</ci>
       <ci>Y</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝒞</ci>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <csymbol cd="unknown">X</csymbol>
          <ci>normal-∣</ci>
          <csymbol cd="unknown">Y</csymbol>
         </cerror>
        </apply>
        <ci>ϕ</ci>
        <ci>Y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝒞</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">X</csymbol>
        <ci>normal-∣</ci>
        <csymbol cd="unknown">Y</csymbol>
       </cerror>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝔼</ci>
       <ci>Y</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>ϕ</ci>
        <ci>Y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝒞</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">X</csymbol>
        <ci>normal-∣</ci>
        <csymbol cd="unknown">Y</csymbol>
       </cerror>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <ci>Y</ci>
       </apply>
       <ci>π</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{X}^{\pi}=\mathbb{E}_{Y}[\mathcal{C}_{X\mid Y}\phi(Y)]=\mathcal{C}_{X\mid Y%
}\mathbb{E}_{Y}[\phi(Y)]=\mathcal{C}_{X\mid Y}\mu_{Y}^{\pi}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Kernel_embedding_of_distributions:133">
 <semantics>
  <msubsup>
   <mi>μ</mi>
   <mi>Y</mi>
   <mi>π</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <ci>Y</ci>
    </apply>
    <ci>π</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{Y}^{\pi}
  </annotation>
 </semantics>
</math>


 is the kernel embedding of 

<math display="inline" id="Kernel_embedding_of_distributions:134">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(Y)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>In practical implementations, the kernel sum rule takes the following form</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:135">
 <semantics>
  <mrow>
   <msubsup>
    <mover accent="true">
     <mi>μ</mi>
     <mo>^</mo>
    </mover>
    <mi>X</mi>
    <mi>π</mi>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mover accent="true">
      <mi class="ltx_font_mathcaligraphic">𝒞</mi>
      <mo>^</mo>
     </mover>
     <mrow>
      <mi>X</mi>
      <mo>∣</mo>
      <mi>Y</mi>
     </mrow>
    </msub>
    <msubsup>
     <mover accent="true">
      <mi>μ</mi>
      <mo>^</mo>
     </mover>
     <mi>Y</mi>
     <mi>π</mi>
    </msubsup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>𝚼</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>G</mi>
       <mo>+</mo>
       <mrow>
        <mi>λ</mi>
        <mi>𝐈</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mover accent="true">
     <mi>𝑮</mi>
     <mo>~</mo>
    </mover>
    <mi>𝜶</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>μ</ci>
       </apply>
       <ci>X</ci>
      </apply>
      <ci>π</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>𝒞</ci>
       </apply>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">X</csymbol>
        <ci>normal-∣</ci>
        <csymbol cd="unknown">Y</csymbol>
       </cerror>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>μ</ci>
        </apply>
        <ci>Y</ci>
       </apply>
       <ci>π</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>𝚼</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <ci>G</ci>
        <apply>
         <times></times>
         <ci>λ</ci>
         <ci>𝐈</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <ci>normal-~</ci>
       <ci>𝑮</ci>
      </apply>
      <ci>𝜶</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\mu}_{X}^{\pi}=\widehat{\mathcal{C}}_{X\mid Y}\widehat{\mu}_{Y}^{\pi}%
=\boldsymbol{\Upsilon}(G+\lambda\mathbf{I})^{-1}\widetilde{\boldsymbol{G}}%
\boldsymbol{\alpha}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where 

<math display="inline" id="Kernel_embedding_of_distributions:136">
 <semantics>
  <mrow>
   <msubsup>
    <mi>μ</mi>
    <mi>Y</mi>
    <mi>π</mi>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mover accent="true">
      <mi>n</mi>
      <mo>~</mo>
     </mover>
    </msubsup>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mover accent="true">
        <mi>y</mi>
        <mo>~</mo>
       </mover>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <ci>Y</ci>
     </apply>
     <ci>π</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <ci>normal-~</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
      <ci>ϕ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>y</ci>
       </apply>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{Y}^{\pi}=\sum_{i=1}^{\widetilde{n}}\alpha_{i}\phi(\widetilde{y}_{i})
  </annotation>
 </semantics>
</math>

 is the empirical kernel embedding of the prior distribution, 

<math display="inline" id="Kernel_embedding_of_distributions:137">
 <semantics>
  <mrow>
   <mi>𝜶</mi>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>α</mi>
      <mover accent="true">
       <mi>n</mi>
       <mo>~</mo>
      </mover>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝜶</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <apply>
        <ci>normal-~</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </vector>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\alpha}=(\alpha_{1},\dots,\alpha_{\widetilde{n}})^{T}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Kernel_embedding_of_distributions:138">
 <semantics>
  <mrow>
   <mi>𝚼</mi>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝚼</ci>
    <vector>
     <apply>
      <times></times>
      <ci>ϕ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <ci>ϕ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\Upsilon}=\left(\phi(x_{1}),\dots,\phi(x_{n})\right)
  </annotation>
 </semantics>
</math>


, and 

<math display="inline" id="Kernel_embedding_of_distributions:139">
 <semantics>
  <mrow>
   <mi>𝐆</mi>
   <mo>,</mo>
   <mover accent="true">
    <mi>𝐆</mi>
    <mo>~</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>𝐆</ci>
    <apply>
     <ci>normal-~</ci>
     <ci>𝐆</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G},\widetilde{\mathbf{G}}
  </annotation>
 </semantics>
</math>

 are Gram matrices with entries 

<math display="inline" id="Kernel_embedding_of_distributions:140">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐆</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>k</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>𝐆</mi>
      <mo>~</mo>
     </mover>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>k</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mover accent="true">
        <mi>y</mi>
        <mo>~</mo>
       </mover>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐆</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>k</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>j</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-~</ci>
       <ci>𝐆</ci>
      </apply>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>k</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-~</ci>
         <ci>y</ci>
        </apply>
        <ci>j</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G}_{ij}=k(y_{i},y_{j}),\widetilde{\mathbf{G}}_{ij}=k(y_{i},\widetilde{%
y}_{j})
  </annotation>
 </semantics>
</math>

 respectively.</p>
<h3 id="kernel-chain-rule">Kernel chain rule</h3>

<p>In probability theory, a joint distribution can be factorized into a product between conditional and marginal distributions</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:141">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>∣</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">π</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X,Y)=P(X\mid Y)\pi(Y)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>The analog of this rule in the kernel embedding framework states that 

<math display="inline" id="Kernel_embedding_of_distributions:142">
 <semantics>
  <msubsup>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   <mrow>
    <mi>X</mi>
    <mi>Y</mi>
   </mrow>
   <mi>π</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝒞</ci>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
    </apply>
    <ci>π</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}_{XY}^{\pi}
  </annotation>
 </semantics>
</math>

, the joint embedding of 

<math display="inline" id="Kernel_embedding_of_distributions:143">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <interval closure="open">
     <ci>X</ci>
     <ci>Y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X,Y)
  </annotation>
 </semantics>
</math>


, can be factorized as a composition of conditional embedding operator with the auto-covariance operator associated with 

<math display="inline" id="Kernel_embedding_of_distributions:144">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(Y)
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:145">
 <semantics>
  <mrow>
   <msubsup>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mrow>
     <mi>X</mi>
     <mi>Y</mi>
    </mrow>
    <mi>π</mi>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     <mrow>
      <mi>X</mi>
      <mo>∣</mo>
      <mi>Y</mi>
     </mrow>
    </msub>
    <msubsup>
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     <mrow>
      <mi>Y</mi>
      <mi>Y</mi>
     </mrow>
     <mi>π</mi>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒞</ci>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>Y</ci>
      </apply>
     </apply>
     <ci>π</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒞</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">X</csymbol>
       <ci>normal-∣</ci>
       <csymbol cd="unknown">Y</csymbol>
      </cerror>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝒞</ci>
       <apply>
        <times></times>
        <ci>Y</ci>
        <ci>Y</ci>
       </apply>
      </apply>
      <ci>π</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}_{XY}^{\pi}=\mathcal{C}_{X\mid Y}\mathcal{C}_{YY}^{\pi}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Kernel_embedding_of_distributions:146">
 <semantics>
  <mrow>
   <msubsup>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mrow>
     <mi>X</mi>
     <mi>Y</mi>
    </mrow>
    <mi>π</mi>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝔼</mi>
     <mrow>
      <mi>X</mi>
      <mi>Y</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>ϕ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>X</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>⊗</mo>
       <mi>ϕ</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒞</ci>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>Y</ci>
      </apply>
     </apply>
     <ci>π</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔼</ci>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>Y</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <apply>
         <times></times>
         <ci>ϕ</ci>
         <ci>X</ci>
        </apply>
        <ci>ϕ</ci>
       </apply>
       <ci>Y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}_{XY}^{\pi}=\mathbb{E}_{XY}[\phi(X)\otimes\phi(Y)]
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Kernel_embedding_of_distributions:147">
 <semantics>
  <mrow>
   <msubsup>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mrow>
     <mi>Y</mi>
     <mi>Y</mi>
    </mrow>
    <mi>π</mi>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝔼</mi>
     <mi>Y</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>ϕ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>Y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>⊗</mo>
       <mi>ϕ</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒞</ci>
      <apply>
       <times></times>
       <ci>Y</ci>
       <ci>Y</ci>
      </apply>
     </apply>
     <ci>π</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔼</ci>
      <ci>Y</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <apply>
         <times></times>
         <ci>ϕ</ci>
         <ci>Y</ci>
        </apply>
        <ci>ϕ</ci>
       </apply>
       <ci>Y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}_{YY}^{\pi}=\mathbb{E}_{Y}[\phi(Y)\otimes\phi(Y)]
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>In practical implementations, the kernel chain rule takes the following form</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:148">
 <semantics>
  <mrow>
   <msubsup>
    <mover accent="true">
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     <mo>^</mo>
    </mover>
    <mrow>
     <mi>X</mi>
     <mi>Y</mi>
    </mrow>
    <mi>π</mi>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mover accent="true">
      <mi class="ltx_font_mathcaligraphic">𝒞</mi>
      <mo>^</mo>
     </mover>
     <mrow>
      <mi>X</mi>
      <mo>∣</mo>
      <mi>Y</mi>
     </mrow>
    </msub>
    <msubsup>
     <mover accent="true">
      <mi class="ltx_font_mathcaligraphic">𝒞</mi>
      <mo>^</mo>
     </mover>
     <mrow>
      <mi>Y</mi>
      <mi>Y</mi>
     </mrow>
     <mi>π</mi>
    </msubsup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>𝚼</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>𝐆</mi>
       <mo>+</mo>
       <mrow>
        <mi>λ</mi>
        <mi>𝐈</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mover accent="true">
     <mi>𝐆</mi>
     <mo>~</mo>
    </mover>
    <mtext>diag</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝜶</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msup>
     <mi>𝚽</mi>
     <mi>T</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>𝒞</ci>
       </apply>
       <apply>
        <times></times>
        <ci>X</ci>
        <ci>Y</ci>
       </apply>
      </apply>
      <ci>π</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>𝒞</ci>
       </apply>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">X</csymbol>
        <ci>normal-∣</ci>
        <csymbol cd="unknown">Y</csymbol>
       </cerror>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>𝒞</ci>
        </apply>
        <apply>
         <times></times>
         <ci>Y</ci>
         <ci>Y</ci>
        </apply>
       </apply>
       <ci>π</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>𝚼</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <ci>𝐆</ci>
        <apply>
         <times></times>
         <ci>λ</ci>
         <ci>𝐈</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <ci>normal-~</ci>
       <ci>𝐆</ci>
      </apply>
      <mtext>diag</mtext>
      <ci>𝜶</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝚽</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\mathcal{C}}_{XY}^{\pi}=\widehat{\mathcal{C}}_{X\mid Y}\widehat{%
\mathcal{C}}_{YY}^{\pi}=\boldsymbol{\Upsilon}(\mathbf{G}+\lambda\mathbf{I})^{-%
1}\widetilde{\mathbf{G}}\text{diag}(\boldsymbol{\alpha})\boldsymbol{\Phi}^{T}
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
</dl>
<h3 id="kernel-bayes-rule">Kernel Bayes' rule</h3>

<p>In probability theory, a posterior distribution can be expressed in terms of a prior distribution and a likelihood function as</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:149">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo>∣</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>∣</mo>
      <mi>Y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>π</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-∣</ci>
       <csymbol cd="unknown">Y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">π</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">Y</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(Y\mid x)=\frac{P(x\mid Y)\pi(Y)}{Q(x)}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Kernel_embedding_of_distributions:150">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mo largeop="true" symmetric="true">∫</mo>
    <mi mathvariant="normal">Ω</mi>
   </msub>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>∣</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="normal">d</mi>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <int></int>
     <ci>normal-Ω</ci>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">π</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x)=\int_{\Omega}P(x\mid y)\mathrm{d}\pi(y)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>The analog of this rule in the kernel embedding framework expresses the kernel embedding of the conditional distribution in terms of conditional embedding operators which are modified by the prior distribution</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:151">
 <semantics>
  <mrow>
   <msubsup>
    <mi>μ</mi>
    <mrow>
     <mi>Y</mi>
     <mo>∣</mo>
     <mi>x</mi>
    </mrow>
    <mi>π</mi>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     <mrow>
      <mi>Y</mi>
      <mo>∣</mo>
      <mi>X</mi>
     </mrow>
     <mi>π</mi>
    </msubsup>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     <mrow>
      <mi>Y</mi>
      <mi>X</mi>
     </mrow>
     <mi>π</mi>
    </msubsup>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msubsup>
       <mi class="ltx_font_mathcaligraphic">𝒞</mi>
       <mrow>
        <mi>X</mi>
        <mi>X</mi>
       </mrow>
       <mi>π</mi>
      </msubsup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">Y</csymbol>
        <ci>normal-∣</ci>
        <csymbol cd="unknown">x</csymbol>
       </cerror>
      </apply>
      <ci>π</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝒞</ci>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <csymbol cd="unknown">Y</csymbol>
         <ci>normal-∣</ci>
         <csymbol cd="unknown">X</csymbol>
        </cerror>
       </apply>
       <ci>π</ci>
      </apply>
      <ci>ϕ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝒞</ci>
        <apply>
         <times></times>
         <ci>Y</ci>
         <ci>X</ci>
        </apply>
       </apply>
       <ci>π</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝒞</ci>
         <apply>
          <times></times>
          <ci>X</ci>
          <ci>X</ci>
         </apply>
        </apply>
        <ci>π</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>ϕ</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{Y\mid x}^{\pi}=\mathcal{C}_{Y\mid X}^{\pi}\phi(x)=\mathcal{C}_{YX}^{\pi}(%
\mathcal{C}_{XX}^{\pi})^{-1}\phi(x)
  </annotation>
 </semantics>
</math>

 where from the chain rule

<math display="block" id="Kernel_embedding_of_distributions:152">
 <semantics>
  <mrow>
   <msubsup>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mrow>
     <mi>Y</mi>
     <mi>X</mi>
    </mrow>
    <mi>π</mi>
   </msubsup>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msub>
       <mi class="ltx_font_mathcaligraphic">𝒞</mi>
       <mrow>
        <mi>X</mi>
        <mo>∣</mo>
        <mi>Y</mi>
       </mrow>
      </msub>
      <msubsup>
       <mi class="ltx_font_mathcaligraphic">𝒞</mi>
       <mrow>
        <mi>Y</mi>
        <mi>Y</mi>
       </mrow>
       <mi>π</mi>
      </msubsup>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mi>T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒞</ci>
      <apply>
       <times></times>
       <ci>Y</ci>
       <ci>X</ci>
      </apply>
     </apply>
     <ci>π</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝒞</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">X</csymbol>
        <ci>normal-∣</ci>
        <csymbol cd="unknown">Y</csymbol>
       </cerror>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝒞</ci>
        <apply>
         <times></times>
         <ci>Y</ci>
         <ci>Y</ci>
        </apply>
       </apply>
       <ci>π</ci>
      </apply>
     </apply>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}_{YX}^{\pi}=\left(\mathcal{C}_{X\mid Y}\mathcal{C}_{YY}^{\pi}\right%
)^{T}
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
</dd>
</dl>

<p>In practical implementations, the kernel Bayes' rule takes the following form</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:153">
 <semantics>
  <mrow>
   <msubsup>
    <mover accent="true">
     <mi>μ</mi>
     <mo>^</mo>
    </mover>
    <mrow>
     <mi>Y</mi>
     <mo>∣</mo>
     <mi>x</mi>
    </mrow>
    <mi>π</mi>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mover accent="true">
      <mi class="ltx_font_mathcaligraphic">𝒞</mi>
      <mo>^</mo>
     </mover>
     <mrow>
      <mi>Y</mi>
      <mi>X</mi>
     </mrow>
     <mi>π</mi>
    </msubsup>
    <msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mover accent="true">
           <mi class="ltx_font_mathcaligraphic">𝒞</mi>
           <mo>^</mo>
          </mover>
          <mrow>
           <mi>X</mi>
           <mi>X</mi>
          </mrow>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
       <mo>+</mo>
       <mrow>
        <mover accent="true">
         <mi>λ</mi>
         <mo>~</mo>
        </mover>
        <mi>𝐈</mi>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <msubsup>
     <mover accent="true">
      <mi class="ltx_font_mathcaligraphic">𝒞</mi>
      <mo>^</mo>
     </mover>
     <mrow>
      <mi>X</mi>
      <mi>X</mi>
     </mrow>
     <mi>π</mi>
    </msubsup>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mover accent="true">
     <mi>𝚽</mi>
     <mo>~</mo>
    </mover>
    <msup>
     <mi>𝚲</mi>
     <mi>T</mi>
    </msup>
    <msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>𝐃𝐊</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
       <mo>+</mo>
       <mrow>
        <mover accent="true">
         <mi>λ</mi>
         <mo>~</mo>
        </mover>
        <mi>𝐈</mi>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <msub>
     <mi>𝐊𝐃𝐊</mi>
     <mi>x</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>μ</ci>
       </apply>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">Y</csymbol>
        <ci>normal-∣</ci>
        <csymbol cd="unknown">x</csymbol>
       </cerror>
      </apply>
      <ci>π</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>𝒞</ci>
        </apply>
        <apply>
         <times></times>
         <ci>Y</ci>
         <ci>X</ci>
        </apply>
       </apply>
       <ci>π</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <ci>normal-^</ci>
           <ci>𝒞</ci>
          </apply>
          <apply>
           <times></times>
           <ci>X</ci>
           <ci>X</ci>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <times></times>
         <apply>
          <ci>normal-~</ci>
          <ci>λ</ci>
         </apply>
         <ci>𝐈</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>𝒞</ci>
        </apply>
        <apply>
         <times></times>
         <ci>X</ci>
         <ci>X</ci>
        </apply>
       </apply>
       <ci>π</ci>
      </apply>
      <ci>ϕ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <ci>normal-~</ci>
       <ci>𝚽</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝚲</ci>
       <ci>T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝐃𝐊</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <times></times>
         <apply>
          <ci>normal-~</ci>
          <ci>λ</ci>
         </apply>
         <ci>𝐈</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐊𝐃𝐊</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\mu}_{Y\mid x}^{\pi}=\widehat{\mathcal{C}}_{YX}^{\pi}\left((\widehat{%
\mathcal{C}}_{XX})^{2}+\widetilde{\lambda}\mathbf{I}\right)^{-1}\widehat{%
\mathcal{C}}_{XX}^{\pi}\phi(x)=\widetilde{\boldsymbol{\Phi}}\boldsymbol{%
\Lambda}^{T}\left((\mathbf{D}\mathbf{K})^{2}+\widetilde{\lambda}\mathbf{I}%
\right)^{-1}\mathbf{K}\mathbf{D}\mathbf{K}_{x}
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
</dl>

<p>where 

<math display="inline" id="Kernel_embedding_of_distributions:154">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝚲</mi>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mi>𝐆</mi>
        <mo>+</mo>
        <mrow>
         <mover accent="true">
          <mi>λ</mi>
          <mo>~</mo>
         </mover>
         <mi>𝐈</mi>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mover accent="true">
      <mi>𝐆</mi>
      <mo>~</mo>
     </mover>
     <mtext>diag</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝜶</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>𝐃</mi>
    <mo>=</mo>
    <mrow>
     <mtext>diag</mtext>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mi>𝐆</mi>
          <mo>+</mo>
          <mrow>
           <mover accent="true">
            <mi>λ</mi>
            <mo>~</mo>
           </mover>
           <mi>𝐈</mi>
          </mrow>
         </mrow>
         <mo>)</mo>
        </mrow>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mover accent="true">
        <mi>𝐆</mi>
        <mo>~</mo>
       </mover>
       <mi>𝜶</mi>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>𝚲</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <ci>𝐆</ci>
        <apply>
         <times></times>
         <apply>
          <ci>normal-~</ci>
          <ci>λ</ci>
         </apply>
         <ci>𝐈</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <ci>normal-~</ci>
       <ci>𝐆</ci>
      </apply>
      <mtext>diag</mtext>
      <ci>𝜶</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>𝐃</ci>
     <apply>
      <times></times>
      <mtext>diag</mtext>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <plus></plus>
         <ci>𝐆</ci>
         <apply>
          <times></times>
          <apply>
           <ci>normal-~</ci>
           <ci>λ</ci>
          </apply>
          <ci>𝐈</ci>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <ci>normal-~</ci>
        <ci>𝐆</ci>
       </apply>
       <ci>𝜶</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\Lambda}=\left(\mathbf{G}+\widetilde{\lambda}\mathbf{I}\right)^{-1%
}\widetilde{\mathbf{G}}\text{diag}(\boldsymbol{\alpha}),\mathbf{D}=\text{diag}%
\left(\left(\mathbf{G}+\widetilde{\lambda}\mathbf{I}\right)^{-1}\widetilde{%
\mathbf{G}}\boldsymbol{\alpha}\right)
  </annotation>
 </semantics>
</math>

. Two regularization parameters are used in this framework

<math display="block" id="Kernel_embedding_of_distributions:155">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 for the estimation of 

<math display="inline" id="Kernel_embedding_of_distributions:156">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mover accent="true">
      <mi class="ltx_font_mathcaligraphic">𝒞</mi>
      <mo>^</mo>
     </mover>
     <mrow>
      <mi>Y</mi>
      <mi>X</mi>
     </mrow>
     <mi>π</mi>
    </msubsup>
    <mo>,</mo>
    <msubsup>
     <mover accent="true">
      <mi class="ltx_font_mathcaligraphic">𝒞</mi>
      <mo>^</mo>
     </mover>
     <mrow>
      <mi>X</mi>
      <mi>X</mi>
     </mrow>
     <mi>π</mi>
    </msubsup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>𝚼</mi>
    <mi>𝐃</mi>
    <msup>
     <mi>𝚼</mi>
     <mi>T</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>𝒞</ci>
       </apply>
       <apply>
        <times></times>
        <ci>Y</ci>
        <ci>X</ci>
       </apply>
      </apply>
      <ci>π</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>𝒞</ci>
       </apply>
       <apply>
        <times></times>
        <ci>X</ci>
        <ci>X</ci>
       </apply>
      </apply>
      <ci>π</ci>
     </apply>
    </list>
    <apply>
     <times></times>
     <ci>𝚼</ci>
     <ci>𝐃</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝚼</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\mathcal{C}}_{YX}^{\pi},\widehat{\mathcal{C}}_{XX}^{\pi}=\boldsymbol{%
\Upsilon}\mathbf{D}\boldsymbol{\Upsilon}^{T}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Kernel_embedding_of_distributions:157">
 <semantics>
  <mover accent="true">
   <mi>λ</mi>
   <mo>~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widetilde{\lambda}
  </annotation>
 </semantics>
</math>

 for the estimation of the final conditional embedding operator 

<math display="inline" id="Kernel_embedding_of_distributions:158">
 <semantics>
  <mrow>
   <msubsup>
    <mover accent="true">
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     <mo>^</mo>
    </mover>
    <mrow>
     <mi>Y</mi>
     <mo>∣</mo>
     <mi>X</mi>
    </mrow>
    <mi>π</mi>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mover accent="true">
      <mi class="ltx_font_mathcaligraphic">𝒞</mi>
      <mo>^</mo>
     </mover>
     <mrow>
      <mi>Y</mi>
      <mi>X</mi>
     </mrow>
     <mi>π</mi>
    </msubsup>
    <msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msubsup>
          <mover accent="true">
           <mi class="ltx_font_mathcaligraphic">𝒞</mi>
           <mo>^</mo>
          </mover>
          <mrow>
           <mi>X</mi>
           <mi>X</mi>
          </mrow>
          <mi>π</mi>
         </msubsup>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
       <mo>+</mo>
       <mrow>
        <mover accent="true">
         <mi>λ</mi>
         <mo>~</mo>
        </mover>
        <mi>𝐈</mi>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <msubsup>
     <mover accent="true">
      <mi class="ltx_font_mathcaligraphic">𝒞</mi>
      <mo>^</mo>
     </mover>
     <mrow>
      <mi>X</mi>
      <mi>X</mi>
     </mrow>
     <mi>π</mi>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>𝒞</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">Y</csymbol>
       <ci>normal-∣</ci>
       <csymbol cd="unknown">X</csymbol>
      </cerror>
     </apply>
     <ci>π</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>𝒞</ci>
       </apply>
       <apply>
        <times></times>
        <ci>Y</ci>
        <ci>X</ci>
       </apply>
      </apply>
      <ci>π</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <ci>normal-^</ci>
           <ci>𝒞</ci>
          </apply>
          <apply>
           <times></times>
           <ci>X</ci>
           <ci>X</ci>
          </apply>
         </apply>
         <ci>π</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <apply>
         <ci>normal-~</ci>
         <ci>λ</ci>
        </apply>
        <ci>𝐈</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>𝒞</ci>
       </apply>
       <apply>
        <times></times>
        <ci>X</ci>
        <ci>X</ci>
       </apply>
      </apply>
      <ci>π</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\mathcal{C}}_{Y\mid X}^{\pi}=\widehat{\mathcal{C}}_{YX}^{\pi}\left((%
\widehat{\mathcal{C}}_{XX}^{\pi})^{2}+\widetilde{\lambda}\mathbf{I}\right)^{-1%
}\widehat{\mathcal{C}}_{XX}^{\pi}
  </annotation>
 </semantics>
</math>


. The latter regularization is done on square of 

<math display="inline" id="Kernel_embedding_of_distributions:159">
 <semantics>
  <msubsup>
   <mover accent="true">
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo>^</mo>
   </mover>
   <mrow>
    <mi>X</mi>
    <mi>X</mi>
   </mrow>
   <mi>π</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>𝒞</ci>
     </apply>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <ci>π</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\mathcal{C}}_{XX}^{\pi}
  </annotation>
 </semantics>
</math>

 because 

<math display="inline" id="Kernel_embedding_of_distributions:160">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 may not be <a href="Positive-definite_matrix" title="wikilink">positive definite</a>.</p>
<h2 id="applications">Applications</h2>
<h3 id="measuring-distance-between-distributions">Measuring distance between distributions</h3>

<p>The <strong>maximum mean discrepancy</strong> (MMD) is a distance-measure between distributions 

<math display="inline" id="Kernel_embedding_of_distributions:161">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Kernel_embedding_of_distributions:162">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(Y)
  </annotation>
 </semantics>
</math>

 which is defined as the squared distance between their embeddings in the RKHS <a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:163">
 <semantics>
  <mrow>
   <mrow>
    <mtext>MMD</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>P</mi>
     <mo>,</mo>
     <mi>Q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msubsup>
    <mrow>
     <mo fence="true">||</mo>
     <mrow>
      <msub>
       <mi>μ</mi>
       <mi>X</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>μ</mi>
       <mi>Y</mi>
      </msub>
     </mrow>
     <mo fence="true">||</mo>
    </mrow>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
    <mn>2</mn>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>MMD</mtext>
     <interval closure="open">
      <ci>P</ci>
      <ci>Q</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>μ</ci>
         <ci>X</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>μ</ci>
         <ci>Y</ci>
        </apply>
       </apply>
      </apply>
      <ci>ℋ</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{MMD}(P,Q)=\left|\left|\mu_{X}-\mu_{Y}\right|\right|_{\mathcal{H}}^{2}
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
</dl>

<p>While most distance-measures between distributions such as the widely used <a href="Kullback–Leibler_divergence" title="wikilink">Kullback–Leibler divergence</a> either require density estimation (either parametrically or nonparametrically) or space partitioning/bias correction strategies,<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> the MMD is easily estimated as an empirical mean which is concentrated around the true value of the MMD. The characterization of this distance as the <em>maximum mean discrepancy</em> refers to the fact that computing the MMD is equivalent to finding the RKHS function that maximizes the difference in expectations between the two probability distributions</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:164">
 <semantics>
  <mrow>
   <mrow>
    <mtext>MMD</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>P</mi>
     <mo>,</mo>
     <mi>Q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>sup</mo>
     <mrow>
      <msub>
       <mrow>
        <mo fence="true">||</mo>
        <mi>f</mi>
        <mo fence="true">||</mo>
       </mrow>
       <mi class="ltx_font_mathcaligraphic">ℋ</mi>
      </msub>
      <mo>≤</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>𝔼</mi>
        <mi>X</mi>
       </msub>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>X</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>𝔼</mi>
        <mi>Y</mi>
       </msub>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>Y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>MMD</mtext>
     <interval closure="open">
      <ci>P</ci>
      <ci>Q</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">supremum</csymbol>
      <apply>
       <leq></leq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <ci>f</ci>
        </apply>
        <ci>ℋ</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝔼</ci>
        <ci>X</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>X</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝔼</ci>
        <ci>Y</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>Y</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{MMD}(P,Q)=\sup_{||f||_{\mathcal{H}}\leq 1}\left(\mathbb{E}_{X}[f(X)]-%
\mathbb{E}_{Y}[f(Y)]\right)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<h3 id="kernel-two-sample-test">Kernel two sample test</h3>

<p>Given <em>n</em> training examples from 

<math display="inline" id="Kernel_embedding_of_distributions:165">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X)
  </annotation>
 </semantics>
</math>

 and <em>m</em> samples from 

<math display="inline" id="Kernel_embedding_of_distributions:166">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(Y)
  </annotation>
 </semantics>
</math>

, one can formulate a test statistic based on the empirical estimate of the MMD</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:167">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mtext>MMD</mtext>
     <mo>^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>P</mi>
     <mo>,</mo>
     <mi>Q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msubsup>
    <mrow>
     <mo fence="true">||</mo>
     <mrow>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mi>n</mi>
       </mfrac>
       <mrow>
        <msubsup>
         <mo largeop="true" symmetric="true">∑</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>n</mi>
        </msubsup>
        <mrow>
         <mi>ϕ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mi>i</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mi>m</mi>
       </mfrac>
       <mrow>
        <msubsup>
         <mo largeop="true" symmetric="true">∑</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>m</mi>
        </msubsup>
        <mrow>
         <mi>ϕ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>y</mi>
           <mi>i</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
     <mo fence="true">||</mo>
    </mrow>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
    <mn>2</mn>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mi>n</mi>
      <mi>m</mi>
     </mrow>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>m</mi>
      </msubsup>
      <mrow>
       <mo>[</mo>
       <mrow>
        <mrow>
         <mrow>
          <mi>k</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>x</mi>
            <mi>i</mi>
           </msub>
           <mo>,</mo>
           <msub>
            <mi>x</mi>
            <mi>j</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>+</mo>
         <mrow>
          <mi>k</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>y</mi>
            <mi>i</mi>
           </msub>
           <mo>,</mo>
           <msub>
            <mi>y</mi>
            <mi>j</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mn>2</mn>
         <mi>k</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mi>i</mi>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>y</mi>
           <mi>j</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-^</ci>
       <mtext>MMD</mtext>
      </apply>
      <interval closure="open">
       <ci>P</ci>
       <ci>Q</ci>
      </interval>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <ci>n</ci>
          </apply>
          <apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <sum></sum>
             <apply>
              <eq></eq>
              <ci>i</ci>
              <cn type="integer">1</cn>
             </apply>
            </apply>
            <ci>n</ci>
           </apply>
           <apply>
            <times></times>
            <ci>ϕ</ci>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <ci>i</ci>
            </apply>
           </apply>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <ci>m</ci>
          </apply>
          <apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <sum></sum>
             <apply>
              <eq></eq>
              <ci>i</ci>
              <cn type="integer">1</cn>
             </apply>
            </apply>
            <ci>m</ci>
           </apply>
           <apply>
            <times></times>
            <ci>ϕ</ci>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>y</ci>
             <ci>i</ci>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <ci>ℋ</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>m</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>j</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>m</ci>
        </apply>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <minus></minus>
          <apply>
           <plus></plus>
           <apply>
            <times></times>
            <ci>k</ci>
            <interval closure="open">
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>x</ci>
              <ci>i</ci>
             </apply>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>x</ci>
              <ci>j</ci>
             </apply>
            </interval>
           </apply>
           <apply>
            <times></times>
            <ci>k</ci>
            <interval closure="open">
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>y</ci>
              <ci>i</ci>
             </apply>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>y</ci>
              <ci>j</ci>
             </apply>
            </interval>
           </apply>
          </apply>
          <apply>
           <times></times>
           <cn type="integer">2</cn>
           <ci>k</ci>
           <interval closure="open">
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <ci>i</ci>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>y</ci>
             <ci>j</ci>
            </apply>
           </interval>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\text{MMD}}(P,Q)=\left|\left|\frac{1}{n}\sum_{i=1}^{n}\phi(x_{i})-%
\frac{1}{m}\sum_{i=1}^{m}\phi(y_{i})\right|\right|_{\mathcal{H}}^{2}=\frac{1}{%
nm}\sum_{i=1}^{n}\sum_{j=1}^{m}\left[k(x_{i},x_{j})+k(y_{i},y_{j})-2k(x_{i},y_%
{j})\right]
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>to obtain a <strong>two-sample test</strong> <a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> of the null hypothesis that both samples stem from the same distribution (i.e. 

<math display="inline" id="Kernel_embedding_of_distributions:168">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=Q
  </annotation>
 </semantics>
</math>


) against the broad alternative 

<math display="inline" id="Kernel_embedding_of_distributions:169">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>≠</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\neq Q
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="density-estimation-via-kernel-embeddings">Density estimation via kernel embeddings</h3>

<p>Although learning algorithms in the kernel embedding framework circumvent the need for intermediate density estimation, one may nonetheless use the empirical embedding to perform density estimation based on <em>n</em> samples drawn from an underlying distribution 

<math display="inline" id="Kernel_embedding_of_distributions:170">
 <semantics>
  <msubsup>
   <mi>P</mi>
   <mi>X</mi>
   <mo>*</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>X</ci>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{X}^{*}
  </annotation>
 </semantics>
</math>

. This can be done by solving the following optimization problem <a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a><a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:171">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>max</mi>
     <msub>
      <mi>P</mi>
      <mi>X</mi>
     </msub>
    </msub>
    <mi>H</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>P</mi>
     <mi>X</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>X</ci>
      </apply>
     </apply>
     <ci>H</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max_{P_{X}}H(P_{X})
  </annotation>
 </semantics>
</math>

 subject to 

<math display="inline" id="Kernel_embedding_of_distributions:172">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo fence="true">||</mo>
     <mrow>
      <msub>
       <mover accent="true">
        <mi>μ</mi>
        <mo>^</mo>
       </mover>
       <mi>X</mi>
      </msub>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>μ</mi>
        <mi>X</mi>
       </msub>
       <mrow>
        <mo stretchy="false">[</mo>
        <msub>
         <mi>P</mi>
         <mi>X</mi>
        </msub>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo fence="true">||</mo>
    </mrow>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   </msub>
   <mo>≤</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>μ</ci>
        </apply>
        <ci>X</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>μ</ci>
         <ci>X</ci>
        </apply>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>P</ci>
          <ci>X</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>ℋ</ci>
    </apply>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ||\widehat{\mu}_{X}-\mu_{X}[P_{X}]||_{\mathcal{H}}\leq\epsilon
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where the maximization is done over the entire space of distributions on 

<math display="inline" id="Kernel_embedding_of_distributions:173">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>


. Here, 

<math display="inline" id="Kernel_embedding_of_distributions:174">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mi>X</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>P</mi>
     <mi>X</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{X}[P_{X}]
  </annotation>
 </semantics>
</math>

 is the kernel embedding of the proposed density 

<math display="inline" id="Kernel_embedding_of_distributions:175">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>X</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{X}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Kernel_embedding_of_distributions:176">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 is an entropy-like quantity (e.g. <a href="Entropy_(information_theory)" title="wikilink">Entropy</a>, <a href="Kullback–Leibler_divergence" title="wikilink">KL divergence</a>, <a href="Bregman_divergence" title="wikilink">Bregman divergence</a>). The distribution which solves this optimization may be interpreted as a compromise between fitting the empirical kernel means of the samples well, while still allocating a substantial portion of the probability mass to all regions of the probability space (much of which may not be represented in the training examples). In practice, a good approximate solution of the difficult optimization may be found by restricting the space of candidate densities to a mixture of <em>M</em> candidate distributions with regularized mixing proportions. Connections between the ideas underlying <a href="Gaussian_process" title="wikilink">Gaussian processes</a> and <a href="conditional_random_fields" title="wikilink">conditional random fields</a> may be drawn with the estimation of conditional probability distributions in this fashion, if one views the feature mappings associated with the kernel as sufficient statistics in generalized (possibly infinite-dimensional) <a href="exponential_family" title="wikilink">exponential families</a>.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>
<h3 id="measuring-dependence-of-random-variables">Measuring dependence of random variables</h3>

<p>A measure of the statistical dependence between random variables 

<math display="inline" id="Kernel_embedding_of_distributions:177">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Kernel_embedding_of_distributions:178">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>


 (from any domains on which sensible kernels can be defined) can be formulated based on the Hilbert–Schmidt Independence Criterion <a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:179">
 <semantics>
  <mrow>
   <mrow>
    <mtext>HSIC</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msubsup>
    <mrow>
     <mo fence="true">||</mo>
     <mrow>
      <msub>
       <mi class="ltx_font_mathcaligraphic">𝒞</mi>
       <mrow>
        <mi>X</mi>
        <mi>Y</mi>
       </mrow>
      </msub>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>μ</mi>
        <mi>X</mi>
       </msub>
       <mo>⊗</mo>
       <msub>
        <mi>μ</mi>
        <mi>Y</mi>
       </msub>
      </mrow>
     </mrow>
     <mo fence="true">||</mo>
    </mrow>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">ℋ</mi>
     <mo>⊗</mo>
     <mi class="ltx_font_mathcaligraphic">ℋ</mi>
    </mrow>
    <mn>2</mn>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>HSIC</mtext>
     <interval closure="open">
      <ci>X</ci>
      <ci>Y</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝒞</ci>
         <apply>
          <times></times>
          <ci>X</ci>
          <ci>Y</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="latexml">tensor-product</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>μ</ci>
          <ci>X</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>μ</ci>
          <ci>Y</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>ℋ</ci>
       <ci>ℋ</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{HSIC}(X,Y)=\left|\left|\mathcal{C}_{XY}-\mu_{X}\otimes\mu_{Y}\right|%
\right|_{\mathcal{H}\otimes\mathcal{H}}^{2}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>and can be used as a principled replacement for <a href="mutual_information" title="wikilink">mutual information</a>, <a href="Pearson_correlation" title="wikilink">Pearson correlation</a> or any other dependence measure used in learning algorithms. Most notably, HSIC can detect arbitrary dependencies (when a characteristic kernel is used in the embeddings, HSIC is zero if and only if the variables are <a href="independence_(probability_theory)" title="wikilink">independent</a>), and can be used to measure dependence between different types of data (e.g. images and text captions). Given <em>n</em> i.i.d. samples of each random variable, a simple parameter-free <a href="Bias_of_an_estimator" title="wikilink">unbiased</a> estimator of HSIC which exhibits <a href="Concentration_of_measure" title="wikilink">concentration</a> about the true value can be computed in 

<math display="inline" id="Kernel_embedding_of_distributions:180">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msubsup>
        <mi>d</mi>
        <mi>f</mi>
        <mn>2</mn>
       </msubsup>
       <mo>+</mo>
       <msubsup>
        <mi>d</mi>
        <mi>g</mi>
        <mn>2</mn>
       </msubsup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>d</ci>
        <ci>f</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>d</ci>
        <ci>g</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n(d_{f}^{2}+d_{g}^{2}))
  </annotation>
 </semantics>
</math>

 time,<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> where the Gram matrices of the two datasets are approximated using 

<math display="inline" id="Kernel_embedding_of_distributions:181">
 <semantics>
  <mrow>
   <msup>
    <mi>𝐀𝐀</mi>
    <mi>T</mi>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>𝐁𝐁</mi>
    <mi>T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐀𝐀</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐁𝐁</ci>
     <ci>T</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}\mathbf{A}^{T},\mathbf{B}\mathbf{B}^{T}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Kernel_embedding_of_distributions:182">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐀</mi>
    <mo>∈</mo>
    <msup>
     <mi>ℝ</mi>
     <mrow>
      <mi>n</mi>
      <mo>×</mo>
      <msub>
       <mi>d</mi>
       <mi>f</mi>
      </msub>
     </mrow>
    </msup>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>𝐁</mi>
    <mo>∈</mo>
    <msup>
     <mi>ℝ</mi>
     <mrow>
      <mi>n</mi>
      <mo>×</mo>
      <msub>
       <mi>d</mi>
       <mi>g</mi>
      </msub>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <ci>𝐀</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>d</ci>
        <ci>f</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>𝐁</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>d</ci>
        <ci>g</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}\in\mathbb{R}^{n\times d_{f}},\mathbf{B}\in\mathbb{R}^{n\times d_{g}}
  </annotation>
 </semantics>
</math>

. The desirable properties of HSIC have led to the formulation of numerous algorithms which utilize this dependence measure for a variety of common machine learning tasks such as: <a href="feature_selection" title="wikilink">feature selection</a> (BAHSIC <a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a>), <a href="Cluster_analysis" title="wikilink">clustering</a> (CLUHSIC <a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a>), and <a href="dimensionality_reduction" title="wikilink">dimensionality reduction</a> (MUHSIC <a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a>).</p>
<h3 id="kernel-belief-propagation">Kernel belief propagation</h3>

<p><a href="Belief_propagation" title="wikilink">Belief propagation</a> is a fundamental algorithm for inference in <a href="graphical_models" title="wikilink">graphical models</a> in which nodes repeatedly pass and receive messages corresponding to the evaluation of conditional expectations. In the kernel embedding framework, the messages may be represented as RKHS functions and the conditional distribution embeddings can be applied to efficiently compute message updates. Given <em>n</em> samples of random variables represented by nodes in a <a href="Markov_Random_Field" title="wikilink">Markov Random Field</a>, the incoming message to node <em>t</em> from node <em>u</em> can be expressed as 

<math display="inline" id="Kernel_embedding_of_distributions:183">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>m</mi>
     <mrow>
      <mi>u</mi>
      <mi>t</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>⋅</mo>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <msubsup>
      <mi>β</mi>
      <mrow>
       <mi>u</mi>
       <mi>t</mi>
      </mrow>
      <mi>i</mi>
     </msubsup>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msubsup>
       <mi>x</mi>
       <mi>t</mi>
       <mi>i</mi>
      </msubsup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <apply>
       <times></times>
       <ci>u</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <ci>normal-⋅</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>β</ci>
        <apply>
         <times></times>
         <ci>u</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <ci>i</ci>
      </apply>
      <ci>ϕ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>t</ci>
       </apply>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{ut}(\cdot)=\sum_{i=1}^{n}\beta_{ut}^{i}\phi(x_{t}^{i})
  </annotation>
 </semantics>
</math>


 if it assumed to lie in the RKHS. The <strong>kernel belief propagation update</strong> message from <em>t</em> to node <em>s</em> is then given by <a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:184">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>m</mi>
     <mo>^</mo>
    </mover>
    <mrow>
     <mi>t</mi>
     <mi>s</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo>(</mo>
     <msub>
      <mo>⊙</mo>
      <mrow>
       <mi>u</mi>
       <mo>∈</mo>
       <mrow>
        <mrow>
         <mi>N</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>\</mo>
        <mi>s</mi>
       </mrow>
      </mrow>
     </msub>
     <msub>
      <mi>𝐊</mi>
      <mi>t</mi>
     </msub>
     <msub>
      <mi>𝜷</mi>
      <mrow>
       <mi>u</mi>
       <mi>t</mi>
      </mrow>
     </msub>
     <mo>)</mo>
    </mrow>
    <mi>T</mi>
   </msup>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐊</mi>
      <mi>s</mi>
     </msub>
     <mo>+</mo>
     <mi>λ</mi>
     <mi>𝐈</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <msubsup>
    <mi>𝚼</mi>
    <mi>s</mi>
    <mi>T</mi>
   </msubsup>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>s</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <ci>t</ci>
      <ci>s</ci>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">direct-product</csymbol>
       <apply>
        <in></in>
        <ci>u</ci>
        <apply>
         <ci>normal-\</ci>
         <apply>
          <times></times>
          <ci>N</ci>
          <ci>t</ci>
         </apply>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐊</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝜷</ci>
       <apply>
        <times></times>
        <ci>u</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>T</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐊</ci>
       <ci>s</ci>
      </apply>
      <plus></plus>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">I</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝚼</ci>
      <ci>s</ci>
     </apply>
     <ci>T</ci>
    </apply>
    <csymbol cd="unknown">ϕ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>s</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{m}_{ts}=\left(\odot_{u\in N(t)\backslash s}\mathbf{K}_{t}\boldsymbol{%
\beta}_{ut}\right)^{T}(\mathbf{K}_{s}+\lambda\mathbf{I})^{-1}\boldsymbol{%
\Upsilon}_{s}^{T}\phi(x_{s})
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where 

<math display="inline" id="Kernel_embedding_of_distributions:185">
 <semantics>
  <mo>⊙</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">direct-product</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \odot
  </annotation>
 </semantics>
</math>

 denotes the element-wise vector product, 

<math display="inline" id="Kernel_embedding_of_distributions:186">
 <semantics>
  <mrow>
   <mrow>
    <mi>N</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>\</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-\</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>t</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N(t)\backslash s
  </annotation>
 </semantics>
</math>

 is the set of nodes connected to <em>t</em> excluding node <em>s</em>, 

<math display="inline" id="Kernel_embedding_of_distributions:187">
 <semantics>
  <mrow>
   <msub>
    <mi>𝜷</mi>
    <mrow>
     <mi>u</mi>
     <mi>t</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <msubsup>
     <mi>β</mi>
     <mrow>
      <mi>u</mi>
      <mi>t</mi>
     </mrow>
     <mn>1</mn>
    </msubsup>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msubsup>
     <mi>β</mi>
     <mrow>
      <mi>u</mi>
      <mi>t</mi>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝜷</ci>
     <apply>
      <times></times>
      <ci>u</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <apply>
        <times></times>
        <ci>u</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <apply>
        <times></times>
        <ci>u</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\beta}_{ut}=\left(\beta_{ut}^{1},\dots,\beta_{ut}^{n}\right)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Kernel_embedding_of_distributions:188">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐊</mi>
    <mi>t</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>𝐊</mi>
    <mi>s</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐊</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐊</ci>
     <ci>s</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{K}_{t},\mathbf{K}_{s}
  </annotation>
 </semantics>
</math>


 are the Gram matrices of the samples from variables 

<math display="inline" id="Kernel_embedding_of_distributions:189">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mi>t</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>X</mi>
    <mi>s</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>s</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{t},X_{s}
  </annotation>
 </semantics>
</math>

, respectively, and 

<math display="inline" id="Kernel_embedding_of_distributions:190">
 <semantics>
  <mrow>
   <msub>
    <mi>𝚼</mi>
    <mi>s</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msubsup>
       <mi>x</mi>
       <mi>s</mi>
       <mn>1</mn>
      </msubsup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msubsup>
       <mi>x</mi>
       <mi>s</mi>
       <mi>n</mi>
      </msubsup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝚼</ci>
     <ci>s</ci>
    </apply>
    <vector>
     <apply>
      <times></times>
      <ci>ϕ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>s</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <ci>ϕ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>s</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\Upsilon}_{s}=\left(\phi(x_{s}^{1}),\dots,\phi(x_{s}^{n})\right)
  </annotation>
 </semantics>
</math>

 is the feature matrix for the samples from 

<math display="inline" id="Kernel_embedding_of_distributions:191">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{s}
  </annotation>
 </semantics>
</math>

.</p>

<p>Thus, if the incoming messages to node <em>t</em> are linear combinations of feature mapped samples from 

<math display="inline" id="Kernel_embedding_of_distributions:192">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{t}
  </annotation>
 </semantics>
</math>

, then the outgoing message from this node is also a linear combination of feature mapped samples from 

<math display="inline" id="Kernel_embedding_of_distributions:193">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{s}
  </annotation>
 </semantics>
</math>


. This RKHS function representation of message-passing updates therefore produces an efficient belief propagation algorithm in which the <a href="Markov_Random_Field#Clique_factorization" title="wikilink">potentials</a> are nonparametric functions inferred from the data so that arbitrary statistical relationships may be modeled.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a></p>
<h3 id="nonparametric-filtering-in-hidden-markov-models">Nonparametric filtering in hidden Markov models</h3>

<p>In the <a href="hidden_Markov_model" title="wikilink">hidden Markov model</a> (HMM), two key quantities of interest are the transition probabilities between hidden states 

<math display="inline" id="Kernel_embedding_of_distributions:194">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>S</mi>
     <mi>t</mi>
    </msup>
    <mo>∣</mo>
    <msup>
     <mi>S</mi>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(S^{t}\mid S^{t-1})
  </annotation>
 </semantics>
</math>

 and the emission probabilities 

<math display="inline" id="Kernel_embedding_of_distributions:195">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>O</mi>
     <mi>t</mi>
    </msup>
    <mo>∣</mo>
    <msup>
     <mi>S</mi>
     <mi>t</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>O</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(O^{t}\mid S^{t})
  </annotation>
 </semantics>
</math>

 for observations. Using the kernel conditional distribution embedding framework, these quantities may be expressed in terms of samples from the HMM. A serious limitation of the embedding methods in this domain is the need for training samples containing hidden states, as otherwise inference with arbitrary distributions in the HMM is not possible.</p>

<p>One common use of HMMs is <a href="Hidden_Markov_Model#Filtering" title="wikilink">filtering</a> in which the goal is to estimate posterior distribution over the hidden state 

<math display="inline" id="Kernel_embedding_of_distributions:196">
 <semantics>
  <msup>
   <mi>s</mi>
   <mi>t</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>s</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{t}
  </annotation>
 </semantics>
</math>

 at time step <em>t</em> given a history of previous observations 

<math display="inline" id="Kernel_embedding_of_distributions:197">
 <semantics>
  <mrow>
   <msup>
    <mi>h</mi>
    <mi>t</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>o</mi>
     <mn>1</mn>
    </msup>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msup>
     <mi>o</mi>
     <mi>t</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>h</ci>
     <ci>t</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>o</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>o</ci>
      <ci>t</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h^{t}=(o^{1},\dots,o^{t})
  </annotation>
 </semantics>
</math>

 from the system. In filtering, a <strong>belief state</strong> 

<math display="inline" id="Kernel_embedding_of_distributions:198">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>S</mi>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>∣</mo>
    <msup>
     <mi>h</mi>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>h</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(S^{t+1}\mid h^{t+1})
  </annotation>
 </semantics>
</math>


 is recursively maintained via a prediction step (where updates 

<math display="inline" id="Kernel_embedding_of_distributions:199">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>S</mi>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>∣</mo>
    <msup>
     <mi>h</mi>
     <mi>t</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>𝔼</mi>
    <mrow>
     <msup>
      <mi>S</mi>
      <mi>t</mi>
     </msup>
     <mo>∣</mo>
     <msup>
      <mi>h</mi>
      <mi>t</mi>
     </msup>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>S</mi>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mo>∣</mo>
     <msup>
      <mi>S</mi>
      <mi>t</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>h</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝔼</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <ci>t</ci>
      </apply>
      <ci>normal-∣</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <ci>t</ci>
      </apply>
     </cerror>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-∣</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <ci>t</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(S^{t+1}\mid h^{t})=\mathbb{E}_{S^{t}\mid h^{t}}[P(S^{t+1}\mid S^{t})]
  </annotation>
 </semantics>
</math>

 are computed by marginalizing out the previous hidden state) followed by a conditioning step (where updates 

<math display="inline" id="Kernel_embedding_of_distributions:200">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>S</mi>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>∣</mo>
    <msup>
     <mi>h</mi>
     <mi>t</mi>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>o</mi>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∝</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>o</mi>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>∣</mo>
    <msup>
     <mi>S</mi>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>S</mi>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>∣</mo>
    <msup>
     <mi>h</mi>
     <mi>t</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>h</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>o</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proportional-to</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>o</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>h</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(S^{t+1}\mid h^{t},o^{t+1})\propto P(o^{t+1}\mid S^{t+1})P(S^{t+1}\mid h^{t})
  </annotation>
 </semantics>
</math>

 are computed by applying Bayes' rule to condition on a new observation).<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> The RKHS embedding of the belief state at time <em>t+1</em> can be recursively expressed as</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:201">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mrow>
     <msup>
      <mi>S</mi>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mo>∣</mo>
     <msup>
      <mi>h</mi>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     <mrow>
      <msup>
       <mi>S</mi>
       <mrow>
        <mi>t</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <msup>
       <mi>O</mi>
       <mrow>
        <mi>t</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <mi>π</mi>
    </msubsup>
    <msup>
     <mrow>
      <mo>(</mo>
      <msubsup>
       <mi class="ltx_font_mathcaligraphic">𝒞</mi>
       <mrow>
        <msup>
         <mi>O</mi>
         <mrow>
          <mi>t</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msup>
        <msup>
         <mi>O</mi>
         <mrow>
          <mi>t</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msup>
       </mrow>
       <mi>π</mi>
      </msubsup>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>o</mi>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-∣</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </cerror>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝒞</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>S</ci>
         <apply>
          <plus></plus>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>O</ci>
         <apply>
          <plus></plus>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>π</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝒞</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>O</ci>
          <apply>
           <plus></plus>
           <ci>t</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>O</ci>
          <apply>
           <plus></plus>
           <ci>t</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <ci>π</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>ϕ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>o</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{S^{t+1}\mid h^{t+1}}=\mathcal{C}_{S^{t+1}O^{t+1}}^{\pi}\left(\mathcal{C}_%
{O^{t+1}O^{t+1}}^{\pi}\right)^{-1}\phi(o^{t+1})
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>by computing the embeddings of the prediction step via the <a href="#Kernel_Sum_Rule" title="wikilink">kernel sum rule</a> and the embedding of the conditioning step via <a href="#Kernel_Bayes'_Rule" title="wikilink">kernel Bayes' rule</a>. Assuming a training sample 

<math display="inline" id="Kernel_embedding_of_distributions:202">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msup>
    <mover accent="true">
     <mi>s</mi>
     <mo>~</mo>
    </mover>
    <mn>1</mn>
   </msup>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msup>
    <mover accent="true">
     <mi>s</mi>
     <mo>~</mo>
    </mover>
    <mi>T</mi>
   </msup>
   <mo>,</mo>
   <msup>
    <mover accent="true">
     <mi>o</mi>
     <mo>~</mo>
    </mover>
    <mn>1</mn>
   </msup>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msup>
    <mover accent="true">
     <mi>o</mi>
     <mo>~</mo>
    </mover>
    <mi>T</mi>
   </msup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>s</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>s</ci>
     </apply>
     <ci>T</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>o</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>o</ci>
     </apply>
     <ci>T</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\widetilde{s}^{1},\dots,\widetilde{s}^{T},\widetilde{o}^{1},\dots,\widetilde{%
o}^{T})
  </annotation>
 </semantics>
</math>

 is given, one can in practice estimate 

<math display="inline" id="Kernel_embedding_of_distributions:203">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>μ</mi>
     <mo>^</mo>
    </mover>
    <mrow>
     <msup>
      <mi>S</mi>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mo>∣</mo>
     <msup>
      <mi>h</mi>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>T</mi>
    </msubsup>
    <mrow>
     <msubsup>
      <mi>α</mi>
      <mi>i</mi>
      <mi>t</mi>
     </msubsup>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mover accent="true">
        <mi>s</mi>
        <mo>~</mo>
       </mover>
       <mi>t</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>μ</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-∣</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </cerror>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>T</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
      </apply>
      <ci>ϕ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>s</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\mu}_{S^{t+1}\mid h^{t+1}}=\sum_{i=1}^{T}\alpha_{i}^{t}\phi(%
\widetilde{s}^{t})
  </annotation>
 </semantics>
</math>


 and filtering with kernel embeddings is thus implemented recursively using the following updates for the weights 

<math display="inline" id="Kernel_embedding_of_distributions:204">
 <semantics>
  <mrow>
   <mi>𝜶</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>α</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>α</mi>
     <mi>T</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝜶</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>T</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\alpha}=(\alpha_{1},\dots,\alpha_{T})
  </annotation>
 </semantics>
</math>

 <a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:205">
 <semantics>
  <mrow>
   <msup>
    <mi>𝐃</mi>
    <mrow>
     <mi>t</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <mtext>diag</mtext>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>G</mi>
         <mo>+</mo>
         <mrow>
          <mi>λ</mi>
          <mi>𝐈</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mover accent="true">
       <mi>G</mi>
       <mo>~</mo>
      </mover>
      <msup>
       <mi>𝜶</mi>
       <mi>t</mi>
      </msup>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐃</ci>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <mtext>diag</mtext>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <ci>G</ci>
        <apply>
         <times></times>
         <ci>λ</ci>
         <ci>𝐈</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <ci>normal-~</ci>
       <ci>G</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝜶</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{D}^{t+1}=\text{diag}\left((G+\lambda\mathbf{I})^{-1}\widetilde{G}%
\boldsymbol{\alpha}^{t}\right)
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:206">
 <semantics>
  <mrow>
   <msup>
    <mi>𝜶</mi>
    <mrow>
     <mi>t</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>𝐃</mi>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>𝐊</mi>
    <msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msup>
           <mi>𝐃</mi>
           <mrow>
            <mi>t</mi>
            <mo>+</mo>
            <mn>1</mn>
           </mrow>
          </msup>
          <mi>K</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
       <mo>+</mo>
       <mrow>
        <mover accent="true">
         <mi>λ</mi>
         <mo>~</mo>
        </mover>
        <mi>𝐈</mi>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <msup>
     <mi>𝐃</mi>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <msub>
     <mi>𝐊</mi>
     <msup>
      <mi>o</mi>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝜶</ci>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐃</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>𝐊</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>𝐃</ci>
          <apply>
           <plus></plus>
           <ci>t</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>K</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <apply>
         <ci>normal-~</ci>
         <ci>λ</ci>
        </apply>
        <ci>𝐈</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐃</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐊</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>o</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\alpha}^{t+1}=\mathbf{D}^{t+1}\mathbf{K}\left((\mathbf{D}^{t+1}K)^%
{2}+\widetilde{\lambda}\mathbf{I}\right)^{-1}\mathbf{D}^{t+1}\mathbf{K}_{o^{t+%
1}}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where 

<math display="inline" id="Kernel_embedding_of_distributions:207">
 <semantics>
  <mrow>
   <mi>𝐆</mi>
   <mo>,</mo>
   <mi>𝐊</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>𝐆</ci>
    <ci>𝐊</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G},\mathbf{K}
  </annotation>
 </semantics>
</math>

 denote the Gram matrices of 

<math display="inline" id="Kernel_embedding_of_distributions:208">
 <semantics>
  <mrow>
   <msup>
    <mover accent="true">
     <mi>s</mi>
     <mo>~</mo>
    </mover>
    <mn>1</mn>
   </msup>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msup>
    <mover accent="true">
     <mi>s</mi>
     <mo>~</mo>
    </mover>
    <mi>T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>s</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>s</ci>
     </apply>
     <ci>T</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widetilde{s}^{1},\dots,\widetilde{s}^{T}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Kernel_embedding_of_distributions:209">
 <semantics>
  <mrow>
   <msup>
    <mover accent="true">
     <mi>o</mi>
     <mo>~</mo>
    </mover>
    <mn>1</mn>
   </msup>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msup>
    <mover accent="true">
     <mi>o</mi>
     <mo>~</mo>
    </mover>
    <mi>T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>o</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>o</ci>
     </apply>
     <ci>T</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widetilde{o}^{1},\dots,\widetilde{o}^{T}
  </annotation>
 </semantics>
</math>

 respectively, 

<math display="inline" id="Kernel_embedding_of_distributions:210">
 <semantics>
  <mover accent="true">
   <mi>𝐆</mi>
   <mo>~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>𝐆</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widetilde{\mathbf{G}}
  </annotation>
 </semantics>
</math>

 is a transfer Gram matrix defined as 

<math display="inline" id="Kernel_embedding_of_distributions:211">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>𝐆</mi>
     <mo>~</mo>
    </mover>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mover accent="true">
       <mi>s</mi>
       <mo>~</mo>
      </mover>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mover accent="true">
       <mi>s</mi>
       <mo>~</mo>
      </mover>
      <mrow>
       <mi>j</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>𝐆</ci>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>k</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>s</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>s</ci>
       </apply>
       <apply>
        <plus></plus>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widetilde{\mathbf{G}}_{ij}=k(\widetilde{s}_{i},\widetilde{s}_{j+1})
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Kernel_embedding_of_distributions:212">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐊</mi>
    <msup>
     <mi>o</mi>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </msub>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>k</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mover accent="true">
         <mi>o</mi>
         <mo>~</mo>
        </mover>
        <mn>1</mn>
       </msup>
       <mo>,</mo>
       <msup>
        <mi>o</mi>
        <mrow>
         <mi>t</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mi>k</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mover accent="true">
         <mi>o</mi>
         <mo>~</mo>
        </mover>
        <mi>T</mi>
       </msup>
       <mo>,</mo>
       <msup>
        <mi>o</mi>
        <mrow>
         <mi>t</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐊</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>o</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <vector>
      <apply>
       <times></times>
       <ci>k</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <ci>normal-~</ci>
          <ci>o</ci>
         </apply>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>o</ci>
         <apply>
          <plus></plus>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </interval>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <ci>k</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <ci>normal-~</ci>
          <ci>o</ci>
         </apply>
         <ci>T</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>o</ci>
         <apply>
          <plus></plus>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </interval>
      </apply>
     </vector>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{K}_{o^{t+1}}=(k(\widetilde{o}^{1},o^{t+1}),\dots,k(\widetilde{o}^{T},o%
^{t+1}))^{T}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="support-measure-machines">Support measure machines</h3>

<p>The <strong>support measure machine</strong> (SMM) is a generalization of the <a href="support_vector_machine" title="wikilink">support vector machine</a> (SVM) in which the training examples are probability distributions paired with labels 

<math display="inline" id="Kernel_embedding_of_distributions:213">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mrow>
      <mo stretchy="false">{</mo>
      <msub>
       <mi>P</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">}</mo>
     </mrow>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mo rspace="7.5pt">,</mo>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <set>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
       </set>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
    </list>
    <set>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{P_{i},y_{i}\}_{i=1}^{n},\ y_{i}\in\{+1,-1\}
  </annotation>
 </semantics>
</math>


.<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> SMMs solve the standard SVM <a href="Support_vector_machine#Dual_form" title="wikilink">dual optimization problem</a> using the following <strong>expected kernel</strong></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:214">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>Q</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <msub>
      <mi>μ</mi>
      <mi>X</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>μ</mi>
      <mi>Z</mi>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝔼</mi>
     <mrow>
      <mi>X</mi>
      <mi>Z</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>k</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>K</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>P</ci>
        <ci>X</ci>
       </apply>
       <apply>
        <times></times>
        <ci>Q</ci>
        <ci>Z</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <ci>X</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <ci>Z</ci>
       </apply>
      </list>
      <ci>ℋ</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝔼</ci>
       <apply>
        <times></times>
        <ci>X</ci>
        <ci>Z</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>k</ci>
        <interval closure="open">
         <ci>x</ci>
         <ci>z</ci>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\left(P(X),Q(Z)\right)=\langle\mu_{X},\mu_{Z}\rangle_{\mathcal{H}}=\mathbb{E}%
_{XZ}[k(x,z)]
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>which is computable in closed form for many common specific distributions 

<math display="inline" id="Kernel_embedding_of_distributions:215">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}
  </annotation>
 </semantics>
</math>

 (such as the Gaussian distribution) combined with popular embedding kernels 

<math display="inline" id="Kernel_embedding_of_distributions:216">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 (e.g. the Gaussian kernel or polynomial kernel), or can be accurately empirically estimated from i.i.d. samples 

<math display="inline" id="Kernel_embedding_of_distributions:217">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mrow>
      <mo stretchy="false">{</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">}</mo>
     </mrow>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mo>∼</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msubsup>
     <mrow>
      <mo stretchy="false">{</mo>
      <msub>
       <mi>z</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">}</mo>
     </mrow>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>m</mi>
    </msubsup>
    <mo>∼</mo>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">similar-to</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <set>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </set>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">similar-to</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <set>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <ci>j</ci>
        </apply>
       </set>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>Z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x_{i}\}_{i=1}^{n}\sim P(X),\{z_{j}\}_{j=1}^{m}\sim Q(Z)
  </annotation>
 </semantics>
</math>

 via</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:218">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>K</mi>
     <mo>^</mo>
    </mover>
    <mrow>
     <mo>(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mi>Z</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mi>n</mi>
      <mi>m</mi>
     </mrow>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>m</mi>
      </msubsup>
      <mrow>
       <mi>k</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>z</mi>
         <mi>j</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>K</ci>
     </apply>
     <interval closure="open">
      <ci>X</ci>
      <ci>Z</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>m</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>m</ci>
       </apply>
       <apply>
        <times></times>
        <ci>k</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <ci>j</ci>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{K}\left(X,Z\right)=\frac{1}{nm}\sum_{i=1}^{n}\sum_{j=1}^{m}k(x_{i},z_%
{j})
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
</dl>

<p>Under certain choices of the embedding kernel 

<math display="inline" id="Kernel_embedding_of_distributions:219">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, the SMM applied to training examples 

<math display="inline" id="Kernel_embedding_of_distributions:220">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>P</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{P_{i},y_{i}\}_{i=1}^{n}
  </annotation>
 </semantics>
</math>

 is equivalent to a SVM trained on samples 

<math display="inline" id="Kernel_embedding_of_distributions:221">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x_{i},y_{i}\}_{i=1}^{n}
  </annotation>
 </semantics>
</math>

, and thus the SMM can be viewed as a <em>flexible</em> SVM in which a different data-dependent kernel (specified by the assumed form of the distribution 

<math display="inline" id="Kernel_embedding_of_distributions:222">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}
  </annotation>
 </semantics>
</math>

) may be placed on each training point.<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a></p>
<h3 id="domain-adaptation-under-covariate-target-and-conditional-shift">Domain adaptation under covariate, target, and conditional shift</h3>

<p>The goal of <a href="Domain_Adaptation" title="wikilink">domain adaptation</a> is the formulation of learning algorithms which generalize well when the training and test data have different distributions. Given training examples 

<math display="inline" id="Kernel_embedding_of_distributions:223">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>x</mi>
      <mi>i</mi>
      <mrow>
       <mi>t</mi>
       <mi>r</mi>
      </mrow>
     </msubsup>
     <mo>,</mo>
     <msubsup>
      <mi>y</mi>
      <mi>i</mi>
      <mrow>
       <mi>t</mi>
       <mi>r</mi>
      </mrow>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <times></times>
         <ci>t</ci>
         <ci>r</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <times></times>
         <ci>t</ci>
         <ci>r</ci>
        </apply>
       </apply>
      </interval>
     </set>
     <apply>
      <eq></eq>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(x_{i}^{tr},y_{i}^{tr})\}_{i=1}^{n}
  </annotation>
 </semantics>
</math>


 and a test set 

<math display="inline" id="Kernel_embedding_of_distributions:224">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>x</mi>
      <mi>j</mi>
      <mrow>
       <mi>t</mi>
       <mi>e</mi>
      </mrow>
     </msubsup>
     <mo>,</mo>
     <msubsup>
      <mi>y</mi>
      <mi>j</mi>
      <mrow>
       <mi>t</mi>
       <mi>e</mi>
      </mrow>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>j</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>m</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>j</ci>
        </apply>
        <apply>
         <times></times>
         <ci>t</ci>
         <ci>e</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>j</ci>
        </apply>
        <apply>
         <times></times>
         <ci>t</ci>
         <ci>e</ci>
        </apply>
       </apply>
      </interval>
     </set>
     <apply>
      <eq></eq>
      <ci>j</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(x_{j}^{te},y_{j}^{te})\}_{j=1}^{m}
  </annotation>
 </semantics>
</math>

 where the 

<math display="inline" id="Kernel_embedding_of_distributions:225">
 <semantics>
  <msubsup>
   <mi>y</mi>
   <mi>j</mi>
   <mrow>
    <mi>t</mi>
    <mi>e</mi>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{j}^{te}
  </annotation>
 </semantics>
</math>

 are unknown, three types of differences are commonly assumed between the distribution of the training examples 

<math display="inline" id="Kernel_embedding_of_distributions:226">
 <semantics>
  <mrow>
   <msup>
    <mi>P</mi>
    <mrow>
     <mi>t</mi>
     <mi>r</mi>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>t</ci>
      <ci>r</ci>
     </apply>
    </apply>
    <interval closure="open">
     <ci>X</ci>
     <ci>Y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{tr}(X,Y)
  </annotation>
 </semantics>
</math>

 and the test distribution 

<math display="inline" id="Kernel_embedding_of_distributions:227">
 <semantics>
  <mrow>
   <msup>
    <mi>P</mi>
    <mrow>
     <mi>t</mi>
     <mi>e</mi>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>t</ci>
      <ci>e</ci>
     </apply>
    </apply>
    <interval closure="open">
     <ci>X</ci>
     <ci>Y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{te}(X,Y)
  </annotation>
 </semantics>
</math>

:<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a><a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a></p>
<ol>
<li><strong>Covariate Shift</strong> in which the marginal distribution of the covariates changes across domains

<math display="block" id="Kernel_embedding_of_distributions:228">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>P</mi>
     <mrow>
      <mi>t</mi>
      <mi>r</mi>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mrow>
    <msup>
     <mi>P</mi>
     <mrow>
      <mi>t</mi>
      <mi>e</mi>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>t</ci>
       <ci>r</ci>
      </apply>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>t</ci>
       <ci>e</ci>
      </apply>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{tr}(X)\neq P^{te}(X)
  </annotation>
 </semantics>
</math>

</li>
<li><strong>Target Shift</strong> in which the marginal distribution of the outputs changes across domains

<math display="block" id="Kernel_embedding_of_distributions:229">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>P</mi>
     <mrow>
      <mi>t</mi>
      <mi>r</mi>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mrow>
    <msup>
     <mi>P</mi>
     <mrow>
      <mi>t</mi>
      <mi>e</mi>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>t</ci>
       <ci>r</ci>
      </apply>
     </apply>
     <ci>Y</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>t</ci>
       <ci>e</ci>
      </apply>
     </apply>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{tr}(Y)\neq P^{te}(Y)
  </annotation>
 </semantics>
</math>

</li>
<li><strong>Conditional Shift</strong> in which 

<math display="inline" id="Kernel_embedding_of_distributions:230">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(Y)
  </annotation>
 </semantics>
</math>

 remains the same across domains, but the conditional distributions differ

<math display="block" id="Kernel_embedding_of_distributions:231">
 <semantics>
  <mrow>
   <msup>
    <mi>P</mi>
    <mrow>
     <mi>t</mi>
     <mi>r</mi>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>∣</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≠</mo>
   <msup>
    <mi>P</mi>
    <mrow>
     <mi>t</mi>
     <mi>e</mi>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>∣</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>t</ci>
      <ci>r</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>t</ci>
      <ci>e</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{tr}(X\mid Y)\neq P^{te}(X\mid Y)
  </annotation>
 </semantics>
</math>

. In general, the presence of conditional shift leads to an <a href="Well-posed_problem" title="wikilink">ill-posed</a> problem, and the additional assumption that 

<math display="inline" id="Kernel_embedding_of_distributions:232">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>∣</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X\mid Y)
  </annotation>
 </semantics>
</math>

 changes only under <a href="Location_parameter" title="wikilink">location</a>-<a href="Scale_parameter" title="wikilink">scale</a> (LS) transformations on 

<math display="inline" id="Kernel_embedding_of_distributions:233">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>


 is commonly imposed to make the problem tractable.</li>
</ol>

<p>By utilizing the kernel embedding of marginal and conditional distributions, practical approaches to deal with the presence of these types of differences between training and test domains can be formulated. Covariate shift may be accounted for by reweighting examples via estimates of the ratio 

<math display="inline" id="Kernel_embedding_of_distributions:234">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>P</mi>
      <mrow>
       <mi>t</mi>
       <mi>e</mi>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <msup>
     <mi>P</mi>
     <mrow>
      <mi>t</mi>
      <mi>r</mi>
     </mrow>
    </msup>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>P</ci>
       <apply>
        <times></times>
        <ci>t</ci>
        <ci>e</ci>
       </apply>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>t</ci>
       <ci>r</ci>
      </apply>
     </apply>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{te}(X)/P^{tr}(X)
  </annotation>
 </semantics>
</math>

 obtained directly from the kernel embeddings of the marginal distributions of 

<math display="inline" id="Kernel_embedding_of_distributions:235">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 in each domain without any need for explicit estimation of the distributions.<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> Target shift, which cannot be similarly dealt with since no samples from 

<math display="inline" id="Kernel_embedding_of_distributions:236">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 are available in the test domain, is accounted for by weighting training examples using the vector 

<math display="inline" id="Kernel_embedding_of_distributions:237">
 <semantics>
  <mrow>
   <msup>
    <mi>𝜷</mi>
    <mo>*</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>𝐲</mi>
     <mrow>
      <mi>t</mi>
      <mi>r</mi>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝜷</ci>
     <times></times>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐲</ci>
     <apply>
      <times></times>
      <ci>t</ci>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\beta}^{*}(\mathbf{y}^{tr})
  </annotation>
 </semantics>
</math>

 which solves the following optimization problem (where in practice, empirical approximations must be used) <a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:238">
 <semantics>
  <mrow>
   <msub>
    <mi>min</mi>
    <mrow>
     <mi>𝜷</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
   <msubsup>
    <mrow>
     <mo fence="true">||</mo>
     <mrow>
      <mrow>
       <msub>
        <mi class="ltx_font_mathcaligraphic">𝒞</mi>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>X</mi>
          <mo>∣</mo>
          <mi>Y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mrow>
          <mi>t</mi>
          <mi>r</mi>
         </mrow>
        </msup>
       </msub>
       <msub>
        <mi>𝔼</mi>
        <msup>
         <mi>Y</mi>
         <mrow>
          <mi>t</mi>
          <mi>r</mi>
         </mrow>
        </msup>
       </msub>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mi>𝜷</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>ϕ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <msub>
       <mi>μ</mi>
       <msup>
        <mi>X</mi>
        <mrow>
         <mi>t</mi>
         <mi>e</mi>
        </mrow>
       </msup>
      </msub>
     </mrow>
     <mo fence="true">||</mo>
    </mrow>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
    <mn>2</mn>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <min></min>
     <apply>
      <times></times>
      <ci>𝜷</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝒞</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <cerror>
            <csymbol cd="ambiguous">fragments</csymbol>
            <ci>normal-(</ci>
            <csymbol cd="unknown">X</csymbol>
            <ci>normal-∣</ci>
            <csymbol cd="unknown">Y</csymbol>
            <ci>normal-)</ci>
           </cerror>
           <apply>
            <times></times>
            <ci>t</ci>
            <ci>r</ci>
           </apply>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝔼</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>Y</ci>
           <apply>
            <times></times>
            <ci>t</ci>
            <ci>r</ci>
           </apply>
          </apply>
         </apply>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <times></times>
           <ci>𝜷</ci>
           <ci>y</ci>
           <ci>ϕ</ci>
           <ci>y</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>μ</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>X</ci>
          <apply>
           <times></times>
           <ci>t</ci>
           <ci>e</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>ℋ</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min_{\boldsymbol{\beta}(y)}\left|\left|\mathcal{C}_{{(X\mid Y)}^{tr}}\mathbb{%
E}_{Y^{tr}}[\boldsymbol{\beta}(y)\phi(y)]-\mu_{X^{te}}\right|\right|_{\mathcal%
{H}}^{2}
  </annotation>
 </semantics>
</math>


 subject to 

<math display="inline" id="Kernel_embedding_of_distributions:239">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝜷</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>𝔼</mi>
      <msup>
       <mi>Y</mi>
       <mrow>
        <mi>t</mi>
        <mi>r</mi>
       </mrow>
      </msup>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>𝜷</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <geq></geq>
     <apply>
      <times></times>
      <ci>𝜷</ci>
      <ci>y</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝔼</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Y</ci>
        <apply>
         <times></times>
         <ci>t</ci>
         <ci>r</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>𝜷</ci>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\beta}(y)\geq 0,\mathbb{E}_{Y^{tr}}[\boldsymbol{\beta}(y)]=1
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>To deal with location scale conditional shift, one can perform a LS transformation of the training points to obtain new transformed training data 

<math display="inline" id="Kernel_embedding_of_distributions:240">
 <semantics>
  <mrow>
   <msup>
    <mi>𝐗</mi>
    <mrow>
     <mi>n</mi>
     <mi>e</mi>
     <mi>w</mi>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>𝐗</mi>
      <mrow>
       <mi>t</mi>
       <mi>r</mi>
      </mrow>
     </msup>
     <mo>⊙</mo>
     <mi>𝐖</mi>
    </mrow>
    <mo>+</mo>
    <mi>𝐁</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐗</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>e</ci>
      <ci>w</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="latexml">direct-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐗</ci>
       <apply>
        <times></times>
        <ci>t</ci>
        <ci>r</ci>
       </apply>
      </apply>
      <ci>𝐖</ci>
     </apply>
     <ci>𝐁</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{X}^{new}=\mathbf{X}^{tr}\odot\mathbf{W}+\mathbf{B}
  </annotation>
 </semantics>
</math>

 (where 

<math display="inline" id="Kernel_embedding_of_distributions:241">
 <semantics>
  <mo>⊙</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">direct-product</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \odot
  </annotation>
 </semantics>
</math>

 denotes the element-wise vector product). To ensure similar distributions between the new transformed training samples and the test data, 

<math display="inline" id="Kernel_embedding_of_distributions:242">
 <semantics>
  <mrow>
   <mi>𝐖</mi>
   <mo>,</mo>
   <mi>𝐁</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>𝐖</ci>
    <ci>𝐁</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{W},\mathbf{B}
  </annotation>
 </semantics>
</math>

 are estimated by minimizing the following empirical kernel embedding distance <a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:243">
 <semantics>
  <mrow>
   <msubsup>
    <mrow>
     <mo fence="true">||</mo>
     <mrow>
      <msub>
       <mover accent="true">
        <mi>μ</mi>
        <mo>^</mo>
       </mover>
       <msup>
        <mi>X</mi>
        <mrow>
         <mi>n</mi>
         <mi>e</mi>
         <mi>w</mi>
        </mrow>
       </msup>
      </msub>
      <mo>-</mo>
      <msub>
       <mover accent="true">
        <mi>μ</mi>
        <mo>^</mo>
       </mover>
       <msup>
        <mi>X</mi>
        <mrow>
         <mi>t</mi>
         <mi>e</mi>
        </mrow>
       </msup>
      </msub>
     </mrow>
     <mo fence="true">||</mo>
    </mrow>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
    <mn>2</mn>
   </msubsup>
   <mo>=</mo>
   <msubsup>
    <mrow>
     <mo fence="true">||</mo>
     <mrow>
      <mrow>
       <msub>
        <mover accent="true">
         <mi class="ltx_font_mathcaligraphic">𝒞</mi>
         <mo>^</mo>
        </mover>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>X</mi>
          <mo>∣</mo>
          <mi>Y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mrow>
          <mi>n</mi>
          <mi>e</mi>
          <mi>w</mi>
         </mrow>
        </msup>
       </msub>
       <msub>
        <mover accent="true">
         <mi>μ</mi>
         <mo>^</mo>
        </mover>
        <msup>
         <mi>Y</mi>
         <mrow>
          <mi>t</mi>
          <mi>r</mi>
         </mrow>
        </msup>
       </msub>
      </mrow>
      <mo>-</mo>
      <msub>
       <mover accent="true">
        <mi>μ</mi>
        <mo>^</mo>
       </mover>
       <msup>
        <mi>X</mi>
        <mrow>
         <mi>t</mi>
         <mi>e</mi>
        </mrow>
       </msup>
      </msub>
     </mrow>
     <mo fence="true">||</mo>
    </mrow>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
    <mn>2</mn>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-^</ci>
          <ci>μ</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>X</ci>
          <apply>
           <times></times>
           <ci>n</ci>
           <ci>e</ci>
           <ci>w</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-^</ci>
          <ci>μ</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>X</ci>
          <apply>
           <times></times>
           <ci>t</ci>
           <ci>e</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>ℋ</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <ci>normal-^</ci>
           <ci>𝒞</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <cerror>
            <csymbol cd="ambiguous">fragments</csymbol>
            <ci>normal-(</ci>
            <csymbol cd="unknown">X</csymbol>
            <ci>normal-∣</ci>
            <csymbol cd="unknown">Y</csymbol>
            <ci>normal-)</ci>
           </cerror>
           <apply>
            <times></times>
            <ci>n</ci>
            <ci>e</ci>
            <ci>w</ci>
           </apply>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <ci>normal-^</ci>
           <ci>μ</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>Y</ci>
           <apply>
            <times></times>
            <ci>t</ci>
            <ci>r</ci>
           </apply>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-^</ci>
          <ci>μ</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>X</ci>
          <apply>
           <times></times>
           <ci>t</ci>
           <ci>e</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>ℋ</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left|\left|\widehat{\mu}_{X^{new}}-\widehat{\mu}_{X^{te}}\right|\right|_{%
\mathcal{H}}^{2}=\left|\left|\widehat{\mathcal{C}}_{(X\mid Y)^{new}}\widehat{%
\mu}_{Y^{tr}}-\widehat{\mu}_{X^{te}}\right|\right|_{\mathcal{H}}^{2}
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
</dl>

<p>In general, the kernel embedding methods for dealing with LS conditional shift and target shift may be combined to find a reweighted transformation of the training data which mimics the test distribution, and these methods may perform well even in the presence of conditional shifts other than location-scale changes.<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a></p>
<h3 id="domain-generalization-via-invariant-feature-representation">Domain generalization via invariant feature representation</h3>

<p>Given <em>N</em> sets of training examples sampled i.i.d. from distributions 

<math display="inline" id="Kernel_embedding_of_distributions:244">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msup>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <msup>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>N</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <cn type="integer">1</cn>
     </apply>
     <interval closure="open">
      <ci>X</ci>
      <ci>Y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <cn type="integer">2</cn>
     </apply>
     <interval closure="open">
      <ci>X</ci>
      <ci>Y</ci>
     </interval>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <ci>N</ci>
     </apply>
     <interval closure="open">
      <ci>X</ci>
      <ci>Y</ci>
     </interval>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{(1)}(X,Y),P^{(2)}(X,Y),\dots,P^{(N)}(X,Y)
  </annotation>
 </semantics>
</math>

, the goal of <strong>domain generalization</strong> is to formulate learning algorithms which perform well on test examples sampled from a previously unseen domain 

<math display="inline" id="Kernel_embedding_of_distributions:245">
 <semantics>
  <mrow>
   <msup>
    <mi>P</mi>
    <mo>*</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <times></times>
    </apply>
    <interval closure="open">
     <ci>X</ci>
     <ci>Y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{*}(X,Y)
  </annotation>
 </semantics>
</math>

 where no data from the test domain is available at training time. If conditional distributions 

<math display="inline" id="Kernel_embedding_of_distributions:246">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo>∣</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(Y\mid X)
  </annotation>
 </semantics>
</math>

 are assumed to be relatively similar across all domains, then a learner capable of domain generalization must estimate a functional relationship between the variables which is robust to changes in the marginals 

<math display="inline" id="Kernel_embedding_of_distributions:247">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X)
  </annotation>
 </semantics>
</math>

. Based on kernel embeddings of these distributions, Domain Invariant Component Analysis (DICA) is a method which determines the transformation of the training data that minimizes the difference between marginal distributions while preserving a common conditional distribution shared between all training domains.<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a> DICA thus extracts <em>invariants</em>, features that transfer across domains, and may be viewed as a generalization of many popular dimension-reduction methods such as <a href="kernel_principal_component_analysis" title="wikilink">kernel principal component analysis</a>, transfer component analysis, and covariance operator inverse regression.<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a></p>

<p>Defining a probability distribution 

<math display="inline" id="Kernel_embedding_of_distributions:248">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>


 on the RKHS 

<math display="inline" id="Kernel_embedding_of_distributions:249">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Kernel_embedding_of_distributions:250">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">𝒫</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>μ</mi>
       <mrow>
        <msup>
         <mi>X</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>i</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </msup>
        <msup>
         <mi>Y</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>i</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </msup>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mi>N</mi>
     </mrow>
     <mtext>for</mtext>
     <mi>i</mi>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>𝒫</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>X</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>Y</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>N</ci>
       </apply>
       <mtext>for</mtext>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <list>
     <ci>normal-…</ci>
     <ci>N</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}(\mu_{X^{(i)}Y^{(i)}})=1/N\text{ for }i=1,\dots,N
  </annotation>
 </semantics>
</math>

, DICA measures dissimilarity between domains via <strong>distributional variance</strong> which is computed as</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:251">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>V</mi>
     <mi class="ltx_font_mathcaligraphic">ℋ</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi class="ltx_font_mathcaligraphic">𝒫</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>N</mi>
     </mfrac>
     <mtext>tr</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝐆</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <msup>
       <mi>N</mi>
       <mn>2</mn>
      </msup>
     </mfrac>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mrow>
         <mi>i</mi>
         <mo>,</mo>
         <mi>j</mi>
        </mrow>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>N</mi>
      </msubsup>
      <msub>
       <mi>𝐆</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>ℋ</ci>
     </apply>
     <ci>𝒫</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>N</ci>
      </apply>
      <mtext>tr</mtext>
      <ci>𝐆</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>N</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <list>
           <ci>i</ci>
           <ci>j</ci>
          </list>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>N</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐆</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{\mathcal{H}}(\mathcal{P})=\frac{1}{N}\text{tr}(\mathbf{G})-\frac{1}{N^{2}}%
\sum_{i,j=1}^{N}\mathbf{G}_{ij}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Kernel_embedding_of_distributions:252">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐆</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <msub>
      <mi>μ</mi>
      <msup>
       <mi>X</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>i</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>μ</mi>
      <msup>
       <mi>X</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>j</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐆</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>X</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>X</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </list>
     <ci>ℋ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G}_{ij}=\langle\mu_{X^{(i)}},\mu_{X^{(j)}}\rangle_{\mathcal{H}}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>so 

<math display="inline" id="Kernel_embedding_of_distributions:253">
 <semantics>
  <mi>𝐆</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐆</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G}
  </annotation>
 </semantics>
</math>


 is a 

<math display="inline" id="Kernel_embedding_of_distributions:254">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>×</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\times N
  </annotation>
 </semantics>
</math>

 Gram matrix over the distributions from which the training data are sampled. Finding an <a href="Orthogonal_matrix" title="wikilink">orthogonal transform</a> onto a low-dimensional <a href="Linear_subspace" title="wikilink">subspace</a> <em>B</em> (in the feature space) which minimizes the distributional variance, DICA simultaneously ensures that <em>B</em> aligns with the <a href="Basis_function" title="wikilink">bases</a> of a <strong>central subspace</strong> <em>C</em> for which 

<math display="inline" id="Kernel_embedding_of_distributions:255">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 becomes independent of 

<math display="inline" id="Kernel_embedding_of_distributions:256">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 given 

<math display="inline" id="Kernel_embedding_of_distributions:257">
 <semantics>
  <mrow>
   <msup>
    <mi>C</mi>
    <mi>T</mi>
   </msup>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>C</ci>
     <ci>T</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{T}X
  </annotation>
 </semantics>
</math>

 across all domains. In the absence of target values 

<math display="inline" id="Kernel_embedding_of_distributions:258">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>


, an unsupervised version of DICA may be formulated which finds a low-dimensional subspace that minimizes distributional variance while simultaneously maximizing the variance of 

<math display="inline" id="Kernel_embedding_of_distributions:259">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 (in the feature space) across all domains (rather than preserving a central subspace).<a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a></p>
<h2 id="example">Example</h2>

<p>In this simple example, which is taken from Song et al.,<a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a> 

<math display="inline" id="Kernel_embedding_of_distributions:260">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>,</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>X</ci>
    <ci>Y</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X,Y
  </annotation>
 </semantics>
</math>

 are assumed to be <a href="Probability_distribution#Discrete_probability_distribution" title="wikilink">discrete random variables</a> which take values in the set 

<math display="inline" id="Kernel_embedding_of_distributions:261">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mi>K</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">1</cn>
    <ci>normal-…</ci>
    <ci>K</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{1,\dots,K\}
  </annotation>
 </semantics>
</math>

 and the kernel is chosen to be the <a href="Kronecker_delta" title="wikilink">Kronecker delta</a> function, so 

<math display="inline" id="Kernel_embedding_of_distributions:262">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <msup>
      <mi>x</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <msup>
      <mi>x</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>k</ci>
     <interval closure="open">
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>normal-′</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>δ</ci>
     <interval closure="open">
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>normal-′</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(x,x^{\prime})=\delta(x,x^{\prime})
  </annotation>
 </semantics>
</math>

. The feature map corresponding to this kernel is the <a href="standard_basis" title="wikilink">standard basis</a> vector 

<math display="inline" id="Kernel_embedding_of_distributions:263">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>𝐞</mi>
    <mi>x</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐞</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(x)=\mathbf{e}_{x}
  </annotation>
 </semantics>
</math>


. The kernel embeddings of such a distributions are thus vectors of marginal probabilities while the embeddings of joint distributions in this setting are 

<math display="inline" id="Kernel_embedding_of_distributions:264">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>×</mo>
   <mi>K</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\times K
  </annotation>
 </semantics>
</math>

 matrices specifying joint probability tables, and the explicit form of these embeddings is</p>
<dl>
<dd><dl>
<dd><math>\mu_X = \mathbb{E}_X [\mathbf{e}_x] = \left(
</math></dd>
</dl>
</dd>
</dl>

<p>\begin{array}{c} P(X=1) \\ \vdots \\ P(X=K) \\ \end{array} \right) </p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:265">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mrow>
     <mi>X</mi>
     <mi>Y</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>𝔼</mi>
    <mrow>
     <mi>X</mi>
     <mi>Y</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>𝐞</mi>
     <mi>X</mi>
    </msub>
    <mo>⊗</mo>
    <msub>
     <mi>e</mi>
     <mi>Y</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo maxsize="210%" minsize="210%">(</mo>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo>=</mo>
      <mi>s</mi>
      <mo>,</mo>
      <mi>Y</mi>
      <mo>=</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo maxsize="210%" minsize="210%">)</mo>
    </mrow>
    <mrow>
     <mrow>
      <mi>s</mi>
      <mo>,</mo>
      <mi>t</mi>
     </mrow>
     <mo>∈</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mi>K</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝒞</ci>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝔼</ci>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐞</ci>
      <ci>X</ci>
     </apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>Y</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">X</csymbol>
       <eq></eq>
       <csymbol cd="unknown">s</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">Y</csymbol>
       <eq></eq>
       <csymbol cd="unknown">t</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <in></in>
      <list>
       <ci>s</ci>
       <ci>t</ci>
      </list>
      <set>
       <cn type="integer">1</cn>
       <ci>normal-…</ci>
       <ci>K</ci>
      </set>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}_{XY}=\mathbb{E}_{XY}[\mathbf{e}_{X}\otimes e_{Y}]=\bigg(P(X=s,Y=t)%
\bigg)_{s,t\in\{1,\dots,K\}}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>The conditional distribution embedding operator 

<math display="inline" id="Kernel_embedding_of_distributions:266">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mrow>
     <mi>Y</mi>
     <mo>∣</mo>
     <mi>X</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     <mrow>
      <mi>Y</mi>
      <mi>X</mi>
     </mrow>
    </msub>
    <msubsup>
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     <mrow>
      <mi>X</mi>
      <mi>X</mi>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝒞</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">Y</csymbol>
      <ci>normal-∣</ci>
      <csymbol cd="unknown">X</csymbol>
     </cerror>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒞</ci>
      <apply>
       <times></times>
       <ci>Y</ci>
       <ci>X</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝒞</ci>
       <apply>
        <times></times>
        <ci>X</ci>
        <ci>X</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}_{Y\mid X}=\mathcal{C}_{YX}\mathcal{C}_{XX}^{-1}
  </annotation>
 </semantics>
</math>

 is in this setting a conditional probability table</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Kernel_embedding_of_distributions:267">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mrow>
     <mi>Y</mi>
     <mo>∣</mo>
     <mi>X</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo maxsize="210%" minsize="210%">(</mo>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Y</mi>
      <mo>=</mo>
      <mi>s</mi>
      <mo>∣</mo>
      <mi>X</mi>
      <mo>=</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo maxsize="210%" minsize="210%">)</mo>
    </mrow>
    <mrow>
     <mrow>
      <mi>s</mi>
      <mo>,</mo>
      <mi>t</mi>
     </mrow>
     <mo>∈</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mi>K</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝒞</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">Y</csymbol>
      <ci>normal-∣</ci>
      <csymbol cd="unknown">X</csymbol>
     </cerror>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">Y</csymbol>
       <eq></eq>
       <csymbol cd="unknown">s</csymbol>
       <ci>normal-∣</ci>
       <csymbol cd="unknown">X</csymbol>
       <eq></eq>
       <csymbol cd="unknown">t</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <in></in>
      <list>
       <ci>s</ci>
       <ci>t</ci>
      </list>
      <set>
       <cn type="integer">1</cn>
       <ci>normal-…</ci>
       <ci>K</ci>
      </set>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}_{Y\mid X}=\bigg(P(Y=s\mid X=t)\bigg)_{s,t\in\{1,\dots,K\}}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>and <math> \mathcal{C}_{XX} =\left(
</math></dd>
</dl>

<p>\begin{array}{c c c} P(X=1) &amp; \dots &amp; 0 \\ \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; \dots &amp; P(X=K) \\ \end{array} \right)  Thus, the embeddings of the conditional distribution under a fixed value of 

<math display="inline" id="Kernel_embedding_of_distributions:268">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>


 may be computed as</p>
<dl>
<dd><dl>
<dd><math> \mu_{Y \mid x} = \mathcal{C}_{Y \mid X} \phi(x) = \left(
</math></dd>
</dl>
</dd>
</dl>

<p>\begin{array}{c} P(Y=1 \mid X = x) \\ \vdots \\ P(Y=K \mid X = x) \\ \end{array} \right) </p>

<p>In this discrete-valued setting with the Kronecker delta kernel, the <a href="#Rules_of_probability_as_operations_in_the_RKHS" title="wikilink">kernel sum rule</a> becomes</p>
<dl>
<dd><dl>
<dd><math> \underbrace{ \left(
</math></dd>
</dl>
</dd>
</dl>

<p>\begin{array}{c} Q(X=1) \\ \vdots \\ P(X = N) \\ \end{array} \right) }_{\mu_Y^\pi} = \underbrace{ \left( \begin{array}{c} \\ P(X=s \mid Y=t) \\ \\ \end{array} \right) }_{ \mathcal{C}_{X\mid Y} } \underbrace{ \left( \begin{array}{c} \pi(Y=1) \\ \vdots \\ pi(Y = N) \\ \end{array} \right) }_{ \mu_Y^\pi} </p>

<p>The <a href="#Rules_of_probability_as_operations_in_the_RKHS" title="wikilink">kernel chain rule</a> in this case is given by</p>
<dl>
<dd><dl>
<dd><math> \underbrace{ \left( \begin{array}{c} \\ Q(X=s,Y=t) \\ \\ \end{array} \right) }_{\mathcal{C}_{XY}^\pi} =
</math></dd>
</dl>
</dd>
</dl>

<p><code>\underbrace{ \left( \begin{array}{c} \\ P(X=s \mid Y=t) \\ \\ \end{array} \right) }_{\mathcal{C}_{X \mid Y}} </code></p>

<p>\underbrace{ \left( \begin{array}{c c c} \pi(Y=1) &amp; \dots &amp; 0 \\ \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; \dots &amp; \pi(Y=K) \\ \end{array} \right) }_{\mathcal{C}_{YY}^\pi} </p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Machine_learning" title="wikilink">Category:Machine learning</a> <a class="uri" href="Category:Statistics" title="wikilink">Category:Statistics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">A. Smola, A. Gretton, L. Song, B. Schölkopf. (2007). <a href="http://eprints.pascal-network.org/archive/00003987/01/SmoGreSonSch07.pdf">A Hilbert Space Embedding for Distributions</a>. <em>Algorithmic Learning Theory: 18th International Conference</em>. Springer: 13–31.<a href="#fnref1">↩</a></li>
<li id="fn2">L. Song, K. Fukumizu, F. Dinuzzo, A. Gretton (2013). <a href="http://www.gatsby.ucl.ac.uk/~gretton/papers/SonFukGre13.pdf">Kernel Embeddings of Conditional Distributions: A unified kernel framework for nonparametric inference in graphical models</a>. <em>IEEE Signal Processing Magazine</em> <strong>30</strong>: 98–111.<a href="#fnref2">↩</a></li>
<li id="fn3">J. Shawe-Taylor, N. Christianini. (2004). <em>Kernel Methods for Pattern Analysis</em>. Cambridge University Press, Cambridge, UK.<a href="#fnref3">↩</a></li>
<li id="fn4">T. Hofmann, B. Schölkopf, A. Smola. (2008). [<a class="uri" href="http://projecteuclid.org/DPubS?service=UI&amp;version">http://projecteuclid.org/DPubS?service=UI&amp;version;</a>;=1.0&amp;verb;=Display&amp;handle;=euclid.aos/1211819561 Kernel Methods in Machine Learning]. <em>The Annals of Statistics</em> <strong>36</strong>(3):1171–1220.<a href="#fnref4">↩</a></li>
<li id="fn5">L. Song. (2008) <a href="http://www.cc.gatech.edu/~lsong/papers/lesong_thesis.pdf">Learning via Hilbert Space Embedding of Distributions</a>. PhD Thesis, University of Sidney.<a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9">K. Fukumizu, A. Gretton, X. Sun, and B. Schölkopf (2008). <a href="http://papers.nips.cc/paper/3340-kernel-measures-of-conditional-dependence.pdf">Kernel measures of conditional independence</a>. <em>Advances in Neural Information Processing Systems</em> <strong>20</strong>, MIT Press, Cambridge, MA.<a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11">L. Song, J. Huang, A. J. Smola, K. Fukumizu. (2009). <a href="http://www.stanford.edu/~jhuang11/research/pubs/icml09/icml09.pdf">Hilbert space embeddings of conditional distributions</a>. <em>Proc. Int. Conf. Machine Learning</em>. Montreal, Canada: 961-968.<a href="#fnref11">↩</a></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20">A. Gretton, K. Borgwardt, M. Rasch, B. Schölkopf, A. Smola. (2007). <a href="http://www.gatsby.ucl.ac.uk/~gretton/papers/GreBorRasSchSmo07.pdf">A kernel method for the two-sample-problem</a>. <em>Advances in Neural Information Processing Systems</em> <strong>19</strong>, MIT Press, Cambridge, MA.<a href="#fnref20">↩</a></li>
<li id="fn21">S. Grunewalder, G. Lever, L. Baldassarre, S. Patterson, A. Gretton, M. Pontil. (2012). <a href="http://icml.cc/2012/papers/898.pdf">Conditional mean embeddings as regressors</a>. <em>Proc. Int. Conf. Machine Learning</em>: 1823–1830.<a href="#fnref21">↩</a></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24"></li>
<li id="fn25"></li>
<li id="fn26">A. Gretton, K. Borgwardt, M. Rasch, B. Schölkopf, A. Smola. (2012). <a href="http://jmlr.org/papers/volume13/gretton12a/gretton12a.pdf">A kernel two-sample test</a>. <em>Journal of Machine Learning Research</em>, <strong>13</strong>: 723-773.<a href="#fnref26">↩</a></li>
<li id="fn27"></li>
<li id="fn28">M. Dudík, S. J. Phillips, R. E. Schapire. (2007). <a href="http://classes.soe.ucsc.edu/cmps242/Winter08/lect/15/maxent_genreg_jmlr.pdf">Maximum Entropy Distribution Estimation with Generalized Regularization and an Application to Species Distribution Modeling</a>. <em>Journal of Machine Learning Research</em>, <strong>8</strong>: 1217-1260.<a href="#fnref28">↩</a></li>
<li id="fn29"></li>
<li id="fn30">A. Gretton, O. Bousquet, A. Smola, B. Schölkopf. (2005). <a href="http://www.gatsby.ucl.ac.uk/~gretton/papers/GreBouSmoSch05.pdf">Measuring statistical dependence with Hilbert–Schmidt norms</a>. <em>Proc. Intl. Conf. on Algorithmic Learning Theory</em>: 63–78.<a href="#fnref30">↩</a></li>
<li id="fn31"></li>
<li id="fn32">L. Song, A. Smola , A. Gretton, K. Borgwardt, J. Bedo. (2007). <a href="http://www.machinelearning.org/proceedings/icml2007/papers/244.pdf">Supervised feature selection via dependence estimation</a>. <em>Proc. Intl. Conf. Machine Learning</em>, Omnipress: 823–830.<a href="#fnref32">↩</a></li>
<li id="fn33">L. Song, A. Smola, A. Gretton, K. Borgwardt. (2007). <a href="http://machinelearning.wustl.edu/mlpapers/paper_files/icml2007_SongSGB07.pdf">A dependence maximization view of clustering</a>. <em>Proc. Intl. Conf. Machine Learning</em>. Omnipress: 815–822.<a href="#fnref33">↩</a></li>
<li id="fn34">L. Song, A. Smola, K. Borgwardt, A. Gretton. (2007). <a href="http://machinelearning.wustl.edu/mlpapers/paper_files/NIPS2007_492.pdf">Colored maximum variance unfolding</a>. <em>Neural Information Processing Systems</em>.<a href="#fnref34">↩</a></li>
<li id="fn35"></li>
<li id="fn36"></li>
<li id="fn37"></li>
<li id="fn38"></li>
<li id="fn39">K. Muandet, K. Fukumizu, F. Dinuzzo, B. Schölkopf. (2012). <a href="http://books.nips.cc/papers/files/nips25/NIPS2012_0015.pdf">Learning from Distributions via Support Measure Machines</a>. <em>Advances in Neural Information Processing Systems</em>: 10–18.<a href="#fnref39">↩</a></li>
<li id="fn40"></li>
<li id="fn41">K. Zhang, B. Schölkopf, K. Muandet, Z. Wang. (2013). <a href="http://jmlr.org/proceedings/papers/v28/zhang13d.pdf">Domain adaptation under target and conditional shift</a>. ''Journal of Machine Learning Research, <strong>28</strong>(3): 819–827.<a href="#fnref41">↩</a></li>
<li id="fn42">A. Gretton, A. Smola, J. Huang, M. Schmittfull, K. Borgwardt, B. Schölkopf. (2008). Covariate shift and local learning by distribution matching. <em>In J. Quinonero-Candela, M. Sugiyama, A. Schwaighofer, N. Lawrence (eds.). Dataset shift in machine learning</em>, MIT Press, Cambridge, MA: 131–160.<a href="#fnref42">↩</a></li>
<li id="fn43"></li>
<li id="fn44"></li>
<li id="fn45"></li>
<li id="fn46"></li>
<li id="fn47">K. Muandet, D. Balduzzi, B. Schölkopf. (2013).<a href="http://jmlr.org/proceedings/papers/v28/muandet13.pdf">Domain Generalization Via Invariant Feature Representation</a>. <em>30th International Conference on Machine Learning</em>.<a href="#fnref47">↩</a></li>
<li id="fn48"></li>
<li id="fn49"></li>
<li id="fn50"></li>
</ol>
</section>
</body>
</html>
