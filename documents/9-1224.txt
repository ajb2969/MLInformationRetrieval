   Publicly Verifiable Secret Sharing      Publicly Verifiable Secret Sharing   In cryptography , a secret sharing scheme is publicly verifiable (PVSS) if it is a verifiable secret sharing scheme and if any party involved can verify the validity of the shares distributed by the dealer.  The method introduced here according to the paper by Chunming Tang, Dingyi Pei, Zhuo Liu, and Yong He is non-interactive and maintains this property throughout the protocol.  Initialization  The PVSS scheme dictates an initialization process in which:   All system parameters are generated.  Each participant must have a registered public key.   Excluding the initialization process, the PVSS consists of two phases:  Distribution  1.Distribution of secret   s   s   s   shares is performed by the dealer   D   D   D   , which does the following:   The dealer creates     s  1   ,    s  2   …   s  n        subscript  s  1      subscript  s  2   normal-…   subscript  s  n      s_{1},s_{2}...s_{n}   for each participant     P  1   ,    P  2   …   P  n        subscript  P  1      subscript  P  2   normal-…   subscript  P  n      P_{1},P_{2}...P_{n}   respectively.  The dealer publishes the encrypted share     E  i    (   s  i   )        subscript  E  i    subscript  s  i     E_{i}(s_{i})   for each    P  i     subscript  P  i    P_{i}   .  The dealer also publishes a string    proof  D     subscript  proof  D    \mathrm{proof}_{D}   to show that each    E  i     subscript  E  i    E_{i}   encrypts    s  i     subscript  s  i    s_{i}      (note    proof  D     subscript  proof  D    \mathrm{proof}_{D}   guarantees that the reconstruction protocol will result in the same   s   s   s   .  2. Verification of the shares:   Anybody knowing the public keys for the encryption methods    E  i     subscript  E  i    E_{i}   , can verify the shares.  If one or more verifications fails the dealer fails and the protocol is aborted.   Reconstruction  1. Decryption of the shares:   The Participants    P  i     subscript  P  i    P_{i}   decrypts their share of the secret    s  i     subscript  s  i    s_{i}   using     E  i    (   s  i   )        subscript  E  i    subscript  s  i     E_{i}(s_{i})   .   (note: fault-tolerance can be allowed here: it's not required that all participants succeed in decrypting     E  i    (   s  i   )        subscript  E  i    subscript  s  i     E_{i}(s_{i})   as long as a qualified set of participants are successful to decrypt    s  i     subscript  s  i    s_{i}   ).   The participant release    s  i     subscript  s  i    s_{i}   plus a string    proof   P  i      subscript  proof   subscript  P  i     \mathrm{proof}_{P_{i}}   this shows the released share is correct.   2. Pooling the shares:   Using the strings    proof   P  i      subscript  proof   subscript  P  i     \mathrm{proof}_{P_{i}}   to exclude the participants which are dishonest or failed to decrypt     E  i    (   s  i   )        subscript  E  i    subscript  s  i     E_{i}(s_{i})   .  Reconstruction   s   s   s   can be done from the shares of any qualified set of participants.   Chaums and Pedersen Scheme  A proposed protocol proving      log     g  1      h  1    =    log     g  2      h  2          subscript      g  1      subscript  h  1      subscript      g  2      subscript  h  2      \log_{{}_{g1}}h_{1}=\log_{{}_{g2}}h_{2}   :   The prover chooses a random    r  ∈    \Zeta    q  *        r   subscript  \Zeta   superscript  q       r\in\boldsymbol{\Zeta}_{q^{*}}     The verifier send a random challenge    c   ∈  R     \Zeta   q       subscript   R   c   subscript  \Zeta  q     c\in_{R}\boldsymbol{\Zeta}_{q}     The prover responds with    s  =   r  -   c  x   (    mod   q   )         s    r    c  x    mod  q       s=r-cx(\mathrm{mod}\,q)     The verifier checks     α  1   =    g  1  s    h  1  c         subscript  α  1      superscript   subscript  g  1   s    superscript   subscript  h  1   c      \alpha_{1}=g_{1}^{s}h_{1}^{c}   and     α  2   =    g  2  s    h  2  c         subscript  α  2      superscript   subscript  g  2   s    superscript   subscript  h  2   c      \alpha_{2}=g_{2}^{s}h_{2}^{c}      Denote this protocol as    dleq   (   g  1   ,   h  1   ,   g  2   ,   h  2   )       dleq    subscript  g  1    subscript  h  1    subscript  g  2    subscript  h  2      \mathrm{dleq}(g_{1},h_{1},g_{2},h_{2})    A generalization of    dleq   (   g  1   ,   h  1   ,   g  2   ,   h  2   )       dleq    subscript  g  1    subscript  h  1    subscript  g  2    subscript  h  2      \mathrm{dleq}(g_{1},h_{1},g_{2},h_{2})   is denoted as    dleq   (  X  ,  Y  ,   g  1   ,   h  1   ,   g  2   ,   h  2   )       dleq   X  Y   subscript  g  1    subscript  h  1    subscript  g  2    subscript  h  2      \text{dleq}(X,Y,g_{1},h_{1},g_{2},h_{2})   where as    X  =    g  1   x  1     g  2   x  2         X     superscript   subscript  g  1    subscript  x  1     superscript   subscript  g  2    subscript  x  2       X=g_{1}^{x_{1}}g_{2}^{x_{2}}   and    Y  =    h  1   x  1     h  2   x  2         Y     superscript   subscript  h  1    subscript  x  1     superscript   subscript  h  2    subscript  x  2       Y=h_{1}^{x_{1}}h_{2}^{x_{2}}   :   The prover chooses a random      r  1   ,   r  2    ∈   Z  q  *         subscript  r  1    subscript  r  2     superscript   subscript  Z  q       r_{1},r_{2}\in Z_{q}^{*}   and sends     t  1   =    g  1   r  1     g  2   r  2          subscript  t  1      superscript   subscript  g  1    subscript  r  1     superscript   subscript  g  2    subscript  r  2       t_{1}=g_{1}^{r_{1}}g_{2}^{r_{2}}   and     t  2   =    h  1   r  1     h  2   r  2          subscript  t  2      superscript   subscript  h  1    subscript  r  1     superscript   subscript  h  2    subscript  r  2       t_{2}=h_{1}^{r_{1}}h_{2}^{r_{2}}     The verifier send a random challenge    c   ∈  R     \Zeta   q       subscript   R   c   subscript  \Zeta  q     c\in_{R}\boldsymbol{\Zeta}_{q}   .  The prover responds with     s  1   =    r  1   -   c   x  1    (    mod   q   )          subscript  s  1      subscript  r  1     c   subscript  x  1     mod  q       s_{1}=r_{1}-cx_{1}(\mathrm{mod}\,q)   ,     s  2   =    r  2   -   c   x  2    (    mod   q   )          subscript  s  2      subscript  r  2     c   subscript  x  2     mod  q       s_{2}=r_{2}-cx_{2}(\mathrm{mod}\,q)   .  The verifier checks     t  1   =    X  c    g  1   s  1     g  2   s  2          subscript  t  1      superscript  X  c    superscript   subscript  g  1    subscript  s  1     superscript   subscript  g  2    subscript  s  2       t_{1}=X^{c}g_{1}^{s_{1}}g_{2}^{s_{2}}   and     t  2   =    Y  c    h  1   s  1     h  2   s  2          subscript  t  2      superscript  Y  c    superscript   subscript  h  1    subscript  s  1     superscript   subscript  h  2    subscript  s  2       t_{2}=Y^{c}h_{1}^{s_{1}}h_{2}^{s_{2}}      The Chaums and Pedersen method is an interactive method and needs some modification to be used in a non-interactive way: Replacing the randomly chosen   c   c   c   by a 'secure hash' function with   m   m   m   as input value.  See also   Verifiable secret sharing   References   Markus Stadler, Publicly Verifiable Secret Sharing  Berry Schoenmakers, A Simple Publicly Verifiable Secret Sharing Scheme and its Application to Electronic Voting , Advances in Cryptology—CRYPTO, 1999, pp. 148–164   "  Category:Applications of cryptography   