   Yao's Millionaires' Problem      Yao's Millionaires' Problem   Yao's Millionaires' problem is a secure multiparty communication problem which was introduced by Andrew Yao , a prominent computer scientist and computational theorist. The problem discusses two millionaires, Alice and Bob, who are interested in knowing which of them is richer without revealing their actual wealth.  This problem is analogous to a more general problem where there are two numbers   a   a   a   and   b   b   b   and the goal is to solve the inequality    a  ≥  b      a  b    a\geq b   without revealing the actual values of   a   a   a   and   b   b   b   .  The Millionaires' Problem is an example of Secure multi-party computation , which is an important problem in cryptography and the solution of which is used in e-commerce and data mining . Commercial applications sometimes have to compare numbers which are confidential and whose security is important.  Many solutions have been introduced for the problem, among which the first solution, presented by Yao himself, 1 was exponential in time and space. This article presents and explains one possible solution. 2  Protocol and proof  The protocol  We will make use of a variant of oblivious transfer , called 1-2 oblivious transfer, in our protocol . In that transfer one bit is transferred in the following way: a sender has two bits    S  0     subscript  S  0    S_{0}   and    S  1     subscript  S  1    S_{1}   . The receiver chooses    i  ∈   {  0  ,  1  }       i   0  1     i\in\{0,1\}   and the sender sends    S  i     subscript  S  i    S_{i}   with the oblivious transfer protocol such that   the receiver doesn't get any information about    S   (   1  -  i   )      subscript  S    1  i     S_{(1-i)}   ,  the value of   i   i   i   is not exposed to the sender.   Now we will begin with the protocol description. We will indicate Alice's number as   a   a   a   and Bob's number as   b   b   b   and assume that the length of their binary representation is less than   d   d   d   for some    d  ∈  N      d  N    d\in N   . The steps of the protocol are as follows.   Alice creates a matrix   K   K   K   of size    d  ×  2      d  2    d\times 2   of   k   k   k   -bit numbers, where   k   k   k   is the length of the key in the oblivious transfer protocol. In addition, she chooses two random numbers   u   u   u   and   v   v   v   where    0  ≤  u  <   2  k         0  u         2  k      0\leq u<2k   and    v  ≤  k      v  k    v\leq k   .      K   i  j  l      subscript  K    i  j  l     K_{ijl}   will be the   l   l   l   -th bit of the number which appears in cell    K   i  j      subscript  K    i  j     K_{ij}   (where    l  =  0      l  0    l=0   indicates the least significant bit ). In addition, we denote    a  i     subscript  a  i    a_{i}   as the   i   i   i   -th bit of Alice's number   a   a   a   . For every   i   i   i   ,    1  ≤  i  ≤  d        1  i       d     1\leq i\leq d   Alice does the following actions.  For every bit    j  ≥  v      j  v    j\geq v   she sets    K   i  1  j      subscript  K    i  1  j     K_{i1j}   and    K   i  2  j      subscript  K    i  2  j     K_{i2j}   to random bits.  If     a  i   =  1       subscript  a  i   1    a_{i}=1   let    l  =  1      l  1    l=1   otherwise let    l  =  2      l  2    l=2   and for every     j  ,  0   ≤  j  ≤    2  ⋅  i   -  1          j  0   j          normal-⋅  2  i   1      j,0\leq j\leq 2\cdot i-1   set    K   i  l  j      subscript  K    i  l  j     K_{ilj}   to a random bit.  For    m  =   2  ⋅  i       m   normal-⋅  2  i     m=2\cdot i   set     K   i  l   (   m  +  1   )     =  1       subscript  K    i  l    m  1     1    K_{il(m+1)}=1   and    K   i  l  m      subscript  K    i  l  m     K_{ilm}   to    a  i     subscript  a  i    a_{i}   .  For every     i  ,  1   ≤  i  <  d         i  1   i       d     i,1\leq i   ,    S  i     subscript  S  i    S_{i}   will be a random   k   k   k   -bit number and    S  d     subscript  S  d    S_{d}   will be another number of   k   k   k   bits where all bits except the last two are random and the last two are calculated as     S   d   (   k  -  1   )     =   1  ⊕    ⊕   j  =  1    d  -  1     S   j   (   k  -  1   )      ⊕    ⊕   j  =  1   d    K   j  1   (   k  -  1   )            subscript  S    d    k  1      direct-sum  1    superscript   subscript  direct-sum    j  1      d  1     subscript  S    j    k  1        superscript   subscript  direct-sum    j  1    d    subscript  K    j  1    k  1         S_{d(k-1)}=1\oplus\bigoplus_{j=1}^{d-1}S_{j(k-1)}\oplus\bigoplus_{j=1}^{d}K_{j%
 1(k-1)}   and     S   d   (   k  -  2   )     =   1  ⊕    ⊕   j  =  1    d  -  1     S   j   (   k  -  2   )      ⊕    ⊕   j  =  1   d    K   j  1   (   k  -  2   )            subscript  S    d    k  2      direct-sum  1    superscript   subscript  direct-sum    j  1      d  1     subscript  S    j    k  2        superscript   subscript  direct-sum    j  1    d    subscript  K    j  1    k  2         S_{d(k-2)}=1\oplus\bigoplus_{j=1}^{d-1}S_{j(k-2)}\oplus\bigoplus_{j=1}^{d}K_{j%
 1(k-2)}   , where   ⊕   direct-sum   \bigoplus   is the bitwise  XOR operation.  For    l  =   1  ,  2       l   1  2     l=1,2   set     K   i  j   ′   =   r  o  t   (    K   i  l    ⊕   S  i    ,  u  )         subscript   superscript  K  normal-′     i  j      r  o  t    direct-sum   subscript  K    i  l     subscript  S  i    u      K^{\prime}_{ij}=rot(K_{il}\oplus S_{i},u)   . Where    r  o  t   (  x  ,  t  )       r  o  t   x  t     rot(x,t)   indicates the bitwise rotation of   x   x   x   to the left by   t   t   t   bits.   For every   i   i   i   ,    0  ≤  i  ≤  d        0  i       d     0\leq i\leq d   Bob transfers    K   i  l   ′     subscript   superscript  K  normal-′     i  l     K^{\prime}_{il}   with the oblivious transfer protocol where    l  =    b  i   +  1       l     subscript  b  i   1     l=b_{i}+1   and    b  i     subscript  b  i    b_{i}   is the   i   i   i   -th bit of   b   b   b   .  Alice sends to Bob    N  =   r  o  l   (    ⊕   j  =  1   d    S  j    ,  u  )        N    r  o  l     superscript   subscript  direct-sum    j  1    d    subscript  S  j    u      N=rol(\bigoplus_{j=1}^{d}S_{j},u)   .  Bob calculates the bitwise XOR of all the numbers he got in step 3 and   N   N   N   from step 4. Bob scans the result from left to right until he finds a large sequence of zero bits. Let   c   c   c   be the bit to the right of that sequence (   c   c   c   is non zero). If the bit to the right of   c   c   c   equals 1 then    a  ≥  b      a  b    a\geq b   . otherwise    a  <  b      a  b    a   .   Proof  Correctness  Bob calculates the final result from     N  ⊕    ⊕   i  =  1   d    K   i   (    b  i   +  1   )    ′     =   r  o  l   (    ⊕   i  =  1   d    K   i   (    b  i   +  1   )      ,  u  )         direct-sum  N    superscript   subscript  direct-sum    i  1    d    subscript   superscript  K  normal-′     i     subscript  b  i   1         r  o  l     superscript   subscript  direct-sum    i  1    d    subscript  K    i     subscript  b  i   1      u      N\oplus\bigoplus_{i=1}^{d}K^{\prime}_{i(b_{i}+1)}=rol(\bigoplus_{i=1}^{d}K_{i(%
 b_{i}+1)},u)   and the result depends on    c  =    ⊕   i  =  1   d    K   i   (    b  i   +  1   )          c    superscript   subscript  direct-sum    i  1    d    subscript  K    i     subscript  b  i   1        c=\bigoplus_{i=1}^{d}K_{i(b_{i}+1)}   . K and therefore c as well, can be split into 3 parts. The left part doesn't affect the result. The right part has all the important information and in the middle there is a sequence of zeros what separate those two parts. The length of each partition of c is linked to the security scheme.  For every i, only one of     K   i  1    ,   K   i  2        subscript  K    i  1     subscript  K    i  2      K_{i1},K_{i2}   has non zero right part and it is    K   i  1      subscript  K    i  1     K_{i1}   if     a  i   =  1       subscript  a  i   1    a_{i}=1   and    K   i  2      subscript  K    i  2     K_{i2}   otherwise. In addition, if    i  >  j      i  j    i>j   and    K   i  l      subscript  K    i  l     K_{il}   has a non zero right part then     K   i  l    ⊕   K   j  l       direct-sum   subscript  K    i  l     subscript  K    j  l      K_{il}\oplus K_{jl}   has also a non zero right part and the two leftmost bits of this right part will be the same as the one of    A   i  l      subscript  A    i  l     A_{il}   . As a result, the right part of c is a function of the entries Bob transferred correspond to the unique bits in a and b and the only bits in the right part in c which are not random are the two leftmost, Exactly the bits which determines the result of     a  i   >   b  i        subscript  a  i    subscript  b  i     a_{i}>b_{i}   where i is the highest order bit in which a and b differ. In the end, if     a  i   >   b  i        subscript  a  i    subscript  b  i     a_{i}>b_{i}   then those two leftmost bits will be 11 and Bob will answer that    a  ≥  b      a  b    a\geq b   . If the bits are 10 then     a  i   <   b  i        subscript  a  i    subscript  b  i     a_{i}   and he will answer a rol(K_{i(1+b_i)} \oplus S_i ,u)  for every   i   i   i   Bob receives one such number and    S  i     subscript  S  i    S_{i}   is random so no secure information is transformed,   N, This is an XOR of random numbers and therefore reveals no information. The relevant information is revealed only after calculating c and,  c, The same goes for c. The left part of c is random and the right part is random as well except from the two leftmost bits. Deducing any information from those bits requires guessing some other values and the chance of guessing them correct is very low.   Complexity  The complexity of the protocol is    O   (   d  2   )       O   superscript  d  2     O(d^{2})   . Alice constructs d length number for each bit of a and Bob calculates XOR d times of d length numbers. The complexity of those operations is    O   (   d  2   )       O   superscript  d  2     O(d^{2})   . The communication part takes also    O   (   d  2   )       O   superscript  d  2     O(d^{2})   . Therefore the complexity of the protocol is     O   (   d  2   )    .      O   superscript  d  2     O(d^{2}).     See also   Cryptography  Secure multi-party computation  RSA  Socialist millionaire , a variant in which the millionaires wish to determine whether their fortunes are equal.   Notes  "  Category:Cryptographic protocols     ↩  ↩     