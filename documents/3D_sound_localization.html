<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="649">3D sound localization</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>3D sound localization</h1>
<hr/>

<p>'3D sound localization' refers to the <a href="acoustical_engineering" title="wikilink">acoustical engineering</a> technology that been used to identify the location of a sound source in a <a href="three-dimensional_space" title="wikilink">three-dimensional space</a>.Usually the location of the source is determined by the direction of the coming sound waves(horizontal and vertical angles) and the distance between the source and the sensors. We note that the sound source localization problem is also a source localization problem. It involves the structure arrangement design of the <a class="uri" href="sensors" title="wikilink">sensors</a> and <a href="signal_processing" title="wikilink">signal processing</a> techniques.</p>

<p>Humans and most mammals use binaural hearing to process the sound localization with two ears, so it is difficult to localize using <a class="uri" href="monaural" title="wikilink">monaural</a> hearing especially in <a href="3D_space" title="wikilink">3D space</a>. For example, when you hear a sound, you need to determine which direction was the sound sent from and what message it contained, based on <a href="binaural_hearing" title="wikilink">binaural hearing</a>, compared information received from each of the two ears. The whole procedure is extremely complex and involves a lot of synthesis.</p>
<h2 id="motivation">Motivation</h2>

<p>The interest in sound localization is widely increasing due to the need for improved solutions in some <a href="Audio_signal" title="wikilink">audio</a> and <a class="uri" href="acoustics" title="wikilink">acoustics</a> fields, such as <a href="hearing_aids" title="wikilink">hearing aids</a>, surveillance<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and <a class="uri" href="navigation" title="wikilink">navigation</a>. Existing real-time passive sound localization systems are mainly based on the time-difference-of-arrival (<a class="uri" href="TDOA" title="wikilink">TDOA</a>) approach, but this limits sound localization to <a href="two-dimensional_space" title="wikilink">two-dimensional space</a>. The most important problem is that systems cannot be used realistically with noisy conditions and 3D implementation.</p>
<h2 id="applications">Applications</h2>

<p> There are many applications of sound source localization such as sound source separation, sound source tracking and speech enhancement. Underwater <a class="uri" href="sonar" title="wikilink">sonar</a> uses sound source localization techniques to identify the location of a target. It is also used in robots for effective human-robot interaction. With the increasing demand of robotic hearing, some applications such as human-machine interface, handicappers' aid and some military applications are being widely exploited.</p>
<h2 id="cues-for-sound-localization">Cues for sound localization</h2>

<p>Localization cues<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> are the features the can help us localize sound. Cues for the sound localization include the binaural cues and monoaural cues.</p>
<ul>
<li>Monoaural cues can be obtained by means of <a href="spectral_analysis" title="wikilink">spectral analysis</a>. Monoaural cues are generally used in vertical localization</li>
<li>Binaural cues are generated by the difference of hearing between the left and right ears. These includes <a href="interaural_time_difference" title="wikilink">interaural time difference</a>(ITD) and interaural intensity difference(ILD). Binaural cues are mostly used for the horizontal localization.</li>
</ul>
<h2 id="methods">Methods</h2>

<p>There are many 3D sound localization methods that are used for various applications.</p>
<ul>
<li>Different types of sensor structure can be used such as <a href="microphone_array" title="wikilink">microphone array</a> and binaural hearing robot head.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
<li>Different techniques can be used to get the optimal results, such as <a href="neural_network" title="wikilink">neural network</a>, <a href="maximum_likelihood" title="wikilink">maximum likelihood</a> and <a href="Multiple_signal_classification" title="wikilink">Multiple signal classification</a> (MUSIC).</li>
<li>According to the timeliness, there are real-time methods and off-line methods</li>
</ul>

<p><big><big>• Microphone Array Approach</big></big></p>
<h3 id="steered-beamformer-approach">Steered Beamformer Approach</h3>

<p>This approach uses eight microphones and combined with a steered beamformer which enhanced by the Reliability Weighted Phase Transform (RWPHAT), and the results finally filtered by a particle filter that tracks each source and also prevents false directions. The motivation of using this method is that based on previous research, the sound tracking and localization only applied for a single sound source, but this method is used for multiple sound sources tracking and localizing.</p>
<h4 id="beamformer-based-sound-localization">Beamformer-based Sound Localization</h4>

<p>To maximum the output energy of a delay-and-sum <a class="uri" href="beamformer" title="wikilink">beamformer</a> in order to find the maximum value of the output of a beamformer which is steered in all possible directions. Using the Reliability Weighted Phase Transform (RWPHAT) method, The output energy of M-microphone delay-and-sum beamformer is</p>

<p>

<math display="block" id="3D_sound_localization:0">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>=</mo>
   <mrow>
    <mi>K</mi>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <msub>
         <mi>m</mi>
         <mn>1</mn>
        </msub>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mrow>
        <mi>M</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </munderover>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <msub>
          <mi>m</mi>
          <mn>2</mn>
         </msub>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mrow>
         <msub>
          <mi>m</mi>
          <mn>1</mn>
         </msub>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </munderover>
       <mrow>
        <mmultiscripts>
         <mi>R</mi>
         <none></none>
         <mrow>
          <mi>R</mi>
          <mi>W</mi>
          <mi>P</mi>
          <mi>H</mi>
          <mi>A</mi>
          <mi>T</mi>
         </mrow>
         <mrow>
          <mi>i</mi>
          <mo>,</mo>
          <mi>j</mi>
         </mrow>
         <none></none>
        </mmultiscripts>
        <mrow>
         <mo>(</mo>
         <mrow>
          <msub>
           <mi>τ</mi>
           <msub>
            <mi>m</mi>
            <mn>1</mn>
           </msub>
          </msub>
          <mo>-</mo>
          <msub>
           <mi>τ</mi>
           <msub>
            <mi>m</mi>
            <mn>2</mn>
           </msub>
          </msub>
         </mrow>
         <mo>)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>E</ci>
    <apply>
     <plus></plus>
     <ci>K</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>m</ci>
           <cn type="integer">1</cn>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>M</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>m</ci>
            <cn type="integer">2</cn>
           </apply>
           <cn type="integer">0</cn>
          </apply>
         </apply>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>m</ci>
           <cn type="integer">1</cn>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>R</ci>
           <apply>
            <times></times>
            <ci>R</ci>
            <ci>W</ci>
            <ci>P</ci>
            <ci>H</ci>
            <ci>A</ci>
            <ci>T</ci>
           </apply>
          </apply>
          <list>
           <ci>i</ci>
           <ci>j</ci>
          </list>
         </apply>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>τ</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>m</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>τ</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>m</ci>
            <cn type="integer">2</cn>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E=K+2\sum_{{m}_{1}=1}^{M-1}\sum_{{m}_{2}=0}^{{m}_{1}-1}{{R}^{RWPHAT}}_{i,j}%
\left({\tau}_{{m}_{1}}-{\tau}_{{m}_{2}}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>Where E indicates the energy, and K is a constant, 

<math display="inline" id="3D_sound_localization:1">
 <semantics>
  <mrow>
   <mmultiscripts>
    <mi>R</mi>
    <none></none>
    <mrow>
     <mi>R</mi>
     <mi>W</mi>
     <mi>P</mi>
     <mi>H</mi>
     <mi>A</mi>
     <mi>T</mi>
    </mrow>
    <mrow>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
    </mrow>
    <none></none>
   </mmultiscripts>
   <mrow>
    <mo>(</mo>
    <mrow>
     <msub>
      <mi>τ</mi>
      <msub>
       <mi>m</mi>
       <mn>1</mn>
      </msub>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>τ</mi>
      <msub>
       <mi>m</mi>
       <mn>2</mn>
      </msub>
     </msub>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <apply>
       <times></times>
       <ci>R</ci>
       <ci>W</ci>
       <ci>P</ci>
       <ci>H</ci>
       <ci>A</ci>
       <ci>T</ci>
      </apply>
     </apply>
     <list>
      <ci>i</ci>
      <ci>j</ci>
     </list>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{R}^{RWPHAT}}_{i,j}\left({\tau}_{{m}_{1}}-{\tau}_{{m}_{2}}\right)
  </annotation>
 </semantics>
</math>

 is the microphone pairs <a class="uri" href="cross-correlation" title="wikilink">cross-correlation</a> defined by Reliability Weighted Phase Transform:</p>

<p>

<math display="block" id="3D_sound_localization:2">
 <semantics>
  <mrow>
   <mrow>
    <mmultiscripts>
     <mi>R</mi>
     <none></none>
     <mrow>
      <mi>R</mi>
      <mi>W</mi>
      <mi>P</mi>
      <mi>H</mi>
      <mi>A</mi>
      <mi>T</mi>
     </mrow>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>j</mi>
     </mrow>
     <none></none>
    </mmultiscripts>
    <mrow>
     <mo>(</mo>
     <mi>τ</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>L</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mrow>
     <mfrac>
      <mrow>
       <msub>
        <mi>ζ</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo>(</mo>
        <mi>k</mi>
        <mo>)</mo>
       </mrow>
       <msub>
        <mi>X</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo>(</mo>
        <mi>k</mi>
        <mo>)</mo>
       </mrow>
       <msub>
        <mi>ζ</mi>
        <mi>j</mi>
       </msub>
       <mrow>
        <mo>(</mo>
        <mi>k</mi>
        <mo>)</mo>
       </mrow>
       <mmultiscripts>
        <mi>X</mi>
        <mi>j</mi>
        <none></none>
        <none></none>
        <mo>*</mo>
       </mmultiscripts>
       <mrow>
        <mo>(</mo>
        <mi>k</mi>
        <mo>)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mrow>
        <mo>|</mo>
        <mrow>
         <msub>
          <mi>X</mi>
          <mi>i</mi>
         </msub>
         <mrow>
          <mo>(</mo>
          <mi>k</mi>
          <mo>)</mo>
         </mrow>
        </mrow>
        <mo>|</mo>
       </mrow>
       <mrow>
        <mo>|</mo>
        <mrow>
         <msub>
          <mi>X</mi>
          <mi>j</mi>
         </msub>
         <mrow>
          <mo>(</mo>
          <mi>k</mi>
          <mo>)</mo>
         </mrow>
        </mrow>
        <mo>|</mo>
       </mrow>
      </mrow>
     </mfrac>
     <msup>
      <mi>e</mi>
      <mrow>
       <mrow>
        <mi>j</mi>
        <mn>2</mn>
        <mi>π</mi>
        <mi>k</mi>
        <mi>τ</mi>
       </mrow>
       <mo>/</mo>
       <mi>L</mi>
      </mrow>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>R</ci>
       <apply>
        <times></times>
        <ci>R</ci>
        <ci>W</ci>
        <ci>P</ci>
        <ci>H</ci>
        <ci>A</ci>
        <ci>T</ci>
       </apply>
      </apply>
      <list>
       <ci>i</ci>
       <ci>j</ci>
      </list>
     </apply>
     <ci>τ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>L</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ζ</ci>
         <ci>i</ci>
        </apply>
        <ci>k</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>i</ci>
        </apply>
        <ci>k</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ζ</ci>
         <ci>j</ci>
        </apply>
        <ci>k</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <ci>j</ci>
         </apply>
         <times></times>
        </apply>
        <ci>k</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <abs></abs>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>X</ci>
           <ci>i</ci>
          </apply>
          <ci>k</ci>
         </apply>
        </apply>
        <apply>
         <abs></abs>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>X</ci>
           <ci>j</ci>
          </apply>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>j</ci>
         <cn type="integer">2</cn>
         <ci>π</ci>
         <ci>k</ci>
         <ci>τ</ci>
        </apply>
        <ci>L</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{R}^{RWPHAT}}_{i,j}\left(\tau\right)=\sum_{k=0}^{L-1}\frac{{\zeta}_{i}\left(k%
\right){X}_{i}\left(k\right){\zeta}_{j}\left(k\right){{X}_{j}}^{*}\left(k%
\right)}{\left|{X}_{i}\left(k\right)\right|\left|{X}_{j}\left(k\right)\right|}%
{e}^{j2\pi k\tau/L}
  </annotation>
 </semantics>
</math>

 the weighted factor 

<math display="inline" id="3D_sound_localization:3">
 <semantics>
  <mrow>
   <mmultiscripts>
    <mi>ζ</mi>
    <none></none>
    <mi>n</mi>
    <mi>i</mi>
    <none></none>
   </mmultiscripts>
   <mrow>
    <mo>(</mo>
    <mi>k</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ζ</ci>
      <ci>n</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{\zeta}^{n}}_{i}\left(k\right)
  </annotation>
 </semantics>
</math>

reflect the reliability of each frequency component, and defined as the Wiener Filter gain 

<math display="inline" id="3D_sound_localization:4">
 <semantics>
  <mrow>
   <mrow>
    <mmultiscripts>
     <mi>ζ</mi>
     <none></none>
     <mi>n</mi>
     <mi>i</mi>
     <none></none>
    </mmultiscripts>
    <mrow>
     <mo>(</mo>
     <mi>k</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mmultiscripts>
      <mi>ξ</mi>
      <none></none>
      <mi>n</mi>
      <mi>i</mi>
      <none></none>
     </mmultiscripts>
     <mrow>
      <mo>(</mo>
      <mi>k</mi>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mmultiscripts>
       <mi>ξ</mi>
       <none></none>
       <mi>n</mi>
       <mi>i</mi>
       <none></none>
      </mmultiscripts>
      <mrow>
       <mo>(</mo>
       <mi>k</mi>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ζ</ci>
       <ci>n</ci>
      </apply>
      <ci>i</ci>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ξ</ci>
        <ci>n</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ξ</ci>
         <ci>n</ci>
        </apply>
        <ci>i</ci>
       </apply>
       <ci>k</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{\zeta}^{n}}_{i}\left(k\right)=\frac{{{\xi}^{n}}_{i}\left(k\right)}{{{\xi}^{n%
}}_{i}\left(k\right)+1}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="3D_sound_localization:5">
 <semantics>
  <mrow>
   <mmultiscripts>
    <mi>ξ</mi>
    <none></none>
    <mi>n</mi>
    <mi>i</mi>
    <none></none>
   </mmultiscripts>
   <mrow>
    <mo>(</mo>
    <mi>k</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ξ</ci>
      <ci>n</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{\xi}^{n}}_{i}\left(k\right)
  </annotation>
 </semantics>
</math>

 is an estimate of a prior SNR at 

<math display="inline" id="3D_sound_localization:6">
 <semantics>
  <msup>
   <mi>i</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>i</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i^{th}
  </annotation>
 </semantics>
</math>

 microphone, at time frame 

<math display="inline" id="3D_sound_localization:7">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, for frequency 

<math display="inline" id="3D_sound_localization:8">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, computed using the decision-directed approach.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>The 

<math display="inline" id="3D_sound_localization:9">
 <semantics>
  <msub>
   <mi>x</mi>
   <msub>
    <mi>m</mi>
    <mi>n</mi>
   </msub>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{m_{n}}
  </annotation>
 </semantics>
</math>

 is the signal from 

<math display="inline" id="3D_sound_localization:10">
 <semantics>
  <msup>
   <mi>m</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>m</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {m}^{th}
  </annotation>
 </semantics>
</math>

 microphone and 

<math display="inline" id="3D_sound_localization:11">
 <semantics>
  <msub>
   <mi>τ</mi>
   <msub>
    <mi>m</mi>
    <mi>n</mi>
   </msub>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>τ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\tau}_{{m}_{n}}
  </annotation>
 </semantics>
</math>

 is the delay of arrival for that microphone. And the more specific procedure of this method is proposed by Valin and Michaud<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>The advantage of this method is it not only can detect the sound direction, but also can derive the distance of sound sources. But the main drawback of this beamforming approach is the accuracy and capability of sound localization are not that perfect as neural network approach using on the moving speakers.</p>
<h3 id="collocated-microphone-array-approach">Collocated Microphone Array Approach</h3>

<p>Real-time sound localization uses a collocated array named Acoustic Vector Sensor (AVS) array.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h4 id="acoustic-vector-array">Acoustic Vector Array</h4>
<figure><b>(Figure)</b>
<figcaption>AVS array: XYZO array</figcaption>
</figure>

<p>• AVS Contains 3 orthogonally installed acoustic particle velocity gradient microphones which are X, Y and Z array shown, and one omnidirectional acoustic microphone O.</p>

<p>• This type of array has been widely used under water.</p>

<p>• AVS uses the Offline Calibration Process<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> to measure and interpolate the impulse response of X, Y, Z and O arrays, to obtain their steering vector.</p>

<p>A sound signal is first windowed using a rectangular window, then each resulting segment signal is created as a frame. 4 parallel frames are detected from XYZO array and used for DOA estimation. The 4 frames are split into small blocks with equal size, then the Hamming window and FFT are used to convert each block from a time domain to a frequency domain. Then the output of this system is represented by a horizontal angle and a vertical angle of the sound sources which is found by the peak in the combined 3D spatial spectrum.</p>

<p>The advantages of this array, compared with past microphone array, are that this device has a high performance even if the aperture is small, and it can localize multiple <a href="low_frequency" title="wikilink">low frequency</a> and <a href="high_frequency" title="wikilink">high frequency</a> wide band sound sources simultaneously. Applying an O array can make more available acoustic information, such as amplitude and time difference. Most importantly, XYZO array has a better performance with a tiny size.</p>

<p>The AVS is one kind of collocated multiple microphone array, it make use of a multiple microphone array approach for estimating the sound directions by multiple arrays and then finds the locations by using reflection informations such as where the direction is detected where different arrays cross.</p>
<h4 id="motivation-of-the-advanced-microphone-array">Motivation of the Advanced Microphone array</h4>

<p>Sound reflections always occur in an actual environment and microphone arrays<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> cannot avoid observing those reflections. This multiple array approach was tested using fixed arrays in the ceiling; the performance of the moving scenario still need to be tested.</p>
<h4 id="learning-how-to-apply-multiple-microphone-array">*Learning how to apply Multiple Microphone Array</h4>

<p>Angle uncertainty (AU) will occur when estimating direction, and position uncertainty (PU) will also aggravate with increasing distance between the array and the source. We know that:</p>

<p>

<math display="block" id="3D_sound_localization:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mi>U</mi>
    <mrow>
     <mo>(</mo>
     <mi>r</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mfrac>
       <mrow>
        <mo>±</mo>
        <mrow>
         <mi>A</mi>
         <mi>U</mi>
        </mrow>
       </mrow>
       <mn>360</mn>
      </mfrac>
      <mo>×</mo>
      <mn>2</mn>
     </mrow>
     <mi>π</mi>
    </mrow>
    <mo>×</mo>
    <mi>r</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>U</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="latexml">plus-or-minus</csymbol>
         <apply>
          <times></times>
          <ci>A</ci>
          <ci>U</ci>
         </apply>
        </apply>
        <cn type="integer">360</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <ci>π</ci>
     </apply>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   PU\left(r\right)=\frac{\pm AU}{360}\times 2\pi\times r
  </annotation>
 </semantics>
</math>

 where r is the distance between array center to source, and AU is angle uncertainly. Measurement is used for judging whether two directions cross at some location or not. Minimum distance between two lines:</p>

<p>

<math display="block" id="3D_sound_localization:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mi>i</mi>
    <mi>s</mi>
    <mi>t</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>d</mi>
      <mi>i</mi>
      <msub>
       <mi>r</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>d</mi>
      <mi>i</mi>
      <msub>
       <mi>r</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mover accent="true">
        <msub>
         <mi>v</mi>
         <mn>1</mn>
        </msub>
        <mo>→</mo>
       </mover>
       <mo>×</mo>
       <mover accent="true">
        <msub>
         <mi>v</mi>
         <mn>2</mn>
        </msub>
        <mo>→</mo>
       </mover>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mo>×</mo>
     <mover accent="true">
      <mrow>
       <msub>
        <mi>p</mi>
        <mn>1</mn>
       </msub>
       <msub>
        <mi>p</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo>→</mo>
     </mover>
    </mrow>
    <mrow>
     <mo>|</mo>
     <mrow>
      <mover accent="true">
       <msub>
        <mi>v</mi>
        <mn>1</mn>
       </msub>
       <mo>→</mo>
      </mover>
      <mo>×</mo>
      <mover accent="true">
       <msub>
        <mi>v</mi>
        <mn>2</mn>
       </msub>
       <mo>→</mo>
      </mover>
     </mrow>
     <mo>|</mo>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>i</ci>
     <ci>s</ci>
     <ci>t</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>i</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>i</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </interval>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <ci>normal-→</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <ci>normal-→</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <ci>normal-→</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <apply>
        <ci>normal-→</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <ci>normal-→</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   dist\left(dir_{1},dir_{2}\right)=\frac{\left(\overrightarrow{v_{1}}\times%
\overrightarrow{v_{2}}\right)\times\overrightarrow{p_{1}p_{2}}}{\left|%
\overrightarrow{v_{1}}\times\overrightarrow{v_{2}}\right|}
  </annotation>
 </semantics>
</math>

 where

<math display="inline" id="3D_sound_localization:14">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>i</mi>
   <msub>
    <mi>r</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>i</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   dir_{1}
  </annotation>
 </semantics>
</math>

and 

<math display="inline" id="3D_sound_localization:15">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>i</mi>
   <msub>
    <mi>r</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>i</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   dir_{2}
  </annotation>
 </semantics>
</math>

 are two directions, 

<math display="inline" id="3D_sound_localization:16">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

are vectors parallel to detected direction, and 

<math display="inline" id="3D_sound_localization:17">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}
  </annotation>
 </semantics>
</math>

are the position of arrays.</p>

<p>If</p>

<p>

<math display="inline" id="3D_sound_localization:18">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>O</mi>
   <msub>
    <mi>S</mi>
    <mrow>
     <mi>s</mi>
     <mi>o</mi>
     <mi>u</mi>
     <mi>r</mi>
     <mi>c</mi>
     <mi>e</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>o</ci>
      <ci>u</ci>
      <ci>r</ci>
      <ci>c</ci>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   POS_{source}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="3D_sound_localization:19">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>O</mi>
   <msub>
    <mi>S</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   POS_{n}
  </annotation>
 </semantics>
</math>

is the estimation of sound source position, 

<math display="inline" id="3D_sound_localization:20">
 <semantics>
  <msub>
   <mi>w</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{n}
  </annotation>
 </semantics>
</math>

 is the position where each direction intersect the line with minimum distance, and 

<math display="inline" id="3D_sound_localization:21">
 <semantics>
  <msub>
   <mi>w</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{n}
  </annotation>
 </semantics>
</math>

 is the weighted factors. As the weighting factor 

<math display="inline" id="3D_sound_localization:22">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>U</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   PU
  </annotation>
 </semantics>
</math>

, we determined use 

<math display="inline" id="3D_sound_localization:23">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 or 

<math display="block" id="3D_sound_localization:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>c</mi>
     <mi>s</mi>
     <msub>
      <mi>p</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>I</mi>
     <mi>F</mi>
     <mi>F</mi>
     <mi>T</mi>
     <mrow>
      <mo>{</mo>
      <mfrac>
       <mrow>
        <mrow>
         <mrow>
          <mi>F</mi>
          <mi>F</mi>
          <mi>T</mi>
          <mrow>
           <mo stretchy="false">[</mo>
           <mrow>
            <msub>
             <mi>s</mi>
             <mi>i</mi>
            </msub>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>n</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo stretchy="false">]</mo>
          </mrow>
         </mrow>
         <mo>⋅</mo>
         <mi>F</mi>
        </mrow>
        <mi>F</mi>
        <mi>T</mi>
        <msup>
         <mrow>
          <mo stretchy="false">[</mo>
          <mrow>
           <msub>
            <mi>s</mi>
            <mi>j</mi>
           </msub>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo stretchy="false">]</mo>
         </mrow>
         <mo>*</mo>
        </msup>
       </mrow>
       <mrow>
        <mo>|</mo>
        <mi>F</mi>
        <mi>F</mi>
        <mi>T</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <msub>
          <mi>s</mi>
          <mi>i</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo stretchy="false">]</mo>
        </mrow>
        <mo>|</mo>
        <mo>⋅</mo>
        <mo>|</mo>
        <mi>F</mi>
        <mi>F</mi>
        <mi>T</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <msub>
          <mi>s</mi>
          <mi>j</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo stretchy="false">]</mo>
        </mrow>
        <mo>|</mo>
       </mrow>
      </mfrac>
      <mo>}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>s</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <ci>I</ci>
     <ci>F</ci>
     <ci>F</ci>
     <ci>T</ci>
     <set>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <ci>normal-⋅</ci>
         <apply>
          <times></times>
          <ci>F</ci>
          <ci>F</ci>
          <ci>T</ci>
          <apply>
           <csymbol cd="latexml">delimited-[]</csymbol>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>s</ci>
             <ci>i</ci>
            </apply>
            <ci>n</ci>
           </apply>
          </apply>
         </apply>
         <ci>F</ci>
        </apply>
        <ci>F</ci>
        <ci>T</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>s</ci>
            <ci>j</ci>
           </apply>
           <ci>n</ci>
          </apply>
         </apply>
         <times></times>
        </apply>
       </apply>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-|</ci>
        <csymbol cd="unknown">F</csymbol>
        <csymbol cd="unknown">F</csymbol>
        <csymbol cd="unknown">T</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-[</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>s</ci>
          <ci>i</ci>
         </apply>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <ci>normal-(</ci>
          <csymbol cd="unknown">n</csymbol>
          <ci>normal-)</ci>
         </cerror>
         <ci>normal-]</ci>
        </cerror>
        <ci>normal-|</ci>
        <ci>normal-⋅</ci>
        <ci>normal-|</ci>
        <csymbol cd="unknown">F</csymbol>
        <csymbol cd="unknown">F</csymbol>
        <csymbol cd="unknown">T</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-[</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>s</ci>
          <ci>j</ci>
         </apply>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <ci>normal-(</ci>
          <csymbol cd="unknown">n</csymbol>
          <ci>normal-)</ci>
         </cerror>
         <ci>normal-]</ci>
        </cerror>
        <ci>normal-|</ci>
        <ci></ci>
       </cerror>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   csp_{ij}(k)=IFFT\left\{\frac{FFT[s_{i}(n)]\cdot FFT[s_{j}(n)]^{*}}{\left|FFT[s%
_{i}(n)]\right|\cdot\left|FFT[s_{j}(n)]\right|\quad}\right\}\quad
  </annotation>
 </semantics>
</math>

 from the array to the line with minimum distance.</p>

<p><big><big>• Binaural Hearing Approach</big></big></p>
<h3 id="learning-method-for-binaural-hearing">Learning method for binaural hearing</h3>
<figure><b>(Figure)</b>
<figcaption>Structure of the binaural robot dummy head</figcaption>
</figure>

<p>Binaural hearing Learning<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> is a <a class="uri" href="bionic" title="wikilink">bionic</a> method. The sensor is a robot dummy head with 2 sensor microphones along with the artificial pinna(reflector). The robot head has 2 rotation axes and can rotate horizontally and vertically. The reflector causes the spectrum change into a certain pattern for incoming white noise sound wave and this pattern is used for the cue of the vertical localization. Cue used for horizontal localization is ITD.</p>

<p>The system should make use of a learning process using <a href="neural_networks" title="wikilink">neural networks</a> by rotating the head with a settled white noise sound source and analyzing the spectrum. Experiments show that the system can identify the direction of the source well in a certain range of angle of arrival. But it cannot identify the sound coming outside the range due to the collapsed spectrum pattern of the reflector.</p>

<p>Binaural hearing use only 2 microphones and is capable of concentrating on one source amaong noises and different sources.</p>
<h3 id="head-related-transfer-function-hrtf">Head-related Transfer Function (HRTF)</h3>

<p>In the real sound localization, the whole head and the torso have an important functional role, not only the two pinnae. This function can be described as spatial linear filtering and the filtering is always quantified in terms of Head-Related Transfer Function (HRTF).<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>HRTF also uses the robot head sensor, which is the binaural hearing model. This model has multiple inputs. The HRTF can be derived based on various cues for localization. Sound localization with HRTF is flitering the input signal with a filter which is designed based on the HRTF. Instead of using the neural networks, a head-related transfer function is used and the localization is based on a simple correlation approach.</p>

<p>See more: <a href="Head-related_transfer_function" title="wikilink">Head-related transfer function</a>.</p>
<h3 id="cross-power-spectrum-phase-csp-analysis">Cross-power spectrum phase (CSP) analysis</h3>

<p>CSP method<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> is also used for the binaural model. The idea is that the angle of arrival can be derived through the time delay of arrival (TDOA) between two microphones, and TDOA can be estimated by finding the maximum coefficients of CSP. CSP coefficients are derived by:<br/>


<math display="inline" id="3D_sound_localization:25">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>i</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{i}(n)
  </annotation>
 </semantics>
</math>

 Where 

<math display="inline" id="3D_sound_localization:26">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>j</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>j</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{j}(n)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="3D_sound_localization:27">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 are signals entering the microphone 

<math display="inline" id="3D_sound_localization:28">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="3D_sound_localization:29">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 respectively<br/>
Time delay of arrival(

<math display="block" id="3D_sound_localization:30">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mo>=</mo>
   <mrow>
    <mi>a</mi>
    <mi>r</mi>
    <mi>g</mi>
    <mrow>
     <mi>max</mi>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mi>c</mi>
       <mi>s</mi>
       <msub>
        <mi>p</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>k</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>τ</ci>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>r</ci>
     <ci>g</ci>
     <apply>
      <max></max>
      <apply>
       <times></times>
       <ci>c</ci>
       <ci>s</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\tau}=arg\max\{csp_{ij}(k)\}
  </annotation>
 </semantics>
</math>

) then can be estimated by:<br/>


<math display="block" id="3D_sound_localization:31">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mo>=</mo>
   <mrow>
    <mi>c</mi>
    <mi>o</mi>
    <msup>
     <mi>s</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mfrac>
     <mrow>
      <mi>v</mi>
      <mo>⋅</mo>
      <mi>τ</mi>
     </mrow>
     <mrow>
      <msub>
       <mi>d</mi>
       <mrow>
        <mi>m</mi>
        <mi>a</mi>
        <mi>x</mi>
       </mrow>
      </msub>
      <mo>⋅</mo>
      <msub>
       <mi>F</mi>
       <mi>s</mi>
      </msub>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>θ</ci>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <ci>normal-⋅</ci>
       <ci>v</ci>
       <ci>τ</ci>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>d</ci>
        <apply>
         <times></times>
         <ci>m</ci>
         <ci>a</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <ci>s</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\theta}=cos^{-1}\frac{v\cdot\tau}{d_{max}\cdot F_{s}}
  </annotation>
 </semantics>
</math>

 Sound source direction is</p>

<p>

<math display="inline" id="3D_sound_localization:32">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 Where 

<math display="inline" id="3D_sound_localization:33">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{s}
  </annotation>
 </semantics>
</math>

 is the sound propagation speed, 

<math display="inline" id="3D_sound_localization:34">
 <semantics>
  <msub>
   <mi>d</mi>
   <mrow>
    <mi>m</mi>
    <mi>a</mi>
    <mi>x</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>a</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{max}
  </annotation>
 </semantics>
</math>

 is the sampling frequency and <span class="LaTeX">$d_{max}$</span> is the distance with maximum time delay between 2 microphones.</p>

<p>CPS method does not require the system impulse response data that HRTF needs. An <a href="expectation-maximization_algorithm" title="wikilink">expectation-maximization algorithm</a> is also used for localizing several sound sources and reduce the localization errors. The system is capable of identifying several moving sound source using only two microphones.</p>
<h3 id="d-sensor-line-array">2D sensor line array</h3>

<p> In order to estimate the location of a source in 3d space, we can use 2 line sensor arrays by respectively putting them horizontally and vertically. An example is a 2D line array used for underwater source localization.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> By processing the data from 2 arrays using the <a href="maximum_likelihood" title="wikilink">maximum likelihood</a> method, the direction, range and depth of the source can be identified simultaneously.<br/>
Unlike the binaural hearing model, this method is much more like a <a href="spectral_analysis" title="wikilink">spectral analysis</a> method. The method can be used for localizing a source which is far away, but the system could be much more expensive than the binaural model because it needs more sensors and power.</p>
<h3 id="hierarchical-fuzzy-artificial-neural-networks-approach">Hierarchical Fuzzy Artificial Neural Networks Approach</h3>

<p> This sound localization system was inspired by biologically binaural sound localization. It is still not understood how animals with two ears and pea-sized brains such as some primitive mammals, are able to perceive 3D space and process sounds. Some animals experience difficulty in 3D sound location, due to the small heads and the wavelength of communication sound may be much larger than their head diameter, as is the case with <a class="uri" href="frogs" title="wikilink">frogs</a>.</p>

<p>Based on previous binaural sound localization methods, a hierarchical fuzzy artificial neural network system combines <a href="interaural_time_difference" title="wikilink">interaural time difference</a>(ITD-based) and interaural intensity difference(IID-based) sound localization methods for higher accuracy that is similar to that of humans. Hierarchical Fuzzy Artificial Neural Networks<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> were used with the goal of the same sound localization accuracy as human ears.</p>

<p>IID-based or ITD-based sound localization methods have a main problem called Front-back confusion.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> In this sound localization based on a hierarchical neural network system, to solve this issue, an IID estimation is with ITD estimation. This system was used for broadband sounds and be deployed for non-stationary scenarios.</p>
<h2 id="d-sound-localization-for-monaural-sound-source">3D sound localization for monaural sound source</h2>

<p>Typically, sound localization is performed by using two (or more) microphones. By using the difference of arrival times of a sound at the two microphones, one can mathematically estimate the direction of the sound source. However, the accuracy with which an array of microphones can localize a sound (using <a href="Interaural_time_difference" title="wikilink">Interaural time difference</a>) is fundamentally limited by the physical size of the array. If the array is too small, then the microphones are spaced too closely together so that they all record essentially the same sound (with ITF near zero), making it extremely difficult to estimate the orientation. Thus, it is not uncommon for microphone arrays to range from tens of centimeters in length (for desktop applications) to many tens of meters in length (for underwater localization). However, microphone arrays of this size then become impractical to use on small robots. even for large robots, such microphone arrays can be cumbersome to mount and to maneuver. In contrast, the ability to localize sound using a single microphone (which can be made extremely small) holds the potential of significantly more compact, as well as lower cost and power, devices for localization.</p>

<p>• <strong><big>conventional HRTF approach </big></strong></p>

<p>A general way to implement 3d sound localization is to use the <a class="uri" href="HRTF" title="wikilink">HRTF</a>(<a href="Head-related_transfer_function" title="wikilink">Head-related transfer function</a>). First, compute HRTFs for the 3D sound localization, which can be obtained by formulating two equations. One represents the signal of a given sound source and the other indicates the signal output from the dummy head microphones for the sound transferred from the source. Then, monaural input data are processed by these HRTFs, and the results are superposed to output from stereo-headphones.</p>

<p>It's a general way. But the disadvantage is that, a great amount of parametric operations are necessary for the whole set of filters to realize the 3D sound localization, which results in high computational complexity.</p>

<p>• <strong><big>DSP implementation of 3D sound localization</big></strong>  A DSP-based implementation of a realtime 3D sound localization approach with the use of an embedded DSP can reduce the <a href="Analysis_of_algorithms" title="wikilink">computational complexity</a> As shown in the figure, the implementation procedure of this realtime algorithm is divided into three phases, (i) Frequency Division, (ii) Sound Localization, and (iii) Mixing. In the case of 3D sound localization for a monaural sound source, the audio input data are divided into two: left and right channels and the audio input data in time series are processed one after another.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>A distinctive feature of this approach is that the audible frequency band is divided into three so that a distinct procedure of 3D sound localization can be exploited for each of the three subbands.</p>

<p>• <strong><big>single microphone approach</big></strong></p>

<p>Consider the problem of estimating the incident angle of a sound, using only a single microphone. Such monaural localization is made possible by the structure of the pinna (outer ear), which modifies sound in a way that is dependent on its incident angle. A machine learning approach is adapted for monaural localization, using only a single microphone and an “artificial pinna” (that distorts sound in a direction-dependent way). The approach models the typical distribution of natural and artificial sounds, as well as the direction-dependent changes to sounds induced by the pinna.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>The experimental results also show that the algorithm is able to fairly accurately localize a wide range of sounds, such as human speech, dog barking, waterfall, thunder, and so on. In contrast to microphone arrays, this approach also offers the potential of significantly more compact, as well as lower cost and power, devices for sound localization.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Acoustic_source_localization" title="wikilink">Acoustic source localization</a></li>
<li><a href="Binaural_recording" title="wikilink">Binaural recording</a></li>
<li><a href="Head-related_transfer_function" title="wikilink">Head-related transfer function</a></li>
<li><a href="Sound_localization" title="wikilink">Sound localization</a></li>
<li><a href="Vertical_sound_localization" title="wikilink">Vertical sound localization</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.youtube.com/watch?v=LJwUVCXH-gM/">A demo of 3d sound</a></li>
<li><a href="http://www.hitl.washington.edu/scivw/EVE/I.B.1.3DSoundSynthesis.html/">3d sound synthesis</a></li>
<li><a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2885955/">3-D Localization of Virtual Sound Sources</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Acoustics" title="wikilink">Category:Acoustics</a> <a class="uri" href="Category:Sound" title="wikilink">Category:Sound</a> <a class="uri" href="Category:Hearing" title="wikilink">Category:Hearing</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
</ol>
</section>
</body>
</html>
