<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="356">Elliptic curve cryptography</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Elliptic curve cryptography</h1>
<hr/>

<p><strong>Elliptic curve cryptography</strong> (<strong>ECC</strong>) is an approach to <a href="public-key_cryptography" title="wikilink">public-key cryptography</a> based on the algebraic structure of <a href="elliptic_curve" title="wikilink">elliptic curves</a> over <a href="finite_field" title="wikilink">finite fields</a>. One of the main benefits in comparison with non-ECC cryptography (with plain <a href="Galois_field" title="wikilink">Galois fields</a> as a basis) is the same level of security provided by keys of smaller size.</p>

<p>Elliptic curves are applicable for <a class="uri" href="encryption" title="wikilink">encryption</a>, <a href="digital_signature" title="wikilink">digital signatures</a>, <a href="CPRNG" title="wikilink">pseudo-random generators</a> and other tasks. They are also used in several <a href="integer_factorization" title="wikilink">integer factorization</a> <a href="algorithm" title="wikilink">algorithms</a> that have applications in cryptography, such as <a href="Lenstra_elliptic_curve_factorization" title="wikilink">Lenstra elliptic curve factorization</a>.</p>
<h2 id="rationale">Rationale</h2>

<p>Public-key cryptography is based on the <a href="Intractability_(complexity)#Intractability" title="wikilink">intractability</a> of certain mathematical <a href="Computational_hardness_assumption" title="wikilink">problems</a>. Early public-key systems are secure assuming that it is difficult to <a href="Integer_factorization" title="wikilink">factor</a> a large integer composed of two or more large prime factors. For elliptic-curve-based protocols, it is assumed that finding the <a href="discrete_logarithm" title="wikilink">discrete logarithm</a> of a random elliptic curve element with respect to a publicly known base point is infeasible: this is the "elliptic curve discrete logarithm problem" or ECDLP. The entire security of ECC depends on the ability to compute a <a href="elliptic_curve_point_multiplication" title="wikilink">point multiplication</a> and the inability to compute the multiplicand given the original and product points. The size of the elliptic curve determines the difficulty of the problem.</p>

<p>The primary benefit promised by ECC is a smaller key size, reducing storage and transmission requirements, i.e. that an elliptic curve group could provide the same level of security afforded by an RSA-based system with a large modulus and correspondingly larger key: for example, a 256-bit ECC public key should provide comparable security to a 3072-bit RSA public key.</p>
<h2 id="history">History</h2>

<p>The use of elliptic curves in cryptography was suggested independently by <a href="Neal_Koblitz" title="wikilink">Neal Koblitz</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and <a href="Victor_S._Miller" title="wikilink">Victor S. Miller</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> in 1985. Elliptic curve cryptography algorithms entered wide use in 2004 to 2005.</p>
<h2 id="theory">Theory</h2>

<p>For current cryptographic purposes, an <em>elliptic curve</em> is a <a href="plane_curve" title="wikilink">plane curve</a> over a finite field (rather than the real numbers) which consists of the points satisfying the equation</p>

<p>
<math display="block" id="Elliptic_curve_cryptography:0">
<semantics>
<mrow>
<mrow>
<msup>
<mi>y</mi>
<mn>2</mn>
</msup>
<mo>=</mo>
<mrow>
<msup>
<mi>x</mi>
<mn>3</mn>
</msup>
<mo>+</mo>
<mrow>
<mi>a</mi>
<mi>x</mi>
</mrow>
<mo>+</mo>
<mi>b</mi>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>y</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<cn type="integer">3</cn>
</apply>
<apply>
<times></times>
<ci>a</ci>
<ci>x</ci>
</apply>
<ci>b</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   y^{2}=x^{3}+ax+b,\,
  </annotation>
</semantics>
</math>
</p>

<p>along with a distinguished <a href="point_at_infinity" title="wikilink">point at infinity</a>, denoted ∞. (The coordinates here are to be chosen from a fixed <a href="finite_field" title="wikilink">finite field</a> of <a href="Characteristic_(algebra)#Case_of_fields" title="wikilink">characteristic</a> not equal to 2 or 3, or the curve equation will be somewhat more complicated.)</p>

<p>This set together with the <a href="Elliptic_curve#The_group_law" title="wikilink">group operation of elliptic curves</a> is an <a href="Abelian_group" title="wikilink">Abelian group</a>, with the point at infinity as identity element. The structure of the group is inherited from the <a href="Divisor_(algebraic_geometry)" title="wikilink">divisor group</a> of the underlying <a href="algebraic_variety" title="wikilink">algebraic variety</a>. As is the case for other popular public key cryptosystems, no mathematical proof of security has been published for ECC .</p>

<p>The U.S. <a href="NIST" title="wikilink">National Institute of Standards and Technology (NIST)</a> has endorsed ECC in its <a href="NSA_Suite_B" title="wikilink">Suite B</a> set of recommended algorithms, specifically Elliptic Curve Diffie–Hellman (ECDH) for key exchange and Elliptic Curve Digital Signature Algorithm (ECDSA) for digital signature. The U.S. <a href="National_Security_Agency" title="wikilink">National Security Agency</a> (NSA) allows their use for protecting information classified up to <a href="Classified_information_in_the_United_States" title="wikilink">top secret</a> with 384-bit keys.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>While the RSA patent expired in 2000, there may be <a href="ECC_patents" title="wikilink">patents in force covering certain aspects of ECC technology</a>, though some (including <a href="RSA_(security_firm)" title="wikilink">RSA Laboratories</a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> and <a href="Daniel_J._Bernstein" title="wikilink">Daniel J. Bernstein</a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a>) argue that the Federal elliptic curve digital signature standard (ECDSA; NIST FIPS 186-3) and certain practical ECC-based key exchange schemes (including ECDH) can be implemented without infringing them.</p>
<h2 id="cryptographic-schemes">Cryptographic schemes</h2>

<p>Several <a href="discrete_logarithm" title="wikilink">discrete logarithm</a>-based protocols have been adapted to elliptic curves, replacing the group 

<math display="inline" id="Elliptic_curve_cryptography:1">
<semantics>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>ℤ</mi>
<mi>p</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<mo>×</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ℤ</ci>
<ci>p</ci>
</apply>
<times></times>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (\mathbb{Z}_{p})^{\times}
  </annotation>
</semantics>
</math>

 with an elliptic curve:</p>
<ul>
<li>The <a href="elliptic_curve_Diffie–Hellman" title="wikilink">elliptic curve Diffie–Hellman</a> (ECDH) key agreement scheme is based on the <a class="uri" href="Diffie–Hellman" title="wikilink">Diffie–Hellman</a> scheme,</li>
<li>The Elliptic Curve <a href="Integrated_Encryption_Scheme" title="wikilink">Integrated Encryption Scheme</a> (ECIES), also known as Elliptic Curve Augmented Encryption Scheme or simply the Elliptic Curve Encryption Scheme,</li>
<li>The <a href="Elliptic_Curve_DSA" title="wikilink">Elliptic Curve Digital Signature Algorithm</a> (ECDSA) is based on the <a href="Digital_Signature_Algorithm" title="wikilink">Digital Signature Algorithm</a>,</li>
<li>The <a href="EdDSA" title="wikilink">Edwards-curve Digital Signature Algorithm</a> (EdDSA) is based on <a href="Schnorr_signature" title="wikilink">Schnorr signature</a> and uses <a href="twisted_Edwards_curve" title="wikilink">twisted Edwards curves</a>,</li>
<li>The <a class="uri" href="ECMQV" title="wikilink">ECMQV</a> key agreement scheme is based on the <a href="Menezes–Qu–Vanstone" title="wikilink">MQV</a> key agreement scheme,</li>
<li>The <a href="Implicit_certificate" title="wikilink">ECQV</a> implicit certificate scheme.</li>
</ul>

<p>At the RSA Conference 2005, the <a href="National_Security_Agency" title="wikilink">National Security Agency</a> (NSA) announced <a href="NSA_Suite_B" title="wikilink">Suite B</a> which exclusively uses ECC for digital signature generation and key exchange. The suite is intended to protect both classified and unclassified national security systems and information.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Recently, a large number of cryptographic primitives based on bilinear mappings on various elliptic curve groups, such as the <a href="Weil_pairing" title="wikilink">Weil</a> and <a href="Tate_pairing" title="wikilink">Tate pairings</a>, have been introduced. Schemes based on these primitives provide efficient <a href="identity-based_encryption" title="wikilink">identity-based encryption</a> as well as pairing-based signatures, <a class="uri" href="signcryption" title="wikilink">signcryption</a>, <a href="key_agreement" title="wikilink">key agreement</a>, and <a href="proxy_re-encryption" title="wikilink">proxy re-encryption</a>.</p>
<h2 id="implementation">Implementation</h2>

<p>Some common implementation considerations include:</p>
<h3 id="domain-parameters">Domain parameters</h3>

<p>To use ECC all parties must agree on all the elements defining the elliptic curve, that is, the <em>domain parameters</em> of the scheme. The field is defined by <em>p</em> in the prime case and the pair of <em>m</em> and <em>f</em> in the binary case. The elliptic curve is defined by the constants <em>a</em> and <em>b</em> used in its defining equation. Finally, the cyclic subgroup is defined by its <em>generator</em> (a.k.a. <em>base point</em>) <em>G</em>. For cryptographic application the <a href="order_(group_theory)" title="wikilink">order</a> of <em>G</em>, that is the smallest positive number <em>n</em> such that 

<math display="inline" id="Elliptic_curve_cryptography:2">
<semantics>
<mrow>
<mrow>
<mi>n</mi>
<mi>G</mi>
</mrow>
<mo>=</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>n</ci>
<ci>G</ci>
</apply>
<infinity></infinity>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   nG=\infty
  </annotation>
</semantics>
</math>

, is normally prime. Since <em>n</em> is the size of a subgroup of 

<math display="inline" id="Elliptic_curve_cryptography:3">
<semantics>
<mrow>
<mi>E</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>𝔽</mi>
<mi>p</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>E</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝔽</ci>
<ci>p</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   E(\mathbb{F}_{p})
  </annotation>
</semantics>
</math>

 it follows from <a href="Lagrange's_theorem_(group_theory)" title="wikilink">Lagrange's theorem</a> that the number 

<math display="inline" id="Elliptic_curve_cryptography:4">
<semantics>
<mrow>
<mi>h</mi>
<mo>=</mo>
<mrow>
<mfrac>
<mn>1</mn>
<mi>n</mi>
</mfrac>
<mrow>
<mo stretchy="false">|</mo>
<mrow>
<mi>E</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>𝔽</mi>
<mi>p</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">|</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>h</ci>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<ci>n</ci>
</apply>
<apply>
<abs></abs>
<apply>
<times></times>
<ci>E</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝔽</ci>
<ci>p</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   h=\frac{1}{n}|E(\mathbb{F}_{p})|
  </annotation>
</semantics>
</math>

 is an integer. In cryptographic applications this number <em>h</em>, called the <em>cofactor</em>, must be small (

<math display="inline" id="Elliptic_curve_cryptography:5">
<semantics>
<mrow>
<mi>h</mi>
<mo>≤</mo>
<mn>4</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<leq></leq>
<ci>h</ci>
<cn type="integer">4</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   h\leq 4
  </annotation>
</semantics>
</math>

) and, preferably, 

<math display="inline" id="Elliptic_curve_cryptography:6">
<semantics>
<mrow>
<mi>h</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>h</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   h=1
  </annotation>
</semantics>
</math>

. Let us summarize: in the prime case the domain parameters are 

<math display="inline" id="Elliptic_curve_cryptography:7">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mi>p</mi>
<mo>,</mo>
<mi>a</mi>
<mo>,</mo>
<mi>b</mi>
<mo>,</mo>
<mi>G</mi>
<mo>,</mo>
<mi>n</mi>
<mo>,</mo>
<mi>h</mi>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<vector>
<ci>p</ci>
<ci>a</ci>
<ci>b</ci>
<ci>G</ci>
<ci>n</ci>
<ci>h</ci>
</vector>
</annotation-xml>
<annotation encoding="application/x-tex">
   (p,a,b,G,n,h)
  </annotation>
</semantics>
</math>

 and in the binary case they are 

<math display="inline" id="Elliptic_curve_cryptography:8">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mo>,</mo>
<mi>f</mi>
<mo>,</mo>
<mi>a</mi>
<mo>,</mo>
<mi>b</mi>
<mo>,</mo>
<mi>G</mi>
<mo>,</mo>
<mi>n</mi>
<mo>,</mo>
<mi>h</mi>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<vector>
<ci>m</ci>
<ci>f</ci>
<ci>a</ci>
<ci>b</ci>
<ci>G</ci>
<ci>n</ci>
<ci>h</ci>
</vector>
</annotation-xml>
<annotation encoding="application/x-tex">
   (m,f,a,b,G,n,h)
  </annotation>
</semantics>
</math>

.</p>

<p>Unless there is an assurance that domain parameters were generated by a party trusted with respect to their use, the domain parameters <em>must</em> be validated before use.</p>

<p>The generation of domain parameters is not usually done by each participant since this involves computing <a href="counting_points_on_elliptic_curves" title="wikilink">the number of points on a curve</a> which is time-consuming and troublesome to implement. As a result several standard bodies published domain parameters of elliptic curves for several common field sizes. Such domain parameters are commonly known as "standard curves" or "named curves"; a named curve can be referenced either by name or by the unique <a href="object_identifier" title="wikilink">object identifier</a> defined in the standard documents:</p>
<ul>
<li>NIST, <a href="http://csrc.nist.gov/groups/ST/toolkit/documents/dss/NISTReCur.pdf">Recommended Elliptic Curves for Government Use</a></li>
<li>SECG, <a href="http://www.secg.org/sec2-v2.pdf">SEC 2: Recommended Elliptic Curve Domain Parameters</a></li>
<li>ECC Brainpool, <a href="http://www.ecc-brainpool.org/download/Domain-parameters.pdf">ECC Brainpool Standard Curves and Curve Generation</a></li>
</ul>

<p>SECG test vectors are also available.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> NIST has approved many SECG curves, so there is a significant overlap between the specifications published by NIST and SECG. EC domain parameters may be either specified by value or by name.</p>

<p>If one (despite the above) wants to construct one's own domain parameters, one should select the underlying field and then use one of the following strategies to find a curve with appropriate (i.e., near prime) number of points using one of the following methods:</p>
<ul>
<li>Select a random curve and use a general point-counting algorithm, for example, <a href="Schoof's_algorithm" title="wikilink">Schoof's algorithm</a> or <a href="Schoof–Elkies–Atkin_algorithm" title="wikilink">Schoof–Elkies–Atkin algorithm</a>,</li>
<li>Select a random curve from a family which allows easy calculation of the number of points (e.g., Koblitz curves), or</li>
<li>Select the number of points and generate a curve with this number of points using <em>complex multiplication</em> technique.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></li>
</ul>

<p>Several classes of curves are weak and should be avoided:</p>
<ul>
<li>Curves over 

<math display="inline" id="Elliptic_curve_cryptography:9">
<semantics>
<msub>
<mi>𝔽</mi>
<msup>
<mn>2</mn>
<mi>m</mi>
</msup>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝔽</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<ci>m</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{F}_{2^{m}}
  </annotation>
</semantics>
</math>

 with non-prime <em>m</em> are vulnerable to <a href="Weil_descent" title="wikilink">Weil descent</a> attacks.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></li>
<li>Curves such that <em>n</em> divides 

<math display="inline" id="Elliptic_curve_cryptography:10">
<semantics>
<mrow>
<msup>
<mi>p</mi>
<mi>B</mi>
</msup>
<mo>-</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>p</ci>
<ci>B</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p^{B}-1
  </annotation>
</semantics>
</math>

 (where <em>p</em> is the characteristic of the field – <em>q</em> for a prime field, or 

<math display="inline" id="Elliptic_curve_cryptography:11">
<semantics>
<mn>2</mn>
<annotation-xml encoding="MathML-Content">
<cn type="integer">2</cn>
</annotation-xml>
<annotation encoding="application/x-tex">
   2
  </annotation>
</semantics>
</math>

 for a binary field) for sufficiently small <em>B</em> are vulnerable to Menezes–Okamoto–Vanstone (MOV) attack<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> which applies usual Discrete Logarithm Problem (DLP) in a small degree extension field of 

<math display="inline" id="Elliptic_curve_cryptography:12">
<semantics>
<msub>
<mi>𝔽</mi>
<mi>p</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝔽</ci>
<ci>p</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{F}_{p}
  </annotation>
</semantics>
</math>

 to solve ECDLP. The bound <em>B</em> should be chosen so that discrete logarithms in the field 

<math display="inline" id="Elliptic_curve_cryptography:13">
<semantics>
<msub>
<mi>𝔽</mi>
<msup>
<mi>p</mi>
<mi>B</mi>
</msup>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝔽</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>p</ci>
<ci>B</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{F}_{p^{B}}
  </annotation>
</semantics>
</math>

 are at least as difficult to compute as discrete logs on the elliptic curve 

<math display="inline" id="Elliptic_curve_cryptography:14">
<semantics>
<mrow>
<mi>E</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>𝔽</mi>
<mi>q</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>E</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝔽</ci>
<ci>q</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   E(\mathbb{F}_{q})
  </annotation>
</semantics>
</math>

.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></li>
<li>Curves such that 

<math display="inline" id="Elliptic_curve_cryptography:15">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">|</mo>
<mrow>
<mi>E</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>𝔽</mi>
<mi>q</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">|</mo>
</mrow>
<mo>=</mo>
<mi>q</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<abs></abs>
<apply>
<times></times>
<ci>E</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝔽</ci>
<ci>q</ci>
</apply>
</apply>
</apply>
<ci>q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |E(\mathbb{F}_{q})|=q
  </annotation>
</semantics>
</math>

 are vulnerable to the attack that maps the points on the curve to the additive group of 

<math display="inline" id="Elliptic_curve_cryptography:16">
<semantics>
<msub>
<mi>𝔽</mi>
<mi>q</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝔽</ci>
<ci>q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{F}_{q}
  </annotation>
</semantics>
</math>
<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></li>
</ul>
<h3 id="key-sizes">Key sizes</h3>

<p>Since all the fastest known algorithms that allow one to solve the ECDLP (<a href="baby-step_giant-step" title="wikilink">baby-step giant-step</a>, <a href="Pollard's_rho_algorithm_for_logarithms" title="wikilink">Pollard's rho</a>, etc.), need 

<math display="inline" id="Elliptic_curve_cryptography:17">
<semantics>
<mrow>
<mi>O</mi>
<mrow>
<mo stretchy="false">(</mo>
<msqrt>
<mi>n</mi>
</msqrt>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>O</ci>
<apply>
<root></root>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   O(\sqrt{n})
  </annotation>
</semantics>
</math>

 steps, it follows that the size of the underlying field should be roughly twice the security parameter. For example, for 128-bit security one needs a curve over 

<math display="inline" id="Elliptic_curve_cryptography:18">
<semantics>
<msub>
<mi>𝔽</mi>
<mi>q</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝔽</ci>
<ci>q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{F}_{q}
  </annotation>
</semantics>
</math>

, where 

<math display="inline" id="Elliptic_curve_cryptography:19">
<semantics>
<mrow>
<mi>q</mi>
<mo>≈</mo>
<msup>
<mn>2</mn>
<mn>256</mn>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<approx></approx>
<ci>q</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<cn type="integer">256</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   q\approx 2^{256}
  </annotation>
</semantics>
</math>

. This can be contrasted with finite-field cryptography (e.g., <a href="Digital_Signature_Algorithm" title="wikilink">DSA</a>) which requires<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> 3072-bit public keys and 256-bit private keys, and integer factorization cryptography (e.g., <a href="RSA_(algorithm)" title="wikilink">RSA</a>) which requires a 3072-bit value of <em>n</em>, where the private key should be just as large. However the public key may be smaller to accommodate efficient encryption, especially when processing power is limited.</p>

<p>The hardest ECC scheme (publicly) broken to date had a 112-bit key for the prime field case and a 109-bit key for the binary field case. For the prime field case this was broken in July 2009 using a cluster of over 200 <a href="PlayStation_3" title="wikilink">PlayStation 3</a> game consoles and could have been finished in 3.5 months using this cluster when running continuously.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> The binary field case was broken in April 2004 using 2600 computers over 17 months.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>A current project is aiming at breaking the ECC2K-130 challenge by Certicom, by using a wide range of different hardware: CPUs, GPUs, FPGA.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h3 id="projective-coordinates">Projective coordinates</h3>

<p>A close examination of the addition rules shows that in order to add two points one needs not only several additions and multiplications in 

<math display="inline" id="Elliptic_curve_cryptography:20">
<semantics>
<msub>
<mi>𝔽</mi>
<mi>q</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝔽</ci>
<ci>q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{F}_{q}
  </annotation>
</semantics>
</math>

 but also an inversion operation. The inversion (for given 

<math display="inline" id="Elliptic_curve_cryptography:21">
<semantics>
<mrow>
<mi>x</mi>
<mo>∈</mo>
<msub>
<mi>𝔽</mi>
<mi>q</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>x</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝔽</ci>
<ci>q</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x\in\mathbb{F}_{q}
  </annotation>
</semantics>
</math>

 find 

<math display="inline" id="Elliptic_curve_cryptography:22">
<semantics>
<mrow>
<mi>y</mi>
<mo>∈</mo>
<msub>
<mi>𝔽</mi>
<mi>q</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>y</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝔽</ci>
<ci>q</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   y\in\mathbb{F}_{q}
  </annotation>
</semantics>
</math>

 such that 

<math display="inline" id="Elliptic_curve_cryptography:23">
<semantics>
<mrow>
<mrow>
<mi>x</mi>
<mi>y</mi>
</mrow>
<mo>=</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>x</ci>
<ci>y</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   xy=1
  </annotation>
</semantics>
</math>

) is one to two orders of magnitude slower<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> than multiplication. Fortunately, points on a curve can be represented in different coordinate systems which do not require an inversion operation to add two points. Several such systems were proposed: in the <em>projective</em> system each point is represented by three coordinates 

<math display="inline" id="Elliptic_curve_cryptography:24">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo>,</mo>
<mi>Y</mi>
<mo>,</mo>
<mi>Z</mi>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<vector>
<ci>X</ci>
<ci>Y</ci>
<ci>Z</ci>
</vector>
</annotation-xml>
<annotation encoding="application/x-tex">
   (X,Y,Z)
  </annotation>
</semantics>
</math>

 using the following relation

<math display="block" id="Elliptic_curve_cryptography:25">
<semantics>
<mrow>
<mi>x</mi>
<mo>=</mo>
<mfrac>
<mi>X</mi>
<mi>Z</mi>
</mfrac>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>x</ci>
<apply>
<divide></divide>
<ci>X</ci>
<ci>Z</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x=\frac{X}{Z}
  </annotation>
</semantics>
</math>

, 

<math display="inline" id="Elliptic_curve_cryptography:26">
<semantics>
<mrow>
<mi>y</mi>
<mo>=</mo>
<mfrac>
<mi>Y</mi>
<mi>Z</mi>
</mfrac>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>y</ci>
<apply>
<divide></divide>
<ci>Y</ci>
<ci>Z</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   y=\frac{Y}{Z}
  </annotation>
</semantics>
</math>

; in the <em>Jacobian system</em> a point is also represented with three coordinates 

<math display="inline" id="Elliptic_curve_cryptography:27">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo>,</mo>
<mi>Y</mi>
<mo>,</mo>
<mi>Z</mi>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<vector>
<ci>X</ci>
<ci>Y</ci>
<ci>Z</ci>
</vector>
</annotation-xml>
<annotation encoding="application/x-tex">
   (X,Y,Z)
  </annotation>
</semantics>
</math>

, but a different relation is used

<math display="block" id="Elliptic_curve_cryptography:28">
<semantics>
<mrow>
<mi>x</mi>
<mo>=</mo>
<mfrac>
<mi>X</mi>
<msup>
<mi>Z</mi>
<mn>2</mn>
</msup>
</mfrac>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>x</ci>
<apply>
<divide></divide>
<ci>X</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>Z</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x=\frac{X}{Z^{2}}
  </annotation>
</semantics>
</math>

, 

<math display="inline" id="Elliptic_curve_cryptography:29">
<semantics>
<mrow>
<mi>y</mi>
<mo>=</mo>
<mfrac>
<mi>Y</mi>
<msup>
<mi>Z</mi>
<mn>3</mn>
</msup>
</mfrac>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>y</ci>
<apply>
<divide></divide>
<ci>Y</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>Z</ci>
<cn type="integer">3</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   y=\frac{Y}{Z^{3}}
  </annotation>
</semantics>
</math>

; in the <em>López–Dahab system</em> the relation is 

<math display="inline" id="Elliptic_curve_cryptography:30">
<semantics>
<mrow>
<mi>x</mi>
<mo>=</mo>
<mfrac>
<mi>X</mi>
<mi>Z</mi>
</mfrac>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>x</ci>
<apply>
<divide></divide>
<ci>X</ci>
<ci>Z</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x=\frac{X}{Z}
  </annotation>
</semantics>
</math>

, 

<math display="inline" id="Elliptic_curve_cryptography:31">
<semantics>
<mrow>
<mi>y</mi>
<mo>=</mo>
<mfrac>
<mi>Y</mi>
<msup>
<mi>Z</mi>
<mn>2</mn>
</msup>
</mfrac>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>y</ci>
<apply>
<divide></divide>
<ci>Y</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>Z</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   y=\frac{Y}{Z^{2}}
  </annotation>
</semantics>
</math>

; in the <em>modified Jacobian</em> system the same relations are used but four coordinates are stored and used for calculations 

<math display="inline" id="Elliptic_curve_cryptography:32">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo>,</mo>
<mi>Y</mi>
<mo>,</mo>
<mi>Z</mi>
<mo>,</mo>
<mrow>
<mi>a</mi>
<msup>
<mi>Z</mi>
<mn>4</mn>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<vector>
<ci>X</ci>
<ci>Y</ci>
<ci>Z</ci>
<apply>
<times></times>
<ci>a</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>Z</ci>
<cn type="integer">4</cn>
</apply>
</apply>
</vector>
</annotation-xml>
<annotation encoding="application/x-tex">
   (X,Y,Z,aZ^{4})
  </annotation>
</semantics>
</math>

; and in the <em>Chudnovsky Jacobian</em> system five coordinates are used 

<math display="inline" id="Elliptic_curve_cryptography:33">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo>,</mo>
<mi>Y</mi>
<mo>,</mo>
<mi>Z</mi>
<mo>,</mo>
<msup>
<mi>Z</mi>
<mn>2</mn>
</msup>
<mo>,</mo>
<msup>
<mi>Z</mi>
<mn>3</mn>
</msup>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<vector>
<ci>X</ci>
<ci>Y</ci>
<ci>Z</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>Z</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>Z</ci>
<cn type="integer">3</cn>
</apply>
</vector>
</annotation-xml>
<annotation encoding="application/x-tex">
   (X,Y,Z,Z^{2},Z^{3})
  </annotation>
</semantics>
</math>

. Note that there may be different naming conventions, for example, <a href="IEEE_P1363" title="wikilink">IEEE P1363</a>-2000 standard uses "projective coordinates" to refer to what is commonly called Jacobian coordinates. An additional speed-up is possible if mixed coordinates are used.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>
<h3 id="fast-reduction-nist-curves">Fast reduction (NIST curves)</h3>

<p>Reduction modulo <em>p</em> (which is needed for addition and multiplication) can be executed much faster if the prime <em>p</em> is a pseudo-<a href="Mersenne_prime" title="wikilink">Mersenne prime</a>, that is 

<math display="inline" id="Elliptic_curve_cryptography:34">
<semantics>
<mrow>
<mi>p</mi>
<mo>≈</mo>
<msup>
<mn>2</mn>
<mi>d</mi>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<approx></approx>
<ci>p</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<ci>d</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p\approx 2^{d}
  </annotation>
</semantics>
</math>

; for example, 

<math display="inline" id="Elliptic_curve_cryptography:35">
<semantics>
<mrow>
<mi>p</mi>
<mo>=</mo>
<mrow>
<msup>
<mn>2</mn>
<mn>521</mn>
</msup>
<mo>-</mo>
<mn>1</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>p</ci>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<cn type="integer">521</cn>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p=2^{521}-1
  </annotation>
</semantics>
</math>

 or 

<math display="inline" id="Elliptic_curve_cryptography:36">
<semantics>
<mrow>
<mi>p</mi>
<mo>=</mo>
<mrow>
<msup>
<mn>2</mn>
<mn>256</mn>
</msup>
<mo>-</mo>
<msup>
<mn>2</mn>
<mn>32</mn>
</msup>
<mo>-</mo>
<msup>
<mn>2</mn>
<mn>9</mn>
</msup>
<mo>-</mo>
<msup>
<mn>2</mn>
<mn>8</mn>
</msup>
<mo>-</mo>
<msup>
<mn>2</mn>
<mn>7</mn>
</msup>
<mo>-</mo>
<msup>
<mn>2</mn>
<mn>6</mn>
</msup>
<mo>-</mo>
<msup>
<mn>2</mn>
<mn>4</mn>
</msup>
<mo>-</mo>
<mn>1.</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>p</ci>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<cn type="integer">256</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<cn type="integer">32</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<cn type="integer">9</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<cn type="integer">8</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<cn type="integer">7</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<cn type="integer">6</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<cn type="integer">4</cn>
</apply>
<cn type="float">1.</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p=2^{256}-2^{32}-2^{9}-2^{8}-2^{7}-2^{6}-2^{4}-1.
  </annotation>
</semantics>
</math>

 Compared to <a href="Barrett_reduction" title="wikilink">Barrett reduction</a> there can be an order of magnitude speed up.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> The speed up here is a practical rather than theoretical one, and derives from the fact that the moduli of numbers against numbers near powers of two can be performed efficiently by computers operating on binary numbers with <a href="bitwise_operation" title="wikilink">bitwise operations</a>.</p>

<p>The curves over 

<math display="inline" id="Elliptic_curve_cryptography:37">
<semantics>
<msub>
<mi>𝔽</mi>
<mi>p</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝔽</ci>
<ci>p</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{F}_{p}
  </annotation>
</semantics>
</math>

 with pseudo-Mersenne <em>p</em> are recommended by NIST. Yet another advantage of the NIST curves is the fact that they use <em>a</em> = −3, which improves addition in Jacobian coordinates.</p>

<p>Many of the efficiency-related decisions in NIST FIPS 186-2 are sub-optimal. Other curves are more secure and run just as fast.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>
<h2 id="applications">Applications</h2>

<p>Elliptic curves are applicable for <a class="uri" href="encryption" title="wikilink">encryption</a>, <a href="digital_signature" title="wikilink">digital signatures</a>, <a href="CPRNG" title="wikilink">pseudo-random generators</a> and other tasks. They are also used in several <a href="integer_factorization" title="wikilink">integer factorization</a> <a href="algorithm" title="wikilink">algorithms</a> that have applications in cryptography, such as <a href="Lenstra_elliptic_curve_factorization" title="wikilink">Lenstra elliptic curve factorization</a>.</p>

<p>NIST recommended fifteen elliptic curves. Specifically, FIPS 186-3 has ten recommended finite fields:</p>
<ul>
<li>Five prime fields 

<math display="inline" id="Elliptic_curve_cryptography:38">
<semantics>
<msub>
<mi>𝔽</mi>
<mi>p</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝔽</ci>
<ci>p</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{F}_{p}
  </annotation>
</semantics>
</math>

 for certain primes <em>p</em> of sizes 192, 224, 256, 384, and 521<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> bits. For each of the prime fields, one elliptic curve is recommended.</li>
<li>Five binary fields 

<math display="inline" id="Elliptic_curve_cryptography:39">
<semantics>
<msub>
<mi>𝔽</mi>
<msup>
<mn>2</mn>
<mi>m</mi>
</msup>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝔽</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<ci>m</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{F}_{2^{m}}
  </annotation>
</semantics>
</math>

 for <em>m</em> equal 163, 233, 283, 409, and 571. For each of the binary fields, one elliptic curve and one <a href="Neal_Koblitz" title="wikilink">Koblitz</a> curve was selected.</li>
</ul>

<p>The NIST recommendation thus contains a total of five prime curves and ten binary curves. The curves were ostensibly chosen for optimal security and implementation efficiency.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>

<p>In 2013, the <em><a href="New_York_Times" title="wikilink">New York Times</a></em> stated that <a href="Dual_EC_DRBG" title="wikilink">Dual Elliptic Curve Deterministic Random Bit Generation</a> (or Dual_EC_DRBG) had been included as a NIST national standard due to the influence of <a class="uri" href="NSA" title="wikilink">NSA</a>, which had included a deliberate weakness in the algorithm and the recommended elliptic curve. <a href="RSA_Security" title="wikilink">RSA Security</a> in September 2013 issued an advisory recommending that its customers discontinue using any software based on Dual_EC_DRBG.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a><a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> In the wake of the exposure of Dual_EC_DRBG as "an NSA undercover operation", cryptography experts have also expressed concern over the security of the NIST recommended elliptic curves,<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> suggesting a return to encryption based on non-elliptic-curve groups.</p>
<h2 id="security">Security</h2>
<h3 id="side-channel-attacks">Side-channel attacks</h3>

<p>Unlike most other <a href="Discrete_Logarithm" title="wikilink">DLP</a> systems (where it is possible to use the same procedure for squaring and multiplication) the EC addition is significantly different for doubling (

<math display="inline" id="Elliptic_curve_cryptography:40">
<semantics>
<mrow>
<mi>P</mi>
<mo>=</mo>
<mi>Q</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>P</ci>
<ci>Q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P=Q
  </annotation>
</semantics>
</math>

) and general addition (

<math display="inline" id="Elliptic_curve_cryptography:41">
<semantics>
<mrow>
<mi>P</mi>
<mo>≠</mo>
<mi>Q</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<neq></neq>
<ci>P</ci>
<ci>Q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P\neq Q
  </annotation>
</semantics>
</math>

) depending on the coordinate system used. Consequently, it is important to counteract <a href="side_channel_attack" title="wikilink">side channel attacks</a> (e.g., timing or <a href="Power_analysis" title="wikilink">simple/differential power analysis attacks</a>) using, for example, fixed pattern window (a.k.a. comb) methods<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> (note that this does not increase the computation time). Another concern for ECC-systems is the danger of <a href="Differential_fault_analysis" title="wikilink">fault attacks</a>, especially when running on <a href="smart_card" title="wikilink">smart cards</a>.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>

<p>Cryptographic experts have also expressed concerns that the National Security Agency has inserted a backdoor into at least one elliptic curve-based pseudo random generator.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> One analysis of the possible backdoor concluded that an adversary in possession of the algorithm's secret key could obtain encryption keys given only 32 bytes of ciphertext.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p>
<h3 id="quantum-computing-attacks">Quantum computing attacks</h3>

<p>Elliptic curve cryptography is vulnerable to a modified <a href="Shor's_algorithm" title="wikilink">Shor's algorithm</a> for solving the discrete logarithm problem on elliptic curves.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> A quantum computer to attack elliptic curve cryptography can be less than half the size of a <a href="quantum_computer" title="wikilink">quantum computer</a> to break an equivalently classically secure version of <a href="Rivest_Shamir_Adleman" title="wikilink">RSA</a>. This is due to the fact that smaller key sizes of elliptic curves are needed to match the classical security of RSA. The work of Proos and Zalka show how a quantum computer to break 2048-bit RSA requires roughly 4096 qubits while a quantum computer to break the equivalently secure 224-bit Elliptic Curve Cryptography requires between 1300 and 1600 qubits. Depending on the growth rate of quantum computers in the future, elliptic curve cryptosystems may become attackable by a quantum computer many years before an equivalently secure RSA scheme.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></p>

<p>To avoid quantum computing concerns, an elliptic curve based alternative to Elliptic Curve Diffie Hellman which is not susceptible to Shor's attack is the <a href="Supersingular_Isogeny_Key_Exchange" title="wikilink">Supersingular Isogeny Diffie–Hellman Key Exchange</a> of De Feo, Jao and Plut. They use elliptic curve <a class="uri" href="isogenies" title="wikilink">isogenies</a> to create a drop in replacement for the quantum attackable <a class="uri" href="Diffie–Hellman" title="wikilink">Diffie–Hellman</a> and <a href="Elliptic_curve_Diffie–Hellman" title="wikilink">Elliptic curve Diffie–Hellman</a> key exchanges. This key exchange utilizes the same elliptic curve computational primitives of existing elliptic curve cryptography and requires computational and transmission overhead similar to many currently used public key systems.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a></p>
<h2 id="patents">Patents</h2>

<p>At least one ECC scheme (<a class="uri" href="ECMQV" title="wikilink">ECMQV</a>) and some implementation techniques are covered by patents.</p>
<h2 id="alternative-representations">Alternative representations</h2>

<p>Alternative representations of elliptic curves include:</p>
<ul>
<li><a href="Hessian_curves" title="wikilink">Hessian curves</a></li>
<li><a href="Edwards_curves" title="wikilink">Edwards curves</a></li>
<li><a href="Twisted_curves" title="wikilink">Twisted curves</a></li>
<li><a href="Twisted_Hessian_curves" title="wikilink">Twisted Hessian curves</a></li>
<li><a href="Twisted_Edwards_curve" title="wikilink">Twisted Edwards curve</a></li>
<li><a href="Doubling-oriented_Doche–Icart–Kohel_curve" title="wikilink">Doubling-oriented Doche–Icart–Kohel curve</a></li>
<li><a href="Tripling-oriented_Doche–Icart–Kohel_curve" title="wikilink">Tripling-oriented Doche–Icart–Kohel curve</a></li>
<li><a href="Jacobian_curve" title="wikilink">Jacobian curve</a></li>
<li><a href="Montgomery_curve" title="wikilink">Montgomery curve</a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Cryptocurrency" title="wikilink">Cryptocurrency</a></li>
<li><a class="uri" href="Curve25519" title="wikilink">Curve25519</a></li>
<li><a class="uri" href="DNSCurve" title="wikilink">DNSCurve</a></li>
<li><a href="ECC_patents" title="wikilink">ECC patents</a></li>
<li><a class="uri" href="ECDH" title="wikilink">ECDH</a></li>
<li><a href="Elliptic_Curve_Digital_Signature_Algorithm" title="wikilink">Elliptic Curve Digital Signature Algorithm</a></li>
<li><a class="uri" href="ECMQV" title="wikilink">ECMQV</a></li>
<li><a href="Elliptic_curve_point_multiplication" title="wikilink">Elliptic curve point multiplication</a></li>
<li><a href="Homomorphic_Signatures_for_Network_Coding" title="wikilink">Homomorphic Signatures for Network Coding</a></li>
<li><a href="Pairing-based_cryptography" title="wikilink">Pairing-based cryptography</a></li>
<li><a href="Public-key_cryptography" title="wikilink">Public-key cryptography</a></li>
<li><a href="Quantum_cryptography" title="wikilink">Quantum cryptography</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li><a href="SECG" title="wikilink">Standards for Efficient Cryptography Group (SECG)</a>, <a href="http://www.secg.org/download/aid-385/sec1_final.pdf">SEC 1: Elliptic Curve Cryptography</a>, Version 1.0, September 20, 2000.</li>
<li>D. Hankerson, A. Menezes, and S.A. Vanstone, <em>Guide to Elliptic Curve Cryptography</em>, Springer-Verlag, 2004.</li>
<li>I. Blake, G. Seroussi, and N. Smart, <em>Elliptic Curves in Cryptography</em>, London Mathematical Society 265, Cambridge University Press, 1999.</li>
<li>I. Blake, G. Seroussi, and N. Smart, editors, <em>Advances in Elliptic Curve Cryptography</em>, London Mathematical Society 317, Cambridge University Press, 2005.</li>
<li>L. Washington, <em>Elliptic Curves: Number Theory and Cryptography</em>, Chapman &amp; Hall / CRC, 2003.</li>
<li><a href="http://www.nsa.gov/business/programs/elliptic_curve.shtml">The Case for Elliptic Curve Cryptography</a>, National Security Agency</li>
<li><a href="http://www.certicom.com/index.php/ecc-tutorial">Online Elliptic Curve Cryptography Tutorial</a>, Certicom Corp.</li>
<li>K. Malhotra, S. Gardner, and R. Patz, Implementation of Elliptic-Curve Cryptography on Mobile Healthcare Devices, Networking, Sensing and Control, 2007 IEEE International Conference on, London, 15–17 April 2007 Page(s):239–244</li>
<li>Saikat Basu, <a href="http://ijns.jalaxy.com.tw/contents/ijns-v14-n2/ijns-2012-v14-n2-p101-108.pdf">A New Parallel Window-Based Implementation of the Elliptic Curve Point Multiplication in Multi-Core Architectures</a>, International Journal of Network Security, Vol. 13, No. 3, 2011, Page(s):234–241</li>
<li>Christof Paar, Jan Pelzl, <a href="http://wiki.crypto.rub.de/Buch/movies.php">"Elliptic Curve Cryptosystems"</a>, Chapter 9 of "Understanding Cryptography, A Textbook for Students and Practitioners". (companion web site contains online cryptography course that covers elliptic curve cryptography), Springer, 2009.</li>
<li>Luca De Feo, David Jao, Jerome Plut, <a href="http://eprint.iacr.org/2011/506">Towards quantum-resistant cryptosystems from supersingular elliptic curve isogenies</a>, Springer 2011.</li>
</ul>
<ul>
<li><a href="http://archive.numdam.org/ARCHIVE/MSMF/MSMF_1978__57_/MSMF_1978__57__1_0/MSMF_1978__57__1_0.pdf">Jacques Vélu, <em>Courbes elliptiques (...)</em>, Société Mathématique de France, <strong>57</strong>, 1-152, Paris, 1978.</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.certicom.com/index.php/ecc-tutorial">Certicom ECC Tutorial</a></li>
<li><a href="http://arstechnica.com/security/2013/10/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/">a relatively easy to understand primer on elliptic curve cryptography</a></li>
<li><a href="http://www.imperialviolet.org/2010/12/04/ecc.html">Elliptic curves and their implementation</a> by Adam Langley (OpenSSL dev).</li>
<li><a href="http://sagenb.org/home/pub/1126/">Interactive introduction to elliptic curves and elliptic curve cryptography with SAGE</a></li>
<li><a href="http://www.numberphile.com/videos/NSA1.html">How did the NSA hack our e-mails?</a> explained by Mathematician <a href="Edward_Frenkel" title="wikilink">Edward Frenkel</a></li>
<li><a href="http://blog.cr.yp.to/20140323-ecdsa.html">How to design an elliptic-curve signature system</a> by <a href="Daniel_J._Bernstein" title="wikilink">Daniel J. Bernstein</a></li>
</ul>

<p>"</p>

<p><a href="Category:Elliptic_curve_cryptography" title="wikilink">Category:Elliptic curve cryptography</a> <a href="Category:Public-key_cryptography" title="wikilink">Category:Public-key cryptography</a> <a href="Category:Finite_fields" title="wikilink">Category:Finite fields</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a class="uri" href="http://www.secg.org/download/aid-390/gec2.pdf">http://www.secg.org/download/aid-390/gec2.pdf</a><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13">IEEE <a href="http://grouper.ieee.org/groups/1363/P1363/index.html">P1363</a>, section A.12.1<a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17">NIST, <a href="http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57_part1_rev3_general.pdf">Recommendation for Key Management—Part 1: general</a>, Special Publication 800-57, August 2005.<a href="#fnref17">↩</a></li>
<li id="fn18"><a class="uri" href="http://lacal.epfl.ch/page81774.html">http://lacal.epfl.ch/page81774.html</a><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a class="uri" href="http://www.ecc-challenge.info/">http://www.ecc-challenge.info/</a><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25">The sequence may seem suggestive of a typographic error. Nevertheless, the last value is 521 and not 512 bits.<a href="#fnref25">↩</a></li>
<li id="fn26">FIPS PUB 186-3, <a href="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf">Digital Signature Standard (DSS)</a>.<a href="#fnref26">↩</a></li>
<li id="fn27">Kim Zetter, <a href="http://www.wired.com/threatlevel/2013/09/rsa-advisory-nsa-algorithm/">RSA Tells Its Developer Customers: Stop Using NSA-Linked Algorithm</a> <em><a href="Wired_(magazine)" title="wikilink">Wired</a></em>, 19 September 2013. "Recommending against the use of SP 800-90A Dual Elliptic Curve Deterministic Random Bit Generation: NIST strongly recommends that, pending the resolution of the security concerns and the re-issuance of SP 800-90A, the Dual_EC_DRBG, as specified in the January 2012 version of SP 800-90A, no longer be used."<a href="#fnref27">↩</a></li>
<li id="fn28"><a href="http://csrc.nist.gov/publications/PubsDrafts.html#SP-800-90-A%20Rev%201%20B%20and%20C">"Due to the debate around the Dual EC DRBG standard highlighted recently by the National Institute of Standards and Technology (NIST), NIST re-opened for public comment its SP 800-90 standard which covers Pseudo-random Number Generators (PRNG)." csrc.nist.gov</a><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="Bruce_Schneier" title="wikilink">Bruce Schneier</a> (5 September) "I no longer trust the constants. I believe the NSA has manipulated them through their relationships with industry." See [<a class="uri" href="http://it.slashdot.org/firehose.pl?op=view&amp;type">http://it.slashdot.org/firehose.pl?op=view&amp;type;</a>;=story&amp;sid;=13/09/11/1224252 Are the NIST Standard Elliptic Curves Back-doored?], <em><a class="uri" href="Slashdot" title="wikilink">Slashdot</a></em>, 11 September 2013.<a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31">See, for example, <a href="#fnref31">↩</a></li>
<li id="fn32"><a class="uri" href="https://www.schneier.com/essay-198.html">https://www.schneier.com/essay-198.html</a><a href="#fnref32">↩</a></li>
<li id="fn33"><a class="uri" href="http://rump2007.cr.yp.to/15-shumow.pdf">http://rump2007.cr.yp.to/15-shumow.pdf</a><a href="#fnref33">↩</a></li>
<li id="fn34"><a href="#fnref34">↩</a></li>
<li id="fn35"><a href="#fnref35">↩</a></li>
<li id="fn36"><a href="#fnref36">↩</a></li>
</ol>
</section>
</body>
</html>
