   Kinetic convex hull      Kinetic convex hull   A kinetic convex hull data structure is a kinetic data structure that maintains the convex hull of a set of continuously moving points. 1  The 2D case  The best known data structure for the 2-dimensional kinetic convex hull problem is by Basch, Guibas , and Hershberger. This data structure is responsive , efficient , compact and local . 2  The data structure  The dual of a convex hull of a set of points is the upper and lower envelopes of the dual set of lines. Therefore, maintaining the upper and lower envelopes of a set of moving lines is equivalent to maintaining the convex hull of a set of moving points. Computing upper and lower envelopes are equivalent problems, so computing the upper envelope of a set of lines is equivalent to computing the convex hull of a set of moving points. The upper envelope of a set of static lines can be computed using a divide and conquer algorithm which partitions the lines into two sets of equal size, calls itself recursively on the two sets to find their upper envelopes, and then merges the two resulting upper envelopes. The merge step is performed using a vertical line sweep . Call the first set of points blue and the second set of points red.  The standard line sweep algorithm for merging upper envelopes sweeps though all of vertices of the red and blue upper envelopes, from left to right. The most recently encountered red and blue points are maintained as the line sweeps. When a point is encountered, the algorithm checks if the point is above or below the segment following the last encountered point of the opposite color. If it is above, that point is added to the merged upper envelope. If it of a different color than the last added point, the red and blue envelopes have crossed, so the intersection point is also added to the merged upper envelope. 3  The sequence of edges and vertices resulting from this algorithm is only dependent on the ordering of points, and the results of the line-point comparisons. Thus, the result can be certified with the following certificates:   x-certificates ( <_x>) are used to certify the order the vertices of the red and blue envelopes. They are the certificates for a kinetic sorted list on the set of vertices. Since each point involves 2 lines, and the certificate involves 2 points, each certificate involves 4 lines. _x  y-certificates ( <_y>) are used to certify that a vertex is above or below an edge. The certificates appear for all comparisons that would occur during the algorithm. _y   As long as all of these certificates hold, the merge steps will be executed identically, so the resulting upper envelope will be the same. A kinetic data structure for upper envelopes can be created by using these certificates to certify the static upper envelope algorithm. However, this scheme is not local, because one line many be involved in many y-certificates if it remains on top or bottom as many points from the other envelope are encountered.  Thus, it is necessary to introduce a s-certificates ( <_s>) which certifies that the slope of a line is greater than or less than the slope of another line. Having the following certificates for all points ab is sufficient to certify the sequence of edges and vertices resulting from a merge, with only O(1) certificates per line: 4 _s       x   [   a  b   ]       x   delimited-[]    a  b      x[ab]         a  b    <  x    a  b    .   n  e  x  t      formulae-sequence    subscript   x     a  b     a  b      n  e  x  t     ab<_{x}ab.next   .     a  b   .   n  e  x  t      formulae-sequence    a  b     n  e  x  t     ab.next   denotes vertex closest to    a  b      a  b    ab   on its right. This certificate is stored for all points    a  b      a  b    ab   which have a different color than the point,     a  b   .   n  e  x  t      formulae-sequence    a  b     n  e  x  t     ab.next   , which follows them.      y  l  i   [   a  b   ]       y  l  i   delimited-[]    a  b      yli[ab]        a  b    <  y    c  e   (   a  b   )        subscript   y     a  b     c  e    a  b      ab<_{y}ce(ab)   or     a  b    >  y    c  e   (   a  b   )        subscript   y     a  b     c  e    a  b      ab>_{y}ce(ab)   . This certificate is stored for all points    a  b      a  b    ab   such that   b   b   b   intersects    c  e   (   a  b   )       c  e    a  b     ce(ab)   .    c  e   (   a  b   )       c  e    a  b     ce(ab)   denotes the contender edge of    a  b      a  b    ab   , the edge from the other envelope that is above or below    a  b      a  b    ab   .      y  r  i   [   a  b   ]       y  r  i   delimited-[]    a  b      yri[ab]        a  b    <  y    c  e   (   a  b   )        subscript   y     a  b     c  e    a  b      ab<_{y}ce(ab)   or     a  b    >  y    c  e   (   a  b   )        subscript   y     a  b     c  e    a  b      ab>_{y}ce(ab)   . This certificate is stored for all points    a  b      a  b    ab   such that   a   a   a   intersects    c  e   (   a  b   )       c  e    a  b     ce(ab)   .      y  t   [   a  b   ]       y  t   delimited-[]    a  b      yt[ab]        c  e   (   a  b   )     <  y    a  b       subscript   y     c  e    a  b      a  b     ce(ab)<_{y}ab   . This certificate is stored for all points    a  b      a  b    ab   for which    a   <  s    c  e   (   a  b   )     <  s   b        subscript   s   a    c  e    a  b       subscript   s     b     a<_{s}ce(ab)<_{s}b   and     c  e   (   a  b   )     <  y    a  b       subscript   y     c  e    a  b      a  b     ce(ab)<_{y}ab   .      s  r  t   [   a  b   ]       s  r  t   delimited-[]    a  b      srt[ab]       a   <  s    c  e   (   a  b   )        subscript   s   a    c  e    a  b      a<_{s}ce(ab)   . This certificate is stored for all points    a  b      a  b    ab   for which    a   <  s    c  e   (   a  b   )     <  s   b        subscript   s   a    c  e    a  b       subscript   s     b     a<_{s}ce(ab)<_{s}b   and     c  e   (   a  b   )     <  y    a  b       subscript   y     c  e    a  b      a  b     ce(ab)<_{y}ab   .      s  r  t   [   a  b   ]       s  r  t   delimited-[]    a  b      srt[ab]        c  e   (   a  b   )     <  s   b      subscript   s     c  e    a  b    b    ce(ab)<_{s}b   . This certificate is stored for all points    a  b      a  b    ab   for which    a   <  s    c  e   (   a  b   )     <  s   b        subscript   s   a    c  e    a  b       subscript   s     b     a<_{s}ce(ab)<_{s}b   and     c  e   (   a  b   )     <  y    a  b       subscript   y     c  e    a  b      a  b     ce(ab)<_{y}ab   .      s  l   [   a  b   ]       s  l   delimited-[]    a  b      sl[ab]       b   <  s    c  e   (   a  b   )        subscript   s   b    c  e    a  b      b<_{s}ce(ab)   . This certificate is stored for all points    a  b      a  b    ab   for which    b   <  s    c  e   (   a  b   )        subscript   s   b    c  e    a  b      b<_{s}ce(ab)   and     a  b    <  y    c  e   (   a  b   )        subscript   y     a  b     c  e    a  b      ab<_{y}ce(ab)   .      s  r   [   a  b   ]       s  r   delimited-[]    a  b      sr[ab]        c  e   (   a  b   )     <  s   a      subscript   s     c  e    a  b    a    ce(ab)<_{s}a   . This certificate is stored for all points    a  b      a  b    ab   for which     c  e   (   a  b   )     <  s   a      subscript   s     c  e    a  b    a    ce(ab)<_{s}a   and     a  b    <  y    c  e   (   a  b   )        subscript   y     a  b     c  e    a  b      ab<_{y}ce(ab)   .   The first certificate,    x   [   a  b   ]       x   delimited-[]    a  b      x[ab]   , certifies the x-ordering of the points in the red and blue envelopes. The second and third certificates,    y  l  i   [   a  b   ]       y  l  i   delimited-[]    a  b      yli[ab]   and    y  r  i   [   a  b   ]       y  r  i   delimited-[]    a  b      yri[ab]   , certify intersections of the red and blue envelopes. The remaining 5 certificates,    y  t   [   a  b   ]       y  t   delimited-[]    a  b      yt[ab]   ,    s  r  t   [   a  b   ]       s  r  t   delimited-[]    a  b      srt[ab]   ,    s  r  t   [   a  b   ]       s  r  t   delimited-[]    a  b      srt[ab]   ,    s  l   [   a  b   ]       s  l   delimited-[]    a  b      sl[ab]   , and    s  r   [   a  b   ]       s  r   delimited-[]    a  b      sr[ab]   place edges that are not in the upper envelopes in the sequence of slopes of the edges that are above it. If the slope is at the start or end of the sequence,    s  l      s  l    sl   or    s  r      s  r    sr   certify this. If it is in the middle of the sequence    s  l  t      s  l  t    slt   , and    s  r  t      s  r  t    srt   certify this, and    y  t      y  t    yt   certifies that the intersection point of the two lines that the edge's slope is in between, is above it. These one or three certificates suffice to prove that all of the edges are above this line. Unlike the previous scheme all lines are only involved in a constant number of certificates. Whenever of these certificates fail, the merged envelope and certificates can be updated in O(1) time.  The kinetic data structure for convex hull is constructed by using these certificates to certify the recursive merge of the upper envelopes. Whenever certificates fail, their merge is updated, and if the envelope resulting from the merge changes, the changes are propagated up through all merges that depend on the result of the merge. 5  Performance  This data structure is responsive , local , compact , and efficient . This is due to the logarithmic depth of the merges used to certify the upper envelope. 6   Responsive: When a certificate fails, it takes O(1) to fix the merge it certifies. If the resulting envelope changes, the change must be propagated up to all merges that depend on the result of the changed merge. There are O(log n ) such mergers, so the update can be performed in O(log n ) time total.  Local: Each line is involved in a most O(log n ) certificates. This is because each line is involved in a constant number of certificates in each merge, and each line is in O(log n ) merges total.  Compactness: The maximum number of certificates used in this data structure is O( n log n ). This is because each merge involves a number of certificates linear to the number of lines merged. Certifying an upper envelope of n lines requires certificates for the merge upper envelope of the two subsets of n /2 lines, and certificates for the merge of the envelopes. Thus the number of certificates, C( n ), required to certify the upper envelope of n lines satisfies the recurrence C( n )=2C( n /2)+O( n ), with C(1)=O(1). By the master theorem the C( n )=O( n log n ).  Efficiency: The maximum number of events processed by this algorithm on algebraic or pseudo-algebraic trajectories is near quadratic,    O   (   n   2  +  ϵ    )       O   superscript  n    2  ϵ      O(n^{2+\epsilon})   for all    ϵ  >  0      ϵ  0    \epsilon>0   .   7 Convex hulls of linearly moving points can change    Ω   (   n  2   )       normal-Ω   superscript  n  2     \Omega(n^{2})   times. 8 Thus this data structure is efficient.  Higher dimensions  Finding an efficient kinetic data structure for maintaining the convex hull of moving points in dimensions higher than 2 is an open problem. 9  Related Problems  Kinetic convex hull can be used to solve the following related problems: 10   Kinetic diameter  Kinetic width  Kinetic minimum box  Kinetic smallest enclosing disk   References  "  Category:Articles created via the Article Wizard  Category:Kinetic data structures  Category:Convex hull algorithms       ↩     ↩  ↩  ↩  ↩     