   M-tree      M-tree   M-trees are tree data structures that are similar to R-trees and B-trees . It is constructed using a metric and relies on the triangle inequality for efficient range and k-NN queries. While M-trees can perform well in many conditions, the tree can also have large overlap and there is no clear strategy on how to best avoid overlap. In addition, it can only be used for distance functions that satisfy the triangle inequality, while many advanced dissimilarity functions used in information retrieval do not satisfy this. 1  Overview  (Figure)  2D M-Tree visualized using ELKI . Due to the axis scales, the spheres appear ellipsoidal. Every blue sphere (leaf) is contained in a red sphere (directory nodes). Leaves overlap, but not too much.   As in any Tree-based data structure, the M-Tree is composed of Nodes and Leaves. In each node there is a data object that identifies it uniquely and a pointer to a sub-tree where its children reside. Every leaf has several data objects. For each node there is a radius   r   r   r   that defines a Ball in the desired metric space. Thus, every node   n   n   n   and leaf   l   l   l   residing in a particular node   N   N   N   is at most distance   r   r   r   from   N   N   N   , and every node   n   n   n   and leaf   l   l   l   with node parent   N   N   N   keep the distance from it.  M-Tree construction  Components  An M-Tree has these components and sub-components:   Non-leaf nodes  A set of routing objects N RO .  Pointer to Node's parent object O p .   Leaf nodes  A set of objects N O .  Pointer to Node's parent object O p .   Routing Object  (Feature value of) routing object O r .  Covering radius r(O r ).  Pointer to covering tree T(O r ).  Distance of O r from its parent object d(O r ,P(O r ))   Object  (Feature value of the) object O j .  Object identifier oid(O j ).  Distance of O j from its parent object d(O j ,P(O j ))    Insert  The main idea is first to find a leaf node   N   N   N   where the new object   O   O   O   belongs. If   N   N   N   is not full then just attach it to   N   N   N   . If   N   N   N   is full then invoke a method to split   N   N   N   . The algorithm is as follows:  Input: Node    N   N   N    of M-Tree     M  T      M  T    MT    , Entry     O  n     subscript  O  n    O_{n}     Output: A new instance of     M  T      M  T    MT    containing all entries in original     M  T      M  T    MT    plus     O  n     subscript  O  n    O_{n}         N  e     subscript  N  e    N_{e}   ←   N   N   N   's routing objects or objects   if     N   N   N    is not a leaf then  {  /*Look for entries that the new object fits into*/  let     N   i  n      subscript  N    i  n     N_{in}    be routing objects from     N  e     subscript  N  e    N_{e}    's set of routing objects     N   R  O      subscript  N    R  O     N_{RO}    such that      d   (   O  r   ,   O  n   )    ≤   r   (   O  r   )          d    subscript  O  r    subscript  O  n       r   subscript  O  r      d(O_{r},O_{n})<=r(O_{r})      if      N   i  n      subscript  N    i  n     N_{in}    is not empty then  {  /*If there are one or more entry, then look for an entry such that is closer to the new object*/        O  r  *   =     min    O  r   ∈   N   i  n      d    (   O  r   ,   O  n   )         superscript   subscript  O  r         subscript      subscript  O  r    subscript  N    i  n      d     subscript  O  r    subscript  O  n       O_{r}^{*}=\min_{O_{r}\in N_{in}}d(O_{r},O_{n})     }   else  {  /*If there are no such entry, then look for an object with minimal distance from */  /*its covering radius's edge to the new object*/        O  r  *   =      min    O  r   ∈   N   i  n      d    (   O  r   ,   O  n   )    -   r   (   O  r   )          superscript   subscript  O  r           subscript      subscript  O  r    subscript  N    i  n      d     subscript  O  r    subscript  O  n       r   subscript  O  r       O_{r}^{*}=\min_{O_{r}\in N_{in}}d(O_{r},O_{n})-r(O_{r})     /*Upgrade the new radii of the entry*/       r   (   O  r  *   )       r   superscript   subscript  O  r       r(O_{r}^{*})    =     d   (   O  r  *   ,   O  n   )       d    superscript   subscript  O  r      subscript  O  n      d(O_{r}^{*},O_{n})     }  /*Continue inserting in the next level*/  return insert(     T   (   O  r  *   )       T   superscript   subscript  O  r       T(O_{r}^{*})    ,     O  n     subscript  O  n    O_{n}    );   else  {  /*If the node has capacity then just insert the new object*/   if     N   N   N    is not full then  {  store(    N   N   N    ,     O  n     subscript  O  n    O_{n}    )   }  /*The node is at full capacity, then it is needed to do a new split in this level*/   else  {  split(    N   N   N    ,     O  n     subscript  O  n    O_{n}    ) }  }  Split  If the split method arrives to the root of the tree, then it choose two routing objects from   N   N   N   , and creates two new nodes containing all the objects in original   N   N   N   , and store them into the new root. If split methods arrives to a node   N   N   N   that is not the root of the tree, the method choose two new routing objects from   N   N   N   , re-arrange every routing object in   N   N   N   in two new nodes    N  1     subscript  N  1    N_{1}   and    N  2     subscript  N  2    N_{2}   , and store these new nodes in the parent node    N  p     subscript  N  p    N_{p}   of original   N   N   N   . The split must be repeated if    N  p     subscript  N  p    N_{p}   has not enough capacity to store    N  2     subscript  N  2    N_{2}   . The algorithm is as follow:  Input: Node    N   N   N    of M-Tree     M  T      M  T    MT    , Entry     O  n     subscript  O  n    O_{n}     Output: A new instance of     M  T      M  T    MT    containing a new partition.  /*The new routing objects are now all those in the node plus the new routing object*/  let be     N  N      N  N    NN    entries of     N  ∪  O      N  O    N\cup O      if     N   N   N    is not the root then  {  /*Get the parent node and the parent routing object*/  let     O  p     subscript  O  p    O_{p}    be the parent routing object of    N   N   N     let     N  p     subscript  N  p    N_{p}    be the parent node of    N   N   N     }  /*This node will contain part of the objects of the node to be split*/  Create a new node     N  ′     superscript  N  normal-′    N^{\prime}     /*Promote two routing objects from the node to be split, to be new routing objects*/  Create new objects     O   p  1      subscript  O    p  1     O_{p1}    and     O   p  2      subscript  O    p  2     O_{p2}    .  Promote(    N   N   N    ,     O   p  1      subscript  O    p  1     O_{p1}    ,     O   p  2      subscript  O    p  2     O_{p2}    )  /*Choose which objects from the node being split will act as new routing objects*/  Partition(    N   N   N    ,     O   p  1      subscript  O    p  1     O_{p1}    ,     O   p  2      subscript  O    p  2     O_{p2}    ,     N  1     subscript  N  1    N_{1}    ,     N  2     subscript  N  2    N_{2}    )  /*Store entries in each new routing object*/  Store     N  1     subscript  N  1    N_{1}    's entries in    N   N   N    and     N  2     subscript  N  2    N_{2}    's entries in     N  ′     superscript  N  normal-′    N^{\prime}      if     N   N   N    is the current root then  {  /*Create a new node and set it as new root and store the new routing objects*/  Create a new root node     N  p     subscript  N  p    N_{p}     Store     O   p  1      subscript  O    p  1     O_{p1}    and     O   p  2      subscript  O    p  2     O_{p2}    in     N  p     subscript  N  p    N_{p}     }   else  {  /*Now use the parent rouing object to store one of the new objects*/  Replace entry     O  p     subscript  O  p    O_{p}    with entry     O   p  1      subscript  O    p  1     O_{p1}    in     N  p     subscript  N  p    N_{p}      if      N  p     subscript  N  p    N_{p}    is no full then  {  /*The second routing object is stored in the parent only if it has free capacity*/  Store     O   p  2      subscript  O    p  2     O_{p2}    in     N  p     subscript  N  p    N_{p}     }   else  {  /*If there is no free capacity then split the level up*/  split(     N  p     subscript  N  p    N_{p}    ,     O   p  2      subscript  O    p  2     O_{p2}    )  }  }  M-Tree Queries  Range Query  A range query is where a minimum similarity/maximum distance value is speciﬁed. For a given query object Q ∈ D and a maximum search distance r(Q), the range query range (Q, r(Q)) selects all the indexed objects Oj such that d(Oj, Q) ≤ r(Q). 2  Algorithm RangeSearch starts from the root node and recursively traverses all the paths which cannot be excluded from leading to qualifying objects.  Input: Node   N   N   N   of M-Tree MT ,   Q   Q   Q   : query object,    r   (  Q  )       r  Q    r(Q)   : search radius  Output: all the DB objects such that     d   (   O  j   ,  Q  )    ≤   r   (  Q  )          d     O  j   Q      r  Q     d(Oj,Q)\leq r(Q)     {   let      O  p     subscript  O  p    O_{p}     be the parent object of node    N   N   N    ;    if     N   N   N     is  not a leaf then {   for  each  entry (     O  r     subscript  O  r    O_{r}    ) in N do {   if       |    d   (   O  p   ,  Q  )    -   d   (   O  r   ,   O  p   )     |   ≤    r   (  Q  )    +   r   (   O  r   )               d    subscript  O  p   Q      d    subscript  O  r    subscript  O  p           r  Q     r   subscript  O  r       |d(O_{p},Q)-d(O_{r},O_{p})|\leq r(Q)+r(O_{r})     then {  Compute     d   (   O  r   ,  Q  )       d    subscript  O  r   Q     d(O_{r},Q)    ;   if       d   (   O  r   ,  Q  )    ≤    r   (  Q  )    +   r   (   O  r   )           d    subscript  O  r   Q        r  Q     r   subscript  O  r       d(O_{r},Q)\leq r(Q)+r(O_{r})     then   RangeSearch (*ptr(     T   (   O  r       fragments  T   fragments  normal-(   subscript  O  r      T(O_{r}    )),    Q   Q   Q    ,     r   (  Q  )       r  Q    r(Q)    );  }  }  }   else {   for  each  entry (     O  j     subscript  O  j    O_{j}    ) in     N   N   N     do {   if       |    d   (   O  p   ,  Q  )    -   d   (   O  j   ,   O  p   )     |   ≤   r   (  Q  )              d    subscript  O  p   Q      d    subscript  O  j    subscript  O  p         r  Q     |d(O_{p},Q)-d(O_{j},O_{p})|\leq r(Q)     then {  Compute     d   (   O  j   ,  Q  )       d    subscript  O  j   Q     d(O_{j},Q)    ;   if      d   (   O  j   ,  Q  )       d    subscript  O  j   Q     d(O_{j},Q)    ≤     r   (  Q  )       r  Q    r(Q)     then  add     o  i  d   (   O  j   )       o  i  d   subscript  O  j     oid(O_{j})    to the result;  }  }  }  }      o  i  d   (   O  j   )       o  i  d   subscript  O  j     oid(O_{j})   is the identiﬁer of the object which resides on a separate data ﬁle.      T   (   O  r   )       T   subscript  O  r     T(O_{r})   is a sub-tree – the covering tree of    O  r     subscript  O  r    O_{r}     k-NN queries  K Nearest Neighbor (k-NN) query takes the cardinality of the input set as an input parameter. For a given query object Q ∈ D and an integer k ≥ 1, the k-NN query NN(Q, k) selects the k indexed objects which have the shortest distance from Q, according to the distance function d. 3   See also   Segment tree  Interval tree - A degenerate R-Tree for 1 dimension (usually time).  Bounding volume hierarchy  Spatial index  GiST   References  "  Category:Trees (data structures)  Category:Database index techniques  Category:Geometric data structures     ↩  ↩      