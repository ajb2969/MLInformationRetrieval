<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="506">Matroid partitioning</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Matroid partitioning</h1>
<hr/>

<p>The <strong>matroid partitioning</strong> problem is a problem arising in the mathematical study of <a href="matroid" title="wikilink">matroids</a> and in the design and analysis of <a href="algorithm" title="wikilink">algorithms</a>, in which the goal is to partition the elements of a matroid into as few independent sets as possible. An example is the problem of computing the <a class="uri" href="arboricity" title="wikilink">arboricity</a> of an <a href="undirected_graph" title="wikilink">undirected graph</a>, the minimum number of <a href="tree_(graph_theory)" title="wikilink">forests</a> needed to cover all of its edges. Matroid partitioning may be solved in <a href="polynomial_time" title="wikilink">polynomial time</a>, given an <a href="matroid_oracle" title="wikilink">independence oracle</a> for the matroid. It may be generalized to show that a <a href="matroid_sum" title="wikilink">matroid sum</a> is itself a matroid, to provide an algorithm for computing <a href="Matroid_rank" title="wikilink">ranks</a> and independent sets in matroid sums, and to compute the largest common independent set in the <a href="matroid_intersection" title="wikilink">intersection</a> of two given matroids.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="example">Example</h2>

<p> The <a class="uri" href="arboricity" title="wikilink">arboricity</a> of an <a href="undirected_graph" title="wikilink">undirected graph</a> is the minimum number of <a href="tree_(graph_theory)" title="wikilink">forests</a> into which its edges can be partitioned, or equivalently (by adding overlapping edges to each forest as necessary) the minimum number of <a href="spanning_tree" title="wikilink">spanning forests</a> whose union is the whole graph. A formula proved by <a href="Crispin_Nash-Williams" title="wikilink">Crispin Nash-Williams</a> characterizes the arboricity exactly: it is the maximum, over all subgraphs 

<math display="inline" id="Matroid_partitioning:0">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 of the given graph 

<math display="inline" id="Matroid_partitioning:1">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, of the quantity 

<math display="inline" id="Matroid_partitioning:2">
 <semantics>
  <mrow>
   <mo>⌈</mo>
   <mfrac>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>H</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>V</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>H</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mfrac>
   <mo>⌉</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ceiling></ceiling>
    <apply>
     <divide></divide>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>E</ci>
       <ci>H</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <ci>V</ci>
        <ci>H</ci>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\lceil\frac{|E(H)|}{|V(H)|-1}\right\rceil
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>The forests of a graph form the independent sets of the associated <a href="graphic_matroid" title="wikilink">graphic matroid</a>, and the quantity 

<math display="inline" id="Matroid_partitioning:3">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>H</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>H</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |V(H)|-1
  </annotation>
 </semantics>
</math>

 appearing in Nash-Williams' formula is the rank of the graphic matroid of 

<math display="inline" id="Matroid_partitioning:4">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

, the maximum size of one of its independent sets. Thus, the problem of determining the arboricity of a graph is exactly the matroid partitioning problem for the graphic matroid. The fact that the 

<math display="inline" id="Matroid_partitioning:5">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>H</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>H</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |E(H)|
  </annotation>
 </semantics>
</math>

 elements of this matroid cannot be partitioned into fewer than 

<math display="inline" id="Matroid_partitioning:6">
 <semantics>
  <mfrac>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>H</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>V</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>H</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>H</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>V</ci>
       <ci>H</ci>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{|E(H)|}{|V(H)|-1}
  </annotation>
 </semantics>
</math>

 independent subsets is then just an application of the <a href="pigeonhole_principle" title="wikilink">pigeonhole principle</a> saying that, if 

<math display="inline" id="Matroid_partitioning:7">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 items are partitioned into sets of size at most 

<math display="inline" id="Matroid_partitioning:8">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

, then at least 

<math display="inline" id="Matroid_partitioning:9">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>/</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x/y
  </annotation>
 </semantics>
</math>

 sets are needed. The harder direction of Nash-Williams' formula, which can be generalized to all matroids, is the proof that a partition of this size always exists.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="formula-for-partition-size">Formula for partition size</h2>

<p>To generalize Nash-Williams' formula, one may replace 

<math display="inline" id="Matroid_partitioning:10">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 by a matroid 

<math display="inline" id="Matroid_partitioning:11">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

, and the subgraph 

<math display="inline" id="Matroid_partitioning:12">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Matroid_partitioning:13">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 with a <a href="matroid_minor" title="wikilink">restriction</a> 

<math display="inline" id="Matroid_partitioning:14">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo stretchy="false">|</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">M</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">S</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M|S
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Matroid_partitioning:15">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 to a subset 

<math display="inline" id="Matroid_partitioning:16">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 of its elements. The number of edges of the subgraph 

<math display="inline" id="Matroid_partitioning:17">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 becomes, in this generalization, the cardinality 

<math display="inline" id="Matroid_partitioning:18">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>S</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |S|
  </annotation>
 </semantics>
</math>

 of the selected subset, and the formula 

<math display="inline" id="Matroid_partitioning:19">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>H</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>H</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |V(H)|-1
  </annotation>
 </semantics>
</math>

 for the maximum size of a forest in 

<math display="inline" id="Matroid_partitioning:20">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 becomes the rank 

<math display="inline" id="Matroid_partitioning:21">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(S)
  </annotation>
 </semantics>
</math>

. Thus, the minimum number of independent sets in a partition of the given matroid 

<math display="inline" id="Matroid_partitioning:22">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 should be given by the formula</p>

<p>

<math display="block" id="Matroid_partitioning:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>k</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mi>max</mi>
      <mi>S</mi>
     </munder>
     <mrow>
      <mo>⌈</mo>
      <mfrac>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>S</mi>
        <mo stretchy="false">|</mo>
       </mrow>
       <mrow>
        <mi>r</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>S</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
      <mo>⌉</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <ci>S</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <abs></abs>
       <ci>S</ci>
      </apply>
      <apply>
       <times></times>
       <ci>r</ci>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(M)=\max_{S}\left\lceil\frac{|S|}{r(S)}\right\rceil,
  </annotation>
 </semantics>
</math>

 which is valid for all matroids and was given an algorithmic proof by .<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="algorithms">Algorithms</h2>

<p>The first algorithm for matroid partitioning was given by .<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> It is an incremental augmenting-path algorithm that considers the elements of the matroid one by one, in an arbitrary order, maintaining at each step of the algorithm an optimal partition for the elements that have been considered so far. At each step, when considering an element 

<math display="inline" id="Matroid_partitioning:24">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 that has not yet been placed into a partition, the algorithm constructs a <a href="directed_graph" title="wikilink">directed graph</a> that has as its nodes the elements that have already been partitioned, the new element 

<math display="inline" id="Matroid_partitioning:25">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, and a special element 

<math display="inline" id="Matroid_partitioning:26">
 <semantics>
  <msub>
   <mo>⊥</mo>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">bottom</csymbol>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot_{i}
  </annotation>
 </semantics>
</math>

 for each of the 

<math display="inline" id="Matroid_partitioning:27">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 independent sets in the current partition. It then forms a directed graph 

<math display="inline" id="Matroid_partitioning:28">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{x}
  </annotation>
 </semantics>
</math>

 on this node set, with a directed arc 

<math display="inline" id="Matroid_partitioning:29">
 <semantics>
  <mrow>
   <msub>
    <mo>⊥</mo>
    <mi>i</mi>
   </msub>
   <mo>→</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">bottom</csymbol>
     <ci>i</ci>
    </apply>
    <ci>normal-→</ci>
    <csymbol cd="unknown">y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot_{i}\rightarrow y
  </annotation>
 </semantics>
</math>

 for each matroid element 

<math display="inline" id="Matroid_partitioning:30">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 that can be added to partition set 

<math display="inline" id="Matroid_partitioning:31">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 without causing it to become dependent, and with a directed arc 

<math display="inline" id="Matroid_partitioning:32">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>→</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>z</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z\rightarrow y
  </annotation>
 </semantics>
</math>

 for each pair of matroid elements 

<math display="inline" id="Matroid_partitioning:33">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>y</mi>
   <mo>,</mo>
   <mi>z</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>y</ci>
    <ci>z</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (y,z)
  </annotation>
 </semantics>
</math>

 such that removing 

<math display="inline" id="Matroid_partitioning:34">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 from its partition and replacing it with 

<math display="inline" id="Matroid_partitioning:35">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 forms another independent set.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>If this graph contains a <a href="directed_path" title="wikilink">directed path</a> from an element 

<math display="inline" id="Matroid_partitioning:36">
 <semantics>
  <msub>
   <mo>⊥</mo>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">bottom</csymbol>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot_{i}
  </annotation>
 </semantics>
</math>

 to the newly considered element 

<math display="inline" id="Matroid_partitioning:37">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, then the shortest such path (or more generally any path that does not have any shortcutting edges) describes a sequence of changes that can be made simultaneously to the partition sets in order to form a new partition, with the same number of sets, that also includes 

<math display="inline" id="Matroid_partitioning:38">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. In this case, the algorithm performs these changes and continues. If, on the other hand, no such path exists, then let 

<math display="inline" id="Matroid_partitioning:39">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 consist of the matroid elements from which 

<math display="inline" id="Matroid_partitioning:40">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is <a href="reachability" title="wikilink">reachable</a> in 

<math display="inline" id="Matroid_partitioning:41">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

. Each set in the current partition must be a maximal independent set in 

<math display="inline" id="Matroid_partitioning:42">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo stretchy="false">|</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">M</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">S</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M|S
  </annotation>
 </semantics>
</math>

, for if some element 

<math display="inline" id="Matroid_partitioning:43">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Matroid_partitioning:44">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 could be added to partition set 

<math display="inline" id="Matroid_partitioning:45">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 in the restriction, then either there would exist an arc 

<math display="inline" id="Matroid_partitioning:46">
 <semantics>
  <mrow>
   <msub>
    <mo>⊥</mo>
    <mi>i</mi>
   </msub>
   <mo>→</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">bottom</csymbol>
     <ci>i</ci>
    </apply>
    <ci>normal-→</ci>
    <csymbol cd="unknown">y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot_{i}\rightarrow y
  </annotation>
 </semantics>
</math>

 (if partition set 

<math display="inline" id="Matroid_partitioning:47">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 is non-maximal in the full matroid 

<math display="inline" id="Matroid_partitioning:48">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

) or an arc 

<math display="inline" id="Matroid_partitioning:49">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>→</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>z</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z\rightarrow y
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Matroid_partitioning:50">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>∉</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>z</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z\notin S
  </annotation>
 </semantics>
</math>

 (if the partition set is non-maximal in 

<math display="inline" id="Matroid_partitioning:51">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 but maximal in the full matroid). In either case the existence of this arc contradicts the assumed construction of the set 

<math display="inline" id="Matroid_partitioning:52">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, and the contradiction proves that each partition set is maximal. Thus, by the easy direction of the matroid partitioning formula, the number of sets needed to partition 

<math display="inline" id="Matroid_partitioning:53">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is at least</p>

<p>

<math display="block" id="Matroid_partitioning:54">
 <semantics>
  <mrow>
   <mrow>
    <mo>⌈</mo>
    <mfrac>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>S</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mrow>
      <mi>r</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>S</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
    <mo>⌉</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>⌈</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mi>k</mi>
       <mi>r</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>S</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mrow>
      <mi>r</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>S</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
    <mo>⌉</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ceiling></ceiling>
      <apply>
       <divide></divide>
       <apply>
        <abs></abs>
        <ci>S</ci>
       </apply>
       <apply>
        <times></times>
        <ci>r</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <ceiling></ceiling>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>k</ci>
         <ci>r</ci>
         <ci>S</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <times></times>
        <ci>r</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\lceil\frac{|S|}{r(S)}\right\rceil=\left\lceil\frac{kr(S)+1}{r(S)}\right%
\rceil=k+1
  </annotation>
 </semantics>
</math>

, so in this case the algorithm may find an optimal partition by placing 

<math display="inline" id="Matroid_partitioning:55">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 into its own new independent set and leaving the other independent sets unchanged.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>The overall algorithm, then, considers each element 

<math display="inline" id="Matroid_partitioning:56">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 of the given matroid in turn, constructs the graph 

<math display="inline" id="Matroid_partitioning:57">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{x}
  </annotation>
 </semantics>
</math>

, tests which nodes can reach 

<math display="inline" id="Matroid_partitioning:58">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, and uses this information to update the current partition so that it includes 

<math display="inline" id="Matroid_partitioning:59">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. At each step, the partition of the elements considered so far is optimal, so when the algorithm terminates it will have found an optimal partition for the whole matroid. Proving that this algorithm is correct requires showing that a shorcut-free path in the auxiliary graph always describes a sequence of operations that, when performed simultaneously, correctly preserves the independence of the sets in the partition; a proof of this fact was given by Edmonds. Because the algorithm only increases the number of sets in the partition when the matroid partitioning formula shows that a larger number is needed, the correctness of this algorithm also shows the correctness of the formula.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>Although this algorithm depends only on the existence of an <a href="matroid_oracle" title="wikilink">independence oracle</a> for its correctness, faster algorithms can be found in many cases by taking advantage of the more specialized structure of specific types of matroids (such as <a href="graphic_matroid" title="wikilink">graphic matroids</a>) from which a particular partitioning problem has been defined.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h2 id="related-problems">Related problems</h2>

<p>A <a href="matroid_sum" title="wikilink">matroid sum</a> 

<math display="inline" id="Matroid_partitioning:60">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mi>i</mi>
   </msub>
   <msub>
    <mi>M</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i}M_{i}
  </annotation>
 </semantics>
</math>

 (where each 

<math display="inline" id="Matroid_partitioning:61">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{i}
  </annotation>
 </semantics>
</math>

 is a matroid) is itself a matroid, having as its elements the union of the elements of the summands. A set is independent in the sum if it can be partitioned into sets that are independent within each summand. The matroid partitioning algorithm generalizes to the problem of testing whether a set is independent in a matroid sum, and its correctness can be used to prove that a matroid sum is necessarily a matroid.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>The <a href="matroid_intersection" title="wikilink">matroid intersection</a> problem of finding the largest set that is independent in two matroids 

<math display="inline" id="Matroid_partitioning:62">
 <semantics>
  <msub>
   <mi>M</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Matroid_partitioning:63">
 <semantics>
  <msub>
   <mi>M</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{2}
  </annotation>
 </semantics>
</math>

 may be solved by turning it into an equivalent matroid sum problem: if 

<math display="inline" id="Matroid_partitioning:64">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is a basis of the sum 

<math display="inline" id="Matroid_partitioning:65">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mn>1</mn>
   </msub>
   <mo>+</mo>
   <msubsup>
    <mi>M</mi>
    <mn>2</mn>
    <mo>*</mo>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">2</cn>
     </apply>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{1}+M_{2}^{*}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Matroid_partitioning:66">
 <semantics>
  <msubsup>
   <mi>M</mi>
   <mn>2</mn>
   <mo>*</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">2</cn>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{2}^{*}
  </annotation>
 </semantics>
</math>

 is the dual of 

<math display="inline" id="Matroid_partitioning:67">
 <semantics>
  <msub>
   <mi>M</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{2}
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Matroid_partitioning:68">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 must have full rank in 

<math display="inline" id="Matroid_partitioning:69">
 <semantics>
  <msubsup>
   <mi>M</mi>
   <mn>2</mn>
   <mo>*</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">2</cn>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{2}^{*}
  </annotation>
 </semantics>
</math>

 and removing a maximal independent set of 

<math display="inline" id="Matroid_partitioning:70">
 <semantics>
  <msubsup>
   <mi>M</mi>
   <mn>2</mn>
   <mo>*</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">2</cn>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{2}^{*}
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Matroid_partitioning:71">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 leaves a maximum intersection.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>Matroid partitioning is a form of <a href="set_cover" title="wikilink">set cover</a> problem, and the corresponding <a href="set_packing" title="wikilink">set packing</a> problem (find a maximum number of disjoint spanning sets within a given matroid) is also of interest. It can be solved by algorithms similar to those for matroid partitioning.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> The fractional set packing and set covering problems associated with a matroid (that is, assign a weight to each independent set in such a way that for every element the total weight of the sets containing it is at most one or at least one, maximizing or minimizing the total weight of all the sets, respectively) can also be solved in polynomial time using matroid partitioning methods.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>

<p>As well as its use in calculating the arboricity of a graph, matroid partitioning can be used with other matroids to find a subgraph of a given graph whose average <a href="degree_(graph_theory)" title="wikilink">degree</a> is maximum, and to find the edge toughness of a graph (a variant of <a href="graph_toughness" title="wikilink">graph toughness</a> involving the deletion of edges in place of vertices).<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Matroid_theory" title="wikilink">Category:Matroid theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">.<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5">.<a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13">.<a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16">.<a href="#fnref16">↩</a></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
</ol>
</section>
</body>
</html>
