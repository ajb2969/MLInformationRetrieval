<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1992">Quantum algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Quantum algorithm</h1>
<hr/>

<p>In <a href="quantum_computing" title="wikilink">quantum computing</a>, a <strong>quantum algorithm</strong> is an <a class="uri" href="algorithm" title="wikilink">algorithm</a> which runs on a realistic model of <a href="quantum_computation" title="wikilink">quantum computation</a>, the most commonly used model being the <a href="quantum_circuit" title="wikilink">quantum circuit</a> model of computation.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> A classical (or non-quantum) algorithm is a finite sequence of instructions, or a step-by-step procedure for solving a problem, where each step or instruction can be performed on a classical <a class="uri" href="computer" title="wikilink">computer</a>. Similarly, a quantum algorithm is a step-by-step procedure, where each of the steps can be performed on a <a href="quantum_computer" title="wikilink">quantum computer</a>. Although all classical algorithms can also be performed on a quantum computer, the term quantum algorithm is usually used for those algorithms which seem inherently quantum, or use some essential feature of quantum computation such as <a href="quantum_superposition" title="wikilink">quantum superposition</a> or <a href="quantum_entanglement" title="wikilink">quantum entanglement</a>.</p>

<p>All problems which can be solved on a quantum computer can be solved on a classical computer. In particular, problems which are <a href="Undecidable_problem" title="wikilink">undecidable</a> using classical computers remain undecidable using quantum computers. What makes quantum algorithms interesting is that they might be able to solve some problems faster than classical algorithms.</p>

<p>The most well known algorithms are <a href="Shor's_algorithm" title="wikilink">Shor's algorithm</a> for factoring, and <a href="Grover's_algorithm" title="wikilink">Grover's algorithm</a> for searching an unstructured database or an unordered list. Shor's algorithms runs exponentially faster than the best known classical algorithm for factoring, the <a href="general_number_field_sieve" title="wikilink">general number field sieve</a>. Grover's algorithm runs quadratically faster than the best possible classical algorithm for the same task.</p>
<h2 id="overview">Overview</h2>

<p>Quantum algorithms are usually described, in the commonly used circuit model of quantum computation, by a <a href="quantum_circuit" title="wikilink">quantum circuit</a> which acts on some input <a href="qubit" title="wikilink">qubits</a> and terminates with a <a class="uri" href="measurement" title="wikilink">measurement</a>. A quantum circuit consists of simple <a href="quantum_gate" title="wikilink">quantum gates</a> which act on at most a fixed number of qubits, usually 2 or 3. Quantum algorithms may also be stated in other models of quantum computation, such as the <a href="Hamiltonian_oracle_model" title="wikilink">Hamiltonian oracle model</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Quantum algorithms can be categorized by the main techniques used by the algorithm. Some commonly used techniques/ideas in quantum algorithms include <a href="phase_kick-back" title="wikilink">phase kick-back</a>, <a href="quantum_phase_estimation_algorithm" title="wikilink">phase estimation</a>, the <a href="quantum_Fourier_transform" title="wikilink">quantum Fourier transform</a>, <a href="quantum_walk" title="wikilink">quantum walks</a>, <a href="amplitude_amplification" title="wikilink">amplitude amplification</a> and <a href="topological_quantum_field_theory" title="wikilink">topological quantum field theory</a>. Quantum algorithms may also be grouped by the type of problem solved, for instance see the survey on quantum algorithms for algebraic problems.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="algorithms-based-on-the-quantum-fourier-transform">Algorithms based on the quantum Fourier transform</h2>

<p>The <a href="quantum_Fourier_transform" title="wikilink">quantum Fourier transform</a> is the quantum analogue of the <a href="discrete_Fourier_transform" title="wikilink">discrete Fourier transform</a>, and is used in several quantum algorithms. The <a href="Hadamard_transform" title="wikilink">Hadamard transform</a> is also an example of a quantum Fourier transform over an n-dimensional vector space over the field <strong>F</strong><sub>2</sub>. The quantum Fourier transform can be efficiently implemented on a quantum computer using only a polynomial number of <a href="quantum_gate" title="wikilink">quantum gates</a>.</p>
<h3 id="deutschjozsa-algorithm">Deutsch–Jozsa algorithm</h3>

<p>The Deutsch–Jozsa algorithm solves a <a class="uri" href="black-box" title="wikilink">black-box</a> problem which probably requires exponentially many queries to the black box for any deterministic classical computer, but can be done with exactly 1 query by a quantum computer. If we allow both bounded-error quantum and classical algorithms, then there is no speedup since a classical probabilistic algorithm can solve the problem with a constant number of queries with small probability of error. The algorithm determines whether a function <em>f</em> is either constant (0 on all inputs or 1 on all inputs) or balanced (returns 1 for half of the input domain and 0 for the other half).</p>
<h3 id="simons-algorithm">Simon's algorithm</h3>

<p>Simon's algorithm solves a black-box problem exponentially faster than any classical algorithm, including bounded-error probabilistic algorithms. This algorithm, which achieves an exponential speedup over all classical algorithms that we consider efficient, was the motivation for Shor's factoring algorithm.</p>
<h3 id="quantum-phase-estimation-algorithm">Quantum phase estimation algorithm</h3>

<p>The <a href="quantum_phase_estimation_algorithm" title="wikilink">quantum phase estimation algorithm</a> is used to determine the eigenphase of an eigenvector of a unitary gate given a quantum state proportional to the eigenvector and access to the gate. The algorithm is frequently used as a subroutine in other algorithms.</p>
<h3 id="shors-algorithm">Shor's algorithm</h3>

<p>Shor's algorithm solves the <a href="discrete_logarithm" title="wikilink">discrete logarithm</a> problem and the <a href="integer_factorization" title="wikilink">integer factorization</a> problem in polynomial time,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> whereas the best known classical algorithms take super-polynomial time. These problems are not known to be in <a href="P_(complexity)" title="wikilink">P</a> or <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>. It is also one of the few quantum algorithms that solves a non–black-box problem in polynomial time where the best-known classical algorithms run in super-polynomial time.</p>
<h3 id="hidden-subgroup-problem">Hidden subgroup problem</h3>

<p>The <a href="Abelian_group" title="wikilink">abelian</a> <a href="hidden_subgroup_problem" title="wikilink">hidden subgroup problem</a> is a generalization of many problems that can be solved by a quantum computer, such as Simon's problem, solving <a href="Pell's_equation" title="wikilink">Pell's equation</a>, testing the <a href="principal_ideal" title="wikilink">principal ideal</a> of a <a href="ring_(mathematics)" title="wikilink">ring</a> R and <a href="integer_factorization" title="wikilink">factoring</a>. There are efficient quantum algorithms known for the Abelian hidden subgroup problem.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The more general hidden subgroup problem, where the group isn't necessarily abelian, is a generalization of the previously mentioned problems and <a href="graph_isomorphism" title="wikilink">graph isomorphism</a> and certain <a href="lattice_problems" title="wikilink">lattice problems</a>. Efficient quantum algorithms are known for certain non-abelian groups. However, no efficient algorithms are known for the <a href="symmetric_group" title="wikilink">symmetric group</a>, which would give an efficient algorithm for graph isomorphism<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> and the <a href="dihedral_group" title="wikilink">dihedral group</a>, which would solve certain lattice problems.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h3 id="boson-sampling-problem">Boson sampling problem</h3>

<p>The Boson Sampling Problem in an experimental configuration assumes<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> an input of <a href="boson" title="wikilink">bosons</a> (ex. photons of light) of moderate number getting randomly scattered into a large number of output modes constrained by a defined <a class="uri" href="Unitarity" title="wikilink">Unitarity</a>. The problem is then to produce a fair sample of the <a href="probability_distribution" title="wikilink">probability distribution</a> of the output which is dependent on the input arrangement of bosons and the Unitarity.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Solving this problem with a classical computer algorithm requires computing the permanent of the unitary transform matrix, which may be either impossible or take a prohibitively long time. In 2014 it was proposed<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> that existing technology and standard probabilistic methods of generating single photon states could be used as input into a suitable quantum computable <a href="Linear_optical_quantum_computing" title="wikilink">linear optical network</a> and that sampling of the output probability distribution would be demonstrably superior using quantum algorithms. In 2015, investigation predicted<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> the sampling problem had similar complexity for inputs other than <a href="Fock_state" title="wikilink">Fock state</a> photons and identified a transition in computational complexity from classically simulatable to just as hard as the Boson Sampling Problem, dependent on the size of coherent amplitude inputs.</p>
<h3 id="estimating-gauss-sums">Estimating Gauss sums</h3>

<p>A <a href="Gauss_sum" title="wikilink">Gauss sum</a> is a type of <a href="exponential_sum" title="wikilink">exponential sum</a>. The best known classical algorithm for estimating these sums takes exponential time. Since the discrete logarithm problem reduces to Gauss sum estimation, an efficient classical algorithm for estimating Gauss sums would imply an efficient classical algorithm for computing discrete logarithms, which is considered unlikely. However, quantum computers can estimate Gauss sums to polynomial precision in polynomial time.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h3 id="fourier-fishing-and-fourier-checking">Fourier fishing and Fourier checking</h3>

<p>We have an <a href="Oracle_machine" title="wikilink">oracle</a> consisting of n random Boolean functions mapping n-bit strings to a Boolean value. We are required to find n n-bit strings z<sub>1</sub>,..., z<sub>n</sub> such that for the Hadamard-Fourier transform, at least 3/4 of the strings satisfy</p>

<p>

<math display="block" id="Quantum_algorithm:0">
 <semantics>
  <mrow>
   <mrow>
    <mo>|</mo>
    <mrow>
     <mover accent="true">
      <mi>f</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mrow>
      <mo>(</mo>
      <msub>
       <mi>z</mi>
       <mi>i</mi>
      </msub>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>|</mo>
   </mrow>
   <mo>⩾</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <apply>
       <ci>normal-~</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left|\tilde{f}\left(z_{i}\right)\right|\geqslant 1
  </annotation>
 </semantics>
</math>

 and at least 1/4 satisfies</p>

<p>

<math display="block" id="Quantum_algorithm:1">
 <semantics>
  <mrow>
   <mrow>
    <mo>|</mo>
    <mrow>
     <mover accent="true">
      <mi>f</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mrow>
      <mo>(</mo>
      <msub>
       <mi>z</mi>
       <mi>i</mi>
      </msub>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>|</mo>
   </mrow>
   <mo>⩾</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <apply>
       <ci>normal-~</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left|\tilde{f}\left(z_{i}\right)\right|\geqslant 2
  </annotation>
 </semantics>
</math>

.</p>

<p>This can be done in <a class="uri" href="BQP" title="wikilink">BQP</a>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="algorithms-based-on-amplitude-amplification">Algorithms based on amplitude amplification</h2>

<p><a href="Amplitude_amplification" title="wikilink">Amplitude amplification</a> is a technique that allows the amplification of a chosen subspace of a quantum state. Applications of amplitude amplification usually lead to quadratic speedups over the corresponding classical algorithms. It can be considered to be a generalization of Grover's algorithm.</p>
<h3 id="grovers-algorithm">Grover's algorithm</h3>

<p>Grover's algorithm searches an unstructured database (or an unordered list) with N entries, for a marked entry, using only 

<math display="inline" id="Quantum_algorithm:2">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msqrt>
     <mi>N</mi>
    </msqrt>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <root></root>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\sqrt{N})
  </annotation>
 </semantics>
</math>

 queries instead of the Ω(<em>N</em>) queries required classically.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> Classically, Ω(<em>N</em>) queries are required, even if we allow bounded-error probabilistic algorithms.</p>
<h3 id="quantum-counting">Quantum counting</h3>

<p>Quantum counting solves a generalization of the search problem. It solves the problem of counting the number of marked entries in an unordered list, instead of just detecting if one exists. Specifically, it counts the number of marked entries in an 

<math display="inline" id="Quantum_algorithm:3">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

-element list, with error 

<math display="inline" id="Quantum_algorithm:4">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 making only 

<math display="inline" id="Quantum_algorithm:5">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>ϵ</mi>
     </mfrac>
     <msqrt>
      <mfrac>
       <mi>N</mi>
       <mi>k</mi>
      </mfrac>
     </msqrt>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>ϵ</ci>
     </apply>
     <apply>
      <root></root>
      <apply>
       <divide></divide>
       <ci>N</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta\left(\frac{1}{\epsilon}\sqrt{\frac{N}{k}}\right)
  </annotation>
 </semantics>
</math>

 queries, where 

<math display="inline" id="Quantum_algorithm:6">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is the number of marked elements in the list.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> More precisely, the algorithm outputs an estimate 

<math display="inline" id="Quantum_algorithm:7">
 <semantics>
  <msup>
   <mi>k</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{\prime}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Quantum_algorithm:8">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, the number of marked entries, with the following accuracy

<math display="block" id="Quantum_algorithm:9">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <msup>
      <mi>k</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>ϵ</mi>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>k</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>ϵ</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |k-k^{\prime}|\leq\epsilon k
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="algorithms-based-on-quantum-walks">Algorithms based on quantum walks</h2>

<p>A quantum walk is the quantum analogue of a classical <a href="random_walk" title="wikilink">random walk</a>, which can be described by a <a href="probability_distribution" title="wikilink">probability distribution</a> over some states. A quantum walk can be described by a <a href="quantum_superposition" title="wikilink">quantum superposition</a> over states. Quantum walks are known to give exponential speedups for some black-box problems.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> They also provide polynomial speedups for many problems. A framework for the creation quantum walk algorithms exists and is quite a versatile tool.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h3 id="element-distinctness-problem">Element distinctness problem</h3>

<p>The element distinctness problem is the problem of determining whether all the elements of a list are distinct. Classically, Ω(<em>N</em>) queries are required for a list of size <em>N</em>, since this problem is harder than the search problem which requires Ω(<em>N</em>) queries. However, it can be solved in 

<math display="inline" id="Quantum_algorithm:10">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>N</mi>
     <mrow>
      <mn>2</mn>
      <mo>/</mo>
      <mn>3</mn>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>N</ci>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(N^{2/3})
  </annotation>
 </semantics>
</math>

 queries on a quantum computer. The optimal algorithm is by <a href="Andris_Ambainis" title="wikilink">Andris Ambainis</a>.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> <a href="Yaoyun_Shi" title="wikilink">Yaoyun Shi</a> first proved a tight lower bound when the size of the range is sufficiently large.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> Ambainis<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> and Kutin<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> independently (and via different proofs) extended his work to obtain the lower bound for all functions.</p>
<h3 id="triangle-finding-problem">Triangle-finding problem</h3>

<p>The triangle-finding problem is the problem of determining whether a given graph contains a triangle (a <a href="clique_(graph_theory)" title="wikilink">clique</a> of size 3). The best-known lower bound for quantum algorithms is Ω(<em>N</em>), but the best algorithm known requires O(<em>N</em><sup>1.297</sup>) queries,<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> an improvement over the previous best O(<em>N</em><sup>1.3</sup>) queries.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a><a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>
<h3 id="formula-evaluation">Formula evaluation</h3>

<p>A formula is a tree with a gate at each internal node and an input bit at each leaf node. The problem is to evaluate the formula, which is the output of the root node, given oracle access to the input.</p>

<p>A well studied formula is the balanced binary tree with only NAND gates.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> This type of formula requires Θ(<em>N</em><sup>c</sup>) queries using randomness,<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> where 

<math display="inline" id="Quantum_algorithm:11">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <msqrt>
        <mn>33</mn>
       </msqrt>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mn>4</mn>
   </mrow>
   <mo>≈</mo>
   <mn>0.754</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>c</ci>
     <apply>
      <divide></divide>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <apply>
         <root></root>
         <cn type="integer">33</cn>
        </apply>
       </apply>
      </apply>
      <cn type="integer">4</cn>
     </apply>
    </apply>
    <apply>
     <approx></approx>
     <share href="#.cmml">
     </share>
     <cn type="float">0.754</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=\log_{2}(1+\sqrt{33})/4\approx 0.754
  </annotation>
 </semantics>
</math>

. With a quantum algorithm however, it can be solved in Θ(<em>N</em><sup>0.5</sup>) queries. No better quantum algorithm for this case was known until one was found for the unconventional Hamiltonian oracle model.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> The same result for the standard setting soon followed.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>

<p>Fast quantum algorithms for more complicated formulas are also known.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></p>
<h3 id="group-commutativity">Group commutativity</h3>

<p>The problem is to determine if a <a href="black_box_group" title="wikilink">black box group</a>, given by <em>k</em> generators, is <a href="Commutativity" title="wikilink">commutative</a>. A black box group is a group with an oracle function, which must be used to perform the group operations (multiplication, inversion, and comparison with identity). We are interested in the query complexity, which is the number of oracle calls needed to solve the problem. The deterministic and randomized query complexities are 

<math display="inline" id="Quantum_algorithm:12">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>k</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(k^{2})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantum_algorithm:13">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(k)
  </annotation>
 </semantics>
</math>

 respectively.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> A quantum algorithm requires 

<math display="inline" id="Quantum_algorithm:14">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>k</mi>
     <mrow>
      <mn>2</mn>
      <mo>/</mo>
      <mn>3</mn>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(k^{2/3})
  </annotation>
 </semantics>
</math>

 queries but the best known algorithm uses 

<math display="inline" id="Quantum_algorithm:15">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>k</mi>
      <mrow>
       <mn>2</mn>
       <mo>/</mo>
       <mn>3</mn>
      </mrow>
     </msup>
     <mrow>
      <mi>log</mi>
      <mi>k</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>k</ci>
      <apply>
       <divide></divide>
       <cn type="integer">2</cn>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <apply>
      <log></log>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(k^{2/3}\log k)
  </annotation>
 </semantics>
</math>

 queries.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></p>
<h2 id="bqp-complete-problems">BQP-complete problems</h2>
<h3 id="computing-knot-invariants">Computing knot invariants</h3>

<p>Witten had shown that the <a class="uri" href="Chern-Simons" title="wikilink">Chern-Simons</a> <a href="topological_quantum_field_theory" title="wikilink">topological quantum field theory</a> (TQFT) can be solved in terms of <a href="Jones_polynomial" title="wikilink">Jones polynomials</a>. A quantum computer can simulate a TQFT, and thereby approximate the Jones polynomial,<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> which as far as we know, is hard to compute classically in the worst-case scenario.</p>
<h3 id="quantum-simulation">Quantum simulation</h3>

<p>The idea that quantum computers might be more powerful than classical computers originated in Richard Feynman's observation that classical computers seem to require exponential time to simulate many-particle quantum systems.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> Since then, the idea that quantum computers can simulate quantum physical processes exponentially faster than classical computers has been greatly fleshed out and elaborated. Efficient (that is, polynomial-time) quantum algorithms have been developed for simulating both Bosonic and Fermionic systems<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> and in particular, the simulation of chemical reactions beyond the capabilities of current classical supercomputers requires only a few hundred qubits.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> Quantum computers can also efficiently simulate topological quantum field theories.<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> In addition to its intrinsic interest, this result has led to efficient quantum algorithms for estimating <a href="Quantum_invariant" title="wikilink">quantum topological invariants</a> such as <a href="Jones_polynomial" title="wikilink">Jones</a><a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> and <a class="uri" href="HOMFLY" title="wikilink">HOMFLY</a> <a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> polynomials, and the <a href="Turaev-Viro_invariant" title="wikilink">Turaev-Viro invariant</a> of three-dimensional manifolds.<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Quantum_sort" title="wikilink">Quantum sort</a></li>
<li><a href="Primality_test" title="wikilink">Primality test</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li>The <a href="http://math.nist.gov/quantum/zoo/">Quantum Algorithm Zoo</a>: A comprehensive list of quantum algorithms that provide a speedup over the fastest known classical algorithms.</li>
</ul>
<h3 id="surveys">Surveys</h3>
<ul>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Quantum_computing" title="wikilink">Category:Quantum computing</a> <a href="Category:Quantum_information_science" title="wikilink">Category:Quantum information science</a> <a href="Category:Theoretical_computer_science" title="wikilink">Category:Theoretical computer science</a> <a href="Category:Quantum_algorithms" title="wikilink"> </a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33"><a href="#fnref33">↩</a></li>
<li id="fn34"><a href="#fnref34">↩</a></li>
<li id="fn35"><a href="#fnref35">↩</a></li>
<li id="fn36"><a href="#fnref36">↩</a></li>
<li id="fn37"><a href="#fnref37">↩</a></li>
<li id="fn38"><a href="#fnref38">↩</a></li>
<li id="fn39"><a href="#fnref39">↩</a></li>
<li id="fn40"><a href="#fnref40">↩</a></li>
<li id="fn41"><a href="#fnref41">↩</a></li>
<li id="fn42"><a href="#fnref42">↩</a></li>
</ol>
</section>
</body>
</html>
