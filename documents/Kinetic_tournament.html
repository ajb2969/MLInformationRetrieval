<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="169">Kinetic tournament</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Kinetic tournament</h1>
<hr/>

<p> A <strong>Kinetic Tournament</strong> is a <a href="kinetic_data_structure" title="wikilink">kinetic data structure</a> that functions as a <a href="priority_queue" title="wikilink">priority queue</a> for elements whose priorities change as a continuous function of time. It is implemented analogously to a "tournament" between elements to determine the "winner" (maximum or minimum element), with the <a href="Kinetic_data_structure#Certificates_Approach" title="wikilink">certificates</a> enforcing the winner of each "match" in the tournament. It supports the usual priority queue operations - <em>insert</em>, <em>delete</em> and <em>find-max</em>. They are often used as components of other kinetic data structures, such as <a href="kinetic_closest_pair" title="wikilink">kinetic closest pair</a>.</p>
<h2 id="implementation">Implementation</h2>

<p>A kinetic tournament is organized in a <a href="binary_tree" title="wikilink">binary tree</a>-like structure, where the leaves contain the elements, and each <a href="internal_node" title="wikilink">internal node</a> contains the larger (or smaller) of the elements in its <a href="child_nodes" title="wikilink">child nodes</a>. Thus, the <a href="Tree_(data_structure)" title="wikilink">root</a> of the tree contains the maximum (or minimum) element at a given time. The validity of the structure is enforced by creating a certificate at each node, which asserts that the element in the node is the larger of the two children. When this certificate fails, the element at the node is changed (to be the element in the other child), and a new certificate representing the new invariant is created. If the element this node was a winner at its <a href="parent_node" title="wikilink">parent node</a>, then the element and certificates at the parent must be recursively updated too.</p>
<h2 id="analysis">Analysis</h2>

<p>This is a O(<em>n</em>) space, responsive, local, compact and efficient data-structure.</p>
<ul>
<li><strong><a href="Kinetic_data_structure#Performance" title="wikilink">Responsiveness</a>:</strong> A certificate failure will cause the creation of a new certificate to replace the old one, which must be put into the <a href="Kinetic_data_structure#Certificates_Approach" title="wikilink">event queue</a>. It may also trigger changes to the O(log<em>n</em>) certificates at its parent nodes. Each certificate change requires a delete and insert operation in the priority queue of events. Each of these takes O(log <em>n</em>) time, so the responsiveness, the total time required to process an certificate failure, is 

<math display="inline" id="Kinetic_tournament:0">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>lg</mi>
      <mn>2</mn>
     </msup>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>lg</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\lg^{2}n)
  </annotation>
 </semantics>
</math>

. While this is considered responsive in general, it is less responsive than other kinetic priority queues such as <a href="kinetic_heap" title="wikilink">kinetic heaps</a> which respond to certificate failures with O(1) certificate changes.</li>
<li><strong><a href="Kinetic_data_structure#Performance" title="wikilink">Locality</a>:</strong> Each element is involved in O(log<em>n</em>) certificates (for example, the maximal element is involved in a certificate at each of its parents all the way up to the root node). Again, while this is considered local, a <a href="kinetic_heap" title="wikilink">kinetic heap</a> is much more local.</li>
<li><strong><a href="Kinetic_data_structure#Performance" title="wikilink">Compactness</a>:</strong> This is a very compact structure, containing O(<em>n</em>) certificates - exactly one for every edge in the tree.</li>
<li><strong><a href="Kinetic_data_structure#Performance" title="wikilink">Efficiency</a>:</strong> Kinetic heaps are very efficient, with the number of <a href="Kinetic_data_structure#Certificates_Approach" title="wikilink">internal events</a> (certificate changes) being only a factor of O(log <em>n</em>) more than the number of <a href="Kinetic_data_structure#Certificates_Approach" title="wikilink">external events</a>. Specifically, for a collection of space-time trajectories where each pair intersects at most <mtpl></mtpl> times, the kinetic tournament processes <mtpl></mtpl> events in <mtpl></mtpl> time, where <mtpl></mtpl> is a <a href="Davenport-Schinzel_sequence" title="wikilink">Davenport-Schinzel sequence</a>. Additionally, insertions and deletions cause O(log<em>n</em>) certificate changes each. Each certificate change takes O(log<em>n</em>) time, which is determined by the time required to execute the event queue update.</li>
</ul>
<h2 id="references">References</h2>

<p>Basch, J. 1999. Kinetic data structures. Ph.D. thesis, Dept. Computer Science, Stanford University. [<a class="uri" href="http://citeseer.ist.psu.edu/viewdoc/download?doi=10.1.1.41.2301&amp;rep">http://citeseer.ist.psu.edu/viewdoc/download?doi=10.1.1.41.2301&amp;rep;</a>;=rep1&amp;type;=pdf]</p>

<p>"</p>

<p><a href="Category:Articles_created_via_the_Article_Wizard" title="wikilink">Category:Articles created via the Article Wizard</a> <a href="Category:Kinetic_data_structures" title="wikilink">Category:Kinetic data structures</a></p>
</body>
</html>
